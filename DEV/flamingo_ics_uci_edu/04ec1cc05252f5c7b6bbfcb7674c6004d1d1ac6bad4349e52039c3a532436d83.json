{"url": "http://flamingo.ics.uci.edu/releases/1.0/src/filtertree/filtertree.cc", "content": "/* \n$Id$\n\nCopyright (C) 2007 by The Regents of the University of California\n\nRedistribution of this file is permitted under\nthe terms of the *GNU* Public License (*GPL*) \t\n\nDate: 04/08/2007\nAuthor: Yiming Lu <yimingl@ics.uci.edu>\n*/\n\n#include <sys/types.h>\n#include <time.h>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include \"filtertree.h\"\n#include \"../util/ed.h\"\nusing std::setw;\n\nFilterTree::FilterTree(unsigned q, \n\t\t\t\t\t   const vector<string> *data, \n\t\t\t\t\t   EDFunction f):\n                       leftSign('#'),\n                       rightSign('$'), \n\t\t\t\t\t   q(q), \n\t\t\t\t\t   function(f),\n\t\t\t\t\t   data(data) \t\t\t\t\t    \t\t\t\t\t \n{\n    this->headBuckets = new Buckets();\n    //for analysis\n    totalTime = 0;\n    candidateNo = 0;\n    shortCandidateNo = 0;\n    patternNo = 0;\n    resultNo = 0;\n    queryNo = 0;\n    shortQueryNo = 0;\n}\n\nFilterTree::FilterTree(const vector<string> *data,\n                       const string& indexFile):\n                       leftSign('#'),\n                       rightSign('$'),  \t\t\t\t\t  \n\t\t\t\t\t   data(data)\n{\n    this->headBuckets = new Buckets();\t\t\t\n    loadIndex(indexFile);\n    //for analysis\n    totalTime = 0;   \t      \n    candidateNo = 0;\n    shortCandidateNo = 0;\n    patternNo = 0;\n    resultNo = 0;\n    queryNo = 0;\n    shortQueryNo = 0;\n}\n\nFilterTree::~FilterTree()\n{\n    for(unsigned i = 0; i < data->size(); i++)\n    {\n        delete countTables[i];\n    }\n    delete[] countTables;\n    delete headBuckets;\t\t\n}\n\nvoid FilterTree::build()\n{\n    buildBuckets();\t\t\n    this->countTables = new CountTable*[data->size()];\n    for(unsigned i = 0; i < data->size(); i++)\n    {\n        countTables[i] = new CountTable();\n    }\t\t\t\n}\n\nvoid FilterTree::saveIndex(const string &indexFile) const\n{\n    //open Index file\n    ofstream ofs ( indexFile.c_str() );\n    //output q value\n    ofs << q;\n    ofs << \" \";\n    //output function value\n    ofs << (unsigned)function;\n    ofs << \" \";\n    //output headBuckets\n    ofs << (*headBuckets);\n    ofs.close();\n}\n\nvoid FilterTree::loadIndex(const string &indexFile)\n{\n    //load the value of q & function\n    ifstream ifs ( indexFile.c_str(),  ifstream::in );\n    ifs >> q;\n    unsigned func;\n    ifs >> func;\n    function = (EDFunction)func;\n    //initiate the countTable\n    this->countTables = new CountTable*[data->size()];\n    for(unsigned i = 0; i < data->size(); i++)\n    {\n        countTables[i] = new CountTable();\n    }\n    //load the headBuckets\n    ifs >> (*headBuckets);\n    ifs.close();\t\n}\n\nvoid FilterTree::search(const string &query,\n                        const unsigned editdist,\n                        vector<unsigned> &results)\n{\n    string temp;\n    double startTime, endTime;\n    double diffTime;\n    \n    startTime = clock();\n    getApproximateMatch(query, patternNo++, editdist, results);\n    endTime = clock();\n    diffTime = static_cast<double>(endTime - startTime)/CLOCKS_PER_SEC;\n    totalTime += diffTime;\n}\n\nvoid FilterTree::buildBuckets()\n{\n    unsigned i,j;\n    unsigned idSize = data->size();\n    \n    for ( i=0; i< idSize; i++ ) \n    {\n        vector<string> grams;\n        str2grams( (*data)[i], grams, q, leftSign, rightSign );\n        if (grams.size() > 0) \n        {\n            for(j=0; j< grams.size(); j++)\n            {\t\t\t\t\n\t\t    /*insert gram in the grams[j] corresponding \n\t\t     *to the string data[i] into hash table\n\t\t     */\n\t\t    this->headBuckets->addToHashTable(grams[j].c_str(), \n\t\t\t\t                              i, \n\t\t\t\t                              j, \n\t\t\t\t                              (*data)[i].size());\n            }\n        }\n    }\t\n}\n\n\nvoid FilterTree::getApproximateMatch(const string &targetWord, \n\t\t\t\t\t\t\t\t\t unsigned patternId, \n\t\t\t\t\t\t\t\t\t unsigned edThreshold, \n\t\t\t\t\t\t\t\t\t vector<unsigned>& results)\n{\n\tunsigned commonGramsNo;\n    unsigned j;\n    LengthBucket *lengthBucket;\n    vector<unsigned>* positions = new vector<unsigned>();\n    vector<LengthBucket *> *lengthBuckets = new vector<LengthBucket *>();    \n\t\n    if(this-> function == standardFunction)\n    {\n        commonGramsNo = edThreshold * q - q + 1;\n    }\n    else\n    {\n\t    commonGramsNo = edThreshold * (q+1) - q +1;\n    }\n    vector<string> grams;\n    str2grams(targetWord, grams, q, leftSign, rightSign);                \n    \n    for( j = 0; j < grams.size(); j++ ) \n    {\n        lengthBucket = headBuckets->getMatchedBuckets(grams[j].c_str());\n        if( (lengthBucket != NULL)\n            && (lengthBucket->isEmpty() == false) ) \n        {\n            lengthBuckets->push_back(lengthBucket);\n            positions->push_back(j);\n        }\n    }\n\t//If the query is not short query, then call mergeSort\n    if ( targetWord.length() > commonGramsNo  )\n    {\n\t    mergeSort(targetWord,\n\t              patternId,\n\t              positions,\n\t              edThreshold,\n\t              lengthBuckets,\n\t              results);\n\t    queryNo++;\n    }\n    //If the query is short query, then call processShortStrings\n    else\n    {\n        processShortStrings(targetWord,\n                            patternId,\n                            positions,\n                            edThreshold,\n                            lengthBuckets,\n                            results);\n        shortQueryNo++;\n    }\n    \n    delete positions;\n    delete lengthBuckets;\t\n}\n\nvoid FilterTree::processShortStrings(const string &targetWord,\n                                     unsigned patternId,\n                                     const vector<unsigned> *positions,\n                                     unsigned edThreshold,\n                                     const vector<LengthBucket *> *lengthBuckets,\n                                     vector<unsigned>& results)\n{\n    unsigned i;\n    unsigned distance;\n    unsigned sourceLength;\n    unsigned targetLength;\n    unsigned sourcePosition;  // the position corresponding to \"sourceId\"\n    unsigned targetPosition;  // the position corresponding to \"targetWord\"\n    unsigned commonGramsNo;\n    const string *sourceWord;\n    signed differentLength;\n    \n    \n    if(this-> function == standardFunction)\n    {\n        commonGramsNo = edThreshold * q - q + 1;\n    }\n    else\n    {\n\t    commonGramsNo = edThreshold * (q+1) - q +1;\n    } \n    \n    targetLength = targetWord.length();\n    for ( i = 0; i < data->size(); i++ )\n    {\n        sourceWord = &((*data)[i]);\n        sourceLength = sourceWord->length();\n        differentLength = (signed)sourceLength - (signed)targetLength;\n        \n        if ( (sourceLength <= commonGramsNo) &&\n             ((differentLength) <= (signed)edThreshold) &&\n             ((- differentLength) <= (signed)edThreshold) )\n        {\n            shortCandidateNo ++ ;\n            if(this-> function == standardFunction)\n            {\n                distance = ed( (*sourceWord), targetWord );\n            }\n            else\n            {\n                distance = edSwap( (*sourceWord), targetWord );\n            }\n            \n            if ( distance <= edThreshold )\n            {\n                resultNo ++ ;\n                results.push_back( i );\n            }\n        }  // end if\n    }  // end for \t\n    \n    unsigned count = 0;\n    unsigned sourceId; // ID of strings in the dataset (dictionary)\t\n    unsigned j,k;\n    LengthBucket *lengthBucket;\n    \n    for (j=0; j< lengthBuckets->size(); j++) \n    {\n        //traverse in gram level\n        lengthBucket = lengthBuckets->at(j);\n        targetPosition = positions->at(j);\n        \n        signed lowBoundLen   =(signed)targetLength\n                             -(signed)edThreshold;\n        signed upperBoundLen =(signed)targetLength\n                             +(signed)edThreshold;\n        signed lowBoundPos   =(signed)targetPosition\n                             -(signed)edThreshold;\n        signed upperBoundPos =(signed)targetPosition\n                             +(signed)edThreshold;\n        unsigned numOfGroups = lengthBucket->getSize();\n        for(i = 0; i < numOfGroups; i++)\n        {\n            //traverse in length level\n            sourceLength = (lengthBucket->getGroups())[i]->getLength();\n            if( (signed)sourceLength > (signed)commonGramsNo \n            && (signed)sourceLength >= lowBoundLen \n            && (signed)sourceLength <= upperBoundLen )\n            {\n                StringPosition** strPos = \n                (lengthBucket->getGroups())[i]->getPositions();\n                unsigned numOfPositions = \n                (lengthBucket->getGroups())[i]->getSize();\n                for(unsigned index = 0; index < numOfPositions; index++)\n                {\n                    //traverse in position level\n                    sourcePosition = strPos[index]->getPosition();\n                    if( (signed)sourcePosition >= lowBoundPos \n                    && (signed)sourcePosition <= upperBoundPos )\n                    {\n                        unsigned numOfStrs = strPos[index]->getSize();\n                        for( k = 0; k < numOfStrs; k++)\n                        {\n                            sourceId = (strPos[index]->getStrIDs())[k];\n                            sourceWord = &(data->at(sourceId));\n                            count = (countTables[sourceId])->getCount(patternId);\n                            if ( (count != (countTables[sourceId])->getMaxCount())\n                            && ((sourceLength > commonGramsNo)||\n                            (targetLength > commonGramsNo)) )\n                            {\n                                count =\n                                (countTables[sourceId])->addCount(patternId);\n                                if(((signed)count\n                                >= ((signed)sourceLength - (signed)commonGramsNo))\n                                &&\n                                ((signed)count\n                                >= ((signed)targetLength - (signed)commonGramsNo))) \n                                {\n                                    shortCandidateNo ++ ;\n                                    if(this-> function == standardFunction)\n                                        distance = ed((*sourceWord), targetWord);\n                                    else\n                                        distance = edSwap((*sourceWord), targetWord);\n                                    //If it is already candidate, then set the count to MAXCOUNT\n                                    (countTables[sourceId])->resetCount(patternId);\n                                    if (distance <= (unsigned)edThreshold) \n                                    {\n                                        resultNo ++ ;\n                                        results.push_back(sourceId);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    //Skip the rest nodes in position level\n                    else if ((signed)sourcePosition > upperBoundPos)\n                    {\n                        break;\n                    }\n                }\n            }\n            //Skip the rest nodes in length level\n            else if((signed)sourceLength > upperBoundLen)\n            {\n                break;\n            }\n        }\n    }\t\n }\n \nvoid FilterTree::mergeSort(const string & targetWord,\n                           unsigned patternId,\n                           const vector<unsigned> *positions,\n                           unsigned edThreshold,\n                           const vector<LengthBucket *> *lengthBuckets,\n                           vector<unsigned>& results)\n{\n    unsigned count = 0;\n    unsigned distance;      \n    unsigned sourceId;        // ID of strings in the dataset (dictionary)\n    unsigned sourcePosition;  // the position corresponding to \"sourceId\"\n    unsigned targetPosition;  // the position corresponding to \"targetPattern\"\n    unsigned targetLength;    // the length of the pattern\n    unsigned sourceLength;    // the length of a string in the dataset\n    const string   *sourceWord;\t  // a string in the dataset (dictionary)\t\n    unsigned commonGramsNo;\n    \n    if(this-> function == standardFunction)\n        commonGramsNo = edThreshold * q - q + 1;\n    else\n        commonGramsNo = edThreshold * (q+1) - q +1; \n    \n    unsigned i,j,k;\n    LengthBucket *lengthBucket;\n    targetLength = targetWord.length();  \t\n\t\n    for (j=0; j< lengthBuckets->size(); j++) {\n        //traverse in gram level\n        lengthBucket = lengthBuckets->at(j);\n        targetPosition = positions->at(j);\n       \n\t    signed lowBoundLen = (signed)targetLength - (signed)edThreshold;\n\t    signed upperBoundLen = (signed)targetLength + (signed)edThreshold;\n\t    \n\t    signed lowBoundPos = (signed)targetPosition - (signed)edThreshold;\n\t    signed upperBoundPos = (signed)targetPosition + (signed)edThreshold;\n\t    \n\t    unsigned numOfGroups = lengthBucket->getSize();\n\t    for(i = 0; i < numOfGroups; i++)\n\t    {\n\t        //traverse in length level\n\t        sourceLength = (lengthBucket->getGroups())[i]->getLength();\n\t        if( (signed)sourceLength >= lowBoundLen \n\t        && (signed)sourceLength <= upperBoundLen )\n\t        {\n\t            StringPosition** strPos =\n\t            (lengthBucket->getGroups())[i]->getPositions();\n\t            unsigned numOfPositions =\n\t            (lengthBucket->getGroups())[i]->getSize();\n\t            for(unsigned index = 0; index < numOfPositions; index++)\n\t            {\n\t                //traverse in position level\n\t                sourcePosition = strPos[index]->getPosition();\n\t                if((signed)sourcePosition >= lowBoundPos \n\t                && (signed)sourcePosition <= upperBoundPos )\n\t                {\n\t                    unsigned numOfStrs = strPos[index]->getSize();\n\t                    for( k = 0; k < numOfStrs; k++)\n\t                    {\n\t                        sourceId = (strPos[index]->getStrIDs())[k];\n\t                        sourceWord = &(data->at(sourceId));\n\t                        count = (countTables[sourceId])->getCount(patternId);\n\t                        \n\t                        if ( (count != (countTables[sourceId])->getMaxCount())\n\t                        && ((sourceLength > commonGramsNo) ||\n\t                        (targetLength > commonGramsNo)))\n\t                        {\n\t                            count = (countTables[sourceId])->addCount(patternId);\n\t                            if (((signed)count\n\t                            >= ((signed)sourceLength - (signed)commonGramsNo))\n\t                            &&\n\t                            ((signed)count\n\t                            >= ((signed)targetLength - (signed)commonGramsNo))) \n\t                            {\n\t                                candidateNo ++ ;\n\t                                if(this-> function == standardFunction)\n\t                                    distance = ed((*sourceWord), targetWord);\n\t                                else\n\t                                    distance = edSwap((*sourceWord), targetWord);\n\t                                //If it is already candidate, then set the count to MAXCOUNT\n\t                                (countTables[sourceId])->resetCount(patternId);\n\t                                \n\t                                if (distance <= (unsigned)edThreshold) {\n\t                                \tresultNo ++ ;\n\t                                \tresults.push_back(sourceId);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                //Skip the rest nodes in position level\n\t                else if ((signed)sourcePosition > upperBoundPos)\n\t                {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        //Skip the rest nodes in length level\n\t        else if((signed)sourceLength > upperBoundLen)\n\t        {\n\t            break;\n\t        }\n\t    }\n    }\t\n}\n \nvoid FilterTree::reportAnalyses()\n{\n    cout<< \"\\n==============================================================\" << endl;\n    cout<< \"= Number of strings in workload = \" << patternNo  << endl;\n    cout<< \"= Total CPU time for approximate string processing = \" << totalTime << \" s\" << endl;\n    cout<< \"= Total Number of candidates for long strings: \" << (unsigned)candidateNo << endl;\n    cout<< \"= Total Number of candidates for short strings: \" << (unsigned)shortCandidateNo << endl;\n    cout<< \"= Total Number of long queries: \" << (unsigned)queryNo << endl;\n    cout<< \"= Total Number of short queries: \" << (unsigned)shortQueryNo << endl;\n    cout<< \"= Total Number of results: \" << (double)resultNo << endl;\n    cout<< \"= Total Memory: \" << headBuckets->getMemory() <<endl;\n    cout<< \"==============================================================\" << endl;\n}\n", "encoding": "ascii"}