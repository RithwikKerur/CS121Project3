{"url": "http://flamingo.ics.uci.edu/releases/1.0/docs/wiki/FilterTreeDoc.html", "content": "<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:html=\"http://www.w3.org/1999/xhtml\">\n<head>\n<title>FilterTreeDoc - Group Page - Trac</title>\n<style type=\"text/css\">\n           @import url(trac.css);\n          </style>\n</head>\n<body>\n<div class=\"wikipage\">\n    <div id=\"searchable\">\n<p>\nAppString &gt; AppStringDoc\n</p>\n<h1 id=\"Filtertree\">Filtertree</h1>\n<h2 id=\"Overview\">Overview</h2>\n<p>\nMany applications need to answer approximate string queries efficiently. The following are a few examples:\n</p>\n<ul>\n<li>The \"Did you mean\" feature by many search engines partially relies on finding words similar to a given keyword. \n</li>\n<li>Spellchecking: suggest good words for a possibly mistyped word. \n</li>\n<li>Record linkage: identify records that could represent the same real-world entity. \n</li>\n</ul>\n<p>\nFiltertree is an indexing tree structure to support approximate string search efficiently. In particular, it can be used to answer such queries: Given a collection of strings and a single string, how to find those strings in the collection that are \"similar to\" the given string? There are various string similarity functions. This structure mainly deals with edit distance. Its main idea is to use a tree structure, where each node or level   * corresponds to a filter. In particular: \n</p>\n<ul>\n<li>It can take various filters.\n</li>\n<li>The nodes at each level could use different filters, depending on the data distribution. Different paths on the tree could even use different sequences of filters. \n</li>\n<li>The tree might not be balanced. The length of each path depends on the data distribution.\n</li>\n</ul>\n<p>\nAs a proof of concept, in the current implementation, we used three filters: length filter, position filter, count filter [1] [2] [3].\n</p>\n<ol>\n<li>Length filter: if two strings S1 and S2 are within edit distance K, their length difference should be at most K.\n</li>\n<li>Position filter: if two strings S1 and S2 are within edit distance K, we can ignore their q-grams that are more than k positions away.\n</li>\n<li>Count filter: if two string S1 and S2 are within edit distance K, they must share enough number common q-grams. \n</li>\n</ol>\n<p>\nBy using these filters, a filtertree could look like: \n</p>\n<p>\n<img src=\"filtertree.jpg\" alt=\"Filtertree\" title=\"Filtertree\"/>\n</p>\n<p>\nNotice that in general the tree structure can be more heterogeneous in terms of the depth of different paths and the types of filters in the nodes.\n</p>\n<h2 id=\"Files\">Files</h2>\n<ul>\n<li>\n<strong>gram.h/gram.cc</strong>: They define the 3 types of nodes of Filtertree, including StringPosition? (position level), GroupStringPosition? (length level), and LengthBucket? (gram level).\n</li>\n<li>\n<strong>buckethead.h/buckethead.cc</strong>: Class Buckets provide the hash function for quickly searching the grams in Filtertree.\n</li>\n<li>\n<strong>filtertree.h/filtertree.cc</strong>: They provide the basic functions for Filtertree. There are two kinds of constructors: one requires the user to set the q value explicitly, and it will build the index; the other one doesn&rsquo;t require the q value, and it will load the index from a file. \n</li>\n<li>\n<strong>unittest.cc</strong>: a test example file that shows two usages, one is to build the index first, and then do the approximate search queries; the other one is to load the index from an external file, and then do approximate search queries.\n</li>\n<li>\n<strong>perftest.cc</strong>: It uses 200 queries and a dataset with 54K strings to test the performance of Filtertree, including the running time and memory requirement. \n</li>\n</ul>\n<h2 id=\"PerformanceResults\">Performance Results</h2>\n<ul>\n<li>Platform: Pentium D 3.4GHz Dual Core, 2GB memory, Linux (Ubuntu), g++.\n</li>\n<li>Dataset: 54K person names.\n</li>\n<li>Queries: 200 queries, and we computed the average performance.\n</li>\n</ul>\n<table class=\"wiki\">\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> Ed threshold </td>\n<td rowspan=\"1\" colspan=\"1\"> Q </td>\n<td rowspan=\"1\" colspan=\"1\"> Time (ms) </td>\n<td rowspan=\"1\" colspan=\"1\"> Index size (MB) \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 1 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1 </td>\n<td rowspan=\"1\" colspan=\"1\">  1.30 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1.45 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 2 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1 </td>\n<td rowspan=\"1\" colspan=\"1\"> 4.05 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1.45 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 3 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1 </td>\n<td rowspan=\"1\" colspan=\"1\"> 14.10 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1.45 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 1 </td>\n<td rowspan=\"1\" colspan=\"1\"> 2 </td>\n<td rowspan=\"1\" colspan=\"1\"> 0.30 </td>\n<td rowspan=\"1\" colspan=\"1\"> 2.16 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 2 </td>\n<td rowspan=\"1\" colspan=\"1\"> 2 </td>\n<td rowspan=\"1\" colspan=\"1\"> 0.80 </td>\n<td rowspan=\"1\" colspan=\"1\"> 2.16 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 3 </td>\n<td rowspan=\"1\" colspan=\"1\"> 2 </td>\n<td rowspan=\"1\" colspan=\"1\"> 5.05 </td>\n<td rowspan=\"1\" colspan=\"1\"> 2.16 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 1 </td>\n<td rowspan=\"1\" colspan=\"1\"> 3 </td>\n<td rowspan=\"1\" colspan=\"1\"> 0.25 </td>\n<td rowspan=\"1\" colspan=\"1\"> 4.36 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 2 </td>\n<td rowspan=\"1\" colspan=\"1\"> 3 </td>\n<td rowspan=\"1\" colspan=\"1\"> 1.08 </td>\n<td rowspan=\"1\" colspan=\"1\"> 4.36 \n</td>\n</tr>\n<tr>\n<td rowspan=\"1\" colspan=\"1\"> 3 </td>\n<td rowspan=\"1\" colspan=\"1\"> 3 </td>\n<td rowspan=\"1\" colspan=\"1\"> 13.30 </td>\n<td rowspan=\"1\" colspan=\"1\"> 4.36 \n</td>\n</tr>\n</table>\n<hr/>\n<p>\n[1] E. Sutinen and J. Tarhio. Filtration with q-Samples in Approximate String Matching. In CPM, 1996.<br/>\n[2] E. Sutinen and J. Tarhio. On Using q-Grams Locations in Approximate String Matching. In ESA, pages 327&ndash;340, 1995.<br/>\n[3] Luis Gravano, Panagiotis G. Ipeirotis, H. V. Jagadish, Nick Koudas, S. Muthukrishnan, Divesh Srivastava, Approximate String Joins in a Database (Almost) for Free. VLDB 2001, pages 491-500.\n</p>\n</div>\n   </div>\n<div class=\"footer\">\n<hr/>\n<p>\n<a href=\"wiki-index.html\">Back to Index</a>\n</p>\n</div>\n</body>\n</html>\n", "encoding": "ascii"}