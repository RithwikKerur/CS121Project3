{"url": "http://flamingo.ics.uci.edu/releases/2.0.1/src/listmerger/utilities.cc", "content": "/*  \n    $Id: utilities.cc 4025 2008-10-01 00:01:14Z abehm $ \n\n    Copyright (C) 2007 by The Regents of the University of California\n \t\n    Redistribution of this file is permitted under the terms of the BSD license\n\n    Author: Jiaheng Lu \n    Date: 05/11/2007\n\n*/\n\n#include \"utilities.h\"\n\n#include <sys/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <functional>\n#include <iterator>\n#include <list>\n#include <algorithm>\n#include <cassert>\n\n#include \"heap.h\"\n#include \"showutil.h\"\n\t\nusing namespace std;\n\ntypedef set<unsigned,less<unsigned> >  UnsignedSet;\n\n\nunsigned  getTotalLogSize(const vector<Array<unsigned>*> &lists)\n{\n  unsigned totalSize = 0;\n\n  unsigned numberOfLists = lists.size();\n\n  for(unsigned i=0;i< numberOfLists;i++)\n       totalSize +=(unsigned)ceil(log(lists.at(i)->size()));\n   \n  return  totalSize;\n  \n\n}//end getTotalSize\n\n\nunsigned  getTotalSize(const vector<Array<unsigned>*> &lists)\n{\n  unsigned totalSize = 0;\n\n  unsigned numberOfLists = lists.size();\n\n  \n  for(unsigned i=0;i< numberOfLists;i++)\n    {  \n      totalSize +=lists.at(i)->size();\n      // cout <<\"i is \" << i <<\n      //\" size is \"<< lists.at(i)->size() <<endl;\n    }//end for\n  return  totalSize;\n  \n\n}//end getTotalSize              \n\n/*\n  This function is for the test of \n  consistent of two different merge\n  algorithms.\n\n  The order of results does not matter.\n\n*/\n\nbool testConsistent(const vector<unsigned> &result1,\n\t\t    const vector<unsigned> &result2)\n{\n  if (result1.size() != result2.size())\n    return false;\n  \n  UnsignedSet s1 (result1.begin(),result1.end());\n  UnsignedSet s2 (result2.begin(),result2.end());\n\n  UnsignedSet::iterator ite1 = s1.begin();\n  UnsignedSet::iterator ite2 = s2.begin();\n\n  while (ite1!= s1.end() )\n    {\n      if (*ite1 != *ite2)\n\treturn false;\n\n      ite1++;\n      ite2++;\n\n    }//end while\n\n  return true;\n  \n}// end testConsistent\n\n\nbool binarySearch(Array<unsigned> *v,\n\t\t  unsigned value,\n\t\t  unsigned start,\n\t\t  unsigned end)\n{\n  int low = start;\n  int high = end - 1;\n  int middle = (low+high+1)/2;\n\n  bool found = false;\n  \n  do\n    {\n      if (value == v->at(middle))\n\treturn true;\n      else if ( value < v->at(middle))\n\thigh = middle - 1;\n      else\n\tlow = middle + 1;\n\n      middle = (low+high+1)/2;\n\n    } while ((low <=high) &&\n\t     (found == false)\n\t     );\n\n  return found;\n\n}//end binarySearch\n\n/*\n  Get statics data frbom running\n\n*/\n\nvoid  getStatistics(const vector<Array<unsigned>*> &arrays,\n\t\t    unsigned threshold,\n\t\t    unsigned longListsSize,\n\t\t    const vector<unsigned> &partialResults,\n\t\t    const vector<unsigned> &results)\n{\n  cout<<\"~~~~~~~~~~~~~~\"<<endl;\n  cout << \"Partial results size is \" << partialResults.size() << endl;\n  cout << \"Final results size is \" << results.size() << endl;\n  cout << \"Threshold is \"<<threshold<<\"; Long lists size is \"<<longListsSize <<endl;\n  cout << \"# of lists is \" <<arrays.size() << endl;\n  cout<<\"**************\"<<endl;\n\n}//end getStatistics\n\n\n/*\n\nThis function is for DividedSkip algorithm\nSeperate to long and short lists sets.\nFor short lists, use binarySearch;\nFor long lists, use hash to search.\n\n*/\n\n\nvoid  splitTwoSets(vector<Array<unsigned>*> *longLists,\n\t\t   vector<Array<unsigned>*> *shortLists,\n\t\t   const unsigned threshold,\n\t\t   const vector<Array<unsigned>*> &originalLists,\n\t\t   unsigned sortedIndex[],\n\t\t   unsigned longListsSize)\n{\n\n  unsigned originalListSize =  originalLists.size();\n\n  for(unsigned i=0;i<originalListSize;i++)\n    {\n      if (i<longListsSize)\n\tlongLists->push_back(originalLists.at(sortedIndex[originalListSize-i-1]));\n      else\n\tshortLists->push_back(originalLists.at(sortedIndex[originalListSize-i-1]));\n      \n    }//end for\n\n}//end splitTwoSets\n\n\nvoid  splitTwoSizeSets(vector<unsigned> *longLists,\n\t\t       vector<unsigned> *shortLists,\n\t\t       const unsigned threshold,\n\t\t       const vector<unsigned> &originalLists,\n\t\t       unsigned sortedIndex[],\n\t\t       unsigned longListsSize)\n{\n\n  unsigned originalListSize =  originalLists.size();\n\n  for(unsigned i=0;i<originalListSize;i++)\n    {\n      if (i<longListsSize)\n\tlongLists->push_back(originalLists.at(sortedIndex[originalListSize-i-1]));\n      else\n\tshortLists->push_back(originalLists.at(sortedIndex[originalListSize-i-1]));\n      \n    }//end for\n\n}//end splitTwoSets\n\n\n\nvoid  splitTwoSetsWithDuplicates(vector<Array<unsigned>*> &longLists,\n\t\t\t\t vector<Array<unsigned>*> &shortLists,\n\t\t\t\t vector<unsigned> &longListsWeights,\n\t\t\t\t vector<unsigned> &shortListsWeights,\n\t\t\t\t const vector<Array<unsigned>*> &originalLists,\n\t\t\t\t const vector<unsigned> &originalWeights,\n\t\t\t\t const unsigned shortListsSize)\n{\n\n  unsigned originalListSize = originalLists.size();\n\n  for(unsigned i=0;i<originalListSize;i++)\n    {\n      if (i<shortListsSize) {\n\tshortLists.push_back(originalLists.at(i));\n\tshortListsWeights.push_back(originalWeights.at(i));\n      }\n      else {\n\tlongLists.push_back(originalLists.at(i));\n\tlongListsWeights.push_back(originalWeights.at(i));\n      }\n    }//end for\n\n  // ORIGINAL CODE BELOW BY JIAHENG\n  // FIXED BY ALEX (ABOVE CODE)\n  /*\n  unsigned originalListSize =  originalLists.size();\n  \n  unsigned currentWeight = 0;\n\n  unsigned i = 0;\n  \n  while ((currentWeight+originalWeights.at(i)) < shortListsSize )\n    {\n      currentWeight += originalWeights.at(i);\n      shortLists.push_back(originalLists.at(i));\n      shortListsWeights.push_back(originalWeights.at(i));\n      i++;\n    }//end for\n\n  shortLists.push_back(originalLists.at(i));\n  shortListsWeights.push_back(shortListsSize-currentWeight);\n  \n  unsigned listSizeforLonger =\n    currentWeight+originalWeights.at(i)-shortListsSize;\n  \n  if ( listSizeforLonger >0)\n    {\n      longLists.push_back(originalLists.at(i));\n      longListsWeights.push_back(listSizeforLonger);  \n    }\n\n  i++;\n\n  for(; i<originalListSize;i++)\n    {\n      longLists.push_back(originalLists.at(i));\n      longListsWeights.push_back(originalWeights.at(i));  \n    }//end for\n\n  */\n\n}//end  splitTwoSetsWithDuplicates\n\n/*\n\nThis function is for MergeOpt algorithm\nSeperate to long and short lists sets.\n\n*/\n\nvoid separateTwoSets(vector<Array<unsigned>*> *longLists,\n\t\t     vector<Array<unsigned>*> *shortLists,\n\t\t     const unsigned threshold,\n\t\t     const vector<Array<unsigned>*> &originalLists,\n\t\t     unsigned sortedIndex[])\n{\n  unsigned originalListSize =  originalLists.size();\n\n  for(unsigned i=0;i<originalListSize;i++)\n    {\n      if (i<threshold-1)\n\tlongLists->push_back(originalLists.at(sortedIndex[originalListSize-i-1]));\n      else\n\tshortLists->push_back(originalLists.at(sortedIndex[originalListSize-i-1]));\n      \n    }//end for\n\n}//end separateTwoSets\n\n\n\n\n/*\n  Use binray search to search the value\n  in search set of lists;\n  change the count \n*/\n\nvoid  binarySearchSet(unsigned &count,\n\t\t      vector<Array<unsigned>* > *lists,\n\t\t      unsigned data)\n{\n  vector<Array<unsigned>*>::iterator ite =\n    lists->begin();\n\n  while(ite != lists->end())\n      {\n\tArray<unsigned> *v = *ite;\n\tif (binarySearch(v,data,0,v->size()))\n\t  count++;\n\tite++;\n      }//end while\n\n}//end binarySearchSet\n\nvoid sortBySize(const vector<unsigned> &allLists,\n\t\tunsigned sortedIndex [] )\n{\n  vector<unsigned>::const_iterator ite = allLists.begin();\n  \n  unsigned sizeHeap[allLists.size()]; \n  unsigned indexHeap[allLists.size()];\n\n  unsigned index = 0;\n\n  unsigned heapSize = 0;\n\n  while (ite != allLists.end())\n    {\n      unsigned sizeOfList = *ite;\n\n      heapInsert(sizeOfList,index++,sizeHeap,indexHeap,heapSize);\n    \n      ite++;\n\n    }//end while\n\n  index = 0;\n\n  while (heapSize > 0)\n    {\n      sortedIndex[index++] = indexHeap[0];\n      heapDelete(sizeHeap,indexHeap,heapSize);\n    }//end while\n\n}//end sortInvertedList\n\n\n\n/*\n  Sort the inverted list with increasing order\n  according to the their sizes\n  by heapSort\n\n  This function is used in MergeOpt.\n\n*/\n\n\nvoid sortBySizeOfLists(const vector<Array<unsigned>*> &allLists,\n\t\t       unsigned sortedIndex [] )\n{\n  vector<Array<unsigned>*>::const_iterator ite = allLists.begin();\n  \n  unsigned sizeHeap[allLists.size()]; \n  unsigned indexHeap[allLists.size()];\n\n  unsigned index = 0;\n\n  unsigned heapSize = 0;\n\n  while (ite != allLists.end())\n    {\n      unsigned sizeOfList = (*ite)->size();\n\n      heapInsert(sizeOfList,index++,sizeHeap,indexHeap,heapSize);\n    \n      ite++;\n\n    }//end while\n\n  index = 0;\n\n  while (heapSize > 0)\n    {\n      sortedIndex[index++] = indexHeap[0];\n      heapDelete(sizeHeap,indexHeap,heapSize);\n    }//end while\n\n}//end sortInvertedList\n\n\n/* Insert items to heap\n   This function is used in binarySearchMerger\n*/\n\nvoid  insertToHeaps(unsigned dataHeap[],\n\t\t    unsigned indexHeap[],\n\t\t    unsigned &heapSize,\n\t\t    const vector< Array<unsigned>* > &lists,\n\t\t    unsigned  pointersIndexList[],\t\t\t  \n\t\t    unsigned  vectorIndexContainer[],\n\t\t    unsigned  containerSize)\n\n{\n  for(unsigned i=0;i<containerSize;i++)\n    {\n      unsigned index = vectorIndexContainer[i];\n      \n      unsigned position = pointersIndexList[index];\n\n      unsigned newData = \n\t(lists.at(index))->at(position);\n\n      heapInsert(newData,index,dataHeap,indexHeap, heapSize);\n\n    }//end for\n\n}//end insertToHeaps\n\n/*\n  This fucntion skips nodes\n  for mergebinarySeach algorithm\n*/\n\nvoid  skipNodes (const vector<Array<unsigned>* > &lists,\n\t\t unsigned vectorIndexContainer[],\n\t\t unsigned containerSize, \n\t\t unsigned pivotData,\n\t\t unsigned pointersIndexList[])\n\n{\n    \n  for(unsigned i=0;i<containerSize;i++)\n    {\n\n      unsigned j = vectorIndexContainer[i];\n\n      unsigned oldPosition =  pointersIndexList[j];\n          \n      pointersIndexList[j] =\n\tlists.at(j)->binarySearch(pivotData,oldPosition);\n\n      // cout<< \"new data\" << lists.at(j)->at( pointersIndexList[j]) <<\n      //\t\" old data \" << pivotData <<endl;\n\n      //assert(lists.at(j)->at( pointersIndexList[j]) >= pivotData);\n    \n    }//end for\n   \n}//end skipNodes\n\n/* \n   This function can be deleted for the final release\n*/\n\nvoid  CountSkipNodes (const vector<Array<unsigned>* > &lists,\n\t\t      unsigned vectorIndexContainer[],\n\t\t      unsigned containerSize, \n\t\t      unsigned pivotData,\n\t\t      unsigned pointersIndexList[],\n\t\t      unsigned &elementScanned)\n\n{\n    \n  for(unsigned i=0;i<containerSize;i++)\n    {\n\n      unsigned j = vectorIndexContainer[i];\n\n      unsigned oldPosition =  pointersIndexList[j];\n          \n      pointersIndexList[j] =\n\tlists.at(j)->binarySearch(pivotData,oldPosition);\n\n      elementScanned += (unsigned)ceil(0.01*log(lists.at(j)->size()));\n\n      // cout<< \"new data\" << lists.at(j)->at( pointersIndexList[j]) <<\n      //\t\" old data \" << pivotData <<endl;\n\n      //assert(lists.at(j)->at( pointersIndexList[j]) >= pivotData);\n    \n    }//end for\n   \n}//end skipNodes\n\n\n\nunsigned max(unsigned s1, unsigned s2)\n{\n\n  if (s1>s2)\n    return s1;\n  else\n    return s2;\n\n}//end max\n\n/* \n This function selects the shorest\n string for computing the thresholds \n in filters.\n\n*/\n\nunsigned  shorestStringSize(const vector<string> &strings\n\t\t\t    )\n{\n  unsigned minSize = ~0;\n\n  for(unsigned i=0;i<(unsigned)strings.size();i++)\n    {\n      unsigned s = strings.at(i).length();\n      \n      if (s < minSize)\n\tminSize = s;\n      \n    }//end for\n\n  return minSize ;\n  \n}//end \n\n\n\n/* \n  This function is only for MergeSkip algorithm.\n\n  Use MergeSkip algorithm to process\n  short lists in DivideSkip algorithm.\n\n*/\n\nvoid  mergeSkipShortLists(const vector<Array<unsigned>*> &arrays,\n\t\t\t     const unsigned threshold,\n\t\t\t     vector<unsigned> &results,\n\t\t\t     vector<unsigned> &counters)\n{\n\n  //const unsigned maxUnsigned = 0x10000000 - 2; \n  const unsigned maxUnsigned = 0xFFFFFFFF; \n\n  unsigned numberOfInvertedList = arrays.size();\n\n  if (threshold>numberOfInvertedList)\n    return; // no answer\n\n  unsigned pointersIndex [numberOfInvertedList];\n        \n  for(unsigned k=0;k<numberOfInvertedList;k++)\n      pointersIndex[k]=0;\n\n  addMAXUnsigned2EachList(arrays,  maxUnsigned);\n\n  unsigned  dataHeap [numberOfInvertedList] ;\n  unsigned  indexHeap [numberOfInvertedList] ; \n        \n  makeInitialHeap(dataHeap,indexHeap,arrays);\n\n  unsigned sizeOfHeaps = numberOfInvertedList;\n\n  unsigned  pivot = threshold -1 ;\n \n  while ( dataHeap[0]  <  maxUnsigned ){\n           \n    //cout<< \" Current heaps are : \" << endl;\n    //printArrayUnsigned (dataHeap, sizeOfHeaps);\n    //printArrayUnsigned (indexHeap, sizeOfHeaps);\n             \n    // Container of vector indexes which should be moved to the next position\n    unsigned vectorIndexContainer[numberOfInvertedList];\n    unsigned containerSize = 0;\n    \n\n    // Check if we can get the result \n    unsigned minData =  dataHeap[0];\n    \n    while (minData == dataHeap[0] && containerSize < numberOfInvertedList )\n      {         \n\tvectorIndexContainer[containerSize++] = indexHeap[0];\n\t\n\theapDelete(dataHeap,indexHeap,sizeOfHeaps);\n\t\n      }//end while\n    \n    if (containerSize >= threshold) // we got the result\n      {\n\tcounters.push_back(containerSize);\n\tresults.push_back(minData);\n\t\n\t//cout<< \"We get a result, rule ID is \" << minData <<\", count is \" << containerSize <<endl;\n\t\n        //move to the next element\n\tfor(unsigned i=0;i<containerSize;i++)\n\t  {\n\t    unsigned j = vectorIndexContainer[i];\n\t    pointersIndex[j]++ ;\n\t  }//end for\n\t\n\tinsertToHeaps(dataHeap,indexHeap,\n\t\t      sizeOfHeaps, \n\t\t      arrays,pointersIndex,\n\t\t      vectorIndexContainer,\n\t\t      containerSize);\n             \n\tcontinue;\n\t\n      }//end if\n\n    \n    // pop more elements from heap\n    // and skip nodes\n\n    while (containerSize < pivot){\n\n      vectorIndexContainer[containerSize++] = indexHeap[0];\n             \n      heapDelete(dataHeap,indexHeap,sizeOfHeaps);\n  \n\n    }//end while (containerSize < pivot )\n                  \n    //printArray( vectorIndexContainer,containerSize);\n\n    // cout<< \"Pivot node is \" <<  dataHeap[0] << endl;\n\n    skipNodes(arrays, vectorIndexContainer, containerSize,\n\t      dataHeap[0], pointersIndex);\n\n    //cout<<\"After skip, current nodes are : \" <<endl;\n\n    //showCurrentNodes(&pointersNode, &pointersIndex, numberOfInvertedList);\n\n    insertToHeaps(dataHeap,\n\t\t  indexHeap,\n\t\t  sizeOfHeaps,\n\t\t  arrays,\n\t\t  pointersIndex,\n\t\t  vectorIndexContainer,\n\t\t  containerSize);\n\n  }//end while  ( thresholdHeap[0]  < MAX)\n\n  deleteMAXUnsignedfromEachList(arrays);\n  \n}//end  mergeSkipShortLists\n\n\nvoid  mergeSkipShortListsWithDuplicate(const vector<Array<unsigned>*> &arrays,\n\t\t\t\t       const vector<unsigned> &weights,\n\t\t\t\t       const unsigned threshold,\n\t\t\t\t       vector<unsigned> &results,\n\t\t\t\t       vector<unsigned> &counters)\n{\n\n  const unsigned maxUnsigned = 0xFFFFFFFF; \n\n  unsigned numberOfInvertedList = arrays.size();\n\n  unsigned pointersIndex [numberOfInvertedList];\n        \n  for(unsigned k=0;k<numberOfInvertedList;k++)\n      pointersIndex[k]=0;\n\n  addMAXUnsigned2EachList(arrays,  maxUnsigned);\n\n  unsigned  dataHeap [numberOfInvertedList] ;\n  unsigned  indexHeap [numberOfInvertedList] ; \n        \n  makeInitialHeap(dataHeap,indexHeap,arrays);\n\n  unsigned sizeOfHeaps = numberOfInvertedList;\n\n  unsigned  pivot = threshold -1 ;\n  \n  while ( dataHeap[0]  <  maxUnsigned ){\n           \n    //cout<< \" Current heaps are : \" << endl;\n    //printArrayUnsigned (dataHeap, sizeOfHeaps);\n    //printArrayUnsigned (indexHeap, sizeOfHeaps);\n             \n    // Container of vector indexes which should be moved to the next position\n    unsigned vectorIndexContainer[numberOfInvertedList];\n    unsigned containerWeight = 0, containerSize = 0;\n    \n    // Check if we can get the result \n    unsigned minData =  dataHeap[0];\n    \n    while (minData == dataHeap[0] && containerSize < numberOfInvertedList )\n      {         \n\tvectorIndexContainer[containerSize++] = indexHeap[0];\n\n\tcontainerWeight += weights[indexHeap[0]];\n\n\theapDelete(dataHeap,indexHeap,sizeOfHeaps);\n\n\t\n      }//end while\n    \n    if (containerWeight >= threshold) // we got the result\n      {\n\tcounters.push_back(containerWeight);\n\tresults.push_back(minData);\n\t\n\t//cout<< \"We get a result, rule ID is \" << minData <<\", count is \" << containerSize <<endl;\n\t\n        //move to the next element\n\tfor(unsigned i=0;i<containerSize;i++)\n\t  {\n\t    unsigned j = vectorIndexContainer[i];\n\t    pointersIndex[j]++ ;\n\t  }//end for\n\t\n\tinsertToHeaps(dataHeap,indexHeap,\n\t\t      sizeOfHeaps, \n\t\t      arrays,pointersIndex,\n\t\t      vectorIndexContainer,\n\t\t      containerSize);\n             \n\tcontinue;\n\t\n      }//end if\n\n    \n    // pop more elements from heap\n    // and skip nodes\n    \n    while (containerWeight < pivot){\n      \n      // FIX BY ALEX\n      // it is possible for a list to have a weight equals to T\n      if(containerWeight + weights[indexHeap[0]] > pivot) break;\n\n      vectorIndexContainer[containerSize++] = indexHeap[0];\n             \n      containerWeight += weights[indexHeap[0]];\n\n      heapDelete(dataHeap,indexHeap,sizeOfHeaps);\n\n    }//end while (containerWeight < pivot )\n                  \n    //printArray( vectorIndexContainer,containerSize);\n\n    // cout<< \"Pivot node is \" <<  dataHeap[0] << endl;\n\n    skipNodes(arrays, vectorIndexContainer, containerSize,\n\t      dataHeap[0], pointersIndex);\n\n    //cout<<\"After skip, current nodes are : \" <<endl;\n\n    //showCurrentNodes(&pointersNode, &pointersIndex, numberOfInvertedList);\n\n    insertToHeaps(dataHeap,\n\t\t  indexHeap,\n\t\t  sizeOfHeaps,\n\t\t  arrays,\n\t\t  pointersIndex,\n\t\t  vectorIndexContainer,\n\t\t  containerSize);\n\n  }//end while  ( thresholdHeap[0]  < MAX)\n\n  deleteMAXUnsignedfromEachList(arrays);\n  \n}//end   mergeSkipShortListsWithDuplicate\n\n\n/*\nvoid detectDuplicateLists(const vector<Array<unsigned>*> &arrays,\n\t\t\t  vector<Array<unsigned>*> &newArrays,\n\t\t\t  vector<unsigned> &newWeights)\n{\n  \n  unsigned sizeOfInvertedLists = arrays.size();\n  \n  unsigned sortedIndex[sizeOfInvertedLists];\n  sortBySizeOfLists(arrays,sortedIndex);//increasing order\n\n  Array<unsigned> *currentArray=arrays.at(sortedIndex[0]);\n  unsigned currentCount = 1;\n\n  for(unsigned i=1;i<sizeOfInvertedLists;i++)\n    {\n      Array<unsigned> *iArray = arrays.at(sortedIndex[i]);\n\n      if (iArray == currentArray)\n\tcurrentCount++;\n      else\n\t{\n\t  newArrays.push_back(currentArray);\n\t  newWeights.push_back(currentCount);\n\t  currentCount = 1;\n\t  currentArray = iArray;\n\t}//end if\n      \n    }//end for\n\n  newArrays.push_back(currentArray);\n  newWeights.push_back(currentCount);\n\n    \n}//end detectDuplicateLists\n*/\n\n// BUGFIX BY ALEX\nvoid detectDuplicateLists(const vector<Array<unsigned>*> &arrays,\n\t\t\t  vector<Array<unsigned>*> &newArrays,\n\t\t\t  vector<unsigned> &newWeights) {\n  \n  unsigned sizeOfInvertedLists = arrays.size();  \n  unsigned sortedIndex[sizeOfInvertedLists];\n  sortBySizeOfLists(arrays,sortedIndex);\n  \n  // we need to take care of unequal lists with the same size\n  // do exhaustive search within each list length group\n  set<unsigned> arraysAdded;\n  for(unsigned i=0;i<sizeOfInvertedLists;i++) {   \n    Array<unsigned> *currentArray=arrays.at(sortedIndex[i]);\n    unsigned arrAddr = (unsigned)currentArray;\n    unsigned currentCount = 1;    \n    \n    // if the array has not been added previously\n    if(arraysAdded.find(arrAddr) == arraysAdded.end()) {\n      // search all arrays with the same length for identical pointers\n      for(unsigned j = i + 1; j < sizeOfInvertedLists; j++) {       \n\tArray<unsigned> *iArray = arrays.at(sortedIndex[j]);\n\tif(iArray->size() != currentArray->size()) break;\n\tif(iArray == currentArray) currentCount++;\n      }    \n      // add the array\n      newArrays.push_back(currentArray);\n      newWeights.push_back(currentCount);\n      arraysAdded.insert(arrAddr);\n    }\n  }  \n\n  // ALEX DEBUG\n  /*\n  unsigned weightSum = 0;\n  for(unsigned i = 0; i < newArrays.size(); i++) {\n    Array<unsigned>* tmp = newArrays.at(i);\n    bool contains = false;\n    for(unsigned j = 0; j < tmp->size(); j++) {      \n      if(tmp->at(j) == 49) {\n\tcontains = true;\n\tbreak;\n      }\n    }\n    if(contains) {\n      cout << \"LIST: \" << (unsigned)newArrays.at(i) << \" \" << newWeights.at(i) << endl;\n      weightSum += newWeights.at(i);\n    }\n  }\n  cout << \"WEIGHTSUM: \" << weightSum << endl;\n  */\n}\n", "encoding": "ascii"}