{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/topk/src/topkindex.cc", "content": "/*\n  $Id: topkindex.cc 5772 2010-10-19 07:15:28Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n \n  Redistribution of this file is permitted under the terms of the BSD\n  license\n\n  Date: 04/28/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"topkindex.h\"\n#include \"util/src/io.h\"\n\nusing namespace std;\nusing namespace tr1;\n\n#ifdef DEBUG\nuint simComp = 0;\nfloat simTime = 0;\nmap<uint, uint> thrFreq;\nmap<uint, uint> thrFreqSim;\nmap<uint, map<uint, uint> > thrsFreq;\nmap<uint, map<uint, uint> > thrsFreqSim;\n#endif\n\nnamespace Topk \n{\n  Index::~Index() \n  {\n    clear();\n  }\n\n  void Index::clear() \n  {\n    for (unordered_map<uint, range<uint*> >::const_iterator it = lists.begin();\n         it != lists.end(); \n         ++it)\n      delete [] it->second._begin;\n    lists.clear();\n  }\n\n  void Index::save(const string &filename) \n    const\n  {\n    ofstream file(filename.c_str(), ios::out | ios::binary);\n\n    if (!file) {\n      cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    WRITING_FILE(filename);\n    save(file);\n    file.close();\n    WRITING_DONE();\n  }\n\n  void Index::save(ofstream &file)\n    const\n  {\n    ostream_iterator<binary_io<uint> > out(file);\n\n    *out++ = lenMax;\n    *out++ = noGramsMin;\n    *out++ = lists.size();\n\n    for (unordered_map<uint, range<uint*> >::const_iterator lst = lists.begin();\n         lst != lists.end(); ++lst) {\n      *out++ = lst->first;    \n      *out++ = lst->second._end - lst->second._begin;\n\n      copy(lst->second._begin, lst->second._end, out);\n    }\n  }\n\n  void Index::load(const string &filename)\n  {\n    ifstream file(filename.c_str(), ios::in | ios::binary);\n\n    if (!file) {\n      cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    READING_FILE(filename);\n    load(file);\n    file.close();\n    READING_DONE();\n  }\n\n  void Index::load(ifstream &file)\n  {\n    clear();\n\n    istream_iterator<binary_io<uint> > in(file);\n\n    uint nList;\n\n    lenMax = *in++;\n    noGramsMin = *in++;\n    nList = *in;\n\n    for (uint list = 0; list < nList; ++list) {\n      ++in;\n      uint gram = *in++;\n      uint size = *in;\n\n      uint *lst = new uint[size];\n      for (uint j = 0; j < size; ++j) {\n        ++in;\n        lst[j] = *in;\n      }\n        \n      lists.insert(make_pair(gram, make_range(lst, lst + size)));\n    }\n  }\n\n  IndexQuery::IndexQuery(const Index &idx, const Query &que) \n  {\n    set<uint> grams;\n    que.sim.gramGen.decompose(que.str, grams);\n \n    for (set<uint>::const_iterator gram = grams.begin(); \n         gram != grams.end(); ++gram) {\n      unordered_map<uint, range<uint*> >::const_iterator \n        ls = idx.lists.find(*gram);\n      if (ls != idx.lists.end()) {\n        lists.push_back(ls->second);\n      }\n    }\n  }\n\n  IndexQuery::IndexQuery(const Index &idx, const QueryGroup &queGrp) \n  {\n    set<uint> grams;\n\n    for (uint i = 0; i < queGrp.n; ++i)\n      queGrp.sim.gramGen.decompose(queGrp.strs[i], grams);\n    \n    OUTPUT(\"no grams \", grams.size());\n\n    for (set<uint>::const_iterator gram = grams.begin(); \n         gram != grams.end(); ++gram) {\n      // cout << *gram << \" \";\n      unordered_map<uint, range<uint*> >::const_iterator \n        ls = idx.lists.find(*gram);\n      if (ls != idx.lists.end())\n        lists.push_back(ls->second);\n    }\n\n    // cout << endl;\n\n  }\n\n  IndexQuery::IndexQuery(const Index &idx, const QueryGrams &que) \n  {\n    OUTPUT(\"no grams \", que.str.size());\n\n    for (vector<uint>::const_iterator gram = que.str.begin(); \n         gram != que.str.end(); ++gram) {\n      // cout << *gram << \" \";\n      unordered_map<uint, range<uint*> >::const_iterator \n        ls = idx.lists.find(*gram);\n      if (ls != idx.lists.end())\n        lists.push_back(ls->second);\n    }\n\n    // cout << endl;\n\n  }\n}\n", "encoding": "ascii"}