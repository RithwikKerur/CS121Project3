{"url": "http://flamingo.ics.uci.edu/releases/2.0/src/filtertree/example.cc", "content": "/*\n  $Id: example.cc 4056 2008-10-10 22:01:51Z abehm $\n\n  Copyright (C) 2008 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license\n    \n  Date: 02/04/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"ftsearchermem.h\"\n#include \"common/query.h\"\n#include \"common/simmetric.h\"\n#include \"listmerger/divideskipmerger.h\"\n#include \"listmerger/scancountmerger.h\"\n\nvector<string> dictionary;\n\n// create a dummy dictionary\nvoid initDictionary();\n\nvoid basicUsage1();\nvoid basicUsage2();\nvoid basicUsage3();\n\nint main() {\n  initDictionary();\n\n  basicUsage1();\n  basicUsage2();\n  basicUsage3();\n\n  return 0;\n}\n\nvoid initDictionary() {\n  vector<string> prefixes;\n  prefixes.push_back(\"string\");\n  prefixes.push_back(\"example\");  \n  prefixes.push_back(\"test\");\n  prefixes.push_back(\"hello\");\n  prefixes.push_back(\"world\");\n  prefixes.push_back(\"foo\");\n  prefixes.push_back(\"bar\");\n\n  vector<string> suffixes;\n  suffixes.push_back(\"1\");\n  suffixes.push_back(\"10\");\n  suffixes.push_back(\"100\");\n  suffixes.push_back(\"2\");\n  suffixes.push_back(\"20\");\n  suffixes.push_back(\"200\");\n  suffixes.push_back(\"3\");\n  suffixes.push_back(\"30\");\n  suffixes.push_back(\"300\");\n\n  cout << \"---------------------------------------\" << endl;\n  cout << \"STRING DICTIONARY:\" << endl;\n  for(unsigned j = 0; j < prefixes.size(); j++)\n    for(unsigned i = 0; i < suffixes.size(); i++) {\n      dictionary.push_back(prefixes.at(j) + suffixes.at(i));\n      cout << dictionary.at(dictionary.size()-1) << endl;\n    }\n  cout << \"---------------------------------------\" << endl << endl;\n}\n\nvoid basicUsage1() {  \n  cout << \"----- BASIC USAGE 1 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(3); // using fixed-length grams\n  SimMetricEd simMetric(gramGen); // using the edit distance\n  //SimMetricJacc simMetric(gramGen); // using jaccard similarity\n  //SimMetricCos simMetric(gramGen); // using cosine similarity\n  //SimMetricDice simMetric(gramGen); // using dice similarity\n  \n  // create simple indexer with default template arguments\n  // default: in-memory index using Array<unsigned> as an inverted list container\n  // first create a string container and fill it with strings to index\n  StringContainerVector strContainer;\n  strContainer.fillContainer(dictionary); // fill the container from a vector<string>\n  FtIndexerSimple<> indexer(&strContainer, &gramGen);\n  indexer.addFilter(new LengthFilter(50)); // add length filtering with a maximum string length of 50\n  indexer.buildIndex();\n  \n  // create merger\n  DivideSkipMerger<> merger;\n  // create searcher passing merger and indexer with default template arguments\n  // default: same as indexer, i.e. assumed simple indexer with Array<unsigned> as inverted lists and DivideSkipMerger as merger type\n  FtSearcherMem<> searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"xample\", simMetric, 2.0f); // query string, similarity metric, similarity threshold\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"ExampleIndex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerSimple<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"ExampleIndex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n\n  cout << \"----------------------\" << endl << endl;\n}\n\nvoid basicUsage2() {  \n  cout << \"----- BASIC USAGE 2 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(3); // using fixed-length grams\n  SimMetricEd simMetric(gramGen); // using the edit distance\n  \n  // create simple indexer with default template arguments\n  // default: in-memory index using Array<unsigned> as an inverted list container\n  // first create a string container and fill it with strings to index\n  StringContainerVector strContainer;\n  strContainer.fillContainer(\"data/dummy.txt\", 180); // fill the container from a datafile and use the first 180 lines\n  FtIndexerSimple<> indexer(&strContainer, &gramGen);\n  indexer.addFilter(new LengthFilter(50)); // add length filtering with a maximum string length of 50\n  indexer.buildIndex();\n  \n  // create merger\n  DivideSkipMerger<> merger;\n  // create searcher passing merger and indexer with default template arguments\n  // default: same as indexer, i.e. assumed simple indexer with Array<unsigned> as inverted lists and DivideSkipMerger as merger type\n  FtSearcherMem<> searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"elloorld\", simMetric, 3.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"ExampleIndex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerSimple<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"ExampleIndex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n\n  cout << \"----------------------\" << endl << endl;\n}\n\nvoid basicUsage3() {  \n  cout << \"----- BASIC USAGE 3 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(3); // using fixed-length grams\n  SimMetricJacc simMetric(gramGen); // using the jaccard distance (using set semantics)\n  \n  // create simple indexer with default template arguments\n  // default: in-memory index using Array<unsigned> as an inverted list container\n  // first create a string container and fill it with strings to index\n  StringContainerVector strContainer;\n  strContainer.fillContainer(\"data/dummy.txt\", 180); // fill the container from a datafile and use the first 180 lines\n  FtIndexerSimple<> indexer(&strContainer, &gramGen);\n  indexer.addFilter(new ChecksumFilter(50)); // add checksum filtering with a maximum string length of 50\n  indexer.buildIndex();\n  \n  // create merger\n  ScanCountMerger<> merger(180);\n  // create searcher, specifying a non-default merger\n  FtSearcherMem<FtIndexerSimple<>, ScanCountMerger<> > searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"elloworld\", simMetric, 0.4f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"ExampleIndex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerSimple<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"ExampleIndex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n\n  cout << \"----------------------\" << endl << endl;\n}\n", "encoding": "ascii"}