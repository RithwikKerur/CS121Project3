{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/partenum/partenum.cc", "content": "/*\n  $Id: partenum.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n \n  The implementation of the PartEnum algorithm invented by Microsoft\n  researchers is limited to non commercial use, which would be covered\n  under the royalty free covenant that Microsoft made public.\n\n  Date: 01/31/2007\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n\n  Uses: http://www.boost.org/doc/html/hash.html\n*/\n\n#include \"partenum.h\"\n\n#include <sys/time.h>\n#include <sys/stat.h>\n\n#include <algorithm>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <set>\n\n#include <boost/functional/hash.hpp>\n\n#include \"util/simfuncs.h\"\n#include \"util/input.h\"\n#include \"util/misc.h\"\n\nusing namespace std;\n\nconst unsigned PartEnum::siglenMax = 100;\nconst string PartEnum::paramSuffix = \".pe.param.bin\";\nconst string PartEnum::signSuffix = \".pe.sign.bin\";\n\nPartEnum::PartEnum(const vector<string> &data, \n                   unsigned q, unsigned editdist, unsigned n1, unsigned n2):\n  data(&data),\n  gramId(GramId(q)),\n  k(2 * editdist *  q),\n  k2((k + 1) / n1 - 1),\n  n1(n1),\n  n2(n2),\n  subs(subsets(n2, n2 - k2)), \n  datalen(this->data->size()), \n  siglen(subs.size() * n1), \n  buckets(new SigsBucket[siglen])\n{\n  if (siglen > siglenMax) {\n    cerr << \"siglen \" << siglen << \" greater than siglenMax \" << siglenMax << endl;\n    exit(EXIT_FAILURE);\n  }\n}\n\nPartEnum::PartEnum(const vector<string> &data, const string &filenamePrefix):\n  data(&data),\n  gramId(GramId(filenamePrefix)),\n  datalen(this->data->size())\n{\n  loadIndex(filenamePrefix);\n}\n\nPartEnum::~PartEnum() \n{\n  for (unsigned i = 0; i < siglen; i++)\n    for (SigsBucket::const_iterator it = buckets[i].begin();\n         it != buckets[i].end(); ++it)\n      delete[] it->second;\n  delete[] buckets;\n}\n\nvoid PartEnum::build() \n{\n  // sign\n  cerr << \"sign\";\n  unsigned *sigs = new unsigned[datalen * siglen];\n  unsigned i = 0;\n  for (vector<string>::const_iterator it = data->begin(); \n       it != data->end(); ++it) {\n    if (i % 10000 == 0) {\n      cerr << '.'; cerr.flush();\n    }\n\n    sign(*it, sigs + i);\n    i += siglen;    \n  }\n  cerr << \"OK\" << endl;\n\n  // bucket\n  cerr << \"bucket\";\n\n  // time efficient\n  for (unsigned j = 0; j < siglen; j++) {\n    if (j % siglen / 10 == 0) {\n      cerr << '.'; cerr.flush();\n    }\n    map<unsigned, vector<unsigned> > bucketsVec;\n\n    for (unsigned i = 0; i < datalen; i++)\n      bucketsVec[sigs[i * siglen + j]].push_back(i);\n\n    for (map<unsigned, vector<unsigned> >::const_iterator\n           it = bucketsVec.begin(); it != bucketsVec.end(); ++it) {\n      unsigned sz = 1 + it->second.size();\n      unsigned *bucket = new unsigned[sz];\n      unsigned i = 0;\n      bucket[i++] = sz;\n      for (vector<unsigned>::const_iterator jt = it->second.begin();\n           jt != it->second.end(); ++jt)\n        bucket[i++] = *jt;\n      buckets[j][it->first] = bucket;\n    }\n    buckets[j].rehash(static_cast<size_t>(buckets[j].load_factor()));\n  }\n\n  // memory efficient\n  /*\n    for (i = 0; i < siglen; i++) {\n    cerr << '.'; cerr.flush();\n\n    map<unsigned, unsigned> bucketSz;\n    for (unsigned j = 0; j < datalen; j++)\n    bucketSz[sigs[j * siglen + i]]++;\n    \n    for (map<unsigned, unsigned>::const_iterator sz = bucketSz.begin();\n    sz != bucketSz.end(); ++sz) {\n    unsigned *bucket = new unsigned[sz->second + 1];\n    unsigned k = 0;\n    bucket[k++] = sz->second + 1;\n    for (unsigned j = 0; j < datalen; j++)\n    if (sigs[j * siglen + i] == sz->first)\n    bucket[k++] = j;\n      \n    buckets[i][sz->first] = bucket;\n    }\n    bucketSz.clear();\n    }\n  */\n\n  cerr << \"OK\" << endl;\n  \n  delete[] sigs;\n}\n\nvoid PartEnum::saveIndex(const string &filenamePrefix) const\n{\n  // save gramid\n  gramId.saveData(filenamePrefix);\n\n  // save param\n  string filenameParam = filenamePrefix + paramSuffix;\n \n  cerr << \"write to \\\"\" << filenameParam << \"\\\"...\";\n  cerr.flush();\n\n  ofstream fileParam(filenameParam.c_str(), ios::out | ios::binary);\n  if (!fileParam) {\n    cerr << \"can't open output file \\\"\" << filenameParam << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  fileParam.write(reinterpret_cast<const char*>(&k), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&k2), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n  \n  fileParam.write(reinterpret_cast<const char*>(&n1), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&n2), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.close();\n\n  cerr << \"OK\" << endl;\n\n  // save sigs\n  string filenameSigs = filenamePrefix + signSuffix;\n\n  cerr << \"write to \\\"\" << filenameSigs << \"\\\"...\";\n  cerr.flush();\n\n  ofstream fileSigs(filenameSigs.c_str(), ios::out | ios::binary);\n  if (!fileSigs) {\n    cerr << \"can't open output file \\\"\" << filenameSigs << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  for (unsigned i = 0; i < siglen; i++) {\n    unsigned sz = buckets[i].size();\n    fileSigs.write(reinterpret_cast<const char*>(&sz), \n                   sizeof(unsigned));\n    if (fileSigs.fail()) writeerror(filenameSigs);\n\n    for (SigsBucket::const_iterator bucket = buckets[i].begin();\n         bucket != buckets[i].end(); ++bucket) {\n\n      fileSigs.write(reinterpret_cast<const char*>(&bucket->first), sizeof(unsigned));\n      if (fileSigs.fail()) writeerror(filenameSigs);\n\n      unsigned *sigs = bucket->second;\n\n      fileSigs.write(reinterpret_cast<const char*>(&sigs[0]), sizeof(unsigned));\n      if (fileSigs.fail()) writeerror(filenameSigs);\n    \n      for (unsigned j = 1; j < bucket->second[0]; j++) {\n        fileSigs.write(reinterpret_cast<const char*>(&sigs[j]),\n                       sizeof(unsigned));\n        if (fileSigs.fail()) writeerror(filenameSigs);\n      }\n    }\n  }\n  fileSigs.close();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid PartEnum::loadIndex(const string &filenamePerfix)\n{\n  if (!consistIndex(filenamePerfix)) {\n    cerr << \"index files are not consistent\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  // load param\n  string filenameParam = filenamePerfix + paramSuffix;\n\n  cerr << \"read from \\\"\" << filenameParam << \"\\\"...\";\n  cerr.flush();\n \n  ifstream fileParam(filenameParam.c_str(), ios::in | ios::binary);\n  if (!fileParam) {\n    cerr << \"can't open input file \\\"\" << filenameParam << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  fileParam.read(reinterpret_cast<char*>(&k), sizeof(unsigned));\n  if (fileParam.eof()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&k2), sizeof(unsigned));\n  if (fileParam.eof()) readerror(filenameParam);\n  \n  fileParam.read(reinterpret_cast<char*>(&n1), sizeof(unsigned));\n  if (fileParam.eof()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&n2), sizeof(unsigned));\n  if (fileParam.eof()) readerror(filenameParam);\n\n  fileParam.close();\n\n  cerr << \"OK\" << endl;\n\n  subs = subsets(n2, n2 - k2);\n  siglen = subs.size() * n1;  \n  buckets = new SigsBucket[siglen];\n\n  // load sigs\n  string filenameSigs = filenamePerfix + signSuffix;\n\n  cerr << \"read from \\\"\" << filenameSigs << \"\\\"...\";\n  cerr.flush();\n\n  ifstream fileSigs(filenameSigs.c_str(), ios::in | ios::binary);\n  if (!fileSigs) {\n    cerr << \"can't open input file \\\"\" << filenameSigs << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  for (unsigned i = 0; i < siglen; i++) {\n    unsigned bucketNo;\n\n    fileSigs.read(reinterpret_cast<char*>(&bucketNo), sizeof(unsigned));\n    if (fileSigs.eof()) readerror(filenameSigs);\n\n    for (unsigned j = 0; j < bucketNo ; j++) {\n      unsigned key;\n\n      fileSigs.read(reinterpret_cast<char*>(&key), sizeof(unsigned));\n      if (fileSigs.eof()) readerror(filenameSigs);\n\n      unsigned sz;\n\n      fileSigs.read(reinterpret_cast<char*>(&sz), sizeof(unsigned));\n      if (fileSigs.eof()) readerror(filenameSigs);\n      \n      unsigned *bucket = new unsigned[sz];\n      bucket[0] = sz;\n      \n      for (unsigned k = 1; k < sz; k++) {\n        fileSigs.read(reinterpret_cast<char*>(bucket + k), sizeof(unsigned));\n        if (fileSigs.eof()) readerror(filenameSigs);\n      }\n      \n      buckets[i][key] = bucket;\n    }\n  }\n\n  fileSigs.close();\n\n  cerr << \"OK\" << endl;\n}\n\nbool PartEnum::consistIndex(const string &filenamePrefix) const\n{\n  string filenameParam = filenamePrefix + paramSuffix;\n  string filenameSign = filenamePrefix + signSuffix;\n\n  if (!gramId.consistData(filenamePrefix, filenameParam))\n    return false;\n\n  struct stat attribParam, attribSign;      \n  if (stat(filenameParam.c_str(), &attribParam)) {\n    cerr << \"can't stat file \\\"\" << filenameParam << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  if (stat(filenameSign.c_str(), &attribSign)) {\n    cerr << \"can't stat file \\\"\" << filenameSign << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  if (!(attribParam.st_mtime <= attribSign.st_mtime))\n    return false;\n\n  return true;  \n}\n\nvoid PartEnum::search(const string &query, vector<unsigned> &results) \n{\n  search(query, getEditdist(), results);\n}\n\nvoid PartEnum::search(const string &query, const unsigned editdist, \n                      vector<unsigned> &results)\n{\n  if (editdist > getEditdist()) {\n    cerr << \"PartEnum::search editdist greater than editdist in constructor\"\n         << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  unsigned sig[siglen], *sigs;\n  unsigned i, j, id;\n  unsigned char checksBit[datalen];\n\n  memset(checksBit, 0, datalen);\n  sign(query, sig);\n  for (j = 0; j < siglen; j++) {\n    SigsBucket::const_iterator pos = buckets[j].find(sig[j]);\n    if (pos != buckets[j].end()) {\n      sigs = pos->second;\n      for (i = 1; i < sigs[0]; i++) {\n        id = sigs[i];\n        if (!checksBit[id]) {\n          checksBit[id] = 1;\n          if (ed(query, (*data)[id], editdist))\n            results.push_back(id);\n        }\n      }\n    }\n  }\n}\n\nvoid PartEnum::sign(const string &s, vector<unsigned> &sig) const \n{\n  unsigned sigP[siglen];\n  sign(s, sigP);\n  for (unsigned i = 0; i < siglen; i++)\n    sig.push_back(sigP[i]);\n}\n\nvoid PartEnum::sign(const string &s, unsigned *sig) const \n{\n  vector<unsigned> ids;\n  gramId.getIds(s, ids);\n  vector<unsigned> sg;\n  set<unsigned> p1;\n  boost::hash<vector<unsigned> > vectorHash;\n  unsigned k = 0;\n  \n  for (unsigned i = 0; i < n1; i++)\n    for (vector<vector<unsigned> >::const_iterator sub = subs.begin();\n         sub != subs.end(); ++sub) {\n      p1.clear();\n      for (vector<unsigned> ::const_iterator j = sub->begin();\n           j != sub->end(); ++j)\n        for (vector<unsigned>::const_iterator id = ids.begin();\n             id != ids.end(); ++id) \n          if (*id >= begin(i, *j) && *id < end(i, *j))\n            p1.insert(*id);\n      sg.clear();\n      sg.push_back(i);\n      sg.insert(sg.end(), sub->begin(), sub->end());\n      sg.insert(sg.end(), p1.begin(), p1.end());\n      sig[k++] = vectorHash(sg);\n    }\n}\n\nbool PartEnum::operator==(const PartEnum &h) const \n{\n  if (this == &h) \n    return true;\n  if (gramId == h.gramId && \n      k == h.k && \n      k2 == h.k2 && \n      n1 == h.n1 && \n      n2 == h.n2 && \n      data == h.data && \n      subs == h.subs && \n      datalen == h.datalen && \n      siglen == h.siglen && \n      *buckets == *h.buckets)\n    return true;\n  return false;\n}\n\nbool operator==(const SigsBucket &b1, const SigsBucket &b2) \n{\n  if (b1.size() != b2.size())\n    return false;\n\n  for (SigsBucket::const_iterator it = b1.begin();\n       it != b1.end(); ++it) {\n    SigsBucket::const_iterator jt = b2.equal_range(it->first).first;\n    if (jt == b2.end())\n      return false;\n    if (it->second[0] != jt->second[0])\n      return false;\n    for (unsigned i = 1; i < it->second[0]; i++)\n      if (it->second[i] != jt->second[i])\n        return false;\n  }\n\n  for (SigsBucket::const_iterator it = b2.begin();\n       it != b2.end(); ++it)\n    if (b1.equal_range(it->first).first == b1.end())\n      return false;\n  \n  return true;  \n}\n", "encoding": "ascii"}