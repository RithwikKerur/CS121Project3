{"url": "http://flamingo.ics.uci.edu/releases/2.0.1/src/util/appsearch.cc", "content": "/*\n  $Id: appsearch.cc 4026 2008-10-01 00:23:25Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the\n  BSD license\n\n  Date: 03/16/2007\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"appsearch.h\"\n\n#include <sys/stat.h>\n\n#include <fstream>\n#include <iostream>\n\n#include \"simfuncs.h\"\n#include \"input.h\"\n#include \"misc.h\"\n\nconst unsigned editdistMin = 1, editdistMax = 3;\n\nstring getFilenameQuery(const string pathData, const string nameDataset, \n                        const unsigned queryCount)\n{\n  return pathData + removeExt(nameDataset) + \n    \".query.\" + utosh(queryCount) + \".bin\";\n}\n\nstring getFilenameAnswer(const string pathData, const string nameDataset, \n                         const unsigned queryCount, const unsigned editdist)\n{\n  return pathData + removeExt(nameDataset) +\n    \".answer.\" + utosh(queryCount) + \".\" + utos(editdist) + \".bin\";\n}\n\n\nbool existQuery(const string pathData, const string nameDataset, \n                const unsigned queryCount)\n{\n  const string filenameQuery = getFilenameQuery(pathData, nameDataset, \n                                                queryCount);\n  string filenameAnswer[editdistMax - editdistMin + 1];\n  unsigned editdist;\n  for (editdist = editdistMin; editdist <= editdistMax; editdist++)\n    filenameAnswer[editdist - editdistMin] = \n      getFilenameAnswer(pathData, nameDataset, queryCount, editdist);\n  \n  ifstream fileQue(filenameQuery.c_str(), ios::in | ios::binary);\n  if (!fileQue)\n    return false;\n  fileQue.close();\n\n  for (editdist = editdistMin; editdist <= editdistMax; editdist++) {\n    ifstream fileAns(filenameAnswer[editdist - editdistMin].c_str(), \n                     ios::in | ios::binary);\n    if (!fileAns)\n      return false;\n    fileAns.close();\n  }\n\n  struct stat attribQue, attribAns;      \n  stat(filenameQuery.c_str(), &attribQue);\n  for (editdist = editdistMin; editdist <= editdistMax; editdist++) {\n    stat(filenameAnswer[editdist - editdistMin].c_str(), &attribAns);\n    if (attribQue.st_mtime > attribAns.st_mtime)\n      return false;\n  }\n  \n  return true;\n}\n\nvoid genQuery(const vector<string> &data, \n              const string pathData, const string nameDataset, \n              const unsigned queryCount)\n{\n  cerr << \"que gen\"; cerr.flush();\n\n  // query\n  const string filenameQuery = getFilenameQuery(pathData, nameDataset, \n                                                queryCount);\n  ofstream fileQuery(filenameQuery.c_str(), ios::out | ios::binary);\n  if (!fileQuery) {\n    cerr << \"can't open output file \\\"\" << filenameQuery << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  vector<unsigned> query;\n  vector<unsigned> queryA(data.size());\n  for (unsigned i = 0; i < queryA.size(); i++)\n    queryA[i] = i;\n  random_shuffle(queryA.begin(), queryA.end());\n    \n  for (unsigned i = 0; i < queryCount; i++) {\n    query.push_back(queryA[i]);\n    fileQuery.write(reinterpret_cast<char*>(&queryA[i]), sizeof(unsigned));\n  }\n  fileQuery.close();  \n\n  // answer\n  for (unsigned editdist = editdistMin; editdist <= editdistMax; editdist++) {\n    string filenameAnswer = getFilenameAnswer(pathData, nameDataset,\n                                              queryCount, editdist);\n    ofstream fileAns(filenameAnswer.c_str(), ios::out | ios::binary);\n    if (!fileAns) {\n      cerr << \"can't open output file \\\"\" << filenameAnswer << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    vector<unsigned> ans;\n    unsigned e, k = 0;\n    for (vector<unsigned>::const_iterator it = query.begin();\n         it != query.end(); ++it) {\n\n      if (k % 10 == 0) {\n        cerr << '.'; cerr.flush();\n      }\n      k++;\n    \n      ans.clear();\n      for (unsigned i = 0; i < data.size(); i++)\n        if (ed(data[*it], data[i], editdist))\n          ans.push_back(i);\n\n      e = ans.size();\n      fileAns.write(reinterpret_cast<char*>(&e), sizeof(unsigned));\n      for (vector<unsigned>::const_iterator jt = ans.begin(); jt != ans.end(); ++jt)\n        fileAns.write(reinterpret_cast<const char*>(&*jt), sizeof(unsigned));\n    }\n    fileAns.close();\n  }  \n\n  cerr << \"OK\" << endl;\n}\n\nvoid readQuery(vector<unsigned> &query,\n               const string pathData, const string nameDataset, \n               const unsigned queryCount)\n{\n  const string filenameQuery = getFilenameQuery(pathData, nameDataset,\n                                                queryCount);\n  cerr << \"que \" << filenameQuery << endl;\n  readBin(query, filenameQuery);\n}\n\nvoid readAnswer(vector<set<unsigned> > &answer,\n                const string pathData, const string nameDataset, \n                const unsigned queryCount, const unsigned editdist)\n{\n  const string filenameAnswer = getFilenameAnswer(pathData, nameDataset,\n                                                  queryCount, editdist);\n  cerr << \"ans \" << filenameAnswer << endl;\n\n  ifstream fileAnswer(filenameAnswer.c_str(), ios::in | ios::binary);\n  if (!fileAnswer) {\n    cerr << \"can't open input file \\\"\" << filenameAnswer << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  set<unsigned> ans;\n  unsigned n, e;\n\n  while (true) {\n    fileAnswer.read(reinterpret_cast<char*>(&n), sizeof(unsigned));\n    if (fileAnswer.eof())\n      break;\n\n    ans.clear();\n    for (unsigned i = 0; i < n; i++) {\n      fileAnswer.read(reinterpret_cast<char*>(&e), sizeof(unsigned));\n      ans.insert(e);\n    }\n\n    answer.push_back(ans);\n  }\n\n  fileAnswer.close();\n}\n", "encoding": "ascii"}