{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/filtertree/src/stringrm.cc", "content": "/*\n  $Id: stringrm.cc 5718 2010-09-09 05:39:08Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 09/06/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include <cstring>\n#include <algorithm>\n\n#include \"stringrm.h\"\n\nint FreeSpaceEntryCmpFunc(const void * a, const void * b) {\n  if( ((FreeSpaceEntry*)a)->freeSpace > ((FreeSpaceEntry*)b)->freeSpace ) return -1;\n  if( ((FreeSpaceEntry*)a)->freeSpace < ((FreeSpaceEntry*)b)->freeSpace ) return 1;\n  if( ((FreeSpaceEntry*)a)->freeSpace == ((FreeSpaceEntry*)b)->freeSpace ) return 0;\n  return 0;\n}\n\nvoid \nFreeSpaceManager::\ninsert(const unsigned blockNum, const unsigned freeSpace) {\n  BlockWithSpace entry(blockNum, freeSpace);\n  FreeSpaceSet::iterator iter = freeSpaceEntries.find(entry);\n  if(iter == freeSpaceEntries.end()) {\n    if(freeSpaceEntries.size() < maxEntries) {\n      freeSpaceEntries.insert(entry);\n      totalFreeSpace += freeSpace;\n    }\n    else {\n      streampos avgFreeSpace = (totalFreeSpace / freeSpaceEntries.size());\n      if(freeSpace >  avgFreeSpace) {\n\tfor(FreeSpaceSet::iterator del_iter = freeSpaceEntries.begin();\t\n\t    del_iter != freeSpaceEntries.end();\n\t    del_iter++) {\n\t  if(del_iter->freeSpace < avgFreeSpace) {\n\t    totalFreeSpace -= del_iter->freeSpace;\t  \n\t    freeSpaceEntries.erase(del_iter);\t      \n\t    break;\n\t  }\n\t}\n\tfreeSpaceEntries.insert(entry);\t  \n\ttotalFreeSpace += freeSpace;\n      }\n    }\n  }\n  else {\n    totalFreeSpace -= iter->freeSpace;\n      freeSpaceEntries.erase(iter);\n      freeSpaceEntries.insert(entry);\t  \n      totalFreeSpace += freeSpace;\n  }\n}\n\nunsigned \nFreeSpaceManager::\ngetBlockWithSpace(unsigned freeSpace) {\n  for(FreeSpaceSet::const_iterator iter = freeSpaceEntries.begin();\n      iter != freeSpaceEntries.end();\n      iter++) {\n    if(iter->freeSpace >= freeSpace) return iter->blockNum;\n  }\n  return NO_SPACE_IN_BLOCK;\n}\n\nvoid \nFreeSpaceManager::\nprint() {\n  cout << \"TOTAL FREE SPACE: \" << totalFreeSpace << endl;\n  cout << \"AVG FREE SPACE: \" << (totalFreeSpace / freeSpaceEntries.size()) << endl;\n  for(FreeSpaceSet::const_iterator iter = freeSpaceEntries.begin();\n      iter != freeSpaceEntries.end();\n      iter++) {\n    cout << iter->blockNum << \" \" << iter->freeSpace << endl;      \n  }\n  cout << \"--------------\" << endl;\n}\n\n\nBufferManagerRM::\nBufferManagerRM(fstream* file, unsigned blockSize, unsigned bufferSlots)\n  : file(file), clockHand(NULL), bufferSlots(bufferSlots), blockSize(blockSize) {\n  init();  \n}\n\nvoid \nBufferManagerRM::\ninit() {\n  BufferEntry* runner = new BufferEntry(blockSize);\n  clockHand = runner;\n  for(unsigned i = 0; i < bufferSlots-1; i++) {\n    runner->next = new BufferEntry(blockSize);\n    runner = runner->next;\n  }\n  runner->next = clockHand; // close the circle\n}\n\nvoid \nBufferManagerRM::\nreadDiskBlock(char* block, const unsigned blockNum) {\n  file->seekg(blockNum * blockSize);\n  file->read(block, blockSize);\n}\n\nvoid \nBufferManagerRM::\nwriteDiskBlock(const char* block, const unsigned blockNum) {\n  file->seekp(blockNum * blockSize);\n  file->write(block, blockSize);\n}\n\n\nBufferEntry* \nBufferManagerRM::\ngetBlock(unsigned blockNum, bool appendBlock) {    \n  tr1::unordered_map<unsigned, BufferEntry*>::iterator iter = cacheMap.find(blockNum);\n  if(iter == cacheMap.end()) {\n\n    // find entry to replace, always start with next\n    while(clockHand->val != 0) {\n      clockHand->val = 0;\n      clockHand = clockHand->next;\n    }\n    \n    // first make the old buffer slot persistent\n    if(clockHand->dirty) writeDiskBlock(clockHand->data, clockHand->blockNum);\n    cacheMap.erase(clockHand->blockNum);\n        \n    if(!appendBlock) readDiskBlock(clockHand->data, blockNum);\n    clockHand->blockNum = blockNum;\n    clockHand->val = 1;\n    clockHand->dirty = false;\n    cacheMap[blockNum] = clockHand;          \n    \n    return clockHand;   \n  }\n  else {    \n    iter->second->val = 1;\n    return iter->second;\n  }\n}\n\nbool\nBufferManagerRM::\ninCache(unsigned blockNum) {\n  return cacheMap.find(blockNum) != cacheMap.end();\n}\n\nvoid \nBufferManagerRM::\nflushBuffer() {  \n  BufferEntry* runner = clockHand;\n  while(runner->next != clockHand) {\n    if(runner->blockNum != UNUSED_BUFFER_ENTRY) writeDiskBlock(runner->data, runner->blockNum); \n    runner = runner->next;\n  }   \n  if(runner->blockNum != UNUSED_BUFFER_ENTRY) writeDiskBlock(runner->data, runner->blockNum);  \n  cacheMap.clear();\n}\n\nBufferManagerRM::\n~BufferManagerRM() {\n  BufferEntry* runner = clockHand;\n  while(runner->next != clockHand) {\n    BufferEntry* next = runner->next;\n    delete runner;\n    runner = next;\n  }\n  delete runner;\n}\n\nvoid \nStringRM::\ninitDiskBlock(char* block) {\n  memset(block, 0, blockSize); // set whole block to zeros\n  // set dictionary entries to unused\n  memset(block + dictOffset, CHAR_MAXVAL, numDictSlots * sizeof(unsigned));\n  // set next block pointer to unused\n  memset(block + dictOffset + numDictSlots * sizeof(unsigned), CHAR_MAXVAL, sizeof(unsigned));    \n  // set free space entry\n  FreeSpaceEntry entry;\n  entry.freeSpace = blockSize - sizeof(unsigned) - numDictSlots * sizeof(unsigned) - numFreeSpaceSlots * sizeof(FreeSpaceEntry);\n  entry.offset = numFreeSpaceSlots * sizeof(FreeSpaceEntry);\n  addFreeSpaceEntry(block, &entry);   \n}\n\nvoid \nStringRM::\naddFreeSpaceEntry(char* block, const FreeSpaceEntry* entry) {\n  unsigned i;\n  for(i = 0; i < numFreeSpaceSlots; i++) {\n    FreeSpaceEntry* tmp = (FreeSpaceEntry*)(block + i*sizeof(FreeSpaceEntry));\n    if(tmp->freeSpace == UNUSED_FREE_SPACE_SLOT) {\n      memcpy(tmp, entry, sizeof(FreeSpaceEntry));\n      break;\n    }\n  }\n  if(i == numFreeSpaceSlots) {\n    cout << \"ERROR: could not add free space entry\" << endl;\n    // TODO: probably should schedule a re-org of this page here\n  }\n  // always sort free space entries\n  sortFreeSpaceEntries(block);\n}\n\nvoid \nStringRM::\nsortFreeSpaceEntries(char* block) {\n  qsort(block, numFreeSpaceSlots, sizeof(FreeSpaceEntry), FreeSpaceEntryCmpFunc);\n}\n\nunsigned \nStringRM::\ngetNextBlockNum(char* block) {\n  return *(block + nextBlockOffset);\n}\n\nunsigned \nStringRM::\ninsertStringIntoBlock(BufferEntry* bufferEntry, const string& s) {\n  // implement first fit policy\n  char* block = bufferEntry->data;\n  FreeSpaceEntry* entry = (FreeSpaceEntry*)block;\n  if(entry->freeSpace < s.size()+sizeof(unsigned)) return NO_SPACE_IN_BLOCK; //means there is not enough space    \n  // try to add entry in dictionary\n  unsigned insertedSlot = 0;\n  unsigned slotCounter;\n  for(slotCounter = 0; slotCounter < numDictSlots; slotCounter++) {\n    unsigned* dictEntry = (unsigned*)(block + dictOffset + slotCounter * sizeof(unsigned));\n    if(*dictEntry == UNUSED_DICT_SLOT) {\n      *dictEntry = entry->offset;\n      insertedSlot = slotCounter;\n      break;\t\n    }\n  }\n  if(slotCounter == numDictSlots) return NO_SPACE_IN_BLOCK;\n  \n  // add data to block\n  unsigned strLength = s.size();\n  const char* rawData = s.c_str();\n  memcpy(block + entry->offset, &strLength, sizeof(unsigned)); \n  memcpy(block + entry->offset + sizeof(unsigned), rawData, strLength);\n  \n  // modify free space entry, TODO: merge adjacent free space blocks\n  entry->freeSpace = entry->freeSpace - strLength - 4;\n  entry->offset = entry->offset + strLength + 4;\n  sortFreeSpaceEntries(block);    \n  \n  // set dirty bit\n  bufferEntry->dirty = true;\n  \n  return insertedSlot;\n}\n\nvoid \nStringRM::\ninsertStringIntoLastBlock(const string& s, RecordID& rid) {\n  unsigned retVal = 0;\n  BufferEntry* block = bufferManager->getBlock(lastFileBlock);\n  retVal = insertStringIntoBlock(block, s);\n  if(retVal == NO_SPACE_IN_BLOCK) {    \n    lastFileBlock++;\n    block = bufferManager->getBlock(lastFileBlock, true);        \n    initDiskBlock(block->data);\n    retVal = insertStringIntoBlock(block, s);\n  }\n  rid.blockNum = lastFileBlock;\n  rid.slotNum = retVal;\n}\n\nvoid \nStringRM::\nretrieveString(string& target, const RecordID& rid) {     \n  BufferEntry* entry = bufferManager->getBlock(rid.blockNum);\n  char* block = entry->data;\n  unsigned strOffset;\n  memcpy(&strOffset, block + dictOffset + rid.slotNum * sizeof(unsigned), sizeof(unsigned));\n  unsigned strLen;\n  memcpy(&strLen, block + strOffset, sizeof(unsigned));\n  target.assign(block + strOffset + sizeof(unsigned), strLen);    \n}\n\nvoid \nStringRM::\ninsertString(const string& s, RecordID& rid) {  \n  unsigned freeBlock = freeSpaceManager->getBlockWithSpace(s.size() + sizeof(unsigned));  \n  if(freeBlock == NO_SPACE_IN_BLOCK) {\n    insertStringIntoLastBlock(s, rid);\n  }\n  else {\n    BufferEntry* block = bufferManager->getBlock(freeBlock);\n    insertStringIntoBlock(block, s);\n  }\n}\n\nStringRM::\nStringRM(unsigned bufferSlots)\n  : blockSize(0), numDictSlots(0), numFreeSpaceSlots(0), dictOffset(0),\n    nextBlockOffset(0), lastFileBlock(1), bufferSlots(bufferSlots),\n    freeSpaceManager(NULL), bufferManager(NULL) {}\n\nvoid \nStringRM::\ncreateStringCollection(const char* fileName, const unsigned blockSize, const unsigned avgstrlen) {\n  if(file.is_open()) file.close();\n  file.open(fileName, ios::in | ios::out | fstream::trunc);\n  if(!file.is_open()) cout << \"ERROR: COULD NOT OPEN FILE: \" << fileName << endl;\n  this->blockSize = blockSize;\n  this->numDictSlots = blockSize / (avgstrlen + sizeof(unsigned));\n  this->numFreeSpaceSlots = this->numDictSlots / 2;\n  this->dictOffset = blockSize - sizeof(unsigned) - numDictSlots * sizeof(unsigned);\n  this->nextBlockOffset = blockSize - sizeof(unsigned);\n  this->lastFileBlock = 1; \n  if(freeSpaceManager) delete freeSpaceManager;\n  freeSpaceManager = new FreeSpaceManager();\n  if(bufferManager) delete bufferManager;\n  bufferManager = new BufferManagerRM(&file, blockSize, bufferSlots); \n  BufferEntry* entry = bufferManager->getBlock(0, true);\n  writeCollectionDescr(entry->data);\n  entry->dirty = true;\n  entry = bufferManager->getBlock(1, true);\n  initDiskBlock(entry->data);\n  entry->dirty = true;\n  bufferManager->flushBuffer();\n  file.close();\n}\n\nvoid \nStringRM::\nopenStringCollection(const char* fileName, bool disableStreamBuffer) {\n  if(file.is_open()) file.close();\n  if(disableStreamBuffer) file.rdbuf()->pubsetbuf(0, 0);\n  file.open(fileName, ios::in | ios::out);\n  if(!file.is_open()) cout << \"ERROR: COULD NOT OPEN FILE: \" << fileName << endl;\n  readCollectionDescr();\n  if(freeSpaceManager) delete freeSpaceManager;\n  freeSpaceManager = new FreeSpaceManager();  \n  if(bufferManager) delete bufferManager;\n  bufferManager = new BufferManagerRM(&file, blockSize, bufferSlots);\n}\n\nvoid \nStringRM::\nwriteCollectionDescr(char* block) {\n  char* runner = block;\n  memset(block, 0, this->blockSize);\n  memcpy(runner, (void*)&this->blockSize, sizeof(unsigned));\n  runner += sizeof(unsigned);\n  memcpy(runner, (void*)&this->numDictSlots, sizeof(unsigned));\n  runner += sizeof(unsigned);\n  memcpy(runner, &this->numFreeSpaceSlots, sizeof(unsigned));\n  runner += sizeof(unsigned);\n  memcpy(runner, &this->dictOffset, sizeof(unsigned));\n  runner += sizeof(unsigned);\n  memcpy(runner, &this->nextBlockOffset, sizeof(unsigned));\n  runner += sizeof(unsigned);\n  memcpy(runner, &this->lastFileBlock, sizeof(unsigned));\n  runner += sizeof(unsigned);\n  memcpy(runner, &this->bufferSlots, sizeof(unsigned));\n}\n\nvoid\nStringRM::\nreadCollectionDescr() {  \n  file.seekp(0);\n  file.read((char*)&this->blockSize, sizeof(unsigned));\n  file.read((char*)&this->numDictSlots, sizeof(unsigned));\n  file.read((char*)&this->numFreeSpaceSlots, sizeof(unsigned));\n  file.read((char*)&this->dictOffset, sizeof(unsigned));\n  file.read((char*)&this->nextBlockOffset, sizeof(unsigned));\n  file.read((char*)&this->lastFileBlock, sizeof(unsigned));\n  file.read((char*)&this->bufferSlots, sizeof(unsigned));\n}\n\n// forces flushing of cache to disk\nvoid \nStringRM::\nflushCache() {\n  // update the meta information\n  BufferEntry* descrEntry = bufferManager->getBlock(0);\n  writeCollectionDescr(descrEntry->data);\n  // flush dirty pages\n  bufferManager->flushBuffer();  \n}\n\nbool\nStringRM::\ninCache(const RecordID& rid) {     \n  return bufferManager->inCache(rid.blockNum);\n}\n\nStringRM::\n~StringRM() {\n  if(file.is_open()) file.close();\n  if(freeSpaceManager) delete freeSpaceManager;\n  if(bufferManager) {\n    bufferManager->flushBuffer();\n    delete bufferManager;\n  }\n}\n", "encoding": "ascii"}