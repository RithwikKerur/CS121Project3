{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/topk/src/perftest_exps.cc", "content": "/*\n  $Id: perftest_exps.cc 5776 2010-10-20 01:34:22Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the BSD\n  license\n\n  Date: 07/21/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"perftest_exps.h\"\n\n#define DEBUG_TIMER\n\n#include \"util/src/io.h\"\n#include \"util/src/misc.h\"\n#include \"util/src/debug.h\"\n\n#include <iomanip>\n\nusing namespace std;\nusing namespace Topk;\n\nvoid exp_xDataSize_yTime_Group(\n  SimMetric &simMetric, \n  PerfDataName dataName, \n  uint noDataStart, \n  uint noDataStop, \n  uint noDataStep,\n  uint noGroupKwd, \n  uint noGroupEd)\n{\n  cerr << \"exp_xDataSize_yTime_Group \" \n       << getDataName(dataName)\n       << '(' \n       << utosh(noDataStart) << \", \"\n       << utosh(noDataStop) << \", \"\n       << utosh(noDataStep) << \") \"\n       << noGroupKwd << ' '\n       << noGroupEd\n       << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  uint **topks;\n  topks = new uint*[noGroupKwd];\n  for (uint i = 0; i < noGroupKwd; ++i)\n    topks[i] = new uint[noAns];\n\n  for (uint noData = noDataStart; noData <= noDataStop; noData += noDataStep) {\n    cerr << \"noData \" << utosh(noData) << endl;\n\n    PerfData data(simMetric.gramGen, dataName, noData);\n    PerfQue que(data, noQue, noData, noGroupKwd, noGroupEd);\n    PerfIndex index(data, simMetric.gramGen, 0);\n\n    uint jMax = 3;\n    float t = 0;\n\n    TIMER_START(\"exps\", jMax);\n    for (uint j = 0; j < jMax; j++) {\n\n      TIME_START;\n      for (uint i = 0; i < que.no - que.no % noGroupKwd; i += noGroupKwd) {\n        QueryGroup queGrp(que.que.begin() + i, noGroupKwd, simMetric, noAns);\n        IndexQuery indexQuery(index.index, queGrp);\n        Topk::Heap::getTopks(\n          data.data, \n          data.weights, \n          index.index, \n          queGrp, \n          indexQuery, \n          topks);\n      }\n      TIME_END;\n      t += _tms / ((que.no - que.no % noGroupKwd) / noGroupKwd);\n\n      TIMER_STEP();\n    }\n    TIMER_STOP();\n\n    float s = t / jMax;\n    cout << noData << \" \" << s << endl;\n    cerr << s << \"ms/que\" << endl;\n  }\n  cerr << \"OK\" << endl;  \n}\n\nvoid exp_xQue_yThr(\n  SimMetric &simMetric, \n  Alg alg,\n  PerfDataName dataName, \n  uint noData)\n{\n  cerr << \"exp_xQue_yThr \" \n       << getAlgName(alg) << ' '\n       << getDataName(dataName) << ' '\n       << utosh(noData)\n       << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  PerfData data(simMetric.gramGen, dataName, noData);\n  PerfQue que(data, noQue);\n  PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n  uint topk[noAns];\n\n  uint kmax = 5;\n  \n  for (uint i = 0; i < que.no; ++i) \n  {\n    Query query(que.que[i], simMetric, noAns);\n      \n    set<uint> gramsQue;\n    query.sim.gramGen.decompose(query.str, gramsQue);\n    IndexQuery_v1 idxQue_v1;\n\n    float invListAvgSize = 0;\n    vector<uint> invListSizes;\n    uint invListMaxSize = 0, invListMinSize = ~0;\n\n    for (set<uint>::const_iterator gram = gramsQue.begin();\n         gram != gramsQue.end(); ++gram) {\n      Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n      idxQue_v1.push_back(ptr);\n\n      uint sz = ptr->size();\n      invListAvgSize += sz;\n      invListSizes.push_back(sz);\n      if (sz > invListMaxSize)\n        invListMaxSize = sz;\n      if (sz < invListMinSize)\n        invListMinSize = sz;\n    }\n    gramsQue.clear();\n    sort(invListSizes.begin(), invListSizes.end());\n    \n    cout << invListAvgSize / query.noGrams << ' ';\n    cout << invListSizes[query.noGrams / 2] << ' ';\n    cout << invListMaxSize - invListMinSize << ' ';\n    cout << query.noGrams << ' ';\n\n    float timeMin = numeric_limits<float>::max();\n    uint thresholdBest = ~0;\n\n    for (thresholdInit = query.noGrams + 1; thresholdInit > 0; --thresholdInit) \n      {\n      TIME_START;\n      for (uint k = 0; k < kmax; ++k)\n        runAlg_v1(\n          AlgTwoPhase,\n          data.data, \n          data.weights, \n          data.nograms, \n          index.index_v1, \n          query, \n          idxQue_v1, \n          topk);\n      TIME_END;\n      cerr << setw(2) << thresholdInit \n           << setw(20) << _tms / kmax << \"ms\"\n           << endl;\n      if (_tms < timeMin) {\n        timeMin = _tms;\n        thresholdBest = thresholdInit;\n      }\n      if (_tms > timeMin + 50 * kmax)\n          break;\n    }\n    cerr << endl;\n    cout << thresholdBest << endl;\n  }\n\n  cerr << \"OK\" << endl;\n}\n\nvoid exp_xQue_yTime_zThr(\n  SimMetric &simMetric, \n  Alg alg,\n  PerfDataName dataName, \n  uint noData)\n{\n  cerr << \"exp_xThr_yTime_zAlg_QueSel \" \n       << getAlgName(alg) << ' '\n       << getDataName(dataName) << ' '\n       << utosh(noData)\n       << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  PerfData data(simMetric.gramGen, dataName, noData);\n  PerfQue que(data, noQue);\n  PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n  \n  uint jMax = 10, k = 0;\n  uint topk[noAns];\n\n  TIMER_START(\"exps\", 3);\n  for (uint i = 0; i < que.no; i += 34) {\n    if (i != 0) {\n      cout << ++k << \" 0\" << endl;\n      cout << ++k << \" 0\" << endl;\n    }\n\n    Query query(que.que[i], simMetric, noAns);\n    for (thresholdInit = query.noGrams + 1; thresholdInit > 0; --thresholdInit) {\n\n      TIME_START;\n      for (uint j = 0; j < jMax; j++)\n        if (alg == AlgRoundRobin || alg == AlgHeap) {\n          IndexQuery indexQuery(index.index, query);\n          runAlg(\n            alg, \n            data.data, \n            data.weights, \n            data.nograms, \n            index.index, \n            query, \n            indexQuery, \n            topk);\n        }\n        else {\n          set<uint> gramsQue;\n          query.sim.gramGen.decompose(query.str, gramsQue);\n          IndexQuery_v1 idxQue_v1;\n          for (set<uint>::const_iterator gram = gramsQue.begin();\n               gram != gramsQue.end(); ++gram) {\n            Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n            idxQue_v1.push_back(ptr);\n          }\n          gramsQue.clear();\n          runAlg_v1(\n            alg, \n            data.data, \n            data.weights, \n            data.nograms, \n            index.index_v1, \n            query, \n            idxQue_v1, \n            topk);\n        }\n      TIME_END;\n\n      float s = _tms / jMax;\n      cout << ++k << ' ' << s \n        // << ' ' << topk[0] \n           << endl;\n    }\n\n    TIMER_STEP();\n  }\n  TIMER_STOP();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid exp_PerfThr_Time(\n  SimMetric &simMetric,  \n  Alg alg, \n  PerfDataName dataName, \n  uint noDataStart, \n  uint noDataStop, \n  uint noDataStep, \n  const string &scoreName)\n{\n  cerr << \"exp_PerfThr_Time \" \n       << getAlgName(alg) << ' '\n       << getDataName(dataName)\n       << '(' \n       << utosh(noDataStart) << \", \"\n       << utosh(noDataStop) << \", \"\n       << utosh(noDataStep) << \")\"\n       << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  for (uint noData = noDataStart; noData <= noDataStop; noData += noDataStep) {\n    cerr << \"noData \" << utosh(noData) << endl;\n\n    PerfData data(simMetric.gramGen, dataName, noData);\n    PerfQue que(data, noQue);\n    PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n    uint topk[noAns];\n    uint thr[que.no];\n\n    TIMER_START(\"exps\", que.no);\n    for (uint i = 0; i < que.no; i++) {\n      Query query(que.que[i], simMetric, noAns);\n      set<uint> gramsQue;\n      query.sim.gramGen.decompose(query.str, gramsQue);\n      IndexQuery_v1 idxQue_v1;\n      for (set<uint>::const_iterator gram = gramsQue.begin();\n           gram != gramsQue.end(); ++gram) {\n        Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n        idxQue_v1.push_back(ptr);\n      }\n      gramsQue.clear();\n\n      float tmin = numeric_limits<float>::max();\n      thr[i] = query.noGrams + 1;\n      for (thresholdInit = query.noGrams + (alg == AlgTwoPhase ? 1 : 0); \n           thresholdInit > 0; --thresholdInit) {\n        TIME_START;\n        runAlg_v1(\n          alg, \n          data.data, \n          data.weights, \n          data.nograms, \n          index.index_v1, \n          query, \n          idxQue_v1, \n          topk);\n        TIME_END;\n\n        if (_tms < tmin) {\n          thr[i] = thresholdInit;\n          tmin = _tms;\n        }\n      }\n      TIMER_STEP();\n    }\n    TIMER_STOP();\n\n    string fn = data.fn.substr(0, data.fn.rfind('.')) + \n      \"/que/data.\" + utosh(data.no) + \n      \".que.\" + utosh(que.no) + \n      \".\" + scoreName +\n      \".q.\" + utos(simMetric.gramGen.getGramLength()) + \n      \".\" + simMetric.name + \n      \".thr.\" + getAlgName(alg) + \".bin\";\n    writeBinaryFile<uint>(fn, thr, thr + que.no);\n  }\n  cerr << \"OK\" << endl;  \n}\n\nvoid exp_PerfThr_Iter(\n  SimMetric &simMetric, \n  PerfDataName dataName, \n  uint noDataStart, \n  uint noDataStop, \n  uint noDataStep, \n  const string &scoreName)\n{\n  cerr << \"exp_PerfThr_Iter \" \n       << getDataName(dataName)\n       << '(' \n       << utosh(noDataStart) << \", \"\n       << utosh(noDataStop) << \", \"\n       << utosh(noDataStep) << \")\"\n       << endl;\n\n  Alg alg = AlgIterative;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  for (uint noData = noDataStart; noData <= noDataStop; noData += noDataStep) {\n    cerr << \"noData \" << utosh(noData) << endl;\n\n    PerfData data(simMetric.gramGen, dataName, noData);\n    PerfQue que(data, noQue);\n    PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n    uint topk[noAns];\n    uint thr[que.no];\n\n    TIMER_START(\"exps\", que.no);\n    for (uint i = 0; i < que.no; i++) {\n      Query query(que.que[i], simMetric, noAns);\n      set<uint> gramsQue;\n      query.sim.gramGen.decompose(query.str, gramsQue);\n      IndexQuery_v1 idxQue_v1;\n      for (set<uint>::const_iterator gram = gramsQue.begin();\n           gram != gramsQue.end(); ++gram) {\n        Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n        idxQue_v1.push_back(ptr);\n      }\n      gramsQue.clear();\n\n      float tmin = numeric_limits<float>::max();\n      for (thresholdInit = query.noGrams; thresholdInit > 0; --thresholdInit) {\n        thresholdPerf = false;\n        TIME_START;\n        runAlg_v1(\n          alg, \n          data.data, \n          data.weights, \n          data.nograms, \n          index.index_v1, \n          query, \n          idxQue_v1, \n          topk);\n        TIME_END;\n        \n        if (thresholdPerf) {\n          thr[i] = thresholdInit;\n          tmin = _tms;\n          break;\n        }\n      }\n      TIMER_STEP();\n    }\n    TIMER_STOP();\n    \n    string fn = data.fn.substr(0, data.fn.rfind('.')) + \n      \"/que/data.\" + utosh(data.no) + \n      \".que.\" + utosh(que.no) + \n      \".\" + scoreName +\n      \".q.\" + utos(simMetric.gramGen.getGramLength()) + \n      \".\" + simMetric.name + \n      \".thr.\" + getAlgName(alg) + \".bin\";\n    writeBinaryFile<uint>(fn, thr, thr + que.no);\n  }\n  cerr << \"OK\" << endl;  \n}\n\nvoid exp_xDataSize_yTime_zAlg_Perf(\n  SimMetric &simMetric, \n  Alg alg,\n  PerfDataName dataName, \n  uint noDataStart, \n  uint noDataStop, \n  uint noDataStep, \n  const string &scoreName)\n{\n  cerr << \"exp_xDataSize_yTime_zAlg_Perf \" \n       << getAlgName(alg) << ' '\n       << getDataName(dataName)\n       << '(' \n       << utosh(noDataStart) << \", \"\n       << utosh(noDataStop) << \", \"\n       << utosh(noDataStep) << \")\"\n       << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  for (uint noData = noDataStart; noData <= noDataStop; noData += noDataStep) {\n    cerr << \"noData \" << utosh(noData) << endl;\n\n    PerfData data(simMetric.gramGen, dataName, noData);\n    PerfQue que(data, noQue);\n    PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n    uint thr[que.no];\n    string fn = data.fn.substr(0, data.fn.rfind('.')) + \n      \"/que/data.\" + utosh(data.no) + \n      \".que.\" + utosh(que.no) + \n      \".\" + scoreName +\n      \".q.\" + utos(simMetric.gramGen.getGramLength()) + \n      \".\" + simMetric.name + \n      \".thr.\" + getAlgName(alg) + \".bin\";\n    readBinaryFile<uint>(fn, thr);\n\n    uint jMax = 10;\n    float t = 0;\n    uint topk[noAns];\n\n    TIMER_START(\"exps\", jMax);\n    for (uint j = 0; j < jMax; j++) {\n\n      TIME_START;\n      if (alg == AlgRoundRobin || alg == AlgHeap)\n        for (uint i = 0; i < que.no; i++) {\n          Query query(que.que[i], simMetric, noAns);\n          thresholdInit = thr[i];\n        \n          IndexQuery indexQuery(index.index, query);\n          runAlg(\n            alg, \n            data.data, \n            data.weights, \n            data.nograms, \n            index.index, \n            query, \n            indexQuery, \n            topk);\n        }\n      else\n        for (uint i = 0; i < que.no; i++) {\n          Query query(que.que[i], simMetric, noAns);\n          thresholdInit = thr[i];\n        \n          set<uint> gramsQue;\n          query.sim.gramGen.decompose(query.str, gramsQue);\n          IndexQuery_v1 idxQue_v1;\n          for (set<uint>::const_iterator gram = gramsQue.begin();\n               gram != gramsQue.end(); ++gram) {\n            Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n            idxQue_v1.push_back(ptr);\n          }\n          gramsQue.clear();\n          runAlg_v1(\n            alg, \n            data.data, \n            data.weights, \n            data.nograms, \n            index.index_v1, \n            query, \n            idxQue_v1, \n            topk);\n        }\n      TIME_END;\n      t += _tms / que.no;\n\n      TIMER_STEP();\n    }\n    TIMER_STOP();\n\n    float s = t / jMax;\n    cout << noData << \" \" << s << endl;\n    cerr << s << \"ms/que\" << endl;\n  }\n  cerr << \"OK\" << endl;  \n}\n\nvoid exp_xDataSize_yTime_zAlg(\n  SimMetric &simMetric, \n  Alg alg,\n  PerfDataName dataName, \n  uint noDataStart, \n  uint noDataStop, \n  uint noDataStep)\n{\n  cerr << \"exp_xDataSize_yTime_zAlg \" \n       << getAlgName(alg) << ' '\n       << getDataName(dataName)\n       << '(' \n       << utosh(noDataStart) << \", \"\n       << utosh(noDataStop) << \", \"\n       << utosh(noDataStep) << \")\"\n       << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  for (uint noData = noDataStart; noData <= noDataStop; noData += noDataStep) {\n    cerr << \"noData \" << utosh(noData) << endl;\n\n    PerfData data(simMetric.gramGen, dataName, noData);\n    PerfQue que(data, noQue);\n    PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n    uint jMax = 10;\n    float t = 0;\n    uint topk[noAns];\n\n    TIMER_START(\"exps\", jMax);\n    for (uint j = 0; j < jMax; j++) {\n\n      TIME_START;\n      if (alg == AlgRoundRobin || alg == AlgHeap)\n        for (uint i = 0; i < que.no; i++) {\n          Query query(que.que[i], simMetric, noAns);\n          thresholdInit = query.noGrams;\n        \n          IndexQuery indexQuery(index.index, query);\n          runAlg(\n            alg, \n            data.data, \n            data.weights, \n            data.nograms, \n            index.index, \n            query, \n            indexQuery, \n            topk);\n        }\n      else\n        for (uint i = 0; i < que.no; i++) {\n          Query query(que.que[i], simMetric, noAns);\n          thresholdInit = query.noGrams;\n\n          set<uint> gramsQue;\n          query.sim.gramGen.decompose(query.str, gramsQue);\n          IndexQuery_v1 idxQue_v1;\n          for (set<uint>::const_iterator gram = gramsQue.begin();\n               gram != gramsQue.end(); ++gram) {\n            Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n            idxQue_v1.push_back(ptr);\n          }\n          gramsQue.clear();\n\n          runAlg_v1(\n            alg, \n            data.data, \n            data.weights, \n            data.nograms, \n            index.index_v1, \n            query, \n            idxQue_v1, \n            topk);\n        }\n      TIME_END;\n      t += _tms / que.no;\n\n      TIMER_STEP();\n    }\n    TIMER_STOP();\n\n    float s = t / jMax;\n    cout << noData << \" \" << s << endl;\n    cerr << s << \"ms/que\" << endl;\n  }\n  cerr << \"OK\" << endl;  \n}\n", "encoding": "ascii"}