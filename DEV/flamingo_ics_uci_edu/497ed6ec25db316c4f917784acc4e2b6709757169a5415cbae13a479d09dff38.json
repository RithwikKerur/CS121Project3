{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/filtertree/unittest.cc", "content": "/*\n  $Id: unittest.cc 5146 2010-03-24 23:05:57Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 04/04/2008\n  Author: Alexander Behm\n*/\n\n#include \"ftindexerholesglobal.h\"\n#include \"ftindexerunionglobal.h\"\n#include \"ftsearchermem.h\"\n#include \"common/query.h\"\n#include \"common/simmetric.h\"\n#include \"listmerger/divideskipmerger.h\"\n#include \"listmerger/scancountmerger.h\"\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\nusing namespace tr1;\n\n// ASSUMPTIONS: uncompressed indexer with no filters delivers correct results\n// it will be used to fill expectedResults\n\n// global vars for performing unittests\nStringContainerVector strContainer;\nvector<Query*> queries;\nvector<string> queryStrings;\nvector<unsigned> expectedResults;\nGramGenFixedLen gramGen(3);\nSimMetricEd simMetric(gramGen);\n\nvoid init();\nvoid deinit();\nbool compareResults(vector<unsigned>& results, const string& identifier);\n\nbool testFtIndexerMem();\nbool testFtIndexerHolesGlobalLLF();\nbool testFtIndexerHolesGlobalSLF();\nbool testFtIndexerHolesGlobalRandom();\nbool testFtIndexerHolesGlobalTimeCost();\nbool testFtIndexerHolesGlobalTimeCostPlus();\nbool testFtIndexerHolesGlobalPanicCost();\nbool testFtIndexerHolesGlobalPanicCostPlus();\nbool testFtIndexerUnionGlobalBasic();\nbool testFtIndexerUnionGlobalCost();\n\nint main() {\n  init();\n\n  bool passed = false;\n\n  cout << \"NOTE: THESE TESTS MAY TAKE SOME MINUTES, PLEASE BE PATIENT\" << endl << endl;\n\n  cout << \"TEST FtIndexerMem:\" << endl;\n  passed = testFtIndexerMem();  \n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;\n  cout << endl;\n\n  cout << \"TEST FtIndexerHolesGlobalLLF:\" << endl;  \n  passed = testFtIndexerHolesGlobalLLF();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n  \n  cout << \"TEST FtIndexerHolesGlobalSLF:\" << endl;  \n  passed = testFtIndexerHolesGlobalSLF();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerHolesGlobalRandom:\" << endl;  \n  passed = testFtIndexerHolesGlobalRandom();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerHolesGlobalTimeCost:\" << endl;  \n  passed = testFtIndexerHolesGlobalTimeCost();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerHolesGlobalTimeCostPlus:\" << endl;  \n  passed = testFtIndexerHolesGlobalTimeCostPlus();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerHolesGlobalPanicCost:\" << endl;  \n  passed = testFtIndexerHolesGlobalPanicCost();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerHolesGlobalPanicCostPlus:\" << endl;  \n  passed = testFtIndexerHolesGlobalPanicCostPlus();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerUnionGlobalBasic:\" << endl;  \n  passed = testFtIndexerUnionGlobalBasic();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerUnionGlobalCost:\" << endl;  \n  passed = testFtIndexerUnionGlobalCost();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  deinit();\n  return 0;\n}\n\nvoid init() {\n  cout << \"INITIALIZING UNITTEST\" << endl;\n\n  vector<string> prefixes;\n  prefixes.push_back(\"string\");\n  prefixes.push_back(\"example\");  \n  prefixes.push_back(\"test\");\n  prefixes.push_back(\"hello\");\n  prefixes.push_back(\"world\");\n  prefixes.push_back(\"foo\");\n  prefixes.push_back(\"bar\");\n  \n  vector<string> suffixes;\n  suffixes.push_back(\"1\");\n  suffixes.push_back(\"10\");\n  suffixes.push_back(\"100\");\n  suffixes.push_back(\"2\");\n  suffixes.push_back(\"20\");\n  suffixes.push_back(\"200\");\n  suffixes.push_back(\"3\");\n  suffixes.push_back(\"30\");\n  suffixes.push_back(\"300\");\n  \n  for(unsigned j = 0; j < prefixes.size(); j++)\n    for(unsigned i = 0; i < suffixes.size(); i++)\n      strContainer.insertString(prefixes.at(j) + suffixes.at(i));\n  \n  // create queries\n  queries.push_back(new Query(\"xample\", simMetric, 2.0f));\n  queries.push_back(new Query(\"ring1\", simMetric, 2.0f));\n  queries.push_back(new Query(\"wrld\", simMetric, 2.0f));\n  queries.push_back(new Query(\"fooa\", simMetric, 2.0f));\n  queries.push_back(new Query(\"br\", simMetric, 2.0f));  \n\n  for(unsigned i = 0; i < 10; i++) {\n    queryStrings.push_back(\"xample\");\n    queryStrings.push_back(\"ring1\");\n    queryStrings.push_back(\"wrld\");\n    queryStrings.push_back(\"fooa\");\n    queryStrings.push_back(\"br\");\n  }\n\n  // execute queries on uncompressed index without filters to get expected results\n  FtIndexerMem<> indexer(&strContainer, &gramGen);\n  indexer.buildIndex(false);      \n  DivideSkipMerger<> merger;\n  FtSearcherMem<> searcher(&merger, &indexer);\n\n  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n    searcher.search(**iter, expectedResults);\n    \n  // sort expected results\n  sort(expectedResults.begin(), expectedResults.end());\n  \n  cout << \"UNITTEST INITIALIZED\" << endl << endl;\n}\n\nvoid deinit() {\n  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n    delete *iter;  \n}\n\nbool compareResults(vector<unsigned>& results, const string& identifier) {\n  // compare results\n  sort(results.begin(), results.end());\n  if(results.size() != expectedResults.size()) {\n    cout << \"FAILED IN \" << identifier << endl;\n    return false;\n  }\n\n  for(unsigned i = 0; i < results.size(); i++)\n    if(results.at(i) != expectedResults.at(i)) {\n      cout << \"FAILED IN \" << identifier << endl;\n      return false;\n    }\n\n  return true;\n}\n\nbool testFtIndexerMem() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<> searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      vector<unsigned> results;      \n\n      // begin block for indexer with lengthfilter\n      {\n\tFtIndexerMem<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addPartFilter(new LengthFilter(maxStrLength));\n\tindexer.buildIndex(false);      \n\n\t// execute queries and compute results\n\tresults.clear();\n\tsearcher.setFtIndexer(&indexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerMem<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t  cout << \"FtIndexerMem, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH FILTER LOADED\");\n      }\n\n      // begin block for indexer with checksum filter\n      {\n\tFtIndexerMem<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addPartFilter(new CharsumFilter(maxStrLength));\n\tindexer.buildIndex(false);      \n\n\t// execute queries and compute results\n\tsearcher.setFtIndexer(&indexer);\t\n\tresults.clear();\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, CHECKSUM FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerMem<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t  cout << \"FtIndexerMem, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, CHECKSUM FILTER LOADED\");\n      }\n\n      // begin block for indexer with both length and checksum filters\n      {\n\tFtIndexerMem<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addPartFilter(new LengthFilter(maxStrLength));\n\tindexer.addPartFilter(new CharsumFilter(maxStrLength));\n\tindexer.buildIndex(false);      \n\n\t// execute queries and compute results\n\tsearcher.setFtIndexer(&indexer);      \n\tresults.clear();\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH+CHECKSUM FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerMem<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t   && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t  cout << \"FtIndexerMem, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH FILTER LOADED\");\n      }\n\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerHolesGlobalLLF() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalLLF<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalLLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalLLF, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalLLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalLLF, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalLLF, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalLLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalLLF, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalLLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalLLF, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalLLF, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalLLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalLLF, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalLLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalLLF, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalLLF, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerHolesGlobalSLF() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalSLF<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalSLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalSLF, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalSLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalSLF, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalSLF, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalSLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalSLF, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalSLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalSLF, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalSLF, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalSLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalSLF, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalSLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalSLF, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalSLF, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerHolesGlobalRandom() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalRandom<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalRandom<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalRandom, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalRandom<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalRandom, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalRandom, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalRandom<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalRandom, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalRandom<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalRandom, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalRandom, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalRandom<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalRandom, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalRandom<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalRandom, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalRandom, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerHolesGlobalTimeCost() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalTimeCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCost, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalTimeCost, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCost, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCost, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalTimeCost, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCost, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCost, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalTimeCost, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCost, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\n\nbool testFtIndexerHolesGlobalTimeCostPlus() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalTimeCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCostPlus, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalTimeCostPlus, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCostPlus, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalTimeCostPlus, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCostPlus, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCostPlus, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalTimeCostPlus, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalTimeCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerHolesGlobalPanicCost() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalPanicCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCost, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalPanicCost, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCost, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCost, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalPanicCost, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCost, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCost, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalPanicCost, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCost, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerHolesGlobalPanicCostPlus() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerHolesGlobalPanicCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerHolesGlobalPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCostPlus, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerHolesGlobalPanicCostPlus, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerHolesGlobalPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCostPlus, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalPanicCostPlus, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCostPlus, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerHolesGlobalPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCostPlus, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerHolesGlobalPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerHolesGlobalPanicCostPlus, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerHolesGlobalPanicCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerUnionGlobalBasic() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger(true);\n  \n  FtSearcherMem<FtIndexerUnionGlobalBasic<> > searcher(&merger);\n  \n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerUnionGlobalBasic<> indexer(&strContainer, &gramGen, compressionRatio, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalBasic, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerUnionGlobalBasic<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerUnionGlobalBasic, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\t  \n\n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalBasic, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerUnionGlobalBasic<> indexer(&strContainer, &gramGen, compressionRatio, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalBasic, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerUnionGlobalBasic<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerUnionGlobalBasic, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalBasic, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerUnionGlobalBasic<> indexer(&strContainer, &gramGen, compressionRatio, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalBasic, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerUnionGlobalBasic<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerUnionGlobalBasic, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalBasic, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerUnionGlobalCost() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<FtIndexerUnionGlobalCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerUnionGlobalCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalCost, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerUnionGlobalCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerUnionGlobalCost, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalCost, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerUnionGlobalCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalCost, CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerUnionGlobalCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerUnionGlobalCost, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalCost, CHECKSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerUnionGlobalCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex(false);      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalCost, LENGTH+CHECKSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerUnionGlobalCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerUnionGlobalCost, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerUnionGlobalCost, LENGTH FILTER LOADED\");\n\t}\t\n      }\n    }\n  }\n\n  return success;\n}\n", "encoding": "ascii"}