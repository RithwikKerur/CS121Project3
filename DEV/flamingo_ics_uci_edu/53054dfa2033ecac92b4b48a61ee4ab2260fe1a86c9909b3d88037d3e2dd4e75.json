{"url": "http://flamingo.ics.uci.edu/releases/1.0/src/filtertree/buckethead.cc", "content": "/* \n$Id$\n\nCopyright (C) 2007 by The Regents of the University of California\n\nRedistribution of this file is permitted under\nthe terms of the *GNU* Public License (*GPL*) \t\n\nDate: 04/08/2007\nAuthor: Yiming Lu <yimingl@ics.uci.edu>\n*/\n\n#include \"buckethead.h\"\n\nBuckets::Buckets( )\n{\n    map = new HashTable();       \n}\n\n\nBuckets::~Buckets()\n{\n\tif(map != NULL)\n    {\n   \t /*\n      *  loop through entire table\n   \t  */\n        HashTable::const_iterator iter;\n        for ( iter = map->begin(); iter != map->end(); iter++ )\n        {\n        \tdelete iter->second;\n        }\n        delete map;\n    }\n}\n\n\nvoid Buckets::addToHashTable(const char *gram, \n\t\t\t\t\t\t\t unsigned stringID, \n\t\t\t\t\t\t\t unsigned short position, \n\t\t\t\t\t\t\t unsigned short stringLength)\n{\n    string tempGram(gram);\n    //get the hashcode for gram\n    unsigned key = hashString(tempGram);\t\t\t   \n    \n    HashTable::const_iterator iter;\n    iter = map->find(key);\t\n    //If the index doesn't have such gram \n    if ( iter == map->end() )\n    {\n        LengthBucket *bucket = new LengthBucket(stringID,\n                                                position, \n\t\t\t\t\t\t\t\t\t\t\t    stringLength);\n\t    map->insert(make_pair(key, bucket));\n    }   \n    //If the index already has such gram\n    else \n    {\n        LengthBucket *bucket = (LengthBucket*)iter->second;\n\t    bucket->insertIntoGroups(stringID, position, stringLength);\n    }      \n}\n\n\nLengthBucket *Buckets::getMatchedBuckets(const char *gram)\n{\n    string tempGram(gram);\n    //get the hashcode for gram\n    unsigned key = hashString(tempGram);\n    //Check to see if the gram is already in bucket \n    HashTable::const_iterator iter;\n    iter = map->find(key);\n    if ( iter != map->end() ) \n    {\n        return \t(LengthBucket*)iter->second;\n    }\n    return NULL;\n}\n\nunsigned Buckets::getMemory()\n{\n    unsigned memOfMap = 8 * (map->size());\n    HashTable::const_iterator iter;\n    for( iter = map->begin(); iter != map->end(); iter++ ) \n    {\n        memOfMap += iter->second->getMemory();\n    }\n    return (memOfMap + sizeof(*this));\n}\n\nostream &operator << (ostream &output, const Buckets & bucket)\n{\n    //num of buckets\n    output << bucket.map->size() <<\" \";\n    //buckets\n    HashTable::const_iterator \titer;\n    for(iter = bucket.map->begin(); iter != bucket.map->end(); iter++) \n    {\n        output << ( iter->first )<<\" \";\n        output <<  *(iter->second) <<\" \";\n    }\n    return output;\n}\n\nistream &operator >> (istream &input, Buckets & bucket)\n{\n\t//num of buckets\t\n    unsigned size;\n    input >> size;\n    //buckets\n    for(unsigned i = 0; i < size; i++) \n    {\n        LengthBucket* lengthBucket = new LengthBucket();\n        unsigned key;\t\t\n\t    input >> key;\n\t    input >> (*lengthBucket);\t\n\t    bucket.map->insert(make_pair(key, lengthBucket));\n    }\n    return input;\t\n}\n\n", "encoding": "ascii"}