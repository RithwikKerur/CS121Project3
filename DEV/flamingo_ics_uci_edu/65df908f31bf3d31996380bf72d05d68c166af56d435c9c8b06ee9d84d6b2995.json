{"url": "http://flamingo.ics.uci.edu/releases/2.0/src/filtertree/unittest.cc", "content": "/*\n  $Id: unittest.cc 4025 2008-10-01 00:01:14Z abehm $\n\n  Copyright (C) 2008 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license\n    \n  Date: 04/04/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"ftsearchermem.h\"\n#include \"common/query.h\"\n#include \"common/simmetric.h\"\n#include \"listmerger/divideskipmerger.h\"\n#include <fstream>\n\nusing namespace std;\nusing namespace tr1;\n\n// global vars for performing unittests\nStringContainerVector strContainer;\nvector<Query*> queries;\nvector<string> queryStrings;\nvector<unsigned> expectedResults;\nGramGenFixedLen gramGen(3);\nSimMetricEd simMetric(gramGen);\n\nvoid init();\nvoid deinit();\nbool compareResults(vector<unsigned>& results, const string& identifier);\n\nbool testFtIndexerSimple();\n\nint main() {\n  init();\n\n  bool passed = false;\n\n  cout << \"NOTE: THESE TESTS MAY TAKE SOME MINUTES, PLEASE BE PATIENT\" << endl << endl;\n\n  cout << \"TEST FtIndexerSimple:\" << endl;\n  passed = testFtIndexerSimple();  \n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;\n  cout << endl;\n\n  deinit();\n  return 0;\n}\n\nvoid init() {\n  cout << \"INITIALIZING UNITTEST\" << endl;\n\n  vector<string> prefixes;\n  prefixes.push_back(\"string\");\n  prefixes.push_back(\"example\");  \n  prefixes.push_back(\"test\");\n  prefixes.push_back(\"hello\");\n  prefixes.push_back(\"world\");\n  prefixes.push_back(\"foo\");\n  prefixes.push_back(\"bar\");\n  \n  vector<string> suffixes;\n  suffixes.push_back(\"1\");\n  suffixes.push_back(\"10\");\n  suffixes.push_back(\"100\");\n  suffixes.push_back(\"2\");\n  suffixes.push_back(\"20\");\n  suffixes.push_back(\"200\");\n  suffixes.push_back(\"3\");\n  suffixes.push_back(\"30\");\n  suffixes.push_back(\"300\");\n  \n  for(unsigned j = 0; j < prefixes.size(); j++)\n    for(unsigned i = 0; i < suffixes.size(); i++)\n      strContainer.insertString(prefixes.at(j) + suffixes.at(i));\n  \n  // create queries\n  queries.push_back(new Query(\"xample\", simMetric, 2.0f));\n  queries.push_back(new Query(\"ring1\", simMetric, 2.0f));\n  queries.push_back(new Query(\"wrld\", simMetric, 2.0f));\n  queries.push_back(new Query(\"fooa\", simMetric, 2.0f));\n  queries.push_back(new Query(\"br\", simMetric, 2.0f));  \n\n  for(unsigned i = 0; i < 10; i++) {\n    queryStrings.push_back(\"xample\");\n    queryStrings.push_back(\"ring1\");\n    queryStrings.push_back(\"wrld\");\n    queryStrings.push_back(\"fooa\");\n    queryStrings.push_back(\"br\");\n  }\n\n  // execute queries on simple index without filters to get expected results\n  FtIndexerSimple<> indexer(&strContainer, &gramGen);\n  indexer.buildIndex(false);      \n  DivideSkipMerger<> merger;\n  FtSearcherMem<> searcher(&merger, &indexer);\n\n  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n    searcher.search(**iter, expectedResults);\n    \n  // sort expected results\n  sort(expectedResults.begin(), expectedResults.end());\n  \n  cout << \"UNITTEST INITIALIZED\" << endl << endl;\n}\n\nvoid deinit() {\n  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n    delete *iter;  \n}\n\nbool compareResults(vector<unsigned>& results, const string& identifier) {\n  // compare results\n  sort(results.begin(), results.end());\n  if(results.size() != expectedResults.size()) {\n    cout << \"FAILED IN \" << identifier << endl;\n    return false;\n  }\n\n  for(unsigned i = 0; i < results.size(); i++)\n    if(results.at(i) != expectedResults.at(i)) {\n      cout << \"FAILED IN \" << identifier << endl;\n      return false;\n    }\n\n  return true;\n}\n\nbool testFtIndexerSimple() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  DivideSkipMerger<> merger;\n  \n  FtSearcherMem<> searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      vector<unsigned> results;      \n\n      // begin block for indexer with lengthfilter\n      {\n\tFtIndexerSimple<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addFilter(new LengthFilter(maxStrLength));\n\tindexer.buildIndex(false);      \n\n\t// execute queries and compute results\n\tresults.clear();\n\tsearcher.setFtIndexer(&indexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerSimple, LENGTH FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerSimple<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t  cout << \"FtIndexerSimple, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerSimple, LENGTH FILTER LOADED\");\n      }\n\n      // begin block for indexer with checksum filter\n      {\n\tFtIndexerSimple<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addFilter(new ChecksumFilter(maxStrLength));\n\tindexer.buildIndex(false);      \n\n\t// execute queries and compute results\n\tsearcher.setFtIndexer(&indexer);\t\n\tresults.clear();\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerSimple, CHECKSUM FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerSimple<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_CHECKSUM) {\n\t  cout << \"FtIndexerSimple, CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerSimple, CHECKSUM FILTER LOADED\");\n      }\n\n      // begin block for indexer with both length and checksum filters\n      {\n\tFtIndexerSimple<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addFilter(new LengthFilter(maxStrLength));\n\tindexer.addFilter(new ChecksumFilter(maxStrLength));\n\tindexer.buildIndex(false);      \n\n\t// execute queries and compute results\n\tsearcher.setFtIndexer(&indexer);      \n\tresults.clear();\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\n\tsuccess = success && compareResults(results, \"FtIndexerSimple, LENGTH+CHECKSUM FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerSimple<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t   && loadedIndexer.filterTypes.at(1)->getType() != FT_CHECKSUM) {\n\t  cout << \"FtIndexerSimple, LENGTH+CHECKSUM FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerSimple, LENGTH FILTER LOADED\");\n      }\n\n    }\n  }\n\n  return success;\n}\n", "encoding": "ascii"}