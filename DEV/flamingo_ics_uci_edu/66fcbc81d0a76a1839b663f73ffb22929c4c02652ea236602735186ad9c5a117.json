{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/filtertree/stringcontainer.cc", "content": "/*\n  $Id: stringcontainer.cc 5229 2010-05-11 05:44:03Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 04/04/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"stringcontainer.h\"\n\n#include \"common/gramgen.h\"\n#include \"common/simmetric.h\"\n#include \"sepia/sepia.h\"\n#include \"util/misc.h\"\n#include <cfloat>\n#include <cstring>\n\ntemplate<>\nStringContainerVector*\ncreateDefaultStringContainer() {\n  return new StringContainerVector(); \n}\n\ntemplate<>\nStringContainerRM*\ncreateDefaultStringContainer() {\n  StringContainerRM* container = new StringContainerRM();\n  container->createContainer(\"default2.rm\");\n  container->openContainer(\"default2.rm\", true);\n  return container;\n}\n\nFilterStats::\nFilterStats(AbstractFilter* filter)\n  : filter(filter) {\n  begin();\n}\n\nvoid \nFilterStats::\nbegin() {\n  minKey = 0xFFFFFFFF;\n  maxKey = 0;\n  wtedAvgValCount = 0;\n  countMap.clear();\n}\n\nvoid\nFilterStats::\nnext(const string& s) {\n  unsigned key = filter->getKey(s);\n  countMap[key]++;\n  if(key < minKey) minKey = key;\n  if(key > maxKey) maxKey = key;\n}\n\nvoid\nFilterStats::\nend(float ed, unsigned strCount) {\n  unsigned start = 0;\n  unsigned stop = 0;        \n  GramGenFixedLen gramGen(3);\n  SimMetricEd sim(gramGen);\n  sim.getFilterBounds(\"\", 1, filter, start, stop);\n  stop = ed * stop;\n  \n  // compute weighted average\n  unsigned valCount = 0;\n  unordered_map<unsigned, unsigned>::iterator iter;   \n  for(unsigned i = minKey; i <= minKey + stop; i++) {\n    iter = countMap.find(i);\n    if(iter != countMap.end()) valCount += iter->second;                  \n  }    \n  float weight = (float)valCount / (float)strCount;\n  float totalWeight = weight;\n  wtedAvgValCount = (float)valCount * weight;\n  \n  for(unsigned i = minKey + stop + 1; i <= maxKey; i++) {\n    unsigned j = i - (minKey + stop + 1);\n    \n    iter = countMap.find(i);\n    if(iter != countMap.end()) valCount += iter->second;                  \n    \n    iter = countMap.find(j);\n    if(iter != countMap.end()) valCount -= iter->second;            \n    \n    if((signed) valCount < 0) valCount = 0;\n    \n    weight = (float)valCount / (float)strCount;\n    totalWeight += weight;\n    wtedAvgValCount += (float)valCount * weight;      \n  }\n  wtedAvgValCount /= totalWeight;\n  \n  countMap.clear();\n}\n\nStatsCollector::\nStatsCollector() {\n  begin();\n}\n\nvoid \nStatsCollector::\nbegin() {\n  avgStrLen = 0;\n  strCount = 0;\n  memset(charFreqs, 0, 256);  \n  \n  clearFilterStats();  \n  filterStats.push_back( new FilterStats(new LengthFilter((unsigned)0)) );\n  filterStats.push_back( new FilterStats(new CharsumFilter((unsigned)0)) );\n}\n\nvoid\nStatsCollector::\nnext(const string& s) {\n  for(unsigned i = 0; i < filterStats.size(); i++)\n    filterStats.at(i)->next(s);\n  \n  avgStrLen += s.size();\n  strCount++;  \n\n  for(unsigned i = 0; i < s.size(); i++) {\n    unsigned char ix = (unsigned char)s[i];\n    charFreqs[ix]++;\n  }\n}\n\nvoid \nStatsCollector::\nend() {      \n  avgStrLen /= (float)strCount;    \n  float ed = (unsigned)(avgStrLen - floor(avgStrLen * 0.85));\n  \n  for(unsigned i = 0; i < filterStats.size(); i++)\n    filterStats.at(i)->end(ed, strCount);\n}\n\nFilterStats*\nStatsCollector::\ngetBestPartFilter() {\n  unsigned bestIx = 0xFFFFFFFF;\n  float bestValCount = FLT_MAX;\n  for(unsigned i = 0; i < filterStats.size(); i++) {\n    float currValCount = filterStats.at(i)->getWtedAvgValCount();\n    if(currValCount < bestValCount) {\n      bestIx = i;\n      bestValCount = currValCount;\n    }\n  }\n  \n  if(bestIx != 0xFFFFFFFF) return filterStats.at(bestIx);\n  else return NULL;\n}\n\nvoid \nStatsCollector::\nclearFilterStats() {\n  for(unsigned i = 0; i < filterStats.size(); i++)\n    if(filterStats.at(i)) delete filterStats.at(i);\n  filterStats.clear();\n}\n\nStatsCollector::  \n~StatsCollector() {\n  clearFilterStats();\n}\n\nvoid\nStringContainerVector::\nfillContainer_Impl(const char* fileName, const unsigned count, const unsigned maxLineLen) {\n  this->fillContainer(this, fileName, count, maxLineLen);\n}\n\nvoid \nStringContainerRM::\nclusterRemap(vector<string>& strs, \n\t     StringAttribs* strAttribs, \n\t     unsigned currentStartIndex,\n\t     unsigned partition) {\n  \n  if(strs.size() == 0) return;\n  \n  // TODO some bug with sepia destructor\n  Sepia* sepia = new Sepia(strs, 1, 4, 10);\n  sepia->build();\n  Clusters* clusters = sepia->getClusters();\n  \n  StringAttribs* newStrAttribs = new StringAttribs[strs.size()];\n  unsigned newAttribCount = 0;\n  for(unsigned j = 0; j < clusters->sizeCluster(); j++) {\n    const Cluster& cluster = clusters->getCluster(j);\n    for(ContCluster::const_iterator iter = cluster.begin(); iter != cluster.end(); iter++) {\n      newStrAttribs[newAttribCount++] = strAttribs[*iter + currentStartIndex];\n    }\t\n  }  \n  \n  // copy new strAttribs back in place\n  memcpy(&strAttribs[currentStartIndex], newStrAttribs, strs.size() * sizeof(StringAttribs));\t\n  delete newStrAttribs;\n}\n\nvoid \nStringContainerRM::\ncopyReorg(StringContainerRM* tempContainer) {\n  \n  CharsumFilter csFilter((unsigned)0);\n  \n  // fill array of string attribs for sorting\n  StringAttribs* strAttribs = new StringAttribs[tempContainer->size()];\n  for(unsigned i = 0; i < tempContainer->size(); i++) {   \n    string currentString;\n    tempContainer->retrieveString(currentString, i);    \n    strAttribs[i].charsum = csFilter.getCharsum(currentString);\n    strAttribs[i].stringId = i;\n    strAttribs[i].length = currentString.size();\n  }\n  \n  // sort collection\n  switch(pho) {\n    \n  case PHO_NONE: break;\n    \n  case PHO_AUTO: {\n    if(gatherStats) {\n      FilterStats* bestFilterStats = statsCollector.getBestPartFilter();\n      switch(bestFilterStats->getFilterType()) {\n\n      case FT_LENGTH: {\n\tqsort(strAttribs, tempContainer->size(), sizeof(StringAttribs), cmpStringAttribsLenCharsum);  \n      } break;\t\n\n      case FT_CHARSUM: {\n\tqsort(strAttribs, tempContainer->size(), sizeof(StringAttribs), cmpStringAttribsCharsumLen);  \n      } break;\t\n\n      case FT_NONE: break;    \n      }\n    }\n    else {\n      cout << \"WARNING: no physical ordering set because container has no stats\" << endl;\n    }\n  } break;\n\n  case PHO_LENGTH: {\n    qsort(strAttribs, tempContainer->size(), sizeof(StringAttribs), cmpStringAttribsLen);  \n  } break;\n\n  case PHO_CHARSUM: {\n    qsort(strAttribs, tempContainer->size(), sizeof(StringAttribs), cmpStringAttribsCharsum);  \n  } break;\n\n  case PHO_LENGTH_CHARSUM: {\n    qsort(strAttribs, tempContainer->size(), sizeof(StringAttribs), cmpStringAttribsLenCharsum);  \n  } break;\n\n  case PHO_CHARSUM_LENGTH: {\n    qsort(strAttribs, tempContainer->size(), sizeof(StringAttribs), cmpStringAttribsCharsumLen);  \n  } break;\n\n  default: {\n    cout << \"WARNING: invalid PhysOrd specified!\" << endl;\n  } break;\n\n  }\n  \n  // cluster partitioned strings using sepia\n  if(partSize && clusters) {\n    unsigned currentStartIndex = 0;\n    unsigned partition = 0;\n    vector<string> strs;\n    TIMER_START(\"CLUSTERING STRINGS\", tempContainer->size() / partSize);\n    for(unsigned i = 0; i < tempContainer->size(); i++) {        \n      string s;\n      tempContainer->retrieveString(s, strAttribs[i].stringId);\n      if(strs.size() >= partSize) {\t\t\n\tclusterRemap(strs, strAttribs, currentStartIndex, partition++);\t\n\tcurrentStartIndex = i;\n\tstrs.clear();\n\tTIMER_STEP();\n      }\n      strs.push_back(s);\n    }\n    clusterRemap(strs, strAttribs, currentStartIndex, partition++);\n    TIMER_STOP();\n  }\n  \n  if(gatherStats) statsCollector.begin();      \n  \n  // copy strings into new collection\n  TIMER_START(\"SORTING STRINGS\", tempContainer->size());\n  for(unsigned i = 0; i < tempContainer->size(); i++) {  \n    string currentString;\n    tempContainer->retrieveString(currentString, strAttribs[i].stringId);\n    if(gatherStats) statsCollector.next(currentString);\n    insertString(currentString);\n    TIMER_STEP();\n  }\n  TIMER_STOP();\n  \n  if(gatherStats) statsCollector.end();\n  \n  delete strAttribs;\n}\n\nvoid\nStringContainerRM::\nfillContainer_Impl(const char* fileName, const unsigned count, const unsigned maxLineLen) {\n  if(pho != PHO_NONE) {\n    StringContainerRM* tempContainer = createDefaultStringContainer<StringContainerRM>();\n    this->fillContainer(tempContainer, fileName, count, maxLineLen);\n    copyReorg(tempContainer);\n    delete tempContainer;\n    int ret = system(\"rm default2.rm\"); // WARNING: OS specific\n    if(ret != 0) cout << \"Temp container file default2.rm could not be deleted\" << endl;\n  }\n  else {\n    fillContainer(this, fileName, count, maxLineLen);\n  }\n\n  writeRidMapFile();\n  \n  flushCache();\n}\n", "encoding": "ascii"}