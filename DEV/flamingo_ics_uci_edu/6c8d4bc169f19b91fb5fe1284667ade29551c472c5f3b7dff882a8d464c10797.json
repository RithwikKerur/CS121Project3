{"url": "http://flamingo.ics.uci.edu/releases/2.0.1/src/common/simmetric.cc", "content": "/*\n  $Id: simmetric.cc 4099 2008-11-07 21:50:29Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the\n  BSD license\n\n  Date: 04/15/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>, Alexander Behm\n*/\n\n#include \"simmetric.h\"\n#include \"util/misc.h\"\n\n#include <cmath>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n// ------------------------------ SimMetric       ------------------------------\n\nbool SimMetric::operator()(const string &s1, const string &s2, float threshold) \n  const \n{\n  return operator()(s1, s2) >= threshold;\n}\n\n// ------------------------------ SimMetricEd     ------------------------------\n\nfloat SimMetricEd::operator()(const string &s1, const string &s2) \n  const \n{  \n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n\n  uint d[2][m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1, \n                           d[iCrt][j - 1] + 1), \n                       d[iPre][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  return d[iPre][m];\n}\n\nbool SimMetricEd::operator()(\n  const string &s1, const string &s2, float threshold) \n  const \n{\n  uint T = static_cast<uint>(threshold);\n\n  uint i, j, ii, jj;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m <= T;\n  if (m == 0)\n    return n <= T;\n  if ((n > m && n - m > T) ||  \n      (m > n &&  m - n > T))\n    return false;\n\n  uint d[n + 1][m + 1], dmin, dmax = T + 1;\n\n  for (i = 0; i <= n; i++)\n    d[i][0] = i;\n  for (j = 1; j <= m; j++)\n    d[0][j] = j;\n\n  for (ii = 1; ii <= n; ii++) {\n    dmin = dmax;\n    for (j = 1; j <= min(ii, m); j++) {\n      i = ii - j + 1;\n      d[i][j] = min(min(d[i - 1][j] + 1,\n                        d[i][j - 1] + 1),\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(d[i][j], d[i - 1][j]));\n    }\n    if (dmin > T)\n      return false;\n  }\n  \n  for (jj = 2; jj <= m; jj++) {\n    dmin = dmax;\n    for (j = jj; j <= min(n + jj - 1, m); j++) {\n      i = n - (j - jj);\n      d[i][j] = min(min(d[i - 1][j] + 1,\n                        d[i][j - 1] + 1),\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(d[i][j], d[i - 1][j]));\n    }\n    if (dmin > T)\n      return false;\n  }\n\n  return d[n][m] <= T;\n}\n\nuint SimMetricEd::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes, \n  const float simThreshold) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  uint q = gramGen.getGramLength();\n  uint numGrams = queryGramCodes.size();\n  return numGrams - (q * edThreshold); \n}\n\nvoid SimMetricEd::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  switch(filterType) {\n\n  case FT_LENGTH: {\n    lbound = (query.length() - edThreshold <= 1) ? 0 : \n      query.length() - edThreshold - 1;\n    ubound = query.length() + edThreshold - 1;\n  } break;\n\n  case FT_CHECKSUM: { \n    uint sum = checksum(query);\n    lbound = sum - (edThreshold * CHECKSUM_ASCII_MAX);\n    if((signed)lbound < 0) lbound = 0;\n    ubound = sum + (edThreshold * CHECKSUM_ASCII_MAX);\n  } break;\n\n  default: {\n    lbound = 0;\n    ubound = 0;\n  } break;\n\n  }\n}\n  \nfloat SimMetricEd::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEd::getSimMin Not Implemented\" << endl; \n  exit(1); \n}\n\nfloat SimMetricEd::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsQuery - noGramsCommon) / \n    gramGen.getGramLength();\n}\n\nuint SimMetricEd::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = noGramsQuery - sim * gramGen.getGramLength();\n  return th > 1 ? static_cast<uint>(floor(th)) : 1;\n}\n\n// ------------------------------ SimMetricEdNorm ------------------------------\n\nfloat SimMetricEdNorm::operator()(const string &s1, const string &s2) \n  const \n{\n  return 1 - static_cast<float>(SimMetricEd::operator()(s1, s2)) / \n    max(s1.length(), s2.length());\n}\n\nbool SimMetricEdNorm::operator()(\n  const string &s1, const string &s2, float threshold) \n  const \n{\n  // return SimMetric::operator()(s1, s2, threshold);\n  return SimMetricEd::operator()(s1, s2, (1 - threshold) * \n                                 max(s1.length(), s2.length()));\n}\n\nuint SimMetricEdNorm::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold)\n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricEdNorm::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricEdNorm::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n} \n\nfloat SimMetricEdNorm::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return 0;\n}\n\nfloat SimMetricEdNorm::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return 1 - static_cast<float>(noGramsQuery - noGramsCommon) / \n    (gramGen.getGramLength() * lenQuery);\n}\n\nuint SimMetricEdNorm::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = noGramsQuery - (1 - sim) * lenQuery * gramGen.getGramLength(); \n  return th > 1 ? static_cast<uint>(floor(th)) : 1;\n}\n\n// ------------------------------ SimMetricEdSwap ------------------------------\n\nfloat SimMetricEdSwap::operator()(const string &s1, const string &s2) \n  const \n{\n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n  uint d[2][m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1,\n                           d[iCrt][j - 1] + 1),\n                       d[iPre][j - 1] + ((s1[i - 1] == s2[j - 1] ||\n                                          (i > 1 &&\n                                           j > 1 &&\n                                           s1[i - 1] == s2[j - 2] &&\n                                           s1[i - 2] == s2[j - 1])) ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  return d[iPre][m];\n}\n\nbool SimMetricEdSwap::operator()(\n  const string &s1, const string &s2, float threshold) \n  const \n{\n  return operator()(s1, s2) <= threshold;\n}\n\nuint SimMetricEdSwap::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold)\n  const \n{\n  cerr << \"SimMetricEdSwap::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricEdSwap::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricEdSwap::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n} \n\nfloat SimMetricEdSwap::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEdSwap::getSimMin Not Implemented\" << endl;\n  exit(1);\n}\n\nfloat SimMetricEdSwap::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEdSwap::getSimMax Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricEdSwap::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricEdSwap::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\n// ------------------------------ SimMetircGram   ------------------------------\n\n// ------------------------------ SimMetricJacc   ------------------------------\n\nfloat SimMetricJacc::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sUni;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  uint interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d = static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n \nfloat SimMetricJacc::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsCommon) / \n    (noGramsQuery + noGramsData - noGramsCommon);\n}\n     \nvoid SimMetricJacc::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filterType) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold);\n    ubound = (uint)ceil(((float)numGrams/simThreshold)); \n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHECKSUM: {\n    uint queryChecksum = checksum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold);\n    uint maxGrams = (uint)ceil(((float)numGrams/simThreshold)); \n    lbound = queryChecksum - ((numGrams - minGrams)*CHECKSUM_ASCII_MAX);\n    ubound = queryChecksum + ((maxGrams - numGrams)*CHECKSUM_ASCII_MAX);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricJacc::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold) \n  const \n{\n  uint numGrams = queryGramCodes.size();\n  return (uint)floor(simThreshold*(numGrams));  \n}\n \nuint SimMetricJacc::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = max(sim * noGramsQuery,\n                 (noGramsQuery + noGramsMin) / (1 + 1 / sim));\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\n// ------------------------------ SimMetricCos    ------------------------------\n\nfloat SimMetricCos::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  static_cast<float>(sInt.size()) / \n    sqrt(s1Gram.size() * s2Gram.size());\n  \n  return d;\n}\n      \nfloat SimMetricCos::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return noGramsCommon / sqrt(noGramsQuery * noGramsData);\n}\n     \nuint SimMetricCos::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold)\n  const \n{\n\n  // uint gramLength = gramGen.getGramLength();\n  uint numGrams = queryGramCodes.size();\n  return (uint)floor(simThreshold*simThreshold*numGrams);\n}  \n\nvoid SimMetricCos::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n    \n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n    \n  switch(filterType) {\n      \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold*simThreshold - gramLength + 1);\n    ubound = (uint)ceil(((float)numGrams/(simThreshold*simThreshold)) - gramLength + 1);\n    if ((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHECKSUM: {\n    uint queryChecksum = checksum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold*simThreshold);\n    uint maxGrams = (uint)ceil((float)numGrams/(simThreshold*simThreshold));\n    lbound = queryChecksum - ((numGrams - minGrams)*CHECKSUM_ASCII_MAX*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*CHECKSUM_ASCII_MAX*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }\n}\n\nuint SimMetricCos::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = sim * sqrt(noGramsQuery * noGramsMin);\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\n// ------------------------------ SimMetricDice   ------------------------------\n\nfloat SimMetricDice::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  2. * sInt.size() / (s1Gram.size() + s2Gram.size());\n  \n  return d;\n}\n      \nfloat SimMetricDice::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricDice::operator(noGramsData, noGramQuery, noGramsCommon) \"\n       << \"Not Implemented\" << endl;\n  exit(1);\n}\n     \nuint SimMetricDice::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold)\n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n} \n\nvoid SimMetricDice::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filterType) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    ubound = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n    \n  case FT_CHECKSUM: {\n    uint queryChecksum = checksum(query);\n    uint minGrams = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    uint maxGrams = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    lbound = queryChecksum - ((numGrams - minGrams)*CHECKSUM_ASCII_MAX*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*CHECKSUM_ASCII_MAX*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricDice::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDice::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\n// ------------------------------ SimGramCount    ------------------------------\n\nfloat SimMetricGramCount::operator()(\n  const string &s1, \n  const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n  \n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  return sInt.size();\n}\n      \nfloat SimMetricGramCount::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return noGramsCommon;\n}\n     \nuint SimMetricGramCount::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold) \n  const \n{\n  cerr << \"SimMetricGramCount::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricGramCount::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const FilterType filterType,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricGramCount::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricGramCount::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return static_cast<uint>(sim);\n}\n", "encoding": "ascii"}