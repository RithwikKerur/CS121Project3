{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/sepia/ppdtable/ppdtable.cc", "content": "/*\n  $Id: ppdtable.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/14/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"ppdtable.h\"\n\nPPDTable::PPDTable(const PPDTable &t) \n{\n  table = new ContPPDEntry;\n  *table = *t.table;\n}\n\nPPDTable& PPDTable::operator=(const PPDTable &t) \n{\n  if (this == &t)\n    return *this;\n  *table = *t.table;\n  return *this;\n}\n\nbool PPDTable::operator==(const PPDTable &t) const \n{\n  if (this == &t)\n    return true;\n  if (*table == *t.table)\n    return true;\n  return false;\n}\n\nostream& operator<<(ostream &out, const PPDTable &t) \n{\n  return out << *t.table;\n}\n\nistream& operator>>(istream &in, PPDTable &t) \n{\n  return in >> *t.table;\n}\n\nvoid PPDTable::insert(const PPDEntry &e) \n{\n  PPDEntry eMin = PPDEntry(e.vect1, e.vect2, SIM_TYPE_MIN, 0, 0);\n  PPDEntry eMax = PPDEntry(e.vect1, e.vect2, SIM_TYPE_MAX, 0, 0);\n\n  PPDEntry eNew = e; eNew.countE = 0;\n  // the element that will be added\n\n  ContPPDEntryIt itMin = table->lower_bound(eMin);\n  ContPPDEntryIt itMax = table->upper_bound(eMax);\n\n  // between itMin and itMax are all the elements with the same vect1 and vect2\n  unsigned a = 0;\n  // \"a\" holds the total number of occurences of pair (v1, v2)\n  if (itMin != itMax) { // there is at lease one pair with (v1, v2)\n    ContPPDEntryIt itLast = itMax; --itLast;\n    a = itLast->countE;\n\n    ContPPDEntryIt itPrev = table->lower_bound(e);\n    //--itPrev;\n\n    // !!! PPDTable assumes that ContPPDEntry is an ordered container !!!\n    if (itPrev->vect1 == eNew.vect1 && itPrev->vect2 == eNew.vect2)\n      // there is an entry (v1, v2, d) with d >= eNew.d\n      eNew.countE = itPrev->countE;\n  }\n\n  // add new element (if necessary)\n  if (table->find(eNew) == table->end()) {\n    bool doInsert = false;\n    if (eNew.distM > DIST_THRESHOLD)\n      // if eNew.distM > itLast->distM\n      //   insert eNew\n      if (itMin != itMax) {\n        ContPPDEntryIt itLast = itMax; --itLast;\n        if (e.distM > itLast->distM) {\n          table->erase(itLast);\n          doInsert = true;\n        }\n      } else\n        doInsert = true;\n    else\n      doInsert = true;\n    if (doInsert) {\n      table->insert(eNew);\n      // if the element is added, the iterators need to be updated\n      itMin = table->lower_bound(eMin);\n      itMax = table->upper_bound(eMax);\n    }\n  }\n\n  // update countE and fract of all the elements with (vect1, vect2)\n  a++;\n  ContPPDEntry tableNew;\n  for (ContPPDEntryIt it = itMin; it != itMax; ++it) {\n    PPDEntry eTmp = *it;\n    if (eTmp.distM >= e.distM)\n      eTmp.countE+=e.countE;\n    eTmp.fract = static_cast<float>(eTmp.countE)/a;\n    tableNew.insert(eTmp);\n  }\n  table->erase(itMin, itMax);\n  table->insert(tableNew.begin(), tableNew.end());\n}\n\nvoid PPDTable::erase(const PPDEntry &e) \n{\n  ContPPDEntryIt it = table->find(e);\n  if (it == table->end()) {\n    cerr << \"PPDTable::erase entry not found\\t\" << e << endl;\n    return;\n  }\n\n  if (it->countE == 0) {\n    cerr << \"PPDTable::erase entry has cont 0\\t\" << e << endl;\n    return;\n  }\n\n  PPDEntry eMin = PPDEntry(e.vect1, e.vect2, SIM_TYPE_MIN, 0, 0);\n  PPDEntry eMax = PPDEntry(e.vect1, e.vect2, SIM_TYPE_MAX, 0, 0);\n\n  ContPPDEntryIt itMin = table->lower_bound(eMin);\n  ContPPDEntryIt itMax = table->upper_bound(eMax);\n\n  // between itMin and itMax are all the elements with the same vect1 and vect2\n  unsigned a = 0;\n  // \"a\" holds the total number of occurences of pair (v1, v2)\n  if (itMin == itMax) {\n    cerr << \"PPDTable::erase entry range not found\\t\" << e << endl;\n    return;\n  }  \n  // there is at lease one pair with (v1, v2)\n  ContPPDEntryIt itLast = itMax; --itLast;\n  a = itLast->countE;\n\n  // update countE and fract of all the elements with (vect1, vect2)\n  a--;\n  ContPPDEntry tableNew;\n  for (ContPPDEntryIt it = itMin; it != itMax; ++it) {\n    PPDEntry eTmp = *it;\n    if (eTmp.distM >= e.distM)\n      eTmp.countE -= e.countE;\n    eTmp.fract = static_cast<float>(eTmp.countE) / a;\n    if (eTmp.countE != 0)\n      tableNew.insert(eTmp);\n  }\n  table->erase(itMin, itMax);\n  table->insert(tableNew.begin(), tableNew.end());\n}\n\nvoid PPDTable::pruneMax() \n{\n  for (ContPPDEntryIt it = table->begin(); it != table->end();)\n    if (it->distM > DIST_THRESHOLD) {\n      ContPPDEntryIt er = it;\n      it++;\n      // !!! PPDTable assumes that ContPPDEntry is a container where\n      // remove does not invalidate iterators !!!\n      table->erase(er);\n    } else\n      it++;\n}\n\n#if SIM_DIST == 1 && SIM_VECT == 1\n\nvoid PPDTable::serialize(ofstream &out)\n{\n  unsigned sz = static_cast<unsigned>(table->size());\n  out.write(reinterpret_cast<char *>(&sz), sizeof(unsigned));\n  for(ContPPDEntryIt it = table->begin(); it != table->end(); it++)\n    it->serialize(out);\n}\n\nvoid PPDTable::deserialize(ifstream &in)\n{\n  unsigned sz;\n  in.read(reinterpret_cast<char *>(&sz), sizeof(unsigned));\n  for (unsigned i = 0; i < sz; i++) {\n    PPDEntry e;\n    e.deserialize(in);\n    table->insert(e);\n  }\n}\n\n#endif\n", "encoding": "ascii"}