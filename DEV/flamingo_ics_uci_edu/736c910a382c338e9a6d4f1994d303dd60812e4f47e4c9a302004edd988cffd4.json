{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/sepia/src/ppdtable/closelex.cc", "content": "/*\n  $Id: closelex.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/14/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"closelex.h\"\n\n#include <algorithm>\n\nclass CmpIdx\n{\nprivate:\n  const vector<string> *data;\npublic:\n  CmpIdx(const vector<string> *d): data(d) {}\n  bool operator()(unsigned idx1, unsigned idx2) { \n    return (*data)[idx1] < (*data)[idx2]; }\n};\n\nCloseLex::CloseLex(const vector<string> *d, Clusters *c, ContQueryPivot *q, \n                   const unsigned samplePer, const unsigned queueSize):\n  PPDSample(d, c, q, samplePer), queueSize(queueSize)\n{\n  // init - sample\n  index.reserve(d->size());\n  for (unsigned i = 0; i < d->size(); i++) index.push_back(i);\n  sort(index.begin(), index.end(), CmpIdx(data));\n  sample = Sample(max(1u, \n                      static_cast<unsigned>(static_cast<float>(samplePer) / \n                                            100 * data->size())), \n                  data->size());\n\n  // init - loop\n  sampleIt=sample.begin();\n  buildQueue();\n  unsigned j = samplePair.begin()->index;\n  samplePair.erase(samplePair.begin());\n  cluster = clusters->getCluster(j);\n  stringIt = cluster.begin();\n}\n\nvoid CloseLex::step() \n{\n  stringIt++;\n  if (stringIt == cluster.end()) {\n    if (samplePair.empty()) {\n      sampleIt++;\n      if (sampleIt == sample.end()) \n        return;\n      buildQueue();\n    }\n    unsigned i = samplePair.begin()->index;\n    samplePair.erase(samplePair.begin());\n    cluster = clusters->getCluster(i);\n    stringIt = cluster.begin();\n  }\n}\n\nbool CloseLex::hasNext() const \n{\n  if (sampleIt != sample.end())\n    return true;\n  return false;\n}\n\nPPDTriple CloseLex::next() \n{\n  const unsigned q = index[*sampleIt];\n  const unsigned p = cluster.getPivot();\n  const unsigned s = *stringIt;\n\n  PPDTriple triple=PPDTriple(q,\n                             p,\n                             s,\n                             SimVect((*data)[q], (*data)[p]),\n                             SimVect((*data)[p], (*data)[s]),\n                             SimDist((*data)[q], (*data)[s]));\n\n  // increment\n  step();\n\n  return triple;\n}\n\nvoid CloseLex::buildQueue() \n{\n  for (unsigned i = 0; i < clusters->sizeCluster(); i++) {\n    const unsigned p = clusters->getCluster(i).getPivot();\n    const unsigned q = *sampleIt;\n    SimType dist = SimDist((*data)[q], (*data)[p]);\n    if (samplePair.size() < queueSize || dist<samplePair.begin()->dist) {\n      samplePair.insert(IndexEntry(i, dist));\n      if (samplePair.size() > queueSize)\n        samplePair.erase(samplePair.begin());\n    }\n  }\n}\n", "encoding": "ascii"}