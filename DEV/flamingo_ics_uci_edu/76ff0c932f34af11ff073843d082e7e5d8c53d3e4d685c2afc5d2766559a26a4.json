{"url": "http://flamingo.ics.uci.edu/releases/3.0/docs/FilterTreeDoc.html", "content": "<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:html=\"http://www.w3.org/1999/xhtml\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>FilterTreeDoc  Group</title><style type=\"text/css\">\n           @import url(media/trac.css);\n          </style></head><body><p><a href=\"index.html\">Back to Index</a></p><hr></hr><div class=\"wikipage searchable\">\n<p>AppString\n&gt; AppStringDoc</p>\n<div class=\"wiki-toc\">\n<ol>\n<li><a href=\"#Filtertree\">Filtertree</a>\n<ol>\n<li><a href=\"#Introduction\">Introduction</a></li>\n<li><a href=\"#ApproximateStringSearch\">Approximate String\nSearch</a></li>\n<li><a href=\"#Overview\">Overview</a>\n<ol>\n<li><a href=\"#IndexingOptions\">Indexing Options</a></li>\n<li><a href=\"#OtherFunctionality\">Other Functionality</a></li>\n</ol>\n</li>\n<li><a href=\"#AnsweringApproximateStringQueries\">Answering\nApproximate String Queries</a></li>\n<li><a href=\"#TheFiltertreeStructure\">The Filtertree Structure</a>\n<ol>\n<li><a href=\"#Recommendations\">Recommendations</a></li>\n</ol>\n</li>\n<li><a href=\"#High-LevelOverviewofImportantComponents\">High-Level\nOverview of Important Components</a>\n<ol>\n<li><a href=\"#GeneralComponents\">General Components</a></li>\n<li><a href=\"#IndexersSearchersandListMergers\">Indexers, Searchers,\nand ListMergers</a></li>\n</ol>\n</li>\n<li><a href=\"#StatsGenOutput\">StatsGen Output</a></li>\n<li><a href=\"#Contributors\">Contributors</a></li>\n</ol>\n</li>\n</ol>\n</div>\n<h1 id=\"Filtertree\">Filtertree</h1>\n<h2 id=\"Introduction\">Introduction</h2>\n<p>This module supports efficient approximate string search on a\ncollection of strings. An approximate query asks for all strings in\nthe collection that are \"similar\" to the query string for a given\nsimilarity function and similarity threshold.</p>\n<h2 id=\"ApproximateStringSearch\">Approximate String Search</h2>\n<p>Many applications need to answer approximate string queries. The\nfollowing are a few examples:</p>\n<ul>\n<li>Spellchecking: suggest good words for a possibly mistyped\nword.</li>\n<li>Record linkage: identify records that could represent the same\nreal-world entity.</li>\n<li>The \"Did you mean\" feature by many search engines partially\nrelies on finding words similar to a given keyword.</li>\n</ul>\n<h2 id=\"Overview\">Overview</h2>\n<h3 id=\"IndexingOptions\">Indexing Options</h3>\n<p>We provide three different flavors of indexing+searching, each\nof which provide specific optimizations for improving query\nperformance:</p>\n<ol>\n<li>All structures are in main memory, including:\n<ul>\n<li>String collection</li>\n<li>Filtertree</li>\n<li>Inverted index</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>All structures are in main memory. We use lossy compression on\nthe inverted index to save space.\n<ul>\n<li>String collection in memory</li>\n<li>Filtertree in memory</li>\n<li>Inverted index in memory (compressed)</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>The data and inverted index is on disk.\n<ul>\n<li>String collection on disk</li>\n<li>Filtertree in memory</li>\n<li>Inverted index on disk</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"OtherFunctionality\">Other Functionality</h3>\n<p>We support the following similarity functions / distance\nmeasures:</p>\n<ul>\n<li>Levenshtein Distance (aka the Edit Distance) <a class=\"ext-link\" href=\"http://en.wikipedia.org/wiki/Levenshtein_distance\"><span class=\"icon\">http://en.wikipedia.org/wiki/Levenshtein_distance</span></a></li>\n<li>Jaccard Similarity <a class=\"ext-link\" href=\"http://en.wikipedia.org/wiki/Jaccard_Similarity_Coefficient\"><span class=\"icon\">\nhttp://en.wikipedia.org/wiki/Jaccard_Similarity_Coefficient</span></a></li>\n<li>Cosine Similarity <a class=\"ext-link\" href=\"http://en.wikipedia.org/wiki/Cosine_similarity\"><span class=\"icon\">http://en.wikipedia.org/wiki/Cosine_similarity</span></a></li>\n<li>Dice Similarity <a class=\"ext-link\" href=\"http://en.wikipedia.org/wiki/Dice%27s_coefficient\"><span class=\"icon\">http://en.wikipedia.org/wiki/Dice%27s_coefficient</span></a></li>\n</ul>\n<p>We support the following single-signature filters (e.g. for\npartitioning the string collection):</p>\n<ul>\n<li>Length Filter</li>\n<li>Charsum Filter</li>\n</ul>\n<p>The index structure (filtertree + inverted index) can be\nsaved/loaded to/from a file.</p>\n<h2 id=\"AnsweringApproximateStringQueries\">Answering Approximate\nString Queries</h2>\n<p>To answer queries efficiently this module uses an inverted-list\nindex on the q-grams of the strings in the collection. That is,\neach string is decomposed into substrings (grams) of size q using a\nsliding window, and then for each gram we build a list of string\nids containing that gram (the inverted list of that gram). The\nprocess of answering queries is based on the observation that if\ntwo strings are similar, then they must share a certain number of\ncommon grams (depending on the similarity function and similarity\nthreshold). False-positives must be removed in a post-processing\nstep, i.e. the true similarities are computed.</p>\n<p>In addition to the above we can further increase the performance\nof queries by using filters. A single-signature filter partitions\nthe string collection into disjoint subsets based on some criteria.\nFor answering a query we only need to consider some of the subsets.\nFor example, if we were looking for all strings in the collection\nwithin an edit-distance of 1 to the string \"abcde\", then we know\nthat any answer string must have a length in [4,6]. So, if we partition\nthe string collection using the length of the strings we can avoid\nprocessing irrelevant string ids during query answering. The\ncharsum filter is similar to the length filter. We partition the\ndata strings based on their charsums (sum of characters in the\nstring). For query answering we can determine a range of charsums\nthat answers must lie in.</p>\n<h2 id=\"TheFiltertreeStructure\">The Filtertree Structure</h2>\n<p>The filtertree structure facilitates the use of filters. Each\nlevel in the tree partitions the string collection based on one\nfilter. Each leaf node contains a gram inverted-index on the subset\nof strings belonging to that leaf. For answering a query we\ntraverse the tree to identify leaf nodes that \"survive\" the\nfiltering criteria, and probe the inverted indexes attached to\nthose leaves to get a list of candidate answers. The following is\nan example of a filtertree with a fanout of 3 and both the length\nand charsum filter applied:</p>\n<p>\n<img width=\"50%\" alt=\"Filtertree structure with two partitioning filters\" title=\"Filtertree structure with two partitioning filters\" src=\"media/FiltertreeStructure.png\"></img></p>\n<h3 id=\"Recommendations\">Recommendations</h3>\n<p>In most cases, using exactly one partitioning filter yields the\nbest performance. An intuitive (but simplified) explanation is as\nfollows:</p>\n<ul>\n<li>For the in-memory indexes, there is trade-off between\nprocessing several inverted indexes with short lists or processing\nfewer inverted indexes with longer lists</li>\n<li>For the disk-based indexes the layout of the inverted lists in\nthe file can be optimized if exactly one partitioning filter is\nused</li>\n</ul>\n<h2 id=\"High-LevelOverviewofImportantComponents\">High-Level\nOverview of Important Components</h2>\n<ul>\n<li>The purpose of this overview is to give the reader a feeling\nfor the code design</li>\n<li>Many details, such as methods, method parameters, and\nattributes have been left out for simplicity</li>\n<li><strong>Blue components</strong> are meant for in-memory\nindexes</li>\n<li><strong>Yellow components</strong> are meant for disk-based\nindexes</li>\n<li><strong>Red components</strong> are meant for in-memory indexes\ncompressed with CombineLists</li>\n<li><strong>Green components</strong> are meant for in-memory\nindexes compressed with DiscardLists</li>\n</ul>\n<h3 id=\"GeneralComponents\">General Components</h3>\n<p><img src=\"media/GeneralComponents.png\" alt=\"Code overview of general components\" title=\"Code overview of general components\"></img></p>\n<h3 id=\"IndexersSearchersandListMergers\">Indexers, Searchers, and\nListMergers</h3>\n<p>\n<img src=\"media/IndexersSearchersMergers.png\" alt=\"Code overview of indexers, searchers and mergers\" title=\"Code overview of indexers, searchers and mergers\"></img></p>\n<h2 id=\"StatsGenOutput\">StatsGen Output</h2>\n<p>The StatsGenerator allows collecting of performance data on the\napproximate string search library. For example, different filters,\nmerging algorithms, datasets, query workloads can be tested. A good\nstart is perftest.cc included in the filtertree folder. The\nperformance numbers are written to an output file (e.g. perftest.cc\nwrites to \"perftest_search_stats.txt\"). The StatsGenerator is\nintended for advanced users who are familiar with the algorithmic\ndetails of approximate string search. The numbers generated depict\ndifferent steps in the process of query answering and will only be\nunderstood by people familiar with the subject. For getting an idea\nof the query performance using certain parameters it is sufficient\nto focus on the field \"total time\" which measures the average query\nperformance of the given workload.</p>\n<h2 id=\"Contributors\">Contributors</h2>\n<ul>\n<li>Alexander Behm (design, main author)</li>\n<li>Chen Li (design, project leader)</li>\n<li>Rares Vernica (design)</li>\n<li>Shengyue Ji (design, implementation)</li>\n<li>Yiming Lu (design, implementation)</li>\n</ul>\n</div><div class=\"footer\"><hr></hr><p><a href=\"index.html\">Back to Index</a></p></div></body></html>\n", "encoding": "ascii"}