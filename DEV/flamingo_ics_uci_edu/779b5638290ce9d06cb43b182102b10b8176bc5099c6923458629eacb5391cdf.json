{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/sepia/sepia.cc", "content": "/*\n  $Id: sepia.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 05/04/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"sepia.h\"\n\n#include <sys/stat.h>\n\n#include \"cluster/lexic.h\"\n#include \"cluster/medoids.h\"\n#include \"freqest/freqest.h\"\n#include \"util/input.h\"\n#include \"util/misc.h\"\n\nconst string Sepia::PARAM_SUFFIX = \".sep.param.bin\";\nconst string Sepia::CLUST_SUFFIX = \".sep.clust.txt\";\nconst string Sepia::PPD_SUFFIX = \".sep.pdd.txt\";\nconst string Sepia::ERR_SUFFIX = \".sep.err.txt\";\n\nSepia::Sepia(const vector<string> &dataset, \n             unsigned thresholdMin, unsigned thresholdMax):\n  dataset(&dataset),\n  thresholdMin(thresholdMin),\n  thresholdMax(thresholdMax), \n  clustNo(1000),\n  recNo(300),\n  clustType(MEDOIDS_IMP),\n  sampleType(CLOSE_RAND),\n  samplePer(20), \n  sampleSizeMul(5),\n  sampleSets(10), \n  sampleSteps(10),\n  queueSize(10),\n  uniqueNo(10)\n{\n}\n\nSepia::Sepia(const vector<string> &dataset, \n             unsigned thresholdMin, unsigned thresholdMax,\n             unsigned clustNo, unsigned recNo,\n             ClusterType clustType, SampleType sampleType,\n             unsigned samplePer, unsigned sampleSizeMul,\n             unsigned sampleSets, unsigned sampleSteps,\n             unsigned queueSize, unsigned uniqueNo):\n  dataset(&dataset),\n  thresholdMin(thresholdMin),\n  thresholdMax(thresholdMax), \n  clustNo(clustNo),\n  recNo(recNo),\n  clustType(clustType),\n  sampleType(sampleType),\n  samplePer(samplePer), \n  sampleSizeMul(sampleSizeMul),\n  sampleSets(sampleSets), \n  sampleSteps(sampleSteps),\n  queueSize(queueSize),\n  uniqueNo(uniqueNo)\n{\n}\n\nSepia::Sepia(const vector<string> &dataset, \n             const string &filenamePrefix):\n  dataset(&dataset)\n{\n  loadData(filenamePrefix);\n}\n\nvoid Sepia::build()\n{\n  // clusters\n  switch (clustType) {\n  case LEXIC:\n    clust = new Lexic(dataset, clustNo, sampleType, samplePer, queueSize, \n                      uniqueNo);\n    break;\n  case MEDOIDS:\n    clust = new Medoids(dataset, clustNo, sampleType, samplePer, queueSize, \n                        uniqueNo, 1, sampleSizeMul, sampleSets, sampleSteps);\n    break;\n  case MEDOIDS_IMP:\n    clust = new Medoids(dataset, clustNo, sampleType, samplePer, queueSize, \n                        uniqueNo, 7, sampleSizeMul, sampleSets, sampleSteps);\n    break;\n  }\n  clust->buildClusters();\n  clust->buildFTables();\n\n  // ppdtable\n  clust->buildPPDtable();\n\n  // errorcorr\n  err = new ErrorCorr(dataset, clust, thresholdMin, thresholdMax, recNo);\n  err->buildRecords();\n  err->buildErrorCorr();\n}\n\nvoid Sepia::saveData(const string &filenamePrefix) const\n{\n  // save param\n  string filenameParam = filenamePrefix + PARAM_SUFFIX;\n  ofstream fileParam(filenameParam.c_str(), ios::out | ios::binary);\n  if (!fileParam) {\n    cerr << \"can't open output file \\\"\" << filenameParam << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  fileParam.write(reinterpret_cast<const char*>(&thresholdMin), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&thresholdMax), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n  \n  fileParam.write(reinterpret_cast<const char*>(&clustNo), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&clustType), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&sampleType), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&samplePer), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&sampleSizeMul), \n                  sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&sampleSets), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&sampleSteps), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&queueSize), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&uniqueNo), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.write(reinterpret_cast<const char*>(&recNo), sizeof(unsigned));\n  if (fileParam.fail()) writeerror(filenameParam);\n\n  fileParam.close();\n\n  clust->writeClusters(filenamePrefix + CLUST_SUFFIX);\n  clust->writePPDtable(filenamePrefix + PPD_SUFFIX);\n  err->writeErrorCorr(filenamePrefix + ERR_SUFFIX);\n}\n\nvoid Sepia::loadData(const string &filenamePrefix) \n{\n  if (!consistData(filenamePrefix)) {\n    cerr << \"data files are not consistent\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  // load param\n  string filenameParam = filenamePrefix + PARAM_SUFFIX;\n  ifstream fileParam(filenameParam.c_str(), ios::in | ios::binary);\n  if (!fileParam) {\n    cerr << \"can't open input file \\\"\" << filenameParam << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  fileParam.read(reinterpret_cast<char*>(&thresholdMin), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&thresholdMax), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n  \n  fileParam.read(reinterpret_cast<char*>(&clustNo), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&clustType), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&sampleType), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&samplePer), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&sampleSizeMul), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&sampleSets), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&sampleSteps), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&queueSize), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&uniqueNo), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.read(reinterpret_cast<char*>(&recNo), sizeof(unsigned));\n  if (fileParam.fail()) readerror(filenameParam);\n\n  fileParam.close();\n\n  // clusters\n  clust = new Clusters(dataset, clustNo, sampleType, samplePer, queueSize, \n                       uniqueNo);\n  clust->readClusters(filenamePrefix + CLUST_SUFFIX);\n\n  // ppdtable\n  clust->readPPDtable(filenamePrefix + PPD_SUFFIX);\n\n  // errorcorr\n  err = new ErrorCorr(dataset, clust, thresholdMin, thresholdMax, recNo);\n  err->readErrorCorr(filenamePrefix + ERR_SUFFIX);\n}\n\nbool Sepia::consistData(const string &filenamePrefix) const\n{\n  const string\n    filenameParam = filenamePrefix + PARAM_SUFFIX, \n    filenameClust = filenamePrefix + CLUST_SUFFIX, \n    filenamePPD = filenamePrefix + PPD_SUFFIX, \n    filenameErr = filenamePrefix + ERR_SUFFIX;\n\n  struct stat attribParam, attribClust, attribPPD, attribErr;      \n\n  if (stat(filenameParam.c_str(), &attribParam)) {\n    cerr << \"can't stat file \\\"\" << filenameParam << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  if (stat(filenameClust.c_str(), &attribClust)) {\n    cerr << \"can't stat file \\\"\" << filenameClust << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  if (stat(filenamePPD.c_str(), &attribPPD)) {\n    cerr << \"can't stat file \\\"\" << filenamePPD << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  if (stat(filenameErr.c_str(), &attribErr)) {\n    cerr << \"can't stat file \\\"\" << filenameErr << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  if (attribParam.st_mtime > attribClust.st_mtime)\n    return false;\n  if (attribClust.st_mtime > attribPPD.st_mtime)\n    return false;\n  if (attribPPD.st_mtime > attribErr.st_mtime)\n    return false;\n\n  return true;\n}\n\nfloat Sepia::getEstimateSelectivity(const string &query, \n                                    const unsigned editdist) const \n{\n  Predicate p = Predicate(query, editdist);\n  float f = freqEstFunc(*dataset, *clust, p);\n  float rCor = err->getError(Record(p, f));\n  if (rCor == -1)\n    return f * 2;\n  else\n    return f / (rCor + 1);\n}\n\nunsigned Sepia::getRealSelectivity(const string &query, \n                                   const unsigned editdist) const \n{\n  return freqRealFunc(*dataset, Predicate(query, editdist));\n}\n\nbool Sepia::operator==(const Sepia &s) const \n{\n  if (this == &s)\n    return true;\n  if (dataset == s.dataset && \n      thresholdMin == s.thresholdMin && \n      thresholdMax == s.thresholdMax && \n      clustNo == s.clustNo && \n      clustType == s.clustType && \n      sampleType == s.sampleType && \n      samplePer == s.samplePer && \n      sampleSizeMul == s.sampleSizeMul && \n      sampleSets == s.sampleSets && \n      sampleSteps == s.sampleSteps && \n      queueSize == s.queueSize && \n      uniqueNo == s.uniqueNo && \n      recNo == s.recNo && \n      *clust == *s.clust && \n      *err == *s.err)\n    return true;\n\n  return false;\n}\n", "encoding": "ascii"}