{"url": "http://flamingo.ics.uci.edu/releases/2.0.1/src/sepia/freqest/errorcorr.cc", "content": "/*\n  $Id: errorcorr.cc 4096 2008-11-06 01:51:40Z rares $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/23/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"errorcorr.h\"\n#include \"freqest.h\"\n\n#include <cstdlib>\n\nbool ErrorCorr::operator==(const ErrorCorr &e) const \n{\n  if (this == &e)\n    return true;\n  if (dataset == e.dataset && \n      *clusters == *e.clusters && \n      thresholdMin == e.thresholdMin && \n      thresholdMax == e.thresholdMax && \n      recordSize == e.recordSize && \n//       vectRecord == e.vectRecord && \n      avgLen == e.avgLen && \n      avgThr == e.avgThr && \n      avgEst == e.avgEst) {\n    bool errEqual = true;\n    for (unsigned i = 0; i < 8; i++)\n      if (err[i] != e.err[i])\n        errEqual = false;\n    if (errEqual)\n      return true;\n  }\n  return false;\n}\n\nvoid ErrorCorr::buildErrorCorr() \n{\n  unsigned sumLen=0;\n  SimType sumThr=0;\n  float sumEst=0;\n  \n  for (VectRecordIt it=vectRecord.begin(); it!=vectRecord.end(); it++) {\n    sumLen+=it->query.length();\n    sumThr+=it->dist;\n    sumEst+=it->est;\n  }\n\n  unsigned size=vectRecord.size();\n  avgLen=static_cast<float>(sumLen)/size;\n  avgThr=static_cast<float>(sumThr)/size;\n  avgEst=sumEst/size;\n\n  unsigned count[8];\n  float sumErr[8];\n  \n  for (unsigned i=0; i<8; i++) {\n    count[i]=0;\n    sumErr[i]=0;\n  }\n\n  for (VectRecordIt it=vectRecord.begin(); it!=vectRecord.end(); it++) {\n    unsigned pos=getPos(*it);\n    count[pos]++;\n    sumErr[pos]+=it->relErr; \n    // assumes that all the entries in the dataset have relErr\n  }  \n\n  for (unsigned i=0; i<8; i++) {\n    if (count[i])\n      err[i]=sumErr[i]/count[i];\n    else\n      err[i]=0;\n  }  \n}\n\nvoid ErrorCorr::buildRecords() \n{\n  const unsigned datasetSize = dataset->size();\n\n  vector<unsigned> indexes;\n  indexes.reserve(datasetSize);\n  for (unsigned i = 0; i < datasetSize; i++) indexes[i] = i;\n\n  cerr << \"errcorr\"; cerr.flush();\n\n  for (unsigned i = 0; i < recordSize; i++) {\n    if (i % 20 == 0) {\n      cerr << '.'; cerr.flush();\n    }\n\n    unsigned index = rand() % (datasetSize - i);\n    indexes[index] = indexes[datasetSize - i - 1];\n\n#if SIM_DIST == 1\n    SimType dist = static_cast<SimType>(rand() % \n                                        (thresholdMax -\n                                         thresholdMin + 1) + thresholdMin);\n#elif SIM_DIST == 2\n    SimType dist = static_cast<SimType>(rand() % \n                                        static_cast<int>(thresholdMax * 10 - \n                                                         thresholdMin * 10 + 1)) / \n      10 + thresholdMin;\n#endif\n\n    Record r = Record((*dataset)[index], dist);\n    r.real = freqRealFunc(*dataset, r);\n    r.est = freqEstFunc(*dataset, *clusters, r);\n    r.setRelErr(); // assumes that the query is form the dataset => real! = 0\n    vectRecord.push_back(r);\n  }\n\n  cerr << \"OK\" << endl;\n}\n\nunsigned ErrorCorr::getPos(Record r) const\n{\n  unsigned pos=0;\n  if (static_cast<float>(r.dist)<=avgThr)\n    ;\n  else \n    pos += 4;\n  if (static_cast<float>(r.query.length())<=avgLen)\n    ;\n  else\n    pos += 2;\n  if (r.est<=avgEst)\n    ;\n  else\n    pos += 1;\n  return pos;\n}\n\nostream& ErrorCorr::info(ostream& out) \n{\n  out << \"ErrorCorr\" << endl << \"---\" << endl;\n  out << \"ErrorCorr record size\\t\" << recordSize << endl;\n  return out << endl;\n}\n\nvoid ErrorCorr::readRecords(const string filename) \n{\n  ifstream file(filename.c_str(), ios::in);\n  if (!file) {\n    cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file >> vectRecord;\n  file.close();\n}\n\nvoid ErrorCorr::writeRecords(const string filename) const \n{\n  ofstream file(filename.c_str(), ios::out);\n  if (!file) {\n    cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file << vectRecord;\n  file.close();\n}\n\nvoid ErrorCorr::readErrorCorr(const string filename) \n{\n  ifstream file(filename.c_str(), ios::in);\n  if (!file) {\n    cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file >> *this;\n  file.close();\n}\n\nvoid ErrorCorr::writeErrorCorr(const string filename) const \n{\n  ofstream file(filename.c_str(), ios::out);\n  if (!file) {\n    cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file << *this;\n  file.close();  \n}\n\nostream& operator<<(ostream& out, const ErrorCorr& errorCorr) \n{\n  out << errorCorr.avgThr << endl;\n  out << errorCorr.avgLen << endl;\n  out << errorCorr.avgEst << endl << endl;\n  for (unsigned i=0; i<8; i++) {\n    out << errorCorr.err[i] << \" \";\n  }\n  out << endl;\n  return out;\n}\n\nistream& operator>>(istream& in, ErrorCorr& errorCorr) \n{\n  in >> errorCorr.avgThr;\n  in >> errorCorr.avgLen;\n  in >> errorCorr.avgEst;\n  for (unsigned i=0; i<8; i++) {\n    in >> errorCorr.err[i];\n  }\n  return in;\n}\n", "encoding": "ascii"}