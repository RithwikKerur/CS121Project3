{"url": "http://flamingo.ics.uci.edu/releases/1.0/src/filtertree/gram.cc", "content": "/* \n$Id$\n\nCopyright (C) 2007 by The Regents of the University of California\n\nRedistribution of this file is permitted under\nthe terms of the *GNU* Public License (*GPL*) \t\n\nDate: 04/08/2007\nAuthor: Yiming Lu <yimingl@ics.uci.edu>\n*/\n\n#include <fstream>\n#include <iostream>\n\n#include \"gram.h\"\n\nusing namespace std;\n\n//------------------------------------------------------------\n// Constructor\n//------------------------------------------------------------\nStringPosition::StringPosition():position(0),\n                                 actualCnt(0),\n                                 sizeOfStringIDs(1)\n{\n    this->stringIDs = new unsigned[sizeOfStringIDs];\t\n}\n\nStringPosition::StringPosition(unsigned stringID, unsigned short position):\n                               position(position),\n                               actualCnt(1),\n                               sizeOfStringIDs(1)\n{\n    this->stringIDs = new unsigned[sizeOfStringIDs];\n    this->stringIDs[0] = stringID;\n}\n\nvoid StringPosition::addStringID(unsigned stringID)\n{\n    actualCnt++;\n    /* if the array is full, then we need to allocate new \n     * space for the new stringID\n     */\n     if(actualCnt > sizeOfStringIDs)\n     {\n     \tunsigned newSizeOfStringIDs = sizeOfStringIDs+1;\n        unsigned *newStringIDs = new unsigned[newSizeOfStringIDs];\n        for(unsigned i = 0; i < sizeOfStringIDs; i++)\n        {\n            newStringIDs[i] = stringIDs[i];\n        }\n        delete[] stringIDs;\n        stringIDs = newStringIDs;\n        sizeOfStringIDs  = newSizeOfStringIDs;\n     }\n     stringIDs[actualCnt-1] = stringID;\n}\n\nostream &operator << (ostream & output, const StringPosition & stringPos)\n{\n    //position\n    output << stringPos.position <<\" \";\n    //num of stringIDs\n    output << stringPos.actualCnt <<\" \";\n    //string IDs\n    for(unsigned i = 0; i < stringPos.actualCnt; i++) {\n    \toutput << stringPos.stringIDs[i]<<\" \";\n    }\n    return output;\n}\n\nistream &operator >> (istream &input, StringPosition & stringPos)\n{\n    //position\n    input >> stringPos.position;\n    //num of stringIDs\n    unsigned size;\n    input >> size;\n    //string IDs\n    for(unsigned i = 0; i < size; i++) {\n    \tunsigned stringID;\n    \tinput >> stringID;\n    \tstringPos.addStringID(stringID);\n    }\n    return input;\n}\n\n//------------------------------------------------------------\n// Destructor\n//------------------------------------------------------------\nStringPosition::~StringPosition()\n{\n    delete[]  this->stringIDs;\n}\n\n//------------------------------------------------------------\n// Constructor\n//------------------------------------------------------------\nGroupStringPosition::GroupStringPosition():\n                     length(0),\n                     actualCnt(0),\n                     sizeOfPositions(1)\n{\n    this->positions = new StringPosition*[sizeOfPositions];\n}\n\nGroupStringPosition::GroupStringPosition(unsigned short length,\n                                         unsigned stringID,\n                                         unsigned short position):\n                                         length(length),\n                                         actualCnt(1),\n                                         sizeOfPositions(1)\n{\n    this->positions = new StringPosition*[sizeOfPositions];\n    \n    StringPosition *strPos = new StringPosition(stringID, position);\n    this->positions[0] = strPos;\n}\n\nGroupStringPosition::GroupStringPosition(unsigned short length,\n                                         StringPosition *strPos):\n                                         length(length),\n                                         actualCnt(1),\n                                         sizeOfPositions(1)\n{\n\tthis->positions = new StringPosition*[sizeOfPositions];\n    \n    this->positions[0] = strPos;\n}\n\n\nvoid GroupStringPosition::insertIntoPositions( unsigned strID,\n                                               unsigned short pos )\n{\n    //Use binary search to find the location to insert the new stringID\n    signed left = 0;\n    signed right = (signed)actualCnt - 1;\n    signed mid = 0;\n    while(left <= right)\n    {\n        mid = (left+right)/2;\n        if( pos > (positions[mid])->getPosition() )\n        {\n            left = mid + 1;\n        }\n        else if( pos < (positions[mid])->getPosition() )\n        {\n            right = mid - 1;\n        }\n        else\n\t    {\n\t        (positions[mid])->addStringID(strID);\n\t        return;\n\t    }\n    }\n    \n    //Check whether it is necessary to allocate new space\n    actualCnt++;\n    if(actualCnt > sizeOfPositions)\n    {\n        unsigned newSizeOfPositions = sizeOfPositions+1;\n        StringPosition **newPositions = new StringPosition*[newSizeOfPositions];\n        for(unsigned i = 0; i < sizeOfPositions; i++)\n        {\n            newPositions[i] = positions[i];\n        }\n        delete[] positions;\n        positions = newPositions;\n        sizeOfPositions  = newSizeOfPositions;\n    }\n    \n    //insert the new position\n    StringPosition *position = new StringPosition(strID, pos);\n    for(signed i = (signed)actualCnt-1; i > (right+1); i--)\n    {\n        positions[i] = positions[i-1];\n    }\n    positions[right+1] = position;\n    return;\t\n}\n\nvoid GroupStringPosition::appendToPositions(StringPosition *strPos)\n{\n    //Check whether it is necessary to allocate new space\n    actualCnt++;\n    if(actualCnt > sizeOfPositions)\n    {\n        unsigned newSizeOfPositions = sizeOfPositions+1;\n        StringPosition ** newPositions = new StringPosition*[newSizeOfPositions];\n        for(unsigned i = 0; i < sizeOfPositions; i++)\n        {\n            newPositions[i] = positions[i];\n        }\n        delete[] positions;\n        positions = newPositions;\n        sizeOfPositions  = newSizeOfPositions;\n    }\n    positions[actualCnt - 1] = strPos;\n}\n\n\nostream &operator << (ostream &output, const GroupStringPosition & group)\n{\n    //length\n    output << group.length <<\" \";\n    //num of positions\n    output << group.actualCnt <<\" \";\n    //positions\n    for(unsigned i = 0; i < group.actualCnt; i++) {\n    \toutput << (*(group.positions[i]))<<\" \";\n    }\n    return output;\n}\n\n\nistream &operator >> (istream &input, GroupStringPosition & group)\n{\n    //length\n    input >> group.length;\n    //num of positions\n    unsigned size;\n    input >> size;\n    //positions\n    for(unsigned i = 0; i < size; i++) {\n        StringPosition *strPosPtr = new StringPosition();\n        input >> (*strPosPtr);\n        group.appendToPositions(strPosPtr);\n    }\n    return input;\t\n}\n\nGroupStringPosition::~GroupStringPosition()\n{\n    for(unsigned i = 0; i < actualCnt; i++)\n    {\n        delete positions[i];\n    }\n    delete [] positions;\n}\n\n\n//------------------------------------------------------------\n// Constructor\n//------------------------------------------------------------\nLengthBucket::LengthBucket():actualCnt(0), sizeOfGroups(1)\n{\n    this->groups = new GroupStringPosition*[sizeOfGroups];\n}\n\nLengthBucket::LengthBucket(unsigned stringID,\n                           unsigned short position,\n                           unsigned short length):\n                           actualCnt(1),\n                           sizeOfGroups(1)\n{\n    GroupStringPosition *groupStrPos = new GroupStringPosition(length, \n                                                                stringID, \n                                                                position);\n    \n    this->groups = new GroupStringPosition*[sizeOfGroups];\n    this->groups[0] = groupStrPos;\n}\n\n//------------------------------------------------------------\n// Destructor\n//------------------------------------------------------------\nLengthBucket::~LengthBucket()\n{\n    for(unsigned i = 0; i < actualCnt; i++)\n    {\n        delete groups[i];\n    }\n    delete [] groups;\n}\n\nvoid LengthBucket::insertIntoGroups(unsigned stringID,\n                                    unsigned short position,\n                                    unsigned short length)\n{\n    //Use binary search to find the location to insert\n    signed left = 0;\n    signed right = (signed)actualCnt - 1;\n    signed mid = 0;\n    while(left <= right)\n    {\n        mid = (left+right)/2;\n        \n        if( length > (groups[mid])->getLength() )\n        {\n            left = mid + 1;\n        }\n        else if( length < (groups[mid])->getLength() )\n        {\n            right = mid - 1;\n        }\n        else\n        {\n            (groups[mid])->insertIntoPositions(stringID, position);\n            return;\n        }\n    }\n    \n    //Check whether it is necessary to allocate new space\n    actualCnt++;\n    if( actualCnt > sizeOfGroups )\n    {\n        unsigned newSizeOfGroups = sizeOfGroups+1;\n        GroupStringPosition ** newGroups = \n        new GroupStringPosition*[newSizeOfGroups];\n        for(unsigned i = 0; i < sizeOfGroups; i++)\n        {\n    \t     newGroups[i] = groups[i];\n        }\n        delete[] groups;\n        groups = newGroups;\n        sizeOfGroups  = newSizeOfGroups;\n    }\n    \n    //insert the new group\n    GroupStringPosition *groupStrPos = new GroupStringPosition(length,\n\t                                                           stringID,\n\t                                                           position);\n    for(signed i = (signed)actualCnt-1; i > (right+1); i--)\n    {\n        groups[i] = groups[i-1];\n    }\n    groups[right+1] = groupStrPos;\n    return;\t\t\t\t\t\t\t\t\t\n}\n\nvoid LengthBucket::appendToGroups(GroupStringPosition *groupStrPos)\n{\n    actualCnt++;\n    if( actualCnt > sizeOfGroups )\n    {\n        unsigned newSizeOfGroups = sizeOfGroups+1;\n        GroupStringPosition ** newGrops = \n        new GroupStringPosition*[newSizeOfGroups];\n        for(unsigned i = 0; i < sizeOfGroups; i++)\n        {\n            newGrops[i] = groups[i];\n        }\n        delete[] groups;\n        groups = newGrops;\n        sizeOfGroups  = newSizeOfGroups;\n    }\n    groups[actualCnt-1] = groupStrPos;\n}\n\nostream &operator << (ostream &output, const LengthBucket & bucket)\n{\n    //num of group\n    output << bucket.actualCnt <<\" \";\n    //GroupStringPosition\n    for(unsigned i = 0; i < bucket.actualCnt; i++) \n    {\n    \toutput << (*(bucket.groups[i]))<<\" \";\n    }\n    return output;\n}\n\nistream &operator >> (istream &input, LengthBucket & bucket)\n{\n    //num of groups\n    unsigned size;\n    input >> size;\n    //GroupStringPosition\n    for(unsigned i = 0; i < size; i++) \n    {\n        GroupStringPosition *groupPosPtr = new GroupStringPosition();\n        input >> (*groupPosPtr);\n        bucket.appendToGroups(groupPosPtr);\n    }\n    return input;\t\t\n}\n\nCountTable::CountTable():MAXCOUNT( 100000 )\n{\n    patternId = -1;\n    stringCount = 0;\n}\n\nCountTable::CountTable(const CountTable & countTable): MAXCOUNT( 100000 )\n{\n    this->patternId = countTable.patternId;\n    this->stringCount = countTable.stringCount;\n}\n\nCountTable::CountTable(const unsigned patternId, \n                       const unsigned count):  MAXCOUNT( 100000 )\n{\n    this->patternId = patternId;\n    this->stringCount = count;\n}\n\nCountTable::~CountTable()\n{\n}\n\nunsigned CountTable::addCount(unsigned patternId) \n{\n    //If the patternId is the previous one, just increase the count.\n    if ( this->patternId == patternId )\n    {\n        ++stringCount;\n    }\n\t//Otherwise reset the count to 0\n\telse \n\t{\n\t    this->patternId = patternId;\n\t    stringCount =1;\n    }\n    return stringCount;\n}\n\nunsigned CountTable::getCount(unsigned patternId) \n{\n    //If the patternId is the previous one, just increase the count.\n    if ( this->patternId == patternId )\n    {\n        return stringCount;\n    } \n    //Otherwise reset the count\tto 0\n\telse  \n    {\n        this->patternId = patternId;\n        stringCount = 0;\n        return 0;\n    }\n}\n\nvoid CountTable::resetCount(unsigned patternId)\n{\n    if ( this->patternId == patternId )\n    {\n        stringCount = MAXCOUNT;\n    }\n    else\n    {\n\t    this->patternId = patternId;\n\t    stringCount = MAXCOUNT;\n    }\n}\n", "encoding": "ascii"}