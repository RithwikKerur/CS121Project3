{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/topk/topksearch.cc", "content": "/*\n  $Id: topksearch.cc 5026 2010-02-17 20:25:03Z rares $\n\n  Copyright (C) 2007 by The Regents of the University of California\n \n  Redistribution of this file is permitted under the terms of the BSD\n  license\n\n  Date: 04/28/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"topksearch.h\"\n#include \"util/io.h\"\n\n#include <cassert>\n\nusing namespace std;\nusing namespace tr1;\n\nnamespace Topk \n{\n  const uint Search::k = 3;\n  const float Search::thr = .7;\n  \n  void Search::save(const string &filename) const \n  {\n    ofstream file(filename.c_str(), ios::out | ios::binary);\n\n    if (!file) {\n      cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    WRITING_FILE(filename);\n    save(file);\n    file.close();\n    WRITING_DONE();\n  }\n\n  void Search::save(ofstream &file) const \n  {\n    topkIndex.save(file);\n\n    uint sz = kwds.size();\n    file.write(reinterpret_cast<const char*>(&sz), sizeof(uint));\n\n    for (vector<KwdInfo*>::const_iterator kwd = kwds.begin();\n         kwd != kwds.end();\n         ++kwd) {\n      uchar ln = static_cast<uchar>((*kwd)->kwd.length());      \n      file.write(reinterpret_cast<const char*>(&ln), sizeof(uchar));\n      file.write((*kwd)->kwd.c_str(), (*kwd)->kwd.length());\n      file.write(reinterpret_cast<const char*>(&(*kwd)->count), sizeof(int));\n    }\n  }\n\n  void Search::load(const string &filename) \n  {\n    ifstream file(filename.c_str(), ios::in | ios::binary);\n\n    if (!file) {\n      cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    READING_FILE(filename);\n    load(file);\n    file.close();\n    READING_DONE();\n  }\n\n  void Search::load(ifstream &file) \n  {\n    topkIndex.load(file);\n\n    free();\n    kwds.clear();\n    kwdToKwdInfo.clear();\n\n    uint sz;\n    file.read(reinterpret_cast<char*>(&sz), sizeof(uint));\n\n    char *buf = new char[numeric_limits<uchar>::max()];\n    for (uint i = 0; i < sz; i++) {\n      uchar ln;\n      file.read(reinterpret_cast<char*>(&ln), sizeof(uchar));\n      file.read(buf, ln);\n\n      int count;\n      file.read(reinterpret_cast<char*>(&count), sizeof(int));\n      \n      string kwd(buf, ln);\n      KwdInfo *kwdInfo = new KwdInfo(kwd, count);\n      \n      kwds.push_back(kwdInfo);\n      kwdToKwdInfo.insert(make_pair(kwd, kwdInfo));\n    }\n    delete [] buf;\n\n    updateWeights();\n  }\n\n  void Search::updateWeights()\n  {\n    int countMin = *min_element(countsBegin(), countsEnd(), lessIgnoreLessOne);\n    transform(\n      countsBegin(), \n      countsEnd(), \n      weightsBegin(), \n      bind2nd(ptr_fun(weight), countMin));\n  }\n\n  void Search::free()\n  {\n    for (std::vector<KwdInfo*>::const_iterator kwd = kwds.begin();\n         kwd != kwds.end();\n         ++kwd) {\n      delete *kwd;\n    }\n  }\n\n  ostream& operator<<(ostream& output, const KwdInfo& k)\n  {\n    return output << k.kwd << \", \" << k.count << \", \" << k.weight;\n  }\n\n  ostream& operator<<(ostream& output, const Search& s)\n  {\n    output << \"== = search = ==\" << endl;\n    output << \"-- - kwds - --\" << endl;\n    for (vector<KwdInfo*>::const_iterator kwd = s.kwds.begin();\n         kwd != s.kwds.end();\n         ++kwd) {\n      output << **kwd << endl;\n    }\n    \n    output << \"== == ==\" << endl;\n    return output;\n  }\n\n  bool operator==(const Search& s1, const Search& s2) \n  {\n    if (&s1 == &s2) {\n      return true;\n    }\n\n    if (s1.kwds.size() != s2.kwds.size()) {\n      return false;\n    }\n\n    vector<KwdInfo*>::const_iterator i1, i2;\n    for (i1 = s1.kwds.begin(), i2 = s2.kwds.begin();\n         i1 != s1.kwds.end() && i2 != s2.kwds.end();\n         ++i1, ++i2) {\n      if (**i1 != **i2) {\n        return false;\n      }      \n    }\n    if (i1 != s1.kwds.end() || i2 != s2.kwds.end()) {\n      return false;\n    }\n\n    assert(s1.kwds.size() == s1.kwdToKwdInfo.size());\n    assert(s2.kwds.size() == s2.kwdToKwdInfo.size());\n\n    for (unordered_map<string, KwdInfo*>::const_iterator \n           p1 = s1.kwdToKwdInfo.begin();\n         p1 != s1.kwdToKwdInfo.end();\n         ++p1) {\n      unordered_map<string, KwdInfo*>::const_iterator p2 = \n        s2.kwdToKwdInfo.find(p1->first);\n      if (p2 == s2.kwdToKwdInfo.end()) {\n        return false;\n      }\n      if (*p1->second != *p2->second) {\n        return false;\n      }\n    }\n      \n    return true;\n  }\n}\n", "encoding": "ascii"}