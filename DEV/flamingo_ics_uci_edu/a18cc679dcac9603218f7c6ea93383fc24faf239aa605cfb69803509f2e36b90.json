{"url": "http://flamingo.ics.uci.edu/releases/1.0/src/sepia/freqest/test.cc", "content": "/*\n    $Id: test.cc 1107 2007-04-16 23:59:13Z rvernica $\n\n    Copyright (C) 2007 by The Regents of the University of California\n\n    Redistribution of this file is permitted under the terms of the\n    GNU Public License (GPL).\n\n    Date: 05/04/2006\n    Author: Rares Vernica <rvernica@ics.uci.edu>\n*/\n\n#include \"test.h\"\n\n#include <cmath>\n\n#include \"freqest.h\"\n\nTest::Test(vector<string>* dat, Clusters* clust,\n           SimType thresholdMin, SimType thresholdMax, bool doBuck):\n  data(dat), clusters(clust), errorCorr(NULL), \n  thresholdMin(thresholdMin), thresholdMax(thresholdMax), doBuck(doBuck)\n{\n  if (doBuck) \n    for (unsigned i = 0; i < 20; i++)\n      buck[i] = 0;\n}\n\nvoid Test::create(const set<unsigned> &setQuery) \n{\n  cerr << \"...build test\" << endl;\n  for (set<unsigned>::iterator it=setQuery.begin(); it!=setQuery.end(); it++) {\n    SimType dist;\n\n#if SIM_DIST == 1\n    dist = static_cast<SimType>(rand() % (thresholdMax - thresholdMin + 1)\n                                + thresholdMin);\n#elif SIM_DIST == 2\n    dist = static_cast<SimType>(rand() % \n                                static_cast<int>(thresholdMax * 10 -\n                                                 thresholdMin * 10 + 1)) /\n      10 + thresholdMin;\n#endif\n\n    Predicate p = Predicate((*data)[*it], dist);\n    p.freq = freqRealFunc(*data, p);\n\n    vectTest.push_back(p);\n  }\n}\n\nvoid Test::test() \n{\n  cerr << \"...test\" << endl;\n\n  sumRelErr=0;\n  sumRelErrCor=0;\n  noRelErr = 0;\n\n  for (unsigned i = 0; i < vectTest.size(); i++) {\n    Predicate p=vectTest[i];\n    float f, fCor;\n    unsigned r;\n\n    f = freqEstFunc(*data, *clusters, p); \n\n    r = p.freq;\n\n    if (r != 0) {\n      float  relErr = (f - r) / r;\n      sumRelErr += fabs(relErr);\n\t\n      if (errorCorr) {\n        float rCor = errorCorr->getError(Record(p, f, r));\n\n        if (rCor == -1)\n          fCor = f * 2;\n        else\n          fCor = f / (rCor + 1);\n\n        float relErrCor = (fCor - r) / r;\n\n        sumRelErrCor += fabs(relErrCor);\n\n        // buckets\n        if (doBuck) {\n          int idx = static_cast<int>(relErrCor * 4) + 5;\n          buck[idx]++;\n        }\n      }\n\n      noRelErr++;\n    }\n    else\n      cerr << \"...absolute error\" << endl;\n  }\n}\n\nostream& Test::info(ostream &out) const\n{\n  out << \"Test\" << endl << \"---\" << endl;\n  out << \"test size\\t\" << vectTest.size() << endl;\n  out << \"threshold\\t\" << thresholdMin << \" \" << thresholdMax << endl;\n  out << endl;\n  \n  int relativeError = static_cast<int>((sumRelErr / noRelErr) * 100);\n  int relativeErrorCorrected = static_cast<int>((sumRelErrCor \n                                                 / noRelErr) * 100);\n\n  out << \"Relative error\\t\" << relativeError\n      << \"%\" << endl;\n  if (errorCorr) {\n    out << \"Relative error corrected\\t\" << relativeErrorCorrected\n        << \"%\" << endl;\n    out << \"Relative error improvement\\t\" \n        << relativeError - relativeErrorCorrected\n        << \"%\" << endl;\n  }\n\n  if (doBuck) {\n    out << \"Relative error buckets\\t10\" << endl;\n    for (int i = 0; i < 20; i++)\n      out << (-125 + i * 25) << \"\\t\" \n          << static_cast<float>(buck[i]) / vectTest.size() << endl;\n  }\n\n  return out << endl;\n}\n\nostream& operator<<(ostream &out, const Test &t) \n{\n  return out << t.vectTest;\n}\n\nistream& operator>>(istream &in, Test &t) \n{\n  return in >> t.vectTest;\n}\n", "encoding": "ascii"}