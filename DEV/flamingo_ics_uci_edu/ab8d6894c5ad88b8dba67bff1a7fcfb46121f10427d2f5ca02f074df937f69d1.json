{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/util/src/misc.cc", "content": "/*\n  $Id: misc.cc 5713 2010-09-09 03:11:22Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the\n  BSD License.\n\n  Date: 01/30/2007\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"misc.h\"\n#include \"input.h\"\n\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <sys/stat.h>\n\nunsigned pow(unsigned x, unsigned y) \n{\n  unsigned r = 1;\n  while (y > 0) {\n    r *= x;\n    y--;\n  }\n  return r;\n}\n\nvector<vector<unsigned> > subsets(unsigned n, unsigned k) \n{\n  if (k == 0) {\n    cerr << \"subsets: k cannot be 0\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  vector<vector<unsigned> > subs;\n  vector<unsigned> sub(k);\n\n  unsigned i;\n  for (i = 0; i < k; i++)\n    sub[i] = i;\n  subs.push_back(sub);\n\n  while (sub[0] < n - k) {\n    for (i = 0; i < k; i++)\n      if (sub[k - i - 1] < n - i - 1)\n        break;\n    i = k - i - 1;\n    sub[i]++;\n    i++;\n    for (; i < k; i++)\n      sub[i] = sub[i - 1] + 1;\n    subs.push_back(sub);\n  }\n\n  return subs;\n}\n\nstring utosh(unsigned i) \n{\n  string str;\n  if (i < 1000)\n    str = utos(i);\n  else if (i < 1000000)\n    str = utos(i / 1000.) + \"k\";\n  else\n    str = utos(i / 1000000.) + \"m\";\n  return str;\n}\n\nUnsignedSeq::UnsignedSeq(unsigned initialValue): value(initialValue)\n{\n}\n\nunsigned UnsignedSeq::operator() ()\n{\n  return value++;\n}\n\nstring removeExt(const string filename)\n{\n  const string exts[] = {\"txt\", \"bin\"};\n  for (unsigned i = 0; i < sizeof(exts) / sizeof(string); i++)\n    if (filename.substr(filename.size() - 4) == \".\" + exts[i])\n      return filename.substr(0, filename.size() - 4);\n  return filename;\n}\n\nvoid writeerror(const string filename) \n{\n  cerr << \"can't write to file \\\"\" << filename << \"\\\"\" << endl;\n  exit(EXIT_FAILURE);\n}\n\nvoid readerror(const string filename) \n{\n  cerr << \"can't read from file \\\"\" << filename << \"\\\"\" << endl;\n  exit(EXIT_FAILURE);\n}\n\nvoid genZipfDist(unsigned distinctValues, unsigned zipfSkew, double valFreqs[]) {\n  double divisor = 0;\n  for(unsigned i = 1; i <= distinctValues; i++)\n    divisor += 1.0 / (double) pow((double)i, (double)zipfSkew);\n\n  for(unsigned i = 1; i <= distinctValues; i++)\n    valFreqs[i-1] = ( 1.0 / (double) pow((double)i, (double)zipfSkew) ) / divisor;\n}\n\nvoid enlargeDataset(const char* targetFile, \n\t\t    const char* inputFile, \n\t\t    unsigned targetSize,\n\t\t    unsigned minErrors,\n\t\t    unsigned maxErrors, \n\t\t    unsigned trueRand) {\n\n  if(trueRand) srand(time(NULL));\n  else srand(150);\n\n  unsigned maxStrLength = 1000;\n\n  vector<string> dictionary;\n  readString(dictionary, inputFile, targetSize, maxStrLength);\t\n\n  cout << \"GENERATING DICTIONARY\" << endl;\n  unsigned originalSize = dictionary.size();\n  while(dictionary.size() < targetSize) {\n    // read original strings and introduce errore\n    for(unsigned i = 0; i < originalSize; i++) {\n      string newString = dictionary.at(i);\n\n      // introduce errors\n      unsigned errors = (rand() % (maxErrors-minErrors)) + maxErrors;\n      for(unsigned j = 0; j < errors; j++) {\n\tunsigned pos = rand() % newString.size();\n\tunsigned op = rand() % 3;\n\tswitch(op) {\n\t  // deletion \n\tcase 0: {\n\t  if(newString.size() > 1) {\n\t    const string del = \"\";\n\t    newString.replace(pos, 1, del);\n\t  }\n\t} break;\n\n\t  // insertion\n\tcase 1: {\n\t  unsigned c = (rand() % (128-33)) + 33;\n\t  char newChar[2];\n\t  newChar[0] = c;\n\t  newChar[1] = '\\0';\n\t  newString.insert(pos, newChar);\t  \n\t} break;\n\n\t  // substitution\n\tcase 2: {\n\t  if(newString.size() > 0) {\n\t    unsigned c = (rand() % (128-33)) + 33;\n\t    char newChar[2];\n\t    newChar[0] = c;\n\t    newChar[1] = '\\0';\n\t    newString.replace(pos, 1, newChar);\n\t  }\n\t} break;\n\n\t}\n      }\n      \n      // push to dictionary vector\n      dictionary.push_back(newString);\n    }    \n  }\n\n  cout << \"WRITING TO \" << targetFile << endl;\n  unsigned perc = 0;\n\n  ofstream fp;\n  fp.open(targetFile, ios::out);\n\n  for(unsigned i = 0; i < dictionary.size(); i++) {\n    fp << dictionary.at(i) << endl;    \n    perc = (unsigned)ceil( (double)(i+1) / (double)dictionary.size()*100 );\n    cout << perc << \"%\" << \"\\r\";\n  }\n  cout << endl << \"ALL DONE!\" << endl;\n\n  fp.close();\n}\n\nvoid linearRegression(const vector<float>& xvals, const vector<float>& yvals, float& slope, float& intercept) {\n  float sumX = 0.0f;\n  float sumY = 0.0f;\n  float sumXY = 0.0f;\n  float sumXSquare = 0.0f;\n  unsigned n = xvals.size();\n\n  for(unsigned i = 0; i < n; i++) {\n    sumX += xvals.at(i);\n    sumY += yvals.at(i);\n    sumXY += xvals.at(i) * yvals.at(i);\n    sumXSquare += xvals.at(i) * xvals.at(i);\n  }  \n\n  slope = (n*sumXY - sumX*sumY) / (n*sumXSquare - sumX*sumX); \n  intercept = (sumY - slope*sumX) / (float)n;\n}\n\n// factorial function\ndouble factorial(unsigned n) {\n  double result = 1.0;\n  for(unsigned i = n; i > 1; i--)\n    result *= i;\n  return result;  \n}\n\nfloat binomialDistrib(unsigned k, unsigned n, float p, bool cumulative) {\n  if(cumulative) {\n    float res = 0.0;\n    for(unsigned i = k; i <= n; i++)\n      res += factorial(n)/(factorial(n-i)*factorial(i))*pow((float)p,(float)i)*pow((float)(1.0f-p),(float)(n-i));\n    return res;\n  }\n  else {\n    return factorial(n)/(factorial(n-k)*factorial(k))*pow((float)p,(float)k)*pow((float)(1.0f-p),(float)(n-k));\n  }\n}\n\nbool fileExists(const char* fileName) {\n  struct stat stFileInfo;\n  int intStat;\n  \n  intStat = stat(fileName, &stFileInfo);\n  if(intStat == 0) return true;\n  else return false; \n}\n\nbool getRandomFileName(string& target, unsigned maxAttempts) {\n  srand(time(NULL));\n  unsigned attempts = 0;\n  \n  while(attempts < maxAttempts) {\n    char fn[11];\n    unsigned r = rand();\n    sprintf(fn, \"%d\", r);    \n    \n    if(!fileExists(fn)) {\n      target.assign(fn);\n      return true;\n    }\n\n    attempts++;\n  }\n  \n  return false;\n}\n", "encoding": "ascii"}