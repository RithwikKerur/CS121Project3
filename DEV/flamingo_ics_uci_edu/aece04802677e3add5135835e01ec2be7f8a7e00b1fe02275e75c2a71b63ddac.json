{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/sepia/src/ppdtable/closeunique.cc", "content": "/*\n  $Id: closeunique.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/14/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"closeunique.h\"\n\n#include <algorithm>\n\nCloseUnique::CloseUnique(const vector<string> *d, Clusters *c, ContQueryPivot *q,\n                         const unsigned samplePer,\n                         const unsigned queueSize, const unsigned uniqueNo):\n  PPDSample(d, c, q, samplePer), queueSize(queueSize), uniqueNo(uniqueNo)\n{\n  // init - sample\n  sample = Sample(data->size());\n  sampleMax = static_cast<unsigned>(countUnique() * .4);\n  buildSample();\n\n  // init - loop\n  sampleIdx = 0;\n  unsigned j=samplePair.begin()->index;\n  samplePair.erase(samplePair.begin());\n  cluster=clusters->getCluster(j);\n  stringIt=cluster.begin();\n}\n\nvoid CloseUnique::step() \n{\n  stringIt++;\n  if (stringIt == cluster.end()) {\n    if (samplePair.empty()) {\n      sampleIdx++;\n      if (sampleIdx < max(1u, \n                          static_cast<unsigned>(static_cast<float>(samplePer) / \n                                                100 * data->size())))\n        buildSample();\n      else\n        return;\n    }\n    unsigned i = samplePair.begin()->index;\n    samplePair.erase(samplePair.begin());\n    cluster = clusters->getCluster(i);\n    stringIt = cluster.begin();\n  }\n}\n\nbool CloseUnique::hasNext() const \n{\n  if (sampleIdx < sampleMax && sample.hasNext())\n    return true;\n  return false;\n}\n\nPPDTriple CloseUnique::next() \n{\n  const unsigned q=sampleIdx;\n  const unsigned p=cluster.getPivot();\n  const unsigned s=*stringIt;\n\n  PPDTriple triple=PPDTriple(q,\n                             p,\n                             s,\n                             SimVect((*data)[q], (*data)[p]),\n                             SimVect((*data)[p], (*data)[s]),\n                             SimDist((*data)[q], (*data)[s]));\n\n  // increment\n  step();\n\n  return triple;\n}\n\nvoid CloseUnique::buildSample() \n{\n  unsigned sampleCrt = 0; \n  bool done = false;\n  set<SimVect>\n    newVect, \n    diffVect;\n\n  while (!done) {\n    if (!sample.hasNext())\n      break;\n    sampleCrt = sample.generate();\n    samplePair.clear();\n    newVect.clear();\n\n    for (unsigned i = 0; i < clusters->sizeCluster(); i++) {\n      const unsigned p = clusters->getCluster(i).getPivot();\n      SimVect vect = SimVect((*data)[sampleCrt], (*data)[p]);\n      if (samplePair.size() < queueSize || \n          vect.getDist() < samplePair.begin()->vect.getDist()) {\n        samplePair.insert(IndexEntryVect(i, vect));\n        newVect.insert(vect);\n        if (samplePair.size() > queueSize) {\n          samplePair.erase(samplePair.begin());\n          newVect.erase(vect);\n        }\n      }\n    }\n\n    diffVect.clear();\n    set_difference(newVect.begin(), newVect.end(), \n                   uniqueVect.begin(), uniqueVect.end(), \n                   inserter(diffVect, diffVect.begin()));\n    if (diffVect.size() >= uniqueNo) \n      done = true;\n  }\n  \n  sample.push_back(sampleCrt);\n  copy(diffVect.begin(), diffVect.end(), inserter(uniqueVect, uniqueVect.begin()));\n}\n\nunsigned CloseUnique::countUnique() \n{\n  unsigned sampleCrt = 0; \n  set<SimVect>\n    diffVect;\n\n  for (unsigned j = 0; j < data->size(); j++) {      \n    sampleCrt = j;\n\n    for (unsigned i = 0; i < clusters->sizeCluster(); i++) {\n      const unsigned p = clusters->getCluster(i).getPivot();\n      SimVect vect = SimVect((*data)[sampleCrt], (*data)[p]);\n\n      diffVect.insert(vect);\t\n    }\n  }\n  \n  return diffVect.size();\n}\n", "encoding": "ascii"}