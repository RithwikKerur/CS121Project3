{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/common/src/simmetric.cc", "content": "/*\n  $Id: simmetric.cc 5757 2010-10-12 06:02:30Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the\n  BSD license.\n  \n  Some of the code in this file is part of compression techniques.\n  Such parts are appropriately marked.\n  Redistribution of the compression techniques is permitted under \n  the terms of the Academic BSD License.\n  \n  Date: 04/15/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>, \n  Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"simmetric.h\"\n#include \"filtertypes.h\"\n#include \"util/src/misc.h\"\n\n#include <cmath>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n// ------------------------------ SimMetric       ------------------------------\n\nbool SimMetric::operator()(const string &s1, const string &s2, float threshold) \n  const \n{\n  return operator()(s1, s2) >= threshold;\n}\n\n\nbool SimMetric::simBatch(const std:: string& query, const std::string& candi, float simThreshold)\n{\n  return operator()(query, candi) >= simThreshold;\n}\n\n// ------------------------------ SimMetricEd     ------------------------------\n\nfloat SimMetricEd::operator()(const string &s1, const string &s2) \n  const \n{  \n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n\n  uint* d[2];\n  for (uint i = 0; i < 2; ++i)\n    d[i] = new uint[m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1, \n                           d[iCrt][j - 1] + 1), \n                       d[iPre][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  uint res = d[iPre][m];\n  \n  for (uint i = 0; i < 2; ++i)\n    delete [] d[i];\n  \n  return res;\n}\n\nbool SimMetricEd::lcFilter(const std::string& query, const std::string& candi, float simThreshold) {\n  uint T = static_cast<int>(simThreshold);\n\n  uint i;\n  uint\n    n = candi.length(), \n    m = query.length();\n  \n  const char* s1 = candi.data();\n  const char* s2 = query.data();\n\n  for(i = lcStart; i < lcEnd; i++) {\n    qLetterCounter[i] = 0;\n    tLetterCounter[i] = 0;\n  }\n  \n  for(i = 0; i < n; i++) qLetterCounter[(uint)(unsigned char)s1[i]]++;\n  for(i = 0; i < m; i++) tLetterCounter[(uint)(unsigned char)s2[i]]++;\n  \n  uint exc_sum = 0;\n  uint bel_sum = 0;\n  for(i = lcStart; i < lcEnd; i++) {\n    if(qLetterCounter[i] > tLetterCounter[i]) {\n      exc_sum += qLetterCounter[i] - tLetterCounter[i];\n      if(exc_sum > T) return false;\n    }\n    else {\n      bel_sum += tLetterCounter[i] - qLetterCounter[i];\n      if(bel_sum > T) return false;\n    }\n  }  \n  \n  return true;\n}\n\nbool SimMetricEd::simBatch(const string&__restrict__ candi, const string&__restrict__ query, float threshold) \n{\n  uint T = static_cast<int>(threshold);\n  \n  uint i, j, ii, jj;\n  uint\n    n = candi.length(), \n    m = query.length();\n  \n  const char*__restrict__ s1 = candi.data();\n  const char*__restrict__ s2 = query.data();\n\n  if (n == 0)\n    return m <= T;\n  if (m == 0)\n    return n <= T;\n  if ((n > m && n - m > T) ||  \n      (m > n &&  m - n > T))\n    return false;\n  \n\n  // LETTER COUNTING OPTIMIZATION\n\n  for(i = lcStart; i < lcEnd; i++) {\n    qLetterCounter[i] = 0;\n    tLetterCounter[i] = 0;\n  }\n  \n  for(i = 0; i < n; i++) qLetterCounter[(uint)(unsigned char)s1[i]]++;\n  for(i = 0; i < m; i++) tLetterCounter[(uint)(unsigned char)s2[i]]++;\n  \n  uint exc_sum = 0;\n  uint bel_sum = 0;\n  for(i = lcStart; i < lcEnd; i++) {\n    if(qLetterCounter[i] > tLetterCounter[i]) {\n      exc_sum += qLetterCounter[i] - tLetterCounter[i];\n      if(exc_sum > T) return false;\n    }\n    else {\n      bel_sum += tLetterCounter[i] - qLetterCounter[i];\n      if(bel_sum > T) return false;\n    }\n  }  \n  // LETTER COUNTING OPTIMIZATION\n  \n  uint dmin, dmax = T + 1;\n\n  for (i = 0; i <= n; i++)\n    matrix[i][0] = i;\n  for (j = 1; j <= m; j++)\n    matrix[0][j] = j;\n\n  for (ii = 1; ii <= n; ii++) {\n    dmin = dmax;\n    for (j = 1; j <= min(ii, m); j++) {\n      i = ii - j + 1;\n      matrix[i][j] = min(min(matrix[i - 1][j] + 1,\n                        matrix[i][j - 1] + 1),\n                    matrix[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(matrix[i][j], matrix[i - 1][j]));\n    }\n    if (dmin > T) return false;\n  }\n  \n  for (jj = 2; jj <= m; jj++) {\n    dmin = dmax;\n    for (j = jj; j <= min(n + jj - 1, m); j++) {\n      i = n - (j - jj);\n      matrix[i][j] = min(min(matrix[i - 1][j] + 1,\n\t\t\t     matrix[i][j - 1] + 1),\n\t\t\t matrix[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(matrix[i][j], matrix[i - 1][j]));\n    }\n\n    if (dmin > T) return false;\n  }\n  \n  return matrix[n][m] <= T;\n}\n\nfloat SimMetricEd::simBatch(const string& candi, const string& query) {\n  uint i, iCrt, iPre, j;\n  uint\n    n = candi.length(), \n    m = query.length();\n\n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n  \n  for (j = 0; j <= m; j++)\n    matrix[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    matrix[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      matrix[iCrt][j] = min(min(matrix[iPre][j] + 1, \n\t\t\t\tmatrix[iCrt][j - 1] + 1), \n\t\t\t    matrix[iPre][j - 1] + (candi[i - 1] == query[j - 1] ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  uint res = matrix[iPre][m];\n  \n  return res;\n}\n\nbool SimMetricEd::operator()(const string &s1, const string &s2, float threshold) \n  const \n{\n  uint T = static_cast<uint>(threshold);\n\n  uint i, j, ii, jj;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m <= T;\n  if (m == 0)\n    return n <= T;\n  if ((n > m && n - m > T) ||  \n      (m > n &&  m - n > T))\n    return false;\n\n  uint **d;\n  d = new uint*[n + 1];\n  for (uint i = 0; i < n + 1; ++i)\n    d[i] = new uint[m + 1];\n  \n  uint dmin, dmax = T + 1;\n\n  for (i = 0; i <= n; i++)\n    d[i][0] = i;\n  for (j = 1; j <= m; j++)\n    d[0][j] = j;\n\n  for (ii = 1; ii <= n; ii++) {\n    dmin = dmax;\n    for (j = 1; j <= min(ii, m); j++) {\n      i = ii - j + 1;\n      d[i][j] = min(min(d[i - 1][j] + 1,\n                        d[i][j - 1] + 1),\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(d[i][j], d[i - 1][j]));\n    }\n    if (dmin > T) {\n      for (uint i = 0; i < n + 1; ++i)\n\tdelete [] d[i];\n      delete [] d;\n      return false;\n    }\n  }\n  \n  for (jj = 2; jj <= m; jj++) {\n    dmin = dmax;\n    for (j = jj; j <= min(n + jj - 1, m); j++) {\n      i = n - (j - jj);\n      d[i][j] = min(min(d[i - 1][j] + 1,\n                        d[i][j - 1] + 1),\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(d[i][j], d[i - 1][j]));\n    }\n\n    if (dmin > T) {\n      for (uint i = 0; i < n + 1; ++i)\n\tdelete [] d[i];\n      delete [] d;\n      return false;\n    }\n  }\n\n  bool res = d[n][m] <= T;\n  \n  for (uint i = 0; i < n + 1; ++i)\n    delete [] d[i];\n  delete [] d;\n\n  return res;\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEd::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes, \n  const float simThreshold, \n  const CompressionArgs* compressArgs) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  uint q = gramGen.getGramLength();\n  uint numGrams = queryGramCodes.size();\n\n  if(!compressArgs) return numGrams - (q * edThreshold); \n  else {\n    // compression arguments set, analyze them\n    // check to see if we have a blacklist\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;\n\n      if(!compressArgs->holesOptimized) {\n        // using holes compression but optimization is disabled\n        // count the number of holes\n        uint numberHoles = 0;\n        for(uint i = 0; i < numGrams; i++)\n          if( blackList->find( queryGramCodes.at(i )) != blackList->end() ) \n            numberHoles++;\n\t\n        return numGrams - (edThreshold * q) - numberHoles;\n      }\n      else {\n        // we have holes compression with optimization turned on\n        // start dynamic programming algorithm\n\t\n        // initialize dynamic programming matrix\n        uint numberHoles = 0;\n        uint imax = edThreshold + 1;\n        uint jmax = numGrams + q;\n        uint dpMatrix[imax][jmax];\n        memset(*dpMatrix, 0, sizeof(uint)*imax*jmax);\n\t\n        // initialize singlePosVector and count number of holes\n        uint singlePosVector[numGrams];\n        memset(singlePosVector, 0, sizeof(uint)*numGrams);\n        uint killCounter = 0;\n        for(uint i = 0; i < numGrams; i++) {\n          if(i >= q) {      \n            if( blackList->find( queryGramCodes.at(i - q) ) == blackList->end() ) \n              killCounter--;    \n          }\n\t  \n          uint gramCode = queryGramCodes.at(i);        \n          if( blackList->find(gramCode) == blackList->end() ) killCounter++;\n          else numberHoles++;\n          singlePosVector[i] = killCounter;\n        }\n\t\n        // start dynamic programming algorithm\n        for(uint i = 1; i < imax; i++) {\n          for(uint j = q; j < jmax; j++) {\n            uint a = dpMatrix[i][j-1];\n            uint b = singlePosVector[j-q] + dpMatrix[i-1][j-q];     \n            dpMatrix[i][j] = (a>b) ? a : b;\n          }\n        }\n\t\n        return numGrams - numberHoles - dpMatrix[imax-1][jmax-1];\n      }\n    }\n    else {\n      // blackList is NULL, return default\n      return numGrams - (q * edThreshold);\n    }\n  }\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEd::getMergeThreshold(\n  const string& query, \n  const float simThreshold, \n  const uint numberHoles) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  uint originalT = gramGen.getNumGrams(query) - \n    (gramGen.getGramLength() * edThreshold);\n  return originalT - numberHoles;\n}\n\nvoid SimMetricEd::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = query.length() - edThreshold;\n    if((signed)lbound <= 0) lbound = 0;\n    ubound = query.length() + edThreshold;\n  } break;\n    \n  case FT_CHARSUM: { \n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint sum = csFilter->getCharsum(query);\n    lbound = sum - (edThreshold * csFilter->getMaxChar());\n    if((signed)lbound < 0) lbound = 0;\n    ubound = sum + (edThreshold * csFilter->getMaxChar());\n  } break;\n\n  default: {\n    cout << \"UNKNOWN FILTER TYPE IN getFilterBounds\" << endl;\n    lbound = 0;\n    ubound = 0;\n  } break;\n\n  }\n}\n  \nfloat SimMetricEd::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEd::getSimMin Not Implemented\" << endl; \n  exit(1); \n}\n\nfloat SimMetricEd::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsQuery - noGramsCommon) / \n    gramGen.getGramLength();\n}\n\nuint SimMetricEd::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = noGramsQuery - sim * gramGen.getGramLength();\n  return th > 1 ? static_cast<uint>(floor(th)) : 1;\n}\n\nuint SimMetricEd::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return noGramsQuery + sim;\n}\n\n// ------------------------------ SimMetricEdNorm ------------------------------\n\nfloat SimMetricEdNorm::operator()(const string &s1, const string &s2) \n  const \n{\n  return 1.0f - static_cast<float>(SimMetricEd::operator()(s1, s2)) / \n    max(s1.length(), s2.length());\n}\n\nbool SimMetricEdNorm::operator()(const string &s1, const string &s2, float threshold) \n  const \n{  \n  return SimMetricEd::operator()(s1, s2, ceil((1.0f - threshold) * max(s1.length(), s2.length())));\n}\n\nbool SimMetricEdNorm::simBatch(const std:: string& candi, const std::string& query, float simThreshold)\n{  \n  return SimMetricEd::simBatch(candi, query, ceil((1.0f - simThreshold) * max(candi.length(), query.length())));\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEdNorm::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{  \n  float ed = ceil((1.0f - simThreshold) * query.length());\n  return this->SimMetricEd::getMergeThreshold(query, queryGramCodes, ed, compressArgs);\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEdNorm::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  float ed = ceil((1.0f - simThreshold) * query.length());\n  return this->SimMetricEd::getMergeThreshold(query, ed, numberHoles);  \n}\n\nvoid SimMetricEdNorm::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  float ed = ceil((1.0f - simThreshold) * query.length());\n  this->SimMetricEd::getFilterBounds(query, ed, filter, lbound, ubound);\n} \n\nfloat SimMetricEdNorm::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return 0;\n}\n\nfloat SimMetricEdNorm::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return 1 - static_cast<float>(noGramsQuery - noGramsCommon) / \n    (gramGen.getGramLength() * lenQuery);\n}\n\nuint SimMetricEdNorm::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = noGramsQuery - (1 - sim) * lenQuery * gramGen.getGramLength(); \n  return th > 1 ? static_cast<uint>(floor(th)) : 1;\n}\n\nuint SimMetricEdNorm::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = \n    (noGramsQuery +  (1 - sim) * (1 -  gramGen.getGramLength())) / sim; \n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\n// ------------------------------ SimMetricEdSwap ------------------------------\n\nfloat SimMetricEdSwap::operator()(const string &s1, const string &s2) \n  const \n{\n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  uint* d[2];\n  for (uint i = 0; i < 2; ++i)\n    d[i] = new uint[m + 1];\n  \n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1,\n                           d[iCrt][j - 1] + 1),\n                       d[iPre][j - 1] + ((s1[i - 1] == s2[j - 1] ||\n                                          (i > 1 &&\n                                           j > 1 &&\n                                           s1[i - 1] == s2[j - 2] &&\n                                           s1[i - 2] == s2[j - 1])) ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  uint res = d[iPre][m];\n  \n  for (uint i = 0; i < 2; ++i)\n    delete [] d[i];\n  \n  return res;\n}\n\nuint SimMetricEdSwap::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n  cerr << \"SimMetricEdSwap::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEdSwap::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricEdSwap::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricEdSwap::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricEdSwap::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n} \n\nfloat SimMetricEdSwap::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEdSwap::getSimMin Not Implemented\" << endl;\n  exit(1);\n}\n\nfloat SimMetricEdSwap::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEdSwap::getSimMax Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricEdSwap::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricEdSwap::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricEdSwap::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricEdSwap::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n// ------------------------------ SimMetircGram   ------------------------------\n\n// ------------------------------ SimMetricJacc   ------------------------------\n\nfloat SimMetricJacc::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sUni;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  uint interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d = static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n \nfloat SimMetricJacc::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsCommon) / \n    (noGramsQuery + noGramsData - noGramsCommon);\n}\n\nvoid SimMetricJacc::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold);\n    ubound = (uint)ceil(((float)numGrams/simThreshold)); \n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold);\n    uint maxGrams = (uint)ceil(((float)numGrams/simThreshold)); \n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar());\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar());\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricJacc::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{\n  uint numGrams = queryGramCodes.size();\n  if(!compressArgs) return (uint)floor(simThreshold*(numGrams));\n  else {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) { \n        uint gramCode = queryGramCodes.at(i);\n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \n      } \n\t\n      return (uint)floor(simThreshold*numGrams); \n    }\n    else {\n      // compression but no holes compression, so return default\n      return (uint)floor(simThreshold*(numGrams));\n    }\n  }\n}\n \n// ATTENTION: part of compression techniques\nuint SimMetricJacc::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  return (uint)floor(simThreshold * gramGen.getNumGrams(query) -  numberHoles);\n}\n\nuint SimMetricJacc::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = max(sim * noGramsQuery,\n                 (noGramsQuery + noGramsMin) / (1 + 1 / sim));\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\nuint SimMetricJacc::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return noGramsQuery / sim;\n}\n\n// ------------------------------ SimMetricJaccBag   ------------------------------\n\nfloat SimMetricJaccBag::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<uint> s1Gram, s2Gram, sUni;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n  \n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  uint interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d = static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n\nbool SimMetricJaccBag::simBatch(const string &candi, const string &query, float simThreshold) \n{ \n  if(candi.length() == 0 || query.length() == 0) return 0;\n  \n  candiGrams.clear();\n  gramGen.decompose(candi, candiGrams);  \n  sort(candiGrams.begin(), candiGrams.end());\n  \n  setUnion.clear();\n\n  set_union(candiGrams.begin(), candiGrams.end(),\n\t    queryGrams.begin(), queryGrams.end(), \n\t    inserter(setUnion, setUnion.begin()));\n  \n  uint interSize  = candiGrams.size() + queryGrams.size() - setUnion.size();\n  \n  float d = static_cast<float>(interSize) / setUnion.size();  \n  return d >= simThreshold;\n}\n \nfloat SimMetricJaccBag::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsCommon) / \n    (noGramsQuery + noGramsData - noGramsCommon);\n}\n     \nvoid SimMetricJaccBag::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold);\n    ubound = (uint)ceil(((float)numGrams/simThreshold)); \n    if(gramGen.prePost) {\n      cout << \"WARNING: JaccBag used with a pre- and postfixing gramgen!\" << endl;\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold);\n    uint maxGrams = (uint)ceil(((float)numGrams/simThreshold)); \n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar());\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar());\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricJaccBag::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{\n  uint numGrams = queryGramCodes.size();\n  uint q = gramGen.getGramLength();\n  // assuming no pre- and postfixing\n  uint minNumGrams = (minStrLen < q) ? 1 : minStrLen - q + 1;\n  float cmp = (float)(numGrams + minNumGrams) / (1.0f + (1.0f / simThreshold));\n  \n  if(compressArgs) {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) { \n        uint gramCode = queryGramCodes.at(i);\n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \n      }      \n    }\n  }\n  \n  return (uint) max(floor(simThreshold * (float)numGrams), cmp);\n}\n \n// ATTENTION: part of compression techniques\nuint SimMetricJaccBag::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  return (uint)floor(simThreshold * gramGen.getNumGrams(query) -  numberHoles);\n}\n\nuint SimMetricJaccBag::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = max(sim * noGramsQuery,\n                 (noGramsQuery + noGramsMin) / (1 + 1 / sim));\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\nuint SimMetricJaccBag::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return noGramsQuery / sim;\n}\n\n// ------------------------------ SimMetricCos    ------------------------------\n\nfloat SimMetricCos::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  static_cast<float>(sInt.size()) / \n    sqrt(static_cast<float>(s1Gram.size() * s2Gram.size()));\n  \n  return d;\n}\n      \nfloat SimMetricCos::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return noGramsCommon / sqrt(static_cast<float>(noGramsQuery * noGramsData));\n}\n     \nuint SimMetricCos::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n\n  // uint gramLength = gramGen.getGramLength();\n  uint numGrams = queryGramCodes.size();\n  if(!compressArgs) return (uint)floor(simThreshold*simThreshold*numGrams); \n  else {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) {     \n        uint gramCode = queryGramCodes.at(i);\t  \n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \t  \n      } \t\n      return (uint)floor(simThreshold*simThreshold*numGrams); \n    }\n    else {\n      // compression but no holes compression, so return default\n      return (uint)floor(simThreshold*simThreshold*numGrams); \n    }\n  }    \n}\n  \n// ATTENTION: part of compression techniques\nuint SimMetricCos::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  return (uint)floor(simThreshold*simThreshold*gramGen.getNumGrams(query) - \n                         numberHoles);   \n}\n\nvoid SimMetricCos::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n    \n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n    \n  switch(filter->getType()) {\n      \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold*simThreshold - gramLength + 1);\n    ubound = (uint)ceil(((float)numGrams/(simThreshold*simThreshold)) - gramLength + 1);\n    if ((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold*simThreshold);\n    uint maxGrams = (uint)ceil((float)numGrams/(simThreshold*simThreshold));\n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar()*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar()*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }\n}\n\nuint SimMetricCos::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = sim * sqrt(static_cast<float>(noGramsQuery * noGramsMin));\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\nuint SimMetricCos::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricCos::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n// ------------------------------ SimMetricDice   ------------------------------\n\nfloat SimMetricDice::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  2. * sInt.size() / (s1Gram.size() + s2Gram.size());\n  \n  return d;\n}\n      \nfloat SimMetricDice::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricDice::operator(noGramsData, noGramQuery, noGramsCommon) \"\n       << \"Not Implemented\" << endl;\n  exit(1);\n}\n     \nuint SimMetricDice::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n \n// ATTENTION: part of compression techniques\nuint SimMetricDice::getMergeThreshold(\n\tconst string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricDice::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    ubound = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n    \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    uint maxGrams = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar()*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar()*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricDice::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDice::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricDice::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDice::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n// ------------------------------ SimGramCount    ------------------------------\n\nfloat SimMetricGramCount::operator()(\n  const string &s1, \n  const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n  \n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  return sInt.size();\n}\n      \nfloat SimMetricGramCount::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return noGramsCommon;\n}\n     \nuint SimMetricGramCount::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{\n  cerr << \"SimMetricGramCount::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricGramCount::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricGramCount::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricGramCount::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricGramCount::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricGramCount::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return static_cast<uint>(sim);\n}\n\nuint SimMetricGramCount::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricGramCount::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n\n// ------------------------------ SimMetricCosBag  ------------------------------\n\nfloat SimMetricCosBag::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n  \n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  static_cast<float>(sInt.size()) / \n    sqrt(static_cast<float>(s1Gram.size() * s2Gram.size()));\n  \n  return d;\n}\n      \nbool SimMetricCosBag::simBatch(const std::string& query, const std::string& candi, float simThreshold) {\n\n  if(query.length() == 0 || candi.length() == 0) return 0;\n  \n  candiGrams.clear();\n  gramGen.decompose(candi, candiGrams);\n  sort(candiGrams.begin(), candiGrams.end());\n  \n  intersection.clear();\n  set_intersection(queryGrams.begin(), queryGrams.end(),\n                   candiGrams.begin(), candiGrams.end(), \n                   inserter(intersection, intersection.begin()));\n  \n  float d =  static_cast<float>(intersection.size()) / \n    sqrt(static_cast<float>(queryGrams.size() * candiGrams.size()));\n  \n  return d >= simThreshold;\n}\n\n\nfloat SimMetricCosBag::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  cout << \"SimMetricCosBag::operator() not implemented yet\" << endl;\n  exit(1);\n}\n\nuint SimMetricCosBag::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n  uint numGrams = queryGramCodes.size();\n  uint q = gramGen.getGramLength();\n  // assuming no pre- and postfixing\n  uint minNumGrams = (minStrLen < q) ? 1 : minStrLen - q + 1;\n  \n  if(compressArgs) {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) { \n        uint gramCode = queryGramCodes.at(i);\n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \n      }      \n    }\n  }\n  \n  return floor(simThreshold * sqrt(numGrams) * sqrt(minNumGrams));\n}\n  \n// ATTENTION: part of compression techniques\nuint SimMetricCosBag::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cout << \"SimMetricCosBag::getMergeThreshold not implemented yet\" << endl;\n  exit(1);\n}\n\nvoid SimMetricCosBag::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n    \n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n    \n  switch(filter->getType()) {\n      \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold*simThreshold - gramLength + 1);\n    ubound = (uint)ceil(((float)numGrams/(simThreshold*simThreshold)) - gramLength + 1);\n    if ((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold*simThreshold);\n    uint maxGrams = (uint)ceil((float)numGrams/(simThreshold*simThreshold));\n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar()*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar()*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }\n}\n\nuint SimMetricCosBag::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricCosBag::getNoGramsMin Not Implemented\" << endl; \n  exit(1);\n}\n\nuint SimMetricCosBag::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricCos::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n\n// ------------------------------ SimMetricDiceBag   ------------------------------\n\nfloat SimMetricDiceBag::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n  \n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  2. * sInt.size() / (s1Gram.size() + s2Gram.size());\n  \n  return d;\n}\n      \nbool SimMetricDiceBag::simBatch(const string &candi, const string &query, float simThreshold) \n{\n  if(candi.length() == 0 || query.length() == 0) return 0;\n  \n  candiGrams.clear();\n  gramGen.decompose(candi, candiGrams);\n  sort(candiGrams.begin(), candiGrams.end());\n  \n  intersection.clear();\n  set_intersection(candiGrams.begin(), candiGrams.end(),\n                   queryGrams.begin(), queryGrams.end(), \n                   inserter(intersection, intersection.begin()));\n  \n  float d =  2.0f * (float)intersection.size() / (candiGrams.size() + queryGrams.size());\n  \n  return d >= simThreshold;\n}\n\nfloat SimMetricDiceBag::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricDice::operator(noGramsData, noGramQuery, noGramsCommon) \"\n       << \"Not Implemented\" << endl;\n  exit(1);\n}\n     \nuint SimMetricDiceBag::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n  uint numGrams = queryGramCodes.size();\n  uint q = gramGen.getGramLength();\n  // assuming no pre- and postfixing\n  uint minNumGrams = (minStrLen < q) ? 1 : minStrLen - q + 1;\n  \n  if(compressArgs) {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) { \n        uint gramCode = queryGramCodes.at(i);\n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \n      }      \n    }\n  }\n  \n  return floor(simThreshold * ((float)numGrams + (float)minNumGrams) / 2.0f);\n}\n \n// ATTENTION: part of compression techniques\nuint SimMetricDiceBag::getMergeThreshold(\n\tconst string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricDiceBag::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    ubound = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n    \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    uint maxGrams = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar()*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar()*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricDiceBag::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDiceBag::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricDiceBag::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDiceBag::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n", "encoding": "ascii"}