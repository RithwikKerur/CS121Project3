{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/topk/src/perftest_util.cc", "content": "/*\n  $Id: perftest_util.cc 5772 2010-10-19 07:15:28Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the BSD\n  license\n\n  Date: 06/25/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"perftest_util.h\"\n\n#include <cmath>\n#include <iomanip>\n\n#define DEBUG_TIMER\n\n#include \"misc.h\"\n#include \"util/src/input.h\"\n#include \"util/src/io.h\"\n#include \"util/src/misc.h\"\n#include \"util/src/debug.h\"\n\nusing namespace std;\nusing namespace Topk;\n\nconst string PerfData::path = \"/data/topk/\";\n\nstring getDataName(PerfDataName dataName)\n{\n  switch (dataName) {\n  case PerfDataIMDB:\n    return \"IMDB\";\n  case PerfDataWebCorpus:\n    return \"WebCorpus\";\n  case PerfDataDBLP:\n    return \"DBLP\";\n  default:\n    return \"Unknown\";\n  }\n}\n\nPerfData::PerfData(const GramGen &gramGen, PerfDataName name, uint no): \n  no(no)\n{\n  vector<string> dataWithWeights;\n  vector<Record> records;\n        \n  switch (name) {\n  case PerfDataIMDB:\n    setFn(path + \"imdb/actors.txt\");\n\n    if (exist()){\n      load();\n      return;\n    }\n\n    readString(dataWithWeights, fn, no);\n    no = dataWithWeights.size();\n\n    for (uint i = 0; i < no; i++) {\n\n      string dat = dataWithWeights[i];\n      uint pos = dat.find('\\t');\n\n      Record r;\n      r.text = dat.substr(0, pos);\n      // r.weight = 1 - 1. / atoi(dat.substr(pos + 1).c_str());\n      // r.weight = atoi(dat.substr(pos + 1).c_str()) / 5047.;\n      r.weight = log(atoi(dat.substr(pos + 1).c_str())) / log(5319);\n\n      records.push_back(r);\n    }\n\n    break;\n  case PerfDataWebCorpus:\n    setFn(path + \"webcorpus/webcorpus.shuf.2.4m.txt\");\n\n    if (exist()){\n      load();\n      return;\n    }\n\n    readString(dataWithWeights, fn, no);\n    no = dataWithWeights.size();\n\n    for (uint i = 0; i < no; i++) {\n      string dat = dataWithWeights[i];\n      uint pos = dat.find('\\t');\n\n      Record r;\n      r.text = dat.substr(0, pos);\n      // r.weight = 1 - 1. / atoi(dat.substr(pos + 1).c_str());\n      // r.weight = atoi(dat.substr(pos + 1).c_str()) / 15087432.;\n      r.weight = log(atoi(dat.substr(pos + 1).c_str())) / log(15087432);\n\n      records.push_back(r);\n    }\n    break;\n  case PerfDataDBLP:\n    setFn(path + \"dblp/articles.rank.csv\");\n\n    if (exist()){\n      load();\n      return;\n    }\n\n    readString(dataWithWeights, fn, no, 700);\n    no = dataWithWeights.size();\n\n    for (uint i = 0; i < no; i++) {\n\n      string dat = dataWithWeights[i];\n      uint pos = dat.find('\\t');\n\n      Record r;\n      r.text = dat.substr(0, pos);\n      r.weight = 1. / atoi(dat.substr(pos + 1).c_str());\n\n      records.push_back(r);\n    }\n    break;\n  case PerfDataENRON:\n    setFn(path + \"enron/words.txt\");\n\n    if (exist()){\n      load();\n      return;\n    }\n\n    readString(dataWithWeights, fn, no);\n    no = dataWithWeights.size();\n\n    for (uint i = 0; i < no; i++) {\n      string dat = dataWithWeights[i];\n      uint pos = dat.find('\\t');\n\n      Record r;\n      r.text = dat.substr(0, pos);\n      r.weight = atof(dat.substr(pos + 1).c_str());\n\n      records.push_back(r);\n    }\n    break;    \n  }\n  \n  // sort data elements by weight\n  stable_sort(records.begin(), records.end(), greater<Record>());\n\n  data = new string[no];\n  weights = new float[no];\n  nograms = new uint[no];\n\n  for (uint i = 0; i < no; i++) {\n    data[i] = records[i].text;\n    weights[i] = records[i].weight;\n    nograms[i] = gramGen.getNumGrams(data[i]);\n  }\n\n  save();\n}\n\nvoid PerfData::setFn(string fn) \n{\n  this->fn = fn;\n  fnStr = fn.substr(0, fn.rfind('.')) + \"/data/data.\" + utosh(no) + \".str.txt\";\n  fnWht = fn.substr(0, fn.rfind('.')) + \"/data/data.\" + utosh(no) + \".wht.bin\";\n  fnNGr = fn.substr(0, fn.rfind('.')) + \"/data/data.\" + utosh(no) + \".ngr.bin\";\n}\n\nbool PerfData::exist()\n  const\n{ \n  return existFile(fnStr) && existFile(fnWht) && existFile(fnNGr);\n}\n\nvoid PerfData::load()\n{\n  data = new string[no];\n  weights = new float[no];\n  nograms = new uint[no];\n  readTextFile<string>(fnStr, data);\n  readBinaryFile<float>(fnWht, weights);\n  readBinaryFile<uint>(fnNGr, nograms);\n}  \n\nvoid PerfData::save() \n  const\n{\n  writeTextFile<string>(fnStr, data, data + no);\n  writeBinaryFile<float>(fnWht, weights, weights + no);\n  writeBinaryFile<uint>(fnNGr, nograms, nograms + no);\n}\n\nstring randomEdit(string s, uint noEd)\n{\n  for (uint i = 0; i < noEd; ++i) {\n    uint pos = rand() % s.length();\n    s[pos] = s[pos] + 1;\n  }\n\n  return s;\n}\n\nPerfQue::PerfQue(\n  const PerfData &data, \n  uint no, \n  uint noData, \n  uint noKwd, \n  uint noEd): \n  no(no), noKwd(noKwd) \n{\n  if (noData == 0 || noData > data.no)\n    noData = data.no;\n\n  string fn = data.fn.substr(0, data.fn.rfind('.')) + \n    \"/que/data.\" + utosh(noData) + \".que.\" + utosh(no) + \n    (noKwd == 1? \"\" : \".\" + utosh(noKwd) + \".\" + utosh(noEd)) + \".txt\";\n  \n  if (existFile(fn)) \n    readString(que, fn);\n  else {\n    selectRandom(data.data, data.data + noData, back_inserter(que), no);\n\n    srand(time(0));\n    for (uint i = 0; i < no; i += noKwd)\n      for (uint j = 1; j < noKwd && i + j < no; ++j)\n        que[i + j] = randomEdit(que[i], noEd);\n\n    writeTextFile<string>(fn, que.begin(), que.end());\n  }\n}\n  \nPerfAns::PerfAns(\n  const PerfData &data, \n  const PerfQue &que, \n  const SimMetric &simMetric,      \n  uint no, \n  bool isWeight): \n  no(no) \n{\n  string fn = data.fn.substr(0, data.fn.rfind('.')) + \n    \"/ans/data.\" + utosh(data.no) + \n    \".que.\" + utosh(que.no) + \n    \".ans.\" + utosh(no) + \n    \".\" + (isWeight ? \"wh\" : \"nw\") + \n    \".q.\" + utos(simMetric.gramGen.getGramLength()) + \n    \".\" + simMetric.name + \".bin\";\n\n  if (existFile(fn))\n    load(fn);\n  else \n    {\n      cerr << \"building ans...\" << endl;\n      TIMER_START(\"ans\", que.no);\n      for (vector<string>::const_iterator qu = que.que.begin(); \n           qu != que.que.end(); ++qu) {\n        multiset<Answer, less<Answer> > ansTopk;\n        set<uint> gramQue;\n        simMetric.gramGen.decompose(*qu, gramQue);\n        for (uint i = 0; i < data.no; i++) {\n          set<uint> gramData;\n          simMetric.gramGen.decompose(data.data[i], gramData);\n          set<uint> gramInter;\n          set_intersection(\n            gramQue.begin(), \n            gramQue.end(), \n            gramData.begin(), \n            gramData.end(), \n            inserter(gramInter, gramInter.begin()));\n          if (gramInter.size()) {\n            float sim = simMetric(*qu, data.data[i]);\n            ansTopk.insert(Answer(i, score(sim, data.weights[i])));\n            if (ansTopk.size() > no)\n              ansTopk.erase(ansTopk.begin());\n          }\n        \n        }\n        vector<unsigned> answID;\n        for (multiset<Answer, less<Answer> >::const_reverse_iterator a = \n               ansTopk.rbegin(); a != ansTopk.rend(); ++a) {\n          answID.push_back(a->wID);\n        }\n        ans.push_back(answID);\n        TIMER_STEP();\n      }\n      TIMER_STOP();\n      cerr << \"OK\" << endl;\n    \n      save(fn);\n    }\n}\n\nvoid PerfAns::load(const string &filename)\n{\n  vector<uint> *data = new vector<uint>;\n  readBin(*data, filename);\n  for (vector<uint>::const_iterator dat = data->begin(); dat != data->end(); ) {\n    uint count = *dat; \n    ++dat;\n    vector<uint> a;\n    for (uint i = 0; i < count; i++, ++dat)\n      a.push_back(*dat);\n    ans.push_back(a);\n  }\n  delete data;\n}\n\nvoid PerfAns::save(const string &filename) \n  const\n{\n  vector<uint> *data = new vector<uint>;\n  for (vector<vector<uint> >::const_iterator an = ans.begin();\n       an != ans.end(); ++an) {\n    data->push_back(an->size());\n    for (vector<uint>::const_iterator a = an->begin(); a != an->end(); ++a)\n      data->push_back(*a);\n  }\n  writeBinaryFile<uint>(filename, data->begin(), data->end());\n  delete data;\n}\n  \nbool PerfAns::isEqual(\n  const PerfData &data, \n  const SimMetric &simMetric,\n  const vector<uint> &topk, \n  const vector<uint> &ans, \n  const Query &q)\n{\n  const float eps = .0001;  // .000001\n  if (topk != ans) {\n    for (uint i = 0; i < topk.size(); i++) {\n      float \n        sc_t = score(\n          simMetric(q.str, data.data[topk[i]]), data.weights[topk[i]]), \n        sc_a = score(\n          simMetric(q.str, data.data[ans[i]]), data.weights[ans[i]]);\n\n      if (topk[i] != ans[i] && \n          !(fabs(sc_t - sc_a) < numeric_limits<float>::epsilon() + eps)) {\n        SimMetricGramCount s(q.sim.gramGen);\n        cerr << q.str << endl\n             << \"t: \" << setw(7) << topk[i] << ' '\n             << setw(20) << data.data[topk[i]] << \", \"\n             << setw(2) << static_cast<uint>(s(q.str, data.data[topk[i]])) \n             << \", \"\n             << simMetric(q.str, data.data[topk[i]]) << ' '\n             << data.weights[topk[i]] << ' '\n             << sc_t\n             << endl\n             << \"a: \" << setw(7) << ans[i] << ' '\n             << setw(20) << data.data[ans[i]] << \", \"\n             << setw(2) << static_cast<uint>(s(q.str, data.data[ans[i]])) \n             << \", \"\n             << simMetric(q.str, data.data[ans[i]]) << ' '\n             << data.weights[ans[i]] << ' '\n             << sc_a\n             << endl\n             << fabs(sc_t - sc_a)\n             << endl;\n        return false;\n      }\n    }\n    if (topk.size() != ans.size()) {\n      cerr << \"topk.size: \" << topk.size() \n           << \" ans.size \" << ans.size() << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\nPerfIndex::PerfIndex(const PerfData &data, const GramGen &gramGen, uint ver)\n{\n  string fn = data.fn.substr(0, data.fn.rfind('.')) + \n    \"/gram/data.\" + utosh(data.no) + \".q.\" + utos(gramGen.getGramLength()) + \n    (ver ? \".v\" + utos(ver) : \"\") + \".bin\";\n\n  if (existFile(fn))\n    if (ver)\n      index_v1.load(fn);\n    else\n      index.load(fn);\n  else {\n    if (ver) {\n      index_v1.build(data.data, data.data + data.no, gramGen);\n      index_v1.save(fn);\n    }\n    else {\n      index.build(data.data, data.data + data.no, gramGen);\n      index.save(fn);\n    }\n  }\n}\n", "encoding": "ascii"}