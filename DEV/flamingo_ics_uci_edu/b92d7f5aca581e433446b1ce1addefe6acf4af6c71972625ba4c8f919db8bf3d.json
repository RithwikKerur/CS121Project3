{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/filtertree/src/stringcontainer.cc", "content": "/*\n  $Id: stringcontainer.cc 5786 2010-10-22 04:24:20Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 04/04/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"stringcontainer.h\"\n\n#include \"common/src/gramgen.h\"\n#include \"common/src/simmetric.h\"\n#include \"util/src/misc.h\"\n#include <cfloat>\n#include <cstring>\n\ntemplate<>\nStringContainerVector*\ncreateDefaultStringContainer(unsigned blockSize, unsigned avgStrLen) {\n  return new StringContainerVector(true); \n}\n\ntemplate<>\nStringContainerRM*\ncreateDefaultStringContainer(unsigned blockSize, unsigned avgStrLen) {\n  StringContainerRM* container = new StringContainerRM(true);\n  container->createContainer(\"default2.rm\", blockSize, avgStrLen);\n  container->openContainer(\"default2.rm\", true);\n  return container;\n}\n\nFilterStats::\nFilterStats(AbstractFilter* filter)\n  : filter(filter), gramGen(NULL) {\n  begin();\n}\n\nvoid \nFilterStats::\nbegin() {\n  minKey = 0xFFFFFFFF;\n  maxKey = 0;\n  wtedAvgValCount = 0;\n  countMap.clear();\n}\n\nvoid\nFilterStats::\nnext(const string& s) {\n  unsigned key = filter->getKey(s, gramGen);\n  countMap[key]++;\n  if(key < minKey) minKey = key;\n  if(key > maxKey) maxKey = key;\n}\n\nvoid\nFilterStats::\nend(float ed, unsigned strCount) {\n  unsigned start = 0;\n  unsigned stop = 0;        \n  GramGenFixedLen gramGen(3);\n  SimMetricEd sim(gramGen);\n  sim.getFilterBounds(\"\", 1, filter, start, stop);\n  stop = ed * stop;\n  \n  // compute weighted average\n  unsigned valCount = 0;\n  unordered_map<unsigned, unsigned>::iterator iter;   \n  for(unsigned i = minKey; i <= minKey + stop; i++) {\n    iter = countMap.find(i);\n    if(iter != countMap.end()) valCount += iter->second;                  \n  }    \n  float weight = (float)valCount / (float)strCount;\n  float totalWeight = weight;\n  wtedAvgValCount = (float)valCount * weight;\n  \n  for(unsigned i = minKey + stop + 1; i <= maxKey; i++) {\n    unsigned j = i - (minKey + stop + 1);\n    \n    iter = countMap.find(i);\n    if(iter != countMap.end()) valCount += iter->second;                  \n    \n    iter = countMap.find(j);\n    if(iter != countMap.end()) valCount -= iter->second;            \n    \n    if((signed) valCount < 0) valCount = 0;\n    \n    weight = (float)valCount / (float)strCount;\n    totalWeight += weight;\n    wtedAvgValCount += (float)valCount * weight;      \n  }\n  wtedAvgValCount /= totalWeight;\n  \n  countMap.clear();\n}\n\nvoid \nStatsCollector::\nbegin() {\n  maxStrLen = 0;\n  minStrLen = 0xFFFFFFFF;\n  avgStrLen = 0;\n  strCount = 0;\n  memset(charFreqs, 0, 256 * sizeof(unsigned));\n  \n  clearFilterStats();\n  \n  FilterStats* lengthFilter = new FilterStats(new LengthFilter((unsigned)0));\n  lengthFilter->setGramGen(gramGen);\n  filterStats.push_back(lengthFilter);\n\n  if(gramGen->getType() != GGT_WORDS) {\n    FilterStats* charsumFilter = new FilterStats(new CharsumFilter((unsigned)0));\n    charsumFilter->setGramGen(gramGen);\n    filterStats.push_back(charsumFilter);\n  }\n}\n\nvoid\nStatsCollector::\nnext(const string& s) {\n  for(unsigned i = 0; i < filterStats.size(); i++)\n    filterStats[i]->next(s);\n  \n  avgStrLen += s.size();\n  strCount++;  \n\n  for(unsigned i = 0; i < s.size(); i++) {\n    unsigned char ix = (unsigned char)s[i];\n    charFreqs[ix]++;\n  }\n\n  if(s.length() < minStrLen) minStrLen = s.length();\n  if(s.length() > maxStrLen) maxStrLen = s.length();\n  \n}\n\nvoid \nStatsCollector::\nend() {      \n  avgStrLen /= (float)strCount;    \n  float ed = (unsigned)(avgStrLen - floor(avgStrLen * 0.85));\n  \n  for(unsigned i = 0; i < filterStats.size(); i++)\n    filterStats[i]->end(ed, strCount);\n}\n\nFilterStats*\nStatsCollector::\ngetBestPartFilter() {\n  unsigned bestIx = 0xFFFFFFFF;\n  float bestValCount = FLT_MAX;\n  for(unsigned i = 0; i < filterStats.size(); i++) {\n    float currValCount = filterStats[i]->getWtedAvgValCount();\n    if(currValCount < bestValCount) {\n      bestIx = i;\n      bestValCount = currValCount;\n    }\n  }\n  \n  if(bestIx != 0xFFFFFFFF) return filterStats[bestIx];\n  else return NULL;\n}\n\nvoid \nStatsCollector::\nclearFilterStats() {\n  for(unsigned i = 0; i < filterStats.size(); i++)\n    if(filterStats[i]) delete filterStats[i];\n  filterStats.clear();\n}\n\nStatsCollector::  \n~StatsCollector() {\n  clearFilterStats();\n}\n\nvoid\nStringContainerVector::\nfillContainer_Impl(const char* fileName, const unsigned count, const unsigned maxLineLen) {\n  if(pho != PHO_NONE) {\n    StringContainerVector* tempContainer = createDefaultStringContainer<StringContainerVector>(0, 0);\n    this->fillContainer(tempContainer, fileName, count, maxLineLen);\n    this->copyReorg(tempContainer);\n    delete tempContainer;\n  }\n  else {\n    fillContainer(this, fileName, count, maxLineLen);\n  }\n}\n\nvoid \nStringContainerVector::\nintegrateUpdates_Impl(const unordered_set<unsigned>& deletedStringIds, unsigned* stringIdMapping) {\n  vector<string> tmp;\n  \n  unsigned deleted = 0;\n  for(unsigned i = 0; i < container.size(); i++) {\n    if(deletedStringIds.find(i) == deletedStringIds.end()) {\n      tmp.push_back(container[i]);\n      stringIdMapping[i] = i - deleted;\n    }\n    else {\n      deleted++;\n      stringIdMapping[i] = 0xFFFFFFFF; // mark id as deleted\n    }\n  }\n\n  if(pho == PHO_NONE) {\n    std::swap(container, tmp);\n  }\n  else {\n    // TODO: maintain physical order\n  }\n}\n\nvoid\nStringContainerRM::\nfillContainer_Impl(const char* fileName, const unsigned count, const unsigned maxLineLen) {\n  if(pho != PHO_NONE) {\n    StringContainerRM* tempContainer = createDefaultStringContainer<StringContainerRM>(blockSize, avgStrLen);\n    this->fillContainer(tempContainer, fileName, count, maxLineLen);\n    this->copyReorg(tempContainer);\n    delete tempContainer;\n    int ret = system(\"rm default2.rm\"); // WARNING: OS specific\n    if(ret != 0) cout << \"Temp container file default2.rm could not be deleted\" << endl;\n    ret = system(\"rm ridmap_default2.rm\"); // WARNING: OS specific\n    if(ret != 0) cout << \"Temp ridmapfile file ridmap_default2.rm could not be deleted\" << endl;\n  }\n  else {\n    fillContainer(this, fileName, count, maxLineLen);\n  }\n  \n  writeRidMapFile();\n  \n  flushCache();\n}\n", "encoding": "ascii"}