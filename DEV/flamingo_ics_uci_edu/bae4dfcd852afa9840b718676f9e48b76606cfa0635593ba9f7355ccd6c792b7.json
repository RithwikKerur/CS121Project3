{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/filtertree/src/unittest.cc", "content": "/*\n  $Id: unittest.cc 5756 2010-10-12 04:21:00Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 04/04/2008\n  Author: Alexander Behm\n*/\n\n#include \"ftindexerdiscardlists.h\"\n#include \"ftindexercombinelists.h\"\n#include \"ftsearchermem.h\"\n#include \"common/src/query.h\"\n#include \"common/src/simmetric.h\"\n#include \"listmerger/src/divideskipmerger.h\"\n#include \"listmerger/src/scancountmerger.h\"\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\nusing namespace tr1;\n\n// ASSUMPTIONS: uncompressed indexer with no filters delivers correct results\n// it will be used to fill expectedResults\n\n// global vars for performing unittests\nStringContainerVector strContainer;\nvector<Query*> queries;\nvector<string> queryStrings;\nvector<unsigned> expectedResults;\nGramGenFixedLen gramGen(3);\nSimMetricEd simMetric(gramGen);\n\nvoid init();\nvoid deinit();\nbool compareResults(vector<unsigned>& results, const string& identifier);\n\nbool testFtIndexerMem();\nbool testFtIndexerDiscardListsLLF();\nbool testFtIndexerDiscardListsSLF();\nbool testFtIndexerDiscardListsRandom();\nbool testFtIndexerDiscardListsTimeCost();\nbool testFtIndexerDiscardListsTimeCostPlus();\nbool testFtIndexerDiscardListsPanicCost();\nbool testFtIndexerDiscardListsPanicCostPlus();\nbool testFtIndexerCombineListsBasic();\nbool testFtIndexerCombineListsCost();\n\nint main() {\n  init();\n\n  bool passed = false;\n\n  cout << \"NOTE: THESE TESTS MAY TAKE SOME MINUTES, PLEASE BE PATIENT\" << endl << endl;\n  \n  cout << \"TEST FtIndexerMem:\" << endl;\n  passed = testFtIndexerMem();  \n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;\n  cout << endl;\n\n  cout << \"TEST FtIndexerDiscardListsLLF:\" << endl;  \n  passed = testFtIndexerDiscardListsLLF();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n  \n  cout << \"TEST FtIndexerDiscardListsSLF:\" << endl;  \n  passed = testFtIndexerDiscardListsSLF();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerDiscardListsRandom:\" << endl;  \n  passed = testFtIndexerDiscardListsRandom();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerDiscardListsTimeCost:\" << endl;  \n  passed = testFtIndexerDiscardListsTimeCost();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerDiscardListsTimeCostPlus:\" << endl;  \n  passed = testFtIndexerDiscardListsTimeCostPlus();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerDiscardListsPanicCost:\" << endl;  \n  passed = testFtIndexerDiscardListsPanicCost();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerDiscardListsPanicCostPlus:\" << endl;  \n  passed = testFtIndexerDiscardListsPanicCostPlus();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerCombineListsBasic:\" << endl;  \n  passed = testFtIndexerCombineListsBasic();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  cout << \"TEST FtIndexerCombineListsCost:\" << endl;  \n  passed = testFtIndexerCombineListsCost();\n  if(passed) cout << \"--- PASSED ---\" << endl;\n  else cout << \"--- FAILED ---\" << endl;  \n  cout << endl;\n\n  deinit();\n  return 0;\n}\n\nvoid init() {\n  cout << \"INITIALIZING UNITTEST\" << endl;\n\n  vector<string> prefixes;\n  prefixes.push_back(\"string\");\n  prefixes.push_back(\"example\");  \n  prefixes.push_back(\"test\");\n  prefixes.push_back(\"hello\");\n  prefixes.push_back(\"world\");\n  prefixes.push_back(\"foo\");\n  prefixes.push_back(\"bar\");\n  \n  vector<string> suffixes;\n  suffixes.push_back(\"1\");\n  suffixes.push_back(\"10\");\n  suffixes.push_back(\"100\");\n  suffixes.push_back(\"2\");\n  suffixes.push_back(\"20\");\n  suffixes.push_back(\"200\");\n  suffixes.push_back(\"3\");\n  suffixes.push_back(\"30\");\n  suffixes.push_back(\"300\");\n  \n  for(unsigned j = 0; j < prefixes.size(); j++)\n    for(unsigned i = 0; i < suffixes.size(); i++)\n      strContainer.insertString(prefixes.at(j) + suffixes.at(i));\n  \n  // create queries\n  queries.push_back(new Query(\"xample\", simMetric, 2.0f));\n  queries.push_back(new Query(\"ring1\", simMetric, 2.0f));\n  queries.push_back(new Query(\"wrld\", simMetric, 2.0f));\n  queries.push_back(new Query(\"fooa\", simMetric, 2.0f));\n  queries.push_back(new Query(\"br\", simMetric, 2.0f));  \n\n  for(unsigned i = 0; i < 10; i++) {\n    queryStrings.push_back(\"xample\");\n    queryStrings.push_back(\"ring1\");\n    queryStrings.push_back(\"wrld\");\n    queryStrings.push_back(\"fooa\");\n    queryStrings.push_back(\"br\");\n  }\n\n  // execute queries on uncompressed index without filters to get expected results\n  FtIndexerMem<> indexer(&strContainer, &gramGen);\n  indexer.buildIndex();\n  MergeOptMerger<> merger;\n  FtSearcherMem<> searcher(&merger, &indexer);\n\n  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n    searcher.search(**iter, expectedResults);\n    \n  // sort expected results\n  sort(expectedResults.begin(), expectedResults.end());\n  \n  cout << \"UNITTEST INITIALIZED\" << endl << endl;\n}\n\nvoid deinit() {\n  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n    delete *iter;  \n}\n\nbool compareResults(vector<unsigned>& results, const string& identifier) {\n  // compare results\n  sort(results.begin(), results.end());\n  if(results.size() != expectedResults.size()) {\n    cout << \"FAILED IN \" << identifier << endl;\n    return false;\n  }\n\n  for(unsigned i = 0; i < results.size(); i++)\n    if(results.at(i) != expectedResults.at(i)) {\n      cout << \"FAILED IN \" << identifier << endl;\n      return false;\n    }\n\n  return true;\n}\n\nbool testFtIndexerMem() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<> searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      vector<unsigned> results;      \n\n      // begin block for indexer with lengthfilter\n      {\n\tFtIndexerMem<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addPartFilter(new LengthFilter(maxStrLength));\n\tindexer.buildIndex();      \n\n\t// execute queries and compute results\n\tresults.clear();\n\tsearcher.setFtIndexer(&indexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerMem<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t  cout << \"FtIndexerMem, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH FILTER LOADED\");\n      }\n\n      // begin block for indexer with checksum filter\n      {\n\tFtIndexerMem<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addPartFilter(new CharsumFilter(maxStrLength));\n\tindexer.buildIndex();      \n\n\t// execute queries and compute results\n\tsearcher.setFtIndexer(&indexer);\t\n\tresults.clear();\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, CHARSUM FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerMem<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t  cout << \"FtIndexerMem, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, CHARSUM FILTER LOADED\");\n      }\n\n      // begin block for indexer with both length and checksum filters\n      {\n\tFtIndexerMem<> indexer(&strContainer, &gramGen, maxStrLength, fanout);\n\tindexer.addPartFilter(new LengthFilter(maxStrLength));\n\tindexer.addPartFilter(new CharsumFilter(maxStrLength));\n\tindexer.buildIndex();      \n\n\t// execute queries and compute results\n\tsearcher.setFtIndexer(&indexer);      \n\tresults.clear();\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH+CHARSUM FILTER BUILT\");\n\n\t// save index, load it into differrent indexer and repeat\n\tindexer.saveIndex(\"UnittestIndex.ix\");\n\tFtIndexerMem<> loadedIndexer(&strContainer);\n\tloadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\n\tif(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t   && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t  cout << \"FtIndexerMem, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t  success = false;\n\t}\n\n\tresults.clear();\n\tsearcher.setFtIndexer(&loadedIndexer);\t\n\tfor(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t  searcher.search(**iter, results);\n\t\n\tsuccess = success && compareResults(results, \"FtIndexerMem, LENGTH FILTER LOADED\");\n      }\n\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerDiscardListsLLF() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsLLF<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsLLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsLLF, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsLLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsLLF, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsLLF, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsLLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsLLF, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsLLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsLLF, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsLLF, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsLLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsLLF, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsLLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsLLF, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsLLF, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerDiscardListsSLF() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsSLF<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsSLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsSLF, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsSLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsSLF, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsSLF, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsSLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsSLF, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsSLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsSLF, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsSLF, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsSLF<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsSLF, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsSLF<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsSLF, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsSLF, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerDiscardListsRandom() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsRandom<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsRandom<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsRandom, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsRandom<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsRandom, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsRandom, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsRandom<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsRandom, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsRandom<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsRandom, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsRandom, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsRandom<> indexer(&strContainer, &gramGen, compressionRatio, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsRandom, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsRandom<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsRandom, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsRandom, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerDiscardListsTimeCost() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsTimeCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCost, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsTimeCost, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCost, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCost, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsTimeCost, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCost, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCost, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsTimeCost, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCost, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\n\nbool testFtIndexerDiscardListsTimeCostPlus() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsTimeCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCostPlus, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsTimeCostPlus, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCostPlus, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsTimeCostPlus, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCostPlus, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsTimeCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCostPlus, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsTimeCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsTimeCostPlus, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsTimeCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerDiscardListsPanicCost() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsPanicCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCost, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsPanicCost, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCost, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCost, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsPanicCost, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCost, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, true, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCost, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsPanicCost, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCost, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerDiscardListsPanicCostPlus() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerDiscardListsPanicCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerDiscardListsPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCostPlus, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerDiscardListsPanicCostPlus, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerDiscardListsPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCostPlus, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsPanicCostPlus, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCostPlus, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerDiscardListsPanicCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, false, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCostPlus, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerDiscardListsPanicCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerDiscardListsPanicCostPlus, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerDiscardListsPanicCostPlus, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerCombineListsBasic() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger(true);\n  \n  FtSearcherMem<FtIndexerCombineListsBasic<> > searcher(&merger);\n  \n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerCombineListsBasic<> indexer(&strContainer, &gramGen, compressionRatio, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsBasic, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerCombineListsBasic<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerCombineListsBasic, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\t  \n\n\t  success = success && compareResults(results, \"FtIndexerCombineListsBasic, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerCombineListsBasic<> indexer(&strContainer, &gramGen, compressionRatio, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsBasic, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerCombineListsBasic<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerCombineListsBasic, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsBasic, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerCombineListsBasic<> indexer(&strContainer, &gramGen, compressionRatio, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsBasic, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerCombineListsBasic<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerCombineListsBasic, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsBasic, LENGTH FILTER LOADED\");\n\t}\n\t\n      }\n    }\n  }\n\n  return success;\n}\n\nbool testFtIndexerCombineListsCost() {  \n  GramGenFixedLen gramGen(3);\n  SimMetricEd simMetric(gramGen);\n  MergeOptMerger<> merger;\n  \n  FtSearcherMem<FtIndexerCombineListsCost<> > searcher(&merger);\n\n  bool success = true;\n\n  // try different filters with different fanouts and values for max string length\n  for(unsigned maxStrLength = 10; maxStrLength <= 200; maxStrLength += 10) {\n    for(unsigned fanout = 1; fanout <= 10; fanout++) {\n      for(float compressionRatio = 0.1f; compressionRatio <= 0.7f; compressionRatio += 0.1f) {\n\tvector<unsigned> results;\n\t\n\t// begin block for indexer with lengthfilter\n\t{\n\t  FtIndexerCombineListsCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  cout << \"INDEX BUILT\" << endl;\n\n\t  // execute queries and compute results\n\t  results.clear();\n\t  searcher.setFtIndexer(&indexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsCost, LENGTH FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerCombineListsCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH) {\n\t    cout << \"FtIndexerCombineListsCost, LENGTH FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsCost, LENGTH FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with checksum filter\n\t{\n\t  FtIndexerCombineListsCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);\t\n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsCost, CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerCombineListsCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerCombineListsCost, CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsCost, CHARSUM FILTER LOADED\");\n\t}\n\t\n\t// begin block for indexer with both length and checksum filters\n\t{\n\t  FtIndexerCombineListsCost<> indexer(&strContainer, &gramGen, compressionRatio, &queryStrings, &simMetric, 2.0f, 0.1f, 0.1f, maxStrLength, fanout);\n\t  indexer.addPartFilter(new LengthFilter(maxStrLength));\n\t  indexer.addPartFilter(new CharsumFilter(maxStrLength));\n\t  indexer.buildIndex();      \n\t  \n\t  // execute queries and compute results\n\t  searcher.setFtIndexer(&indexer);      \n\t  results.clear();\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsCost, LENGTH+CHARSUM FILTER BUILT\");\n\t  \n\t  // save index, load it into differrent indexer and repeat\n\t  indexer.saveIndex(\"UnittestIndex.ix\");\n\t  FtIndexerCombineListsCost<> loadedIndexer(&strContainer);\n\t  loadedIndexer.loadIndex(\"UnittestIndex.ix\");\n\t  \n\t  if(loadedIndexer.filterTypes.at(0)->getType() != FT_LENGTH\n\t     && loadedIndexer.filterTypes.at(1)->getType() != FT_CHARSUM) {\n\t    cout << \"FtIndexerCombineListsCost, LENGTH+CHARSUM FILTER LOADED INCORRECTLY\" << endl;\n\t    success = false;\n\t  }\n\t  \n\t  results.clear();\n\t  searcher.setFtIndexer(&loadedIndexer);\t\n\t  for(vector<Query*>::iterator iter = queries.begin(); iter != queries.end(); iter++)\n\t    searcher.search(**iter, results);\n\t  \n\t  success = success && compareResults(results, \"FtIndexerCombineListsCost, LENGTH FILTER LOADED\");\n\t}\t\n      }\n    }\n  }\n\n  return success;\n}\n", "encoding": "ascii"}