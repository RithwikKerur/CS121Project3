{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/lbaktree/src/kwdsstorage.cc", "content": "/*\n $Id: kwdsstorage.cc 5795 2010-10-23 01:18:03Z abehm $\n \n Copyright (C) 2010 by The Regents of the University of California\n \n Redistribution of this file is permitted under\n the terms of the BSD license.\n \n Date: 08/19/2010\n Author: Sattam Alsubaiee <salsubai (at) ics.uci.edu>\n*/\n\n#include \"kwdsstorage.h\"\n\nKeywordsFile::KeywordsFile(string fileName)\n{\n\tkeywordsFileName = fileName;\n\tbuffer = 0;\n}\n\nvoid KeywordsFile::readIndex(string indexFileName, bool newFile)\n{\n  \tfstream indexFile;\n\t\n\tif(newFile)\n\t{\n\t\tindexFile.open(indexFileName.c_str(), ios_base::in | ios_base::out | ios_base::binary | ios_base::trunc);\n\t}\n\telse\n\t{\n\t\tindexFile.open(indexFileName.c_str(), ios_base::in | ios_base::out | ios_base::binary);\n\t\tif(indexFile.is_open())\n\t\t{\n\t\t\tindexFile.seekg(0, ios_base::end);\n\t\t\tif(indexFile.tellg() / sizeof(IndexNode) > 0)\n\t\t\t{\n\t\t\t\tindexFile.seekg(0, ios_base::beg);\n\t\t\t\tIndexNode irec;\n\t\t\t\twhile(!indexFile.eof())\n\t\t\t\t{\n\t\t\t\t\tindexFile.read((char *)&irec, sizeof(irec));\n\t\t\t\t\tindexMap[irec.id] = irec;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindexFile.close();\n\t\t}\n\t}\n}\n\nvoid KeywordsFile::writeIndex()\n{\n  \tfstream indexFile;\n\tIndexNode irec;\n\tindexFile.open((keywordsFileName + \".idx\").c_str(), ios_base::in | ios_base::out | ios_base::binary | ios_base::trunc);\n\tif(indexFile.is_open())\n\t{\n\t\tunordered_map <unsigned, IndexNode>::iterator it; \n\t\tfor (it = indexMap.begin(); it != indexMap.end(); ++it) \n\t\t{\n\t\t\tirec = (*it).second;\n            indexFile.write((char *)&irec, sizeof(irec));\n\t\t}\n\t\tindexFile.close();\n\t}\n}\n\nIndexNode KeywordsFile::getIndexNode(unsigned id)\n{\n\treturn indexMap[id];\n}\n\nbool KeywordsFile::open(bool newFile)\n{\n\tif(newFile)\n\t{\n\t\tkeywordsFile.open((keywordsFileName + \".dat\").c_str(), ios_base::in | ios_base::out | ios_base::binary | ios_base::trunc);\n\t}\n\telse\n\t{\n\t\tkeywordsFile.open((keywordsFileName + \".dat\").c_str(), ios_base::in | ios_base::out | ios_base::binary);\n\t}\n\treadIndex(keywordsFileName + \".idx\", newFile);\n\treturn keywordsFile.is_open();\n}\n\n\nKeywordsFile::~KeywordsFile()\n{\n\tif(keywordsFile.is_open())\n\t{\n\t\tclose();\n\t}\n}\n\nunordered_map <unsigned, IndexNode>::iterator KeywordsFile::begin()\n{\n\treturn indexMap.begin();\n}\n\nunordered_map <unsigned, IndexNode>::iterator KeywordsFile::end()\n{\n\treturn indexMap.end();\n}\n\nvoid KeywordsFile::close()\n{\n\twriteIndex();\n\tkeywordsFile.close();\n\tkeywordsFile.clear();\n\tindexMap.clear();\n}\n\nbool KeywordsFile::write(string text, unsigned id, unsigned numKeywords)\n{\n    bool result = true;\n\tIndexNode irec;\n\t\n\ttry\n\t{\t\n\t\tunordered_map<unsigned, IndexNode>::iterator it;\n\t\tit = indexMap.find(id);\n\t\t\n\t\tif(it != indexMap.end())\n\t\t{\n\t\t\tindexMap.erase(it);\n\t\t\tkeywordsFile.seekp((it->second).position);\n\t\t\tirec.position = keywordsFile.tellp();\n\t\t\tirec.size = text.length();\n\t\t\tirec.id = id;\n\t\t\tirec.numKeywords = numKeywords;\n\t\t\tindexMap[id] = irec;\n\t\t\tkeywordsFile.write(text.c_str(), (std::streamsize)text.length());\n\t\t\tkeywordsFile.seekp(0, ios_base::end);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tirec.position = keywordsFile.tellp();\n\t\t\tirec.size = text.length();\n\t\t\tirec.id = id;\n\t\t\tirec.numKeywords = numKeywords;\n\t\t\tindexMap[id] = irec;\n\t\t\tkeywordsFile.write(text.c_str(), (std::streamsize)text.length());\n\t\t}\n\t}\n\tcatch(char *ex)\n\t{\n\t\tcout << \"Problem writing \" << ex << endl;\n\t\tresult = false;\n\t}\n    \n\treturn (result); \n}\n\nstring KeywordsFile::read(unsigned id)\n{\n\tIndexNode irec = indexMap[id];\n\tif(buffer)\n\t{\n\t\tdelete [] buffer;\n\t}\n\tbuffer = new char[irec.size + 1];\n\tkeywordsFile.seekg(irec.position, ios_base::beg);\n\tkeywordsFile.read(buffer, irec.size);\n\tbuffer[irec.size] = '\\0';\n\treturn (string)buffer;\n}\n\nunsigned KeywordsFile::getRecordCount()\n{\n\treturn (unsigned)indexMap.size();\n}\n", "encoding": "ascii"}