{"url": "http://flamingo.ics.uci.edu/releases/2.0/src/util/simfuncs.cc", "content": "/*\n  $Id: simfuncs.cc 4026 2008-10-01 00:23:25Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the\n  BSD license\n\n  Date: 05/10/2007\n  Author: Jiaheng Lu\n          Rares Vernica \n*/\n\n#include \"simfuncs.h\"\n\n#include <fstream>\n#include <iostream>\n\n#include \"misc.h\"\n#include \"gram.h\"\n\n#include \"output.h\"\n\nunsigned ed(const string &s1, const string &s2)\n{ \n  unsigned i, iCrt, iPre, j;\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n\n  unsigned d[2][m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(d[iPre][j] + 1, \n                       d[iCrt][j - 1] + 1, \n                       d[iPre][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  return d[iPre][m];\n}\n\nbool substringed(const string &longS, const string &shortS, unsigned threshold)\n{ \n \n  unsigned i, j;\n  unsigned\n    m = longS.length(), \n    n = shortS.length();\n\n  if ((n == 0)|| (m == 0))\n    return false;\n  \n  if (m<n) return false;\n\n  unsigned d[n+1][m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = 0;\n\n  for (i = 0; i <= n; i++)\n    d[i][0] = i;\n\n  \n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++)\n      d[i][j] = min(d[i-1][j] + 1, \n\t\t    d[i][j - 1] + 1, \n\t\t    d[i-1][j - 1] + (longS[j-1] == shortS[i-1] ? 0 : 1));\n   \n  }\n  \n  for(unsigned k=0;k<m+1;k++)\n    if (d[n][k] <= threshold)\n      return true;\n\n  return false;\n\n}//end substringed\n\nbool ed(const string &s1, const string &s2, unsigned threshold) \n{\n  unsigned i, j, ii, jj;\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m <= threshold;\n  if (m == 0)\n    return n <= threshold;\n  if ((n > m && n - m > threshold) ||  \n      (m > n &&  m - n > threshold))\n    return false;\n\n  unsigned d[n + 1][m + 1], dmin, dmax = threshold + 1;\n\n  for (i = 0; i <= n; i++)\n    d[i][0] = i;\n  for (j = 1; j <= m; j++)\n    d[0][j] = j;\n\n  for (ii = 1; ii <= n; ii++) {\n    dmin = dmax;\n    for (j = 1; j <= min(ii, m); j++) {\n      i = ii - j + 1;\n      d[i][j] = min(d[i - 1][j] + 1,\n                    d[i][j - 1] + 1,\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, d[i][j], d[i - 1][j]);\n    }\n    if (dmin > threshold)\n      return false;\n  }\n  \n  for (jj = 2; jj <= m; jj++) {\n    dmin = dmax;\n    for (j = jj; j <= min(n + jj - 1, m); j++) {\n      i = n - (j - jj);\n      d[i][j] = min(d[i - 1][j] + 1,\n                    d[i][j - 1] + 1,\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, d[i][j], d[i - 1][j]);\n    }\n    if (dmin > threshold)\n      return false;\n  }\n\n  return d[n][m] <= threshold;\n}\n\nunsigned edSwap(const string &s1, const string &s2)\n{ \n  unsigned i, iCrt, iPre, j;\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n  unsigned d[2][m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(d[iPre][j] + 1,\n                       d[iCrt][j - 1] + 1,\n                       d[iPre][j - 1] + ((s1[i - 1] == s2[j - 1] ||\n                                          (i > 1 &&\n                                           j > 1 &&\n                                           s1[i - 1] == s2[j - 2] &&\n                                           s1[i - 2] == s2[j - 1])) ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  return d[iPre][m];\n}\n\nfloat normalizedED(const string &s1, const string &s2)\n{ \n  \n   unsigned distance = ed(s1,s2);\n\n  if (s1.size()<s2.size())\n    return (1-distance*1.0/s2.size());\n  else\n    return (1-distance*1.0/s1.size());\n\n}//end normalizedED\n\nvoid decompose2GramsHashSet(const string &s, set<unsigned> &result, \n                            unsigned gramLength)\n{\n  vector<string> words;\n\n  str2words(s, words, \" \");\n\n\n  for(unsigned i=0;i<words.size();i++) {\n    vector<unsigned> res;\n    str2grams(words.at(i),res,gramLength);\n    \n    for(unsigned i=0;i<res.size();i++)\n      result.insert(res.at(i));\n    \n  }//end for\n}//end decompose2GramsHashSet\n\nfloat cosine(const string &s1, const string &s2, unsigned gramLength)\n{\n  set<string> gramSet1;\n  str2grams(s1, gramSet1,gramLength);\n \n  set<string> gramSet2;\n  str2grams(s2, gramSet2,gramLength);\n \n  unsigned news1Size = gramSet1.size();\n  unsigned news2Size = gramSet2.size();\n  gramSet1.insert(gramSet2.begin(),gramSet2.end());\n  unsigned unionSize = gramSet1.size();\n  unsigned intersectionSize \n\t= news1Size+news2Size-unionSize;\n \n  double d =\n\tintersectionSize*1.0/sqrt(news1Size*news2Size);\n\n  return d;\n}//end cosine\n\n//return the jaccard similarity coefficient\n\nfloat jaccard(const string &s1, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<string> s1Gram, s2Gram, sUni;\n  str2grams(s1, s1Gram, q);\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n\nfloat jaccard(const set<string> &s1Gram, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1Gram.size(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<string> s2Gram, sUni;\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d; \n}\n\nfloat jaccardBag(const string &s1, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<string> s1Gram, s2Gram, sUni;\n  str2grams(s1, s1Gram, q);\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n\nfloat jaccardBag(const multiset<string> &s1Gram, const string &s2, \n                            unsigned q)\n{\n  unsigned\n    n = s1Gram.size(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<string> s2Gram, sUni;\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d; \n}\n\nfloat jaccardNoPrePost(const string &s1, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<string> s1Gram, s2Gram, sUni;\n  str2gramsNoPrePost(s1, s1Gram, q);\n  str2gramsNoPrePost(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n\nfloat jaccardNoPrePost(const set<string> &s1Gram, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1Gram.size(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<string> s2Gram, sUni;\n  str2gramsNoPrePost(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d; \n}\n\nfloat jaccardHash(const string &s1, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<unsigned> s1Gram, s2Gram, sUni;\n  str2grams(s1, s1Gram, q);\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n\nfloat jaccardHashBag(const string &s1, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<uint> s1Gram, s2Gram, sUni;\n  str2grams(s1, s1Gram, q);\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));  \n\n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n\n  /*\n  cout << s1Gram.size() << \" \" << s1Gram << endl;\n  cout << s2Gram.size() << \" \" << s2Gram << endl;\n  cout << sUni.size() << \" \" << sUni << endl;\n  cout << interSize << endl;\n  cout << d << endl;\n  */\n\n  return d; \n}\n\nfloat jaccardHashBag(const multiset<uint> &s1Gram, const string &s2, \n                     unsigned q)\n{\n  unsigned\n    n = s1Gram.size(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  multiset<uint> s2Gram, sUni;\n  str2grams(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d; \n}\n\nfloat jaccardHashNoPrePost(const string &s1, const string &s2, unsigned q)\n{\n  unsigned\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<unsigned> s1Gram, s2Gram, sUni;\n  str2gramsNoPrePost(s1, s1Gram, q);\n  str2gramsNoPrePost(s2, s2Gram, q);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  unsigned interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d =  static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n\nfloat dice(const string &s1, const string &s2, unsigned gramLength  )\n{\n  set<string> gramSet1;\n  str2grams(s1, gramSet1,gramLength);\n \n  set<string> gramSet2;\n  str2grams(s2, gramSet2,gramLength);\n \n  unsigned news1Size = gramSet1.size();\n  unsigned news2Size = gramSet2.size();\n  gramSet1.insert(gramSet2.begin(),gramSet2.end());\n  unsigned unionSize = gramSet1.size();\n  unsigned intersectionSize \n\t= news1Size+news2Size-unionSize;\n \n  float d =\n      (2.0*intersectionSize)/(news1Size+news2Size);\n\n  return d;\n}//end dice\n", "encoding": "ascii"}