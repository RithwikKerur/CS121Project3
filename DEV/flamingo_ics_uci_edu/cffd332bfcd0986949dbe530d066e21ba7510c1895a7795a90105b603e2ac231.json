{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/sepia/src/cluster/clusters.cc", "content": "/*\n  $Id: clusters.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/14/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"clusters.h\"\n#include \"ppdtable/allrand.h\"\n#include \"ppdtable/closelex.h\"\n#include \"ppdtable/closerand.h\"\n#include \"ppdtable/closeunique.h\"\n\n#include <algorithm>\n\nostream& operator<<(ostream &out, const QueryVect &qv) \n{\n  return out << qv.query << \"\\t\" << qv.vect;\n}\n\nistream& operator>>(istream &in, QueryVect &qv)\n{\n  return in >> qv.query >> qv.vect;\n}  \n\nClusters::Clusters(const vector<string> *d, unsigned clusterNo, \n                   SampleType sampleType, unsigned samplePer,\n                   unsigned queueSize, unsigned uniqueNo): \n  data(d), clusterNo(clusterNo), sampleType(sampleType), \n  samplePer(samplePer), queueSize(queueSize), uniqueNo(uniqueNo), \n  clusters(new VectCluster), ppdtable(new PPDTable()),\n  queryPivot(new ContQueryPivot())\n{\n}\n\nClusters::Clusters(const Clusters &cs): \n  data(cs.data), clusterNo(cs.clusterNo), sampleType(sampleType), \n  samplePer(samplePer), queueSize(queueSize), uniqueNo(uniqueNo)\n{\n  clusters = new VectCluster;\n  *clusters = *cs.clusters;\n  ppdtable = new PPDTable();\n  *ppdtable = *cs.ppdtable;\n  queryPivot = new ContQueryPivot();\n  *queryPivot = *cs.queryPivot;\n}\n\nClusters::~Clusters() \n{\n  delete clusters;\n  delete ppdtable;\n  delete queryPivot;\n}\n\nClusters& Clusters::operator=(const Clusters &cs) \n{\n  if (this == &cs)\n    return *this;\n  *clusters=*cs.clusters;\n  *ppdtable=*cs.ppdtable;\n  *queryPivot = *cs.queryPivot;\n  data=cs.data;\n  return *this;\n}\n\nbool Clusters::operator==(const Clusters &c) const \n{\n  if (this == &c)\n    return true;\n  if (data == c.data && \n      clusterNo == c.clusterNo && \n      sampleType == c.sampleType && \n      samplePer == c.samplePer && \n      queueSize == c.queueSize && \n      uniqueNo == c.uniqueNo && \n      *clusters == *c.clusters && \n      *ppdtable == *c.ppdtable // &&\n//    *queryPivot == *c.queryPivot\n    )\n    return true;\n  \n  return false;\n}\n\nconst size_t Clusters::sizeEntries() const\n{\n  size_t cntEntries = 0;\n  for (VectCluster::const_iterator it = clusters->begin();\n       it != clusters->end(); ++it)\n    cntEntries += it->getFTable().size();\n  return cntEntries;\n}\n\nvoid Clusters::buildFTables() \n{\n  for (VectClusterIt i=clusters->begin(); i!=clusters->end(); i++)\n    i->buildFTable(data);\n}\n\nvoid Clusters::buildPPDtable() \n{\n  PPDSample *sampleEngine;\n  switch (sampleType) {\n  case ALL_RAND:\n    sampleEngine = new AllRand(data, this, queryPivot, samplePer);\n    break;\n  case CLOSE_LEX:\n    sampleEngine = new CloseLex(data, this, queryPivot, samplePer, queueSize);\n    break;\n  case CLOSE_UNIQUE:\n    sampleEngine = new CloseUnique(data, this, queryPivot, samplePer, queueSize,\n                                   uniqueNo);\n    break;\n  default: // CLOSE_RAND:\n    sampleEngine = new CloseRand(data, this, queryPivot, samplePer, queueSize);\n    break;\n  }\n\n  unsigned i = 0;\n\n  cerr << \"ppdtable\"; cerr.flush();\n\n  while (sampleEngine->hasNext()) {\n\n    if (i++ % 1000000 == 0) {\n      cerr << '.'; cerr.flush();\n    }\n\n    PPDTriple triple = sampleEngine->next();\n    PPDEntry entry = PPDEntry(triple.vect1, triple.vect2,\n                              SimUpperOrEqual(triple.dist));\n    ppdtable->insert(entry);   \n  }\n\n  cerr << \"OK\" << endl;\n\n  delete sampleEngine;\n}\n\nostream& operator<<(ostream &out, const Clusters &cs) \n{\n  out << static_cast<unsigned>(cs.clusters->size()) << endl << endl;\n  copy(cs.clusters->begin(), cs.clusters->end(), \n       ostream_iterator<Cluster>(out, \"\\n\"));\n  return out;\n}\n\nistream& operator>>(istream &in, Clusters &cs) \n{\n  unsigned n;\n  in>>n;\n  for (unsigned i=0; i<n; i++) {\n    Cluster cluster;\t\t\t\n    in>>cluster;\n    cs.clusters->push_back(cluster);\n  }\n  return in;\n}\n\ntypedef map<SimType, unsigned> MapSimDist;\n\nostream& operator<<(ostream &out, const MapSimDist &map) \n{\n  for (MapSimDist::const_iterator it = map.begin(); it != map.end(); ++it) \n    {\n      out << it->first << \" \" << it->second << endl;\n    }\n  return out;\n}\n\nvoid Clusters::hist(ostream &out, const vector<string> &d) const \n{\n  MapSimDist globalHist, localHist;\n  for (VectClusterIt cluster = clusters->begin();\n       cluster!= clusters->end(); ++cluster) {\n    localHist.clear();\n    unsigned pivot = cluster->getPivot();\n    for (ContCluster::const_iterator index = cluster->begin();\n         index != cluster->end(); ++index) {\n      SimType dist = SimDist(d[pivot], d[*index]);\t  \n      ++localHist[SimUpperOrEqual(dist)];\n    }\n\n    for (MapSimDist::const_iterator it = localHist.begin();\n         it != localHist.end(); ++it) \n      globalHist[it->first] += it->second; // / cluster->size();\n  }\n\n  out << globalHist;\n}\n\nvoid Clusters::stat(ostream &out, const vector<string> &d) const \n{\n  float \n    sumAvg = 0, \n    sumRad = 0;\n  for (VectClusterIt cluster = clusters->begin();\n       cluster!= clusters->end(); ++cluster) {\n    unsigned pivot = cluster->getPivot();\n    SimType\n      sumDist = 0;\n    for (ContCluster::const_iterator index = cluster->begin();\n         index != cluster->end(); ++index) {\n      SimType dist = SimDist(d[pivot], d[*index]);\t  \n      sumDist += dist;\n    }\n    SimType\n      avgDist = sumDist / cluster->size();\n    sumAvg += avgDist;\n    sumRad += cluster->getRadius();\n  }\n\n  out << sumAvg / sizeCluster() << \"\\t\" << sumRad / sizeCluster() << \"\\t\";\n}\n\nostream& Clusters::info(ostream &out) \n{\n  out << \"Clusters\" << endl << \"---\" << endl;\n  out << \"Clusters no\\t\" << clusterNo << endl;\n  return out << endl;\n}\n\nbool Clusters::isPivot(unsigned idx) const\n{\n  for (vector<Cluster>::const_iterator it = clusters->begin(); \n       it != clusters->end(); ++it) \n    if (it->getPivot() == idx) \n      return true;\n  return false;\n}\n\nvoid Clusters::insert(unsigned idx)\n{\n  SimType min = SimDist((*data)[clusters->begin()->getPivot()], (*data)[idx]);\n  vector<Cluster>::iterator closest = clusters->begin();\n  for (vector<Cluster>::iterator it = clusters->begin() + 1; \n       it != clusters->end(); ++it) {\n    SimType crt = SimDist((*data)[it->getPivot()], (*data)[idx]);\n    if (crt < min) {\n      min = crt;\n      closest = it;\n    }\n  }\n\n  // \"closest\" is the closest cluster\n  unsigned pivot = closest->getPivot();\n  SimVect vect2 = SimVect( (*data)[pivot], (*data)[idx]);\n  closest->insert(idx, vect2);\n\n  SimType dist = vect2.getDist();\n  if (dist > closest->getRadius()) \n    closest->setRadius(dist);\n\n  for (ContQueryPivot::const_iterator it = queryPivot->find(pivot);\n       it != queryPivot->end() && it->first == pivot; ++it) {\n    SimVect vect1 = it->second.vect;\n    SimType dist = SimDist((*data)[it->second.query], (*data)[idx]);\n    PPDEntry entry = PPDEntry(vect1, vect2, SimUpperOrEqual(dist));\n    ppdtable->insert(entry);\n  }\n}\n\nclass CmpDist\n{\nprivate:\n  const vector<string> *data;\n  string pivotStr;\npublic:\n  CmpDist(const vector<string> *data, unsigned pivot): \n    data(data), pivotStr((*data)[pivot]) {}\n  bool operator()(unsigned i, unsigned j) {\n    return SimDist((*data)[i], pivotStr) < SimDist((*data)[j], pivotStr); }\n};\n\nvoid Clusters::erase(unsigned idx) \n{\n  vector<Cluster>::iterator contain;\n  for (contain = clusters->begin(); contain != clusters->end(); ++contain) \n    if (contain->find(idx) != contain->end()) \n      break;\n  if (contain == clusters->end()) {\n    cerr << \"Clusters::erase index not found\\t\" << idx << endl;\n    return;\n  }  \n  unsigned pivot = contain->getPivot();\n  SimVect vect2 = SimVect((*data)[pivot], (*data)[idx]);\n  contain->erase(idx, vect2);\n\n  if (contain->getRadius() == vect2.getDist())\n    // update radius\n    contain->setRadius(SimDist((*data)[pivot], \n                               (*data)[*max_element(contain->begin(), \n                                                    contain->end(),\n                                                    CmpDist(data, pivot))]));\n\n  for (ContQueryPivot::const_iterator it = queryPivot->find(pivot);\n       it != queryPivot->end() && it->first == pivot; ++it) {\n    SimVect vect1 = it->second.vect;\n    SimType dist = SimDist((*data)[it->second.query], (*data)[idx]);\n    PPDEntry entry = PPDEntry(vect1, vect2, SimUpperOrEqual(dist));\n    ppdtable->erase(entry);\n  }\n}\n\nvoid Clusters::readClusters(const string &filename)\n{\n  ifstream file(filename.c_str(), ios::in);\n  if (!file) {\n    cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file >> *this;\n  file.close();\n}\n\nvoid Clusters::writeClusters(const string &filename) const\n{\n  ofstream file(filename.c_str(), ios::out);\n  if (!file) {\n    cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file << *this;\n  file.close();\n}\n\nvoid Clusters::readPPDtable(const string &filename)\n{\n  ifstream file(filename.c_str(), ios::in);\n  if (!file) {\n    cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file >> *ppdtable;\n  file.close();\n}\n\nvoid Clusters::writePPDtable(const string &filename) const\n{\n  ofstream file(filename.c_str(), ios::out);\n  if (!file) {\n    cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file << *ppdtable;\n  file.close();\n}\n\n\nostream& operator<<(ostream &out, const ContQueryPivot &cont) \n{\n  out << cont.size() << endl << endl;\n  for(ContQueryPivot::const_iterator it = cont.begin(); it != cont.end(); ++it) \n    out << it->first << \"\\t\" << it->second << endl;\n  return out;\n}\n\nistream& operator>>(istream &in, ContQueryPivot &cont) \n{\n  unsigned sz;\n  in >> sz;\n  for (unsigned i = 0; i < sz; i++) {\n    unsigned pivot;\n    QueryVect qv;\n    in >> pivot >> qv;\n    cont.insert(std::make_pair(pivot, qv));\n  }\n  return in;\n}\n", "encoding": "ascii"}