{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/topk/perftest.cc", "content": "/*\n  $Id: perftest.cc 5026 2010-02-17 20:25:03Z rares $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the BSD\n  license\n\n  Date: 05/31/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n\n#include \"topk.h\"\n#include \"perftest_exps.h\"\n#include \"perftest_util.h\"\n#include \"util/io.h\"\n#include \"util/output.h\"\n#include \"util/misc.h\"\n#include \"util/time.h\"\n\nusing namespace std;\nusing namespace Topk;\n\nuint thresholdInit = 0;             // threshold for Iterative and TwoPhase\nbool thresholdPerf = false;\nuint factorK = 1;                   // for Iterative\nfloat time1 = 0;\n\nvoid smoke(Alg alg)\n{\n  cerr << \"smoke \" << getAlgName(alg) << endl;\n\n  const uint noData = 1500000;\n  const uint noQue  =    1000;\n  const uint noAns  =    1000;\n  const bool isWeight = true;\n\n  GramGenFixedLen gramGen(3);\n  SimMetricEdNorm simMetric(gramGen);\n\n  PerfData data(gramGen, PerfDataIMDB, noData);\n  PerfQue que(data, noQue);\n  PerfAns ans(data, que, simMetric, noAns, isWeight);\n  PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n  TIMER_START(\"smoke\", noQue);\n  vector<uint> topk;\n  for (uint i = 0; i < que.no; i++) \n    // uint i = 5;\n    { \n      OUTPUT(\"i\", i);\n        \n      Query query(que.que[i], simMetric, noAns);\n\n      if (alg == AlgRoundRobin || alg == AlgHeap) {\n        IndexQuery indexQuery(index.index, query);\n        runAlg(\n          alg, \n          data.data, \n          data.weights, \n          data.nograms, \n          index.index, \n          query, \n          indexQuery, \n          back_inserter(topk));\n      }\n      else {\n        set<uint> gramsQue;\n        query.sim.gramGen.decompose(query.str, gramsQue);\n        IndexQuery_v1 idxQue_v1;\n        for (set<uint>::const_iterator gram = gramsQue.begin();\n             gram != gramsQue.end(); ++gram) {\n          Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n          idxQue_v1.push_back(ptr);\n        }\n        gramsQue.clear();\n\n        thresholdInit = query.noGrams;\n\n        runAlg_v1(\n          alg, \n          data.data, \n          data.weights, \n          data.nograms, \n          index.index_v1, \n          query, \n          idxQue_v1, \n          back_inserter(topk));\n      }\n\n      OUTPUT_L2(\"top\", topk);\n      OUTPUT_L2(\"ans\", ans.ans[i]);\n\n      assert(PerfAns::isEqual(data, simMetric, topk, ans.ans[i], query));\n      topk.clear();\n      \n      TIMER_STEP();\n    }\n  TIMER_STOP();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid smokeMulti()\n{\n  cerr << \"smokeMulti\" << endl;\n\n  const uint noData = 1500000;\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n  const bool isWeight = true;\n\n  GramGenFixedLen gramGen(3);\n  SimMetricEdNorm simMetric(gramGen);\n\n  PerfData data(gramGen, PerfDataIMDB, noData);\n  PerfQue que(data, noQue);\n  PerfAns ans(data, que, simMetric, noAns, isWeight);\n  PerfIndex index(data, simMetric.gramGen, 0);\n\n  uint noKwd = 2;\n\n  range<Query**> ques;\n  ques._begin = new Query*[noKwd];\n  ques._end = ques._begin + noKwd;\n\n  vector<vector<uint> > topks;\n  for (uint i = 0; i < noKwd; ++i)\n    topks.push_back(vector<uint>(noAns));\n\n  TIMER_START(\"smoke\", noQue);\n  vector<uint> topk;\n  for (uint i = 0; i < que.no - noKwd + 1; i++) \n    // uint i = 5;\n    {\n      QueryGroup queGrp(que.que.begin() + i, noKwd, simMetric, noAns);\n\n      OUTPUT(\"i\", i);\n\n      IndexQuery indexQuery(index.index, queGrp);\n      Topk::Heap::getTopks(\n        data.data, \n        data.weights, \n        index.index, \n        queGrp, \n        indexQuery, \n        topks);\n\n      for (uint j = 0; j < noKwd; ++j) {\n        OUTPUT_L2(\"que\", queGrp.strs[j]);\n        OUTPUT_L2(\"top\", topks[j]);\n        OUTPUT_L2(\"ans\", ans.ans[i + j]);\n      }\n      \n      for (uint j = 0; j < noKwd; ++j)\n        assert(\n          PerfAns::isEqual(\n            data,\n            simMetric,\n            topks[j],\n            ans.ans[i + j], \n            Query(queGrp.strs[j], queGrp.sim, queGrp.k)));\n      \n      TIMER_STEP();\n    }\n  TIMER_STOP();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid perf(\n  const SimMetric &simMetric, Alg alg, PerfDataName perfDataName, uint noData)\n{\n  cerr << \"perf \" << getAlgName(alg) << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n\n  PerfData data(simMetric.gramGen, perfDataName, noData);\n  PerfQue que(data, noQue);\n  PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n  uint jMax = 5;               // 5\n  float t = 0;\n  uint topk[noAns];\n\n  TIMER_START(\"exps\", jMax);\n  for (uint j = 0; j < jMax; j++) {\n\n    TIME_START;\n    if (alg == AlgRoundRobin || alg == AlgHeap)\n      for (uint i = 0; i < que.no; i++) {\n        Query query(que.que[i], simMetric, noAns);\n        thresholdInit = query.noGrams;\n        \n        IndexQuery indexQuery(index.index, query);\n        runAlg(\n          alg, \n          data.data, \n          data.weights, \n          data.nograms, \n          index.index, \n          query, \n          indexQuery, \n          topk);\n      }\n    else\n      for (uint i = 0; i < que.no; i++) {\n        Query query(que.que[i], simMetric, noAns);\n        thresholdInit = query.noGrams;\n        \n        set<uint> gramsQue;\n        query.sim.gramGen.decompose(query.str, gramsQue);\n        IndexQuery_v1 idxQue_v1;\n        for (set<uint>::const_iterator gram = gramsQue.begin();\n             gram != gramsQue.end(); ++gram) {\n          Array<uint> *ptr = index.index_v1.lists.find(*gram)->second;\n          idxQue_v1.push_back(ptr);\n        }\n        gramsQue.clear();\n        runAlg_v1(\n          alg, \n          data.data, \n          data.weights, \n          data.nograms, \n          index.index_v1, \n          query, \n          idxQue_v1, \n          topk);\n      }\n    TIME_END;\n    t += _tms / que.no;\n\n    TIMER_STEP();\n  }\n  TIMER_STOP();\n\n  float s = t / jMax;\n  cout << setw(8) << s << \" ms/que\" << endl;\n  cerr << \"OK\" << endl;\n}\n\nvoid perfMulti(\n  const SimMetric &simMetric, PerfDataName perfDataName, uint noData)\n{\n  cerr << \"perfMulti\" << endl;\n\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n  const uint noKwd  =       2;\n\n  PerfData data(simMetric.gramGen, perfDataName, noData);\n  PerfQue que(data, noQue, noData, noKwd, 2);\n  PerfIndex index(data, simMetric.gramGen, 0);\n\n  const uint jMax = 3;               // 5\n  float t = 0;\n\n  uint topk[noAns];\n\n  for (uint j = 0; j < jMax; j++) {\n    TIME_START;\n    for (uint i = 0; i < que.no; i++) {\n      Query query(que.que[i], simMetric, noAns);\n      thresholdInit = query.noGrams;\n        \n      IndexQuery indexQuery(index.index, query);\n      Topk::Heap::getTopk(\n        data.data, \n        data.weights, \n        index.index, \n        query, \n        indexQuery, \n        topk);\n    }\n    TIME_END;\n    t += _tms / que.no;\n  }\n\n  float s = t / jMax;\n  cout << setw(8) << s << \" ms/que, total: \" \n       << (s * noKwd) <<\" ms/que \"<< endl;\n\n\n  uint topks[noKwd][noAns];\n  t = 0;\n\n  TIMER_START(\"exps\", jMax);\n  for (uint j = 0; j < jMax; j++) {\n\n    TIME_START;\n    for (uint i = 0; i < que.no - que.no % noKwd; i += noKwd) {\n      QueryGroup queGrp(que.que.begin() + i, noKwd, simMetric, noAns);\n      IndexQuery indexQuery(index.index, queGrp);\n      Topk::Heap::getTopks(\n        data.data, \n        data.weights, \n        index.index, \n        queGrp, \n        indexQuery, \n        topks);\n    }\n    TIME_END;\n    t += _tms / ((que.no - que.no % noKwd) / noKwd);\n\n    TIMER_STEP();\n  }\n  TIMER_STOP();\n\n  s = t / jMax;\n  cout << setw(8) << s << \" ms/que\" << endl;\n  cerr << \"OK\" << endl;\n}\n\n#ifdef DEBUG\nvoid debug()\n{\n  cerr << \"debug \" << endl;\n\n  const uint noData =  400000;\n  const uint noQue  =     100;\n  const uint noAns  =      10;\n  const uint noKwd   =      2;\n\n  uint iBeg = 0;\n\n  GramGenFixedLen gramGen(2);\n  SimMetricEdNorm simMetric(gramGen);\n\n  PerfData data(gramGen, PerfDataENRON, noData);\n  PerfQue que(data, noQue, noData / 1000);\n\n  Query q(que.que[iBeg], simMetric, noAns);\n  TIME_START;\n  // for (uint i = 0; i < data.no; i++)\n  //   q.sim(q.str, data.data[i]);\n  TIME_END;\n  float simSpeed = _tms / data.no;\n  cerr << \"sim speed \" << simSpeed << \"ms/sim\" << endl;\n\n  uint topk[noAns];\n\n  PerfIndex index(data, simMetric.gramGen, 0);\n\n  fill(topk, topk + noAns, 0);\n\n  simComp = simTime = 0;\n  thrFreq.clear();\n\n  cout << \"--------------------------------------\" << endl;\n\n  TIME_RESET;\n  for (uint i = iBeg; i < noKwd + iBeg; i++) {\n    Query query(que.que[i], simMetric, noAns);\n    thresholdInit = query.noGrams;\n      \n    IndexQuery indexQuery(index.index, query);\n    Topk::Heap::getTopk(\n      data.data, \n      data.weights, \n      index.index, \n      query, \n      indexQuery, \n      topk);\n\n    cout << \"que \" << que.que[i] << endl;\n    // cout << \"thr freq\" << endl;\n    // for (map<uint, uint>::const_iterator t = thrFreq.begin();\n    //      t != thrFreq.end(); ++t)\n    //   cout << t->first << '\\t' << t->second << endl;\n    // cout << endl;\n    // thrFreq.clear();\n    cout << \"thr freq sim\" << endl;\n    for (map<uint, uint>::const_iterator t = thrFreqSim.begin();\n         t != thrFreqSim.end(); ++t)\n      cout << t->first << '\\t' << t->second << endl;\n    cout << endl;\n    thrFreqSim.clear();\n\n    for (uint j = 0; j < noAns; ++j)\n      cout << topk[j] << \":\" << data.data[topk[j]] << \"; \";\n    cout << endl;\n  }\n  TIME_END;\n  cerr << \"topk      \" << setw(20) << right << _tms << \"ms\" << endl;\n  cout << \"sim comp \" << simComp << endl;\n  cout << \"sim time comp \" << simComp * simSpeed << endl;\n  cout << \"sim time \" << simTime << endl;\n  cout << \"--------------------------------------\" << endl;\n\n  uint topks[noKwd][noAns];\n\n  simComp = simTime = 0;\n  thrFreq.clear();\n  \n  QueryGroup queGrp(que.que.begin() + iBeg, noKwd, simMetric, noAns);\n  \n  TIME_RESET;\n  IndexQuery indexQuery(index.index, queGrp);\n  Topk::Heap::getTopks(\n    data.data, \n    data.weights, \n    index.index, \n    queGrp, \n    indexQuery, \n    topks);\n  TIME_END;\n\n  cerr << \"topk-multi\" << setw(20) << right << _tms << \"ms\" << endl;\n  cout << \"sim comp \" << simComp << endl;\n  cout << \"sim time comp \" << simComp * simSpeed << endl;\n  cout << \"sim time \" << simTime << endl;\n  cout << \"thr freq\" << endl;\n  for (map<uint, uint>::const_iterator t = thrFreq.begin();\n       t != thrFreq.end(); ++t)\n    cout << t->first << '\\t' << t->second << endl;\n  cout << endl;\n  // cout << \"thrs freq\" << endl;\n  // for (map<uint, map<uint, uint> >::const_iterator ts = thrsFreq.begin();\n  //      ts != thrsFreq.end(); ++ts) {\n  //   cout << ts->first;\n  //   for (map<uint, uint>::const_iterator t = ts->second.begin();\n  //        t != ts->second.end(); ++t)\n  //     cout << '\\t' << t->first << '\\t' << t->second << endl;\n  //   cout << endl;\n  // }\n  // cout << endl;\n  cout << \"thrs freq sim\" << endl;\n  for (map<uint, map<uint, uint> >::const_iterator ts = thrsFreqSim.begin();\n       ts != thrsFreqSim.end(); ++ts) {\n    cout << ts->first;\n    for (map<uint, uint>::const_iterator t = ts->second.begin();\n         t != ts->second.end(); ++t)\n      cout << '\\t' << t->first << '\\t' << t->second << endl;\n    cout << endl;\n  }\n  cout << endl;\n\n  for (uint i = 0; i < noKwd; ++i) {\n    for (uint j = 0; j < noAns; ++j)\n      cout << topks[i][j] << \":\" << data.data[topks[i][j]] << \"; \";\n    cout << endl;\n  }\n\n  cerr << \"OK\" << endl;\n}\n\nvoid exp(\n  const SimMetric &simMetric, \n  Alg alg,\n  PerfDataName dataName, \n  uint noDataStart, \n  uint noDataStop, \n  uint noDataStep)\n{\n  cerr << \"export \" \n       << getDataName(dataName)\n       << '(' \n       << utosh(noDataStart) << \", \"\n       << utosh(noDataStop) << \", \"\n       << utosh(noDataStep) << \")\"\n       << endl;\n\n  const uint noQue  =     100;\n\n  for (uint noData = noDataStart; noData <= noDataStop; noData += noDataStep) {\n    cerr << \"noData \" << utosh(noData) << endl;\n\n    PerfData data(simMetric.gramGen, dataName, noData);\n    PerfQue que(data, noQue);\n    PerfIndex index(data, simMetric.gramGen, getAlgVer(alg));\n\n    string path(\"/data/search_dbms/imdb/\");\n    string filename(path + \"que.\" + utosh(noData) + \".txt\");\n    \n    ofstream file(filename.c_str(), ios::out);\n\n    if (!file) {\n      cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    cerr << \"writing \\\"\" << filename << \"\\\"...\";\n    cerr.flush();\n\n    // for (uint i = 0; i < data.no; ++i)\n    //   file << i << '\\t' << data.data[i] << '\\t' << data.weights[i] << endl;\n\n    // for (unordered_map<uint, range<uint*> >::const_iterator \n    //        i = index.index.lists.begin();\n    //      i != index.index.lists.end(); ++i)\n    //   for (uint* j = i->second._begin; j != i->second._end; ++j)\n    //     file << i->first<< '\\t' << *j << endl;\n \n    for (vector<string>::const_iterator q = que.que.begin(); \n         q != que.que.end(); ++q)\n      file << *q << endl;\n   \n    cerr << \"OK\" << endl;\n\n    break;\n  }\n  cerr << \"OK\" << endl;  \n}\n#endif\n\nint main(int argc, char* argv[])\n{\n  cout << fixed << setprecision(2);\n  cerr << fixed << setprecision(8);\n\n  GramGenFixedLen gramGen(3);   // 3\n  SimMetricJacc simMetric(gramGen);\n  string scoreName = \"sum\";\n\n  cerr << scoreName << \", \" << simMetric.name << endl;\n\n  Topk::Heap::nLongParam = .01;               // IMDB .01; WebCoprus .017\n  \n  smoke(AlgHeap);\n  // smokeMulti();\n  // perf(simMetric, AlgHeap, PerfDataIMDB, 1500000);\n  // perf(simMetric, AlgHeap, PerfDataENRON, 400000);\n  // perfMulti(simMetric, PerfDataIMDB, 1500000);\n  // perfMulti(simMetric, PerfDataENRON, 400000);\n  // debug();\n\n  // exp_xDataSize_yTime_zAlg(\n  //   simMetric, AlgHeap, PerfDataIMDB, 200000, 200000, 200000);\n  // exp_xDataSize_yTime_Group(\n  //   simMetric, PerfDataIMDB, 200000, 200000, 200000, 2, 2);\n\n  // exp_xDataSize_yTime_zAlg(\n  //   simMetric, (Alg)atoi(argv[1]), PerfDataIMDB, 200000, 1200000, 200000);\n  // exp_xDataSize_yTime_zAlg(\n  //   simMetric, (Alg)atoi(argv[1]), PerfDataWebCorpus, 400000, 2400000, 400000);\n\n  // exp_PerfThr_Iter(\n  //   simMetric, PerfDataIMDB, 200000, 1200000, 200000, scoreName);\n  // exp_PerfThr_Iter(\n  //   simMetric, PerfDataWebCorpus, 400000, 2400000, 400000, scoreName);\n\n  // exp_PerfThr_Time(\n  //   simMetric, \n  //   (Alg)atoi(argv[1]), \n  //   PerfDataIMDB, \n  //   200000, \n  //   1200000, \n  //   200000, \n  //   scoreName);\n  // exp_PerfThr_Time(\n  //   simMetric, \n  //   (Alg)atoi(argv[1]), \n  //   PerfDataWebCorpus, \n  //   400000, \n  //   2400000, \n  //   400000, \n  //   scoreName);\n\n  // exp_xDataSize_yTime_zAlg_Perf(\n  //   simMetric,\n  //   (Alg)atoi(argv[1]),\n  //   PerfDataIMDB,\n  //   200000,\n  //   1200000,\n  //   200000,\n  //   scoreName);\n  // exp_xDataSize_yTime_zAlg_Perf(\n  //   simMetric, \n  //   (Alg)atoi(argv[1]),\n  //   PerfDataWebCorpus,\n  //   400000,\n  //   2400000,\n  //   400000,\n  //   scoreName);\n\n  // exp_xQue_yTime_zThr(\n  //   simMetric, (Alg)atoi(argv[1]), PerfDataIMDB, 1200000);\n  // exp_xQue_yTime_zThr(\n  //   simMetric, (Alg)atoi(argv[1]), PerfDataWebCorpus, 2400000);\n\n  // exp_xQue_yThr(simMetric, AlgTwoPhase, PerfDataIMDB, atoi(argv[1]));\n  // exp_xQue_yThr(simMetric, AlgTwoPhase, PerfDataWebCorpus, atoi(argv[1]));\n\n  // exp(simMetric, AlgHeap, PerfDataIMDB, 200000, 1200000, 200000);\n\n  return 0;\n}\n", "encoding": "ascii"}