{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/topk/src/oldlistmerger/ondiskmergeradapt.cc", "content": "/*\n  $Id: ondiskmergeradapt.cc 5716 2010-09-09 04:27:56Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 09/06/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"ondiskmergeradapt.h\"\n\nfloat \nCandidate<Array<PosID> >::\nwildcardEd(const string &s1, const string& s2, const char wildchar) {\n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n  \n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n  \n  uint d[2][m + 1];\n  \n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n  \n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1, \n                           d[iCrt][j - 1] + 1), \n                       d[iPre][j - 1] + ( (s1[i - 1] == s2[j - 1] || s2[j - 1] == wildchar) ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  return d[iPre][m];\n}\n\nfloat \nCandidate<Array<PosID> >::\nwildcardEd(const char* s1, const char* s2, unsigned n, unsigned m, const char wildchar) {\n  uint i, iCrt, iPre, j;\n  \n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n  \n  uint d[2][m + 1];\n  \n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n  \n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1, \n                           d[iCrt][j - 1] + 1), \n                       d[iPre][j - 1] + ( (s1[i - 1] == s2[j - 1] || s2[j - 1] == wildchar) ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  return d[iPre][m];\n}\n\nvoid\nCandidate<Array<PosID> >::\ncheckMismatches(const Query& query, unsigned gramLength) {\n  unsigned count = 0;\n  unsigned location = 0;\n  for(set<unsigned char>::iterator iter = mismatchPositions.begin();\n      iter != mismatchPositions.end();\n      iter++) {\n    if(*iter > location) {\n      count++;\n      location = *iter + gramLength - 1;\n    }\n  }  \n  if(count > query.threshold) isPruned |= POSFILTER_MISMATCH;\n}\n\nvoid\nCandidate<Array<PosID> >::\ncheckPartialString(const Query& query, const string& prePostQueryStr) {\n  float ed = wildcardEd(prePostQueryStr, partialStr);\n  if(ed > query.threshold) isPruned |= POSFILTER_DP;\n}\n\nvoid\nCandidate<Array<PosID> >::\ncheckSubstrFilter(const Query& query, \n\t\t  const string& prePostQueryStr,\n\t\t  const string& gram,\n\t\t  unsigned gramLength,\n\t\t  unsigned stringLength,\n\t\t  unsigned char stringPos,\n\t\t  unsigned char queryPos,\n\t\t  unsigned substrFilterCount) {\n    \n  unsigned queryLength = prePostQueryStr.size();\n\n  // sanity check\n  if(stringPos >= queryLength) return;\n\n  signed lengthDiff = abs( (signed)queryLength - (signed)stringLength );  \n\n  // we have a mismatch\n  if(substrFilterCount == 0) {    \n    if(lengthDiff + (signed)gramLength <= (signed)query.threshold) return;\n  }\n  // we have a match\n  else { \n    signed posDiff = (signed)stringPos - (signed)queryPos;\n    signed diff = abs( (signed)stringLength - (signed)queryLength - posDiff) + abs(posDiff);    \n    if(diff <= query.threshold) return; \n  }\n\n  // make sure there was no collision\n  if( gram.size() == 0 ) return;\n  \n  unsigned start_pos = 0;\n  unsigned query_end_pos = 0;\n  unsigned string_end_pos = 0;\n  \n  start_pos = stringPos;\n  query_end_pos = stringPos + query.threshold + gramLength;\n  string_end_pos = query_end_pos;\n  \n  if(queryLength > stringLength) query_end_pos += lengthDiff;\n  else string_end_pos += lengthDiff;\n  \n  if(query_end_pos >= prePostQueryStr.size()) query_end_pos = prePostQueryStr.size();  \n  if(string_end_pos >= stringLength) string_end_pos = stringLength;    \n  \n  float ed = wildcardEd(prePostQueryStr.c_str() + start_pos,\n\t\t\tpartialStr.c_str() + start_pos,\n\t\t\tquery_end_pos - start_pos,\n\t\t\tstring_end_pos - start_pos,\n\t\t\tWILDCHAR);\n  \n  if(ed > query.threshold) isPruned |= POSFILTER_SUBSTR;\n}\n\ntemplate<>\nvoid \nOnDiskMergerAdapt<Array<PosID> >::\nprocessPosID(const Query& query, \n\t     const string& prePostQueryStr, \n\t     unsigned gramCode,\n\t     unsigned candiID,\n\t     vector<unsigned char>& wglPos,\n\t     unsigned char candiPos,\n\t     bool* posMatched,\n\t     Candidate<Array<PosID> >* c) const {\n  \n  string& gram = (*(this->gramcode2gram))[gramCode];\n  c->updatePartialString(gram, candiPos);\n  \n  unsigned gramLength = this->gramGen->getGramLength();\n  unsigned prePostCandiStrLen = this->gramGen->getPrePostStrLen(this->charsumStats[candiID].length);\n  \n  // apply position filter and remember matching grams from queries perspective\n  unsigned substrFilterCount = 0;\n  unsigned char substrFilterQueryPos = 0;\n  for(unsigned i = 0; i < wglPos.size(); i++) {        \n    unsigned char posDiff = (wglPos.at(i) > candiPos) ? wglPos.at(i) - candiPos : candiPos - wglPos.at(i);    \n    if(posDiff <= (unsigned char)query.threshold) {\n      substrFilterCount++;\n      substrFilterQueryPos = wglPos.at(i);\n      posMatched[i] = true;\n    }\n  }\n  \n  if( posFilters & POSFILTER_SUBSTR && substrFilterCount < 2 && !(c->isPruned & POSFILTER_SUBSTR) ) {\n    c->checkSubstrFilter(query, prePostQueryStr, gram, gramLength, prePostCandiStrLen, candiPos, substrFilterQueryPos, substrFilterCount);\n  }\n}\n\ntemplate<>\nvoid \nOnDiskMergerAdapt<Array<PosID> >::\naddRemainingCandidates(const Query& query, const string& prePostQueryStr, LeafContext<Array<PosID> >* lc, vector<unsigned>& results) const {\n  for(unsigned x = 0; x < lc->candidates.size(); x++) {\n    Candidate<Array<PosID> >* c = lc->candidates.at(x);\n    if(posFilters & POSFILTER_ENDDP) c->checkPartialString(query, prePostQueryStr);\n    if(!c->isPruned) results.push_back(c->id);\n    delete c;\n  }\n}\n\ntemplate<>\nArray<PosID>::iterator\nOnDiskMergerAdapt<Array<PosID> >::\nexpProbe(Array<PosID>::iterator start, \n\t Array<PosID>::iterator end, \n\t unsigned value) const {\n  unsigned c = 0;\n  for(;;) {      \n    Array<PosID>::iterator iter = start + (1 << c);\n    if(iter >= end) return end;\n    else if(iter->id >= value) return iter;\n    c++;\n  }\n}\n\ntemplate<>\nvoid  \nOnDiskMergerAdapt<Array<PosID> >::\ndetectDuplicateLists(vector<QueryGramList<Array<PosID> >* >& qgls, vector<WeightedGramList<Array<PosID> >* >& wgls) const {\n  \n  sort(qgls.begin(), qgls.end(), OnDiskMergerAdapt<Array<PosID> >::cmpQglByGramCode);\n  \n  unsigned i = 0;\n  while(i < qgls.size()) {    \n    QueryGramList<Array<PosID> >* currentQGL = qgls.at(i);\n    unsigned currentCount = 0;          \n\n    WeightedGramList<Array<PosID> >* wgl = new WeightedGramList<Array<PosID> >();\n    while(i < qgls.size()) {\n      if(currentQGL->gramCode == qgls.at(i)->gramCode) {\n\tcurrentQGL = qgls.at(i);\n\tcurrentCount++;\n\twgl->positions.push_back(currentQGL->pos);\n\ti++;\t\n      }\n      else break;      \n    }\n    wgl->gramCode = currentQGL->gramCode;\n    wgl->gramList = dynamic_cast<GramListOnDisk<Array<PosID> >*>(currentQGL->gl);\n    wgl->weight = currentCount;\n    wgls.push_back(wgl);\n  }  \n}\n\ntemplate<>\nvoid \nOnDiskMergerAdapt<Array<PosID> >::\nheapMerge(const Query& query, const string& prePostQueryStr, LeafContext<Array<PosID> >& lc, vector<unsigned>& results) const {\n    \n  typedef Array<PosID> InvList;\n  unsigned numberLists = lc.initialLists;\n  \n  unsigned pointersIndex[numberLists];  \n  memset(pointersIndex, 0, numberLists * sizeof(unsigned));\n  \n  Heap<HeapMergeElement<InvList> > heap(numberLists);\n  \n  // make initial heap\n  for(unsigned i = 0; i < numberLists; i++) {\n    unsigned j = 0;\n    InvList* invList = lc.wgls->at(i)->gramList->getArray();\n    unsigned currentID = invList->at(0).id;\n    while(j < invList->size()) {\n      PosID& e = invList->at(j);\n      if(currentID == e.id) {\n\theap.push(new HeapMergeElement<InvList>(&e, i));\t\n\tpointersIndex[i]++;\n      }\n      else break;\n      j++;\n    }\n  }\n  \n  HeapMergeElement<InvList>* poppedElements[numberLists];\n  while( !heap.empty() ) {                       \n\n    // Container of vector indexes which should be moved to the next position \n    unsigned poppedElementCount = 0;\n    unsigned currentID = heap.head()->element->id;\n    unsigned weight = 0;    \n    Candidate<InvList>* c = new Candidate<InvList>(this->gramGen->getPrePostStrLen(this->charsumStats[currentID].length));\n    \n    while( currentID == heap.head()->element->id && poppedElementCount < numberLists) {         \n      \n      poppedElements[poppedElementCount++] = heap.head();\n      unsigned currentListIndex = heap.head()->listIndex;\n      vector<unsigned char>& wglPos = lc.wgls->at(heap.head()->listIndex)->positions;\n      bool posMatched[wglPos.size()];\n      memset(posMatched, 0, sizeof(bool) * wglPos.size());      \n      \n      unsigned sameListCount = 0;      \n      while( currentListIndex == heap.head()->listIndex && currentID == heap.head()->element->id ) {\t\n\tsameListCount++;\n\t\n\tprocessPosID(query, prePostQueryStr, lc.wgls->at(currentListIndex)->gramCode, currentID,\n\t\t     wglPos, heap.head()->element->pos, posMatched, c);\n\t\n\theap.pop();\n\tif(heap.empty()) break; // for safety\n      }\n      \n      // count matched grams from queries perspective and set mismatched grams from queries perspective\n      unsigned matches = 0;\n      for(unsigned i = 0; i < wglPos.size(); i++) {\n\tif(posMatched[i]) matches++;\n\telse c->mismatchPositions.insert( wglPos.at(i) );\t  \n      }\n      \n      // make the weight as tight as possible\n      weight += min(sameListCount, matches);\n      \n      if(heap.empty()) break; // for safety\n    }        \n        \n    // the weight may be 0 due to the position filter, disregard candidates with zero weight\n    // also analyze mismatching positions to see if we can prune this candidate\n    if(posFilters & POSFILTER_MISMATCH)\n      c->checkMismatches(query, gramGen->getGramLength());\n    \n    if((weight > 0) && (!c->isPruned)) {\n      \n      if(posFilters & POSFILTER_LENGTH) c->isPruned |= checkLength(query, prePostQueryStr, *c);\n      \n      if( (posFilters & POSFILTER_DP) && (!c->isPruned) ) {\n\tc->checkPartialString(query, prePostQueryStr);\n\t\n\tif(!c->isPruned) {\n\t  c->id = currentID;\n\t  c->weight = weight;\n\t  lc.candidates.push_back(c);\n\t}\n\telse delete c;\t\n      }\n      else {\n\tc->id = currentID;\n\tc->weight = weight;\n\tlc.candidates.push_back(c);\n      }\n    }\n    else delete c;\n    \n    // move to next elements and insert to heap\n    for(unsigned i = 0; i < poppedElementCount; i++) {\n      unsigned index = poppedElements[i]->listIndex;\n      unsigned position = pointersIndex[index];      \n      InvList* invList = lc.wgls->at(index)->gramList->getArray();\n      if(position < invList->size()) {\n\tunsigned currentID = invList->at(position).id;\n\twhile(position < invList->size()) {\n\t  PosID& e = invList->at(position);\n\t  if(currentID == e.id) {\n\t    heap.push(new HeapMergeElement<InvList>(&e, index));\t    \n\t    pointersIndex[index]++;\n\t  }\n\t  else break;\n\t  position++;\n\t}\n      }      \n      delete poppedElements[i];\n    }                 \n  } \n}\n\ntemplate<>\nvoid \nOnDiskMergerAdapt<Array<PosID> >::\nreadNextLists(const Query& query,\n\t      const string& prePostQueryStr,\n\t      LeafContext<Array<PosID> >& lc, \n\t      unsigned listsToRead, \n\t      vector<unsigned>& results) {\n  \n  typedef Array<PosID> InvList;\n  \n  for(unsigned i = 0; i < listsToRead; i++) {          \n    WeightedGramList<InvList>* wgl = lc.wgls->at(lc.currentList+i);\n    GramListOnDisk<InvList>* gl = wgl->gramList;    \n    InvList* array = gl->getArray(lc.invListsFile);\n    lc.remainingWeight -= wgl->weight;    \n    \n    vector<unsigned char>& wglPos = wgl->positions;\n    bool posMatched[wglPos.size()]; // remember matched positions from queries perspective\n    \n    // do lookup for every candidate\n    bool cleanseNeeded = false;\n    InvList::iterator start = array->begin();\n    \n    for(unsigned j = 0; j < lc.candidates.size(); j++) {      \n      Candidate<InvList>* candidate = lc.candidates.at(j);\n      if((signed)candidate->weightNeeded <= 0) continue;      \n      \n      InvList::iterator end = expProbe(start, array->end(), candidate->id);\n      PosID toFind(candidate->id, 0);\n      start = lower_bound(start, end, toFind);\n            \n      // iterate through inverted list from start as long as the string ids match\n      unsigned listMatchCount = 0;\n      memset(posMatched, 0, sizeof(bool) * wglPos.size());\n      while(start != array->end()) {\n\tif(start->id == candidate->id) {\n\t  listMatchCount++;\n\t  processPosID(query, prePostQueryStr, wgl->gramCode, candidate->id, wglPos, start->pos, posMatched, candidate);\n\t}\n\telse break; // string ids no longer match\t\n\tstart++;\n      }\n      \n      // count matched grams from queries perspective and set mismatched grams from queries perspective\n      unsigned matches = 0;\n      for(unsigned p = 0; p < wglPos.size(); p++) {\n\tif(posMatched[p]) matches++;\n\telse candidate->mismatchPositions.insert( wglPos.at(p) );\n      }\n      \n      // keep weight as tight as possible      \n      unsigned weight = min(listMatchCount, matches);\n      if(posFilters & POSFILTER_MISMATCH)\n\tcandidate->checkMismatches(query, gramGen->getGramLength());\n      \n      if(listMatchCount > 0 && (posFilters & POSFILTER_DP) ) \n\tcandidate->checkPartialString(query, prePostQueryStr);\n      \n      if(!candidate->isPruned) {      \n\t// check if we add any weight\n\tif(weight > 0) {\n\t  candidate->weight += weight;\n\t  if(candidate->weight >= lc.threshold) {\n\t    lc.candidateCounts[candidate->weightNeeded]--;\n\t    candidate->weightNeeded = 0;\n\t    results.push_back(candidate->id);\t  \n\t    cleanseNeeded = true;\n\t  }\n\t}\n\t// we are adding no weight\n\telse {\n\t  lc.candidateCounts[candidate->weightNeeded]--;\n\t  candidate->weightNeeded = (candidate->weightNeeded > wgl->weight) ? candidate->weightNeeded - wgl->weight : 0;\n\t  if(candidate->weightNeeded > lc.remainingWeight) candidate->weightNeeded = 0;\n\t  if(candidate->weightNeeded > 0) lc.candidateCounts[candidate->weightNeeded]++;\n\t  else cleanseNeeded = true;\n\t}      \n      }\n      else { // we must remove the candidate\n\tlc.candidateCounts[candidate->weightNeeded]--;\n\tcandidate->weightNeeded = 0;\n\tcleanseNeeded = true;\n      }\n    }      \t\n    \n    // do we need to remove items from the candidate set\n    // i.e. we can guarantee that some elements are either answers or cannot be answers\n    if(cleanseNeeded) cleanseCandidates(lc.candidates);\n    \n    gl->clear();\n  }\n}\n", "encoding": "ascii"}