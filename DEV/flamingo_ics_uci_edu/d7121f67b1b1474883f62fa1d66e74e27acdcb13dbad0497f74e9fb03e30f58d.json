{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/filtertree/src/wrappers/example.cc", "content": "/*\n  $Id: example.cc 5788 2010-10-22 10:09:57Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD License.\n    \n  Date: 09/06/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"wrappers.h\"\n\n// create a dummy dictionary\nextern void readString(vector<string>& data, const string& filenameData, unsigned count, unsigned maxLineLen);\nstd::vector<string> dictionary;\nvoid initDictionary();\n\n// EXAMPLES\nvoid wrapperSimpleExampleEd();\nvoid wrapperSimpleShortExampleEd();\nvoid wrapperSimpleExampleEdNorm();\nvoid wrapperSimpleIndexMaintenance();\nvoid wrapperDiscardListsExample();\nvoid wrapperOnDiskSimpleExample();\n\nint main() {\n  \n  initDictionary();\n  \n  wrapperSimpleExampleEd();\n  wrapperSimpleShortExampleEd();\n  wrapperSimpleExampleEdNorm();\n  wrapperSimpleIndexMaintenance();\n  wrapperDiscardListsExample();\n  wrapperOnDiskSimpleExample();\n  \n  return 0;\n}\n\nvoid initDictionary() {\n  // params: target vector, filename, number strings to read, max line length\n  readString(dictionary, \"../data/female_names.txt\", 4000, 20);\n}\n\n// USAGE OF WRAPPERS FOR UNCOMPRESSED INDEXES\n// List of Wrappers:\n// WrapperSimpleEd\n// WrapperSimpleEdNorm\n// WrapperSimpleJacc\n// WrapperSimpleCos\n// WrapperSimpleDice\n// see typedefs in wrapperuncompressed.h\n// ALSO POSSIBLE TO SPECIFY SIMMETRIC AS TEMPLATE PARAMETER: WrapperSimple<SimilarityMetric>\nvoid wrapperSimpleExampleEd() {\n  cout << \"----- EXAMPLE: WrapperSimpleEd -----\" << endl;\n  \n  GramGenFixedLen gramGen(2);\n  \n  StringContainerVector strContainer(true);\n  strContainer.initStatsCollector(&gramGen);\n  strContainer.fillContainer(\"../data/female_names.txt\", 4000);\n  \n  // create wrapper and build index\n  // params: stringcontainer, gramgenerator, use partitioning filter?\n  WrapperSimpleEd wrapper(&strContainer, &gramGen, true);\n  wrapper.buildIndex();\n  \n  // perform search\n  float editDistance = 1.0f;\n  string queryString = \"kathrin\";\n  vector<unsigned> resultStringIDs;\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  // save index\n  wrapper.saveIndex(\"wrapperIndex.ix\");\n\n  // load index\n  wrapper.loadIndex(\"wrapperIndex.ix\");\n\n  // perform search on loaded index\n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  cout << \"-----------------------------------------\" << endl << endl;  \n}\n\n// USAGE OF WRAPPERS FOR UNCOMPRESSED INDEXES\n// List of Wrappers:\n// WrapperSimpleEd\n// WrapperSimpleEdNorm\n// WrapperSimpleJacc\n// WrapperSimpleCos\n// WrapperSimpleDice\n// see typedefs in wrapperuncompressed.h\n// ALSO POSSIBLE TO SPECIFY SIMMETRIC AS TEMPLATE PARAMETER: WrapperSimple<SimilarityMetric>\nvoid wrapperSimpleShortExampleEd() {\n  cout << \"----- EXAMPLE: WrapperShortSimpleEd -----\" << endl;\n  \n  GramGenFixedLen gramGen(2);\n  \n  StringContainerVector strContainer(true);\n  strContainer.initStatsCollector(&gramGen);\n  strContainer.fillContainer(\"../data/female_names.txt\", 4000);\n  \n  // create wrapper and build index\n  // params: stringcontainer, gramgenerator, use partitioning filter?\n  WrapperShortSimpleEd wrapper(&strContainer, &gramGen, true);\n  wrapper.buildIndex();\n  \n  // perform search\n  float editDistance = 1.0f;\n  string queryString = \"kathrin\";\n  vector<unsigned> resultStringIDs;\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  // save index\n  wrapper.saveIndex(\"wrapperIndex.ix\");\n\n  // load index\n  wrapper.loadIndex(\"wrapperIndex.ix\");\n\n  // perform search on loaded index\n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  cout << \"-----------------------------------------\" << endl << endl;  \n}\n\n// USAGE OF WRAPPERS FOR UNCOMPRESSED INDEXES\n// List of Wrappers:\n// WrapperSimpleEd\n// WrapperSimpleEdNorm\n// WrapperSimpleJacc\n// WrapperSimpleCos\n// WrapperSimpleDice\n// see typedefs in wrapperuncompressed.h\n// ALSO POSSIBLE TO SPECIFY SIMMETRIC AS TEMPLATE PARAMETER: WrapperSimple<SimilarityMetric>\nvoid wrapperSimpleExampleEdNorm() {\n  cout << \"----- EXAMPLE: WrapperSimpleEdNorm -----\" << endl;\n  \n  GramGenFixedLen gramGen(2);\n  \n  StringContainerVector strContainer(true);\n  strContainer.initStatsCollector(&gramGen);\n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n\n  // create wrapper and build index\n  // params: stringcontainer, gramgenerator, use partitioning filter?\n  WrapperSimpleEdNorm wrapper(&strContainer, &gramGen, true);\n  wrapper.buildIndex();\n  \n  // perform search\n  float normEditDistance = 0.9f;\n  string queryString = \"kathrin\";\n  vector<unsigned> resultStringIDs;\n  wrapper.search(queryString, normEditDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  // save index\n  wrapper.saveIndex(\"wrapperIndex.ix\");\n\n  // load index\n  wrapper.loadIndex(\"wrapperIndex.ix\");\n  \n  // perform search on loaded index\n  resultStringIDs.clear();\n  wrapper.search(queryString,  normEditDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  cout << \"-----------------------------------------\" << endl << endl;  \n}\n\n// USAGE OF WRAPPERS FOR UNCOMPRESSED INDEXES\n// List of Wrappers:\n// WrapperSimpleEd\n// WrapperSimpleEdNorm\n// WrapperSimpleJacc\n// WrapperSimpleCos\n// WrapperSimpleDice\n// see typedefs in wrapperuncompressed.h\n// ALSO POSSIBLE TO SPECIFY SIMMETRIC AS TEMPLATE PARAMETER: WrapperSimple<SimilarityMetric>\nvoid wrapperSimpleIndexMaintenance() {\n  cout << \"----- EXAMPLE: WrapperSimpleEd Index Maintenance -----\" << endl;\n  \n  GramGenFixedLen gramGen(2);\n  \n  StringContainerVector strContainer(true);\n  strContainer.initStatsCollector(&gramGen);\n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n\n  // create wrapper and build index\n  // params: stringcontainer, gramgenerator, use partitioning filter?\n  WrapperSimpleEd wrapper(&strContainer, &gramGen, true);\n  wrapper.buildIndex();\n  \n  // perform search\n  float editDistance = 2.0f;\n  string queryString = \"kathrin\";\n  vector<unsigned> resultStringIDs;\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << resultStringIDs[i] << \" \" << tmp << endl;\n  }\n  \n  // insert a couple of strings\n  wrapper.insertString(\"kathryn\");\n  wrapper.insertString(\"kathein\");\n  wrapper.insertString(\"cathrin\");\n  wrapper.insertString(\"cathryn\");\n  \n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS AFTER INSERTIONS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << resultStringIDs[i] << \" \" << tmp << endl;\n  }\n\n  // delete first 1000 strings from index and stringcontainer\n  for(unsigned i = 0; i < 1000; i++)\n    wrapper.deleteString(i);\n  \n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);  \n  cout << \"SIMILAR STRINGS AFTER DELETIONS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << resultStringIDs[i] << \" \" << tmp << endl;\n  }\n  \n  // integrate the deletions into the inverted lists\n  // WARNING: this operation takes time and should be done periodically but infrequently\n  wrapper.integrateUpdates();\n  \n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);  \n  cout << \"SIMILAR STRINGS AFTER INTEGRATION: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << resultStringIDs[i] << \" \" << tmp << endl;\n  }\n\n\n  cout << \"-----------------------------------------\" << endl << endl;  \n}\n\n// USAGE OF WRAPPERS FOR COMPRESSED INDEXES USING GLOBAL HOLES COMPRESSION\n// List of Wrappers:\n\n// Using Long-List-First hole selection (workload independent)\n// WrapperDiscardListsLLFEd;\n// WrapperDiscardListsLLFEdNorm;\n// WrapperDiscardListsLLFJacc;\n// WrapperDiscardListsLLFCos;\n// WrapperDiscardListsLLFDice;\n\n// Using Long-List-First hole selection (workload independent)\n// WrapperDiscardListsSLFEd;\n// WrapperDiscardListsSLFEdNorm;\n// WrapperDiscardListsSLFJacc;\n// WrapperDiscardListsSLFCos;\n// WrapperDiscardListsSLFDice;\n\n// Using Random-List hole selection (workload independent)\n// WrapperDiscardListsRandomEd;\n// WrapperDiscardListsRandomEdNorm;\n// WrapperDiscardListsRandomJacc;\n// WrapperDiscardListsRandomCos;\n// WrapperDiscardListsRandomDice;\n\n// Using Panic-Cost-Plus hole selection (workload dependent)\n// WrapperDiscardListsPanicCostEd;\n// WrapperDiscardListsPanicCostEdNorm;\n// WrapperDiscardListsPanicCostJacc;\n// WrapperDiscardListsPanicCostCos;\n// WrapperDiscardListsPanicCostDice;\n\n// Using Time-Cost-Plus hole selection (workload dependent)\n// WrapperDiscardListsTimeCostEd;\n// WrapperDiscardListsTimeCostEdNorm;\n// WrapperDiscardListsTimeCostJacc;\n// WrapperDiscardListsTimeCostCos;\n// WrapperDiscardListsTimeCostDice;\n\n// see typedefs in wrapperholesglobal.h\n// ALSO POSSIBLE TO SPECIFY SIMMETRIC AS TEMPLATE PARAMETER: WrapperDiscardListsLLF<SimilarityMetric>\nvoid wrapperDiscardListsExample() {\n  cout << \"----- EXAMPLE: WrapperDiscardLists ----\" << endl;\n\n  StringContainerVector strContainer(true);\n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n  \n  // create wrapper and build index using 0.5 as reduction ratio\n  WrapperDiscardListsLLFEd wrapper(&strContainer, 2, true, 0.5);\n  wrapper.buildIndex();\n\n  // perform search\n  float editDistance = 1.0f;\n  string queryString = \"kathrin\";\n  vector<unsigned> resultStringIDs;\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  // save index\n  wrapper.saveIndex(\"wrapperIndex.ix\");\n\n  // load index\n  wrapper.loadIndex(\"wrapperIndex.ix\");\n\n  // perform search on loaded index\n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  cout << \"-----------------------------------------\" << endl << endl;  \n}\n\n\n// USAGE OF WRAPPERS FOR DISK-BASED INDEXES\n// List of Wrappers:\n\n// wrappers using simple merging algorithm\n// WrapperOnDiskSimpleEd\n// WrapperOnDiskSimpleEdNorm\n// WrapperOnDiskSimpleJacc\n// WrapperOnDiskSimpleCos\n// WrapperOnDiskSimpleDice\n\n// wrappers using adaptive merging algorithm\n// WrapperOnDiskAdaptEd\n// WrapperOnDiskAdaptEdNorm\n// WrapperOnDiskAdaptJacc\n// WrapperOnDiskAdaptCos\n// WrapperOnDiskAdaptDice\n\n// see typedefs in wrapperondisk.h\n// ALSO POSSIBLE TO SPECIFY SIMMETRIC AS TEMPLATE PARAMETER: WrapperSimple<SimilarityMetric>\nvoid wrapperOnDiskSimpleExample() {\n  cout << \"----- EXAMPLE: WrapperOnDisk -----\" << endl;\n  \n  StringContainerRM strContainer(true);\n  strContainer.createAndOpen(\"wrapperContainer.rm\");\n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n  \n  // create wrapper and build index\n  // params: stringcontainer, use partitioning filter?, gramlength, use pre- and postfixing or string?\n  WrapperOnDiskSimpleEd wrapper(&strContainer, \"invLists.ix\", 2, true, true);\n  wrapper.buildIndex();\n\n  // perform search\n  float editDistance = 1.0f;\n  string queryString = \"kathrin\";\n  vector<unsigned> resultStringIDs;\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  // save index\n  wrapper.saveIndex(\"wrapperIndex.ix\");\n\n  // load index\n  wrapper.loadIndex(\"wrapperIndex.ix\");\n\n  // perform search on loaded index\n  resultStringIDs.clear();\n  wrapper.search(queryString, editDistance, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs[i]);\n    cout << tmp << endl;\n  }\n\n  cout << \"-----------------------------------------\" << endl << endl;  \n}\n", "encoding": "ascii"}