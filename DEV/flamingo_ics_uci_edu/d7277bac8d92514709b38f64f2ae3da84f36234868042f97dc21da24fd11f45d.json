{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/common/simmetric.cc", "content": "/*\n  $Id: simmetric.cc 5149 2010-03-24 23:37:18Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the\n  BSD license.\n  \n  Some of the code in this file is part of compression techniques.\n  Such parts are appropriately marked.\n  Redistribution of the compression techniques is permitted under \n  the terms of the Academic BSD License.\n  \n  Date: 04/15/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu>, \n  Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"simmetric.h\"\n#include \"filtertypes.h\"\n#include \"util/misc.h\"\n\n#include <cmath>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n// ------------------------------ SimMetric       ------------------------------\n\nbool SimMetric::operator()(const string &s1, const string &s2, float threshold) \n  const \n{\n  return operator()(s1, s2) >= threshold;\n}\n\n// ------------------------------ SimMetricEd     ------------------------------\n\nfloat SimMetricEd::operator()(const string &s1, const string &s2) \n  const \n{  \n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m;\n  if (m == 0)\n    return n;\n\n  uint* d[2];\n  for (uint i = 0; i < 2; ++i)\n    d[i] = new uint[m + 1];\n\n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1, \n                           d[iCrt][j - 1] + 1), \n                       d[iPre][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  uint res = d[iPre][m];\n  \n  for (uint i = 0; i < 2; ++i)\n    delete [] d[i];\n  \n  return res;\n}\n\nbool SimMetricEd::operator()(const string &s1, const string &s2, float threshold) \n  const \n{\n  uint T = static_cast<uint>(threshold);\n\n  uint i, j, ii, jj;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0)\n    return m <= T;\n  if (m == 0)\n    return n <= T;\n  if ((n > m && n - m > T) ||  \n      (m > n &&  m - n > T))\n    return false;\n\n  uint **d;\n  d = new uint*[n + 1];\n  for (uint i = 0; i < n + 1; ++i)\n    d[i] = new uint[m + 1];\n  \n  uint dmin, dmax = T + 1;\n\n  for (i = 0; i <= n; i++)\n    d[i][0] = i;\n  for (j = 1; j <= m; j++)\n    d[0][j] = j;\n\n  for (ii = 1; ii <= n; ii++) {\n    dmin = dmax;\n    for (j = 1; j <= min(ii, m); j++) {\n      i = ii - j + 1;\n      d[i][j] = min(min(d[i - 1][j] + 1,\n                        d[i][j - 1] + 1),\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(d[i][j], d[i - 1][j]));\n    }\n    if (dmin > T) {\n      for (uint i = 0; i < n + 1; ++i)\n\tdelete [] d[i];\n      delete [] d;\n      return false;\n    }\n  }\n  \n  for (jj = 2; jj <= m; jj++) {\n    dmin = dmax;\n    for (j = jj; j <= min(n + jj - 1, m); j++) {\n      i = n - (j - jj);\n      d[i][j] = min(min(d[i - 1][j] + 1,\n                        d[i][j - 1] + 1),\n                    d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));\n      dmin = min(dmin, min(d[i][j], d[i - 1][j]));\n    }\n\n    if (dmin > T) {\n      for (uint i = 0; i < n + 1; ++i)\n\tdelete [] d[i];\n      delete [] d;\n      return false;\n    }\n  }\n\n  bool res = d[n][m] <= T;\n  \n  for (uint i = 0; i < n + 1; ++i)\n    delete [] d[i];\n  delete [] d;\n\n  return res;\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEd::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes, \n  const float simThreshold, \n  const CompressionArgs* compressArgs) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  uint q = gramGen.getGramLength();\n  uint numGrams = queryGramCodes.size();\n\n  if(!compressArgs) return numGrams - (q * edThreshold); \n  else {\n    // compression arguments set, analyze them\n    // check to see if we have a blacklist\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;\n\n      if(!compressArgs->holesOptimized) {\n        // using holes compression but optimization is disabled\n        // count the number of holes\n        uint numberHoles = 0;\n        for(uint i = 0; i < numGrams; i++)\n          if( blackList->find( queryGramCodes.at(i )) != blackList->end() ) \n            numberHoles++;\n\t\n        return numGrams - (edThreshold * q) - numberHoles;\n      }\n      else {\n        // we have holes compression with optimization turned on\n        // start dynamic programming algorithm\n\t\n        // initialize dynamic programming matrix\n        uint numberHoles = 0;\n        uint imax = edThreshold + 1;\n        uint jmax = numGrams + q;\n        uint dpMatrix[imax][jmax];\n        memset(*dpMatrix, 0, sizeof(uint)*imax*jmax);\n\t\n        // initialize singlePosVector and count number of holes\n        uint singlePosVector[numGrams];\n        memset(singlePosVector, 0, sizeof(uint)*numGrams);\n        uint killCounter = 0;\n        for(uint i = 0; i < numGrams; i++) {\n          if(i >= q) {      \n            if( blackList->find( queryGramCodes.at(i - q) ) == blackList->end() ) \n              killCounter--;    \n          }\n\t  \n          uint gramCode = queryGramCodes.at(i);        \n          if( blackList->find(gramCode) == blackList->end() ) killCounter++;\n          else numberHoles++;\n          singlePosVector[i] = killCounter;\n        }\n\t\n        // start dynamic programming algorithm\n        for(uint i = 1; i < imax; i++) {\n          for(uint j = q; j < jmax; j++) {\n            uint a = dpMatrix[i][j-1];\n            uint b = singlePosVector[j-q] + dpMatrix[i-1][j-q];     \n            dpMatrix[i][j] = (a>b) ? a : b;\n          }\n        }\n\t\n        return numGrams - numberHoles - dpMatrix[imax-1][jmax-1];\n      }\n    }\n    else {\n      // blackList is NULL, return default\n      return numGrams - (q * edThreshold);\n    }\n  }\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEd::getMergeThreshold(\n  const string& query, \n  const float simThreshold, \n  const uint numberHoles) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  uint originalT = gramGen.getNumGrams(query) - \n    (gramGen.getGramLength() * edThreshold);\n  return originalT - numberHoles;\n}\n\nvoid SimMetricEd::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint edThreshold = (uint)simThreshold;\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = query.length() - edThreshold;\n    if((signed)lbound <= 0) lbound = 0;\n    ubound = query.length() + edThreshold;\n  } break;\n    \n  case FT_CHARSUM: { \n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint sum = csFilter->getCharsum(query);\n    lbound = sum - (edThreshold * csFilter->getMaxChar());\n    if((signed)lbound < 0) lbound = 0;\n    ubound = sum + (edThreshold * csFilter->getMaxChar());\n  } break;\n\n  default: {\n    cout << \"UNKNOWN FILTER TYPE IN getFilterBounds\" << endl;\n    lbound = 0;\n    ubound = 0;\n  } break;\n\n  }\n}\n  \nfloat SimMetricEd::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEd::getSimMin Not Implemented\" << endl; \n  exit(1); \n}\n\nfloat SimMetricEd::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsQuery - noGramsCommon) / \n    gramGen.getGramLength();\n}\n\nuint SimMetricEd::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = noGramsQuery - sim * gramGen.getGramLength();\n  return th > 1 ? static_cast<uint>(floor(th)) : 1;\n}\n\nuint SimMetricEd::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return noGramsQuery + sim;\n}\n\n// ------------------------------ SimMetricEdNorm ------------------------------\n\nfloat SimMetricEdNorm::operator()(const string &s1, const string &s2) \n  const \n{\n  return 1.0f - static_cast<float>(SimMetricEd::operator()(s1, s2)) / \n    max(s1.length(), s2.length());\n}\n\nbool SimMetricEdNorm::operator()(const string &s1, const string &s2, float threshold) \n  const \n{  \n  return SimMetricEd::operator()(s1, s2, ceil((1.0f - threshold) * max(s1.length(), s2.length())));\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEdNorm::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{  \n  float ed = ceil((1.0f - simThreshold) * query.length());\n  return this->SimMetricEd::getMergeThreshold(query, queryGramCodes, ed, compressArgs);\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEdNorm::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  float ed = ceil((1.0f - simThreshold) * query.length());\n  return this->SimMetricEd::getMergeThreshold(query, ed, numberHoles);  \n}\n\nvoid SimMetricEdNorm::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  float ed = ceil((1.0f - simThreshold) * query.length());\n  this->SimMetricEd::getFilterBounds(query, ed, filter, lbound, ubound);\n} \n\nfloat SimMetricEdNorm::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return 0;\n}\n\nfloat SimMetricEdNorm::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  return 1 - static_cast<float>(noGramsQuery - noGramsCommon) / \n    (gramGen.getGramLength() * lenQuery);\n}\n\nuint SimMetricEdNorm::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = noGramsQuery - (1 - sim) * lenQuery * gramGen.getGramLength(); \n  return th > 1 ? static_cast<uint>(floor(th)) : 1;\n}\n\nuint SimMetricEdNorm::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = \n    (noGramsQuery +  (1 - sim) * (1 -  gramGen.getGramLength())) / sim; \n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\n// ------------------------------ SimMetricEdSwap ------------------------------\n\nfloat SimMetricEdSwap::operator()(const string &s1, const string &s2) \n  const \n{\n  uint i, iCrt, iPre, j;\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  uint* d[2];\n  for (uint i = 0; i < 2; ++i)\n    d[i] = new uint[m + 1];\n  \n  for (j = 0; j <= m; j++)\n    d[0][j] = j;\n\n  iCrt = 1;\n  iPre = 0;\n  for (i = 1; i <= n; i++) {\n    d[iCrt][0] = i;\n    for (j = 1; j <= m; j++)\n      d[iCrt][j] = min(min(d[iPre][j] + 1,\n                           d[iCrt][j - 1] + 1),\n                       d[iPre][j - 1] + ((s1[i - 1] == s2[j - 1] ||\n                                          (i > 1 &&\n                                           j > 1 &&\n                                           s1[i - 1] == s2[j - 2] &&\n                                           s1[i - 2] == s2[j - 1])) ? 0 : 1));\n    iPre = !iPre;\n    iCrt = !iCrt;\n  }\n  \n  uint res = d[iPre][m];\n  \n  for (uint i = 0; i < 2; ++i)\n    delete [] d[i];\n  \n  return res;\n}\n\nuint SimMetricEdSwap::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n  cerr << \"SimMetricEdSwap::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricEdSwap::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricEdSwap::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricEdSwap::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricEdSwap::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n} \n\nfloat SimMetricEdSwap::getSimMin(\n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEdSwap::getSimMin Not Implemented\" << endl;\n  exit(1);\n}\n\nfloat SimMetricEdSwap::getSimMax(\n  uint lenQuery, \n  uint noGramsQuery, \n  uint noGramsData, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricEdSwap::getSimMax Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricEdSwap::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricEdSwap::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricEdSwap::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricEdSwap::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n// ------------------------------ SimMetircGram   ------------------------------\n\n// ------------------------------ SimMetricJacc   ------------------------------\n\nfloat SimMetricJacc::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sUni;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_union(s1Gram.begin(), s1Gram.end(),\n            s2Gram.begin(), s2Gram.end(), \n            inserter(sUni, sUni.begin()));\n  \n  uint interSize  = s1Gram.size() + s2Gram.size() - sUni.size();\n  \n  float d = static_cast<float>(interSize) / sUni.size();\n  \n  return d;\n}\n \nfloat SimMetricJacc::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return static_cast<float>(noGramsCommon) / \n    (noGramsQuery + noGramsData - noGramsCommon);\n}\n     \nvoid SimMetricJacc::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold);\n    ubound = (uint)ceil(((float)numGrams/simThreshold)); \n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold);\n    uint maxGrams = (uint)ceil(((float)numGrams/simThreshold)); \n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar());\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar());\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricJacc::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{\n  uint numGrams = queryGramCodes.size();\n  if(!compressArgs) return (uint)floor(simThreshold*(numGrams));\n  else {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) { \n        uint gramCode = queryGramCodes.at(i);\n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \n      } \n\t\n      return (uint)floor(simThreshold*numGrams); \n    }\n    else {\n      // compression but no holes compression, so return default\n      return (uint)floor(simThreshold*(numGrams));\n    }\n  }\n}\n \n// ATTENTION: part of compression techniques\nuint SimMetricJacc::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  return (uint)floor(simThreshold * gramGen.getNumGrams(query) -  numberHoles);\n}\n\nuint SimMetricJacc::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = max(sim * noGramsQuery,\n                 (noGramsQuery + noGramsMin) / (1 + 1 / sim));\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\nuint SimMetricJacc::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return noGramsQuery / sim;\n}\n\n// ------------------------------ SimMetricCos    ------------------------------\n\nfloat SimMetricCos::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  static_cast<float>(sInt.size()) / \n    sqrt(static_cast<float>(s1Gram.size() * s2Gram.size()));\n  \n  return d;\n}\n      \nfloat SimMetricCos::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return noGramsCommon / sqrt(static_cast<float>(noGramsQuery * noGramsData));\n}\n     \nuint SimMetricCos::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n\n  // uint gramLength = gramGen.getGramLength();\n  uint numGrams = queryGramCodes.size();\n  if(!compressArgs) return (uint)floor(simThreshold*simThreshold*numGrams); \n  else {\n    // compression args are set\n    if(compressArgs->blackList) {\n      set<uint>* blackList = compressArgs->blackList;      \n      for(uint i = 0; i < numGrams; i++) {     \n        uint gramCode = queryGramCodes.at(i);\t  \n        if(blackList->find(gramCode) != blackList->end())\n          numGrams--;    \t  \n      } \t\n      return (uint)floor(simThreshold*simThreshold*numGrams); \n    }\n    else {\n      // compression but no holes compression, so return default\n      return (uint)floor(simThreshold*simThreshold*numGrams); \n    }\n  }    \n}\n  \n// ATTENTION: part of compression techniques\nuint SimMetricCos::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  return (uint)floor(simThreshold*simThreshold*gramGen.getNumGrams(query) - \n                         numberHoles);   \n}\n\nvoid SimMetricCos::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n    \n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n    \n  switch(filter->getType()) {\n      \n  case FT_LENGTH: {\n    lbound = (uint)floor((float)numGrams*simThreshold*simThreshold - gramLength + 1);\n    ubound = (uint)ceil(((float)numGrams/(simThreshold*simThreshold)) - gramLength + 1);\n    if ((signed)lbound < 0) lbound = 0;\n  } break;\n      \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor((float)numGrams*simThreshold*simThreshold);\n    uint maxGrams = (uint)ceil((float)numGrams/(simThreshold*simThreshold));\n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar()*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar()*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }\n}\n\nuint SimMetricCos::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  float th = sim * sqrt(static_cast<float>(noGramsQuery * noGramsMin));\n  return th > 1 ? static_cast<uint>(ceil(th)) : 1;\n}\n\nuint SimMetricCos::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricCos::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n// ------------------------------ SimMetricDice   ------------------------------\n\nfloat SimMetricDice::operator()(const string &s1, const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n\n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  float d =  2. * sInt.size() / (s1Gram.size() + s2Gram.size());\n  \n  return d;\n}\n      \nfloat SimMetricDice::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  cerr << \"SimMetricDice::operator(noGramsData, noGramQuery, noGramsCommon) \"\n       << \"Not Implemented\" << endl;\n  exit(1);\n}\n     \nuint SimMetricDice::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs)\n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n \n// ATTENTION: part of compression techniques\nuint SimMetricDice::getMergeThreshold(\n\tconst string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricEdNorm::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricDice::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  uint numGrams = gramGen.getNumGrams(query);\n  uint gramLength = gramGen.getGramLength();\n  switch(filter->getType()) {\n    \n  case FT_LENGTH: {\n    lbound = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    ubound = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    if(gramGen.prePost) {\n      lbound = lbound - gramLength + 1;\n      ubound = ubound - gramLength + 1;\n    }\n    else {\n      lbound = lbound + gramLength - 1;\n      ubound = ubound + gramLength - 1;\n    }\n    if((signed)lbound < 0) lbound = 0;\n  } break;\n    \n  case FT_CHARSUM: {\n    const CharsumFilter* csFilter = dynamic_cast<const CharsumFilter*>(filter);\n    uint queryChecksum = csFilter->getCharsum(query);\n    uint minGrams = (uint)floor( ((float)numGrams*simThreshold) / (2.0f - simThreshold) );\n    uint maxGrams = (uint)ceil( ((2.0f - simThreshold) * numGrams) / simThreshold);\n    lbound = queryChecksum - ((numGrams - minGrams)*csFilter->getMaxChar()*gramLength);\n    ubound = queryChecksum + ((maxGrams - numGrams)*csFilter->getMaxChar()*gramLength);\n  } break;\n      \n  default: {\n    lbound = 0;\n    ubound = 0;\n    cout << \"WARNING: unknown filter passed to distancemeasure.\" << endl;\n  } break;\n      \n  }   \n}\n\nuint SimMetricDice::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDice::noGramsMin Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricDice::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricDice::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n\n// ------------------------------ SimGramCount    ------------------------------\n\nfloat SimMetricGramCount::operator()(\n  const string &s1, \n  const string &s2) \n  const \n{\n  uint\n    n = s1.length(), \n    m = s2.length();\n\n  if (n == 0 || m == 0)\n    return 0;\n  \n  set<uint> s1Gram, s2Gram, sInt;\n  gramGen.decompose(s1, s1Gram);\n  gramGen.decompose(s2, s2Gram);\n\n  set_intersection(s1Gram.begin(), s1Gram.end(),\n                   s2Gram.begin(), s2Gram.end(), \n                   inserter(sInt, sInt.begin()));\n  \n  return sInt.size();\n}\n      \nfloat SimMetricGramCount::operator()(\n  uint noGramsData, \n  uint noGramsQuery, \n  uint noGramsCommon) \n  const \n{\n  return noGramsCommon;\n}\n     \nuint SimMetricGramCount::getMergeThreshold(\n  const string& query, \n  const vector<uint>& queryGramCodes,\n  const float simThreshold,\n  const CompressionArgs* compressArgs) \n  const \n{\n  cerr << \"SimMetricGramCount::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\n// ATTENTION: part of compression techniques\nuint SimMetricGramCount::getMergeThreshold(\n  const string& query,\n  const float simThreshold,\n  const uint numberHoles) \n  const \n{\n  cerr << \"SimMetricGramCount::getMergeThreshold Not Implemented\" << endl;\n  exit(1);\n}\n\nvoid SimMetricGramCount::getFilterBounds(\n  const string& query,\n  const float simThreshold,\n  const AbstractFilter* filter,\n  uint& lbound,\n  uint& ubound) \n  const \n{\n  cerr << \"SimMetricGramCount::getFilterBounds Not Implemented\" << endl;\n  exit(1);\n}\n\nuint SimMetricGramCount::getNoGramsMin(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  return static_cast<uint>(sim);\n}\n\nuint SimMetricGramCount::getNoGramsMax(\n  uint lenQuery, \n  uint noGramsMin, \n  uint noGramsQuery, \n  float sim)\n  const \n{\n  cerr << \"SimMetricGramCount::getNoGramsMax Not Implemented\" << endl; \n  exit(1); \n}\n", "encoding": "ascii"}