{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/common/filtertypes.cc", "content": "/*\n  $Id: filtertypes.cc 4777 2009-11-20 01:26:06Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license\n    \n  Date: 04/04/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"filtertypes.h\"\n#include \"listmerger/heap.h\"\n#include \"util/misc.h\"\n#include <cmath>\n#include <climits>\n\nAbstractFilter* \nAbstractFilter::\nloadFilterInstance(ifstream& fpIn) {\n  FilterType filterType;\n  fpIn.read((char*)&filterType, sizeof(FilterType));\n\n  switch(filterType) {\n  case FT_LENGTH: return new LengthFilter(fpIn); break;\n  case FT_CHARSUM: return new CharsumFilter(fpIn); break;\n  default: {\n    cout << \"WARNING: attempt to read filter from file failed. Unknown filter type.\" << endl;\n    return NULL;\n  } break;\n  }\n}\n\nLengthFilter::\nLengthFilter(ifstream& fpIn) {\n  ft = FT_LENGTH;\n  fpIn.read((char*)&maxStrLen, sizeof(unsigned));\n  fpIn.read((char*)&this->maxKey, sizeof(unsigned));\n}\n\nunsigned \nLengthFilter::\ngetFilterLbound() const {\n  return 0;\n}\n\nunsigned \nLengthFilter::\ngetFilterUbound() const  {\n  return maxKey;\n}\n\nvoid \nLengthFilter::\nadjustBounds(unsigned minKey, unsigned maxKey, unsigned fanout) {\n  // we only adjust the upper bound for the length filter\n  this->maxKey = maxKey + (fanout - (maxKey % fanout));\n}\n\nunsigned\nLengthFilter::\ngetKey(const string& s) const  {\n  return s.length();\n}\n\nAbstractFilter* \nLengthFilter::\nclone() const {\n  return new LengthFilter((LengthFilter*)this);\n}\n\nvoid\nLengthFilter::\nsaveFilterInstance(ofstream& fpOut) const {\n  fpOut.write((const char*)&ft, sizeof(FilterType));\n  fpOut.write((const char*)&maxStrLen, sizeof(unsigned));\n  fpOut.write((const char*)&this->maxKey, sizeof(unsigned));\n}\n\nCharsumFilter::\nCharsumFilter(ifstream& fpIn) {\n  ft = FT_CHARSUM;\n  fpIn.read((char*)&maxStrLen, sizeof(unsigned));\n  fpIn.read((char*)&maxChar, sizeof(unsigned char));\n  fpIn.read((char*)&this->maxKey, sizeof(unsigned));\n\n  // read charmap\n  unsigned charMapSize;\n  fpIn.read((char*)&charMapSize, sizeof(unsigned));\n  if(charMapSize == 256) {\n    charMap = new unsigned char[256];\n    fpIn.read((char*)&charMap, sizeof(unsigned char) * 256);\n  }\n  else {\n    charMap = NULL;\n  }\n}\n\nvoid \nCharsumFilter::\nsetCharMap(const unsigned* charFreqs) {  \n\n  if(charFreqs == NULL) {\n    charMap = NULL;\n    return;\n  }\n\n  double totalFreq = 0;\n  CharFreq freqs[256];\n  for(unsigned i = 0; i < 256; i++) {\n    freqs[i].c = (unsigned char)i;\n    freqs[i].freq = charFreqs[i];\n    totalFreq += charFreqs[i];\n  }\n  qsort(freqs, 256, sizeof(CharFreq), CharFreq::cmp);\n  \n  // set the charmap and the maxChar\n  charMap = new unsigned char[256];\n  double currFreq = 0;\n  maxChar = 0;\n  for(unsigned i = 0; i < 256; i++) {\n    charMap[(unsigned char)freqs[i].c] = i;\n    currFreq += freqs[i].freq;\n    if(maxChar == 0 && (currFreq / totalFreq) >= 0.95) maxChar = i;\n  }  \n}\n\nunsigned \nCharsumFilter::\ngetFilterLbound() const {\n  return 0;\n}\n\nunsigned \nCharsumFilter::\ngetFilterUbound() const {\n  return maxKey;\n}\n\nvoid \nCharsumFilter::\nadjustBounds(unsigned minKey, unsigned maxKey, unsigned fanout) {\n  // we only adjust the upper bound for the charsum filter  \n  this->maxKey = maxKey + (fanout - (maxKey % fanout));\n}\n\nunsigned\nCharsumFilter::\ngetKey(const string& s) const { \n  return getCharsum(s);\n}\n\nAbstractFilter* \nCharsumFilter::\nclone() const {\n  return new CharsumFilter((CharsumFilter*)this);\n}\n\nvoid\nCharsumFilter::\nsaveFilterInstance(ofstream& fpOut) const {\n  fpOut.write((const char*)&ft, sizeof(FilterType));\n  fpOut.write((const char*)&maxStrLen, sizeof(unsigned));\n  fpOut.write((const char*)&maxChar, sizeof(unsigned char));\n  fpOut.write((const char*)&this->maxKey, sizeof(unsigned));\n\n  // write charmap\n  unsigned charMapSize = 0;\n  if(charMap) {\n    charMapSize = 256;\n    fpOut.write((const char*)&charMapSize, sizeof(unsigned));\n    fpOut.write((const char*)&charMap, sizeof(unsigned char) * charMapSize);\n  }\n  else {\n    fpOut.write((const char*)&charMapSize, sizeof(unsigned));\n  }\n}\n\nunsigned \nCharsumFilter::\ngetCharsum(const string& str) const {\n  unsigned sum = 0;\n  if(charMap) {\n    for(unsigned i = 0; i < str.size(); i++) {\n      unsigned char c = charMap[(unsigned char)str[i]];\n      sum += (c > maxChar) ? maxChar : c;\n    }\n  }\n  else {\n    for(unsigned i = 0; i < str.size(); i++) {\n      unsigned char c = (unsigned char)str[i];\n      sum += (c > maxChar) ? maxChar : c;\n    }\n  }\n  return sum;  \n}\n\nunsigned \nCharsumFilter::\nfillCharsumStats(const string& str, \n\t\t unsigned* charsum, \n\t\t unsigned char* lowChars, \n\t\t unsigned char* highChars, \n\t\t unsigned numChars) {\n  \n  unsigned sum = 0;\n  unsigned charCount = 0;\n  Heap<unsigned char> queryHighHeap(str.size(), numChars);\n  Heap<unsigned char> queryLowHeap(str.size(), numChars);\n  unsigned char reverseChars[str.size()];\n\n  if(charMap) {\n    for(unsigned i = 0; i < str.size(); i++) {\n      unsigned char c = charMap[(unsigned char)str[i]];\n      if(c > maxChar) c = maxChar;\n      sum += c;\n      reverseChars[i] = (unsigned char)0xFF - charMap[(unsigned char)str[i]];\n      queryHighHeap.push((unsigned char*)&reverseChars[i]);\n      queryLowHeap.push((unsigned char*)&charMap[(unsigned char)str[i]]);\n    }\n    *charsum = sum;\n    \n    while(charCount < numChars && charCount < str.size()) {  \n      lowChars[charCount] = *(queryLowHeap.head());\n      highChars[charCount] = (unsigned char)0xFF - *(queryHighHeap.head());\n      if(lowChars[charCount] > maxChar) lowChars[charCount] = maxChar;\n      if(highChars[charCount] > maxChar) highChars[charCount] = maxChar;\n      queryLowHeap.pop();\n      queryHighHeap.pop();\n      charCount++;\n    }     \n  }\n  else {\n    for(unsigned i = 0; i < str.size(); i++) {\n      unsigned char c = (unsigned char)str[i];\n      if(c > maxChar) c = maxChar;    \n      sum += c;\n      reverseChars[i] = (unsigned char)0xFF - (unsigned char)str[i];\n      queryHighHeap.push((unsigned char*)&reverseChars[i]);\n      queryLowHeap.push((unsigned char*)&str[i]);\n    }\n    *charsum = sum;\n    \n    while(charCount < numChars && charCount < str.size()) {  \n      lowChars[charCount] = *(queryLowHeap.head());\n      highChars[charCount] = (unsigned char)0xFF - *(queryHighHeap.head());\n      if(lowChars[charCount] > maxChar) lowChars[charCount] = maxChar;\n      if(highChars[charCount] > maxChar) highChars[charCount] = maxChar;\n      queryLowHeap.pop();\n      queryHighHeap.pop();\n      charCount++;\n    } \n  }\n  \n  return charCount;\n}\n\nvoid\nCharsumFilter::\nprepareCache(unsigned editDistance) {\n  unsigned lengths = editDistance * 2 + 1; // answers could be ed shorter, ed longer, or same length  \n  \n  // initialize cache\n  lbCache = new signed*[lengths];\n  ubCache = new signed*[lengths];\n  for(unsigned i = 0; i < lengths; i++) {\n    lbCache[i] = new signed[maxChar+1];\n    ubCache[i] = new signed[maxChar+1];\n    for(unsigned j = 0; j <= maxChar; j++) {\n      lbCache[i][j] = INT_MIN;\n      ubCache[i][j] = INT_MAX;\n    }\n  } \n}\n\nbool \nCharsumFilter::\npassesFilterCache(QueryCharsumStats* queryStats, StrCharsumStats* candiStats, unsigned editDistance) {\n  signed deltaLen = (candiStats->length > queryStats->length) ? candiStats->length - queryStats->length : queryStats->length - candiStats->length;\n  signed ed = (signed)editDistance;\n  if(deltaLen > ed) return false;\n\n  unsigned cacheIx;  \n  if(queryStats->length <= candiStats->length) {\n    cacheIx = candiStats->length - queryStats->length;\n\n    // check the bounds in the cache\n    if((signed)candiStats->charsum < lbCache[cacheIx][candiStats->lChar] || (signed)candiStats->charsum > ubCache[cacheIx][candiStats->hChar]) return false;\n    \n    // check if we need to compute cache values\n    if(lbCache[cacheIx][candiStats->lChar] == INT_MIN) {\n      // compute both bounds\n      if(ubCache[cacheIx][candiStats->hChar] == INT_MAX) {\n\tsigned subst = ed - deltaLen;\n\tubCache[cacheIx][candiStats->hChar] = (signed)queryStats->charsum + deltaLen * candiStats->hChar;\n\tlbCache[cacheIx][candiStats->lChar] = (signed)queryStats->charsum + deltaLen * candiStats->lChar;\n\tfor(signed i = 0; i < subst; i++) {\n\t  ubCache[cacheIx][candiStats->hChar] += (candiStats->hChar > queryStats->lChars[i]) ? (signed)candiStats->hChar - (signed)queryStats->lChars[i] : 0;\n\t  lbCache[cacheIx][candiStats->lChar] += (candiStats->lChar < queryStats->hChars[i]) ? (signed)candiStats->lChar - (signed)queryStats->hChars[i] : 0;\n\t}      \n\t\n\tif((signed)candiStats->charsum < lbCache[cacheIx][candiStats->lChar] || (signed)candiStats->charsum > ubCache[cacheIx][candiStats->hChar]) return false;\n      }\n      // only compute lower bound\n      else {\n\tsigned subst = ed - deltaLen;\n\tlbCache[cacheIx][candiStats->lChar] = (signed)queryStats->charsum + deltaLen * candiStats->lChar;\n\tfor(signed i = 0; i < subst; i++) {\t  \n\t  lbCache[cacheIx][candiStats->lChar] += (candiStats->lChar < queryStats->hChars[i]) ? (signed)candiStats->lChar - (signed)queryStats->hChars[i] : 0;\n\t}      \t\n\tif((signed)candiStats->charsum < lbCache[cacheIx][candiStats->lChar]) return false;\n      }\n    }\n    else {\n      // only compute upper bound\n      if(ubCache[cacheIx][candiStats->hChar] == INT_MAX) {\n\tsigned subst = ed - deltaLen;\n\tubCache[cacheIx][candiStats->hChar] = (signed)queryStats->charsum + deltaLen * candiStats->hChar;\n\tfor(signed i = 0; i < subst; i++) {\n\t  ubCache[cacheIx][candiStats->hChar] += (candiStats->hChar > queryStats->lChars[i]) ? (signed)candiStats->hChar - (signed)queryStats->lChars[i] : 0;\t  \n\t}      \t\n\tif((signed)candiStats->charsum > ubCache[cacheIx][candiStats->hChar]) return false;\n      }\n    }    \n  }\n  else {\n    cacheIx = (queryStats->length - candiStats->length) << 1;\n        \n    // check the bounds in the cache\n    if((signed)candiStats->charsum < lbCache[cacheIx][candiStats->lChar] || (signed)candiStats->charsum > ubCache[cacheIx][candiStats->hChar]) return false;\n\n    // check if we need to compute cache values\n    if(lbCache[cacheIx][candiStats->lChar] == INT_MIN) {\n      // compute both bounds\n      if(ubCache[cacheIx][candiStats->hChar] == INT_MAX) {\n\tsigned subst = ed - deltaLen;\n\tubCache[cacheIx][candiStats->hChar] = (signed)queryStats->charsum;\n\tlbCache[cacheIx][candiStats->lChar] = (signed)queryStats->charsum;\n\tfor(signed i = 0; i < deltaLen; i++) {\n\t  ubCache[cacheIx][candiStats->hChar] -= (signed)queryStats->lChars[i];\n\t  lbCache[cacheIx][candiStats->lChar] -= (signed)queryStats->hChars[i];\n\t}\n\tfor(signed i = 0; i < subst; i++) {\n\t  unsigned qix = i + deltaLen;\n\t  ubCache[cacheIx][candiStats->hChar] += (candiStats->hChar > queryStats->lChars[qix]) ? (signed)candiStats->hChar - (signed)queryStats->lChars[qix] : 0;\t\n\t  lbCache[cacheIx][candiStats->lChar] += (candiStats->lChar < queryStats->hChars[qix]) ? (signed)candiStats->lChar - (signed)queryStats->hChars[qix] : 0;\t\n\t}            \t\n\tif((signed)candiStats->charsum < lbCache[cacheIx][candiStats->lChar] || (signed)candiStats->charsum > ubCache[cacheIx][candiStats->hChar]) return false;\t\n      }\n      // compute only lower bound\n      else {\n\tsigned subst = ed - deltaLen;\n\tlbCache[cacheIx][candiStats->lChar] = (signed)queryStats->charsum;\n\tfor(signed i = 0; i < deltaLen; i++) {\n\t  lbCache[cacheIx][candiStats->lChar] -= (signed)queryStats->hChars[i];\n\t}\n\tfor(signed i = 0; i < subst; i++) {\n\t  unsigned qix = i + deltaLen;\t  \n\t  lbCache[cacheIx][candiStats->lChar] += (candiStats->lChar < queryStats->hChars[qix]) ? (signed)candiStats->lChar - (signed)queryStats->hChars[qix] : 0;\t\n\t}\t\n\tif((signed)candiStats->charsum < lbCache[cacheIx][candiStats->lChar]) return false;\n      }\n    }\n    else {\n      // compute only upper bound\n      if(ubCache[cacheIx][candiStats->hChar] == INT_MAX) {\n\tsigned subst = ed - deltaLen;\n\tubCache[cacheIx][candiStats->hChar] = (signed)queryStats->charsum;\n\tfor(signed i = 0; i < deltaLen; i++) {\n\t  ubCache[cacheIx][candiStats->hChar] -= (signed)queryStats->lChars[i];\n\t}\n\tfor(signed i = 0; i < subst; i++) {\n\t  unsigned qix = i + deltaLen;\n\t  ubCache[cacheIx][candiStats->hChar] += (candiStats->hChar > queryStats->lChars[qix]) ? (signed)candiStats->hChar - (signed)queryStats->lChars[qix] : 0;\t\t  \n\t}            \t\n\tif((signed)candiStats->charsum > ubCache[cacheIx][candiStats->hChar]) return false;\n      }\n    }    \n  }  \n  \n  return true;\n}\n\nvoid \nCharsumFilter::\nclearCache(unsigned editDistance) {\n  unsigned lengths = editDistance * 2 + 1; // answers could be ed shorter, ed longer, or same length  \n  for(unsigned i = 0; i < lengths; i++) {\n    delete lbCache[i];\n    delete ubCache[i];\n  } \n  delete lbCache;\n  delete ubCache;\n}\n\nbool \nCharsumFilter::\npassesFilter(QueryCharsumStats* queryStats, StrCharsumStats* candiStats, unsigned editDistance) {\n  signed ed = (signed)editDistance;\n  register signed ubound = (signed)queryStats->charsum;\n  register signed lbound = (signed)queryStats->charsum;\n  register signed deltaLen = (candiStats->length > queryStats->length) ? candiStats->length - queryStats->length : queryStats->length - candiStats->length;\n  if(deltaLen > ed) return false;\n  \n  signed subst = ed - deltaLen;\n  if(queryStats->length <= candiStats->length) {\n    ubound += deltaLen * candiStats->hChar;\n    lbound += deltaLen * candiStats->lChar;\n    for(signed i = 0; i < subst; i++) {\n      ubound += (candiStats->hChar > queryStats->lChars[i]) ? (signed)candiStats->hChar - (signed)queryStats->lChars[i] : 0;\n      lbound += (candiStats->lChar < queryStats->hChars[i]) ? (signed)candiStats->lChar - (signed)queryStats->hChars[i] : 0;\n    }\n  }\n  else {\n    for(signed i = 0; i < deltaLen; i++) {\n      ubound -= (signed)queryStats->lChars[i];\n      lbound -= (signed)queryStats->hChars[i];\n    }\n    for(signed i = 0; i < subst; i++) {\n      unsigned qix = i + deltaLen;\n      ubound += (candiStats->hChar > queryStats->lChars[qix]) ? (signed)candiStats->hChar - (signed)queryStats->lChars[qix] : 0;\n      lbound += (candiStats->lChar < queryStats->hChars[qix]) ? (signed)candiStats->lChar - (signed)queryStats->hChars[qix] : 0;\n    }\n  }\n  \n  if((signed)candiStats->charsum < lbound || (signed)candiStats->charsum > ubound) return false;\n  else return true;\n}\n\n\nbool \nCharsumFilter::\npassesFilter(signed queryLen, \n\t     signed queryChecksum, \n\t     unsigned char* queryLowChars,\n\t     unsigned char* queryHighChars,\n\t     signed candiLen, \n\t     signed candiChecksum,\n\t     signed candiLowChar,\n\t     signed candiHighChar,\n\t     unsigned editDistance) {\n  \n  signed ed = (signed)editDistance;\n  signed ubound = (signed)queryChecksum;\n  signed lbound = (signed)queryChecksum;\n  signed deltaLen = (candiLen > queryLen) ? candiLen - queryLen : queryLen - candiLen;\n  if(deltaLen > ed) return false;\n  \n  signed subst = ed - deltaLen;\n  if(queryLen <= candiLen) {\n    ubound += deltaLen * candiHighChar;\n    lbound += deltaLen * candiLowChar;\n    for(signed i = 0; i < subst; i++) {\n      ubound += (candiHighChar > queryLowChars[i]) ? (signed)candiHighChar - (signed)queryLowChars[i] : 0;\n      lbound += (candiLowChar < queryHighChars[i]) ? (signed)candiLowChar - (signed)queryHighChars[i] : 0;\n    }\n  }\n  else {\n    for(signed i = 0; i < deltaLen; i++) {\n      ubound -= (signed)queryLowChars[i];\n      lbound -= (signed)queryHighChars[i];\n    }\n    for(signed i = 0; i < subst; i++) {\n      unsigned qix = i + deltaLen;\n      ubound += (candiHighChar > queryLowChars[qix]) ? (signed)candiHighChar - (signed)queryLowChars[qix] : 0;\n      lbound += (candiLowChar < queryHighChars[qix]) ? (signed)candiLowChar - (signed)queryHighChars[qix] : 0;\n    }    \n  }\n  \n  if(candiChecksum < lbound || candiChecksum > ubound) return false;\n  else return true;\n}\n\nbool \nCharsumFilter::\npassesFilter(signed queryLen, \n\t     signed queryChecksum, \n\t     unsigned char* queryLowChars,\n\t     unsigned char* queryHighChars,\n\t     signed candiLen, \n\t     signed candiChecksum,\n\t     unsigned numCandiChars,\n\t     unsigned char* candiLowChars,\n\t     unsigned char* candiHighChars,\n\t     unsigned editDistance) {\n  \n  signed ed = (signed)editDistance;\n  signed maxCharIx = (signed)numCandiChars - (signed)1;\n  signed ubound = (signed)queryChecksum;\n  signed lbound = (signed)queryChecksum;\n  signed deltaLen = (candiLen > queryLen) ? candiLen - queryLen : queryLen - candiLen;\n  if(deltaLen > ed) return false;\n  \n  signed subst = ed - deltaLen;\n  if(queryLen <= candiLen) {\n    for(signed i = 0; i < deltaLen; i++) {\n      unsigned qix = (i > maxCharIx) ? maxCharIx : i;      \n      ubound += candiHighChars[qix];\n      lbound += candiLowChars[qix];\n    }\n    for(signed i = 0; i < subst; i++) {\n      unsigned cix = (i + deltaLen > maxCharIx) ? maxCharIx : i + deltaLen;\n      ubound += (candiHighChars[cix] > queryLowChars[i]) ? (signed)candiHighChars[cix] - (signed)queryLowChars[i] : 0;\n      lbound += (candiLowChars[cix] < queryHighChars[i]) ? (signed)candiLowChars[cix] - (signed)queryHighChars[i] : 0;\n    }    \n  }\n  else {\n    for(signed i = 0; i < deltaLen; i++) {\n      ubound -= queryLowChars[i];\n      lbound -= queryHighChars[i];\n    }\n    for(signed i = 0; i < subst; i++) {\n      unsigned qix = i + deltaLen;\n      unsigned cix = (i > maxCharIx) ? maxCharIx : i;\n      ubound += (candiHighChars[cix] > queryLowChars[qix]) ? (signed)candiHighChars[cix] - (signed)queryLowChars[qix] : 0;\n      lbound += (candiLowChars[cix] < queryHighChars[qix]) ? (signed)candiLowChars[cix] - (signed)queryHighChars[qix] : 0;\n    }    \n  }  \n  \n  if(candiChecksum < lbound || candiChecksum > ubound) return false;\n  else return true;\n}\n\nbool \nCharsumFilter::\npassesPartitionFilter(signed queryLen, \n\t\t      signed queryChecksum, \n\t\t      unsigned char* queryLowChars,\n\t\t      unsigned char* queryHighChars,\n\t\t      CharsumPartInfo* partInfo,\n\t\t      unsigned editDistance) {\n\n  // sanity\n  if(partInfo->minStrLen == 0xFFFFFFFF) return true;\n\n  signed ed = (signed)editDistance;\n  signed ubound = (signed)queryChecksum;\n  signed lbound = (signed)queryChecksum;\n\n  signed deltaLenUb = \n    ((signed)partInfo->maxStrLen > queryLen) \n    ? (signed)partInfo->maxStrLen - queryLen \n    : queryLen - (signed)partInfo->maxStrLen;\n\n  signed deltaLenLb = \n    ((signed)partInfo->minStrLen > queryLen) \n    ? (signed)partInfo->minStrLen - queryLen \n    : queryLen - (signed)partInfo->minStrLen;\n  \n  // compute upper bound\n  if(queryLen <= (signed)partInfo->maxStrLen) {\n    ubound += deltaLenUb * partInfo->highChar;\n  }\n  else {\n    for(signed i = 0; i < deltaLenUb; i++) {\n      ubound -= (signed)queryLowChars[i];\n    }\n  }\n  for(signed i = deltaLenUb; i < (signed)ed; i++) {\n    ubound += ((signed)partInfo->highChar > (signed)queryLowChars[i]) ? (signed)partInfo->highChar - (signed)queryLowChars[i] : 0;\n  }\n\n  // compute lower bound  \n  if(queryLen <= (signed)partInfo->minStrLen) {\n    lbound += (signed)deltaLenLb * (signed)partInfo->lowChar;\n  }\n  else {\n    for(signed i = 0; i < deltaLenLb; i++) {\n      lbound -= (signed)queryHighChars[i];\n    }\n  }\n  for(signed i = deltaLenLb; i < (signed)ed; i++) {\n    lbound += (partInfo->lowChar < (signed)queryHighChars[i]) ? partInfo->lowChar - (signed)queryHighChars[i] : 0;\n  }\n  \n  // sanity (cases can happen due to overflow)\n  if(lbound > ubound || lbound > queryChecksum || ubound < queryChecksum) return true;\n  \n  if((signed)partInfo->maxCharsum < lbound || (signed)partInfo->minCharsum > ubound) return false;\n  else return true;  \n}\n", "encoding": "ascii"}