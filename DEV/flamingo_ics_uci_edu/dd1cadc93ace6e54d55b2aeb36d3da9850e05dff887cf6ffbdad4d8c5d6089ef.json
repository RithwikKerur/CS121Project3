{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/filtertree/example.cc", "content": "/*\n  $Id: example.cc 5240 2010-05-19 16:51:45Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n    \n  Date: 02/04/2008\n  Author: Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"common/query.h\"\n#include \"common/simmetric.h\"\n\n#include \"ftindexermem.h\"\n#include \"ftindexerdiscardlists.h\"\n#include \"ftindexercombinelists.h\"\n#include \"listmerger/divideskipmerger.h\"\n#include \"listmerger/scancountmerger.h\"\n\n#include \"ftsearchermem.h\"\n#include \"ftindexerondisk.h\"\n#include \"ftsearcherondisk.h\"\n#include \"listmerger/ondiskmergersimple.h\"\n#include \"listmerger/ondiskmergeradapt.h\"\n\n#include \"util/misc.h\"\n\n// create a dummy dictionary\nextern void readString(vector<string>& data, const string& filenameData, unsigned count, unsigned maxLineLen);\nstd::vector<string> dictionary;\nvoid initDictionary();\n\nvoid memBasicUsage1();\nvoid memBasicUsage2();\nvoid memBasicUsage3();\nvoid memDiscardLists();\nvoid memCombineLists();\nvoid memAdvancedUsage();\n\nvoid ondiskBasicUsage1();\nvoid ondiskBasicUsage2();\n\nint main() {\n  \n  initDictionary();\n\n  memBasicUsage1();\n  memBasicUsage2();\n  memBasicUsage3();\n  memDiscardLists();\n  memCombineLists();\n  memAdvancedUsage();\n  \n  ondiskBasicUsage1();\n  ondiskBasicUsage2();\n  \n  return 0;\n}\n\nvoid initDictionary() {\n  // params: target vector, filename, number strings to read, max line length\n  readString(dictionary, \"data/female_names.txt\", 4000, 20);\n}\n\n\n// builds in-memory index with length filter for partitioning\n// fills index from existing collection\nvoid memBasicUsage1() {  \n  cout << \"----- MEM BASIC USAGE 1 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2); // using fixed-length grams\n  SimMetricEd simMetric(gramGen); // using the edit distance\n  //SimMetricJacc simMetric(gramGen); // using jaccard similarity\n  //SimMetricCos simMetric(gramGen); // using cosine similarity\n  //SimMetricDice simMetric(gramGen); // using dice similarity\n  \n  // create simple indexer with default template arguments\n  // default: in-memory index using Array<unsigned> as an inverted list container\n  // first create a string container and fill it with strings to index\n  StringContainerVector strContainer(true); // true indicates statistics gathering, e.g. for auto part filtering\n  strContainer.fillContainer(dictionary.begin(), dictionary.end()); // fill the container from a collection\n  FtIndexerMem<> indexer(&strContainer, &gramGen, 20, 10); // maxStrLen=20, fanout=10\n  indexer.addPartFilter(new LengthFilter(20)); // add length filtering with a maximum string length of 20\n  indexer.buildIndex();\n  \n  // create merger\n  DivideSkipMerger<> merger;\n  // create searcher passing merger and indexer with default template arguments\n  // default: same as indexer, i.e. assumed simple indexer with Array<unsigned> as inverted lists and DivideSkipMerger as merger type\n  FtSearcherMem<> searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f); // query string, similarity metric, similarity threshold\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerMem<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n\n  cout << \"----------------------\" << endl << endl;\n}\n\n// builds in-memory index with charsum filter for partitioning\n// fills index from data file\nvoid memBasicUsage2() {  \n  cout << \"----- MEM BASIC USAGE 2 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2); // using fixed-length grams\n  SimMetricEd simMetric(gramGen); // using the edit distance\n  \n  // create simple indexer with default template arguments\n  // default: in-memory index using Array<unsigned> as an inverted list container\n  // first create a string container and fill it with strings to index\n  StringContainerVector strContainer;\n  strContainer.fillContainer(\"data/female_names.txt\", 4000); // fill the container from a datafile and use the first 4000 lines\n  FtIndexerMem<> indexer(&strContainer, &gramGen, 20, 10); // maxStrLen=20, fanout=10\n  indexer.addPartFilter(new CharsumFilter(20)); // add charsum filtering with a maximum string length of 20\n  indexer.buildIndex();\n  \n  // create merger\n  DivideSkipMerger<> merger;\n  // create searcher passing merger and indexer with default template arguments\n  // default: same as indexer, i.e. assumed simple indexer with Array<unsigned> as inverted lists and DivideSkipMerger as merger type\n  FtSearcherMem<> searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerMem<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);\n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n\n  cout << \"----------------------\" << endl << endl;\n}\n\n// builds in-memory index with length filter for partitioning\n// fills index from data file\n// uses non-default list-merging algorithm, ScanCount\nvoid memBasicUsage3() {  \n  cout << \"----- MEM BASIC USAGE 3 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2); // using fixed-length grams\n  SimMetricJacc simMetric(gramGen); // using the jaccard distance (using set semantics)\n  \n  // create simple indexer with default template arguments\n  // default: in-memory index using Array<unsigned> as an inverted list container\n  // first create a string container and fill it with strings to index\n  StringContainerVector strContainer;\n  strContainer.fillContainer(\"data/female_names.txt\", 4000); // fill the container from a datafile and use the first 4000 lines\n  FtIndexerMem<> indexer(&strContainer, &gramGen, 20, 10); // maxStrLen=20, fanout=10\n  indexer.addPartFilter(new LengthFilter(20)); // add length filtering with a maximum string length of 50\n  indexer.buildIndex();\n  \n  // create merger\n  ScanCountMerger<> merger(4000);\n  // create searcher, specifying a non-default merger\n  FtSearcherMem<FtIndexerMem<>, ScanCountMerger<> > searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 0.7f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerMem<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n\n  cout << \"----------------------\" << endl << endl;\n}\n\n// builds in-memory index with length filter for partitioning\n// compresses index by discarding some inverted lists (based on impact tto given workload)\n// fills index from existing collection\n// other compressed indexers are:\n// FtIndexerDiscardListsLLF - discard long lists first\n// FtIndexerDiscardListsSLF - discard short lists first\n// FtIndexerDiscardListsRandom - randomly discard lists first\n// FtIndexerDiscardListsPanicCost - minimize number of panics\n// FtIndexerDiscardListsTimeCost - minimize total running time\n// FtIndexerCombineListsBasic - combine lists based on correlation\n// FtIndexerCombineListsCost - combine lists based on total running time\nvoid memDiscardLists() {\n  cout << \"----- MEM DISCARDLISTS ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2);\n  SimMetricEd simMetric(gramGen);\n  \n  // create index compressed with holes, using TimeCost as hole selection algorithm\n  // default template parameters: in-memory index using Array<unsigned> as an inverted list\n  StringContainerVector strContainer;\n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n  // params: string container, gram generator, compression ratio, training workload, training metric, training threshold, ratio cost, \n  //         data sampling fraction, queries sampling fraction, max sting length, fanout\n  FtIndexerDiscardListsTimeCost<> \n    indexer(&strContainer, &gramGen, 0.5f, &dictionary, &simMetric, 1.0f, false, 0.01f, 0.25f, 20, 10);\n  indexer.addPartFilter(new LengthFilter(20));\n  indexer.buildIndex();\n  \n  // create merger\n  DivideSkipMerger<> merger;\n  // create searcher passing merger and indexer\n  // must specify indexer type as template argument\n  FtSearcherMem<FtIndexerDiscardListsTimeCost<> > searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerDiscardListsTimeCost<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"----------------------------\" << endl << endl;;\n}\n\n// builds in-memory index with length filter for partitioning\n// compresses index by combining some inverted lists (based on impact tto given workload)\n// fills index from existing collection\n// other compressed indexers are:\n// FtIndexerDiscardListsLLF - discard long lists first\n// FtIndexerDiscardListsSLF - discard short lists first\n// FtIndexerDiscardListsRandom - randomly discard lists first\n// FtIndexerDiscardListsPanicCost - minimize number of panics\n// FtIndexerDiscardListsTimeCost - minimize total running time\n// FtIndexerCombineListsBasic - combine lists based on correlation\n// FtIndexerCombineListsCost - combine lists based on total running time\nvoid memCombineLists() {\n  cout << \"----- MEM COMPRESSION UNION ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2);\n  SimMetricEd simMetric(gramGen);\n  \n  // create index compressed with holes, using TimeCost as hole selection algorithm\n  // default template parameters: in-memory index using Array<unsigned> as an inverted list\n  StringContainerVector strContainer;\n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n  // params: string container, gram generator, compression ratio, training workload, training metric, training threshold,  \n  //         data sampling fraction, queries sampling fraction, max sting length, fanout\n  FtIndexerCombineListsCost<> \n    indexer(&strContainer, &gramGen, 0.5f, &dictionary, &simMetric, 1.0f, 0.01f, 1.0f, 20, 10);\n  indexer.addPartFilter(new LengthFilter(20));\n  indexer.buildIndex();\n  \n  // create merger\n  DivideSkipMerger<> merger;\n  // create searcher passing merger and indexer\n  // must specify indexer type as template argument\n  FtSearcherMem< FtIndexerCombineListsCost<> > searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerCombineListsCost<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"----------------------------\" << endl << endl;;\n}\n\n// builds in-memory index with length filter for partitioning\n// compresses index by discarding some inverted lists (based on impact tto given workload)\n// fills index from existing collection\n// uses non-default list-merging algorithm, ScanCount\n// explicitly specifies template parameters, and constructor arguments\nvoid memAdvancedUsage() {\n  cout << \"----- MEM ADVANCED USAGE ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2);\n  SimMetricEd simMetric(gramGen);\n  \n  // create index compressed with holes, using TimeCost as hole selection algorithm \n  // and specifiying the non-default string container and Array<unsigned> as inverted list\n  StringContainerRM strContainer;\n  strContainer.createContainer(\"tmpcollection.txt\");\n  strContainer.openContainer(\"tmpcollection.txt\");  \n  strContainer.fillContainer(dictionary.begin(), dictionary.end());\n  // params: string container, gram generator, compression ratio, training workload, training metric, training threshold, ratio cost, \n  //         data sampling fraction, queries sampling fraction, max sting length, fanout\n  FtIndexerDiscardListsTimeCost<StringContainerRM, Array<unsigned> > \n    indexer(&strContainer, &gramGen, 0.5f, &dictionary, &simMetric, 2.0f, false, 0.01f, 0.25f, 20, 10);\n  indexer.addPartFilter(new LengthFilter(20));\n  indexer.buildIndex();\n  \n  // create merger specifying inverted list type\n  ScanCountMerger<Array<unsigned> > merger(dictionary.size());\n  // create searcher passing merger and indexer\n  // specify all template arguments, need to specify merger if not default (DivideSkipMerger)\n  FtSearcherMem<FtIndexerDiscardListsTimeCost<StringContainerRM, Array<unsigned> >, ScanCountMerger<Array<unsigned> > > searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerDiscardListsTimeCost<StringContainerRM, Array<unsigned> > indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"-------------------------\" << endl << endl;\n}\n\n// builds disk-based index on disk-based string collection\n// uses length filter for partitioning, and default list-merging algorithm\n// fills index from existing collection\nvoid ondiskBasicUsage1() {\n  cout << \"----- ONDISK BASIC USAGE 1 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2);\n  SimMetricEd simMetric(gramGen);\n  \n  // using disk-based string container\n  StringContainerRM strContainer(PHO_AUTO);\n  strContainer.createAndOpen(\"collection.rm\");\n  strContainer.fillContainer(dictionary.begin(), dictionary.end()); // fill the container from dictionary\n  // params: container, gramgen, disableStreamBuffer, index filename, bytes per run, max str len, fanout\n  FtIndexerOnDisk<> indexer(&strContainer, &gramGen, false, \"invlists.ix\", 50000, 20, 10);\n  indexer.addPartFilter(new LengthFilter(20)); // param: max str len\n  indexer.buildIndex();\n  \n  // create merger specifying inverted list type\n  OnDiskMergerSimple<> merger;\n  // create searcher passing merger and indexer\n  FtSearcherOnDisk<> searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerOnDisk<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"-------------------------\" << endl << endl;\n}\n\n\n// builds disk-based index on disk-based string collection\n// uses length filter for partitioning\n// uses adaptive list-merging algorithm\n// fills index from existing collection\nvoid ondiskBasicUsage2() {\n  cout << \"----- ONDISK BASIC USAGE 2 ----\" << endl;\n\n  // create gramgenerator and similarity metric\n  GramGenFixedLen gramGen(2);\n  SimMetricEd simMetric(gramGen);\n  \n  // using disk-based string container\n  StringContainerRM strContainer(PHO_AUTO);\n  strContainer.createAndOpen(\"collection.rm\");\n  strContainer.fillContainer(\"data/female_names.txt\", 4000); // fill the container from a datafile and use the first 4000 lines\n  // params: container, gramgen, disableStreamBuffer, index filename, bytes per run, max str len, fanout\n  FtIndexerOnDisk<> indexer(&strContainer, &gramGen, false, \"invlists.ix\", 50000, 20, 10);\n  indexer.autoAddPartFilter(); // automatically choose a partitioning filter based on container stats\n  indexer.buildIndex();\n  \n  // create merger specifying inverted list type\n  OnDiskMergerAdapt<> merger;\n  // create searcher passing merger and indexer\n  FtSearcherOnDisk<FtIndexerOnDisk<>, OnDiskMergerAdapt<> > searcher(&merger, &indexer);\n  \n  vector<unsigned> resultStringIDs;\n  Query query(\"kathrin\", simMetric, 1.0f);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"SAVING INDEX\" << endl;\n  indexer.saveIndex(\"exampleindex.ix\");\n\n  cout << \"LOADING INDEX\" << endl;\n  FtIndexerOnDisk<> indexerLoaded(&strContainer);\n  indexerLoaded.loadIndex(\"exampleindex.ix\");\n  \n  resultStringIDs.clear();\n  searcher.setFtIndexer(&indexerLoaded);\n  searcher.search(query, resultStringIDs);  \n  cout << \"SIMILAR STRINGS: \" << endl;\n  for(unsigned i = 0; i < resultStringIDs.size(); i++) {\n    string tmp;\n    strContainer.retrieveString(tmp, resultStringIDs.at(i));\n    cout << tmp << endl;\n  }\n  \n  cout << \"-------------------------\" << endl << endl;\n}\n", "encoding": "ascii"}