{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/sepia/src/ppdtable/ppdentry.cc", "content": "/*\n  $Id: ppdentry.cc 4143 2008-12-08 23:23:55Z abehm $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/14/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"ppdentry.h\"\n\n#include <iomanip>\n#include <iterator>\n\nusing namespace std;\n\nPPDEntry::PPDEntry(SimVect v1, SimVect v2, SimType d, unsigned c, float f): \n  vect1(v1), vect2(v2), distM(d), countE(c), fract(f)\n{\n  if (distM > DIST_THRESHOLD) \n    distM = DIST_THRESHOLD;\n}\n\nbool PPDEntry::operator==(const PPDEntry &e) const \n{\n  if (this == &e)\n    return true;\n  if (vect1 == e.vect1 && \n      vect2 == e.vect2 && \n      distM == e.distM && \n      countE == e.countE && \n      fract == e.fract)\n    return true;\n  return false;\n}\n\nostream& operator<<(ostream &out, const PPDEntry &e)\n{\n  return out << e.vect1 << \"\\t\" << e.vect2 << \"\\t\"\n             << setw(5) << e.distM << \"\\t\"\n             << setw(5) << e.countE << \"\\t\" << e.fract;\n}\n\nistream& operator>>(istream &in, PPDEntry &e)\n{\n  return in >> e.vect1 >> e.vect2 >> e.distM >> e.countE >> e.fract;\n}\n\nbool operator<(const PPDEntry &left, const PPDEntry &right)\n{\n  if (&left == &right)\n    return false;\n  if (left.vect1 != right.vect1)\n    return left.vect1 < right.vect1;\n  if (left.vect2 != right.vect2)\n    return left.vect2 < right.vect2;\n  return left.distM < right.distM;\n}\n\nostream& operator<<(ostream &out, const ContPPDEntry &c)\n{\n  out << static_cast<unsigned>(c.size()) << endl << endl;\n  copy(c.begin(), c.end(), ostream_iterator<PPDEntry>(out, \"\\n\"));\n  return out;\n}\n\nistream& operator>>(istream &in, ContPPDEntry &c)\n{\n\tunsigned n;\n\tin >> n;\n\tfor (unsigned i = 0; i < n; i++) {\n\t\tPPDEntry e;\n\t\tin >> e;\n\t\tc.insert(e);\n\t}\n\treturn in;\n}\n\n#if SIM_DIST == 1 && SIM_VECT == 1\n\nvoid PPDEntry::serialize(ofstream &out) const\n{\n//   vect1.serialize(out);\n//   vect2.serialize(out);\n//   out.write(reinterpret_cast<const char*>(&distM), sizeof(SimType));\n\n  // < I, D, S > < I, D, S > D   in [0, 15]\n  // unsigned -  32bit\n\n  unsigned data = 0;\n  \n  data |= 0x0000000F & vect1.ins;\n  data |= 0x000000F0 & (vect1.del << 4);\n  data |= 0x00000F00 & (vect1.sub << 8);\n  data |= 0x0000F000 & (vect2.ins << 12);\n  data |= 0x000F0000 & (vect2.del << 16);\n  data |= 0x00F00000 & (vect2.sub << 20);\n  data |= 0x0F000000 & (distM << 24);\n\n  out.write(reinterpret_cast<const char*>(&data), sizeof(unsigned));\n  out.write(reinterpret_cast<const char*>(&countE), sizeof(unsigned));\n\n//   unsigned fractU = static_cast<unsigned>(fract * 10000);\n//   unsigned char buf[2];\n//   buf[0] = 0xFF & fractU;\n//   buf[1] = 0xFF & (fractU >> 8);\n//   out.write(reinterpret_cast<const char*>(&buf), sizeof(unsigned char) * 2);\n\n  out.write(reinterpret_cast<const char*>(&fract), sizeof(float));\n}\n\nvoid PPDEntry::deserialize(ifstream &in)\n{\n//   vect1.deserialize(in);\n//   vect2.deserialize(in);\n//   in.read(reinterpret_cast<char*>(&distM), sizeof(SimType));\n\n  unsigned data = 0;\n\n  in.read(reinterpret_cast<char*>(&data), sizeof(unsigned));\n\n  vect1.ins = data & 0x0000000F;\n  vect1.del = (data & 0x000000F0) >> 4;\n  vect1.sub = (data & 0x00000F00) >> 8;\n  vect2.ins = (data & 0x0000F000) >> 12;\n  vect2.del = (data & 0x000F0000) >> 16;\n  vect2.sub = (data & 0x00F00000) >> 20;\n  distM    = (data & 0x0F000000) >> 24;\n\n  in.read(reinterpret_cast<char*>(&countE), sizeof(unsigned));\n\n//   unsigned fractU = 0;\n//   unsigned char buf[2];\n//   in.read(reinterpret_cast<char*>(&buf), sizeof(unsigned char) * 2);\n//   fractU = (buf[1] << 8) | buf[0];\n//   fract = static_cast<float>(fractU) / 10000;\n\n  in.read(reinterpret_cast<char*>(&fract), sizeof(float));\n}\n\n#endif\n", "encoding": "ascii"}