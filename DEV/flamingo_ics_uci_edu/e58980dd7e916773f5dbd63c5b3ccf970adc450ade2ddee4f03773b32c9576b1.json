{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/util/src/gram.cc", "content": "/*\n  $Id: gram.cc 6132 2012-02-22 21:53:14Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license.\n\n  Date: 01/30/2007\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"gram.h\"\n\n#include <sys/stat.h>\n\n#include \"input.h\"\n#include \"misc.h\"\n\nhash<string> hashString;\n\nvoid str2grams(const string &s, vector<string> &res, unsigned q,\n               unsigned char st, unsigned char en)\n{\n  const string sPad = string(q - 1, st) + s + string(q - 1, en);\n  \n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res.push_back(sPad.substr(i, q));  \n}\n\nvoid str2grams(const string &s, vector<unsigned> &res, \n               unsigned q, unsigned char st, unsigned char en) \n{\n  string sPad = string(q - 1, st) + s + string(q - 1, en);\n  \n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res.push_back(hashString(sPad.substr(i, q)));\n}\n\nvoid str2grams(const string &s, multiset<string> &res, unsigned q, \n               unsigned char st, unsigned char en)\n{\n  const string sPad = string(q - 1, st) + s + string(q - 1, en);\n\n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res.insert(sPad.substr(i, q));  \n}\n\nvoid str2grams(const string &s, multiset<unsigned> &res, \n               unsigned q, unsigned char st, unsigned char en) \n{\n  string sPad = string(q - 1, st) + s + string(q - 1, en);\n  \n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res.insert(hashString(sPad.substr(i, q)));\n}\n\nvoid str2grams(const string &s, set<string> &res, unsigned q, \n               unsigned char st, unsigned char en)\n{\n  const string sPad = string(q - 1, st) + s + string(q - 1, en);\n\n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res.insert(sPad.substr(i, q));  \n}\n\nvoid str2grams(const string &s, set<unsigned> &res, \n               unsigned q, unsigned char st, unsigned char en) \n{\n  string sPad = string(q - 1, st) + s + string(q - 1, en);\n  \n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res.insert(hashString(sPad.substr(i, q)));\n}\n\nvoid str2grams(const string &s, map<unsigned, unsigned> &res, unsigned q, \n               unsigned char st, unsigned char en)\n{\n  const string sPad = string(q - 1, st) + s + string(q - 1, en);\n\n  for (unsigned i = 0; i < s.length() + q - 1; i++)\n    res[hashString(sPad.substr(i, q))]++;  \n}\n\nvoid str2gramsNoPrePost(const string &s, vector<unsigned> &res,  unsigned q) \n{\n  for (unsigned i = 0; i < s.length() - q + 1; i++) {\n    //ignore gram with space \n    string substring = s.substr(i, q);\n    string::size_type loc = substring.find(' ', 0);\n    if (loc == string::npos) \n      res.push_back(hashString(substring));\n  }//end for\n}\n\nvoid str2gramsNoPrePost(const string &s, set<string> &res, unsigned q)\n{\n  if (s.length() < q) {\n    cerr << \"string length (\" << s.length()\n         << \") less than q (\" << q << \")\" << endl;\n    exit(1);\n  }\n  \n  for (unsigned i = 0; i < s.length() - q + 1; i++)\n    res.insert(s.substr(i, q));  \n}\n\nvoid str2gramsNoPrePost(const string &s, set<unsigned> &res,  unsigned q) \n{\n  for (unsigned i = 0; i < s.length() - q + 1; i++) {\n    //ignore gram with space \n    string substring = s.substr(i, q);\n    string::size_type loc = substring.find(' ', 0);\n    if (loc == string::npos) \n      res.insert(hashString(substring));\n  }//end for\n}\n\n//Get special grams which contains in \"ch\" set\n//this function is used in synonym work\n\nvoid getSpecialGrams(const string &s, const unsigned q, const vector<char> ch,\n                     set<unsigned> &res) \n{\n  for (unsigned i = 0; i < s.length() - q + 1; i++) {\n    string substring = s.substr(i, q);\n    for(unsigned i=0;i<ch.size();i++) {\n      string::size_type loc = substring.find(ch.at(i), 0 );\n      if( loc != string::npos ) \n        res.insert(hashString(substring));\n    }//end for\n  }//end for\n}// getSpecialGrams\n\n//convert strings to inverted lists with id and position information\n//Please remember to release memory space in map in your own code!\n// If create grams without prefix and suffic, please set addStEn = false\nvoid createIdPosInvertedLists(const vector<string> data, bool addStEn,\n                              GramListMap &idLists, GramListMap &posLists,\n                              unsigned q,\n                              unsigned char st, unsigned char en)\n{\n  for(unsigned i=0;i<data.size();i++) {\n    vector<unsigned> gramCodes;\n    if (addStEn)\n      str2grams(data.at(i),gramCodes,q,st,en);\n    else\n      str2gramsNoPrePost(data.at(i),gramCodes,q);\n      \n    for(unsigned j=0;j<gramCodes.size();j++) {\n      unsigned gram = gramCodes.at(j);\n\t  \n      if (idLists.find(gram) == idLists.end()) {\n\t      // a new gram\n\t      Array<unsigned> *arrayGram = new Array<unsigned>();\n\t      arrayGram->append(i);\n\t      idLists[gram] = arrayGram;\n\t      \n\t      Array<unsigned> *arrayPos = new Array<unsigned>();\n\t      arrayPos->append(j);\n\t      posLists[gram] = arrayPos;\n\t    }//end if\n      else {\n\t      Array<unsigned> *arrayGram = idLists[gram];\n\t      arrayGram->append(i);\n\t      \n\t      Array<unsigned> *arrayPos = posLists[gram];\n\t      arrayPos->append(j);\n\t    }//end else\n    }//end for  \n  }//end for\n}//end  createIdPosInvertedLists\n\nvoid grams2str(const vector<string> &v, string &res, const unsigned q)\n{\n  res = \"\";\n  \n  for (unsigned i = 0; i < v.size() - q + 1; i++)\n    res += v[i].substr(q - 1, 1);\n}\n\nunsigned gram2id(const string &gram) \n{\n  unsigned\n    id = 0, \n    gramLen = gram.length();\n  string::size_type pos;\n  for (unsigned i = 0; i < gramLen; i++) {\n    pos = GramId::charsetEn.find(gram[i]);\n    if (pos == string::npos) {\n      cerr << \"can't find character '\" << gram[i] << \"'(\" \n           << static_cast<unsigned>(gram[i]) << \") of gram \\\"\" << gram\n           << \"\\\" in charset\" << endl;\n      exit(EXIT_FAILURE);\n    }\n    id += pow(GramId::charsetEn.size(), gramLen - i - 1) * pos;\n  }\n  return id;\n}\n\nvoid id2gram(unsigned id, string &res, const unsigned q)\n{\n  res = \"\";\n  while (id > 0) {\n    res = string(1, GramId::charsetEn[id % GramId::charsetEn.size()]) + res;\n    id = id / GramId::charsetEn.size();\n  }\n  while (res.length() < q)\n    res = string(1, GramId::charsetEn[0]) + res;\n}\n\n// GramId\nconst unsigned GramId::charsetLenMax = 500;\nconst string GramId::charsetEn = \n  \" !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~0123456789abcdefghijklmnopqrstuvwxyz\";\nconst string GramId::gramidSuffix = \".gid.bin\";\n\nGramId::GramId(unsigned q, char st, char en, \n               const string &charset, bool withPerm):\n  q(q),\n  st(st),\n  en(en),\n  charset(string(1, st) + charset + string(1, en)), \n  charsetLen(this->charset.size()), \n  n(pow(charsetLen, q)), \n  perm(vector<unsigned>(n))\n{\n  for (unsigned i = 0; i < n; i++)\n    perm[i] = i;\n  if (withPerm)\n    random_shuffle(perm.begin(), perm.end());\n  \n  \n}\n\nGramId::GramId(const string &filenamePrefix) \n{\n  loadData(filenamePrefix);\n}\n\nunsigned GramId::getId(const string &gram) const\n{\n  unsigned\n    id = 0, \n    gramLen = gram.length();\n  string::size_type pos;\n  for (unsigned i = 0; i < gramLen; i++) {\n    pos = charset.find(gram[i]);\n    if (pos == string::npos) {\n      cerr << \"can't find character '\" << gram[i] << \"'(\" \n           << static_cast<unsigned>(gram[i]) << \") of gram \\\"\" << gram\n           << \"\\\" in charset\" << endl;\n      exit(EXIT_FAILURE);\n    }\n    id += pow(charsetLen, gramLen - i - 1) * pos;\n  }\n  return id;\n}\n\nstring GramId::getGram(unsigned id) const\n{\n  string gram = \"\";\n  while (id > 0) {\n    gram = string(1, charset[id % charsetLen]) + gram;\n    id = id / charsetLen;\n  }\n  while (gram.length() < q)\n    gram = string(1, charset[0]) + gram;\n  return gram;\n}\n\nvoid GramId::getIds(const string &s, vector<unsigned> &ids) const\n{\n  vector<string> gs;\n  str2grams(s, gs, q);\n  for (vector<string>::const_iterator it = gs.begin(); it != gs.end(); it++)\n    ids.push_back(getId(*it));\n}\n\nvoid GramId::getGrams(const vector<unsigned> &ids, vector<string> &grams) const\n{\n  for (vector<unsigned>::const_iterator it = ids.begin(); it != ids.end(); it++)\n    grams.push_back(getGram(*it));\n}\n\nvoid GramId::saveData(const string &filenamePrefix) const\n{\n  string filename = filenamePrefix + gramidSuffix;\n\n  cerr << \"write to \\\"\" << filename << \"\\\"...\";\n  cerr.flush();\n\n  ofstream file(filename.c_str(), ios::out | ios::binary);\n  if (!file) {\n    cerr << \"can't open output file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file.write(reinterpret_cast<const char*>(&q), sizeof(unsigned));\n  if (file.fail()) writeerror(filename);\n\n  file.write(reinterpret_cast<const char*>(&st), sizeof(char));\n  if (file.fail()) writeerror(filename);\n\n  file.write(reinterpret_cast<const char*>(&en), sizeof(char));\n  if (file.fail()) writeerror(filename);\n\n  file.write(reinterpret_cast<const char*>(&charsetLen), sizeof(unsigned));\n  if (file.fail()) writeerror(filename);\n\n  for (unsigned i = 0; i < charsetLen; i++) {\n    file.write(reinterpret_cast<const char*>(&charset[i]), sizeof(char));\n    if (file.fail()) writeerror(filename);\n  }\n  \n  file.write(reinterpret_cast<const char*>(&n), sizeof(unsigned));\n  if (file.fail()) writeerror(filename);\n\n  for (vector<unsigned>::const_iterator it = perm.begin(); it != perm.end(); ++it)\n    file.write(reinterpret_cast<const char*>(&*it), sizeof(unsigned));\n\n  file.close();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid GramId::loadData(const string &filenamePerfix)\n{\n  string filename = filenamePerfix + gramidSuffix;\n \n  cerr << \"read from \\\"\" << filename << \"\\\"...\";\n  cerr.flush();\n\n  ifstream file(filename.c_str(), ios::in | ios::binary);\n  if (!file) {\n    cerr << \"can't open input file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  file.read(reinterpret_cast<char*>(&q), sizeof(unsigned));\n  if (file.fail()) writeerror(filename);\n\n  file.read(reinterpret_cast<char*>(&st), sizeof(char));\n  if (file.fail()) writeerror(filename);\n\n  file.read(reinterpret_cast<char*>(&en), sizeof(char));\n  if (file.fail()) writeerror(filename);\n\n  file.read(reinterpret_cast<char*>(&charsetLen), sizeof(unsigned));\n  if (file.fail()) writeerror(filename);\n\n  charset = \"\";\n  for (unsigned i = 0; i < charsetLen; i++) {\n    char ch;\n    file.read(reinterpret_cast<char*>(&ch), sizeof(char));\n    if (file.fail()) writeerror(filename);\n    charset += string(1, ch);\n  }\n  \n  file.read(reinterpret_cast<char*>(&n), sizeof(unsigned));\n  if (file.fail()) writeerror(filename);\n\n  for (unsigned i = 0; i < n; i++) {\n    unsigned e;\n    file.read(reinterpret_cast<char*>(&e), sizeof(unsigned));\n    perm.push_back(e);\n  }\n\n  file.close();\n\n  cerr << \"OK\" << endl;\n}\n\nunsigned GramId::invPerm(unsigned id) const\n{\n  for (unsigned i = 0; i < perm.size(); i++)\n    if (perm[i] == id)\n      return i;\n  cerr << \"ID \" << id << \" out of range in permutation\" << endl;\n  exit(EXIT_FAILURE);\n}\n\nbool GramId::consistData(const string &filenamePrefix, \n                         const string &filenameExt) const\n{\n  string filename = filenamePrefix + gramidSuffix;\n\n  struct stat attrib, attribExt;\n  if (stat(filename.c_str(), &attrib)) {\n    cerr << \"can't stat file \\\"\" << filename << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  if (stat(filenameExt.c_str(), &attribExt)) {\n    cerr << \"can't stat file \\\"\" << filenameExt << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  if (!(attribExt.st_mtime <= attrib.st_mtime))\n    return false;\n\n  return true;  \n}\n\nbool GramId::operator==(const GramId& g) const \n{\n  if (this == &g)\n    return true;\n  if (q == g.q && \n      st == g.st && \n      en == g.en && \n      charset == g.charset && \n      charsetLen == g.charsetLen && \n      n == g.n && \n      perm == g.perm)\n    return true;\n  return false;\n}\n\n// str2words\nvoid str2words(const string &s, vector<string> &res, const string &delims) \n{\n  string::size_type begIdx, endIdx;\n  \n  begIdx = s.find_first_not_of(delims);\n  \n  while (begIdx != string::npos) {\n    endIdx = s.find_first_of(delims, begIdx);\n    if (endIdx == string::npos)\n      endIdx = s.length();\n//     cout << begIdx << \" \" << endIdx << \" \" \n//          << s.substr(begIdx, endIdx - begIdx) << endl;\n    res.push_back(s.substr(begIdx, endIdx - begIdx));\n    begIdx = s.find_first_not_of(delims, endIdx);\n  }\n}\n\n// WordIndex\nvoid WordIndex::build(const vector<string> &data, WordHash &wordHash)\n{\n  cout << \"WordIndex::build...\"; cout.flush();\n  \n  vector<string> words;\n  for (unsigned i = 0; i < data.size(); i++) {\n\n    words.clear();\n    str2words(data[i], words);\n    for (vector<string>::const_iterator word = words.begin();\n         word != words.end(); ++word)\n      wordHash[*word].insert(i);\n  } \n\n  cout << \"OK\" << endl;\n}\n\nvoid WordIndex::build(const string &filenameDataset, WordHash &wordHash)\n{\n  cout << \"WordIndex::build...\"; cout.flush();\n\n  ifstream fileDataset(filenameDataset.c_str());\n  if (!fileDataset) {\n    cerr << \"can't open input file \\\"\" << filenameDataset << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  \n  vector<string> words;\n  unsigned i = 0;\n  const unsigned maxLineLen = 256;\n  char line[maxLineLen];\n\n  while (true) {\n    fileDataset.getline(line, maxLineLen);\n    if (fileDataset.eof())\n      break;\n    if (fileDataset.fail()) {\n      cerr << \"open reading input file \\\"\"\n           << filenameDataset << \"\\\"\" << endl\n           << \"line length might exceed \" << maxLineLen << \" characters\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    words.clear();\n    str2words(string(line), words);\n    for (vector<string>::const_iterator word = words.begin();\n         word != words.end(); ++word)\n      wordHash[*word].insert(i);\n\n    i++;\n  } \n\n  cout << \"OK\" << endl;\n}\n\nvoid WordIndex::build(const vector<string> &data,\n                      WordIds &wordIds, WordKey &wordKey)\n{\n  cout << \"WordIndex::build...\"; cout.flush();\n  \n  vector<string> words;\n  for (unsigned i = 0; i < data.size(); i++) {\n\n    words.clear();\n    str2words(data[i], words);\n    for (vector<string>::const_iterator word = words.begin();\n         word != words.end(); ++word) {\n\n      pair<WordKey::iterator, bool> wordIns = \n        wordKey.insert(make_pair(*word, 0));\n\n      unsigned wordPos;\n      if (wordIns.second) {\n        // word not in WordLevel\n        wordPos = wordIds.size();\n        wordIns.first->second = wordPos;\n        Ids ids;\n        ids.insert(i);\n        wordIds.push_back(make_pair(*word, ids));\n      }\n      else {\n        // word in WordLevel\n        wordPos = wordIns.first->second;\n        wordIds[wordPos].second.insert(i);\n      }            \n    }\n  } \n\n  cout << \"OK\" << endl;\n}\n\nvoid WordIndex::build(const string &filenameDataset,\n                      WordIds &wordIds, WordKey &wordKey)\n{\n  cout << \"WordIndex::build...\"; cout.flush();\n\n  ifstream fileDataset(filenameDataset.c_str());\n  if (!fileDataset) {\n    cerr << \"can't open input file \\\"\" << filenameDataset << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  \n  vector<string> words;\n  unsigned i = 0;\n  const unsigned maxLineLen = 256;\n  char line[maxLineLen];\n\n  while (true) {\n    fileDataset.getline(line, maxLineLen);\n    if (fileDataset.eof())\n      break;\n    if (fileDataset.fail()) {\n      cerr << \"open reading input file \\\"\"\n           << filenameDataset << \"\\\"\" << endl\n           << \"line length might exceed \" << maxLineLen << \" characters\" << endl;\n      exit(EXIT_FAILURE);\n    }\n\n    words.clear();\n    str2words(string(line), words);\n    for (vector<string>::const_iterator word = words.begin();\n         word != words.end(); ++word) {\n\n      pair<WordKey::iterator, bool> wordIns = \n        wordKey.insert(make_pair(*word, 0));\n\n      unsigned wordPos;\n      if (wordIns.second) {\n        // word not in WordLevel\n        wordPos = wordIds.size();\n        wordIns.first->second = wordPos;\n        Ids ids;\n        ids.insert(i);\n        wordIds.push_back(make_pair(*word, ids));\n      }\n      else {\n        // word in WordLevel\n        wordPos = wordIns.first->second;\n        wordIds[wordPos].second.insert(i);\n      }            \n    }\n\n    i++;\n  } \n\n  cout << \"OK\" << endl;\n}\n\nvoid WordIndex::build(const vector<string> &data,\n                      vector<string> &wordVect, vector<Ids> &idsVect, \n                      WordKey &wordPosMap) \n{\n  cout << \"WordIndex::build...\"; cout.flush();\n\n  vector<string> words;\n  unsigned pos;\n  \n  for (unsigned i = 0; i < data.size(); i++) {\n\n    words.clear();\n    str2words(data[i], words);\n    for (vector<string>::const_iterator word = words.begin();\n         word != words.end(); ++word) {\n\n      pair<WordKey::iterator, bool> ins = \n        wordPosMap.insert(make_pair(*word, 0));\n\n      if (ins.second) {\n        // word not in WordHash\n        pos = wordVect.size();\n        wordVect.push_back(*word);\n        Ids ids;\n        ids.insert(i);\n        idsVect.push_back(ids);\n        ins.first->second = pos;\n      }\n      else {\n        // word in WordHash\n        pos = ins.first->second;\n        idsVect[pos].insert(i);\n      } \n    }\n  }\n\n  cout << \"OK\" << endl;  \n}\n\nvoid WordIndex::save(const string &filenameWords, \n                     const string &filenameIds,\n                     const WordHash &wordHash) \n{\n  cerr << \"write to \\\"\" << filenameWords << \"\\\" and \\\"\"\n       << filenameIds << \"\\\"...\";\n\n  ofstream fileWords(filenameWords.c_str(), ios::out);  \n  if (!fileWords) {\n    cerr << \"can't open output file \\\"\" << filenameWords << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  ofstream fileIds(filenameIds.c_str(), ios::out | ios::binary);  \n  if (!fileIds) {\n    cerr << \"can't open output file \\\"\" << filenameIds << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  unsigned size;\n  for(WordHash::const_iterator it = wordHash.begin();\n      it != wordHash.end(); ++it) {\n    fileWords << it->first << endl;\n    \n    size = it->second.size();\n    fileIds.write(reinterpret_cast<const char*>(&size), sizeof(unsigned));\n    for (Ids::const_iterator jt = it->second.begin();\n         jt != it->second.end(); ++jt)\n      fileIds.write(reinterpret_cast<const char*>(&*jt), sizeof(unsigned));\n  }\n    \n  fileWords.close();\n  fileIds.close();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid WordIndex::load(const string &filenameWords, \n                     const string &filenameIds, \n                     WordHash &wordHash)\n{\n  cerr << \"read from \\\"\" << filenameWords << \"\\\" and \\\"\"\n       << filenameIds << \"\\\"...\";\n\n  ifstream fileWords(filenameWords.c_str(), ios::in);  \n  if (!fileWords) {\n    cerr << \"can't open input file \\\"\" << filenameWords << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  ifstream fileIds(filenameIds.c_str(), ios::in | ios::binary);  \n  if (!fileIds) {\n    cerr << \"can't open input file \\\"\" << filenameIds << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  unsigned size, id;\n  string word;\n  Ids ids;\n\n  while (true) {\n    // hash\n    fileWords >> word;\n    if (fileWords.eof())\n      break;\n\n    ids.clear();\n    fileIds.read(reinterpret_cast<char*>(&size), sizeof(unsigned));\n    for (unsigned i = 0; i < size; i++) {\n      fileIds.read(reinterpret_cast<char*>(&id), sizeof(unsigned));\n      ids.insert(id);\n    }\n    \n    wordHash[word] = ids;\n  }\n    \n  fileWords.close();\n  fileIds.close();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid WordIndex::save(const string &filenameWids, \n                     const string &filenameWkey,\n                     const WordIds &wordIds, const WordKey &wordKey)\n{\n  cerr << \"write to \\\"\" << filenameWids << \"\\\" and \\\"\"\n       << filenameWkey << \"\\\"...\";\n\n  ofstream fileWids(filenameWids.c_str(), ios::out | ios::binary);  \n  if (!fileWids) {\n    cerr << \"can't open output file \\\"\" << filenameWids << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  unsigned size;\n  for(WordIds::const_iterator it = wordIds.begin();\n      it != wordIds.end(); ++it) {\n    size = it->second.size();\n    fileWids.write(reinterpret_cast<const char*>(&size), sizeof(unsigned));\n    for (Ids::const_iterator jt = it->second.begin();\n         jt != it->second.end(); ++jt)\n      fileWids.write(reinterpret_cast<const char*>(&*jt), sizeof(unsigned));\n  }\n    \n  fileWids.close();\n\n  ofstream fileWkey(filenameWkey.c_str(), ios::out);  \n  if (!fileWkey) {\n    cerr << \"can't open output file \\\"\" << filenameWkey << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  for (WordIds::const_iterator it = wordIds.begin();\n       it != wordIds.end(); ++it)\n    fileWkey << it->first<< \" \" << wordKey.find(it->first)->second << endl;\n\n  fileWkey.close();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid WordIndex::load(const string &filenameWids, \n                     const string &filenameWkey, \n                     WordIds &wordIds, WordKey &wordKey)\n{\n  cerr << \"read from \\\"\" << filenameWids << \"\\\" and \\\"\"\n       << filenameWkey << \"\\\"...\";\n\n  ifstream fileWids(filenameWids.c_str(), ios::in | ios::binary);  \n  if (!fileWids) {\n    cerr << \"can't open input file \\\"\" << filenameWids << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  ifstream fileWkey(filenameWkey.c_str(), ios::in);  \n  if (!fileWkey) {\n    cerr << \"can't open input file \\\"\" << filenameWkey << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  string word;\n  unsigned size, id;\n  Ids ids;\n\n  while (true) {\n    fileWids.read(reinterpret_cast<char*>(&size), sizeof(unsigned));\n    if (fileWids.eof())\n      break;\n    ids.clear();\n    for (unsigned i = 0; i < size; i++) {\n      fileWids.read(reinterpret_cast<char*>(&id), sizeof(unsigned));\n      ids.insert(id);\n    }\n\n    fileWkey >> word >> id;\n    if (fileWkey.eof()) {\n      cerr << \"inconsistency in input file \\\"\" << filenameWkey << \"\\\"\" << endl;\n      exit(EXIT_FAILURE);\n    }\n    \n    wordIds.push_back(make_pair(word, ids));\n    wordKey[word] = id;\n  }\n\n  fileWids.close();  \n  fileWkey.close();\n\n  cerr << \"OK\" << endl;\n}\n\nbool WordIndex::exist(const string &filename1, const string &filename2) \n{\n  ifstream file1(filename1.c_str(), ios::in | ios::binary);  \n  if (!file1) \n    return false;\n  file1.close();\n\n  ifstream file2(filename2.c_str(), ios::in);  \n  if (!file2)\n    return false;\n  file2.close();\n  \n  return true;\n}\n\nconst string\nfilenameExtWordVect = \".wi.wv.txt\", \n                  filenameExtIdsVect = \".wi.idv.bin\";\n\n\nvoid WordIndex::save(const string &filename, const vector<string> &wordVect,\n                     const vector<Ids> &idsVect, const WordKey &wordPosMap) \n{\n  const string\n    filenameWordVect = filename + filenameExtWordVect, \n    filenameIdsVect = filename + filenameExtIdsVect;\n  \n  cerr << \"write to \\\"\" << filenameWordVect << \"\\\" and\" << endl\n       << \"         \\\"\" << filenameIdsVect  << \"\\\"...\";\n  cerr.flush();\n\n  ofstream fileWordVect(filenameWordVect.c_str(), ios::out);  \n  if (!fileWordVect) {\n    cerr << \"can't open output file \\\"\" << filenameWordVect << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  for (vector<string>::const_iterator word = wordVect.begin();\n       word != wordVect.end(); ++word)\n    fileWordVect << *word << endl;\n\n  fileWordVect.close();\n\n\n  ofstream fileIdsVect(filenameIdsVect.c_str(), ios::out | ios::binary);  \n  if (!fileIdsVect) {\n    cerr << \"can't open output file \\\"\" << filenameIdsVect << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  for (vector<Ids>::const_iterator ids = idsVect.begin();\n       ids != idsVect.end(); ++ids) {\n    unsigned size = ids->size();\n    fileIdsVect.write(reinterpret_cast<const char*>(&size), sizeof(unsigned));\n    for (Ids::const_iterator id = ids->begin();\n         id != ids->end(); ++id)\n      fileIdsVect.write(reinterpret_cast<const char*>(&*id), sizeof(unsigned));\n  }\n  \n  fileIdsVect.close();\n\n  cerr << \"OK\" << endl;\n}\n\nvoid WordIndex::load(const string &filename, vector<string> &wordVect,\n                     vector<Ids> &idsVect, WordKey &wordPosMap) \n{\n  const string\n    filenameWordVect = filename + filenameExtWordVect, \n    filenameIdsVect = filename + filenameExtIdsVect;\n  \n  cerr << \"read from \\\"\" << filenameWordVect << \"\\\" and\" << endl\n       << \"          \\\"\" << filenameIdsVect  << \"\\\"...\";\n  cerr.flush();\n\n  readString(wordVect, filenameWordVect);\n\n  ifstream fileIdsVect(filenameIdsVect.c_str(), ios::in | ios::binary);  \n  if (!fileIdsVect) {\n    cerr << \"can't open input file \\\"\" << filenameIdsVect << \"\\\"\" << endl;\n    exit(EXIT_FAILURE);\n  }\n  \n  for (unsigned i = 0; i < wordVect.size(); i++) {    \n    unsigned size;\n    fileIdsVect.read(reinterpret_cast<char*>(&size), sizeof(unsigned));\n\n    Ids ids;\n    unsigned el;\n    for (unsigned j = 0; j < size; j++) {\n      fileIdsVect.read(reinterpret_cast<char*>(&el), sizeof(unsigned));\n      ids.insert(el);\n    }\n    idsVect.push_back(ids);\n\n    wordPosMap[wordVect[i]] = i;\n  }\n  \n  fileIdsVect.close();\n\n  cerr << \"OK\" << endl;\n}\n", "encoding": "ascii"}