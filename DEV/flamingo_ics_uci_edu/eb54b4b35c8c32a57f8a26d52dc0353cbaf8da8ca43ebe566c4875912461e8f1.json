{"url": "http://flamingo.ics.uci.edu/releases/3.0/src/listmerger/heap.cc", "content": "/*\n  $Id: heap.cc 5149 2010-03-24 23:37:18Z abehm $\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license.\n  \n  Author: Jiaheng Lu\n  Date: 04/14/2007\n\n*/\n\n\n/*\n\nThis file provides all basic operations for heap.\n\n*/\n\n#include \"heap.h\"\n\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <functional>\n#include <iterator>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n\n/* Test if the node has\n   the right child in heap\n*/\n\n\nbool hasRightChildInHeap(unsigned nodeIndex, unsigned size){\n\n  if (nodeIndex*2+2 >= size)\n    return false;\n  else\n    return true;\n  \n\n}//end hasRightChildInHeap\n\n\nbool isLeafInHeap(unsigned nodeIndex, unsigned size){\n\n  if (nodeIndex*2+1 >= size)\n    return true;\n  else\n    return false;\n\n}//end isLeafInHeap\n\n/*\n  rebuild the heap\n  after the deletion\n*/\n\n\nvoid heapRebuild(unsigned data[], \n\t\t unsigned index[],\n                 unsigned root,\n                 unsigned size)\n\n{\n  if (! isLeafInHeap( root, size))//if the root is not a leaf \n    {\n      //root must have a left child\n      unsigned child = 2 * root + 1;\n\n      if  (hasRightChildInHeap(root, size))\n\t{\n\n          unsigned rightChild = child +1;\n          \n          if ( data[rightChild] < data[child])\n\t    child = rightChild ;\n\n\t}//end if\n   \n      if (  data[child] <  data[root]) \n\t{\n\n\t  // swap root and child\n\n\t  unsigned temp = data[root];\n\t  data[root] = data[child];\n\t  data[child] = temp;\n\n\t  temp = index[root];\n\t  index[root] = index[child];\n\t  index[child] = temp;\n\n\t  heapRebuild( data, index, child, size);\n\n\t}//end if\n          \n    }//end if \n\n  //else root is a leaf, so we are done.\n\n}//end heapRebuild \n\n\n\n\n/*  \n    Replace the current\n    head node to a new node.\n    The size of heap \n    is not changed.\n\n*/\n\nvoid heapReplaceHead(unsigned newData,\n\t\t     unsigned data[],\n\t\t     unsigned index[],\n\t\t     unsigned size)\n\n{\n\n  // replace the newItem as the top of the tree\n\n  data[0] = newData;\n\n  heapRebuild(data,index,0,size);\n\n}//end heapReplaceHead\n\n\n/*  Insert a node to heap;\n    First insert it to the end of heap;\n    Then  trickle new item up to appropriate spot\n\n*/\n\nvoid heapInsert(unsigned newData,\n                unsigned newIndex,\n                unsigned data[],\n                unsigned index[],\n                unsigned &size)\n\n{\n\n  // insert newItem into the bottom of the tree\n\n  data[size] = newData;\n  index[size] = newIndex;\n\n  // trickle new item up to appropriate spot in the tree\n\n  unsigned place = size;\n\n  unsigned parent = (place-1)/2;\n\n\n  \n  while ( (place >= 1) &&\n          data[place] < data[parent]  \n        )       \n    {\n      // swap place and parent \n\n      unsigned temp = data[parent];\n      data[parent] = data[place];\n      data[place] = temp;\n\n               \n      temp = index[parent];\n      index[parent] = index[place];\n      index[place] = temp;\n\n      place = parent;\n\n      parent = (place-1)/2;\n  \n    }//end while\n\n  ++size;\n \n\n}//end heapInsert\n\nvoid printHeap( unsigned heap[], unsigned size ){\n\n  for(unsigned i=0;i<size;i++)\n    cout<< \" \" << heap[i] ;\n\n  cout <<endl;\n\n}//end printHeap\n\n\nvoid heapDelete(unsigned data[],\n                unsigned index[],\n                unsigned &size )\n \n{\n \n  data[0] = data[size-1];\n  index[0] = index[size-1];\n\n  --size;\n\n  heapRebuild(data, index, 0, size );\n\n}//end heapDelete\n\n\nvoid  deleteMAXUnsignedfromEachList(const vector<Array<unsigned>*> &lists)\n{\n\t\n  for(unsigned k=0;k<unsigned(lists.size());k++)\n    { \n\t\t\n      Array<unsigned> *onelist = lists.at(k);\n      \n      onelist->removeLastElement();\n        \n    }//end for\n\t\n}//end deleteMAXUnsignedfromEachList\n\n\nvoid addMAXUnsigned2EachList(const vector<Array<unsigned>* > &lists,\n\t\t\t     unsigned MAXUnsigned){\n\t\n  for(unsigned k=0;k< (unsigned)lists.size();k++){ \n\t\n    Array<unsigned> *onelist = lists.at(k);\n\t \n    onelist->append(MAXUnsigned);\n        \n  }//end for\n\n}//end addMAXUnsigned2EachList\t\n\t\n        \t\nvoid makeInitialHeap(unsigned dataHeap[],\n\t\t     unsigned indexHeap[],\n\t\t     const vector< Array<unsigned>* > &lists)\n{\n  unsigned size = 0;\n\n  for(unsigned i=0;i< unsigned(lists.size());i++)\n    {\t\n      unsigned t = lists.at(i)->at(0);\t\n      heapInsert(t,i,dataHeap,indexHeap,size);\n\n    }//end for\n\t   \n}//end makeInitialHeap\n", "encoding": "ascii"}