{"url": "http://flamingo.ics.uci.edu/releases/2.0.1/src/sepia/cluster/medoids.cc", "content": "/*\n  $Id: medoids.cc 4096 2008-11-06 01:51:40Z rares $\n\n  Copyright (C) 2007 by The Regents of the University of California\n\n  Redistribution of this file is permitted under the terms of the \n  BSD license\n\n  Date: 01/14/2006\n  Author: Rares Vernica <rares (at) ics.uci.edu>\n*/\n\n#include \"medoids.h\"\n\n#include <cstdlib>\n\nMedoids::Medoids(const vector<string>* d, unsigned clusterNo, \n                 SampleType sampleType, unsigned samplePer,\n                 unsigned queueSize, unsigned uniqueNo, \n                 unsigned ver, unsigned sampleSizeMul,\n                 unsigned sampleSets, unsigned sampleSteps):\n  Clusters(d, clusterNo, sampleType, samplePer, queueSize, uniqueNo),\n  ver(ver), sampleSizeMul(sampleSizeMul), sampleSets(sampleSets),\n  sampleSteps(sampleSteps)\n{\n  for (unsigned i = 0; i < clusterNo; i++)\n    clusters->push_back(Cluster());\n\n  sampleSize = sampleSizeMul * clusterNo;\n  if (sampleSize > d->size()) \n    sampleSize = d->size();\n\n  time_t ltime;\n  time(&ltime);\n  srand(static_cast<unsigned int>(ltime));\n}\n\nvoid Medoids::buildClusters() \n{\n  cerr << \"cluster\"; cerr.flush();\n  \n  switch (ver) {\n  case 1:\n    buildClustersVer1();\n    break;\n  case 2:\n    buildClustersVer2();\n    break;\n  case 3:\n    buildClustersVer3();\n    break;\n  case 5:\n    buildClustersVer5();\n    break;\n  case 6:\n    buildClustersVer6();\n  case 7:\n    buildClustersVer7();\n    break;\n  } \n\n  cerr << \"OK\" << endl;\n}\n\nvoid Medoids::buildClustersVer1() \n{\n  const unsigned dataSize = static_cast<unsigned>(data->size());\n\n  unsigned *pivot = new unsigned[clusterNo];\n  unsigned *pivotFinal = new unsigned[clusterNo];\n  unsigned *sample = new unsigned[sampleSize];\n\n  set<unsigned>\n    *idSet = new set<unsigned>, \n    *dataSet = new set<unsigned>;\n\n  SimType minSumDist = 0;\n\n  for (unsigned l = 0; l < sampleSets; l++) {\n    cerr << '.'; cerr.flush();\n\n    // ---=== SAMPLE ===---\n    // select sample records\n    for (unsigned i = 0; i < dataSize; i++) dataSet->insert(i);\n    for (unsigned i = 0; i < sampleSize; i++) {\n      set<unsigned>::iterator it = dataSet->\n        lower_bound(rand() % static_cast<unsigned>(dataSet->size()));\n      unsigned id = *it;\n      sample[i] = id;\n      dataSet->erase(it);\n    }\n\n    for (unsigned k = 0; k < sampleSteps; k++){// ---=== BUILD ===---\n      // select random pivots\n      idSet->clear();\n      for (unsigned i = 0; idSet->size() < clusterNo;) { // BUILD (select pivots)\n        unsigned j = sample[rand()%sampleSize];\n        if (idSet->insert(j).second)\n          pivot[i++] = j;\n      }\n\t\t\n      // assign each sample element to a pivot (to a cluster) and\n      // compute the sum of dissimilarities  (sum of objective functions)\n      SimType sumDist = 0;\n      for (unsigned i = 0; i < sampleSize; i++) {\n        // find the best pivot\n        SimType minDist = 0;\n        for (unsigned j = 0; j < clusterNo; j++) {\n          SimType dist = SimDist((*data)[sample[i]], (*data)[pivot[j]]);\n          if (j == 0 || dist < minDist)\n            minDist = dist;\n        }\n        sumDist+=minDist;\n      }\n\n      if ((l == 0 && k == 0) || sumDist < minSumDist) {\n        minSumDist = sumDist;\n        unsigned *pivotExtra;\n        pivotExtra = pivotFinal; pivotFinal = pivot; pivot = pivotExtra;\n      }\n    }\n  }\n\n  delete dataSet;\n  delete idSet;\n  delete [] sample;\n\n  // set final pivots as pivots\n  for (unsigned i = 0; i < clusterNo; i++)\n    (*clusters)[i].setPivot(pivotFinal[i]);\n\n  delete [] pivotFinal;\n  delete [] pivot;\n\n  assignClusters();\n}\n\nvoid Medoids::buildClustersVer2() \n{\n  const unsigned dataSize = static_cast<unsigned>(data->size());\n\n  unsigned *pivot = new unsigned[clusterNo];\n  unsigned *pivotFinal = new unsigned[clusterNo];\n\n  set<unsigned> *idSet = new set<unsigned>;\n\n  SimType minSumDist = 0;\n  for (unsigned k = 0; k < sampleSteps; k++){\n    cerr << '.'; cerr.flush();\n\n    // ---=== BUILD ===---\n    // select random pivots\n    idSet->clear();\n    for (unsigned i = 0; idSet->size() < clusterNo;) { // BUILD (select pivots)\n      unsigned j = rand()%dataSize;\n      if (idSet->insert(j).second)\n        pivot[i++] = j;\n    }\n\t\n    // assign each sample element to a pivot (to a cluster) and\n    // compute the sum of dissimilarities  (sum of objective functions)\n    SimType sumDist = 0;\n    for (unsigned i = 0; i < dataSize; i++) {\n      // find the best pivot\n      SimType minDist = 0;\n      for (unsigned j = 0; j < clusterNo; j++) {\n        SimType dist = SimDist((*data)[i], (*data)[pivot[j]]);\n        if (j == 0 || dist < minDist)\n          minDist = dist;\n      }\n      sumDist+=minDist;\n    }\n\n    if (k == 0 || sumDist < minSumDist) {\n      minSumDist = sumDist;\n      unsigned *pivotExtra;\n      pivotExtra = pivotFinal; pivotFinal = pivot; pivot = pivotExtra;\n    }\n  }\n\n  delete idSet;\n\n  // set final pivots as pivots\n  for (unsigned i = 0; i < clusterNo; i++)\n    (*clusters)[i].setPivot(pivotFinal[i]);\n\n  delete [] pivotFinal;\n  delete [] pivot;\n\n  assignClusters();\n}\n\nvoid Medoids::buildClustersVer3() \n{\n  const unsigned dataSize = static_cast<unsigned>(data->size());\n\n  unsigned *pivot = new unsigned[clusterNo];\n  unsigned *pivotFinal = new unsigned[clusterNo];\n  unsigned *sample = new unsigned[sampleSize];\n\n  set<unsigned> *idSet = new set<unsigned>;\n\n  SimType minSumDist = 0;\n  for (unsigned k = 0; k < sampleSteps; k++){\n    cerr << '.'; cerr.flush();\n\n    // ---=== SAMPLE ===---\n    // select sample records\n    idSet->clear();\n\n    if (k != 0) { // we already have a set of pivotFinal\n      // add the set of pivotFinal to the sample\n      for (unsigned i = 0; i < clusterNo; i++) {\n        idSet->insert(pivotFinal[i]);\n        sample[i] = pivotFinal[i];\n      }\n    }\n\n    for (unsigned i = idSet->size(); idSet->size() < sampleSize;) { // 1st SAMPLE\n      unsigned j = rand()%dataSize;\n      if (idSet->insert(j).second)\n        sample[i++] = j;\n    }\n\n    // ---=== BUILD ===---\t\n    //     idSet->clear();\n    //     for (unsigned i = 0; i < sampleSize; i++) idSet->insert(sample[i]);\n\n    // first pivot\n    unsigned pivotId = 0;\n    SimType minSumDistPivot = 0;\n    for (set<unsigned>::iterator i = idSet->begin(); i != idSet->end(); i++) {\n      SimType sumDist = 0;\n      for (set<unsigned>::iterator j = idSet->begin(); j != idSet->end(); j++)\n        sumDist+=SimDist((*data)[*i], (*data)[*j]);\n      if (i == idSet->begin() || sumDist < minSumDistPivot) {\n        pivotId = *i;\n        minSumDistPivot = sumDist;\n      }\n    }\n    pivot[0] = pivotId; // we have the first\n    idSet->erase(pivotId);\n\n    // rest of the pivots\n    for (unsigned m = 1; m < clusterNo; m++) {\n      SimType maxSumCji = 0;\n      unsigned pivotId = 0; // the best unselected object - the new pivot\n\n      for (set<unsigned>::iterator i = idSet->begin(); i != idSet->end(); i++) {\n        SimType sumCji = 0;\n        for (set<unsigned>::iterator j = idSet->begin(); j != idSet->end(); j++) {\n          // compute Dj\n          SimType Dj = 0;\n          for (unsigned l = 0; l < m; l++) {\n            SimType dist = SimDist((*data)[*j], (*data)[pivot[l]]);\n            if (l == 0 || dist < Dj) {\n              Dj = dist;\n            }\n          }\n\n          // compute Cji\n          SimType dist = SimDist((*data)[*j], (*data)[*i]);\n          SimType Cji = Dj>dist?Dj-dist:0;\n\n          // add to total\n          sumCji+=Cji;\n        }\n\n        if (i == idSet->begin() || sumCji>maxSumCji) {\n          maxSumCji = sumCji;\n          pivotId = *i;\n        }\n      }\n\n      pivot[m] = pivotId;\n      idSet->erase(pivotId);\n    }\n\n    // assign each sample element to a pivot (to a cluster) and\n    // compute the sum of dissimilarities  (sum of objective functions)\n    SimType sumDist = 0;\n    for (unsigned i = 0; i < sampleSize; i++) {\n      // find the best pivot\n      SimType minDist = 0;\n      for (unsigned j = 0; j < clusterNo; j++) {\n        SimType dist = SimDist((*data)[sample[i]], (*data)[pivot[j]]);\n        if (j == 0 || dist < minDist)\n          minDist = dist;\n      }\n      sumDist+=minDist;\n    }\n\n    if (k == 0 || sumDist < minSumDist) {\n      minSumDist = sumDist;\n      unsigned *pivotExtra;\n      pivotExtra = pivotFinal; pivotFinal = pivot; pivot = pivotExtra;\n    }\n  }\n\n  delete idSet;\n  delete [] sample;\n\n  // set final pivots as pivots\n  for (unsigned i = 0; i < clusterNo; i++)\n    (*clusters)[i].setPivot(pivotFinal[i]);\n\n  delete [] pivotFinal;\n  delete [] pivot;\n\t\n  assignClusters();\t\n}\n\nvoid Medoids::buildClustersVer5() \n{ \n  const unsigned dataSize = data->size();\n  vector<unsigned> *pivots = new vector<unsigned>(clusterNo);\n  SimType sumMin = 0;\n  for (unsigned i = 0; i < dataSize; i++) {\n    SimType sumCrt = 0;\n    for (unsigned j = 0; j < dataSize; j++) {\n      if (i == j) continue;\n      sumCrt += SimDist((*data)[i], (*data)[j]);\n    }\n    if (i == 0 || sumCrt < sumMin) {\n      sumMin = sumCrt;\n      (*pivots)[0] = i;\n    }\n  }\n  cerr << '.'; cerr.flush();\n\n  vector<unsigned> *assigned = new vector<unsigned>();\n  assigned->reserve(dataSize);\n  vector<SimType> *distances = new vector<SimType>();\n  distances->reserve(dataSize);\n  for (unsigned i = 0; i < dataSize; i++) {\n    (*assigned)[i] = 0;\n    (*distances)[i] = SimDist((*data)[(*pivots)[0]], (*data)[i]);\n  }\n  cerr << '.'; cerr.flush();\n\n  for (unsigned i = 1; i < clusterNo; i++) {\n    SimType maxGain = 0;\n    for (unsigned j = 0; j < dataSize; j++) {\n      unsigned k;\n      for (k = 0; k < i && (*pivots)[k] != j; k++);\n      if (k != i) continue;\n\n      SimType crtGain = 0;\n      for (k = 0; k < dataSize; k++) {\n        SimType crtDist = SimDist((*data)[j], (*data)[k]);\n        if (crtDist < (*distances)[k]) crtGain += (*distances)[k] - crtDist;\n      }\n      if (crtGain > maxGain) {\n        maxGain = crtGain;\n        (*pivots)[i] = j;\n      }\n    }\n    for (unsigned j = 0; j < dataSize; j++) {\n      SimType newDist = SimDist((*data)[(*pivots)[i]], (*data)[j]);\n      if (newDist < (*distances)[j]) {\n        (*assigned)[j] = i;\n        (*distances)[j] = newDist;\n      }\n    }\n  }\n  cerr << '.'; cerr.flush();\n\n  for (unsigned i = 0; i < clusterNo; i++) \n    (*clusters)[i].setPivot((*pivots)[i]);\n  for (unsigned i = 0; i < dataSize; i++) {\n    unsigned clusterId = (*assigned)[i];\n    (*clusters)[clusterId].insert(i);\n    (*clusters)[clusterId].setRadius(max((*clusters)[clusterId].getRadius(),\n                                         (*distances)[i]));\n  }\n  delete distances;\n  delete assigned;\n  delete pivots;\n}\n\nvoid Medoids::buildClustersVer6() \n{\n  const unsigned dataSize = data->size();\n  set<unsigned> *pivots = new set<unsigned>();\n\n  time_t ltime;\n  time(&ltime);\n  srand(static_cast<unsigned>(ltime));\n\n  while (pivots->size() < clusterNo) pivots->insert(rand() % dataSize);\n  \n  unsigned i = 0;\n  for (set<unsigned>::iterator it = pivots->begin(); \n       it != pivots->end(); ++it) (*clusters)[i++].setPivot(*it);\n\n  delete pivots;\n\n  assignClusters();\n\n  for (unsigned i = 0; i < sampleSteps; i++) {\n    cerr << '.'; cerr.flush();\n    \n    bool changed = false;\n    for (VectClusterIt it = clusters->begin(); it != clusters->end(); ++it) \n      if (it->improve(*data)) changed = true;\n\n    if (changed) {\n      for (VectClusterIt it = clusters->begin(); \n           it != clusters->end(); ++it) it->clear();\n      assignClusters();\n    }\n    else break;\n  }\n}\n\nvoid Medoids::buildClustersVer7() \n{\n  const unsigned dataSize = data->size();\n\n  time_t ltime;\n  time(&ltime);\n  srand(static_cast<unsigned>(ltime));\n\n  Sample\n    samples = Sample(sampleSize, dataSize),\n    pivots = Sample(clusterNo, sampleSize);\n\n  unsigned i = 0;\n  for (vector<unsigned>::const_iterator it = pivots.begin(); \n       it != pivots.end(); ++it)\n    (*clusters)[i++].setPivot(samples[*it]);\n\n  assignClusters(samples.begin(), samples.end());\n\n  for (unsigned i = 0; i < sampleSteps; i++) {\n    cerr << '.'; cerr.flush();\n\n    bool changed = false;\n    for (VectClusterIt it = clusters->begin(); it != clusters->end(); ++it) \n      if (it->improve(*data)) changed = true;\n\n    if (changed) {\n      for (VectClusterIt it = clusters->begin(); \n           it != clusters->end(); ++it) it->clear();\n      assignClusters(samples.begin(), samples.end());\n    }\n    else break;\n  }\n\n  assignClustersMinus(samples.begin(), samples.end());\n}\n\nvoid Medoids::assignClusters() \n{\n  const unsigned dataSize = data->size();\n\n  cerr << '.'; cerr.flush();\n\n  // assign each data element to a pivot (to a cluster)\n  for (unsigned i = 0; i < dataSize; i++) {\n    SimType minDist = 0;\n    unsigned clusterI = 0;\n\t\t\n    // find the best pivot\n    for (unsigned j = 0; j < clusterNo; j++) {\n      if (i == (*clusters)[j].getPivot()) {\n        minDist = 0;\n        clusterI = j;\n        break;\n      }\n      SimType dist = SimDist((*data)[i], (*data)[(*clusters)[j].getPivot()]);\n      if (j == 0 || dist < minDist) {\n        minDist = dist;\n        clusterI = j;\n      }\t\n    }\n\n    (*clusters)[clusterI].insert(i);\n    (*clusters)[clusterI].setRadius(max((*clusters)[clusterI].getRadius(), \n                                        minDist));\n  }\n}\n\nvoid Medoids::assignClusters(vector<unsigned>::const_iterator begin, \n                             vector<unsigned>::const_iterator end)\n{\n  cerr << '.'; cerr.flush();\n\n  // assign each data element to a pivot (to a cluster)\n  for (vector<unsigned>::const_iterator i = begin; i != end; ++i) {\n    SimType minDist = 0;\n    unsigned clusterI = 0;\n\t\t\n    // find the best pivot\n    for (unsigned j = 0; j < clusterNo; j++) {\n      if (*i == (*clusters)[j].getPivot()) {\n        minDist = 0;\n        clusterI = j;\n        break;\n      }\n      SimType dist = SimDist((*data)[*i], (*data)[(*clusters)[j].getPivot()]);\n      if (j == 0 || dist < minDist) {\n        minDist = dist;\n        clusterI = j;\n      }\t\n    }\n\n    (*clusters)[clusterI].insert(*i);\n    (*clusters)[clusterI].setRadius(max((*clusters)[clusterI].getRadius(), \n                                        minDist));\n  }\n}\n\nvoid Medoids::assignClustersMinus(vector<unsigned>::const_iterator begin, \n                                  vector<unsigned>::const_iterator end)\n{\n  cerr << '.'; cerr.flush();\n\n  set<unsigned> samples = set<unsigned>(begin, end);\n\n  const unsigned dataSize = data->size();\n\n  // assign each data element to a pivot (to a cluster)\n  for (unsigned i = 0; i < dataSize; i++) {\n    if (samples.find(i) != samples.end()) continue;\n\n    SimType minDist = 0;\n    unsigned clusterI = 0;\n\t\t\n    // find the best pivot\n    for (unsigned j = 0; j < clusterNo; j++) {\n      if (i == (*clusters)[j].getPivot()) {\n        minDist = 0;\n        clusterI = j;\n        break;\n      }\n      SimType dist = SimDist((*data)[i], (*data)[(*clusters)[j].getPivot()]);\n      if (j == 0 || dist < minDist) {\n        minDist = dist;\n        clusterI = j;\n      }\t\n    }\n\n    (*clusters)[clusterI].insert(i);\n    (*clusters)[clusterI].setRadius(max((*clusters)[clusterI].getRadius(), \n                                        minDist));\n  }\n}\n\nostream& Medoids::info(ostream &out)\n{\n  Clusters::info(out);\n  out << \"Cluster method\\tMedoids \" << ver << endl;\n  out << \"sample size\\t\" << sampleSizeMul << endl;\n  out << \"sample sets\\t\" << sampleSets << endl;\n  out << \"sample steps\\t\" << sampleSteps << endl;\n  return out << endl;\n}\n\nostream& output(ostream &out, const unsigned* p, const unsigned k, \n                const vector<string> &d)\n{\n  for (unsigned i = 0; i < k; i++)\n    out << '[' << i << \"]\\t\" << p[i] << \"\\t(\" << d[p[i]] << ')' << endl;\n  return out;\n}\n\nostream& output(ostream &out, const Closest* c, const unsigned nK, \n                const unsigned* p, const unsigned* np) \n{\n  for (unsigned i = 0; i < nK; i++)\n    out << np[i] << \":\\t(\" << p[c[i].d] << ',' << p[c[i].e] << ')' << endl;\n  return out;\n}\n", "encoding": "ascii"}