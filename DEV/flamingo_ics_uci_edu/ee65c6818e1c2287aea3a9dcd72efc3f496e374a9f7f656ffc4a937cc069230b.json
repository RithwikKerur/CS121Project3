{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/common/src/gramgen.cc", "content": "/*\n  $Id: gramgen.h Tue Apr 05 10:20:24 PDT 2008 abehm$\n\n  Copyright (C) 2010 by The Regents of the University of California\n\t\n  Redistribution of this file is permitted under\n  the terms of the BSD license\n    \n  Date: 04/05/2008\n  Author: Rares Vernica <rares (at) ics.uci.edu> \n  Alexander Behm <abehm (at) ics.uci.edu>\n*/\n\n#include \"gramgen.h\"\n#include <iostream>\n\nusing namespace std;\nusing namespace tr1;\n\n#if _WIN32\nconst hash_win32 GramGen::hashString = hash_win32();\n#else\nconst hash<string> GramGen::hashString = hash<string>();\n#endif\n\nunsigned GramGenFixedLen::getPrePostStrLen(unsigned origStrLen) const {\n  if(prePost) return origStrLen;\n  else return origStrLen + 2 * q - 2;\n}\n\nGramGen* GramGen::loadGramGenInstance(ifstream& fpIn)\n{\n  GramGenType ggt = GGT_FIXED;\n  fpIn.read((char*)&ggt, sizeof(GramGenType));\n\n  switch(ggt) {\n  case GGT_FIXED: return new GramGenFixedLen(fpIn); break;\n  case GGT_WORDS: return new WordGen(fpIn); break;\n  default:\n    cout << \"ERROR: unknown gramgentype loaded from file!\" << endl;\n    return NULL; break;\n  }\n}\n\nGramGenFixedLen::GramGenFixedLen(ifstream& fpIn)\n{  \n  fpIn.read((char*)&q, sizeof(uint));\n  fpIn.read((char*)&noSpace, sizeof(bool));\n  fpIn.read((char*)&prePost, sizeof(bool));\n}\n\nbool GramGenFixedLen::containsSpace(string& s) const \n{\n  string::size_type loc = s.find(' ', 0);\n  return !(loc == string::npos);\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s, \n  vector<string> &res, \n  uchar st, \n  uchar en) \n  const \n{  \n  if(prePost) {\n    const string sPad = string(q - 1, st) + s + string(q - 1, en);  \n    for (uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))\n\tres.push_back(sPad.substr(i, q));        \n    }\n  }\n  else {\n    if(s.length() < q) {\n      res.push_back(s);\n      return;\n    }\n        \n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))\n        res.push_back(substring);\n    }\n  }\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s, \n  vector<uint> &res, \n  uchar st, \n  uchar en) \n  const\n{\n  if(prePost) {\n    string sPad = string(q - 1, st) + s + string(q - 1, en);  \n    for(uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))\n\tres.push_back(hashString(substring));\n    }\n  }\n  else {\n    if(s.length() < q) {\n      res.push_back(hashString(s));\n      return;\n    } \n    \n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))\n\tres.push_back(hashString(substring));\n    }      \n  }\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s,\n  multiset<string> &res,  \n  uchar st, \n  uchar en) \n  const \n{\n  if(prePost) {\n    const string sPad = string(q - 1, st) + s + string(q - 1, en);\n    for (uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))      \n\tres.insert(substring);  \n    }\n  }\n  else {      \n    if(s.length() < q) {\n      res.insert(s);\n      return;\n    }\n    \n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);      \n      if(!(noSpace && containsSpace(substring)))      \n\tres.insert(substring);  \n    }\n  }\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s, \n  multiset<uint> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  if(prePost) {\n    const string sPad = string(q - 1, st) + s + string(q - 1, en);  \n    for (uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))     \n\tres.insert(hashString(substring));      \n    }\n  }\n  else {\n    if(s.length() < q) {\n      res.insert(hashString(s));\n      return;\n    }\n\n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))           \n\tres.insert(hashString(substring));  \n    }\n  }\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s, \n  set<string> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  if(prePost) {\n    const string sPad = string(q - 1, st) + s + string(q - 1, en);\n    for (uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))     \n\tres.insert(substring);  \n    }\n  }\n  else {      \n    if(s.length() < q) {\n      res.insert(s);\n      return;\n    }\n\n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))           \n\tres.insert(substring);  \n    }\n  }\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s, \n  set<uint> &res, \n  uchar st, \n  uchar en) \n  const \n{\n if(prePost) {\n    const string sPad = string(q - 1, st) + s + string(q - 1, en);  \n    for (uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q); \n      if(!(noSpace && containsSpace(substring)))        \n\tres.insert(hashString(substring));\n    }\n  }\n  else {\n    if(s.length() < q) {\n      res.insert(hashString(s));\n      return;\n    }\n    \n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))    \n\tres.insert(hashString(substring));  \n    }\n  }\n}\n\nvoid GramGenFixedLen::decompose(\n  const string &s, \n  map<uint, uint> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  if(prePost) {\n    const string sPad = string(q - 1, st) + s + string(q - 1, en);\n    for (uint i = 0; i < s.length() + q - 1; i++) {\n      string substring = sPad.substr(i, q); \n      if(!(noSpace && containsSpace(substring)))    \n\tres[hashString(substring)]++;  \n    }\n  }\n  else {\n    if(s.length() < q) {\n      res[hashString(s)]++;  \n      return;\n    }\n\n    for (uint i = 0; i < s.length() - q + 1; i++) {\n      string substring = s.substr(i, q);\n      if(!(noSpace && containsSpace(substring)))    \n\tres[hashString(substring)]++;  \n    }\n  }\n}\n\nuint GramGenFixedLen::getNumGrams(const string& s) const \n{\n  if(prePost) return s.length() + q - 1;\n  else return (s.length() < q) ? s.length() : s.length() - q + 1;\n}\n\nvoid \nGramGenFixedLen::\ngetPrePostString(const std::string& src, std::string& dest, uchar st, uchar en) const {\n  if(prePost) dest = string(q - 1, st) + src + string(q - 1, en);  \n  else dest = src;\n}\n\nvoid GramGenFixedLen::saveGramGenInstance(ofstream& fpOut) \n{\n  fpOut.write((const char*)&gramGenType, sizeof(gramGenType));\n  fpOut.write((const char*)&q, sizeof(uint));\n  fpOut.write((const char*)&noSpace, sizeof(bool));\n  fpOut.write((const char*)&prePost, sizeof(bool));\n}\n\nvoid WordGen::decompose(\n  const string &s, \n  vector<string> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res.push_back(s.substr(lastPos, pos - lastPos));\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }  \n}\n\nvoid WordGen::decompose(\n  const string &s, \n  vector<uint> &res, \n  uchar st, \n  uchar en) \n  const\n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res.push_back(hashString(s.substr(lastPos, pos - lastPos)));\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }\n}\n\nvoid WordGen::decompose(\n  const string &s,\n  multiset<string> &res,  \n  uchar st, \n  uchar en) \n  const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res.insert(s.substr(lastPos, pos - lastPos));\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }  \n}\n\nvoid WordGen::decompose(\n  const string &s, \n  multiset<uint> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res.insert(hashString(s.substr(lastPos, pos - lastPos)));\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }  \n}\n\nvoid WordGen::decompose(\n  const string &s, \n  set<string> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res.insert(s.substr(lastPos, pos - lastPos));\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }\n}\n\nvoid WordGen::decompose(\n  const string &s, \n  set<uint> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res.insert(hashString(s.substr(lastPos, pos - lastPos)));\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }\n}\n\nvoid WordGen::decompose(\n  const string &s, \n  map<uint, uint> &res, \n  uchar st, \n  uchar en) \n  const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  \n  while (string::npos != pos || string::npos != lastPos) {\n    // Found a token, add it to the vector.\n    res[hashString(s.substr(lastPos, pos - lastPos))]++;\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  }\n}\n\nuint WordGen::getNumGrams(const string& s) const \n{\n  // Skip delimiter at beginning.\n  string::size_type lastPos = s.find_first_not_of(delimiter, 0);\n  // Find first \"non-delimiter\".\n  string::size_type pos = s.find_first_of(delimiter, lastPos);\n  unsigned count = 0;\n\n  while (string::npos != pos || string::npos != lastPos) {\n    count++;\n    // Skip delimiter.  Note the \"not_of\"\n    lastPos = s.find_first_not_of(delimiter, pos);\n    // Find next \"non-delimiter\"\n    pos = s.find_first_of(delimiter, lastPos);\n  } \n  \n  return count;\n}\n\nunsigned \nWordGen::getPrePostStrLen(unsigned origStrLen) const {\n  return origStrLen;\n}\n\nvoid \nWordGen::\ngetPrePostString(const std::string& src, std::string& dest, uchar st, uchar en) const {\n  dest = src;\n}\n\nWordGen::WordGen(ifstream& fpIn)\n{\n  unsigned len;  \n  fpIn.read((char*)&len, sizeof(uint));\n  char s[len];\n  fpIn.read(s, len);\n  delimiter.assign(s, len);\n  fpIn.read((char*)&gramGenType, sizeof(GramGenType));\n  fpIn.read((char*)&prePost, sizeof(bool));  \n}\n\nvoid WordGen::saveGramGenInstance(ofstream& fpOut) \n{\n  uint len = delimiter.length();\n  fpOut.write((const char*)&len, sizeof(uint));\n  fpOut.write((const char*)delimiter.c_str(), len);\n  fpOut.write((const char*)&gramGenType, sizeof(GramGenType));\n  fpOut.write((const char*)&prePost, sizeof(bool));\n}\n", "encoding": "ascii"}