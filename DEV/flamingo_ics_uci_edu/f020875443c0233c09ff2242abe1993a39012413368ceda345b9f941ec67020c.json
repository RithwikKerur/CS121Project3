{"url": "http://flamingo.ics.uci.edu/releases/4.0/src/lbaktree/src/example.cc", "content": "/*\n $Id: example.cc 5798 2010-10-23 02:33:38Z abehm $\n \n Copyright (C) 2010 by The Regents of the University of California\n \n Redistribution of this file is permitted under\n the terms of the BSD license.\n \n Date: 08/19/2010\n Author: Sattam Alsubaiee <salsubai (at) ics.uci.edu>\n*/\n\n#include <string>\n#include <fstream>\n#include <iostream>\n#include \"lbaktree.h\"\n\nbool sortCondition(const string &a, const string &b)\n{\n    return a.size() > b.size();\n}\n\nbool parseLine(string &line, Rectangle &mbr, vector<string> &kwds)\n{\n\tstring coordinates = line.substr(0, line.find(\",\"));\n\tstring keywords = line.substr(line.find(\",\") + 1, line.length());\n\tistringstream coordinatesStream(coordinates);\n\tistringstream keywordsStream(keywords);\n\tstring keyword;\n\twhile(keywordsStream >> keyword)\n\t{\n\t\ttransform(keyword.begin(), keyword.end(), keyword.begin(), ::tolower);\n\t\tkwds.push_back(keyword);\n\t}\n\tfloat coord;\n\tvector<float> coords;\n\twhile(coordinatesStream >> coord)\n\t{\n\t\tcoords.push_back(coord);\n\t}\n\tif(coords.size() == 2)\n\t{\n\t\tmbr.min.x = coords[0];\n\t\tmbr.min.y = coords[1];\n\t\tmbr.max.x = mbr.min.x;\n\t\tmbr.max.y = mbr.min.y;\n\t}\n\telse \n\t{\n\t\tmbr.min.x = coords[0];\n\t\tmbr.min.y = coords[1];\n\t\tmbr.max.x = coords[2];\n\t\tmbr.max.y = coords[3];\n\t}\n\tif(kwds.empty())\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid printResults(LBAKTree &lbaktree, vector<Object> &objects)\n{\n\tfor(unsigned i = 0; i < objects.size(); ++i)\n\t{\n\t\tcout << objects[i].id;\n\t\tvector<string> objectKeywords;\n\t\tlbaktree.getObjectKeywords(objects[i].id, objectKeywords);\n\t\tfor(unsigned j = 0; j < objectKeywords.size(); ++j)\n\t\t{\n\t\t\tcout << \", \" << objectKeywords[j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(int argc, char **argv)\n{\t\t\n\tstring datasetFile = \"../data/data.txt\";\n\tstring queryWorkloadFile = \"../data/queries.txt\";\n\t\n\t// this is an enum, can be \"fl\", \"vl\", or \"vlf\"\n\tAlgorithmType algoType = vlf;\n\t\n\t// space budget in bytes for the approximate indexes, this parameter is only for \"vl\" and \"vlf\" algorithms\n\tdouble spaceBudget = 500000000.0;\n\n\t// can be between 0 and 1\n\tfloat similarityThreshold = 0.8f;\n\t\n\t// can be between 0 and 1\n\tdouble keywordFrequencyThreshold = 1.0; \n\t\n\t// the approximate indexes level on the tree, this parameter is only for the \"fl\" algorithm\n\t//unsigned indexesLevel = 1; \n\t\n\tStorage st;\n\t\n\t// for the FL (fixed level) algorithm\n\t//LBAKTree lbaktree(&st, algoType, indexesLevel, similarityThreshold); \n\t\n\t// for the VL (variable level) algorithm\n\t//LBAKTree lbaktree(&st, queryWorkloadFile, algoType, spaceBudget, similarityThreshold); \n\t\n\t// for the VLF (variable level exploiting keyword-frequencies) algorithm\n\tLBAKTree lbaktree(&st, queryWorkloadFile, algoType, spaceBudget, similarityThreshold, keywordFrequencyThreshold); \n\t\n\tifstream data(datasetFile.c_str());\n\tif (!data)\n\t{\n\t\tcerr << \"cannot open dataset file\" << endl;\n\t\treturn -1;\n\t}\n\tifstream queries(queryWorkloadFile.c_str());\n\tif (!queries)\n\t{\n\t\tcerr << \"cannot open query workload file\" << endl;\n\t\treturn -1;\n\t}\n\n    string line;\n    unsigned count = 0;\n\tstruct timeval t1, t2;\n\tstruct timezone tz;\n\t\n\t// inserting the objects in the LBAK-tree\n\twhile (getline(data, line))\n\t{\t\n\t\tRectangle mbr;\n\t\tObject obj;\n\t\tvector<string> kwds;\n\t\tif(parseLine(line, mbr, kwds))\n\t\t{\n\t\t\tobj.mbr = mbr;\n\t\t\tobj.id = count;\n\t\t\tlbaktree.insert(obj, kwds);\n\t\t}\n\t\tif ((count % 1000) == 0)\n\t\t\tcerr << count << endl;\n\t\t++count;\n\t}\n\tcout << \"building the index structures\" << endl;\n    lbaktree.buildIndex();\n\tcout << \"starting the queries\" << endl;\n\t\n    unsigned numOfQueries = 0, answer = 0;\n    double totalTime = 0.0;\n\t\n\twhile (getline(queries, line))\n\t{\n\t\tvector<Object> objects;\n\t\tRectangle range;\n\t\tvector<string> kwds;\n\t\tparseLine(line, range, kwds);\n\t\t\n\t\tsort(kwds.begin(), kwds.end(), sortCondition);\n\t\tlbaktree.startTimeMeasurement(t1, tz);        \n\t\tlbaktree.rangeQuery(objects, range, kwds);\n\t\tlbaktree.stopTimeMeasurement(t2, tz);\n\t\tdouble timeMeasurement = lbaktree.getTimeMeasurement(t1, t2);\n\t\ttotalTime += timeMeasurement;\n\t\t\n\t\tprintResults(lbaktree, objects);\n\t\tanswer += objects.size();\n\t\t++numOfQueries;\n\t\t\n\t\tif ((count % 1000) == 0)\n\t\t\tcerr << count << endl;\n\t\t\n\t\t++count;\n\t}\n\tcout << \"AVG query time (ms): \" << totalTime / numOfQueries << endl;\n\tcout << \"Total queries answer: \" << answer << endl;\n    \n    return 0;\n}\n\n\n", "encoding": "ascii"}