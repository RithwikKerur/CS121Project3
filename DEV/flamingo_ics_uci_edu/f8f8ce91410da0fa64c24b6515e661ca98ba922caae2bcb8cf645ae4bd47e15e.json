{"url": "http://flamingo.ics.uci.edu/releases/4.1/src/lbaktree/src/rstartree/rstartree.cc", "content": "/*\n $Id: rstartree.cc 6148 2012-02-22 23:13:40Z salsubaiee $\n\n Copyright (C) 2010 by The Regents of the University of California\n\n Redistribution of this file is permitted under\n the terms of the BSD license.\n\n Date: 11/01/2009\n Author: Sattam Alsubaiee <salsubai (at) ics.uci.edu>\n*/\n\n#include \"rstartree.h\"\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <limits>\n#include <cmath>\n\n\nusing namespace std;\nusing namespace tr1;\nRTree::RTree(Storage *storage)\n{\n    this->storage = storage;\n    nodeSize = sizeof(Node);\n    nodeNum = 0;\n}\n\nvoid RTree::create()\n{\n    Node *root = (Node *)storage->alloc(nodeSize);\n    storage->setRoot(root->id);\n    root->level = 0;\n    root->numChildren = 0;\n\n    root->mbr.min.x = 0.0; // testing\n    root->mbr.min.y = 0.0; // testing\n    root->mbr.max = root->mbr.min; // testing\n\n    storage->write(root);\n    storage->free(root);\n    nodeNum = 1;\n}\n\nvoid RTree::rangeQuery(vector<Object> &objects, const Rectangle &range,\n                       uintptr_t id)\n{\n    Node *node = (Node *)storage->read(id);\n    unsigned i;\n    for(i = 0; i < node->numChildren; i++)\n        if(node->objects[i].mbr.intersects(range))\n        {\n            if(node->isLeaf())\n                objects.push_back(node->objects[i]);\n            else\n                rangeQuery(objects, range, node->objects[i].id);\n        }\n    storage->free(node);\n}\n\nvoid RTree::rangeQuery(vector<Object> &objects, const Rectangle &range)\n{\n    objects.clear();\n    uintptr_t id = storage->getRoot();\n    rangeQuery(objects, range, id);\n}\n\nvoid RTree::kNNQuery(multimap<double, Object> &objects,\n                     const Point &point, unsigned k)\n{\n    objects.clear();\n    vector<NodeMinDist2> heap;\n    NodeMinDist2 nroot;\n    nroot.id = storage->getRoot();\n    nroot.minDist2 = 0.0;\n    heap.push_back(nroot);\n\n    while(!heap.empty() && (objects.size() < k\n                            || heap[0].minDist2 < -objects.begin()->first))\n    {\n        uintptr_t id = heap[0].id;\n        pop_heap(heap.begin(), heap.end());\n        heap.pop_back();\n        Node *node = (Node *)storage->read(id);\n        unsigned i;\n        for(i = 0; i < node->numChildren; i++)\n            if(node->isLeaf())\n            {\n                double minDist2 = node->objects[i].mbr.minDist2(point);\n                if(objects.size() < k || minDist2 < -objects.begin()->first)\n                {\n                    objects.insert(pair<double, Object>\n                                   (-minDist2, node->objects[i]));\n                    if(objects.size() > k)\n                        objects.erase(objects.begin());\n                }\n            }\n            else\n            {\n                NodeMinDist2 nnode;\n                nnode.id = node->objects[i].id;\n                nnode.minDist2 = node->objects[i].mbr.minDist2(point);\n                heap.push_back(nnode);\n                push_heap(heap.begin(), heap.end());\n            }\n        storage->free(node);\n    }\n}\n\nvoid RTree::insert(const Object &obj)\n{\n    uintptr_t id = storage->getRoot();\n    Node *node = (Node *)storage->read(id);\n    byte* overflowArray = 0;\n    overflowArray = new byte[node->level];\n    memset(overflowArray, 0, node->level);\n    insert(obj, 0, overflowArray);\n    storage->free(node);\n    delete[] overflowArray;\n}\n\nvoid RTree::insert(const Object &obj, unsigned desiredLevel,\n                   byte *overflowArray)\n{\n    stack<Node *> path;\n    stack<unsigned> childPosition;\n    uintptr_t id = storage->getRoot();\n    Node *node = (Node *)storage->read(id);\n    path.push(node);\n    childPosition.push(0);\n\n    unsigned minChild = 0;\n    double minArea, minEnlarge;\n    while(node->level > desiredLevel)\n    {\n        minChild = 0;\n        minArea = std::numeric_limits<double>::max();\n        minEnlarge = std::numeric_limits<double>::max();\n\n        // the children pointers in the node point to leaves\n        if(node->level == 1)\n        {\n            // find least overlap enlargment, use minimum enlarged\n            // area to break tie, if tie still exists use minimum area\n            // to break it\n            vector <EntryValue> entries;\n            unsigned k;\n            for(unsigned i = 0; i < node->numChildren; ++i)\n            {\n                EntryValue entry;\n                entry.object = node->objects[i];\n                entry.value = node->objects[i].mbr.enlargedArea(obj.mbr);\n                entries.push_back(entry);\n\n                if(entry.value < minEnlarge)\n                {\n                    minEnlarge = entry.value;\n                    minChild = i;\n                }\n            }\n\n            if (minEnlarge != 0.0)\n            {\n                minEnlarge = std::numeric_limits<double>::max();\n                if(node->numChildren > NEAR_MINIMUM_OVERLAP_FACTOR)\n                {\n                    // sort the entries based on their area enlargment needed\n                    // to include the object\n                    sort(entries.begin(), entries.end());\n                    k = NEAR_MINIMUM_OVERLAP_FACTOR;\n                }\n                else\n                {\n                    k = node->numChildren;\n                }\n\n                double minOverlap = std::numeric_limits<double>::max();\n                unsigned id = 0;\n                for(unsigned i = 0; i < k; ++i)\n                {\n                    Rectangle mbr1 = entries.at(i).object.mbr;\n                    Rectangle mbr2 = entries.at(i).object.mbr;\n                    mbr2.enlarge(obj.mbr);\n                    double difference = 0.0;\n\n                    for(unsigned j = 0; j < node->numChildren; ++j)\n                    {\n                        if(node->objects[j].id != entries.at(i).object.id)\n                        {\n                            double intersection =\n                                mbr2.overlapedArea(node->objects[j].mbr);\n                            if(intersection != 0.0)\n                            {\n                                difference += intersection -\n                                              mbr1.overlapedArea(node->objects[j].mbr);\n                            }\n                        }\n                        else\n                        {\n                            id = j;\n                        }\n                    }\n                    double enlarge =\n                        entries.at(i).object.mbr.enlargedArea(obj.mbr);\n                    double area = entries.at(i).object.mbr.area();\n\n                    if(difference < minOverlap ||\n                            (difference == minOverlap && enlarge < minEnlarge) ||\n                            (difference == minOverlap && enlarge == minEnlarge &&\n                             area < minArea))\n                    {\n                        minOverlap = difference;\n                        minEnlarge = enlarge;\n                        minArea = area;\n                        minChild = id;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // find minimum enlarged area, use minimum area to break tie\n            for(unsigned i = 0; i < node->numChildren; ++i)\n            {\n                double enlarge = node->objects[i].mbr.enlargedArea(obj.mbr);\n                double area = node->objects[i].mbr.area();\n                if(enlarge < minEnlarge ||\n                        (enlarge == minEnlarge && area < minArea))\n                {\n                    minEnlarge = enlarge;\n                    minArea = area;\n                    minChild = i;\n                }\n            }\n        }\n        // enlarge the node and write if needed\n        if(minEnlarge > 0.0)\n        {\n            node->objects[minChild].mbr.enlarge(obj.mbr);\n            node->mbr.enlarge(obj.mbr); // testing\n            storage->write(node);\n        }\n\n        // move on to the next level\n        id = node->objects[minChild].id;\n        node = (Node *)storage->read(id);\n        path.push(node);\n        childPosition.push(minChild);\n    }\n\n    // add object to leaf and write\n    node->objects[node->numChildren++] = obj;\n    node->mbr.enlarge(obj.mbr); // testing\n    storage->write(node);\n\n    // overflow treatment\n    while(!path.empty())\n    {\n        node = path.top();\n        minChild = childPosition.top();\n        id = node->id;\n        path.pop();\n        childPosition.pop();\n        if(node->numChildren == BRANCH_FACTOR)\n        {\n            // if the level is not the root level and this is the\n            // first overflow treatment in the given level during the\n            // insertion of one data rectangle\n            if(!path.empty() && overflowArray[node->level] == 0)\n            {\n                overflowArray[node->level] = 1;\n                reinsert(node, path.top(), desiredLevel, minChild,\n                         overflowArray);\n            }\n            else\n            {\n                Object a, b;\n                split(node, a, b);\n                if(path.empty())\n                {\n                    // create new root\n                    Node *root = (Node *)storage->alloc(nodeSize);\n                    storage->setRoot(root->id);\n                    root->level = node->level + 1;\n                    root->numChildren = 2;\n                    root->objects[0] = a;\n                    root->objects[1] = b;\n\n                    root->mbr = a.mbr; // testing\n                    root->mbr.enlarge(b.mbr); // testing\n\n                    storage->write(root);\n                    storage->free(root);\n                    ++nodeNum;\n                }\n                else\n                {\n                    // insert into parent level\n                    Node *node2 = (Node *)path.top();\n                    unsigned i;\n                    for(i = 0; i < node2->numChildren; ++i)\n                        if(node2->objects[i].id == id)\n                        {\n                            node2->objects[i] = a;\n                            break;\n                        }\n                    node2->objects[node2->numChildren++] = b;\n                    storage->write(node2);\n                }\n            }\n        }\n        storage->free(node);\n    }\n}\n\nvoid RTree::reinsert(Node *node, Node *parentNode, unsigned desiredLevel,\n                     unsigned position, byte *overflowArray)\n{\n    Point p, center;\n    center.x = 0.5 * (parentNode->objects[position].mbr.min.x +\n                      parentNode->objects[position].mbr.max.x);\n    center.y = 0.5 * (parentNode->objects[position].mbr.min.y +\n                      parentNode->objects[position].mbr.max.y);\n\n    vector <CenterDistance> dist; // MBR centers distances\n\n    // compute the distance between the center of the node's MBR and\n    // all its children MBRs centers\n    for(unsigned i = 0; i < node->numChildren; ++i)\n    {\n        p.x = 0.5 * (node->objects[i].mbr.max.x + node->objects[i].mbr.min.x) -\n              center.x;\n        p.y = 0.5 * (node->objects[i].mbr.max.y + node->objects[i].mbr.max.y) -\n              center.y;\n\n        CenterDistance child;\n        child.object.id = node->objects[i].id;\n        child.object.mbr = node->objects[i].mbr;\n        child.distance = (p.x * p.x) + (p.y * p.y);\n        dist.push_back(child);\n    }\n\n    // sort the entries in decreasing order of their distances\n    sort(dist.begin(), dist.end());\n\n    // delete top (BRANCH_FACTOR * REINSERT_FACTOR) entries from the\n    // node\n    unsigned i;\n    unsigned k = std::floor((double)BRANCH_FACTOR * REINSERT_FACTOR);\n    for(i = 0; i < k; ++i)\n    {\n        deleteObject(node, dist[i].object.id);\n    }\n\n    // reset the node's MBR\n    parentNode->objects[position].mbr = dist[i].object.mbr;\n\n    node->mbr = dist[i].object.mbr; // testing\n\n    ++i;\n    // rebuild the node's MBR\n    for(; i < BRANCH_FACTOR; ++i)\n    {\n        parentNode->objects[position].mbr.enlarge(dist[i].object.mbr);\n\n        node->mbr.enlarge(dist[i].object.mbr); // testing\n    }\n    storage->write(node);\n    storage->write(parentNode);\n\n    // reinsert the top (REINSERT_FACTOR * BRANCH_FACTOR) entries\n    for(unsigned j = 0; j < k; ++j)\n    {\n        insert(dist[j].object, node->level, overflowArray);\n    }\n}\n\nvoid RTree::deleteObject(Node *node, uintptr_t id)\n{\n    for(unsigned i = 0; i < node->numChildren; ++i)\n    {\n        // to delete an object, place the last object in the deleted\n        // slot and reduce numChildren by 1\n        if(node->objects[i].id == id)\n        {\n            node->objects[i] = node->objects[node->numChildren - 1];\n            break;\n        }\n    }\n    node->numChildren--;\n}\n\nvoid RTree::split(Node *node, Object &a, Object &b)\n{\n    // calculations are based on the R*-tree paper\n    unsigned m = std::floor((double)BRANCH_FACTOR * SPLIT_FACTOR);\n    unsigned splitDistribution = (BRANCH_FACTOR - 1) - (2 * m) + 2;\n\n    // to calculate the minimum margin in order to pick the split axis\n    double minMargin = std::numeric_limits<double>::max();\n\n    // to calculate the margin, overlap area, and the area of the\n    // distributions\n    Rectangle lowerMbr1, upperMbr1, lowerMbr2, upperMbr2;\n\n    // to calculate the minimum values of the overlaped area and the\n    // area of the distributions\n    double lowerOverlap = 0.0, upperOverlap = 0.0;\n    double lowerArea = 0.0, upperArea = 0.0;\n    double minLowerOverlap[2];\n    double minUpperOverlap[2];\n    double minLowerArea[2];\n    double minUpperArea[2];\n\n    // to store the partition index that separate between the two\n    // groups\n    unsigned lowerPartitionIndex[2];\n    unsigned upperPartitionIndex[2];\n\n    // to determine which values are chosen (lower or upper values)\n    unsigned sortOrder = 0;\n\n    // to store the sorted entries\n    vector <vector <EntryValue> > lowerValues;\n    vector <vector <EntryValue> > upperValues;\n\n    // choose split axis\n    unsigned splitAxis = std::numeric_limits<unsigned>::max();\n    for(unsigned dim = 0; dim < 2; ++dim)\n    {\n        // fill the vectors with the entries lower and upper values of\n        // their rectangles\n        vector <EntryValue> temp1, temp2;\n        for(unsigned i = 0; i < node->numChildren; ++i)\n        {\n            EntryValue entry;\n            entry.object.id = node->objects[i].id;\n            entry.object.mbr = node->objects[i].mbr;\n\n            if(dim == 0)\n                entry.value = node->objects[i].mbr.min.x;\n            else\n                entry.value = node->objects[i].mbr.min.y;\n            temp1.push_back(entry);\n\n            if(dim == 0)\n                entry.value = node->objects[i].mbr.max.x;\n            else\n                entry.value = node->objects[i].mbr.max.y;\n            temp2.push_back(entry);\n        }\n        lowerValues.push_back(temp1);\n        upperValues.push_back(temp2);\n\n        // sort the values\n        sort(lowerValues.at(dim).begin(), lowerValues.at(dim).end());\n        sort(upperValues.at(dim).begin(), upperValues.at(dim).end());\n\n        // initialization\n        minLowerOverlap[dim] = std::numeric_limits<double>::max();\n        minUpperOverlap[dim] = std::numeric_limits<double>::max();\n        minLowerArea[dim] = std::numeric_limits<double>::max();\n        minUpperArea[dim] = std::numeric_limits<double>::max();\n        double lowerMargin = 0.0, upperMargin = 0.0;\n\n        // generate (BRANCH_FACTOR - 1) - (2 * m) + 2 distribution for all the\n        // BRANCH_FACTOR objects\n        for(unsigned k = 1; k < splitDistribution; ++k)\n        {\n            unsigned d = m - 1 + k;\n\n            lowerMbr1 = lowerValues.at(dim).at(0).object.mbr;\n            upperMbr1 = upperValues.at(dim).at(0).object.mbr;\n\n            for(unsigned j = 1; j < d; ++j)\n            {\n                lowerMbr1.enlarge(lowerValues.at(dim).at(j).object.mbr);\n                upperMbr1.enlarge(upperValues.at(dim).at(j).object.mbr);\n            }\n\n            lowerMbr2 = lowerValues.at(dim).at(d).object.mbr;\n            upperMbr2 = upperValues.at(dim).at(d).object.mbr;\n\n            for(unsigned j = d + 1; j < BRANCH_FACTOR; ++j)\n            {\n                lowerMbr2.enlarge(lowerValues.at(dim).at(j).object.mbr);\n                upperMbr2.enlarge(upperValues.at(dim).at(j).object.mbr);\n            }\n\n            // calculate the margin of the distributions\n            lowerMargin += lowerMbr1.margin() + lowerMbr2.margin();\n            upperMargin += upperMbr1.margin() + upperMbr2.margin();\n\n            // calculate the overlaped area of the distributions\n            lowerOverlap = lowerMbr1.overlapedArea(lowerMbr2);\n            upperOverlap = upperMbr1.overlapedArea(upperMbr2);\n\n            // calculate the area of the distributions\n            lowerArea = lowerMbr1.area() + lowerMbr2.area();\n            upperArea = upperMbr1.area() + upperMbr2.area();\n\n            if(lowerOverlap < minLowerOverlap[dim] ||\n                    (lowerOverlap == minLowerOverlap[dim] && lowerArea <\n                     minLowerArea[dim]))\n            {\n                minLowerOverlap[dim] = lowerOverlap;\n                minLowerArea[dim] = lowerArea;\n                lowerPartitionIndex[dim] = d;\n            }\n            if(upperOverlap < minUpperOverlap[dim] ||\n                    (upperOverlap == minUpperOverlap[dim] && upperArea <\n                     minUpperArea[dim]))\n            {\n                minUpperOverlap[dim] = upperOverlap;\n                minUpperArea[dim] = upperArea;\n                upperPartitionIndex[dim] = d;\n            }\n        }\n\n        double margin = ::min(lowerMargin, upperMargin);\n\n        // store minimum margin as split axis\n        if (margin < minMargin)\n        {\n            minMargin = margin;\n            splitAxis = dim;\n            sortOrder = (lowerMargin < upperMargin) ? 0 : 1;\n        }\n    }\n\n    // setup bid for children a and b\n    a.id = node->id;\n    Node *node2 = (Node *)storage->alloc(nodeSize);\n    node2->level = node->level;\n    node2->numChildren = 0;\n    b.id = node2->id;\n    ++nodeNum;\n\n    if(sortOrder == 0) // lower values\n    {\n        adjustNode(node, node2, a, b, lowerValues.at(splitAxis),\n                   lowerPartitionIndex[splitAxis]);\n    }\n    else // upper values\n    {\n        adjustNode(node, node2, a, b, upperValues.at(splitAxis),\n                   upperPartitionIndex[splitAxis]);\n    }\n\n    node->mbr = a.mbr; // testing\n    node2->mbr = b.mbr; // testing\n\n    // write\n    storage->write(node);\n    storage->write(node2);\n    storage->free(node2);\n}\n\nvoid RTree::adjustNode(Node *node, Node *node2, Object &a, Object &b,\n                       vector <EntryValue> &entries, unsigned partitionIndex)\n{\n    // setup mbr for objects a and b\n    a.mbr = entries.at(0).object.mbr;\n    node->objects[0] = entries.at(0).object;\n    node->numChildren = 1;\n    for(unsigned i = 1; i < partitionIndex; ++i)\n    {\n        a.mbr.enlarge(entries.at(i).object.mbr);\n        node->objects[node->numChildren++] = entries.at(i).object;\n    }\n\n    b.mbr = entries.at(partitionIndex).object.mbr;\n    node2->objects[0] = entries.at(partitionIndex).object;\n    node2->numChildren = 1;\n    for(unsigned i = partitionIndex + 1; i < entries.size(); ++i)\n    {\n        b.mbr.enlarge(entries.at(i).object.mbr);\n        node2->objects[node2->numChildren++] = entries.at(i).object;\n    }\n}\n\nbool RTree::retrieve(unordered_set<uintptr_t> &ids, uintptr_t oid, uintptr_t id)\n{\n    Node *node = (Node *)storage->read(id);\n    unsigned i;\n    bool ret = false;\n    for(i = 0; i < node->numChildren; i++)\n        if(node->isLeaf())\n        {\n            if(ids.count(node->objects[i].id))\n                fprintf(stderr, \"retrieve panic!\\n\");\n            else\n            {\n                ids.insert(node->objects[i].id);\n                if(oid == node->objects[i].id)\n                {\n                    ret = true;\n                    printf(\"path[%u] %f %f %f %f\\n\", node->level,\n                           node->objects[i].mbr.min.x,\n                           node->objects[i].mbr.max.x,\n                           node->objects[i].mbr.min.y,\n                           node->objects[i].mbr.max.y);\n                }\n            }\n\n        }\n        else\n        {\n            if(retrieve(ids, oid, node->objects[i].id))\n            {\n                ret = true;\n                printf(\"path[%u] %f %f %f %f\\n\", node->level,\n                       node->objects[i].mbr.min.x,\n                       node->objects[i].mbr.max.x,\n                       node->objects[i].mbr.min.y,\n                       node->objects[i].mbr.max.y);\n            }\n        }\n    storage->free(node);\n    return ret;\n}\n\nvoid RTree::retrieve(unordered_set<uintptr_t> &ids, uintptr_t oid)\n{\n    retrieve(ids, oid, storage->getRoot());\n}\n\n", "encoding": "ascii"}