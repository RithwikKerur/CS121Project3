{"url": "https://grape.ics.uci.edu/wiki/public/wiki/cs221-2019-spring-project3?version=19&format=txt", "content": "\r\n= CS221: Project 3 - PI: Positional index, phrase search, compression =\r\n'''Test Cases Due:     Week 6 Fri. (May 10), Due on Github as Pull Requests'''[[BR]]\r\n'''Review Due:           Week 7 Mon. (May 13),  Due on Github as Pull Requests Comments'''[[BR]]\r\n'''Final Code Due:     Week 8, Wed. (May 22),  Due on Github.'''[[BR]]\r\n\r\n\r\n== Coding Tasks ==\r\n1. Implement LSM-like Positional Index (insertion and merge). (6 points)\r\n1. Implement Phrase Search. (3 points)\r\n1. Implement Compression. (6 points)\r\n\r\n== Testing Tasks ==\r\n1. Write at least 2 test cases for a task (2 points)\r\n1. Review the test cases of two teams (2 points)\r\n\r\nTotal: 19 points \r\n\r\n== Overview ==\r\n\r\nIn this project, you'll be implementing a disk-based positional index and phrase search operations. Compared to the inverted index in Project 2, a positional index stores the positions of all the occurrences of a keyword in a document.  In addition, you'll compress both the inverted index and the positional index.\r\n\r\nThe positional index supports phrase search, which means searching a sequence of keywords in the exact order. For example, the query \"new york\" will only match documents with \"new\" immediately followed by \"york\". A document like \"new ... other tokens ... york\" won't match.\r\n\r\nThe \"position\" of a word in the positional index can have different meanings. It could be either a character position or a token position. Token positions can include or exclude stop words. Different kinds of \"position\" definitions also have different implications on phrase search. For example, for the document \"University of California, Irvine\", if we search the phrase \"University California\", the handling of the stop word \"of\" can affect the search result.\r\n\r\nIn this project, we store '''token''' positions in the positional index. In particular, we use tokens generated from the analyzer.  If the analyzer removes stop words, then stop words are also excluded from the positional index. For example, the token positions of \"cat and dog\" are \"{cat: 1}, {dog: 2}\".\r\n\r\n\r\n== Task 1: Implement an LSM-based positional index. ==\r\n\r\nThe on-disk index structure of the positional index is similar to the LSM structure in Project 2. The behavior for `addDocument()`, `flush()`, and `merge()` operations should be the same as Project 2. You should continue using the `InvertedIndexManager` class from Project 2. \r\n\r\nThe index format of the positional index should be on top of the inverted index format in Project 2. Recall in Project 2, we have 3 files per segment: docStore, dictionary, and invertedLists. The dictionary stores the pointer from a token to the inverted list of the token. In this project, we need another \"positional\" file to store the list of positions of a token in a document. The invertedLists needs to store an additional pointer to its position list per documentID.\r\n\r\nYou need to implement the following functions newly added to `InvertedIndexManager`\r\n\r\n{{{\r\n\r\n/**\r\n * Creates a positional index with a given folder, analyzer, and compressor.\r\n * Compressor must be used to compress the inverted lists and position lists.\r\n *\r\n */\r\npublic static InvertedIndexManager createOrOpenPositional(String indexFolder, Analyzer analyzer, Compressor compressor);\r\n\r\n/**\r\n * Reads a disk segment of a positional index into memory based on segmentNum.\r\n * This function is mainly used for checking correctness in test cases.\r\n *\r\n * Throws UnsupportedOperationException if the inverted index is not a positional index.\r\n *\r\n * @param segmentNum n-th segment in the inverted index (start from 0).\r\n * @return in-memory data structure with all contents in the index segment, null if segmentNum don't exist.\r\n */\r\npublic PositionalIndexSegmentForTest getIndexSegmentPositional(int segmentNum);\r\n\r\n\r\n/**\r\n * An in-memory representation of a positional index segment, used *only* for testing purposes.\r\n * Only for this testing class, you could load everything into memory.\r\n */\r\npublic class PositionalIndexSegmentForTest {\r\n\r\n    private final Map<String, List<Integer>> invertedLists;\r\n    private final Map<Integer, Document> documents;\r\n    private final Table<String, Integer, List<Integer>> positions;\r\n\r\n}\r\n\r\n}}}\r\n\r\nThe positional index should support ALL operations from the inverted index in Project 2 (`searchQuery(), searchAndQuery(), searchOrQuery(), documentIterator(), getIndexSegment()`). When doing these operations, you could ignore the positional part of the index. We would run all project 2 test cases with your positional index and they should still pass.\r\n\r\nWhen designing and implementing this task, you may find limitations of your Project 2 implementation. It is recommended to take this chance to fix those problems to make the development of Project 3 easier.\r\n\r\n== Task 2: Implement phrase search. ==\r\n\r\nIn this task, you'll implement phrase search using the positional index. You should make same assumptions about IO and tokenization as in project 2.\r\n\r\nThe keywords in the list variable `phrase` represents a consecutive sequence of keywords.  A document is a result only if it matches the sequence in its exact order.\r\n\r\nImplement the following function:\r\n\r\n{{{\r\n/**\r\n * Performs a phrase search on a positional index.\r\n * Phrase search means the document must contain the consecutive sequence of keywords in the exact order.\r\n *\r\n * You could assume that the analyzer won't convert each keyword into multiple tokens.\r\n * Throws UnsupportedOperationException if the inverted index is not a positional index.\r\n *\r\n * @param phrase, a consecutive sequence of keywords\r\n * @return a iterator of documents matching the query\r\n */\r\npublic Iterator<Document> searchPhraseQuery(List<String> phrase);\r\n\r\n}}}\r\n\r\n\r\n== Task 3: Implement compression. ==\r\n\r\nIn this task, you'll implement a compressor based on delta encoding and variable-length encoding. Implement the `encode` and `decode` functions for `DeltaVarLenCompressor`.\r\n\r\nDelta encoding means storing the difference (delta) between adjacent integers rather than the actual numbers. For example, given a list `[3, 5, 8, 13, 20]`, the delta encoding stores `[3, 2, 3, 5, 7]`. \r\n\r\nVariable-length encoding of an integer works similarly to UTF-8. We use a variable number of bytes instead of a constant number (4) of bytes to represent an integer. Specifically, in each byte, the first bit indicates if there are more bytes to read - `1` means reading the next byte and `0` means termination, and the rest 7 bits are used to encode the integer value. \r\n\r\nFor example, the integer value `13` is encoded as `00001101`. The first bit `0` means no more bytes to read, and the rest 7 bits `0001101` represent the number 13. The integer value `128` (`2^7`) is encoded as `10000001 00000000`. The first bit in the first byte indicates the inclusion of the next byte. The integer value `16,384` (`2^14`) is encoded as `10000001 10000000 00000000`.\r\n\r\n{{{\r\n/**\r\n * Encodes a list of integers to a byte array.\r\n */\r\nbyte[] encode(List<Integer> integers);\r\n\r\n/**\r\n * Decodes part of a byte array to a list of integers.\r\n *\r\n * @param bytes bytes to decode\r\n * @param startOffset starting position to decode\r\n * @param length number of bytes to decode from start position\r\n */\r\nList<Integer> decode(byte[] bytes, int startOffset, int length);\r\n}}}\r\n\r\nThe compressor should be used to compress the inverted lists and the positional lists. The compressor interface has a reference implementation `NaiveCompressor`, which does normal integer encoding without any compression. In test cases, two positional indexes will be constructed with `NaiveCompressor` and `DeltaVarLenCompressor` and the read/write counters will be compared to determine the compression ratio.\r\n\r\n\r\n== Test cases ==\r\nPlease follow the similar general guideline and procedure as in Project 1 and 2. Here are the [https://docs.google.com/spreadsheets/d/1_iwJOT-bnYDk9tWNNy61GCyi1kRN7s3VHdn5h_2T1DA/edit#gid=303113227 test case assignments].\r\n\r\nGuidelines for p3:\r\n- Put all test cases in the package `edu.uci.ics.cs221.index.positional` with the naming convention in the spreadsheet.\r\n- The grade will be also based the quality of the test cases.\r\n\r\nDetail description of test cases:\r\n- Task1: Flush Positional Segments / Task1: Merge Positional Segments. Test the correctness of positional index flushing and merging operations using `getNumSegments` and `getIndexSegmentPositional`. Verify the content of the positional index is correct.\r\n- Task2: Phrase Search. Construct various phrase search queries and check the result the query is correct.\r\n- Task3: Compressor Correctness. Test the correctness of `encode` and `decode` functions of the `DeltaVarLenCompressor`. Verify the result byte array matches delta encoding and variable length encoding. Don't test the compressor with invalid inputs.\r\n- Task3: Compare Index with Compression. Test the effect of the compressor to the positional index. Build the positional index using the no compression `NaiveCompressor` using non-trivial amount of data and record the IO counter values. Then Build the positional index using same data with `DeltaVarLenCompressor`. Compare the IO counter values to verify the compression ratio.\r\n- Overall: Large Data Stress Test. Test the positional index with a large amount of data. Using same dataset with project 2 stress test is prohibited.\r\n\r\n\r\n", "encoding": "ascii"}