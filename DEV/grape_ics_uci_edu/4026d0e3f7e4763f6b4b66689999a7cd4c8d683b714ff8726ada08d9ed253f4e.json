{"url": "https://grape.ics.uci.edu/wiki/public/wiki/cs222-2017-fall-project2-description?version=2&format=txt", "content": "{{{\r\n#!div style=\"background-color:rgb(237,222,222)\"\r\n\r\n= Introduction = \r\nIn this project, you will continue implementing the record-based file manager (RBFM). Once you have finished implementing that, you will build a relation manager (RM) on top of the basic paged file system. The RM manager should meet the following basic requirements. \r\n\r\n= Basic Requirements (100 points) =\r\n\r\n\r\n== Finish RBFM ==\r\nYou need to finish the implementation of the record-based file manager (RBFM) that you have started in part 1. Specifically, you should finish implementing the following methods: '''RecordBasedFileManager::deleteRecord()''', '''RecordBasedFileManager::updateRecord()''', '''RecordBasedFileManager::readAttribute()''', and '''RecordBasedFileManager::scan()'''. Please refer to [wiki:cs222-2017-fall-project1-description Project 1 Description] for their explanations and look at the file '''rbfm.h''' for the signature of those methods. Once you finish the implementation of those methods and test them well, you will use those methods to implement the relation manager (please have a look at the file '''rm.h''').\r\n\r\n== Implement the Relation Manager ==\r\n\r\nThe !RelationManager class is responsible for managing the database tables. It handles the creation and deletion of tables. It also handles the basic operations performed on top of a table (e.g., insert and delete tuples). \r\n\r\n\r\n=== Catalog ===\r\nCreate a catalog to hold all information about your database. This includes at least the following:\r\n * Table information (e.g., table-name, table-id, etc.).\r\n * For each table, the columns, and for each of these columns: the column name, type, length, and position.\r\n * The name of the record-based file in which the data corresponding to each table is stored.\r\n\r\nIt is mandatory to store the catalog information by using the RBF layer functions. You should create the catalog's tables and populate them the first time your database is initialized (when the method createCatalog() is called). Once the catalog's tables and columns tables have been created, they should be persisted to disk. Please use the following name and type for the catalog tables and columns. You can add more attributes you want/need to. However, please do not change the given name of these two tables or their attribute names. \r\n\r\n{{{\r\nTables (table-id:int, table-name:varchar(50), file-name:varchar(50))\r\nColumns(table-id:int, column-name:varchar(50), column-type:int, column-length:int, column-position:int)\r\n}}}\r\n\r\nAn example of the records that should be in these two tables after creating a table named \"Employee\" is:\r\n\r\n{{{\r\nTables \r\n(1, \"Tables\", \"Tables\")\r\n(2, \"Columns\", \"Columns\")\r\n(3, \"Employee\", \"Employee\")\r\n\r\nColumns\r\n(1, \"table-id\", TypeInt, 4 , 1)\r\n(1, \"table-name\", TypeVarChar, 50, 2)\r\n(1, \"file-name\", TypeVarChar, 50, 3)\r\n(2, \"table-id\", TypeInt, 4, 1)\r\n(2, \"column-name\",  TypeVarChar, 50, 2)\r\n(2, \"column-type\", TypeInt, 4, 3)\r\n(2, \"column-length\", TypeInt, 4, 4)\r\n(2, \"column-position\", TypeInt, 4, 5)\r\n(3, \"empname\", TypeVarChar, 30, 1)\r\n(3, \"age\", TypeInt, 4, 2)\r\n(3, \"height\", TypeReal, 4, 3)\r\n(3, \"salary\", TypeInt, 4, 4)\r\n}}}\r\nNote that !TypeInt, !TypevarChar, and !TypeReal are the enum types used to represent an attribute type and defined in the rbfm.h file. Also for the file-name attribute, you can use your own naming conventions if you want (e.g,. \"Tables.tbl\" for Tables table). In this example, The last row of Tables table states that the table-id of the \"Employee\" table is 3, its name is \"Employee\", and the RBF file associated with this table is \"Employee\". The last line of the Columns table shows the information about the \"salary\" column of the \"Employee\" table. Specifically, the table-id is 3, the column-name is \"salary\", the type of this column is Int, its length is 4, and the position of this column is 4.\r\n\r\nThe catalog tables (Tables and Columns) should be created when the method createCatalog() is called. All other subsequent invocations of your database should use the already created catalog's tables. The catalog tables will be deleted when the deleteCatalog() is called. Between the createCatalog() and deleteCatalog() methods, the catalog should be persistent on disk. Please note that users should be able to query your catalog's tables as any other table, but they should not be allowed to modify its content through the RM API. Modifications of the catalog's tables should be only allowed from internal calls (for instance, when creating a user table or deleting a user table, etc.). To do this, you may need to have a \"system\" vs. \"user\" flag in your Tables catalog so you can distinguish \"system tables\" from \"user tables\" and make it illegal to do anything but reading \"system tables\" through the RM layer.  If you take this design, then you need to add one more column to the two schemas defined above.\r\n\r\n=== !RelationManager class ===\r\n\r\nThe following is more information about the !RelationManager class.  Your program should create exactly one instance of this class, and all requests for the RM component should be directed to that instance. The public methods of the class declaration are shown first, followed by descriptions of the methods. The last two methods in the class declaration are the constructor and destructor methods and are not explained further. '''Note:''' your tuple-oriented file system must create a relation manager (RM) that initializes the catalog information you may need to store. It also internally creates a record-based file manager using the implementation from Project 1.\r\n\r\n{{{\r\nclass RelationManager\r\n{\r\npublic:\r\n  RC createCatalog();\r\n\r\n  RC deleteCatalog();\r\n\r\n  RC createTable(const string &tableName, const vector<Attribute> &attrs);\r\n\r\n  RC deleteTable(const string &tableName);\r\n\r\n  RC getAttributes(const string &tableName, vector<Attribute> &attrs);\r\n\r\n  RC insertTuple(const string &tableName, const void *data, RID &rid);\r\n\r\n  RC deleteTuple(const string &tableName, const RID &rid);\r\n\r\n  RC updateTuple(const string &tableName, const void *data, const RID &rid);\r\n\r\n  RC readTuple(const string &tableName, const RID &rid, void *data);\r\n\r\n  // mainly for debugging\r\n  // Print a tuple that is passed to this utility method.\r\n  RC printTuple(const vector<Attribute> &attrs, const void *data);\r\n\r\n  RC readAttribute(const string &tableName, const RID &rid, const string &attributeName, void *data);\r\n\r\n  // scan returns an iterator to allow the caller to go through the results one by one. \r\n  RC scan(const string &tableName,\r\n      const string &conditionAttribute,\r\n      const CompOp compOp,                  // comparison type such as \"<\" and \"=\"\r\n      const void *value,                    // used in the comparison\r\n      const vector<string> &attributeNames, // a list of projected attributes\r\n      RM_ScanIterator &rm_ScanIterator);\r\n\r\nprotected:\r\n  RelationManager();\r\n  ~RelationManager();\r\n};\r\n}}}\r\n\r\n\r\n=== RC createCatalog() ===\r\nThis method creates two system catalog tables - Tables and Columns. If they already exist, return an error. The actual files for these two tables should be created and tuples describing themselves should be inserted into these tables as shown earlier in the catalog section.\r\n\r\n=== RC deleteCatalog() ===\r\nThis method deletes the system catalog tables. The actual files for these two tables should be deleted. It will return an error if the system catalog does not exist.\r\n\r\n=== RC createTable(const string &tableName, const vector<Attribute> &attrs) ===\r\nThis method creates a table called tableName with a vector of attributes (attrs). The actual RBF file for this table should be created.\r\n\r\n=== RC deleteTable(const string &tableName); ===\r\nThis method deletes a table by the given tableName. The actual RBF file for this table should be deleted.\r\n\r\n=== RC getAttributes(const string &tableName, vector<Attribute> &attrs); ===\r\nThis method gets the attributes (attrs) of a table called tableName by looking in the catalog tables.  \r\n\r\n=== RC insertTuple(const string &tableName, const void *data, RID &rid); ===\r\nThis method inserts a tuple into a table called tableName. You can assume that the input is always correct and free of error. That is, you do not need to check if the input tuple has the right number of attributes and/or if the attribute types match. Since there can be NULL values in one or more attributes, the first part in *data contains n bytes to pass the null information about each attributes. For details, check insertRecord() in [wiki:cs222-2017-fall-project1-description Project 1 Description].\r\n\r\n=== RC deleteTuple(const string &tableName, const RID &rid); ===\r\nThis method deletes a tuple with a given rid. Also, each time a tuple is deleted, you will need to compact the underlying page. That is, keep the free space together in the middle of the page -- the slot table will be at one end, the record data area will be at the other end, and the free space should be in the middle.\r\n\r\n=== RC updateTuple(const string &tableName, const void *data, const RID &rid); ===\r\nThis method updates a tuple identified by a given rid. '''Note:''' if the tuple grows (i.e., the size of the tuple increases) and there is no space in the page to store the tuple (after the update), then the tuple is migrated to a new page with enough free space. Since you will implement an index structure (e.g., B-tree) in Project 3, tuples will be identified by their rids and when they migrate, you must leave a tombstone behind pointing to the new location of the tuple. Also, each time a tuple is updated to become smaller, you need to compact the underlying page. That is, keep the free space in the middle of the page -- the slot table will be at one end, the tuple data area will be at the other end, and the free space should be in the middle. Again, the structure for *data is the same as for insertRecord().\r\n\r\n=== RC readTuple(const string &tableName, const RID &rid, void *data); ===\r\nThis method reads a tuple identified by a given rid. The structure for *data is the same as for insertRecord().\r\n\r\n=== RC printTuple(const vector<Attribute> &attrs, const void *data); ===\r\nThis method mainly exists for debugging purposes. This method prints the tuple whose data is passed into this method. The structure for *data is the same as for insertRecord(). For details, refer to printRecord() in [wiki:cs222-2016-fall-project1-description Project 1 Description].\r\n\r\n=== RC readAttribute(const string &tableName, const RID &rid, const string &attributeName, void *data); ===\r\nThis method mainly exists for debugging purposes. This method reads a specific attribute of a tuple identified by a given rid. The structure for *data is the same as for insertRecord(). That is, a null-indicator will be placed in the beginning of *data. However, for this function, since it returns a value for just one attribute, exactly one byte of null-indicators should be returned, not a set of the null-indicators for all of the tuple's attributes. \r\n\r\n=== RC scan(const string &tableName, const string &conditionAttribute, const !CompOp compOp, const void *value, const vector<string> &attributeNames, RM_ScanIterator &rm_ScanIterator); ===\r\nThis method scans the table called tableName. That is, it sequentially reads all of the tuples in the table. This method returns an iterator called rm_ScanIterator to allow the caller to go through the records in the table one by one. A scan has a filter condition associated with it, e.g., it consists of a list of attributes to project out as well as a predicate on an attribute (\u201cSal > 40000\u201d). '''Note:''' the RBFM_ScanIterator should not cache the scan result in memory. In fact, your code should be looking only at one (or a few) page(s) of data at a time when getNextTuple() is called. In this project, let the OS do all the memory management work for you.\r\n\r\n== RM_ScanIterator Class  ==\r\nThe RM_ScanIterator class is a class that represents an iterator which is used to go through the tuples in the table one by one. The way to use this iterator is as follows:\r\n{{{\r\nRM_ScanIterator rmsi;\r\n\r\n// At this moment, do not execute scan and cache the results in the memory. Just initialize the scan operator\r\nrc = rm->scan(tableName, conditionAttribute, compOp, value, attributes, rmsi);     \r\n\r\nwhile(rmsi.getNextTuple(rid, returnedData) != RM_EOF){\r\n   // fetch one tuple at at time and process the data;\r\n}\r\nrmsi.close();\r\n}}}\r\n\r\nThe public methods of this class are shown next. The first two methods in the class declaration are the constructor and destructor methods and are not explained further. \r\n \r\n{{{\r\nclass RM_ScanIterator {\r\npublic:\r\n  RM_ScanIterator();\r\n  ~RM_ScanIterator();\r\n\r\n  // \"data\" follows the same format as RelationManager::insertTuple()\r\n  RC getNextTuple(RID &rid, void *data);\r\n  RC close();\r\n};\r\n}}}\r\n\r\n=== RC getNextTuple(RID &rid, void *data); ===\r\nThis method is used to get the next tuple from the scanned table. It returns RM_EOF when all tuples have been scanned. Note that the structure for *data is the same as for insertRecord(). That is, a null-indicator will be placed in the beginning of *data. However, for this function, since it returns a value for the attributes that are specified in the scan method, the corresponding byte(s) for these attributes of null-indicators should be placed, not the null-indicators for the entire set of table attributes. \r\n\r\n\r\n=== RC close(); ===\r\nThis method is used to close the iterator.\r\n\r\n\r\n== Design Assumptions ==\r\nYou can make the following simplifying assumptions when implementing PFM, RBFM, and RM (including !ScanIterator):[[br]]\r\n\r\n 1. The size of one tuple cannot exceed the size of a page. That is, an empty page can always hold at least one tuple. If an incoming tuple is too big for an empty page, or a tuple grows too much to fit alone on a page, return an error. (However, if a page has two or more tuples, then one of the tuples can grow to not fit on that shared page.) \r\n\r\n 2. A table maps to a single file, and a single file contains only one table.\r\n\r\n= Advanced Requirements (10 points) =\r\nAdvanced features will be treated as extra credit work. Extra credit points will be tracked separately and used when considering effort as a factor when assigning final grades. The following are the advanced features for this part of the project: \r\n\r\n{{{\r\nclass RelationManager\r\n{\r\npublic:\r\n\r\n  ......\r\n  RC addAttribute(const string &tableName, const Attribute &attr);\r\n\r\n  RC dropAttribute(const string &tableName, const string &attributeName);\r\n}\r\n}}}\r\n\r\n=== RC addAttribute(const string &tableName, const Attribute &attr); ===\r\nThis method adds a new attribute (attr) to a table called tableName. '''Note:''' This operation will update the catalogs but should not involve touching the data itself. That is, when you read a record right after adding an attribute A, the value for the attribute A should be returned as NULL.\r\n\r\n=== RC dropAttribute(const string &tableName, const string &attributeName); ===\r\nThis method drops an attribute called attributeName from a table called tableName. '''Note:''' This operation will update the catalogs but should not involve touching the data itself. That is, when you read a record right after dropping an attribute A, the value for the attribute A should not be included even though it still actually resides on disk.\r\n\r\n'''HINT:''' The above two methods will affect how operations access the fields of a record if it was created before such a schema change.\r\n\r\n\r\n= Explanation =\r\nThe commands listed above are by no means complete, but they do capture the essence of a tuple-oriented file system.\r\n\r\nYou have a lot of freedom in designing your specific algorithms and building your system. You should spend a significant amount of time in coming up with a design for your system before you start coding.\r\n\r\nFor endianess, that should matter only if binary files are copied to a different machine. We won't do that. We advise you to use memcpy to copy the int/real/char* values into the tuple byte array and vice-versa. As long as the same machine does the reading and writing, things should be fine. \r\n\r\nGrading will be based on the correctness of the implementation unless your code takes an exceedingly long time (e.g., more than 10 minutes) to execute a test case. Most test cases can be executed within a few seconds.\r\n\r\n}}}", "encoding": "utf-8"}