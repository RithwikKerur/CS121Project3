{"url": "https://grape.ics.uci.edu/wiki/public/wiki/cs221-2019-spring-project3?version=5&format=txt", "content": "\r\n= CS221: Project 3 - II: Positional index, phrase search, compression =\r\n'''Test Cases Due:     Week 6 Fri. (May 10), Due on Github as Pull Requests'''[[BR]]\r\n'''Review Due:           Week 7 Mon. (May 13),  Due on Github as Pull Requests Comments'''[[BR]]\r\n'''Final Code Due:     Week 8, Wed. (May 22),  Due on Github.'''[[BR]]\r\n\r\n\r\n== Coding Tasks ==\r\n1. Implement LSM-like Positional Index (insertion and merge). (5 points)\r\n1. Implement Phrase Search. (4 points)\r\n1. Implement Compression. (6 points)\r\n\r\n== Testing Tasks ==\r\n1. Write at least 2 test cases for a task (2 points)\r\n1. Review the test cases of two teams (2 points)\r\n\r\nTotal: 19 points \r\n\r\n== Overview ==\r\n\r\nIn this project, you'll be implementing a disk-based positional index and the phrase search operations. Compared to the inverted index in project 2, positional index stores the positions of all occurrences of the keywords in a document. In addition, we also store the term frequency - the number of times a word appears. Positional index is much bigger compared to inverted index, you'll implement delta-encoding and variable-length encoding to compress the inverted lists and positions.\r\n\r\nPositional index enables phrase search. Phrase search means searching a sequence of keywords in exact order. For example, the query \"new york\" will only match documents with \"new\" immediately followed by \"york\". A document like \"new ... other tokens ... york\" won't match.\r\n\r\nThe \"position\" of a word in the positional index have different variations. It could be either character position or token position. Token position might include or exclude stop words. Different kinds of \"position\" also have different meanings on phrase search. For example, \"University of California, Irvine\", if we search the phrase \"University California\", choice on stop words affects the search result.\r\n\r\nIn this project, we stores the '''token''' position. We use the tokens generated from the analyzer - if the analyzer removes the stop words, then the stop words are also excluded from the positional index. For example, the positions of \"cat and dog\" is \"{cat: 1}, {dog: 2}\".\r\n\r\n\r\n== Task 1: Implement LSM-like positional index. ==\r\n\r\nThe on disk index structure of the positional index is similar to the LSM structure in project 2. The behavior for `addDocument`, `flush`, and `merge` operations should be the same as project 2. You should continue using the `InvertedIndexManager` from project 2. \r\n\r\nThe index format of the positional index should be based on top of the inverted index format in project 2. Recall in project 2 we have 3 files per segment: docStore, dictionary, and invertedLists. The dictionary stores the pointer from a token to the inverted lists of the token. In this project, we need another \"position\" file to store the position list of a token in a document. The \"InvertedLists\" needs to store an additional pointer to the position list per documentID.\r\n\r\nYou need to implement the following functions newly added to `InvertedIndexManager`\r\n\r\n{{{\r\n    /**\r\n     * Creates a positional index with the given folder, analyzer, and the compressor.\r\n     * Compressor must be used to compress the inverted lists and the position lists.\r\n     *\r\n     */\r\n    public static InvertedIndexManager createOrOpenPositional(String indexFolder, Analyzer analyzer, Compressor compressor)\r\n\r\n    /**\r\n     * Reads a disk segment of a positional index into memory based on segmentNum.\r\n     * This function is mainly used for checking correctness in test cases.\r\n     *\r\n     * Throws UnsupportedOperationException if the inverted index is not a positional index.\r\n     *\r\n     * @param segmentNum n-th segment in the inverted index (start from 0).\r\n     * @return in-memory data structure with all contents in the index segment, null if segmentNum don't exist.\r\n     */\r\n    public PositionalIndexSegmentForTest getIndexSegmentPositional(int segmentNum)\r\n\r\n}}}\r\n\r\n== Task 2: Implement phrase search. ==\r\n\r\nIn this task, you'll implement phrase search using the positional index. You should make same assumptions about IO and tokenization as in project 2.\r\n\r\nThe keywords in the list represents a consecutive sequence of keywords, a document only matches if it matches the sequence in exact order.\r\n\r\nImplement the following function:\r\n\r\n{{{\r\n    /**\r\n\r\n     * Performs a phrase search on a positional index.\r\n     * Phrase search means the document must contain the consecutive sequence of keywords in exact order.\r\n     *\r\n     * You could assume the analyzer won't convert each keyword into multiple tokens.\r\n     * Throws UnsupportedOperationException if the inverted index is not a positional index.\r\n     *\r\n     * @param phrase, a consecutive sequence of keywords\r\n     * @return a iterator of documents matching the query\r\n     */\r\n    public Iterator<Document> searchPhraseQuery(List<String> phrase)\r\n\r\n}}}\r\n\r\n\r\n== Task 3: Implement compression. ==\r\n\r\nIn this task, you'll implement delta encoding and variable length encoding in to one compressor. Implement the `encode` and `decode` functions for `DeltaVarLenCompressor`.\r\n\r\nDelta Encoding means storing the difference (delta) between adjacent integers rather than the actual number. For example, given an list `[1, 5, 8, 13, 20]`, the delta encoding stores `[1, 4, 3, 5, 7]`. \r\n\r\nVariable length encoding of an integer works similarly to UTF-8. We use a variable number of bytes instead of a constant 4 bytes to represent an integer. Specifically, in each byte, the first bit indicates if there are more bytes to read - `1` means reading the next byte and `0` means termination, and the rest 7 bits are used to encode the integer value. \r\n\r\nFor example, int value `1` is encoded as `00000001`. The first byte `0` means no more bytes to read, and the rest 7 bits `0000001` represents 1. int value `128` (`2^7`) is encoded as `10000001 00000000`. The first bit in the first byte indicates reading the next byte. int value `16,384` (`2^14`) is encoded as `10000001 10000000 00000000`.\r\n\r\n{{{\r\n    /**\r\n     * Encodes a list of integers to a byte array.\r\n     */\r\n    byte[] encode(List<Integer> integers);\r\n\r\n    /**\r\n     * Decodes part of a byte array to a list of integers.\r\n     *\r\n     * @param bytes bytes to decode\r\n     * @param startOffset starting position to decode\r\n     * @param length number of bytes to decode from start position\r\n     */\r\n    List<Integer> decode(byte[] bytes, int startOffset, int length);\r\n}}}\r\n\r\n\r\n== Test cases ==\r\nPlease follow the similar general guideline and procedure as in project 1 and project 2. Please put all test cases in the package `edu.uci.ics.cs221.index.positional`. Test case assignments will be released soon.", "encoding": "ascii"}