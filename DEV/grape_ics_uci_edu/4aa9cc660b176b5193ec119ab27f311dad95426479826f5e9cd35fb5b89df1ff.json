{"url": "https://grape.ics.uci.edu/wiki/public/wiki/cs221-2019-spring-project3?version=2&format=txt", "content": "\r\n= CS221: Project 2 - II: Positional index, phrase search, compression =\r\n'''Test Cases Due:     Week 6 Fri. (May 10), Due on Github as Pull Requests'''[[BR]]\r\n'''Review Due:           Week 7 Mon. (May 13),  Due on Github as Pull Requests Comments'''[[BR]]\r\n'''Final Code Due:     Week 8, Wed. (May 22),  Due on Github.'''[[BR]]\r\n\r\n\r\n== Coding Tasks ==\r\n1. Implement LSM-like Positional Index (insertion and merge).\r\n1. Implement Phrase Search.\r\n1. Implement Compression.\r\n\r\n== Testing Tasks ==\r\n1. Write at least 2 test cases for a task (2 points)\r\n1. Review the test cases of two teams (2 points)\r\n\r\nTotal: 19 points \r\n\r\n== Overview ==\r\n\r\nIn this project, you'll be implementing a disk-based positional index and the phrase search operations. Compared to the inverted index in project 2, positional index stores the positions of all occurrences of the keywords in a document. In addition, we also store the frequency of a \r\n\r\nPositional index enables phrase search. Phrase search means searching a sequence of keywords in exact order. For example, the query \"new york\" will only match documents with \"new\" immediately followed by \"york\". A document like \"new ... other tokens ... york\" won't match.\r\n\r\nThe \"position\" of a word in the positional index have many different kinds. It could be either character position or token position. Token position might include or exclude stop words. Different kinds of \"position\" also have different meanings on phrase search. For example, \"University of California, Irvine\", if we search the phrase \"University California\", choice on stop words affects the search result.\r\n\r\nIn this project, we stores the '''token''' position. We use the tokens generated from the analyzer - if the analyzer removes the stop words, then the stop words are also excluded from the positional index. For example, the positions of \"cat and dog\" is \"{cat: 1}, {dog: 2}\".\r\n\r\n\r\n== Task 1: Implement LSM-like positional index. ==\r\n\r\nThe on disk index structure of the positional index is similar to the LSM structure in project 2. The behavior for `addDocument`, `flush`, and `merge` operations should be the same as project 2. \r\n\r\n\r\n{{{\r\n--- dictionary ---\r\n<term1>: <pointer_to_positional_posting>, <term2>: <pointer_to_positional_posting>, ...\r\n--- positional posting lists ---\r\n<docID1>: <num_of_occurrences>, [pos1, pos2, pos3, ...], <docID2>: <num_of_occurrences>, [pos1, pos2, pos3, ...]\r\n}}}\r\n\r\n\r\n{{{\r\npublic void addDocument(Document document)\r\n\r\npublic void flush()\r\n\r\npublic Iterator<Document> documentIterator()\r\n\r\npublic int getNumSegments()\r\n\r\npublic PositionalIndexSegmentForTest getIndexSegment(int segmentNum)\r\n\r\n}}}\r\n\r\n== Task 2: Implement phrase search. ==\r\n\r\nIn this task, you'll implement phrase search using the positional index. You should make same assumptions about IO and tokenization as in project 2.\r\n\r\nThe keywords in the list represents a consecutive sequence of keywords, a document only matches if it matches the sequence in exact order.\r\n\r\nThe following are specific functions to implement:\r\n\r\n{{{\r\n    public Iterator<Document> pharseSearch(List<String> keywords) \r\n}}}\r\n\r\n\r\n== Task 3: Implement compression. ==\r\n\r\n\r\n\r\n== Test cases ==\r\nPlease follow the similar general guideline and procedure as in project 1 and project 2. Test case assignments will be released soon.", "encoding": "ascii"}