{"url": "https://grape.ics.uci.edu/wiki/public/wiki/cs222p-2017-fall-project1-description?version=4&format=txt", "content": "{{{#!div style=\"background-color:#f2f3f4\"\r\n\r\n= CS222P Fall 2017: Principles of Data Management - Project 1 Description =\r\n\r\n= Introduction =\r\nIn this project, you will implement a paged file (PF) system and the first few operations of a record-based file (RBF) manager. The PF component provides facilities for higher-level client components to perform file I/O in terms of pages. In the PF component, methods are provided to create, destroy, open, and close paged files, to read and write a specific page of a given file, and to add pages to a given file. The record manager is going to be built on top of the basic paged file system. In this part of the project, you are also required to implement some (not all) of the methods provided in the record manager code skeleton.\r\n\r\nAll methods in the PF and RBF components, except constructors and destructors, return integer codes. A return code of 0 indicates normal completion. A nonzero return code indicates that either an exception condition or an error has occurred.\r\n\r\n= Interface =\r\nThe interface of part 1 of the project consists of three classes: the\u00a0!PagedFileManager, the\u00a0!FileHandle, and the\u00a0!RecordBasedFileManager\u00a0classes.\r\n\r\n== !PagedFileManager\u00a0Class ==\r\nThe\u00a0!PagedFileManager\u00a0class handles the creation, deletion, opening, and closing of paged files. Your program should create exactly one instance of this class, and all requests for PF component file management should be directed to that instance. Below, the public methods of the class declaration are shown first, followed by descriptions of the methods. The first two methods in the class declaration are the constructor and destructor methods for the class; they are not explained further. Each method except the constructor and destructor methods returns a value of type RC (for \"return code\" -- actually an integer). A return code of 0 indicates normal completion. A nonzero return code indicates that an exception condition or error has occurred.\r\n\r\n{{{\r\n#!cpp\r\nclass PagedFileManager {\r\n\r\npublic:\r\n    // Access to the _pf_manager instance\r\n    static PagedFileManager* instance();                                      \r\n\r\n    // Create a new file\r\n    RC createFile    (const string &fileName);                            \r\n    \r\n    // Destroy a file\r\n    RC destroyFile   (const string &fileName);                            \r\n\r\n    // Open a file\r\n    RC openFile      (const string &fileName, FileHandle &fileHandle);\r\n\r\n    // Close a file\r\n    RC closeFile     (FileHandle &fileHandle);\r\n\r\nprotected:    \r\n    // Constructor\r\n    PagedFileManager();\r\n\r\n    // Destructor\r\n    ~PagedFileManager();\r\n\r\nprivate:\r\n    static PagedFileManager* _pf_manager;\r\n}\r\n}}}\r\n=== RC createFile (const string &fileName) ===\r\nThis method creates an empty-paged file called fileName. The file should not already exist. This method should not create any pages in the file.\r\n\r\n=== RC destroyFile (const string &fileName) ===\r\nThis method destroys the paged file whose name is fileName. The file should already exist.\r\n\r\n=== RC openFile (const string &fileName,\u00a0!FileHandle\u00a0&fileHandle) ===\r\nThis method opens the paged file whose name is fileName. The file must already exist (and been created using the createFile method). If the open method is successful, the fileHandle object whose address is passed in as a parameter now becomes a \"handle\" for the open file. This file handle is used to manipulate the pages of the file (see the\u00a0!FileHandle\u00a0class description below). It is an error if fileHandle is already a handle for some open file when it is passed to the openFile method. It is not an error to open the same file more than once if desired, but this would be done by using a different fileHandle object each time. Each call to the openFile method creates a new \"instance\" of the open file. Warning: Opening a file more than once for data modification is not prevented by the PF component, but doing so is likely to corrupt the file structure and may crash the PF component. (You do not need to try and prevent this, as you can assume the layer above is \"friendly\" in that regard.) Opening a file more than once for reading is no problem.\r\n\r\n=== RC closeFile (!FileHandle\u00a0&fileHandle) ===\r\nThis method closes the open file instance referred to by fileHandle. (The file should have been opened using the openFile method.) All of the file's pages are flushed to disk when the file is closed.\r\n\r\n== !FileHandle\u00a0Class ==\r\nThe\u00a0!FileHandle\u00a0class provides access to the pages of an open file. To access the pages of a file, a client first creates an instance of this class and passes it to the PagedFileManager::openFile method described above. As before, the public methods of the class declaration are shown first, followed by descriptions of the methods. The first two methods in the class declaration are the constructor and destructor methods and are not explained further. In order for you to gather performance data about file accesses, the\u00a0!FileHandle\u00a0class should maintain counters for each of the I/O-related operations of theFileHandle\u00a0class. When initialized, all counters should be set to 0. Inside each method of\u00a0!FileHandle, you will then need to increase the corresponding counter by 1 every time you successfully execute the associated method. For instance, when readPage() is executed, readPageCounter should be increased by 1.\r\n\r\n{{{\r\nclass FileHandle {\r\n\r\npublic:\r\n    // variables to keep counter for each operation\r\n    unsigned readPageCounter;\r\n    unsigned writePageCounter;\r\n    unsigned appendPageCounter;\r\n\r\n    // Constructor\r\n    FileHandle();\r\n\r\n    // Destructor\r\n    ~FileHandle();\r\n\r\n    // Get a specific page\r\n    RC readPage(PageNum pageNum, void *data);\r\n\r\n    // Write a specific page\r\n    RC writePage(PageNum pageNum, const void *data);\r\n\r\n    // Append a specific page\r\n    RC appendPage(const void *data);\r\n\r\n    // Get the number of pages in the file\r\n    unsigned getNumberOfPages();\r\n\r\n    // Put the current counter values into variables\r\n    RC collectCounterValues(unsigned &readPageCount, unsigned &writePageCount, unsigned &appendPageCount);\r\n}\r\n}}}\r\n=== RC readPage(!PageNum\u00a0pageNum, void *data) ===\r\nThis method reads the page into the memory block pointed to by data. The page should exist. Note that page numbers start from 0.\r\n\r\nHere is a part of some example code for readPage that increases readPageCount whenever it is executed. For writePage() and appendPage(), the logic is similar.\r\n\r\n{{{\r\n    RC FileHandle::readPage(PageNum pageNum, void *data) {\r\n        ......\r\n    \treadPageCount = readPageCount + 1;\r\n    \treturn 0;\r\n    }\r\n    \r\n}}}\r\n=== RC writePage(!PageNum\u00a0pageNum, const void *data) ===\r\nThis method writes the given data into a page specified by pageNum. The page should exist. Page numbers start from 0.\r\n\r\n=== RC appendPage(const void *data) ===\r\nThis method appends a new page to the end of the file and writes the given data into the newly allocated page.\r\n\r\n=== unsigned getNumberOfPages() ===\r\nThis method returns the total number of pages currently in the file.\r\n\r\n=== RC collectCounterValues(unsigned &readPageCount, unsigned &writePageCount, unsigned &appendPageCount) ===\r\nThis method should return the current counter values of this\u00a0!FileHandle\u00a0in the three given variables. Here is some example code that gives you an idea how it will be applied.\r\n\r\n{{{\r\n\t......\r\n\tunsigned readPageCount = 0;\r\n\tunsigned writePageCount = 0;\r\n\tunsigned appendPageCount = 0;\r\n\t\r\n\t......\r\n\tFileHandle fileHandle1;\r\n        rc = pfm->openFile(fileName, fileHandle1);\r\n\tfileHandle1.collectCounterValues(readPageCount, writePageCount, appendPageCount);\r\n\tcout << \"Before AppendPage - R:\" << readPageCount << \" W:\" << writePageCount << \" A:\" << appendPageCount << endl;\r\n\t\r\n\t......\r\n\trc = fileHandle1.appendPage(data);\r\n\tfileHandle1.collectCounterValues(readPageCount, writePageCount, appendPageCount);\r\n\tcout << \"After AppendPage R:\" << readPageCount << \" W:\" << writePageCount << \" A:\" << appendPageCount << endl;\r\n    \r\n}}}\r\nAnd a result might be:\r\n\r\n{{{\r\n\tBefore AppendPage - R:0 W:0 A:0\r\n\tAfter AppendPage - R:0 W:0 A:1\r\n}}}\r\nIn this example,\u00a0!FileHandle\u00a0appends one page (A + 1).\r\n\r\n== !RecordBasedFileManager\u00a0Class ==\r\nThe\u00a0!RecordBasedFileManager\u00a0class handles record-based operations such as inserting, updating, deleting, and reading records. Your program should create exactly one instance of this class, and all requests for this component should be directed to that instance. Below, the public methods of the class declaration are shown first, followed by descriptions of the methods. The first two methods in the class declaration are the constructor and destructor methods for the class; they are not explained further. Each method except the constructor and destructor methods returns a value of type RC. A return code of 0 indicates normal completion. A nonzero return code indicates that an exception condition or error has occurred. Please note that in this part of the project, you are only responsible for implementing the first group of methods in this class (besides the constructor and destructor). Note that for part 1 of the project, you are thus NOT required to implement the following methods: deleteRecord, updateRecord, readAttribute, and scan.\r\n\r\n{{{\r\n#!cpp\r\nclass RecordBasedFileManager {\r\n\r\npublic:\r\n    // Access to the _rbf_manager instance\r\n    static RecordBasedFileManager* instance();                                      \r\n\r\n    // Create a new record-based file\r\n    RC createFile(const string &fileName);\r\n  \r\n    // Destroy a record-based file\r\n    RC destroyFile(const string &fileName);\r\n  \r\n    // Open a record-based file\r\n    RC openFile(const string &fileName, FileHandle &fileHandle);\r\n  \r\n    // Close a record-based file\r\n    RC closeFile(FileHandle &fileHandle);\r\n  \r\n    // Insert a record into a file\r\n    RC insertRecord(FileHandle &fileHandle, const vector<Attribute> &recordDescriptor, const void *data, RID &rid);\r\n\r\n    // Read a record identified by the given rid.\r\n    RC readRecord(FileHandle &fileHandle, const vector<Attribute> &recordDescriptor, const RID &rid, void *data);\r\n  \r\n    // Print the record that is passed to this utlity method.\r\n    RC printRecord(const vector<Attribute> &recordDescriptor, const void *data);\r\n    \r\n    /******************************************************************************************\r\n    * All methods below this comment (other than the constructor and destructor) are NOT required to be implemented for part 1 of the project\r\n    *******************************************************************************************/\r\n   \r\n    // Delete a record identified by the given rid.\r\n    RC deleteRecord(FileHandle &fileHandle, const vector<Attribute> &recordDescriptor, const RID &rid);\r\n\r\n    // Update a record identified by the given rid.\r\n    RC updateRecord(FileHandle &fileHandle, const vector<Attribute> &recordDescriptor, const void *data, const RID &rid);\r\n\r\n    // Read an attribute given its name and the rid.\r\n    RC readAttribute(FileHandle &fileHandle, const vector<Attribute> &recordDescriptor, const RID &rid, const string attributeName, void *data);\r\n\r\n    // Scan returns an iterator to allow the caller to go through the results one by one. \r\n    RC scan(FileHandle &fileHandle,\r\n      const vector<Attribute> &recordDescriptor,\r\n      const string &conditionAttribute,\r\n      const CompOp compOp,                  // comparision type such as \"<\" and \"=\"\r\n      const void *value,                    // used in the comparison\r\n      const vector<string> &attributeNames, // a list of projected attributes\r\n      RBFM_ScanIterator &rbfm_ScanIterator);\r\n    \r\nprotected:    \r\n    // Constructor\r\n    RecordBasedFileManager();\r\n\r\n    // Destructor\r\n    ~RecordBasedFileManager();\r\n\r\nprivate:\r\n    static RecordBasedFileManager* _rbf_manager;\r\n}\r\n}}}\r\n=== RC createFile(const string &fileName) ===\r\nThis method creates a record-based file called fileName. The file should not already exist. Please note that this method should internally use the method PagedFileManager::createFile (const char *fileName).\r\n\r\n=== RC destroyFile(const string &fileName) ===\r\nThis method destroys the record-based file whose name is fileName. The file should exist. Please note that this method should internally use the method PagedFileManager::destroyFile (const char *fileName).\r\n\r\n=== RC openFile(const string &fileName,\u00a0!FileHandle\u00a0&fileHandle) ===\r\nThis method opens the record-based file whose name is fileName. The file must already exist and it must have been created using the RecordBasedFileManager::createFile method. If the method is successful, the fileHandle object whose address is passed as a parameter becomes a \"handle\" for the open file. The file handle rules in the method PagedFileManager::openFile apply here too. Also note that this method should internally use the method PagedFileManager::openFile(const char *fileName,\u00a0!FileHandle\u00a0&fileHandle).\r\n\r\n=== RC closeFile(!FileHandle\u00a0&fileHandle) ===\r\nThis method closes the open file instance referred to by fileHandle. The file must have been opened using the RecordBasedFileManager::openFile method. Note that this method should internally use the method PagedFileManager::closeFile(!FileHandle\u00a0&fileHandle).\r\n\r\n=== RC insertRecord(!FileHandle\u00a0&fileHandle, const vector<Attribute> &recordDescriptor, const void *data, RID &rid) ===\r\nGiven a record descriptor, insert a new record into the file identified by the provided handle. You can assume that the input is always correct and free of error. That is, you do not need to check to see if the input record has the right number of attributes or if the attribute types match. However, in order to deal with NULL values in the attributes, the first part in *data contains n bytes for passing the null information about each fields. The value n can be calculated by using this formula: ceil(number of fields in a record / 8). For example, if there are 5 fields, ceil(5/8) = 1 byte. If there are 20 fields, the size will be ceil(20/8) = 3 bytes. The left-most bit in the first byte corresponds to the first field. The right-most bit in the first byte corresponds to the eighth field. If there are more than eight fields, the left-most bit in the second byte corresponds to the ninth field and so on. If the corresponding bit to each field is set to 1, then the actual data does not contain any value for this field. For example, if there are three fields in a record and the second field contains NULL, the bit representation in a byte is 0100000. In addition, in the actual data, the incoming record contains the first and the third values only. That is, the third field value is placed right after the first field value in this case.\r\n\r\nThis format (null-fields-indicator + actual data) is to be used for all record manipulation operations (unless stated differently). For example, when you read a record, the first part of what you return should contain a null-fields-indicator that provides the information about null fields, and the actual data should not contain null field values.\r\n\r\nYour file structure is a heap file, and you may use a system-sequenced file organization. That is, if the last (current) page has enough space, insert a new record into this page. If not, find the first page with free space large enough to store the record, e.g., looking from the beginning of the file, and store the record at that location. An RID here is the record ID which is used to uniquely identify records in a file. An RID consists of: 1) the page number that the record resides in within the file, and 2) the slot number that the record resides in within the page. The insertRecord method accepts an RID object and fills it with the RID of the record that is the target for insertion; this lets the caller know what the system-determined RID was for each newly inserted record. For managing free space within pages, you should keep the free space coalesced in the center of the page at all times -- so if a record deletion or update creates a \"hole\", you should move records around to keep all of the free space together. Note that this will not change the RIDs of your records; when you move a record within a page, you will also keep track of the record's new offset in the slot table on the page, and the RID only contains the slot number, not the offset itself.\r\n\r\nNote that the API data format above is just intended for passing the data into the insertRecord(). This does not necessarily mean that the internal representation of your record should be the same as this format. (It probably shouldn't be. :-))\r\n\r\n=== RC readRecord(!FileHandle\u00a0&fileHandle, const vector<Attribute> &recordDescriptor, const RID &rid, void *data) ===\r\nGiven a record descriptor, read the record identified by the given rid.\r\n\r\n=== RC printRecord(const vector<Attribute> &recordDescriptor, const void *data) ===\r\nThis is a utility method that will be mainly used for debugging/testing. It should be able to interpret the bytes of each record using the passed-in record descriptor and then print its content to the screen. For instance, suppose a record consists of two fields: age (int) and height (float), which means the record will be of size 9 (1 byte for the null-fields-indicator, 4 bytes for int, and 4 bytes for float). The printRecord method should recognize the record format using the record descriptor. It should then check the null-fields-indicator to skip certain fields if there are any NULL fields. Then, it should be able to convert the four bytes after the first byte into an int object and the last four bytes to a float object and print their values. It should also print NULL for those fields that are skipped because they are null. Thus, an example for three records would be:\r\n\r\n{{{\r\n age: 24      height: 6.1\r\n age: NULL    height: 7.5       \r\n age: 32      height: NULL\r\n}}}\r\n=== RC deleteRecord(!FileHandle\u00a0&fileHandle, const vector<Attribute> &recordDescriptor, const RID &rid) ===\r\nGiven a record descriptor, delete the record identified by the given rid. Also, each time when a record is deleted, you will need to compact that page. That is, keep the free space in the middle of the page -- the slot table will be at one end, the record data area will be at the other end, and the free space should be in the middle.\r\n\r\n=== RC updateRecord(!FileHandle\u00a0&fileHandle, const vector<Attribute> &recordDescriptor, const void *data, const RID &rid) ===\r\nGiven a record descriptor, update the record identified by the given rid with the passed data. If the record grows and there is no space in the page to store the record, the record must be migrated to a new page with enough free space. Since you will soon be implementing an index structure, assume that records are identified by their RID values and when they migrate, you should leave a tombstone behind (pointing to the new location of the record). Also, each time when a record is updated to become smaller, you need to compact that page. That is, keep the free space in the middle of the page -- the slot table will be at one end, the record data area will be at the other end, and the free space should be in the middle. Again, the structure for *data is the same as the one we use for the insertRecord().\r\n\r\n=== RC readAttribute(!FileHandle\u00a0&fileHandle, const vector<Attribute> &recordDescriptor, const RID &rid, const string attributeName, void *data) ===\r\nGiven a record descriptor, read a specific attribute of a record identified by a given rid.\r\n\r\n=== RC scan(!FileHandle\u00a0&fileHandle, const vector<Attribute> &recordDescriptor, const string &conditionAttribute, const\u00a0!CompOp\u00a0compOp, const void *value, const vector<string> &attributeNames, RBFM_ScanIterator &rbfm_ScanIterator) ===\r\nGiven a record descriptor, scan a file, i.e., sequentially read all the entries in the file. A scan has a filter condition associated with it, e.g., it consists of a list of attributes to project out as well as a predicate on an attribute (\"Sal > 40000\"). Specifically, the parameter conditionAttribute here is the attribute's name that you are going to apply the filter on. The compOp parameter is the comparison type that is going to be used in the filtering process. The value parameter is the value of the conditionAttribute that is going to be used to filter out records. Note that the retrieved records should only have the fields that are listed in the vector attributeNames. Please take a look at the test cases for more information on how to use this method.\r\n\r\n== Memory Requirements ==\r\nYou should be careful about how to use memory to implement those operations. It is\u00a0'''NOT ACCEPTABLE'''\u00a0to cache the entire database or even a large portion of the database in memory, since that is not practical for large amounts of data. Also, for each operation, you should make sure that the \"effect\" of the operation (if any) has indeed been stored in the Linux file. For example, for the \"insertRecord\" operation, after the function successfully returns, the inserted record should physically reside in the file in the Linux filesystem. The tests will help you to not make mistakes here -- that is why each test case is run separately from the others.\r\n\r\n== Record Representation ==\r\n * You need to support basic attribute types, including integers, reals, and variable-length character strings. Other types are optional.\r\n * There can be NULL values in one or multiple fields in a record, as described throughout this document.\r\n * You can assume that the float value comparisons can be done by using logical operators (==, !=, >=, <=, <, >).\r\n * Endianness is not an issue here since you do not communicate with other systems. Use the default setting that your system provides.\r\n * Records within file pages should be represented using a record format that nicely handles mixes of binary data and variable-length character data. \"Nicely\" here refers to both space and efficiency, e.g., you should not waste 70 bytes of space to store \"abcdefghij\" in a VARCHAR(80) field.\r\n * '''Your record representation must allow direct addressability of data fields - i.e., finding the nth field must be an O(1) operation, not an O(n) operation.'''\r\n * Your chosen on-page record format should be clearly documented in your project code and your accompanying report.\r\n\r\n}}}", "encoding": "utf-8"}