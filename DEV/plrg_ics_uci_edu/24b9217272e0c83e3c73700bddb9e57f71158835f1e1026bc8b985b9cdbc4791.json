{"url": "http://plrg.ics.uci.edu/software_page/42-2/", "content": "\n<!DOCTYPE html>\n<html lang=\"en-US\">\n<head>\n\n\t\t<meta charset=\"UTF-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n\t<link rel=\"profile\" href=\"http://gmpg.org/xfn/11\" />\n\t<link rel=\"pingback\" href=\"http://plrg.ics.uci.edu/wordpress/xmlrpc.php\" />\t\n<title>CDSChecker &#8211; Programming Languages Research Group</title>\n<link rel='dns-prefetch' href='//fonts.googleapis.com' />\n<link rel='dns-prefetch' href='//s.w.org' />\n<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Programming Languages Research Group &raquo; Feed\" href=\"http://plrg.ics.uci.edu/feed/\" />\n<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Programming Languages Research Group &raquo; Comments Feed\" href=\"http://plrg.ics.uci.edu/comments/feed/\" />\n\t\t<script type=\"text/javascript\">\n\t\t\twindow._wpemojiSettings = {\"baseUrl\":\"https:\\/\\/s.w.org\\/images\\/core\\/emoji\\/12.0.0-1\\/72x72\\/\",\"ext\":\".png\",\"svgUrl\":\"https:\\/\\/s.w.org\\/images\\/core\\/emoji\\/12.0.0-1\\/svg\\/\",\"svgExt\":\".svg\",\"source\":{\"concatemoji\":\"http:\\/\\/plrg.ics.uci.edu\\/wordpress\\/wp-includes\\/js\\/wp-emoji-release.min.js?ver=5.2.3\"}};\n\t\t\t!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline=\"top\",l.font=\"600 32px Arial\",a){case\"flag\":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case\"emoji\":return b=d([55357,56424,55356,57342,8205,55358,56605,8205,55357,56424,55356,57340],[55357,56424,55356,57342,8203,55358,56605,8203,55357,56424,55356,57340]),!b}return!1}function f(a){var c=b.createElement(\"script\");c.src=a,c.defer=c.type=\"text/javascript\",b.getElementsByTagName(\"head\")[0].appendChild(c)}var g,h,i,j,k=b.createElement(\"canvas\"),l=k.getContext&&k.getContext(\"2d\");for(j=Array(\"flag\",\"emoji\"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],\"flag\"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener(\"DOMContentLoaded\",h,!1),a.addEventListener(\"load\",h,!1)):(a.attachEvent(\"onload\",h),b.attachEvent(\"onreadystatechange\",function(){\"complete\"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);\n\t\t</script>\n\t\t<style type=\"text/css\">\nimg.wp-smiley,\nimg.emoji {\n\tdisplay: inline !important;\n\tborder: none !important;\n\tbox-shadow: none !important;\n\theight: 1em !important;\n\twidth: 1em !important;\n\tmargin: 0 .07em !important;\n\tvertical-align: -0.1em !important;\n\tbackground: none !important;\n\tpadding: 0 !important;\n}\n</style>\n\t<link rel='stylesheet' id='wp-block-library-css'  href='http://plrg.ics.uci.edu/wordpress/wp-includes/css/dist/block-library/style.min.css?ver=5.2.3' type='text/css' media='all' />\n<link rel='stylesheet' id='attitude_style-css'  href='http://plrg.ics.uci.edu/wordpress/wp-content/themes/attitude_mod/style.css?ver=5.2.3' type='text/css' media='all' />\n<link rel='stylesheet' id='google_fonts-css'  href='//fonts.googleapis.com/css?family=PT+Sans%7CPhilosopher&#038;ver=5.2.3' type='text/css' media='all' />\n<script type='text/javascript' src='http://plrg.ics.uci.edu/wordpress/wp-includes/js/jquery/jquery.js?ver=1.12.4-wp'></script>\n<script type='text/javascript' src='http://plrg.ics.uci.edu/wordpress/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>\n<script type='text/javascript' src='http://plrg.ics.uci.edu/wordpress/wp-content/themes/attitude_mod/library/js/tinynav.js?ver=5.2.3'></script>\n<script type='text/javascript' src='http://plrg.ics.uci.edu/wordpress/wp-content/themes/attitude_mod/library/js/backtotop.js?ver=5.2.3'></script>\n<link rel='https://api.w.org/' href='http://plrg.ics.uci.edu/wp-json/' />\n<link rel=\"EditURI\" type=\"application/rsd+xml\" title=\"RSD\" href=\"http://plrg.ics.uci.edu/wordpress/xmlrpc.php?rsd\" />\n<link rel=\"wlwmanifest\" type=\"application/wlwmanifest+xml\" href=\"http://plrg.ics.uci.edu/wordpress/wp-includes/wlwmanifest.xml\" /> \n<link rel=\"canonical\" href=\"http://plrg.ics.uci.edu/software_page/42-2/\" />\n<link rel='shortlink' href='http://plrg.ics.uci.edu/?p=42' />\n<link rel=\"alternate\" type=\"application/json+oembed\" href=\"http://plrg.ics.uci.edu/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fplrg.ics.uci.edu%2Fsoftware_page%2F42-2%2F\" />\n<link rel=\"alternate\" type=\"text/xml+oembed\" href=\"http://plrg.ics.uci.edu/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fplrg.ics.uci.edu%2Fsoftware_page%2F42-2%2F&#038;format=xml\" />\n\n</head>\n\n<body class=\"page-template-default page page-id-42 page-child parent-pageid-28 \">\n\t\n\t<div class=\"wrapper\">\n\t\t\t\t<header id=\"branding\" >\n\t\t\t\t\n\t<div class=\"container clearfix\">\n\t\t<div class=\"hgroup-wrap clearfix\">\n\t\t\t\t\t\t\t\t<section class=\"hgroup-right\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<form action=\"http://plrg.ics.uci.edu/\" class=\"searchform clearfix\" method=\"get\">\n\t\t<label class=\"assistive-text\" for=\"s\">Search</label>\n\t\t<input type=\"text\" placeholder=\"Search\" class=\"s field\" name=\"s\">\n\t</form><!-- .searchform -->\n\t\t\t\t\t</section><!-- .hgroup-right -->\t\n\t\t\t\t\t\t\t<hgroup id=\"site-logo\" class=\"clearfix\">\n\t\t\t\t\t\t\t\t\t\t\t\t<h1 id=\"site-title\"> \n\t\t\t\t\t\t\t\t<a href=\"http://plrg.ics.uci.edu/\" title=\"Programming Languages Research Group\" rel=\"home\">\n\t\t\t\t\t\t\t\t\tProgramming Languages Research Group\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t</h1>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t</hgroup><!-- #site-logo -->\n\t\t\t\n\t\t</div><!-- .hgroup-wrap -->\n\t</div><!-- .container -->\t\n\t\t\t\t\t<img src=\"http://plrg.eecs.uci.edu/wordpress/wp-content/uploads/2015/04/cropped-IMG_0976_small.jpg\" class=\"header-image\" width=\"2000\" height=\"485\" alt=\"Programming Languages Research Group\">\n\t\t\t\t\n\t<nav id=\"access\" class=\"clearfix\">\n\t\t\t\t\t<div class=\"container clearfix\"><ul class=\"root\"><li id=\"menu-item-34\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-home menu-item-34\"><a href=\"http://plrg.ics.uci.edu/\">Brian Demsky</a></li>\n<li id=\"menu-item-22\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-22\"><a href=\"http://plrg.ics.uci.edu/students/\">Students</a></li>\n<li id=\"menu-item-19\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-19\"><a href=\"http://plrg.ics.uci.edu/publications_page/\">Publications</a></li>\n<li id=\"menu-item-29\" class=\"menu-item menu-item-type-post_type menu-item-object-page current-page-ancestor menu-item-has-children menu-item-29\"><a href=\"http://plrg.ics.uci.edu/software_page/\">Software</a>\n<ul class=\"sub-menu\">\n\t<li id=\"menu-item-455\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-455\"><a href=\"http://plrg.ics.uci.edu/c11tester/\">C11Tester \u2013 A Tool for Testing C/C++ Atomics in Real World Code</a></li>\n\t<li id=\"menu-item-396\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-396\"><a href=\"http://plrg.ics.uci.edu/software-relaxed-mm/\">Software for Relaxed Memory Models</a></li>\n\t<li id=\"menu-item-83\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-83\"><a href=\"http://plrg.ics.uci.edu/software_page/irvine-research-java-compiler/\">Irvine Research Java Compiler</a></li>\n\t<li id=\"menu-item-77\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-77\"><a href=\"http://plrg.ics.uci.edu/software_page/views/\">Views</a></li>\n\t<li id=\"menu-item-358\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-358\"><a href=\"http://plrg.ics.uci.edu/vigilia/\">Vigilia</a></li>\n</ul>\n</li>\n<li class=\"default-menu\"><a href=\"http://plrg.ics.uci.edu\" title=\"Navigation\">Navigation</a></li></ul></div><!-- .container -->\n\t\t\t\t\t</nav><!-- #access --> \t\t\n\t\t\t\t</header>\n\t\t\n\t\t\t\t<div id=\"main\" class=\"container clearfix\">\n\n<div id=\"container\">\n\t\n\n<div id=\"content\">\t<section id=\"post-42\" class=\"post-42 page type-page status-publish hentry\">\n\t\t<article>\n\n\t\t\t\n\t\t\t<header class=\"entry-header\">\n    \t\t\t<h1 class=\"entry-title\">\n<!--    \t\t\t\tCDSChecker -->\n    \t\t\t</h1><!-- .entry-title -->\n  \t\t\t</header>\n\n  \t\t\t\n  \t\t\t\n  \t\t\t<div class=\"entry-content clearfix\">\n    \t\t\t<h1>CDSChecker: A Model Checker for C11 and C++11 Atomics</h1>\n<p>CDSChecker is a model checker for C11/C++11 which exhaustively explores the behaviors of code under the C/C++ memory model. It uses partial order reduction as well as a few other novel techniques to eliminate time spent on redundant execution behaviors and to significantly shrink the state space. The model checking algorithm is described in more detail in this <a href=\"http://plrg.eecs.uci.edu/publications/c11modelcheck.pdf\">paper</a> (published in OOPSLA &#8217;13):</p>\n<p>It is designed to support unit tests on concurrent data structure written using C/C++ atomics.</p>\n<p>CDSChecker is constructed as a dynamically-linked shared library which implements the C and C++ atomic types and portions of the other thread-support libraries of C/C++ (e.g., std::atomic, std::mutex, etc.). Notably, we only support the C version of threads (i.e.,\u00a0<code>thrd_t</code>\u00a0and similar, from\u00a0<code>&lt;threads.h&gt;</code>), because C++ threads require features which are only available to a C++11 compiler (and we want to support others, at least for now).</p>\n<p>CDSChecker should compile on Linux and Mac OSX with no dependencies and has been tested with LLVM (clang/clang++) and GCC. It likely can be ported to other *NIX flavors. We have not attempted to port to Windows.</p>\n<h2>Getting Started</h2>\n<p>If you haven&#8217;t done so already, you may download CDSChecker using\u00a0<a href=\"http://git-scm.com/\">git</a>:</p>\n<pre><code>  git clone git://demsky.eecs.uci.edu/model-checker.git\r\n</code></pre>\n<p>Source code can also be downloaded via the snapshot links on Gitweb (found in the\u00a0<strong>See Also</strong>\u00a0section).</p>\n<p>Get the benchmarks (not required; distributed separately), placing them as a subdirectory under the\u00a0<code>model-checker</code>\u00a0directory:</p>\n<pre><code>  cd model-checker\r\n  git clone git://demsky.eecs.uci.edu/model-checker-benchmarks.git benchmarks\r\n</code></pre>\n<p>Compile the model checker:</p>\n<pre><code>  make\r\n</code></pre>\n<p>Compile the benchmarks:</p>\n<pre><code>  make benchmarks\r\n</code></pre>\n<p>Run a simple example (the\u00a0<code>run.sh</code>\u00a0script does some very minimal processing for you):</p>\n<pre><code>  ./run.sh test/userprog.o\r\n</code></pre>\n<p>To see the help message on how to run CDSChecker, execute:</p>\n<pre><code>  ./run.sh -h\r\n</code></pre>\n<h2>Useful Options</h2>\n<p><code>-m num</code></p>\n<blockquote><p>Controls the liveness of the memory system. Note that multithreaded programs often rely on memory liveness for termination, so this parameter is necessary for such programs.</p>\n<p>Liveness is controlled by\u00a0<code>num</code>: the number of times a load is allowed to see the same store when a newer store exists&#8212;one that is ordered later in the modification order.</p></blockquote>\n<p><code>-y</code></p>\n<blockquote><p>Turns on CHESS-like yield-based fairness support (requires\u00a0<code>thrd_yield()</code>\u00a0instrumentation in test program).</p></blockquote>\n<p><code>-f num</code></p>\n<blockquote><p>Turns on alternative fairness support (less desirable than\u00a0<code>-y</code>). A necessary alternative for some programs that do not support yield-based fairness properly.</p></blockquote>\n<p><code>-v</code></p>\n<blockquote><p>Verbose: show all executions and not just buggy ones.</p></blockquote>\n<p><code>-s num</code></p>\n<blockquote><p>Constrain how long we will run to wait for a future value past when it is expected</p></blockquote>\n<p><code>-u num</code></p>\n<blockquote><p>Value to provide to atomics loads from uninitialized memory locations. The default is 0, but this may cause some programs to throw exceptions (segfault) before the model checker prints a trace.</p></blockquote>\n<p>Suggested options:</p>\n<blockquote>\n<pre><code>-m 2 -y\r\n</code></pre>\n</blockquote>\n<p>or</p>\n<blockquote>\n<pre><code>-m 2 -f 10\r\n</code></pre>\n</blockquote>\n<h2>Benchmarks</h2>\n<p>Many simple tests are located in the\u00a0<code>tests/</code>\u00a0directory. You may also want to try the larger benchmarks (distributed separately), which can be placed under the\u00a0<code>benchmarks/</code>\u00a0directory. After building CDSChecker, you can build and run the benchmarks as follows:</p>\n<blockquote>\n<pre><code>make benchmarks\r\ncd benchmarks\r\n\r\n# run barrier test with fairness/memory liveness\r\n./run.sh barrier/barrier -y -m 2\r\n\r\n# Linux reader/write lock test with fairness/memory liveness\r\n./run.sh linuxrwlocks/linuxrwlocks -y -m 2\r\n\r\n# run all benchmarks and provide timing results\r\n./bench.sh\r\n</code></pre>\n</blockquote>\n<h2>Running your own code</h2>\n<p>You likely want to test your own code, not just our simple tests. To do so, you need to perform a few steps.</p>\n<p>First, because CDSChecker executes your program dozens (if not hundreds or thousands) of times, you will have the most success if your code is written as a unit test and not as a full-blown program.</p>\n<p>Second, because CDSChecker must be able to manage your program for you, your program should declare its main entry point as\u00a0<code>user_main(int, char**)</code>\u00a0rather than\u00a0<code>main(int, char**)</code>.</p>\n<p>Third, test programs must use the standard C11/C++11 library headers (see below for supported APIs) and must compile against the versions provided in CDSChecker&#8217;s\u00a0<code>include/</code>\u00a0directory. Notably, we only support C11 thread syntax (<code>thrd_t</code>, etc. from\u00a0<code>&lt;thread.h&gt;</code>).</p>\n<p>Test programs may also use our included happens-before race detector by including\u00a0and utilizing the appropriate functions (<code>store_{8,16,32,64}()</code>\u00a0and\u00a0<code>load_{8,16,32,64}()</code>) for storing/loading data to/from non-atomic shared memory.</p>\n<p>CDSChecker can also check boolean assertions in your test programs. Just include\u00a0<code>&lt;model-assert.h&gt;</code>\u00a0and use the\u00a0<code>MODEL_ASSERT()</code>\u00a0macro in your test program. CDSChecker will report a bug in any possible execution in which the argument to\u00a0<code>MODEL_ASSERT()</code>\u00a0evaluates to false (that is, 0).</p>\n<p>Test programs should be compiled against our shared library (libmodel.so) using the headers in the\u00a0<code>include/</code>\u00a0directory. Then the shared library must be made available to the dynamic linker, using the\u00a0<code>LD_LIBRARY_PATH</code>\u00a0environment variable, for instance.</p>\n<h3>Supported C11/C++11 APIs</h3>\n<p>To model-check multithreaded code properly, CDSChecker needs to instrument any concurrency-related API calls made in your code. Currently, we support parts of the following thread-support libraries. The C versions can be used in either C or C++.</p>\n<ul>\n<li><code>&lt;atomic&gt;</code>,\u00a0<code>&lt;cstdatomic&gt;</code>,\u00a0<code>&lt;stdatomic.h&gt;</code></li>\n<li><code>&lt;condition_variable&gt;</code></li>\n<li><code>&lt;mutex&gt;</code></li>\n<li><code>&lt;threads.h&gt;</code></li>\n</ul>\n<p>Because we want to extend support to legacy (i.e., non-C++11) compilers, we do not support some new C++11 features that can&#8217;t be implemented in C++03 (e.g., C++\u00a0<code>&lt;thread&gt;</code>).</p>\n<h2>Reading an execution trace</h2>\n<p>When CDSChecker detects a bug in your program (or when run with the\u00a0<code>--verbose</code>\u00a0flag), it prints the output of the program run (STDOUT) along with some summary trace information for the execution in question. The trace is given as a sequence of lines, where each line represents an operation in the execution trace. These lines are ordered by the order in which they were run by CDSChecker (i.e., the &#8220;execution order&#8221;), which does not necessarily align with the &#8220;order&#8221; of the values observed (i.e., the modification order or the reads-from relation).</p>\n<p>The following list describes each of the columns in the execution trace output:</p>\n<ul>\n<li>#: The sequence number within the execution. That is, sequence number &#8220;9&#8221; means the operation was the 9th operation executed by CDSChecker. Note that this represents the execution order, not necessarily any other order (e.g., modification order or reads-from).</li>\n<li>t: The thread number</li>\n<li>Action type: The type of operation performed</li>\n<li>MO: The memory-order for this operation (i.e.,\u00a0<code>memory_order_XXX</code>, where\u00a0<code>XXX</code>\u00a0is\u00a0<code>relaxed</code>,\u00a0<code>release</code>,\u00a0<code>acquire</code>,\u00a0<code>rel_acq</code>, or\u00a0<code>seq_cst</code>)</li>\n<li>Location: The memory location on which this operation is operating. This is well-defined for atomic write/read/RMW, but other operations are subject to CDSChecker implementation details.</li>\n<li>Value: For reads/writes/RMW, the value returned by the operation. Note that for RMW, this is the value that is\u00a0<em>read</em>, not the value that was\u00a0<em>written</em>. For other operations, &#8216;value&#8217; may have some CDSChecker-internal meaning, or it may simply be a don&#8217;t-care (such as\u00a0<code>0xdeadbeef</code>).</li>\n<li>Rf: For reads, the sequence number of the operation from which it reads. [Note: If the execution is a partial, infeasible trace (labeled INFEASIBLE), as printed during\u00a0<code>--verbose</code>\u00a0execution, reads may not be resolved and so may have Rf=? or Rf=Px, where x is a promised future value.]</li>\n<li>CV: The clock vector, encapsulating the happens-before relation (see our paper, or the C/C++ memory model itself). We use a Lamport-style clock vector similar to [1]. The &#8220;clock&#8221; is just the sequence number (#). The clock vector can be read as follows:Each entry is indexed as CV[i], where\n<pre><code>    i = 0, 1, 2, ..., &lt;number of threads&gt;\r\n</code></pre>\n<p>So for any thread i, we say CV[i] is the sequence number of the most recent operation in thread i such that operation i happens-before this operation. Notably, thread 0 is reserved as a dummy thread for certain CDSChecker operations.</li>\n</ul>\n<p>See the following example trace:</p>\n<pre><code>------------------------------------------------------------------------------------\r\n#    t    Action type     MO       Location         Value               Rf  CV\r\n------------------------------------------------------------------------------------\r\n1    1    thread start    seq_cst  0x7f68ff11e7c0   0xdeadbeef              ( 0,  1)\r\n2    1    init atomic     relaxed        0x601068   0                       ( 0,  2)\r\n3    1    init atomic     relaxed        0x60106c   0                       ( 0,  3)\r\n4    1    thread create   seq_cst  0x7f68fe51c710   0x7f68fe51c6e0          ( 0,  4)\r\n5    2    thread start    seq_cst  0x7f68ff11ebc0   0xdeadbeef              ( 0,  4,  5)\r\n6    2    atomic read     relaxed        0x60106c   0                   3   ( 0,  4,  6)\r\n7    1    thread create   seq_cst  0x7f68fe51c720   0x7f68fe51c6e0          ( 0,  7)\r\n8    3    thread start    seq_cst  0x7f68ff11efc0   0xdeadbeef              ( 0,  7,  0,  8)\r\n9    2    atomic write    relaxed        0x601068   0                       ( 0,  4,  9)\r\n10   3    atomic read     relaxed        0x601068   0                   2   ( 0,  7,  0, 10)\r\n11   2    thread finish   seq_cst  0x7f68ff11ebc0   0xdeadbeef              ( 0,  4, 11)\r\n12   3    atomic write    relaxed        0x60106c   0x2a                    ( 0,  7,  0, 12)\r\n13   1    thread join     seq_cst  0x7f68ff11ebc0   0x2                     ( 0, 13, 11)\r\n14   3    thread finish   seq_cst  0x7f68ff11efc0   0xdeadbeef              ( 0,  7,  0, 14)\r\n15   1    thread join     seq_cst  0x7f68ff11efc0   0x3                     ( 0, 15, 11, 14)\r\n16   1    thread finish   seq_cst  0x7f68ff11e7c0   0xdeadbeef              ( 0, 16, 11, 14)\r\nHASH 4073708854\r\n------------------------------------------------------------------------------------\r\n</code></pre>\n<p>Now consider, for example, operation 10:</p>\n<p>This is the 10th operation in the execution order. It is an atomic read-relaxed operation performed by thread 3 at memory address\u00a0<code>0x601068</code>. It reads the value &#8220;0&#8221;, which was written by the 2nd operation in the execution order. Its clock vector consists of the following values:</p>\n<pre><code>    CV[0] = 0, CV[1] = 7, CV[2] = 0, CV[3] = 10\r\n</code></pre>\n<h2>End of Execution Summary</h2>\n<p>CDSChecker prints summary statistics at the end of each execution. These summaries are based off of a few different properties of an execution, which we will break down here:</p>\n<ul>\n<li>An\u00a0<em>infeasible</em>\u00a0execution is an execution which is not consistent with the memory model. Such an execution can be considered overhead for the model-checker, since it should never appear in practice.</li>\n<li>A\u00a0<em>buggy</em>\u00a0execution is an execution in which CDSChecker has found a real bug: a data race, a deadlock, failure of a user-provided assertion, or an uninitialized load, for instance. CDSChecker will only report bugs in feasible executions.</li>\n<li>A\u00a0<em>redundant</em>\u00a0execution is a feasible execution that is exploring the same state space explored by a previous feasible execution. Such exploration is another instance of overhead, so CDSChecker terminates these executions as soon as they are detected. CDSChecker is mostly able to avoid such executions but may encounter them if a fairness option is enabled.</li>\n</ul>\n<p>Now, we can examine the end-of-execution summary of one test program:</p>\n<pre><code>$ ./run.sh test/rmwprog.o\r\n+ test/rmwprog.o\r\n******* Model-checking complete: *******\r\nNumber of complete, bug-free executions: 6\r\nNumber of redundant executions: 0\r\nNumber of buggy executions: 0\r\nNumber of infeasible executions: 29\r\nTotal executions: 35\r\n</code></pre>\n<ul>\n<li><em>Number of complete, bug-free executions:</em>\u00a0these are feasible, non-buggy, and non-redundant executions. They each represent different, legal behaviors you can expect to see in practice.</li>\n<li><em>Number of redundant executions:</em>\u00a0these are feasible but redundant executions that were terminated as soon as CDSChecker noticed the redundancy.</li>\n<li><em>Number of buggy executions:</em>\u00a0these are feasible, buggy executions. These are the trouble spots where your program is triggering a bug or assertion. Ideally, this number should be 0.</li>\n<li><em>Number of infeasible executions:</em>\u00a0these are infeasible executions, representing some of the overhead of model-checking.</li>\n<li><em>Total executions:</em>\u00a0the total number of executions explored by CDSChecker. Should be the sum of the above categories, since they are mutually exclusive.</li>\n</ul>\n<h2>Other Notes and Pitfalls</h2>\n<ul>\n<li>Many programs require some form of fairness in order to terminate in a finite amount of time. CDSChecker supports the\u00a0<code>-y num</code>\u00a0and\u00a0<code>-f num</code>\u00a0flags for these cases. The\u00a0<code>-y</code>\u00a0option (yield-based fairness) is preferable, but it requires careful usage of yields (i.e.,\u00a0<code>thrd_yield()</code>) in the test program. For programs without proper\u00a0<code>thrd_yield()</code>, you may consider using\u00a0<code>-f</code>\u00a0instead.</li>\n<li>Q: I see an error similar to the following:<br />\nError: assertion failed in mymemory.cc at line 77<br />\nAdd breakpoint to line 45 in file common.cc.A: The model checker likely ran out of snapshotting memory to run your program. This means that your program probably has executions that run forever. Try adding the -b# option with # replaced by a number that specifies a bound on the length of the execution. For example -b200 will limit executions to 200 steps. Alternatively, read the DEBUGGINGNOTES file and use the gdb option to run.sh to get a stack trace and start debugging.</li>\n<li>Deadlock detection: CDSChecker can detect deadlocks. For instance, try the following test program.<br />\n<blockquote>\n<pre><code>./run.sh test/deadlock.o\r\n</code></pre>\n</blockquote>\n<p>Deadlock detection currently detects when a thread is about to step into a deadlock, without actually including the final step in the trace. But you can examine the program to see the next step.</li>\n<li>CDSChecker has to speculatively explore many execution behaviors due to the relaxed memory model, and many of these turn out to be infeasible (that is, they cannot be legally produced by the memory model). CDSChecker discards these executions as soon as it identifies them (see the &#8220;Number of infeasible executions&#8221; statistic); however, the speculation can occasionally cause CDSChecker to hit unexpected parts of the unit test program (causing a division by 0, for instance). In such programs, you might consider running CDSChecker with the\u00a0<code>-u num</code>\u00a0option.</li>\n<li>Related to the previous point, CDSChecker may report more than one bug for a particular candidate execution. This is because some bugs may not be reportable until CDSChecker has explored more of the program, and in the time between initial discovery and final assessment of the bug, CDSChecker may discover another bug.</li>\n<li>Data races may be reported as multiple bugs, one for each byte-address of the data race in question. See, for example, this run:\n<pre><code>$ ./run.sh test/releaseseq.o\r\n...\r\nBug report: 4 bugs detected\r\n  [BUG] Data race detected @ address 0x601078:\r\n    Access 1: write in thread  2 @ clock   4\r\n    Access 2:  read in thread  3 @ clock   9\r\n  [BUG] Data race detected @ address 0x601079:\r\n    Access 1: write in thread  2 @ clock   4\r\n    Access 2:  read in thread  3 @ clock   9\r\n  [BUG] Data race detected @ address 0x60107a:\r\n    Access 1: write in thread  2 @ clock   4\r\n    Access 2:  read in thread  3 @ clock   9\r\n  [BUG] Data race detected @ address 0x60107b:\r\n    Access 1: write in thread  2 @ clock   4\r\n    Access 2:  read in thread  3 @ clock   9\r\n</code></pre>\n</li>\n</ul>\n<h2>See Also</h2>\n<p>The CDSChecker project page:</p>\n<blockquote><p><a href=\"http://demsky.eecs.uci.edu/c11modelchecker.html\">http://demsky.eecs.uci.edu/c11modelchecker.html</a></p></blockquote>\n<p>The CDSChecker source and accompanying benchmarks on Gitweb:</p>\n<blockquote><p><a href=\"http://plrg.eecs.uci.edu/git/?p=model-checker.git;a=summary\">http://plrg.eecs.uci.edu/git/?p=model-checker.git;a=summary</a></p>\n<p><a href=\"http://plrg.eecs.uci.edu/git/?p=model-checker-benchmarks.git;a=summary\">http://plrg.eecs.uci.edu/git/?p=model-checker-benchmarks.git;a=summary</a></p></blockquote>\n<h2>Contact</h2>\n<p>Please feel free to contact us for more information. Bug reports are welcome, and we are happy to hear from our users. We are also very interested to know if CDSChecker catches bugs in your programs.</p>\n<p>Contact Brian Norris at\u00a0<a href=\"mailto:banorris@uci.edu\">banorris@uci.edu</a>\u00a0or Brian Demsky at\u00a0<a href=\"mailto:bdemsky@uci.edu\">bdemsky@uci.edu</a>.</p>\n<h2>Copyright</h2>\n<p>Copyright \u00a9 2013 Regents of the University of California. All rights reserved.</p>\n<p>CDSChecker is distributed under the GPL v2. See the LICENSE file for details.</p>\n<h2>Acknowledgments</h2>\n<p>This material is based upon work supported by the National Science\u00a0Foundation under Grant Nos CCF-0846195, CCF-1217854, CNS-1228995, and\u00a0CCF-1319786.</p>\n<p>Any opinions, findings, and conclusions or recommendations expressed\u00a0in this material are those of the author(s) and do not necessarily\u00a0reflect the views of the National Science Foundation.</p>\n<h2>References</h2>\n<p>[1] L. Lamport. Time, clocks, and the ordering of events in a distributed system. CACM, 21(7):558-565, July 1978.</p>\n    \t\t\t  \t\t\t</div>\n\n  \t\t\t\n<div id=\"comments\" class=\"comments-area\">\n\n\t\n\t\n\t\n</div><!-- #comments .comments-area -->\n\t\t</article>\n\t</section>\n</div><!-- #content --></div><!-- #container -->\n\n\n\t   </div><!-- #main -->\n\n\t   \n\t   \t\n\t   \n\t   <footer id=\"colophon\" class=\"clearfix\">\n\t\t\t\n\n\n<div id=\"site-generator\">\n\t\t\t\t<div class=\"container\"><div style=\"clear:both;\"></div>\n\t\t\t</div><!-- .container -->\n\t\t\t</div><!-- #site-generator --><div class=\"back-to-top\"><a href=\"#branding\">Back to Top</a></div>\t\t</footer>\n\t   \n\t\t\t\n\n\t</div><!-- .wrapper -->\n\n\t \n\n<script type='text/javascript' src='http://plrg.ics.uci.edu/wordpress/wp-includes/js/wp-embed.min.js?ver=5.2.3'></script>\n\n</body>\n</html>", "encoding": "utf-8"}