{"url": "http://www-db.ics.uci.edu/pages/software/htree/htree_README", "content": "\n------------------------------------------------------------\nCopyright 1999, The University of California at Irvine\n------------------------------------------------------------\n\nDESCRIPTION OF SOURCE CODE FILES\n================================\n\nThis software implements the hybrid tree index structure \nas described in [1]. This distribution of the software contains \na total of 26 files: \n\n(1) 12 .C files (HTree.C, Node.C, DataNode.C, \nOFNode.C, MONode.C, HTreeSearch.C, HTreeRangeSearch.C, \nMultiPointQuery.C, Point.C, Rect.C, HTreeTest.C, GenSearchTest.C)\n\n(2) 10 .h files (decl.h, HTree.h, Node.h, DataNode.h, \nOFNode.h, MONode.h, Query.h, MultiPointQuery.h,\nPoint.h, Rect.h)\n\n(3) a makefile\n\n(4) this file (the README)\n\n(5) 1 data file \"CH.16d.asc\" (16-d color histogram, 68041 points) and \n1 query file \"CH.16d.Query\" (250 queries, a random sample of \"CH.16d.asc\"). \n(The format of the data file is explained under \"Building a hybrid tree from scratch\". \nThe query file has the same format.)\n\n\nThe source code of the hybrid tree lies in the\nfiles HTree.C, Node.C, DataNode.C, OFNode.C, MONode.C, \nHTreeSearch.C, HTreeRangeSearch.C and MultiPointQuery.C \n(decl.h, HTree.h, Node.h, DataNode.h, \nOFNode.h, MONode.h, Query.h, MultiPointQuery.h \nare the corresponding header files). The files\nPoint.C and Rect.C (Point.h, Rect.h are the header files)\nimplement point and rectangle classes.\nThe files HTreeTest.C and GenSearchTest.C are the test programs.\nWe have tried this code only on the SUN Sparc platform (running Solaris 2.6) \nand with gcc-2.8.1 compiler.\n\n\nCOMPILING THE CODE\n==================\n\nBefore we explain how to do perform the \nvarious operations on the hybrid tree so\nthat you can write your own application program,\nwe will explain how to compile and run the included\ntest program \"HTreeTest.C\". To compile the code \n(with HTreeTest.C), run \"make\". \n\nCOMPILE TIME PARAMETERS (specified in decl.h)\n=============================================\nBefore we explain how to run the program,\nwe describe the parameters that need to be specified\nat compile time (they are in decl.h). The two main \ncompile-time parameters are the page size\nand the dimensionality of the data. These 2 parameters \nare the first 2 constants defined in decl.h.\n\n#define PGSIZE  4096\n#define NUMDIMS  16            /* number of dimensions */\n\n\nYou do not need to change them for running the test program\non the included dataset (CH.16d.asc) because the dimensionality\nis 16 (but you can change the pagesize if you want). \nBut to run in on some dataset with a different dimensionality, you \nwill have to change the constant and recompile. \n\n\nRUNNING THE CODE\n================\n\nConstructing the tree from the dataset\n--------------------------------------\n\nTo build a hybrid tree from scratch, run\n\"HTreeTest 0 CH.16d.asc HTdump.color\".\nThe above command will construct a hybrid tree from the \ndata file \"CH.16d.asc\" (the format of the data file is explained \nunder \"Building a hybrid tree from scratch\") and dump it into a file \n\"HTdump.color\" (binary file).\n\nOutput\n------\nYou should get an output like this:\n\n\ninserted 0 points \ninserted 1000 points \ninserted 2000 points \ninserted 3000 points \ninserted 4000 points \n.\n.\n<snip>\n.\n.\ninserted 61000 points \ninserted 62000 points \ninserted 63000 points \ninserted 64000 points \ninserted 65000 points \ninserted 66000 points \ninserted 67000 points \ninserted 68000 points \ntotal inserts = 68041 \nTook approx. 35 seconds\ndumped 1879 nodes on disk \nTook approx. 35 seconds\n\n\n\nRunning the queries\n--------------------\nTo run some queries (250 queries) stored in the CH.16d.Query,\nrun \"HTreeTest 1 HTdump.color CH.16d.Query\".\nThe above command will load the hybrid tree\nfrom the file \"HTdump.color\" (into which it was\ndumped after construction) and run the queries\none after another and print out some statistics \n(e.g., average disk accesses, average CPU time etc.).\nCurrently, all the queries are 10-nearest neighbor queries with \nL2 distance function (see the discussion on \"Searching the hybrid tree\" below\nand lines 100-120 in HTreeTest.C). To run some other \ntype of query (e.g., range query), you need to modify the\ntest program based on the discussion in \"Searching the hybrid tree\".\n\n\n\nOutput\n------\nYou should get an output like this:\n\nLoading......\nNumber of empty nodes = 0 \nLoaded 1879 nodes from disk \nLoaded 68041 objects from disk \nTook approx. 2 seconds\nQuery 1: 10 \ndisk acc = 5 time = 0.008223 \n\nQuery 2: 10 \ndisk acc = 3 time = 0.004518 \n\nQuery 3: 10 \ndisk acc = 57 time = 0.062877 \n\nQuery 4: 10 \ndisk acc = 12 time = 0.009754 \n\nQuery 5: 10 \ndisk acc = 31 time = 0.025896 \n\nQuery 6: 10 \ndisk acc = 12 time = 0.012305 \n.\n.\n<snip>\n.\n.\nQuery 241: 10 \ndisk acc = 36 time = 0.032513 \n\nQuery 242: 10 \ndisk acc = 68 time = 0.051635 \n\nQuery 243: 10 \ndisk acc = 31 time = 0.023012 \n\nQuery 244: 10 \ndisk acc = 48 time = 0.033600 \n\nQuery 245: 10 \ndisk acc = 176 time = 0.127336 \n\nQuery 246: 10 \ndisk acc = 23 time = 0.019883 \n\nQuery 247: 10 \ndisk acc = 97 time = 0.063216 \n\nQuery 248: 10 \ndisk acc = 14 time = 0.015109 \n\nQuery 249: 10 \ndisk acc = 27 time = 0.030441 \n\nQuery 250: 10 \ndisk acc = 63 time = 0.054714 \n\nAverage disk access at level 0 = 10.000000 \nAverage disk access at level 1 = 52.459999 \nAverage disk access at level 2 = 7.756000 \nAverage disk access at level 3 = 1.000000 \nAverage disk access (total) = 61.215996 \nAverage time taken for 1st iter : 0.043191 seconds\n\n-------------------------------------------------------------\n\nExplanation of the output\n-------------------------\n\nFor each query, the test program HTreeTest.C prints out the number \nof objects retrieved (10 objects retrieved for all queries since all\nthe queries were 10-NN queries), the number of disk accesses \n(i.e. the number of nodes of the hybrid tree visited, e.g.,\n63 for Query 250) and the CPU time it took\nto execute the query.\n\n\nAt the end of the run, we print out the statistics averaged\nover all the queries. The \"Average disk access at level 0\"\nis the average number of objects retrieved (these are\nNOT index node accesses and hence do not count in the total\nindex node accesses printed as \"Average disk access (total)\").\nThe index node accesses start from level 1 i.e.\nthe \"Average disk access at level 1\" is the average \nnumber of leaf level nodes accessed, the \"Average disk \naccess at level 2\" is the average number of nodes accessed \nat the level just above the leaf level and so on. \nNote the average disk access at the highest level\n(\"Average disk access at level 3\" in this case) should \nalways be 1.00 since there is only one node at the highest\nlevel (the root node) and all queries access that one node.\nThe \"Average disk access (total)\" is the average number of \nthe index nodes visited (summed across all levels). It is the sum of \ndisk accesses at all levels STARTING FROM level 1 (level 0 is NOT counted \nbecause it is the number of objects retrieved and not number of index nodes \nvisited). In this case, \"Average disk access (total)\" is the sum of\naverage disk access at level 1,2 and 3 \n( 52.459999 + 7.756000 + 1.000000 = 61.215996).\n\"Average time taken for 1st iter\" is the average CPU time it took\nto execute each query.\n\n\n\nHow to perform various operations on the hybrid tree\n=====================================================\n\nWe will now explain how to do perform the various operations \non the hybrid tree so that you can write your own application \nprogram or modify the existing test program HTreeTest.C \n(or GenSearchTest.C) to suit your needs. You can use the \ntest program HTreeTest.C as you are reading this to serve \nas an example.\n\n\nBuilding a hybrid tree from scratch\n===================================\nThere are 2 options:\n\n1. You can read the data points one by one from the \ndata file and insert them into the hybrid tree.\nTo read a data point, you can use the Read function of \nthe Point class:\n\nint Point::Read(FILE *fp, int *id)   (see Point.C)\n\nFile pointer fp must point to a beginning of a data record in the data file\nwhere a data record looks like this:\n<id-of-the-point>  <position-of-point-along-dim1> .... \n<position-of-point-along-dimk> \\newline\nid-of-the-point is of type int, rest is of type float.\nThe id argument would contain the id-of-the-point.\n\nOr you can write you own function to read the point\nand construct the point object (especially if \nthe format of the data file is different from above).\n\nTo insert the point into the hybrid tree, see the function\nto insert a point into the hybrid tree, explained below.\n\n\n2. If your data file has the following format -- each\ndata point is one line and the data point is described\nas <id-of-the-point>  <position-of-point-along-dim1> .... \n<position-of-point-along-dimk> -- you can pass the \nname of the file to the hybrid tree constructor along\nwith the maximum number of objects you want to be inserted:\n\nHTree::HTree(char *datafile, int max_inserts) (see HTree.C)\n\nThe first max_inserts objects in the file would be inserted.\nAn example of such a file is CH.16d.asc (containing\n16-d color histograms). \n\nThe test program uses option 2 (see line 211 in HTreeTest.C)\nto construct the tree. (So if you want to use HTreeTest.C for\nsome other data file, make sure that the data file has\nthe above format.)\n\n\nDumping the hybrid tree from memory to disk\n===========================================\n\nvoid HTree::HTreeDump(char *dumpfile) (see HTree.C)\n\nThe tree will dumped in the (binary) file whose name is\npassed as dumpfile. \n\nThe test program uses the above function (see line 216 \nin HTreeTest.C) to dump the tree to disk.\n\n\n\nLoading the hybrid tree from disk to memory\n===========================================\n\nHTree::HTree(char *dumpfile) (see HTree.C)\n\nThe tree will be loaded into memory from the file passed \nas argument (see line 226 in HTreeTest.C).\nHybrid tree uses an optimization called Encoded\nLive Space (ELS) Optimization (see [1] for details).\nThe ELS is created during the loading process:\nthe search functions take advantage of the ELS\nduring search. When the tree is changed, the ELSs\nwould get invalidated -- which means the search\nperformance would deteriorate with time if you are\ndoing a lot of insertions and deletions in the tree.\nIn that case, you can recreate all the ELS using the function:\n\nvoid HTree::ELS()  (see HTree.C)\n\nand restore the performance from time to time.\n\nIf you do all the insertions initially (during the tree\nconstruction phase) and then do only searches (as\nin HTreeTest.C), then you would not need to recreate ELSs\nas they would never get invalidated (since there\nare no insertions after the tree has been loaded into memory\nfrom the dumpfile which is when the ELSs were created).\n\n\nInserting a point into the hybrid tree\n======================================\n\nint HTree::Insert(Point *R, int Tid); (see HTree.C)\n\nInserts the point R with the id Tid into the hybrid tree.\nReturns 1 if the tree increased in height (due to the root\nsplit), returns 0 otherwise\n\n\nDeleting a point from the hybrid tree\n======================================\n\nint HTree::Delete(Point *P, int Tid); (see HTree.C)\n\nDeletes the point P with id Tid from  the hybrid tree.\nReturns 0 if the deletion was successful, 1 otherwise.\n\n\nSearching the hybrid tree\n==========================\n\nThe only interface to searching the hybrid tree\nis the Scan function:\n\nint Scan(Query *query);\n\nThe query object has the following fields, you\nneed to fill up only the relevant fields\ndepending on the ``type'' of the query you are asking.\nSee function SearchTest in HTreeTest.C as an example. \nThe queries in SearchTest are 10-nearest neighbor\nqueries with L2 distance function. To run some other\ntype of query (e.g., range query), you need to modify the\nSearchTest function as explained here.\n\nThe fields are in the query object are:\n(1)int type;                      \n(2)MultiPointQuery startQuery;    \n(3)Result *startResult\nint feedback;\nint getmore;\n(4)int use_function;              \n(5)float (* dist_func) (Point *, Point *);  \n(6)int dist_metric;   // user can either specify a standard dist metric like L1, L2 or LMAX\n                     // dist_metric would be used\n(7) int k;             // the number of answers the user wants, for continue queries\n                     // the number of additional answers she wants\n(8)float range;       // for range queries, all answers within that range will be returned\n(9)int max_returned;  // for range queries, the user wants at most these many answers\n                     // to be returned so that the result buffer is not overwritten\n(10)long *diskacc;     // statistic returned; the number of disk accesses\n                     // to be used to do experiments for writing papers\n\n(11)PQ *startQueue;               // contains the state for the first result\n\n\nYou can do 2 types of queries: range queries and k-NN queries.\nLet me describe what you need to fill up for each of these\ntypes one by one:\n\nRange Queries\n=============\nLet Q be a query.\n1. Set Q.type to  Query::RANGEQUERY.\n\n2. Set Q.feedback to 0. (since you are not using feedback)\n\n3. Set Q.getmore to 0. (for range query, you get all the objects \nat once, so you can't do get more)\n\n4. Set Q.startQuery to the multipoint query you want to ask.\nA multipoint query contains the following fields (see [2] for details):\n(i)   int numPoints;\n(ii)  Point *querypoints;\n(iii) float *weights;\nIt is a generalization of single point queries; so it\ncan used for single point queries as well.\nNote that although the name is startQuery, it \nis the actual query. It has been so named keeping\nthe feedback environment in mind; otherwise, this\nis the only query. You need to allocate \nmemory to store the querypoints and weights.\nFor efficiency, you can preallocate some maximum amount of \nmemory so that you don't have to allocate and deallocate for every query.\n\n4. Set Q.startResult properly. The hybrid tree will populate\nthe startResult with the answers to the query.\nstartResult is a pointer to struct result defined as:\nstruct result\n{\n int numObjects;      // number of objects returned as result\n struct ReturnedObj *objectList; // list of objects returned as result\n};\n\nstruct ReturnedObj\n{\n long id;             // id the object returned\n Point point;         // point corr. to the object returned\n float distance;      // distance from the query point, invalid for bounding box queries\n};\n\nAgain, make sure you allocate objectList. For efficiency,\npreallocate it.\n\n5. Are you going to provide your own distance function\nor use one of the standard Lnorms (L1, L2 or Lmax)? If\nyou want to provide your own distance function, set\nQ.use_function to 1 and Q.dist_func to the pointer to\nyour function. If you want to use L1, L2 or Lmax \n(all dimensions have weight 1.0, so not normalized i.e.\nsum of weights != 1), set Q.use_function to 0 and\nset Q.dist_metric to L1, L2 or LMAX.\n\n6. Set Q.range to the range you want.\n\n7. Set Q.max_returned to the max answers you want: this is used\nto prevent accidental memory overwrite i.e. if you allocated space\nfor the result's  objectList to hold 5000 objects, \nyou can put it here so that your objectList does not overflow.\n\n8. Set Q.disk_acc appropriately. It is\nan array of longs, it is filled up with the total number\nof disk accesses incurred at each level during the \nsearch process: diskacc[0] will contain the total\nnumber of objects seen (which is also returned by each of\nthe functions), diskacc[1] is the total number of leaf nodes\naccessed during the search, diskacc[2] is the number of\nnodes accessed of the next higher level and so on. \nPreallocate for efficiency.\n\nNearest neighbor (k-NN) queries \n===============================\n(see function SearchTest in HTreeTest.C as an example)\n\n1. Set Q.type to  Query::NNQUERY.\n2. Set Q.feedback to 0. (since you are not using feedback)\n3. Set Q.getmore to 0 if you are just starting, set it to 1\nto continue to get some more answers.\n4. Set Q.startQuery, Q.startResult, Q.use_function\nand Q.dist_func/Q.dist_metric as described before.\n5. Set Q.k to the number of top answers you want.\n6. Set Q.disk_acc as discussed before.\n7. Set Q.startQueue to a priority queue which\nwill be used to execute the query. Declare the\nqueue as PQ queue and set Q.startQueue=&queue.\nUses STL to implement the priority queue.\n\n\nBounding box queries\n====================\n\nYou can implement bounding box queries using the range query interface\n(by using the center of the box as the query point and writing\nyour own distance function (weighted Lmax)). If you want to run\na bounding box query by passing the rectangle as a parameter, you\ncan use the function defined in HTreeRangeSearch.C. \n\nint HTree::Search(Rect *R, long *diskacc, Result *res, int max_returned)\n\n\nConstants you may want to change\n================================\n\nThe only constants you may want to change is the page size\nand the dimensionality of the data. These 2 constants\nare the first 2 constants defined in decl.h.\n\n#define PGSIZE  4096\n#define NUMDIMS  16            /* number of dimensions */\n\nYou can change them and recompile. \n\n\n===================================================================\n\nMiscellaneous\n-------------\n\n1. Generalized Search\n   ------------------\nHybrid tree allows the user to define the criteria of\nwhether to explore a node or not (for range search) and/or\ndistance from internal nodes (for k-NN search)\n(via the function: \nUser_Overlap(Rect *rect, float *dist, int type_of_node)).\nThis feature is similar to the \"Consistent\" function of GiST.\nThe user can define separate criteria/distance computation\nfor leaf and internal nodes.  There is a test program\nin the directory called \"GenSearchTest.C\" that shows\nhow to perform generalized search. But I have not integrated\nit with the \"Scan function interface\" defined above yet \n(will do it soon, but till them it is invoked through a \ndifferent interface as shown in \"GenSearchTest.C\").\nFor more detailed explanation, contact kaushik@ics.uci.edu\n\n2.  Relevance Feedback\n    ------------------\nHybrid tree supports efficient relevance feedback for k-NN\nqueries. For more information, see [2].\nThis feature is not present in this version of the code.\nSend me email at kaushik@ics.uci.edu if you need the \nversion with Relevance Feedback.\n\nReferences\n==========\n\n[1] @article{hybridtree,\nauthor=\"K. Chakrabarti and S. Mehrotra\",\ntitle=\"The Hybrid Tree: An Index Structure for High Dimensional Feature Spaces\",\njournal=\"Proceedings of the 1999 IEEE International Conference on Data Engineering\",\nmonth=\"March\",\nyear=\"1999\"\n}\n\n\n[2] @article{qref-tr,\nauthor=\"K. Chakrabarti, K.Porkaew, M. Ortega and S. Mehrotra\",\ntitle=\"Evaluating Refined Queries in Top-$k$ Retrieval Systems\",\njournal=\"Submitted for publication. Available online at http://www-db.ics.uci.edu/pages/publications/index.shtml#TR-MARS-00-05\",\nmonth=\"July\",\nyear=\"2000\"\n}\n\n\n===================================================================\nFor more info on hybrid tree, please see the paper:\nK. Chakrabarti and S. Mehrotra, \nThe Hybrid Tree: An Index Structure for High Dimensional Feature Spaces , \n1999 IEEE International Conference on Data Engineering , March 1999. \nhttp://www-db.ics.uci.edu/pages/publications/index.shtml#TR-MARS-99-01\n\nor contact kaushik@ics.uci.edu / kaushikc@cs.uiuc.edu\n", "encoding": "ascii"}