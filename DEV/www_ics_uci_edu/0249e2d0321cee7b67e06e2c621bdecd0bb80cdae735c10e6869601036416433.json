{"url": "https://www.ics.uci.edu/~aburtsev/143A/2018fall/hw/hw3-system-calls.html", "content": "<HTML>\n<HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">\n<TITLE>143A Principles of Operating Systems</TITLE>\n<LINK HREF=\"./css/main.css\" TYPE=\"text/css\" REL=\"stylesheet\">\n<META NAME=\"Description\" CONTENT=\"Home page of Anton Burtsev.\">\n<META NAME=\"Keywords\" CONTENT=\"Anton Burtsev, Burtsev, Anton, 143A\">\n<SCRIPT SRC=\"./scripts/image_switcher.js\" LANGUAGE=\"JavaScript\"></SCRIPT>\n</HEAD>\n\n<BODY BGCOLOR=\"#FFFFFF\" LEFTMARGIN=\"0\" TOPMARGIN=\"0\" MARGINWIDTH=\"0\" MARGINHEIGHT=\"0\">\n\t<TABLE  ID=\"text\" ALIGN=\"CENTER\" WIDTH=\"600\" BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD>\n\t\t<DIV ID=\"tech_nav\">\n\t\t\t<A HREF=\"../index.html\">Home</A>\n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"30\" ALT=\"\" BORDER=\"0\"/>\n\t\t</DIV>\n\t</TD>\n\t</TR>\t\n\t<TR>\n\t<TD COLSPAN=\"4\" ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\">\n\n\n\t\t<P>\n\n\n<h1>HW3: System Calls</h1>\n\n<p>This homework asks you to first extend the xv6 kernel with a simple\nbacktrace system call.\n\n<p>You will program the xv6 operating system, so you should use the same setup\nas for the <a href=\"hw2-boot-xv6.html\">HW2: Xv6 boot</a>.\n\n<h2>Backtrace system call</h2>\n\nIn this part of the homework you will add a new system call to the xv6 kernel. The main point of the\nexercise is for you to see some of the different pieces of the system call\nmachinery.\n\n<p> Your new system call will print the backtrace of the program, i.e., it's invocation \nhistory on the console. Specifically, if the user program invokes this new system call \nthe system call prints all registers of the user program, and then walks the stack \nframe by frame printing the return addresses saved on the stack on the console.\n\n<p> \nSpecifically, your new system call will have the following interface: \n\n<pre> int backtrace(); </pre> \n\nAnd when you invoke it from your test program <tt>bt</tt> should print something like \nthis on the console: \n\n<pre>\n$ bt\neax:0x16\nebx:0xbfa8\n...\nesp:0x2f9c\neip:0x369\nebp:0x2fa8\n#0  0x4c\n#1  0x6c\n#2  0x16\n#3  0xffffffff\n</pre>\n\nIn order to test your system call you should create a user-level program\n<tt>bt</tt> that calls your new system call. In order to make your new\n<tt>bt</tt> program available to run from the xv6 shell, look at how other\nprograms are implemented, e.g., <tt>ls</tt> and <tt>wc</tt> and make\nappropriate modifications to the Makefile such that the new application gets\ncompiled, linked, and added to the xv6 filesystem. \n\n<p>\nWhen you're done, you should be able to invoke your <tt>bt</tt> program from \nthe shell. \n\nYou can follow the following example template for <tt>bt.c</tt>:\n\n<pre>\n#include \"types.h\"\n#include \"stat.h\"\n#include \"user.h\"\n\nint baz() __attribute__((noinline)); \nint baz() {\n   int a; \n   a = backtrace();\n   return a + uptime();  \n}\n\nint bar() __attribute__((noinline)); \nint bar() {\n  int b; \n  b = baz(); \n  return b + uptime();\n}\n\nint foo() __attribute__((noinline)); \nint foo() {\n  int c; \n  c = bar();\n  return c + uptime();\n}\n\n\nint\nmain(int argc, char *argv[])\n{\n  foo();\n  exit();\n}\n</pre>\n\n<p>\nIn order to make your new <tt>bt</tt> program available to run from\nthe xv6 shell, add <tt>_bt</tt> to the <tt>UPROGS</tt> definition\nin <tt>Makefile</tt>.\n\n<p>Your strategy for making the <tt>backtrace</tt> system call should be to clone all of the\npieces of code that are specific to some existing system call, for example the\n\"uptime\" system call or \"read\". You should grep for uptime in all the source files, using\n<tt>grep -n uptime *.[chS]</tt>.\n\n<h2>Some hints</h2>\n\n<p> It's convenient to implement the body of the <tt>backtrace()</tt> system call in the\nsyscall.c file. Remember that xv6 saves user registers in the trap frame data structure \nduring the system call invocation. Xv6 user programs are compiled with the stack frame, \nand hence if you review the calling convention lecture, you'll be able to implement the logic \nof unwinding the stack. \n\n<h2>Extra credit (10%): Unwind the stack of the program inside the kernel</h2>\n\n<p> Change your <tt>backtrace()</tt> system call to unwind the kernel stack as well. \n\n<h2>Extra credit (5%): Maybe you can come up with a way of unwinding the stack of a program that \ndoes not maintain the stack frames?</h2>\n\n<p> Hint: your implementation does not have to be completely accurate, but should be useful for debugging. \n\n<h2>Extra credit (15%): implement ps</h2>\n\nImplement the <tt>ps</tt> tool that lists all processes running on the system.\nFor that you should implement yet another system call <tt>getprocinfo()</tt> that returns information\nfor a process. Specifically, your new system call will have the following interface: \n\n<pre> int getprocinfo(int proc_num, struct uproc *up); </pre> \n\nWhere proc_num is the process number in the <tt>ptable.proc[NPROC]</tt> array of all possible processes\nand <tt>struct uproc</tt> is a structure that describes the process, i.e., contains the following\ninformation about the process: process name, process id, parent process id,\nsize of process memory, process state, whether process is waiting on a channel,\nand whether it's been killed. \n\n<p>\nYou will have to define the <tt>struct uproc</tt> and implement the ps utility\nby querying the system repeatedly about all possible processes in the system, i.e., all elements \nof the <tt>ptable.proc[NPROC]</tt> array.\n  \nYou should create a user-level program that calls your new <tt>getprocinfo()</tt> system\ncall.\n\n<p> When you're done, typing <tt>ps</tt> to an xv6 shell prompt should print\nall processes running in the system and information about them. \n\n\n\n<div class=\"question\"> <p><b>Submit</b> <p>Submit your answers on Canvas <a href=\"https://canvas.eee.uci.edu/courses/12602\">HW3 System calls</a> as a compressed tar file of your xv6\nsource tree (after running make clean). You can use the following command to create a compressed tar file (if you submit extra credit assignments, put a short hw3.txt readme file \ndescribing what you've done inside your archive). \n<pre>\nopenlab$ cd xv6-public\nopenlab$ make clean\nopenlab$ cd ..\nopenlab$ tar -czvf hw3.tgz xv6-public\n</pre>\n\n\n</div>\n\n\t</TD>\t\t\t\n\t</TR>\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD COLSPAN=\"4\">\n\t\t<DIV ID=\"tech\">Updated: November, 2018</DIV>\n\t</TD>\n\t</TR>\n\t</TABLE>\n</BODY>\n</HTML>\n\n\n", "encoding": "ascii"}