{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/graphs.txt", "content": "\t\t\t\tGraphs\r\n\r\nThe mathematical theory of graphs was first developed by the famous Swiss\r\nmathematician Leonard Euler (pronounced like \"Oiler\") in 1735. It was motivated\r\nby a desire to solve the \"Bridges of Konigsberg\" problem. A brief introduction\r\nto this problem and a graphic for it appears first in the graph.pdf\r\naccompanying this lecture. We will start our discussion of Graphs by\r\nintroducing this problem, learning to represent it as a graph, and then\r\npartially solving the problem.\r\n\r\n  In Konigsberg, Germany, a river ran through the city such that in its center\r\n  was an island, and after passing the island, the river broke into two parts.\r\n  Seven bridges were built so that the people of the city could get from one\r\n  part to another (see graphic). The people wondered whether or not one could\r\n  walk around the city in a way that would involve crossing each bridge exactly\r\n  once. It doesn't matter where the people started and stopped.\r\n\r\nEuler proved that no such tour (now called an Euler tour or Euler path) was\r\npossible in Konigsberg. A similar problem is known as \"The Traveling Salesman\"\r\nproblem, in which the traveler must end up at the same place he/she started\r\n(and visit every node exactly once: that is called a hamiltonian path): often it\r\nalso involves another criteria: minmizing the distance traveled. It is a much\r\nharder problem to solve.\r\n\r\nUsing some of the terminology that we will learn below, the relevant theorems\r\nare:\r\n\r\nTheorem 1: If an undirected graph has more than two nodes with an odd degree,\r\n      then it does not have an Euler path.\r\n \r\nTheorem 2: If an undirected graph has two nodes or fewer with an odd degree,\r\n      then it has at least one Euler path. \r\n\r\nIt is interesting that local properties (the degrees of the nodes) determine\r\nwhether or not some global property (Euler path) is possible. Although this\r\ninformation tells whether or not a Euler tour exist, it does not tell us how\r\nto actually construct a path/tour: an algorithm to find a tour has complexity\r\nO(E) where E is the number of edges (one way to measure the size of a graph).\r\n\r\nMathematically, Graph theory is a sub-area in the Topology (which generalizes\r\nGeometry): topology is concerned less with distance and angles and more with\r\nconnectedness; for example, the triangle inequality for distance (d is the\r\ndistance function) - d(a,b) + d(b,c) >= d(a,c) - is not necessarily true in\r\ngraphs.\r\n        10\r\n    a----->c\r\n     \\     ^\t\td(a,b) + d(b,c) = 5\r\n    2 \\   /3   \t\td(a,c)          = 10\r\n       v /\r\n        b\r\n\r\nFundamentally Graphs consists of nodes (aka vertices) and edges (aka arcs).\r\nNodes are typically labelled by some string that identifies them; edges are\r\noften labelled by the value of the edge. For example, we can construct a graph\r\nof airline fares, where each node is an aiport and each edge is the cost from\r\nflying from the origin airport to the destination airport. Such a structure\r\nwould be useful to determine the (minimum) cost of a trip between any 2\r\nairports, whether or not they are directly connected (get from A to B by taking\r\nflights whose total cost is minimized: note that cost to travel from airport A\r\nto B, and then B to C, might be less than the cost to traver directly from A to\r\nC, which shows the triangle inequality -see above- doesn't necessarily hold for\r\ngraphs ....or airfares).\r\n\r\nWe can omit the edge values if we are concerned only whether or not we can fly\r\nfrom the origin airport to the destination airport: represented by whether or\r\nnot there is an edge between them). Likewise we can use an edge value that is a\r\npair<Time,Time> where each element in the pair gives a departure and arrival\r\ntime (so that we can actually schedule trips through intermediate airports by\r\nchoosing particular flights whose times allow connections to be made). So,\r\nalthough edge values that are single numbers are common and important, edge\r\nvalues can be much more general. When we show implementations of the Graph data\r\ntype, its class will be templated by the type of value stored for each edge.\r\n\r\nMany problems can be encoded into graphs that represent them, and the solved by\r\nusing well-known/efficient graph algorithms. There are large books written\r\nentirely on the subject of graph theory and graph algorithms, and UCI has an\r\nadvanced ICS course (CS 163) focussing on graphs and graph algorithms.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTechnical Terms\r\n\r\nLet's pause here to define some more important graph terms, beyond the nodes\r\nand edges discussed above.\r\n\r\nIn a \"directed graph\" (aka digraph, the kind we will mostly study), edges have a\r\ndistinguishable \"origin\" and \"destination\" node; an edge is written as an arrow\r\nfrom its origin to its destination. A digraph might contain just one edge\r\nbetween two nodes, or it might contain two: one from the first to the second,\r\nand one back from the second to the first (with each edge associated with its\r\nown value). For example, in a graph whose nodes are street corners and whose\r\nedge values are the times to travel between them (a digraph: something a GPS\r\nmust represent and use to solve minimum-time route problems) a one-way street\r\nwill have one edge between the nodes; a two-way street will have two edges (one\r\ngoing each way: travel times might be different, if not always, at different\r\ntimes of the day because of commuter traffic).\r\n\r\nInstead of allowing multiple edges from one node to another, we can specify a\r\ndata structure for the edge that allows multiple values.\r\n\r\nThe in-degree of a node is a count of the number of edges having this node as\r\ntheir destination; likewise, the out-degree of a node is a count of the number\r\nof edges having this node as their origin. The degree of a node is the sum of\r\nits in-degree and out-degree. A node is considered a \"source\" in a graph if it\r\nhas in-degree of 0 (no nodes have a source as their destination); likewise, a\r\nnode is considered a \"sink\" in a graph if it has out-degree of 0 (no nodes have\r\na sink as their origin). \r\n\r\nIn an \"undirected graph\", there can be only one edge/value between any pair of\r\nnodes: each node serves as both the origin and destination of that edge. For an\r\nundirected graph, the in-degree, out-degree, and degree are all the same. We can\r\nuse a digraph to represent an undirected graph by using two edges (each with\r\nthe same value) to connect any two nodes.\r\n\r\nA directed graph is \"weakly-symmetric\" if when there is an edge from node1 to\r\nnode2, then there also is an edge from node2 to node1; likewise, a directed\r\ngraph is \"strongly-symmetric\" if when there is an edge from node1 to node2,\r\nthen there also is an edge from node2 to node1 with the associated values for\r\nthese edges equal.\r\n\r\nA \"subgraph\" of a graph contains a subset of its nodes and edges. The \"natural\r\nsubgraph\" of a graph (containing a certain subset of nodes) includes all the\r\nedges in the graph that have a node in this subset as both an origin and\r\ndestination node. The \"natural subgraph\" of a graph (containing a certain\r\nsubset of edges) includes all the nodes in the graph that are endpoint of any\r\nedge is the subset.\r\n\r\nWe have used graphs, informally, in programming assignment #1. There, we\r\nrepresented a digraph by a map whose key is the name of an origin node and\r\nwhose value is the set of names of all the destination nodes reached by its\r\nedges. In this representation, we omitted the value for the edges and it was\r\nnot easy/efficient to find the nodes leading into a node: finding the origin\r\nnodes of a destination node. Both of these deficiencies are removed in the\r\nactual graph classes we will implement.\r\n\r\nA \"path\" in a graph is a sequence of nodes n1, n2, ..., nx, such that there is\r\nan edge from n1 to n2, from n2 to n3, etc. to nx. Equivalently we can represent\r\na path as a sequence of edge e1, e2, ... en such that the destination node of\r\ne(sub i) is the original node of e(sub i+1).\r\n\r\nThe \"transitive closure\" of a graph is a graph with the same nodes, such that if\r\nthere is ANY path from node1 to node2 in the original graph, there is an edge\r\ndirectly connecting node1 to node2 in the transitive closure graph; the value\r\non this edge is often related to the values on the path: one useful way to do\r\nthis is to assign the value of this edge to be the minimum sum of the edge\r\nvalues, representing the minimim-sum path between the nodes.\r\n\r\nA graph is called \"cyclic\" if it has at least one path in the graph that\r\ncontains the same node twice. Such a path is called a \"cycle\". Likewise, if a\r\ngraph contains no cycles, the graph is called \"acyclic\" (aka \"noncyclic\").\r\n\r\nA graph is \"connected\" if there is a path between every two nodes. Typically we\r\ndiscuss connectedness in terms of an undirected graph. If a graph is not\r\nconnected, it can be decomposed into its \"connected components\": each component\r\nis the largest subgraph that is connected. Connectedness is an Equivalence\r\nrelation: (1) every node is connected to itself; (2) if node a is connected to\r\nnode b then node b is connected to node a; (3) if node a is connected to node b\r\nand node b is connected to node c, then node a is connected to node c. This\r\nmeans that if two components include an edge between any of their nodes, then\r\nthey can be merged into a larger component. When we discuss how to compute\r\nconnected components, the Equivalence data type that we have discussed (and you\r\nwill implement in a quiz) will play a major part in the algorithm.\r\n\r\nA \"spanning tree\" is an acyclic/connected undirected graph that represents an\r\nN-ary tree; we can choose any node as the root. Typically, there are many\r\nspanning trees for a graph. A \"minimum spanning tree\" is the spanning tree that\r\nminimizes the sum of the values associated with all the edges contained in the\r\nspanning tree. We can represent a project to lay fiber optic cables between N\r\ncities by a graph: each city is a node and the edges between cities are the\r\ncost of laying the fiber optic cable. The minimum spanning tree is the minimum\r\ncost to lay enough fiber optic cable so that there is a path between any two\r\ncities. We will discuss an algorithm to solve this problem easily, relying on\r\nefficient implementations of the PriorityQueue and Equivalence relation data\r\ntypes.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nAn Example Graph\r\n\r\nThe second example in the graph.pdf accompanying this lecture represent some\r\nairports and the edges represent flights from one airport to another. The edge\r\nvalues represent the mileage for each flight (or, they could represent\r\nthe cost of an airplane ticket for that flight, the amount of time each flight\r\ntakes, etc). This graph is strongly symmetic; rather than showing two edges\r\nconnecting each pair of nodes, we show only one (double-arrowed) edge. While\r\nmileage has this property, other edge values (cost, travel time, etc.) might\r\nnot. This graph is taken from the excellent book: Goodrich (a faculty member at\r\nUCI) and Tamassia, Data Structures and Algorithms in Java, John Wiley & Sons,\r\n2010 (it has since been updated).\r\n\r\nLet's state some facts about this tree using some of the terminology defined\r\nabove.\r\n\r\nThere is a node named SFO representing San Francisco.\r\n\r\nThere is an edge from the node named SFO (origin) to the node named BOS\r\n(destination) -and vice versa- that has the value 2704.\r\n\r\nThe graph is stongly symmetric (so, really it is an undirected graph).\r\n\r\nThe graph is cyclic; in fact, not only does it have many cycles, it is\r\nconnected: there is a path from every node to every other node.\r\n\r\nIt has a natural subgraph (for ORD, PVD, JFK) that is is also connected; it has\r\na natural subgraph (SFO, MIA, PVD) that is not connected: in fact, such a\r\nnatural subgraph contains no edges.\r\n\r\nA similar but much more extensive graph is used as the underlying data\r\nstructure in Mapquest or GoogleMaps, web sites that plan minimal travel routes,\r\nincluding computing the expected amount of travel time.\r\n\r\nNote that real graphs might model one-way streets (so there may be an edge\r\n-a street that one can travel- from corner1 to corner2 but not vice versa).\r\nAlso, some roads may be partitioned into more lanes going one way than the\r\nother, so although there are edges going each way, their values might be\r\ndifferent. These program can take into account what time you are traveling (in\r\nsome places, traffic patterns vary tremendously from the norm during rush\r\nhours); in fact, if billions of sensors are placed on roads throughout the US,\r\nthey could report traffic slowdowns to these programs, which could contact you\r\nin your car, and automatically reroute you to avoid such delays. Or, if cars\r\n(or the cell phones of occupants) report their position and speed to a website,\r\nwe would not need road sensors.\r\n\r\nGraphs can also easily model the servers (nodes) and transmission lines (edges,\r\nwith their transmission speeds/capacities -bandwidth- indicated by their\r\nvalues) of the internet. We can ask questions like what is the minimum time it\r\nwould take to transmit a large number of web pages from one server to another\r\nusing all the paths available, not exceeding the bandwidth of any transmission\r\nline. This problem, a bit beyond the scope of this course, was originally\r\nsolved by the Ford-Fulkerson algorithm, and improved by the Edmonds-Karp\r\nalgorithm, whose complexity class is O(n e^2), where n is the number of nodes\r\nand e is the number of edges respectively in the graph. \r\n\r\n------------------------------------------------------------------------------\r\n\r\nGraph Metrics\r\n\r\nWe will discuss that the minimum and maximum number of edges in a graph with\r\nN nodes (the minimum is 0 edges - no nodes connected; the maximum is N^2 edges\r\n- every node has an edge to every node, including itself), and use the terms\r\n\"sparse\" and \"dense\" to discuss graphs whose nodes have O(N) and O(N^2) edges\r\nrespectively.\r\n\r\nAlso, we can ask how many structurally different graphs there are with N nodes\r\n(we asked this same questions for linked lists and trees): for directed graphs\r\nthat allow an edge from a node to itself, there are (2^N)^N different graphs,\r\nor 2^(N^2): Each node in an N-node directed graph has 2^N different possible\r\npatterns of out-edges (yes/no to each of the other N-1 nodes and itself) and\r\nthere are N nodes each having its own pattern. Think of the pattern for node 0\r\nas representing one subset of the values 1 through N (a number is in the subset\r\nif node 0 has an out edge to that node): there are 2^N different subsets of N\r\nnumbers.\r\n\r\nFor example, a 4 node graph (say nodes A, B, C, and D) a given node A, can have\r\n1 way of no out-edges, 4 ways of 1 out-edges (to A, B, C, or D), 6 ways of 2\r\nout-edges (to A and B, to A and C, to A and D, to B and C, to B and D, or to C\r\nand D), 4 ways of 3 out edges (to A, B, and C, to A, B, and D, to A, C, and D,\r\nand to B, C, and D), and 1 way of 4 out edges (to A, B, C, and D) for a total\r\nof 16 (= 2^4). Each of the 4 nodes can have the same 16 possible patterns of\r\nout-edges, so there are 16^4 (63,536) different graphs, which is also 2^16\r\n(= (2^4)^4.\r\n\r\nSo for 10 nodes there are 2^100 different graphs or (2^10)^10 or about 10^30\r\ndifferent graphs. For 1000 nodes there are 2^1,000,000 different graphs or\r\n(2^10)^100,000, or about 10^300,000 different graphs (recall there are about\r\n10^68 to 10^72 atoms of matter in the known universe; so, 10^300,000 is\r\nunimagineably larger). So, the number of graphs grow much faster than the\r\nnumber of lists (all N value lists are the same) and the number of trees\r\n(4^N/sqrt(pi*N^3)) whose exponent is just N not N^2.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nStoring/Manipulating Graphs\r\n\r\nThe most fundamental question we can ask about a graph is (a) whether there is\r\nan edge from node A to node B (and if there is, what is its value). Another\r\nimportant question is, (b) given node A, what are all the edges whose source is\r\nA (or edges whose destination is A).\r\n\r\nThere are a few standard way to store information about a graph so that we can\r\nanswer these questions efficiently.\r\n\r\n1) A MATRIX, with N rows and N colums (one for each node in the graph) whose\r\nvalues (Ath row and Bth column) stores nothing (there is no edge) or the value\r\non the edge from node A to B in this graph. In a directed graph we would store\r\nall N^2 values, and the value in row A and column B might be different than the\r\nvalue in row B and column A. In an undirected graph, we could just store the\r\n\"upper triangular part\" since the value at row A and column B is the same as\r\nthe value in row B and column A: so lookup the value in row min(A,B) and column\r\nmax(A,B). To answer question (a) is O(1) and to answer question (b)\r\nis O(N) - scan one entire row or column in the matrix. Note that a matrix\r\nrequires O(N^2) storage, even if the graph is sparse and contains only O(N)\r\nedges.\r\n\r\n2) An array with N rows (one for each node in the graph) with each index i\r\nstoring a linked list of edges values/destination nodes whose origin node is\r\nnumbered i. This is called an ADJACENCY LIST: each node stores a reference to\r\na list of nodes reachable from it. To answer question (a) we go to the index\r\nfor node A and traverse all the values in the linked list looking for B. So to\r\nanswer question (a) is O( out-degree(A) ) and to answer question (b) is O(1)\r\nsince the reference in a row stores a list to exactly those nodes that are\r\ndestinations of node A. In a sparse graph out-degree(i) is O(1) and in a dense\r\ngraph out-degree(i) is O(N).\r\n\r\n3) A HashMap with M keys (M is the number of edges in the graph; each key is a\r\npair of nodes) and each key is associated with the value of the edge between\r\nthose nodes; and, a second HashMap with N keys (one for each node in the graph)\r\nand each key is associated with a set of edges having that node as their origin.\r\nTo answer question (a) we just do a map lookup of the edge, which is O(1). To\r\nanswer question (b) we do a map lookup of the node, which again is O(1).\r\n\r\nWe will add a Graph class to our standard Data Types that has many more\r\ninteresting commands and queries. To implement all operations efficiently, we\r\nwill store avariety of sets in the map from nodes to \"information\" connected to\r\na node: in/out edges and in/out nodes) to allow quick execution of these useful\r\nmethods. This will be done in a HashGraph, which is Programming Assignment #5.\r\n\r\nHere is a quick overview of what we will be able to do with Graphs:\r\n\r\nadd a node, add an edge, remove a node, remove an edge\r\nget a count of the nodes and a count of the edges\r\ncheck whether a graph has a node, has an edge, and get the value of an edge\r\nfind the in-degree, out-degree, and the degree of a node\r\niterate over all nodes and all edges in the graph\r\niterate over all out-nodes, in-nodes, out-edges, and in-edges of any given node\r\nprint a graph into a file and load a graph from a file\r\n", "encoding": "ascii"}