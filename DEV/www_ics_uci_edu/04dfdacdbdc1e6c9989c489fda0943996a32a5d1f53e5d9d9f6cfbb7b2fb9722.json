{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/TkinterApp/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: A Tkinter Application</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: A Tkinter Application</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Having seen some of the basics of how the <b>tkinter</b> library works, and noting the similarities between what we saw and how PyGame works, we are ready to embark on building a <b>tkinter</b> application.  Setting up a <b>tkinter</b> application requires three basic tasks:</p>\r\n\r\n<ol>\r\n  <li>Creating the widgets we'll need in our window.</li>\r\n  <li>Specifying how those widgets will participate in a layout (i.e., Where should they be displayed, and how does that change as the size of the window changes?).</li>\r\n  <li>Decide what events we need to handle and set up our event handlers to be notified when they occur.</li>\r\n</ol>\r\n\r\n<p>As we did when we wrote PyGame-based applications, we should tend to want to arrange all of this in a class, an object of which represents one instance of our application.  The <b>__init__()</b> method can set everything up, a <b>run()</b> method can be called to allow <b>tkinter</b> to take charge (by calling <b>mainloop()</b> on our <b>Tk</b> object), and handlers for various events will be additional (private) methods in the same class.</p>\r\n\r\n<p>Also, as we did with PyGame, we should want to keep the \"model\" and the \"view\" separate.  Even though we're using a different library for it, we're still writing a program with the same basic structural characteristics.  There is code that is meant to control how the program looks and how the user interacts with it; that's the view.  There is code that is meant to embody how the program works internally &mdash; the details of the problem we're solving &mdash; and that's the model.</p>\r\n\r\n<p>Model/view separation leads to all kinds of benefits, not the least of which is it also opens an avenue to using the <a href=\"../TestDrivenDevelopment\">test-driven development techniques</a> we learned previously.  While <b>tkinter</b> is not designed in a way that would make it easy for us to write automated tests for things like the placement of buttons in a window, the things we're most interested in testing &mdash; where the majority of the complexity in a real application with a graphical user interface tend to lie &mdash; are the \"guts\", anyway.  If the model is kept completely separate, with no interaction with <b>tkinter</b> and designed in a way that is automatically testable, we'll have no problems approaching it using a test-driven development style.  The view, on the other hand, can be built and tested the \"old fashioned\" way, which is to say that we'll build it and interact with it manually to make sure it's working properly.</p>\r\n\r\n<p>First, though, there are a couple of additional bits of Python we're going to need on our journey.  Those are summarized below.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The implications of functions in Python being objects</p>\r\n\r\n<p>We've seen previously that functions in Python are objects.  This allows us to store them in variables, pass them as parameters, and so on.  For example, if we have this function that squares a number:</p>\r\n\r\n<blockquote><pre>\r\ndef square(n: 'number') -> 'number':\r\n    return n * n\r\n</pre></blockquote>\r\n\r\n<p>along with this function that takes a one-argument function as a parameter, applies it to every element of a list, and returns a list of the results:</p>\r\n\r\n<blockquote><pre>\r\ndef apply_to_all(f: 'one-argument function', elements: list) -> list:\r\n    results = []\r\n\r\n    for element in elements:\r\n        results.append(f(element))\r\n\r\n    return result\r\n</pre></blockquote>\r\n\r\n<p>then we could square all of the elements of a list by simply calling <b>apply_to_all()</b> and passing the <b>square()</b> function to it as a parameter.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>L = [1, 2, 3, 4, 5]</b>\r\n&gt;&gt;&gt; <b>apply_to_all(square, L)</b>\r\n[1, 4, 9, 16, 25]\r\n</pre></blockquote>\r\n\r\n<p>There's a critically important piece of syntax here.  When we passed the <b>square()</b> function as a parameter, we didn't follow it with parentheses; we simply named it.  This is because we didn't want to call the function and pass its result to <b>apply_to_all()</b>; instead, we wanted to pass <i>the function itself</i>, with the understanding that <b>apply_to_all()</b> was going to call it for us (once for each element of the list).  The expression <b>square(3)</b> calls the square function and passes the argument <b>3</b> to it and evaluates to the function's result; the expression <b>square</b> evaluates to the function itself, an object that we can call later by following it with parentheses and passing it an argument.</p>\r\n\r\n<p class=\"subtitle\">Functions that build and return functions</p>\r\n\r\n<p>The fact that functions are objects &mdash; just like strings, lists, integers, and so on &mdash; implies that we can pass them as arguments to other functions, as we did in the previous section.  This isn't considered special in Python, and it's not an exception to any rule.  It's simply a consequence of two facts:</p>\r\n\r\n<ol>\r\n  <li>You can pass objects as arguments to functions.</li>\r\n  <li>Functions are objects.</li>\r\n</ol>\r\n\r\n<p>If functions are objects, then it stands to reason that we should be able to use them in other ways that objects are used.  Not only can you pass objects as arguments, but you can also return them from functions.  (In fact, in Python, <i>all</i> functions return an object.  Even the ones that don't reach a <b>return</b> statement will return an object called <b>None</b>.)</p>\r\n\r\n<p>So, if you can return objects from functions, can you return <i>functions</i> from functions?  The answer is an unqualified \"Yes!\"  Functions are objects.  You can return objects from functions.  Therefore, you can return functions from functions.</p>\r\n\r\n<p>But why would you ever want to return a function from a function?  What functions do is automate a task.  You give them arguments and they give you a result.  If you wanted to automate the task of <i>building functions</i> &mdash; because you wanted to build lots of similar functions that were different in only a small way &mdash; you could do so by writing a function that takes whatever arguments are necessary to differentiate the functions from each other, build one of them, and return it to you.</p>\r\n\r\n<p>As an example, imagine you wanted to write a collection of functions that each took a string as an argument and printed that string a certain number of times.  One of the functions prints it once; one of the functions prints it twice; and so on.  (You could, of course, just write a function that takes an argument specifying the number of times you want to print it, but remember the overall goal here: We write to write event-handling functions in <b>tkinter</b>, in which case we don't have control over what arguments these functions are allowed to take.  The \"command\" function associated with a button must accept no arguments, because <b>tkinter</b> will never pass it any.)  Here's one way to do that.</p>\r\n\r\n<blockquote><pre>\r\ndef make_duplicate_printer(count: int) -&gt; 'function(str) -&gt; None':\r\n    def print_duplicates(s: str) -&gt; None:\r\n        for i in range(count):\r\n            print(s)\r\n\r\n    return print_duplicates\r\n</pre></blockquote>\r\n\r\n<p>What's going on here?  Let's break it down a bit.</p>\r\n\r\n<ul>\r\n  <li>First of all, we need to be sure we all agree on what a <b>def</b> statement really does.  It really does two things: Creates a function and then stores it in (more or less) a variable.  When we do that at the \"top-level\" of a module (i.e., not inside of any functions or classes), then we've stored the function globally within that module.  When we do that within a class, we've stored the function as a method in that class.  When we do it within another function, we've stored the function <i>as a local variable in that function</i>.</li>\r\n  <li>So, the first thing <b>make_duplicate_printer</b> does when you call it is create a new function and store it in a local variable called <b>print_duplicates</b>.  The function it creates takes a string argument called <b>s</b> and returns no value.</li>\r\n  <li>Notice how the <b>print_duplicates</b> function uses the variable <b>count</b>, which is actually one of the arguments of <b>make_duplicate_printer</b>, the function that <b>print_duplicates</b> is defined in.  That's not as crazy as it looks; that's perfectly legal.  The reason is that <b>print_duplicates</b> doesn't exist until <b>make_duplicate_printer</b> is called, because it's <b>make_duplicate_printer</b> that builds it.  At the time <b>make_duplicate_printer</b> is building <b>print_duplicates</b>, there will be a value of <b>count</b> &mdash; this only happens during a call to <b>make_duplicate_printer</b>.  So any variable available to <b>make_duplicate_printer</b> is also available to <b>print_duplicates</b>.</li>\r\n  <li>Finally, having built the new function &mdash; and note that this will be a separate function every time <b>make_duplicate_printer</b> is called &mdash; it will then be returned to the caller of <b>make_duplicate_printer</b>.</li>\r\n</ul>\r\n\r\n<p>How do we use <b>make_duplicate_printer</b>?</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>make_duplicate_printer(3)</b>\r\n&lt;function make_duplicate_printer.<locals>.print_duplicates at 0x00000168A5171E18&gt;\r\n&gt;&gt;&gt; <b>x = make_duplicate_printer(3)</b>\r\n&gt;&gt;&gt; <b>type(x)</b>\r\n&lt;class 'function'&gt;\r\n&gt;&gt;&gt; <b>x('Boo')</b>\r\nBoo\r\nBoo\r\nBoo\r\n&gt;&gt;&gt; <b>make_duplicate_printer(4)('Boo')</b>\r\nBoo\r\nBoo\r\nBoo\r\nBoo\r\n</pre></blockquote>\r\n\r\n<p>We can store the result of <b>make_duplicate_printer</b> in a variable.  Notice that if we ask its type, we see that it's a function.  And, since it's a function, we can call it by following its name with parentheses and passing it an argument.  That's even true in the last example, where we do all of this in a single expression: ask <b>make_duplicate_printer</b> to build us a function, then call that resulting function.</p>\r\n\r\n<p class=\"subtitle\">Methods are functions, but they can become bound methods</p>\r\n\r\n<p>As we've seen, classes contain methods, which are called on objects of that class.  For example, suppose we have this class, similar to one from a previous code example.</p>\r\n\r\n<blockquote><pre>\r\nclass Counter:\r\n    def __init__(self):\r\n        self._count = 0\r\n\r\n    def count(self) -> int:\r\n        self._count += 1\r\n        return self._count\r\n\r\n    def reset(self, new_count: int) -> None:\r\n        self._count = new_count\r\n</pre></blockquote>\r\n\r\n<p>Given that class, we've seen before that we can call its methods in one of two ways:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>c = Counter()</b>\r\n&gt;&gt;&gt; <b>c.reset(3)</b>\r\n&gt;&gt;&gt; <b>Counter.reset(c, 3)</b>\r\n</pre></blockquote>\r\n\r\n<p>The call <b>c.reset(3)</b> is the typical way we write a call to a method.  This says \"I want to call the <b>reset()</b> method <i>on</i> the object <b>c</b>.\"  However, Python internally translates the call to the other notation we saw, <b>Counter.reset(c, 3)</b>, which we don't normally write, but which makes clearer the relationship between the arguments to the call and the parameters of the method: <b>c</b> is assigned into <b>self</b> because it's the first argument that was passed, while <b>3</b> is assigned into <b>new_count</b> because it's the second.</p>\r\n\r\n<p>But what if we leave out the parentheses, like we did with the <b>square()</b> function previously?  Then things get more interesting.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>Counter.reset</b>\r\n&lt;function Counter.reset at 0x02E23030&gt;\r\n&gt;&gt;&gt; <b>c.reset</b>\r\n&lt;bound method Counter.reset of &lt;__main__.Counter object at 0x02E21670&gt;&gt;\r\n</pre></blockquote>\r\n\r\n<p>The funny-looking hexadecimal numbers specify where the objects are stored in memory, so they'll probably be different for you than they were for me, and they aren't important here.  But the types are more interesting:</p>\r\n\r\n<ul>\r\n  <li><b>Counter.reset</b> returns a function object, just like <b>square</b> did.  If you wanted to call it, you'd need to pass the arguments it requires.  The <b>Counter.reset</b> method requires two arguments: a Counter object (<b>self</b>) and an integer (<b>new_count</b>).</li>\r\n  <li><b>c.reset</b> returns a <i>bound method</i> object instead.  A bound method is one in which the <b>self</b> parameter has already been bound to the object preceding the dot (in this case, <b>c</b>).  If we want to call a bound method, we pass it the <i>missing</i> arguments (i.e., the arguments other than <b>self</b>).  In this case, there's just one, <b>new_count</b>.</li>\r\n</ul>\r\n\r\n<p>To see how this works, consider the following example:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x = Counter.reset</b>\r\n&gt;&gt;&gt; <b>x(c, 3)</b>\r\n&gt;&gt;&gt; <b>y = c.reset</b>\r\n&gt;&gt;&gt; <b>y(3)</b>\r\n</pre></blockquote>\r\n\r\n<p>The first two lines set a variable <b>x</b> to be the <b>Counter.reset</b> function and then call it.  That function requires two arguments, so if we want to call it, we have to pass both: <b>self</b> and <b>new_count</b>.  The second two lines set a variable <b>y</b> to be the bound method <b>c.reset</b> instead.  That bound method requires only one argument, since <b>self</b> has already been bound to <b>c</b>, to we call it by passing it the one argument, which is then bound to <b>new_count</b>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Writing object-oriented GUIs</p>\r\n\r\n<p>A <b>tkinter</b>-based GUI is written using event-based programming techniques, which means that we ask <b>tkinter</b> to handle the basic control flow and watch for inputs, then notify us only when events occur in which we've registered an interest.  Some kinds of event handler functions, like the ones that handle the <b>command</b> behavior on the <b>Button</b> widget, take no parameters; most take a single parameter, an <i>event object</i> that describes the event.  But if we use functions (as opposed to methods) for our event handlers, the only information they'll have available to them is the information passed to them; they might know something about the event that's occurring now, but won't have access to any other information about what's happened before.  That makes even a simple application like our Scribble application very difficult to write.</p>\r\n\r\n<p>However, there is a saving grace in Python: classes and object-oriented programming.  We've seen before that classes are a way to bring together data and the operations that know how to manipulate that data.  The objects you create from classes don't just <i>store</i> things; they know how to <i>do</i> things with the data they store.  In the case of GUIs built using <b>tkinter</b>, they beautifully solve the problem of ensuring that necessary information is available to event handlers.  If event handlers are methods that are called on an object, those methods will have access not only to the event object that's passed to them (if any), but also any other information that's stored within the object (via <b>self</b>).  So long as the necessary information is stored in the object's attributes, it will be available in event handler methods; if one event handler changes one of these attributes, its updated value will be available to subsequently-called event handlers.</p>\r\n\r\n<p class=\"subtitle\">Using bound methods for event handlers</p>\r\n\r\n<p>The only trick, then, is how to use a method as an event handler.  If <b>tkinter</b> will call an event handler like it's a function and pass it, say, a single argument that is an event object, how can a method that also requires a <b>self</b> argument be a parameter?</p>\r\n\r\n<p>The answer lies in the bound methods we presented earlier.  If an event handler is a bound method, the <b>self</b> argument is already bound; <b>tkinter</b> won't need to pass it.  And when <b>tkinter</b> calls the event handler and passes it an event object, what it's actually calling is a method that takes a <b>self</b> and an event object, meaning that it has access to the two things it needs:</p>\r\n\r\n<ul>\r\n  <li>Information about the event that's happening now, in the form of an event object</li>\r\n  <li>Any necessary information about things that have happened before, stored in the attributes of <b>self</b></li>\r\n</ul>\r\n\r\n<p>The use of bound methods as event handlers is demonstrated in the code example below.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>Below is a link to a partially-complete version of our Calculator application from lecture.  What's left is entirely to be done in the model and the unit tests; the GUI is done.  The good thing about that is everything we have left to do is based around concepts we've already learned about; the \"hard part\" is finished.</p>\r\n\r\n<ul>\r\n  <li><b><a href=\"calculator_app.py\">calculator_app.py</a></b></li>\r\n  <li><b><a href=\"calculator.py\">calculator.py</a></b></li>\r\n  <li><b><a href=\"test_calculator.py\">test_calculator.py</a></b></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}