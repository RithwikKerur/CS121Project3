{"url": "https://www.ics.uci.edu/~kay/courses/141/hw/hw1.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Wednesday, January 19, 2000 3:52 PM\">\n<TITLE>Asst. 1 * Scheme Introduction</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"644EC08E\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Programming languages, homework, Scheme\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Assignment 1, Scheme Introduction, for ICS 141, an undergraduate course in the concepts of programming languages taught by David G. Kay in the Department of Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2000 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"asst_1_scheme_introduc_files/sidebar_76.gif\" WIDTH=468 HEIGHT=78>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4><B>About the assignments in ICS 141:</B> \nThis course teaches not only new concepts but also new ways of thinking.\n Learning to think in new ways usually requires practice-- actually <I>doing</I>\nthe new things a few times (or more).  The homeworks are your opportunity\nto get that practice.  Don&#39;t just say to yourself, &quot;Let me just\nget the answer down and turn it in; I&#39;ll learn how to do it later.&quot;\n Keep working (by yourself, with the instructor or TAs, or with your classmates)\nuntil you can produce the answers on your own, without help.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>It&#39;s no secret that some of the problems\nwe assign this quarter are the same as we assigned last quarter.  It is\nentirely possible for you to find the answers from someone who took the\ncourse before and just copy them down and turn them in.  But besides being\nacademically dishonest, it also won&#39;t prepare you to do similar problems\non the exams, so your course grade will suffer.  Give the assignments the\ntime and attention they require, and enjoy stretching your &quot;mental\nmuscles.&quot;</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Due date:</B>  This assignment is due on\nMonday, January 24, by 3:00 PM.  Deposit your assignment in the locking\ndrop box in room CS 189.  The due date is closer than it seems; be sure\nto get started this week so you can ask questions in discussion on Friday.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Summary:</B>  For this assignment you will\nbecome acquainted with running the Scheme interpreter and the basic patterns\nof recursive list processing code in Scheme.  A few of the problems will\nseem familiar to those who took ICS 22 here from me; I apologize for the\nrepetition but your work back then will pay off now.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part I (Readings and review questions):</B>\n Each chapter of Sebesta ends with two sets of exercises, one called &quot;review\nquestions&quot; and one called &quot;problem set.&quot;  Each set is numbered\nstarting from 1, so be careful to verify which set we&#39;re asking for\non each assignment.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You should know the answers to the review\nquestions listed below, but you do not have to turn them in.  This list\nshould help you identify some of the more important concepts in the text.\n (On the other hand, don&#39;t infer that topics we skip or omit are entirely\n<I>un</I>important.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 1:  1-11, 13, 15-17, 19-25, 27-32.\n Come back to these questions at the end of the course, as you review for\nthe final.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 2:  8, 14-17, 21, 26-30, 35-38, 42,\n43, 46.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 14:  1, 4, 6-9, 14.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part II:</B>  In Chapter 2 of Sebesta,\nanswer in one or two brief sentences each of the following questions in\nthe problem set on page 104:  6, 7, 8, 9, and 14.  (Note that these are\nquestions from the &quot;problem set,&quot; not from the &quot;review questions.&quot;)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Feel free to try some of the exercises we\ndon&#39;t assign, but if you get stuck, ask us before spending too much\ntime on any problem; not all of them address issues that will be important\nto us.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part III:</B>  We cover Scheme in ICS 141\nfor two main reasons:  To illustrate concepts of functional programming,\nincluding higher-order functions, and to give you experience learning a\nnew language that&#39;s significantly different from what you already know.\n Learning to think in a new way isn&#39;t easy; some frustration is inevitable\nas you stretch your mind in new directions.  But middle school and high\nschool students learn this material (see </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.schemers.com\">www.schemers.com</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">www.cs.rice.edu/CS/PLT/Teaching/</FONT><FONT FACE=\"AGaramond\" SIZE=4>),\nso you can, too.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Scheme language details:</B>  Writing textbooks\nis hard work, so maybe we can forgive Sebesta missing a few details about\nthe current status of the Scheme language standard:\n<BR>\n-- The two boolean constants are </FONT><FONT FACE=\"Courier New\">#t</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">#f</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n </FONT><FONT FACE=\"Courier New\">NIL</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis no longer used, and while the empty list counts as false, it&#39;s bad\nprogramming practice to use it that way.\n<BR>\n-- Many Scheme implementations allow </FONT><FONT FACE=\"Courier New\">first</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">rest</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nin place of the historically interesting but hopelessly non-mnemonic </FONT><FONT FACE=\"Courier New\">car</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">cdr</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n If yours doesn&#39;t, you can just say </FONT><FONT FACE=\"Courier New\">(define\nfirst car)</FONT><FONT FACE=\"AGaramond\" SIZE=4> and </FONT><FONT FACE=\"Courier New\">(define\nrest cdr)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n<BR>\n-- Some Scheme implementations allow curly braces or square brackets instead\nof parentheses, as a visual aid to matching pairs up.  That&#39;s not standard;\nyou should just use parentheses and let your environment do the matching\nfor you.\n<BR>\n-- There are two equivalent styles for defining functions, which I&#39;ll\ncall the prototype form and the lambda form.  Sebesta uses the prototype\nform, which is shorter and which illustrates what a call might look like:\n</FONT><FONT FACE=\"Courier New\">(define (cube x) (* x x x))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n I prefer the lambda form, which doesn&#39;t hide the underlying lambda\nexpression and which is consistent in form with other uses of </FONT><FONT FACE=\"Courier New\">define</FONT><FONT FACE=\"AGaramond\" SIZE=4>:\n </FONT><FONT FACE=\"Courier New\">(define&#160;cube&#160;(lambda&#160;(x)\n(* x x x)))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Scheme implementations:</B>  The NT machines\nin the labs have an implementation of Scheme called EdScheme.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>For use at home, you can download a limited-time\nversion of EdScheme for free from </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.schemers.com\">www.schemers.com</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\nyou can also purchase a copy for about 50% off (see us for details).  We\nalso recommend DrScheme, another implementation from Rice University that&#39;s\navailable entirely for free on most every platform (</FONT><FONT FACE=\"Courier New\">www.cs.rice.edu/CS/PLT/packages/drscheme/</FONT><FONT FACE=\"AGaramond\" SIZE=4>).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Problems:</B>  For most of these problems,\nwe&#39;ll ask you to print out the transcript window showing your interaction\nwith the Scheme interpreter.  You&#39;ll probably want to produce a separate\ntranscript for turning in, rather than printing out pages and pages showing\nall your experimentation.  But don&#39;t worry if your transcript contains\na few typos.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  Get used to the Scheme environment.\n Try some expressions like </FONT><FONT FACE=\"Courier New\">(* 123 456)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">(expt 2 100)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">(/ 3.14159265 2)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Type in some definitions of symbols in the\nglobal environment, like </FONT><FONT FACE=\"Courier New\">(define pi 3.14159265)</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nand then try </FONT><FONT FACE=\"Courier New\">(/ pi 2)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Type in a function definition like this one:<A NAME=\"_14_5735\"></A></FONT></P>\n<P>\n<CODE><FONT FACE=\"Courier New\">(define fact                            \n     ; Compute n! (n factorial).\n<BR>\n&#160;&#160; (lambda (n)                                ; 0! is 1 by definition\n<BR>\n&#160;&#160;  &#160; (cond                                   ; The extra\nhorizontal space\n<BR>\n&#160;&#160;  &#160;  &#160; ((&lt;= n 0)  1 )                       ; isn&#39;t\nneeded; it just lines\n<BR>\n&#160;&#160;  &#160;  &#160; (else      (* n (fact (- n 1)))))))  ; up the\ncond clause parts.</FONT></CODE></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Notice how the environment indents and highlights\nblocks of code so you don&#39;t get the parentheses confused.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Make sure you know how to save your code in\na file and load that file into Scheme for evaluation.  EdScheme doesn&#39;t\nautomatically re-evaluate changes you make in your code, any more than Visual\nC++ does (you have to recompile there, too).\n<BR>\nTry some compound expressions, like </FONT><FONT FACE=\"Courier New\">(gcd\n(fact 100) (expt 2 1000))</FONT><FONT FACE=\"AGaramond\" SIZE=4> and</FONT><FONT>\n</FONT><FONT FACE=\"Courier New\">(fact (fact 5))</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">(first&#160;(rest &#39;(Huey Dewey Louie)))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>What is the value produced by </FONT><FONT FACE=\"Courier New\">(/\n(fact 5) (expt 7 2))</FONT><FONT FACE=\"AGaramond\" SIZE=4>?  This result\nis called &quot;exact representation&quot;--it looks unusual to us, but\nit&#39;s useful in further calculations because nothing is lost by rounding\noff to a decimal representation.  On the other hand, evaluate </FONT><FONT FACE=\"Courier New\">(output-fixed-point\n(/ (fact 5) (expt 7 2)) 15 10)</FONT><FONT FACE=\"AGaramond\" SIZE=4>.  (The\n15 is the total size in characters of the result; the 10 is the number of\ndigits to the right of the decimal point.)  The code for </FONT><FONT FACE=\"Courier New\">output-fixed-point</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis available on Masterhit, the NT lab server.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>What happens when you evaluate</FONT><FONT>\n</FONT><FONT FACE=\"Courier New\">(fact (fact 500))</FONT><FONT FACE=\"AGaramond\" SIZE=4>?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Play around more with EdScheme, trying other\nexpressions.  Experiment with the list operators--</FONT><FONT FACE=\"Courier New\">cons</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nfirst</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nrest</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nlist</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nappend</FONT><FONT FACE=\"AGaramond\" SIZE=4>,</FONT><FONT FACE=\"Courier New\">\nnull?</FONT><FONT FACE=\"AGaramond\" SIZE=4>--until you&#39;re comfortable\nwith how they work.  You can look at the online help (available under the\nHelp menu or question-mark button) for some more information.  To understand\nwhat a function does, be sure you understand what kinds of data it expects\nas its arguments (atoms? lists? numbers?) and what kind of data it returns.\n The function </FONT><FONT FACE=\"Courier New\">cons</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nfor example, takes any expression as its first argument and a list as its\nsecond argument, and it returns a list.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You don&#39;t have to turn anything in for\nthis part (<B>III (a)</B>) of the lab.  But of course if you short-change\nthe time you spend building familiarity, you&#39;ll have much more trouble\nlater on.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  This function, called Ackerman&#39;s\nfunction, grows really fast:<A NAME=\"_14_8111\"></A>\n<BR>\n</FONT><CODE><FONT FACE=\"Courier New\">(define A\n<BR>\n&#160; (lambda (x y)\n<BR>\n&#160;   (cond ((= x 0) (+ 1 y))\n<BR>\n&#160;         ((= y 0) (A (- x 1) 1))\n<BR>\n&#160;         (else (A (- x 1)\n<BR>\n&#160;                  (A x (- y 1)))))))\n<BR>\n</FONT></CODE><FONT FACE=\"AGaramond\" SIZE=4><B>(b.1)  </B>Type it in and\ntry it out (with very small arguments).  Then print out the Transcript window\nshowing what you did.  (But you don&#39;t have to print out results that\nshow pages and pages of solid digits.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.2)</B>  Rewrite Ackerman&#39;s function\non paper using standard mathematical notation.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)</B>  What&#39;s the longest number\nyou can generate in the Scheme you&#39;re using, without running out of\nmemory and taking no more than 60 seconds of processor time?  Generating\nthe big numbers is one part of the question; counting the digits is another.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.1)</B>  Try using </FONT><FONT FACE=\"Courier New\">(string-length\n(number-&gt;string </FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>your-big-number</U></I></FONT><FONT FACE=\"Courier New\">))</FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.2)</B>  Try to approximate it using\nthe log base 10.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.3)</B>  Try to do it using some tool(s)\nother than Scheme (or any programming language).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.4)</B>  Using your wristwatch (or slow,\nmeasured counting), time how long it takes for Scheme to calculate and display\nyour big number.  Now, time how long it takes to calculate the big number\n<I>and then</I> its length (by nesting the expression to generate the big\nnumber inside the length-calculating expression from part <B>(c.1)</B> or\n<B>(c.2)</B>).  You&#39;d expect the second to take longer, but on some\nScheme systems it doesn&#39;t.  Does it on your system?  Why might the generate-and-calculate-length\ntask take <I>less</I> time?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.5)</B>  Type up your answers to these\nquestions and print a transcript showing what you did.  Again, don&#39;t\nprint more than a page or two of solid digits.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(d)</B>  Write each of the following functions\nin Scheme.  For each, pay attention to the type of value that&#39;s returned:\n Is it a list, a single item, a number, a boolean?  If you&#39;re new to\nrecursive thinking, it will take you a while to start seeing the patterns;\nthat&#39;s why there are so many exercises (and even this many may not be\nenough).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Go back and read what the course reference\nsheet says about collaboration.  It&#39;s good to work with your classmates,\nbut remember that the goal is that you be able to write routines like this\nindependently.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(member? A B)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\n(true) if </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\noccurs in the list </FONT><FONT FACE=\"Courier\" SIZE=2><TT>B</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nand</FONT><FONT FACE=\"AGaramond\"> </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\n(false) if it doesn't.  (Sebesta solves this in the text, but try it yourself\nfirst.)\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? 'a '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? 'a '(b a t t y))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? '(b (c)) '(a b (b (c)) d\n(b (c))))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(member? '(b (c)) '(a b (c)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\ntakes a list of numbers and returns a list containing all the numbers from\nthe original list that are even.  The predefined predicate </FONT><FONT FACE=\"Courier\" SIZE=2><TT>even?</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis useful here.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '(3 9 7))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '(1 2 3 4 5))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(2 4)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(find-all-evens '(3 2 7 2 6))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(2 2 6)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(all-even? A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\ntakes a list of numbers and returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nif they're all even, and </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\notherwise.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(all-even? '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(all-even? '(3 5 7 2 6))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#f</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(all-even? '(2 8 0 4 88))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches A B)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns the number of times </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\noccurs in the list </FONT><FONT FACE=\"Courier\" SIZE=2><TT>B</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches 'a '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>0</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches 'a '(a b a c a\nd))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>3</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches 'a '(a b (a) c\n(a d)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>1</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(count-all-matches '(a (b)) '(a b\n(a (b)) a (b) (a (b)) ((a (b)))))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>2</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(subst A B C)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>C</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nwith all occurrences of </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nchanged to </FONT><FONT FACE=\"Courier\" SIZE=2><TT>B</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'x 'y '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'a 'b '(a c e))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(b c e)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'a 'b '(b c d))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(b c d)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst 'a '(a b) '(a b r a))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>((a b) b r (a b))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(subst '(a b c) 'abc '(w x (a b c)\ny (a b c) z))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> returns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(w\nx abc y abc z)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(first-atom A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns the first atom in the list </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nno matter how deeply nested.  Use the predefined predicates </FONT><FONT FACE=\"Courier\" SIZE=2><TT>pair?</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand</FONT><FONT FACE=\"Courier\" SIZE=2><TT> null?</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nto test whether something is an atom or not.\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '(a b c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>a</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '(((a b) c)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>a</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first-atom '( () a b c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich is easy because </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atom? '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nis </FONT><FONT FACE=\"Courier\" SIZE=2><TT>#t</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>(atomize A)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns a list of all the atoms in </FONT><FONT FACE=\"Courier\" SIZE=2><TT>A</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nno matter how deeply nested.  (Hint:  Use the predefined function </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(append\nL1 L2)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> to join the atoms in </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(first\nA)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4> with the atoms in </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(rest\nA)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.)\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '())</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>()</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '(a b c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(a b c)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '((a b) c))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(a b c)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\n<BR>\n</FONT><FONT FACE=\"Courier\" SIZE=2><TT>(atomize '(((a) () (b c)) (d e)))</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nreturns </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(a () b c d e)</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Again, print out a transcript showing your\ndefinitions and some tests indicating that they&#39;re right.</FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}