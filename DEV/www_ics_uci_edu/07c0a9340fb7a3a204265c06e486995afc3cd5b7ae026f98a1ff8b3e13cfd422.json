{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/List.txt", "content": "\t\t\tA Lecture on Using Lists\r\n\r\nThere is a special Interface in Java and two Classes that implement\r\nit, which allow us to use an \"ordered collection\" more easily.\r\n\r\nThe Interface is List. The classes implementing it are ArrayList and\r\nLinkedList. The ArrayList class implements the List Interface by using\r\nan array, just as we have seen for Stacks and Queues and Portofolios: its\r\ninstance variables store an array and an indication of how much of the array\r\nis used, and it doubles the length of the underlying array when necessary. The\r\nLinkedList implementation is used a slightly more advanced technique to\r\nimplement this Interface (discussed in ICS-22 as a self-referential class).\r\n\r\nFundamentally, a List (like an array) allows us to store/process values in\r\na collection where order is important. Unlike an array, we can store only\r\nreferences to Objects (not primitive values) with Lists (although we can always\r\nuse wrapper-classes to store the equivalent of primitive values). First we will\r\nsee how to declare and intialize lists, then examine the methods that we can\r\nuse to operate on them.\r\n\r\nThere is a new syntax (called generic classes) that we use to declare and\r\ninitialize lists. Unlike with arrays, we write the type of the values stored\r\nin the arrays in angle-braces. We often use the Interface as the type of\r\nthe variable. To declare an initialy empty List, where each value in the\r\nlist can refer to an object constructed from the Stock class, we would write\r\nthe following (which could appear in the Portfolio class)\r\n\r\n  List<Stock> stocks = new ArrayList<Stock>();\r\n\r\nThe ArrayList object (like Stack, Queue, and Portfolio objects) internally\r\nstores an array (a Stock[]) and an instance variable to keep track of how many\r\nvalues in the array are used. Operations that \"add\" values to the array (just\r\nlike push, enqueue, and buy -for Portfolio) double the array lengh when\r\nnecessary.\r\n\r\nFundamental methods for List<E> and ArrayList<E>\r\n\r\n  boolean  add        (E e) \r\n  void     add        (int index, E element) \r\n  void     clear      () \r\n  boolean  contains   (Object o) \r\n  boolean  equals     (Object o) \r\n  E        get        (int index) \r\n  int      indexOf    (Object o) \r\n  boolean  isEmpty    () \r\n  int      lastIndexOf(Object o) \r\n  E        remove     (int index) \r\n  boolean  remove     (Object o) \r\n  E        set        (int index, E element) \r\n  int      size       () \r\n  Object[] toArray    () \r\n\r\n------------------------------------------------------------------------------\r\nOther, more advance and less useful methods for List<E> and ArrayList<E>\r\n\r\n  boolean addAll(Collection<? extends E> c) \r\n  boolean addAll(int index, Collection<? extends E> c) \r\n  boolean containsAll(Collection<?> c) \r\n  int hashCode() \r\n  Iterator<E> iterator() \r\n  ListIterator<E> listIterator() \r\n  ListIterator<E> listIterator(int index) \r\n  boolean removeAll(Collection<?> c) \r\n  boolean retainAll(Collection<?> c) \r\n  List<E> subList(int fromIndex, int toIndex) \r\n  <T> T[] toArray(T[] a) \r\n------------------------------------------------------------------------------\r\n \r\nWe will talk about these fundamental methods during lecture (discussing their\r\nsemantics). You can read their Javadoc (see either List or ArrayList). The\r\n\"E\" that appears in the prototype specifies the type that appears in\r\nangle-brackets. So, if we declare List<Stock> then the method\r\n\r\n  add(E d)\r\n\r\nreally means\r\n\r\n  add(Stock e)\r\n\r\nNote that some methods still use Object, meaning that any reference to an\r\nobject is allowed, not just references to Stock.\r\n\r\nThe most fundamental operations on Lists mirror arrays: getting a value from\r\na list by specifying its position and storing a values in a list by specifying\r\nits position. We can also easily get the size of any List (the number of values\r\nactually stored in the list)\r\n\r\nOf course, standard object/class syntax uses method calls, not [], so these\r\noperations are a built unwieldy when compared with arrays. The following\r\nloop prints every value in an List. Notice the calls to .size and .get\r\n\r\nfor (int i=0; i<stocks.size(); i++)\r\n  System.out.println( stocks.get(i) );\r\n\r\nTo exchange the values in positions i and j in a List, we could write the\r\nswap method below\r\n\r\n  public static void swap (int i, int j, List<Stock> l) {\r\n    Stock temp = l.get(i);          //Array version: temp = l[i]\r\n    l.set(i, l.get(j) );            //               l[i] = l[j];\r\n    l.set(j, temp);                 //               l[j] = temp;\r\n  }\r\n\r\nNotice that we can easily transform any expression using array notation\r\n([]) into one using List notation (.get and .set), but the resulting code\r\nis harder to read. Note that [] throws an exception if we access the array\r\noutside its physical bounds (<0 or >=.length); .get and .set throw an exception\r\nif we access the list outside its size ((<0 or >=.size), which is a bit more\r\nuseful: so, accessing a length 5 array (which stores just 3 values, in indexes\r\n0, 1, and 2) at index 4 is legal; but not so for a List (whose .size() is 3).\r\n\r\nAlso in this example, we specify the the parameter as List<Stock> instead of\r\nArrayList<Stock>; this allows either an ArrayList<Stock> or LinkedList<Stock>\r\nobject to be passed (both implement List<Stock>). So, we can specify and write\r\nthis method independently of what choice of class we make to actually store\r\nour List (recall List is a interface: ArrayList and LinkedList are classes).\r\n\r\nIn fact, we can even more generally write a swap method using \r\n\r\n  public static void swap (int i, int j, List<Object> l) {\r\n    Object temp = l.get(i);\r\n    l.set(i, l.get(j) );\r\n    l.set(j, temp);\r\n  }\r\n\r\nI will briefly discuss the rest of the fundamental methods above:\r\nadd (two forms), clear, contains, equals, indexOf, isEmpty, lastIndexOf,\r\nremove (two forms),and toArray.\r\n\r\nAll these methods go beyond what we can do with arrays (although we\r\ncould write most of these methods fairly easily, using our own loops,).\r\nBut, it is easier to use Lists since we get this code automatically (see\r\nespecially the second form of add and both forms of remove).\r\n\r\nAt the end of this lecture is the implementation of SimpleQueue using\r\nan ArrayList. Compare its methods with the ones that process arrays.\r\nNotably, the remove method is much simpler (since List support\r\n\"remove(0);\" which both removes/returns the value stored at index\r\n0 in the List. Also note that enqueue just calls \"add(o);\" which\r\nhandles array doubling if necessary.\r\n\r\nThe Iterator interface is much like StringTokenizer: primarily it has methods\r\nhasNext and next. We can construct an Iterator for any list and use it\r\nto get every value from the List, one after another. With standard Java\r\niterators we can rewrite the code to print every value in a List as\r\n\r\nfor (Iterator<Stock> i=stocks.iterator(); i.hasNext(); /* see next in body*/)\r\n  System.out.println( i.next(); );\r\n\r\nHere we have done away with indexing and any notion of counting how big the\r\narray is (programmers consider the indexes a distraction in this case).\r\n\r\nIn fact, starting with Java 1.5 we can write this loop even more simply.\r\n\r\nfor (Stock s : stocks)\r\n  System.out.println( s );\r\n\r\nwhich uses a very simple syntax and translates to the iterator above. The for\r\nloop stores into s every values in stocks (one new one for each loop iteration,\r\nas long as their are unseen values in stock). The body of the loop just prints\r\neach s.\r\n\r\nThe class Collections in Java (see its Javadoc) stores a huge number of\r\nstatic methods which operate on Lists and Collections (a List is a special\r\nkind of Collection -we will study inheritnace soon, with codifies \"special\r\nkind of\"- so you can pass a List to any parameter that specifies collection.\r\n\r\nNotable methods are max and min (typically given a comparator), reverse,\r\nrotate, and shuffle.\r\n\r\nFinally, my preference is to delay coverage of List and ArrayList until ICS-22,\r\nwhere it can be covered more systematically and completely, but UCI requires\r\nme toat least briefly discuss this material in ICS-21.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\n\r\npublic class SimpleQueue  { //Implemented with List/ArrayList, not array\r\n\r\n\r\n  //Constructors\r\n  public SimpleQueue (int initialSize) throws IllegalArgumentException {\r\n    q = new ArrayList<Object>(initialSize);\r\n  }\r\n\r\n  public SimpleQueue ()\r\n  {this(1);}\r\n\r\n\r\n\r\n  //Mutators  \r\n  public void makeEmpty () {\r\n    q.clear();\r\n  }\r\n\r\n  public void enqueue (Object o) {\r\n    q.add(o);\r\n  }\r\n\r\n  public Object dequeue () throws IllegalStateException {\r\n    if ( q.isEmpty() )\r\n      throw new IllegalStateException(\"SimpleQueue dequeue: queue is empty\");\r\n\r\n    return q.remove(0);\r\n  }\r\n\r\n\r\n  //Accessors\r\n  public Object peek () throws IllegalStateException {\r\n    if ( q.isEmpty() )\r\n      throw new IllegalStateException(\"SimpleQueue peek: queue is empty\");\r\n\r\n    return q.get(0);  \r\n  }\r\n\r\n  public boolean isEmpty ()\r\n  {return q.isEmpty();}\r\n\r\n  public int getSize ()\r\n  {return q.size();}\r\n\r\n  public String toString () {\r\n    String answer = \"SimpleQueue[size=\"+q.size();\r\n    for (int i=0; i<=q.size(); i++)\r\n      answer += \";q[\"+i+\"]=\"+q.get(i);\r\n    answer +=  \"]\";\r\n\r\n    return answer;\r\n  }\r\n\r\n\r\n\r\n  //Instance Variables  \r\n  private List<Object> q;\r\n}\r\n", "encoding": "ascii"}