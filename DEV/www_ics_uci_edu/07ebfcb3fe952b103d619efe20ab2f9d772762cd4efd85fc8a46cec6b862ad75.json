{"url": "https://www.ics.uci.edu/~ejw/authoring/protocol/draft-ietf-webdav-protocol-05.txt", "content": "WEBDAV Working Group                            Y.Y. Goland, Microsoft\n\nINTERNET DRAFT                          E.J. Whitehead, Jr., UC Irvine\n<draft-ietf-webdav-protocol-05>                     A. Faizi, Netscape\n                                                   S.R. Carter, Novell\n                                                     D. Jensen, Novell\nExpires April, 1998                                  November 19, 1997\n\n\n  Extensions for Distributed Authoring on the World Wide Web -- WEBDAV\n\n\nStatus of this Memo\n\n   This document is an Internet-Draft. Internet-Drafts are working\n   documents of the Internet Engineering Task Force (IETF), its areas,\n   and its working groups. Note that other groups may also distribute\n   working documents as Internet-Drafts.\n\n   Internet-Drafts are draft documents valid for a maximum of six\n   months and may be updated, replaced, or made obsolete by other\n   documents at any time. It is inappropriate to use Internet-Drafts as\n   reference material or to cite them other than as \"work in progress\".\n\n   To learn the current status of any Internet-Draft, please check the\n   \"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow\n   Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),\n   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or\n   ftp.isi.edu (US West Coast).\n\n   Distribution of this document is unlimited. Please send comments to\n   the Distributed Authoring and Versioning (WEBDAV) working group at\n   <w3c-dist-auth@w3.org>, which may be joined by sending a message\n   with subject \"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\n   Discussions of the WEBDAV working group are archived at\n   <URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\nAbstract\n\n   This document specifies a set of methods, headers, and content-types\n   ancillary to HTTP/1.1 for the management of resource properties,\n   creation and management of resource collections, namespace\n   manipulation, resource locking (collision avoidance), and efficient\n   transmission of resource changes.\n\nChanges\n\n1.1. Changes since draft-ietf-webdav-protocol-04.txt\n\n   [Editor's note: This section will not appear in the final form of\n   this document.  Its purpose is to provide a concise list of changes\n   from the previous revision of the draft for use by reviewers.]\n\n   Added this change section.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Removed scoping for namespaces so the namespace for\n   every element is explicitly stated.\n\n   Changed the syntax from <?XML:Namespace.../> to <?namespace...?>.\n\n   Removed propfindresult, this was left over from the old search\n   format.\n\n   Changed all the DAV XML element names to lower case.\n\n   Changed the property format to use Name and Namespace rather than\n   name and schema.\n\n   Removed proploc attribute and removed section on GETting, DELETEing,\n   and PUTing properties since we do not provide a mechanism for\n   getting a URI for properties.  Also removed the requirement that\n   properties be URI addressable.\n\n   Removed quoted string choice from owner header, it is just XML.\n\n   Made all the HTTP error codes use the same format.\n\n   Changed the name of the create element in PROPPATCH to set, the new\n   name seems to cause less confusion.\n\n   Moved all headers in the draft to a single section.\n\n   Deleted the state token section of the draft and moved the state\n   token headers to the header section of the draft.  Removed the state\n   token header.\n\n   Changed the write lock section to state that a Lock-Token request\n   header, not a state-token request header, is to be submitted on\n   request for write locked resources.\n\n   Created a \"generic\" XML element section for XML elements that get\n   repeatedly re-used throughout the spec.  I moved LINK XML element to\n   this section.\n\n   Made multistatus and Schema discovery their own level one sections.\n\n   Collected all the properties together.\n\n   Removed all references to the possibility of properties have their\n   own URIs.  This includes removing the property identifier section.\n\n   Separated the section on web collections and namespaces into two\n   separate sections.\n\n   Collected all the new response codes together into their own\n   section.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Changed the XML multiresponse element name to multistatus.\n\n   Added a stand alone section on levels of DAV compliance. I also went\n   method by method, property by property, to specify compliance\n   requirements.\n\n   Added an introduction.\n\n   Changed all the \"True\" and \"False\" to \"T\" and \"F\".\n\n   Altered the first two paragraphs of the Property Names section to\n   make the relationship between a property's name and its schema a\n   little clearer.  I also added some text in the same section defining\n   a property name as a namespace and element.\n\n   Added a second paragraph to property model for http resources -\n   overview.  This paragraph clarifies why XML was chosen.\n\n   Added a 409 Conflict error to move to cover attempts to move a\n   collection with members.\n\n   Changed the collection requirement to read the collections SHOULD\n   end with \"/\".  Also added a SHOULD about returning a location header\n   if the client submits a URL for a collection without a trailing \"/\".\n\n   Moved the owner header into the body due to size concerns.\n\n   Replaced the iscollection xml element with resourcetype.\n\n   Moved the DAV property to the DAV header that is returned with\n   OPTIONS.\n\n   Folded the tree draft into this draft.  Changed the DELETE, COPY,\n   and MOVE sections to include their effect on collections as taken\n   from the tree draft.  Created a Depth header section and put in the\n   general rules that were in the introduction to the tree draft.  I\n   also added the 102 response and response-status header.\n\n   Removed the versioning section.\n\n   Put all the methods into a single section.\n\n   Replaced the PROPFIND request body with a propfind header. Now the\n   response can be cached just using vary.\n\n   Nuked resinfo for INDEX and combined it with multistatus which is\n   now used for both INDEX and PROPFIND.  Stripped down INDEX as\n   agreed.\n\n   Removed the problem definition and proposed solution sections. We\n   can always cut and paste them together from the older version if we\n   feel we need them but this draft is supposed to be a dry run for\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   last call and last call documents do not have problem\n   definition/proposed solution sections.\n\n   Killed the section on schema discovery, it is controversial and we\n   aren't going to be able to require it.  We should specify it in a\n   different spec.\n\n   Added a section on notational conventions used within the document.\n\n   Moved the terminology section to the end of the document to provide\n   better flow from the high-level introduction to the specific\n   introduction sections.\n\n   Increased the numeric value of the 4xx status codes introduced in\n   this specification to avoid conflicts with the new revision of the\n   HTTP/1.1 specification, which introduces two new 4xx status codes.\n\n   Wrote internationalization concerns section.\n\n   Added XML version number to all examples.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\nContents\n\nSTATUS OF THIS MEMO...................................................1\nABSTRACT..............................................................1\nCHANGES...............................................................1\n\n1.1. Changes since draft-ietf-webdav-protocol-04.txt..................1\nCONTENTS..............................................................5\n2. INTRODUCTION.......................................................8\n3. DATA MODEL FOR RESOURCE PROPERTIES.................................9\n3.1. The Resource Property Model......................................9\n3.2. Existing Metadata Proposals.....................................10\n3.3. Properties and HTTP Headers.....................................10\n3.4. Property Values.................................................10\n\n3.5. Property Names..................................................11\n4. COLLECTIONS OF WEB RESOURCES......................................11\n4.1. Collection Resources............................................11\n4.2. Creation and Retrieval of Collection Resources..................12\n4.3. HTTP URL Namespace Model........................................13\n4.4. Source Resources and Output Resources...........................13\n5. LOCKING...........................................................14\n\n5.1. Exclusive Vs. Shared Locks......................................14\n5.2. Required Support................................................15\n5.3. Lock Tokens.....................................................16\n5.4. opaquelocktoken Lock Token URI Scheme...........................16\n5.5. Lock Capability Discovery.......................................16\n5.6. Active Lock Discovery...........................................17\n6. WRITE LOCK........................................................17\n6.1. Methods Restricted by Write Locks...............................17\n\n6.2. Write Locks and Properties......................................17\n6.3. Write Locks and Null Resources..................................17\n6.4. Write Locks and Collections.....................................18\n6.5. Write Locks and COPY/MOVE.......................................18\n6.6. Re-issuing Write Locks..........................................18\n6.7. Write Locks and The Lock-Token Request Header...................18\n7. NOTATIONAL CONVENTIONS............................................19\n\n8. HTTP METHODS FOR DISTRIBUTED AUTHORING............................19\n8.1. PROPFIND........................................................19\n8.2. PROPPATCH.......................................................23\n8.3. MKCOL Method....................................................25\n8.4. INDEX Method....................................................26\n8.5. DELREF Method...................................................28\n8.6. ADDREF Method...................................................28\n8.7. GET, HEAD for Collections.......................................29\n\n8.8. POST for Collections............................................29\n8.9. DELETE..........................................................29\n8.10. PUT............................................................31\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n8.11. COPY Method....................................................31\n8.12. MOVE Method....................................................35\n8.13. LOCK Method....................................................38\n\n8.14. UNLOCK Method..................................................42\n8.15. PATCH Method...................................................43\n9. DAV HEADERS.......................................................47\n9.1. Collection-Member Header........................................47\n9.2. DAV Header......................................................47\n9.3. Depth Header....................................................47\n9.4. Destination Header..............................................48\n9.5. Destroy Header..................................................48\n\n9.6. Enforce-Live-Properties Header..................................49\n9.7. If-None-State-Match.............................................49\n9.8. If-State-Match..................................................50\n9.9. Lock-Info Request Header........................................50\n9.10. Lock-Token Request Header......................................51\n9.11. Lock-Token Response Header.....................................51\n9.12. Overwrite Header...............................................52\n\n9.13. Propfind Request Header........................................52\n9.14. Status-URI Response Header.....................................52\n9.15. Timeout Header.................................................52\n10. RESPONSE CODE EXTENSIONS TO RFC 2068.............................54\n10.1. 102 Processing.................................................54\n10.2. 207 Multi-Status...............................................54\n10.3. 418 Unprocessable Entity.......................................54\n10.4. 419 Insufficient Space on Resource.............................54\n\n10.5. 420 Method Failure.............................................54\n11. MULTI-STATUS RESPONSE............................................54\n11.1. multistatus XML Element........................................55\n11.2. response XML Element...........................................55\n11.3. status XML Element.............................................55\n11.4. responsedescription XML Element................................55\n12. GENERIC DAV XML ELEMENTS.........................................55\n\n12.1. href XML Element...............................................56\n12.2. link XML Element...............................................56\n12.3. prop XML element...............................................57\n13. DAV PROPERTIES...................................................57\n13.1. creationdate Property..........................................57\n13.2. displayname Property...........................................57\n13.3. get-content-language Property..................................58\n13.4. get-content-length Property....................................58\n\n13.5. get-content-type Property......................................58\n13.6. get-etag Property..............................................58\n13.7. get-last-modified Property.....................................59\n13.8. index-content-language Property................................59\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n13.9. index-content-length Property..................................59\n13.10. index-content-type Property...................................59\n13.11. index-etag Property...........................................59\n\n13.12. index-last-modified Property..................................60\n13.13. lockdiscovery Property........................................60\n13.14. resourcetype Property.........................................62\n13.15. Source Link Property Type.....................................62\n13.16. supportedlock Property........................................63\n14. DAV COMPLIANCE LEVELS............................................64\n14.1. Level 1........................................................64\n14.2. Level 2........................................................64\n\n15. INTERNATIONALIZATION SUPPORT.....................................65\n16. SECURITY CONSIDERATIONS..........................................66\n17. TERMINOLOGY......................................................66\n18. COPYRIGHT........................................................66\n19. ACKNOWLEDGEMENTS.................................................67\n20. REFERENCES.......................................................69\n21. AUTHORS' ADDRESSES...............................................71\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n2. Introduction\n\n   This document describes an extension to the HTTP/1.1 protocol that\n   allows clients to perform remote web content authoring operations.\n   This extension provides a coherent set of methods, headers, request\n   entity body formats, and response entity body formats that provide\n   operations for:\n\n   Properties: The ability to create, remove, and query information\n   about Web pages, such as its author, creation date, etc. Also, the\n   ability to link pages of any media type to related pages.\n\n   Collections: The ability to create sets of related documents, and to\n   receive a listing of pages at a particular hierarchy level (like a\n   directory listing in a file system).\n\n   Locking: The ability to keep more than one person from working on a\n   document at the same time. This prevents the \"lost update problem\"\n   in which modifications are lost as first one author, then another\n   writes their changes without merging the other author's changes\n\n   Namespace Operations: The ability to copy and move Web resources\n\n   Efficient Update: The ability to send changes which are proportional\n   to the size of the change rather than retransmitting the entire\n   resource.\n\n   Requirements and rationale for these operations are described in a\n   companion document, \"Requirements for a Distributed Authoring and\n   Versioning Protocol for the World Wide Web\" [Slein et al., 1997].\n\n   The sections below provide a detailed introduction to resource\n   properties (Section 3), collections of resources (Section 4), and\n   locking operations (Section 5).  These sections introduce the\n   abstractions manipulated by the WebDAV-specific HTTP methods\n   described in Section 8, \"HTTP Methods for Distributed Authoring\".\n\n   In HTTP/1.1, method parameter information was exclusively encoded in\n   HTTP headers. Unlike HTTP/1.1, WebDAV, encodes method parameter\n   information either in an Extensible Markup Language (XML) [Bray,\n   Sperberg-McQueen, 1997] request entity body, or in an HTTP header.\n   The use of XML to encode method parameters was motivated by the\n   ability to add extra XML elements to existing structures, providing\n   extensibility, and by XML's ability to encode information in ISO\n   10646 character sets, providing internationalization support. As a\n   rule of thumb, parameters are encoded in XML entity bodies when they\n   have unbounded length, or when they may be shown to a human user and\n   hence require encoding in an ISO 10646 character set.  Otherwise,\n   parameters are encoded within an HTTP header.  Section 9 describes\n   the new HTTP headers used with WebDAV methods.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   In addition to encoding method parameters, XML is used in WebDAV to\n   encode the responses from methods, providing the extensibility and\n   internationalization advantages of XML for method output, as well as\n   input. XML elements used in this specification are defined in\n   Section 12.\n\n   While the response codes provided by HTTP/1.1 are sufficient to\n   describe the preponderance of error conditions encountered by WebDAV\n   methods, there are some errors that do not fall neatly into the\n   existing categories.  New status codes developed for the WebDAV\n   methods are defined in Section 10.  Since some WebDAV methods may\n   operate over many resources, the multiresponse status type has been\n   introduced to return status information for multiple resources.\n   Multiresponse status is described in Section 11.\n\n   The properties mechanism is employed by WebDAV to store information\n   about the current state of the resource.  For example, when a lock\n   is taken out on a resource, a lock information property describes\n   the current state of the lock. Section 13 defines the properties\n   used within the WebDAV specification.\n\n   Finishing off the specification are sections on what it means to be\n   compliant with this specification (Section 14), on\n   internationalization support (Section 15), and on security (Section\n   16).\n\n\n3. Data Model for Resource Properties\n\n3.1. The Resource Property Model\n\n   Properties are pieces of data that describe the state of a resource.\n   Properties are data about data.\n\n   Properties are used in distributed authoring environments to provide\n   for efficient discovery and management of resources.  For example, a\n   'subject' property might allow for the indexing of all resources by\n   their subject, and an 'author' property might allow for the\n   discovery of what authors have written which documents.\n\n   The DAV property model consists of name/value pairs.  The name of a\n   property identifies the property's syntax and semantics, and\n   provides an address by which to refer to that syntax and semantics.\n\n   There are two categories of properties: \"live\" and \"non-live\".  A\n   live property has its syntax and semantics enforced by the server.\n   This represents the two cases of a) the value of a property is read-\n   only, maintained by the server, and b) the value of the property is\n   maintained by the client, but server performs syntax checking on\n   submitted values. A non-live property has its syntax and semantics\n   enforced by the client; the server merely records the value of the\n   property verbatim.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n3.2. Existing Metadata Proposals\n\n   Properties have long played an essential role in the maintenance of\n   large document repositories, and many current proposals contain some\n   notion of a property, or discuss web metadata more generally.  These\n   include PICS [Miller et al., 1996], PICS-NG, the Rel/Rev draft\n   [Maloney, 1996], Web Collections, XML [Bray, Sperberg-McQueen,\n   1997], several proposals on representing relationships within HTML,\n   digital signature manifests (DCMF), and a position paper on Web\n   metadata architecture [Berners-Lee, 1997].  Work on PICS-NG and Web\n   Collections has been subsumed by the Resource Definition Framework\n   (RDF) metadata activity of the World Wide Web Consortium, which\n   consists of a network-based data model and an XML representation of\n   that model.\n\n   Some proposals come from a digital library perspective.  These\n   include the Dublin Core [Weibel et al., 1995] metadata set and the\n   Warwick Framework [Lagoze, 1996], a container architecture for\n   different metadata schemas.  The literature includes many examples\n   of metadata, including MARC [MARC, 1994], a bibliographic metadata\n   format, and RFC 1807 [Lasher, Cohen, 1995], a technical report\n   bibliographic format employed by the Dienst system. Additionally,\n   the proceedings from the first IEEE Metadata conference describe\n   many community-specific metadata sets.\n\n   Participants of the 1996 Metadata II Workshop in Warwick, UK\n   [Lagoze, 1996], noted that, \"new metadata sets will develop as the\n   networked infrastructure matures\" and \"different communities will\n   propose, design, and be responsible for different types of\n   metadata.\" These observations can be corroborated by noting that\n   many community-specific sets of metadata already exist, and there is\n   significant motivation for the development of new forms of metadata\n   as many communities increasingly make their data available in\n   digital form, requiring a metadata format to assist data location\n   and cataloging.\n\n3.3. Properties and HTTP Headers\n\n   Properties already exist, in a limited sense, in HTTP message\n   headers.  However, in distributed authoring environments a\n   relatively large number of properties are needed to describe the\n   state of a resource, and setting/returning them all through HTTP\n   headers is inefficient.  Thus a mechanism is needed which allows a\n   principal to identify a set of properties in which the principal is\n   interested and to then set or retrieve just those properties.\n\n3.4. Property Values\n\n   The value of a property is expressed as a well-formed XML document.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   XML has been chosen because it is a flexible, self-describing,\n   structured data format that supports rich schema definitions, and\n   because of its support for multiple character sets.  XML's self-\n   describing nature allows any property's value to be extended by\n   adding new elements.  Older clients will not break because they will\n   still have the data specified in the original schema and will ignore\n   elements they do not understand.  XML's support for multiple\n   character sets allows human-readable properties to be encoded and\n   read in a character set familiar to the user.\n\n3.5. Property Names\n\n   A property name is a universally unique identifier that is\n   associated with a schema that provides information about the syntax\n   and semantics of the property.\n\n   Because a property's name is universally unique, clients can depend\n   upon consistent behavior for a particular property across multiple\n   resources, so long as that property is \"live\" on the resources in\n   question.\n\n   The XML namespace mechanism, which is based on URIs, is used to name\n   properties because it provides a mechanism to prevent namespace\n   collisions and for varying degrees of administrative control.\n\n   The property namespace is flat; that is, no hierarchy of properties\n   is explicitly recognized.  Thus, if a property A and a property A/B\n   exist on a resource, there is no recognition of any relationship\n   between the two properties.  It is expected that a separate\n   specification will eventually be produced which will address issues\n   relating to hierarchical properties.\n\n   Finally, it is not possible to define the same property twice on a\n   single resource, as this would cause a collision in the resource's\n   property namespace.\n\n\n4. Collections of Web Resources\n\n   This section provides a description of a new type of Web resource,\n   the collection, and discusses its interactions with the HTTP URL\n   namespace. The purpose of a collection resource is to model\n   collection-like objects (e.g., filesystem directories) within a\n   server's namespace.\n\n   All DAV compliant resources MUST support the HTTP URL namespace\n   model specified herein.\n\n4.1. Collection Resources\n\n   A collection is a resource whose state consists of an unordered list\n   of internal members, an unordered list of external members, and a\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   set of properties.  An internal member resource MUST have a URI that\n   is immediately relative to the base URI of the collection, that is,\n   a relative URI in which \"../\" is illegal, which MUST begin with \"./\"\n   and which SHOULD contain a \"/\" at the end of the URI if the internal\n   member resource is itself a collection.\n\n   An external member resource MUST be an absolute URI that is not an\n   internal URI.  Any given internal or external URI MUST only belong\n   to the collection once, i.e., it is illegal to have multiple\n   instances of the same URI in a collection.  Properties defined on\n   collections behave exactly as do properties on non-collection\n   resources.\n\n   There is a standing convention that when a collection is referred to\n   by its name without a trailing slash, the trailing slash is\n   automatically appended.  Due to this, a resource MAY accept a URI\n   without a trailing \"/\" to point to a collection. In this case it\n   SHOULD return a location header in the response pointing to the URL\n   ending with the \"/\".  For example, if a client performs an INDEX on\n   http://foo.bar/blah (no trailing slash), the resource\n   http://foo.bar/blah/ (trailing slash) MAY respond as if the\n   operation were invoked on it, and SHOULD return a location header\n   with http://foo.bar/blah/ in it.\n\n\n4.2. Creation and Retrieval of Collection Resources\n\n   This document specifies the MKCOL method to create new collection\n   resources, rather than using the existing HTTP/1.1 PUT or POST\n   method, for the following reasons\n\n   In HTTP/1.1, the PUT method is defined to store the request body at\n   the location specified by the Request-URI.  While a description\n   format for a collection can readily be constructed for use with PUT,\n   the implications of sending such a description to the server are\n   undesirable.  For example, if a description of a collection that\n   omitted some existing resources were PUT to a server, this might be\n   interpreted as a command to remove those members.  This would extend\n   PUT to perform DELETE functionality, which is undesirable since it\n   changes the semantics of PUT, and makes it difficult to control\n   DELETE functionality with an access control scheme based on methods.\n\n   While the POST method is sufficiently open-ended that a _create a\n   collection_ POST command could be constructed, this is undesirable\n   because it would be difficult to separate access control for\n   collection creation from other uses of POST.\n\n   This document specifies the INDEX method for listing the contents of\n   a collection, rather than relying on the existing HTTP/1.1 GET\n   method.  This is to avoid conflict with the de-facto standard\n   practice of redirecting a GET request on a directory to its\n   index.html resource.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   The exact definition of the behavior of GET and PUT on collections\n   is defined later in this document.\n\n4.3. HTTP URL Namespace Model\n\n   The HTTP URL Namespace is a hierarchical namespace where the\n   hierarchy is delimited with the \"/\" character.  DAV compliant\n   resources MUST maintain the consistency of the HTTP URL namespace.\n   Any attempt to create a resource (excepting the root member of a\n   namespace) that would not be the internal member of a collection\n   MUST fail. For example, if the collection http://www.foo.bar.org/a/\n   exists, but http://www.foo.bar.org/a/b/does not exist, an attempt to\n   create http://www.foo.bar.org/a/b/c must fail.\n\n4.4. Source Resources and Output Resources\n\n   For many resources, the entity returned by a GET method exactly\n   matches the persistent state of the resource, for example, a GIF\n   file stored on a disk.  For this simple case, the URL at which a\n   resource is accessed is identical to the URL at which the source\n   (the persistent state) of the resource is accessed.  This is also\n   the case for HTML source files that are not processed by the server\n   prior to transmission.\n\n   However, the server can sometimes process HTML resources before they\n   are transmitted as a return entity body.  For example, server-side-\n   include directives within an HTML file instruct a server to replace\n   the directive with another value, such as the current date.  In this\n   case, what is returned by GET (HTML plus date) differs from the\n   persistent state of the resource (HTML plus directive).  Typically\n   there is no way to access the HTML resource containing the\n   unprocessed directive.\n\n   Sometimes the entity returned by GET is the output of a data-\n   producing process that is described by one or more source resources\n   (that may not even have a location in the URL namespace).  A single\n   data-producing process may dynamically generate the state of a\n   potentially large number of output resources.  An example of this is\n   a CGI script that describes a \"finger\" gateway process that maps\n   part of the namespace of a server into finger requests, such as\n   http://www.foo.bar.org/finger_gateway/user@host.\n\n   In the absence of distributed authoring capabilities, it is\n   acceptable to have no mapping of source resource(s) to the URI\n   namespace. In fact, preventing access to the source resource(s) has\n   desirable security benefits.  However, if remote editing of the\n   source resource(s) is desired, the source resource(s) should be\n   given a location in the URI namespace.  This source location should\n   not be one of the locations at which the generated output is\n   retrievable, since in general it is impossible for the server to\n   differentiate requests for source resources from requests for\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   process output resources.  There is often a many-to-many\n   relationship between source resources and output resources.\n\n   On WebDAV compliant servers, for all output resources which have a\n   single source resource (and that source resource has a URI), the URI\n   of the source resource SHOULD be stored in a link on the output\n   resource with type http://www.ietf.org/standards/dav/source.  Note\n   that by storing the source URIs in links on the output resources,\n   the burden of discovering the source is placed on the authoring\n   client.\n\n\n5. Locking\n\n   The ability to lock a resource provides a mechanism for serializing\n   access to that resource.  Using a lock, an authoring client can\n   provide a reasonable guarantee that another principal will not\n   modify a resource while it is being edited.  In this way, a client\n   can prevent the \"lost update\" problem.\n\n   This specification allows locks to vary over two client-specified\n   parameters, the number of principals involved (exclusive vs. shared)\n   and the type of access to be granted.  Furthermore, this document\n   only provides the definition of locking for one lock access type,\n   the write lock.  However, the syntax is extensible, and permits the\n   eventual specification of other access types.\n\n5.1. Exclusive Vs. Shared Locks\n\n   The most basic form of lock is an exclusive lock.  This is a lock\n   where the access right in question is only granted to a single\n   principal.  The need for this arbitration results from a desire to\n   avoid having to constantly merge results.\n\n   However, there are times when the goal of a lock is not to exclude\n   others from exercising an access right but rather to provide a\n   mechanism for principals to indicate that they intend to exercise\n   their access right.  Shared locks are provided for this case.  A\n   shared lock allows multiple principals to receive a lock.  Hence any\n   principal with appropriate access can get the lock.\n\n   With shared locks there are two trust sets that affect a resource.\n   The first trust set is created by access permissions.  Principals\n   who are trusted, for example, may have permission to write the\n   resource.  Those who are not, don't.  Among those who have access\n   permission to write the resource, the set of principals who have\n   taken out a shared lock also must trust each other, creating a\n   (typically) smaller trust set within the access permission write\n   set.\n\n   Starting with every possible principal on the Internet, in most\n   situations the vast majority of these principals will not have write\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   access to a given resource.  Of the small number who do have write\n   access, some principals may decide to guarantee their edits are free\n   from overwrite conflicts by using exclusive write locks.  Others may\n   decide they trust their collaborators will not overwrite their work\n   (the potential set of collaborators being the set of principals who\n   have write permission) and use a shared lock, which informs their\n   collaborators that a principal is potentially working on the\n   resource.\n\n   The WebDAV extensions to HTTP do not need to provide all of the\n   communications paths necessary for principals to coordinate their\n   activities.  When using shared locks, principals may use any out of\n   band communication channel to coordinate their work (e.g., face-to-\n   face interaction, written notes, post-it notes on the screen,\n   telephone conversation, Email, etc.)  The intent of a shared lock is\n   to let collaborators know who else is potentially working on a\n   resource.\n\n   Shared locks are included because experience from web distributed\n   authoring systems has indicated that exclusive write locks are often\n   too rigid.  An exclusive write lock is used to enforce a particular\n   editing process: take out exclusive write lock, read the resource,\n   perform edits, write the resource, release the lock.  This editing\n   process has the problem that locks are not always properly released,\n   for example when a program crashes, or when a lock owner leaves\n   without unlocking a resource.  While both timeouts and\n   administrative action can be used to remove an offending lock,\n   neither mechanism may be available when needed; the timeout may be\n   long or the administrator may not be available.\n\n   Despite their potential problems, exclusive write locks are\n   extremely useful, since often a guarantee of freedom from overwrite\n   conflicts is what is needed. This specification provides both\n   exclusive write locks and the less strict mechanism of shared locks.\n\n5.2. Required Support\n\n   A WebDAV compliant server is not required to support locking in any\n   form.  If the server does support locking it MAY choose to support\n   any combination of exclusive and shared locks for any access types.\n\n   The reason for this flexibility is that locking policy strikes to\n   the very heart of the resource management and versioning systems\n   employed by various storage repositories.  These repositories\n   require control over what sort of locking will be made available.\n   For example, some repositories only support shared write locks while\n   others only provide support for exclusive write locks while yet\n   others use no locking at all.  As each system is sufficiently\n   different to merit exclusion of certain locking features, this\n   specification leaves locking as the sole axis of negotiation within\n   WebDAV.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n5.3. Lock Tokens\n\n   A lock token is a URI that identifies a particular lock.  A lock\n   token is returned by every successful LOCK operation in the lock-\n   token response header, and can also be discovered through lock\n   discovery on a resource.\n\n   Lock token URIs are required to be unique across all resources for\n   all time. This uniqueness constraint allows lock tokens to be\n   submitted across resources and servers without fear of confusion.\n\n   This specification provides a lock token URI scheme called\n   opaquelocktoken that meets the uniqueness requirements.  However\n   resources are free to return any URI scheme so long as it meets the\n   uniqueness requirements.\n\n5.4. opaquelocktoken Lock Token URI Scheme\n\n   The opaquelocktoken URI scheme is designed to be unique across all\n   resources for all time.  Due to this uniqueness quality, a client\n   MAY submit an opaque lock token in a Lock-Token request header and\n   an if-state[-not]-match header on a resource other than the one that\n   returned it.\n\n   All resources MUST recognize the opaquelocktoken scheme and, at\n   minimum, recognize that the lock token was not generated by the\n   resource.  Note, however, that resources are not required to\n   generate opaquelocktokens in LOCK method responses.\n\n   In order to guarantee uniqueness across all resources for all time\n   the opaquelocktoken requires the use of the GUID mechanism.\n\n   Opaquelocktoken generators, however, have a choice of how they\n   create these tokens.  They can either generate a new GUID for every\n   lock token they create, which is potentially very expensive, or they\n   can create a single GUID and then add extension characters.  If the\n   second method is selected then the program generating the extensions\n   MUST guarantee that the same extension will never be used twice with\n   the associated GUID.\n\n   Opaque-Lock-Token = \"opaquelocktoken\" \":\" GUID [Extension]\n   GUID = ; As defined in [Leach, Salz, 1997]\n   Extension = *urlc   ;urlc is defined in [Berners-Lee et al., 1997]\n   (draft-fielding-url-syntax-07.txt)\n\n5.5. Lock Capability Discovery\n\n   Since server lock support is optional, a client trying to lock a\n   resource on a server can either try the lock and hope for the best,\n   or perform some form of discovery to determine what lock\n   capabilities the server supports.  This is known as lock capability\n   discovery.  Lock capability discovery differs from discovery of\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   supported access control types, since there may be access control\n   types without corresponding lock types.  A client can determine what\n   lock types the server supports by retrieving the supportedlock\n   property.\n\n   Any DAV compliant resource that supports the LOCK method MUST\n   support the supportedlock property.\n\n5.6. Active Lock Discovery\n\n   If another principal locks a resource that a principal wishes to\n   access, it is useful for the second principal to be able to find out\n   who the first principal is.  For this purpose the lockdiscovery\n   property is provided.  This property lists all outstanding locks,\n   describes their type, and provides their lock token.\n\n   Any DAV compliant resource that supports the LOCK method MUST\n   support the lockdiscovery property.\n\n\n6. Write Lock\n\n   This section describes the semantics specific to the write access\n   type for locks.  The write lock is a specific instance of a lock\n   type, and is the only lock type described in this specification.  A\n   DAV compliant resource MAY support the write lock.\n\n6.1. Methods Restricted by Write Locks\n\n   A write lock prevents a principal without the lock from successfully\n   executing a PUT, POST, PATCH, PROPPATCH, MOVE, DELETE, MKCOL, ADDREF\n   or DELREF on the locked resource.  All other current methods, GET in\n   particular, function independent of the lock.\n\n   Note, however, that as new methods are created it will be necessary\n   to specify how they interact with a write lock.\n\n6.2. Write Locks and Properties\n\n   While those without a write lock may not alter a property on a\n   resource it is still possible for the values of live properties to\n   change, even while locked, due to the requirements of their schemas.\n   Only dead properties and live properties defined to respect locks\n   are guaranteed not to change while write locked.\n\n6.3. Write Locks and Null Resources\n\n   It is possible to assert a write lock on a null resource in order to\n   lock the name.  Please note, however, that locking a null resource\n   effectively makes the resource non-null, as the resource now has\n   lock related properties defined on it.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n6.4. Write Locks and Collections\n\n   A write lock on a collection prevents the addition or removal of\n   members of the collection.  As a consequence, when a principal\n   issues a request to create a new internal member of a collection\n   using PUT or POST, or to remove an existing internal member of a\n   collection using DELETE, this request MUST fail if the principal\n   does not have a write lock on the collection.\n\n   However, if a write lock request is issued to a collection\n   containing internal member resources that are currently locked in a\n   manner which conflicts with the write lock, the request MUST fail\n   with a 409 Conflict status code.\n\n6.5. Write Locks and COPY/MOVE\n\n   The owner of a write lock MUST NOT execute a MOVE method on a\n   resource he has locked.  This specification intentionally does not\n   define what happens if a MOVE method request is made on a locked\n   resource by the lock's owner.\n\n   A COPY method invocation MUST NOT duplicate any write locks active\n   on the source.\n\n6.6. Re-issuing Write Locks\n\n   If a principal already owns a write lock on a resource, any future\n   requests for the same type of write lock, on the same resource,\n   while the principal's previous write lock is in effect, MUST result\n   in a successful response with the same lock token as provided for\n   the currently existing lock.  Two lock requests are defined to be\n   identical if their Lock-Info headers are identical.\n\n6.7. Write Locks and The Lock-Token Request Header\n\n   If a user agent is not required to have knowledge about a lock when\n   requesting an operation on a locked resource, the following scenario\n   might occur.  Program A, run by User A, takes out a write lock on a\n   resource.  Program B, also run by User A, has no knowledge of the\n   lock taken out by Program A, yet performs a PUT to the locked\n   resource.  In this scenario, the PUT succeeds because locks are\n   associated with a principal, not a program, and thus program B,\n   because it is acting with principal A's credential, is allowed to\n   perform the PUT.  However, had program B known about the lock, it\n   would not have overwritten the resource, preferring instead to\n   present a dialog box describing the conflict to the user.  Due to\n   this scenario, a mechanism is needed to prevent different programs\n   from accidentally ignoring locks taken out by other programs with\n   the same authorization.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   In order to prevent these collisions the lock token request header\n   is introduced.  Please refer to the Lock Token Request Header\n   section for details and requirements.\n\n6.7.1. Write Lock Token Example\n\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n   Lock-Token: <opaquelocktoken:123AbcEfg1284h23h2>\n   <opaquelocktoken:AAAASDFcalkjfdas12312>\n\n\n   HTTP/1.1 200 OK\n\n\n   In this example, both the source and destination are locked so two\n   lock tokens must be submitted.  If only one of the two resources was\n   locked, then only one token would have to be submitted.\n\n\n7. Notational Conventions\n\n   Since this document describes a set of extensions to the HTTP/1.1\n   protocol, the augmented BNF used herein to describe protocol\n   elements is exactly the same as described in Section 2.1 of RFC\n   2068, _Hypertext Transfer Protocol -- HTTP/1.1_ [Fielding et al.,\n   1997].  Since this augmented BNF uses the basic production rules\n   provided in Section 2.2 of RFC 2068, these rules apply to this\n   document as well.\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [Bradner,\n   1997].\n\n\n8. HTTP Methods for Distributed Authoring\n\n8.1. PROPFIND\n\n   The PROPFIND method retrieves properties defined on the Request-URI,\n   if it is a non-collection resource, or on the Request-URI and\n   potentially its member resources, if the resource is a collection.\n   All DAV compliant resources MUST support the PROPFIND method.\n\n   A client MAY submit a Depth header with a PROPFIND on a collection\n   with a value of \"0\", \"1\" or \"infinity\".  DAV compliant servers MUST\n   support the \"0\", \"1\" and \"infinity\" behaviors. By default, the\n   PROPFIND method on a collection without a Depth header MUST act as\n   if a Depth = infinity header was included.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   A client MUST submit a Propfind request header describing what\n   information is being requested.  It is possible to request\n   particular property values, all property values, or a list of the\n   names of the resource's properties.\n\n   The response is a text/xml message body that contains a multistatus\n   XML element that describes the results of the attempts to retrieve\n   the various properties.  If a property was successfully retrieved\n   then its value MUST be returned in a prop XML element.  If the scope\n   of PROPFIND covers more than a single resource, as is the case with\n   Depth values of \"1\" and \"infinity\", each response XML element MUST\n   contain an href XML element which identifies the resource on which\n   the properties in the prop XML element are defined. In the case of\n   allprop and propname, if a principal does not have the right to know\n   if a particular property exists, an error MUST NOT be returned.  The\n   results of this method SHOULD NOT be cached.\n\n8.1.1. Example: Retrieving Named Properties\n\n   PROPFIND  /files/ HTTP/1.1\n   Host: www.foo.bar\n   Depth: 0\n   Propfind: <http://www.foo.bar/boxschema/bigbox> <http://www.foo.bar/\n   boxschema/author> <http://www.foo.bar/boxschema/DingALing> <http://w\n   ww.foo.bar/boxschema/Random>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <?namespace href = \"http://www.foo.bar/boxschema\" AS = R\"?>\n   <D:multistatus>\n     <D:response>\n          <D:prop>\n               <R:bigbox>\n                    <R:BoxType>Box type A</R:BoxType>\n               </R:bigbox>\n               <R:author>\n                    <R:Name>J.J. Dingleheimerschmidt</R:Name>\n               </R:author>\n          </D:prop>\n          <D:status>HTTP/1.1 200 OK</D:status>\n     </D:response>\n     <D:response>\n          <D:prop><R:DingALing/><R:Random/></D:prop>\n          <D:status>HTTP/1.1 403 Forbidden</D:status>\n          <D:responsedescription> The user does not have access to the\n   DingALing property.\n          </D:responsedescription>\n     </D:response>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n     <D:responsedescription> There has been an access violation error.\n     </D:responsedescription>\n   </D:multistatus>\n\n   In this example, PROPFIND is executed on the collection\n   http://www.foo.bar/files/.  The specified depth is zero, hence the\n   PROPFIND applies only to the collection itself, and not to any of\n   its members.  The Propfind header specifies the name of four\n   properties whose values are being requested. In this case only two\n   properties were returned, since the principal issuing the request\n   did not have sufficient access rights to see the third and fourth\n   properties.\n\n8.1.2. Example: Using allprop to Retrieve All Properties\n\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Depth: 1\n   Propfind: allprop\n\n\n   HTTP/1.1 200 OK\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"S\"?>\n   <?namespace href = \"http://www.foo.bar/boxschema/\" AS = R\"?>\n   <S:multistatus>\n     <S:response>\n          <S:href>http://www.foo.bar/container/</S:href>\n          <S:prop>\n               <R:bigbox>\n                    <R:BoxType>Box type A</R:BoxType>\n               </R:bigbox>\n               <R:author>\n                    <R:Name>Hadrian</R:Name>\n               </R:author>\n          </S:prop>\n          <S:status>HTTP 1.1 200 OK</S:status>\n     </S:response>\n     <S:response>\n          <S:href>http://www.foo.bar/container/index.html</S:href>\n          <S:prop>\n               <R:bigbox>\n                    <R:BoxType>Box type B</R:BoxType>\n               </R:bigbox>\n          </S:prop>\n          <S:status>HTTP 1.1 200 OK</S:status>\n     </S:response>\n   </S:multistatus>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   In this example, PROPFIND was invoked on the resource\n   http://www.foo.bar/container/ with a Depth header of 1, meaning the\n   request applies to the resource and its children, and a Propfind\n   header of \"allprop\", meaning the request should return the name and\n   value of all properties defined on each resource.\n\n   The resource http://www.foo.bar/container/ has two properties\n   defined on it, named http://www.foo.bar/boxschema/bigbox, and\n   http://www.foo.bar/boxschema/author, while resource\n   http://www.foo.bar/container/index.html has only a single resource\n   defined on it, named http://www.foo.bar/boxschema/bigbox, another\n   instance of the \"bigbox\" property type.\n\n8.1.3. Example: Using propname to Retrieve all Property Names\n\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Propfind: propname\n\n   HTTP/1.1 200 OK\n   Content-Type: text/xml\n   Content-Length: xxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?>\n   <?namespace href = \"http://www.foo.bar/boxschema/\" AS = \"R\"?>\n   <D:multistatus>\n     <D:response>\n          <D:href>http://www.foo.bar/container/</D:href>\n          <D:prop>\n               <R:bigbox/>\n               <R:author/>\n          </D:prop>\n          <D:status>HTTP 1.1 200 OK</D:status>\n     </D:response>\n     <D:response>\n          <D:href>http://www.foo.bar/container/index.html</D:href>\n          <D:prop>\n               <R:bigbox/>\n          </D:prop>\n          <D:status>HTTP 1.1 200 OK</D:status>\n     </D:response>\n   </D:multistatus>\n\n\n   In this example, PROPFIND is invoked on the collection resource\n   http://www.foo.bar/container/, with a Propfind header set to\n   \"propname\", meaning the name of all properties should be returned.\n   Since no depth header is present, it assumes its default value of\n   \"infinity\", meaning the name of the properties on the collection and\n   all its progeny should be returned.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Consistent with the previous example, resource\n   http://www.foo.bar/container/ has two properties defined on it,\n   http://www.foo.bar/boxschema/bigbox, and\n   http://www.foo.bar/boxschema/author.  The resource\n   http://www.foo.bar/container/index.html, a member of the \"container\"\n   collection, has only one property defined on it,\n   http://www.foo.bar/boxschema/bigbox.\n\n\n8.2. PROPPATCH\n\n   The PROPPATCH method processes instructions specified in the request\n   body to set and/or remove properties defined on the resource\n   identified by Request-URI.\n\n   All DAV compliant resources MUST support the PROPPATCH method and\n   MUST process instructions that are specified using the\n   propertyupdate, set, and remove XML elements of the DAV schema.\n   Execution of the directives in this method is, of course, subject to\n   access control constraints.  DAV compliant resources MUST support\n   the setting of arbitrary dead properties.\n\n   The request message body of a PROPPATCH method MUST contain at least\n   one propertyupdate XML element.  Instruction processing MUST occur\n   in the order instructions are received (i.e., from top to bottom),\n   and MUST be performed atomically.\n\n8.2.1. propertyupdate XML element\n\n   Name:       propertyupdate\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To contain a request to alter the properties on a\n   resource.\n   Parent:     None\n   Values=     1*(set | remove)\n   Description: This XML element is a container for the information\n   required to modify the properties on the resource.  This XML element\n   is multi-valued.\n\n8.2.2. set XML element\n\n   Name:       set\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To set the DAV properties specified inside the set XML\n   element.\n   Parent:     propertyupdate\n   Values=     prop\n   Description: This XML element MUST contain only a prop XML element.\n   The elements contained by prop specify the name and value of\n   properties that are set on the Request-URI.  If a property already\n   exists then its value is replaced.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n8.2.3. remove XML element\n\n   Name:       remove\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To remove the DAV properties specified inside the remove\n   XML element.\n   Parent:     propertyupdate\n   Values=     prop\n   Description: Remove specifies that the properties specified in prop\n   should be removed.  Specifying the removal of a property that does\n   not exist is not an error.  All the elements in prop MUST be empty,\n   as only the names of properties to be removed are required.\n\n8.2.4. Response Codes\n\n   200 OK - The command succeeded.  As there can be a mixture of sets\n   and removes in a body, a 201 Create seems inappropriate.\n\n   403 Forbidden - The client, for reasons the server chooses not to\n   specify, cannot alter one of the properties.\n\n   405 Conflict - The client has provided a value whose semantics are\n   not appropriate for the property.  This includes trying to set read-\n   only properties.\n\n   413 Request Entity Too Long - If a particular property is too long\n   to be recorded then a composite XML error will be returned\n   indicating the offending property.\n\n8.2.5. Example\n\n   PROPPATCH /bar.html HTTP/1.1\n   Host: www.foo.com\n   Content-Type: text/xml\n   Content-Length: xxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <?namespace href = \"http://www.w3.com/standards/z39.50/\" AS = \"Z\"?>\n   <D:propertyupdate>\n     <D:set>\n          <D:prop>\n               <Z:authors>\n                    <Z:Author>Jim Whitehead</Z:Author>\n                    <Z:Author>Roy Fielding</Z:Author>\n               </Z:authors>\n          </D:prop>\n     </D:set>\n     <D:remove>\n          <D:prop><Z:Copyright-Owner/></D:prop>\n     </D:remove>\n   </D:propertyupdate>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href=\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <?namespace href=\"http://www.w3.com/standards/z39.50/\" AS = \"Z\"?>\n   <D:multistatus>\n     <D:response>\n          <D:prop><Z:Authors/></D:prop>\n          <D:status>HTTP/1.1 420 Method Failure</D:status>\n     </D:response>\n     <D:response>\n          <D:prop><Z:Copyright-Owner/></D:prop>\n          <D:status>HTTP/1.1 409 Conflict</D:status>\n     </D:response>\n     <D:responsedescription> Copyright Owner can not be deleted or\n   altered.</D:responsedescription>\n   </D:multistatus>\n\n   In this example, the client requests the server to set the value of\n   the http://www.w3.com/standards/z39.50/Authors property, and to\n   remove the property http://www.w3.com/standards/z39.50/Copyright-\n   Owner.  Since the Copyright-Owner property could not be removed, no\n   property modifications occur.  The Method Failure response code for\n   the Authors property indicates this action would have succeeded if\n   it were not for the conflict with removing the Copyright-Owner\n   property.\n\n8.3. MKCOL Method\n\n   The MKCOL method is used to create a new collection. All DAV\n   compliant resources MUST support the MKCOL method.\n\n8.3.1. Request\n\n   MKCOL creates a new collection resource at the location specified by\n   the Request-URI.  If the Request-URI exists, then MKCOL must fail.\n   During MKCOL processing, a server MUST make the Request-URI a member\n   of its parent collection.  If no such ancestor exists, the method\n   MUST fail.  When the MKCOL operation creates a new collection\n   resource, all ancestors MUST already exist, or the method MUST fail\n   with a 409 Conflict status code.  For example, if a request to\n   create collection /a/b/c/d/ is made, and neither /a/b/ nor /a/b/c/\n   exists, the request MUST fail.\n\n   When MKCOL is invoked without a request body, the newly created\n   collection has no members.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   A MKCOL request message MAY contain a message body.  The behavior of\n   a MKCOL request when the body is present is limited to creating\n   collections, members of a collection, bodies of members and\n   properties on the collections or members.  If the server receives a\n   MKCOL request entity type it does not support or understand it MUST\n   respond with a 415 Unsupported Media Type status code.  The exact\n   behavior of MKCOL for various request media types is undefined in\n   this document, and will be specified in separate documents.\n\n8.3.2. Response Codes\n\n   Responses from a MKCOL request are not cacheable, since MKCOL has\n   non-idempotent semantics.\n\n   201 Created - The collection or structured resource was created in\n   its entirety.\n\n   403 Forbidden - This indicates at least one of two conditions: 1)\n   The server does not allow the creation of collections at the given\n   location in its namespace, and 2) The parent collection of the\n   Request-URI exists but cannot accept members.\n\n   405 Method Not Allowed - MKCOL can only be executed on a\n   deleted/non-existent resource.\n\n   409 Conflict - A collection cannot be made at the Request-URI until\n   one or more intermediate collections have been created.\n\n   415 Unsupported Media Type- The server does not support the request\n   type of the body.\n\n   419 Insufficient Space on Resource - The resource does not have\n   sufficient space to record the state of the resource after the\n   execution of this method.\n\n8.3.3. Example\n\n   This example creates a collection called /webdisc/xfiles/ on the\n   server www.server.org.\n\n   MKCOL /webdisc/xfiles/ HTTP/1.1\n   Host: www.server.org\n\n\n   HTTP/1.1 201 Created\n\n8.4. INDEX Method\n\n   The INDEX method is used to enumerate the members of a resource.\n   All DAV compliant resources MUST support the INDEX method if they\n   have members.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n8.4.1. The Request\n\n   For a collection, INDEX MUST return a list of its members.  All\n   WebDAV compliant resources MUST support the text/xml response entity\n   described below.  The INDEX result for a collection MAY also return\n   a list of the members of child collections, to any depth.\n\n   Collections that respond to an INDEX method with a text/xml entity\n   MUST contain a single multistatus XML element which contains a\n   response XML element for each member.\n\n   A resource that supports INDEX MUST return the resourcetype property\n   for each member.\n\n   Note that the prop XML element MAY contain additional properties.\n\n8.4.2. Example\n\n   INDEX /user/yarong/dav_drafts/ HTTP/1.1\n   Host: www.microsoft.com\n\n   HTTP/1.1 200 OK\n   Content-Type: text/xml\n   Content-Length: xxx\n   Last-Modified: Thu, 11 Sep 1997 23:45:12 GMT\n   ETag: _fooyyybar_\n\n   <?XML version=\"1.0\">\n   <?namespace href = _http://www.ietf.org/standards/dav/_ as = _D_?>\n   <D:multistatus>\n     <D:response>\n          <D:href>http://www.microsoft.com/user/yarong/dav_drafts/\n          </D:href>\n          <D:prop>\n               <D:resourcetype>\n                    <D:collection/>\n               </D:resourcetype>\n          </D:prop>\n          <D:status>HTTP 1.1 200 OK</D:status>\n     </D:response>\n     <D:response>\n          <D:href>\n          http://www.microsoft.com/user/yarong/dav_drafts/base\n          </D:href>\n          <D:prop>\n               <D:resourcetype/>\n          </D:prop>\n          <D:status>HTTP 1.1 200 OK</D:status>\n     </D:response>\n   </D:multistatus>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n8.5. ADDREF Method\n\n   The ADDREF method is used to add external members to a resource.\n   All DAV compliant collection resources MUST support the ADDREF\n   method.  All other DAV compliant resources MAY support the ADDREF\n   method as appropriate.\n\n8.5.1. The Request\n\n   The ADDREF method adds the URI specified in the Collection-Member\n   header as an external member to the collection specified by the\n   Request-URI.  The value in the Collection-Member header MUST be an\n   absolute URI meeting the requirements of an external member URI.\n\n   It is not an error if the URI specified in the Collection-Member\n   header already exists as an external member of the collection.\n   However, after processing the ADDREF there MUST be only one instance\n   of the URI in the collection.  If the URI specified in the\n   Collection-Member header already exists as an internal member of the\n   collection, the ADDREF method MUST fail with a 412 Precondition\n   Failed status code.\n\n8.5.2. Example\n\n   ADDREF /~ejw/dav/ HTTP/1.1\n   Host: www.ics.uci.edu\n   Collection-Member: http://www.ietf.org/standards/dav/\n\n\n   HTTP/1.1 200 OK\n\n\n   This example adds the URI http://www.ietf.org/standards/dav/ as an\n   external member resource of the collection\n   http://www.ics.uci.edu/~ejw/dav/.\n\n\n8.6. DELREF Method\n\n   The DELREF method is used to remove external members from a\n   resource.  All DAV compliant collection resources MUST support the\n   DELREF method.  All other DAV compliant resources MUST support the\n   DELREF method only if they support the ADDREF method.\n\n8.6.1. The Request\n\n   The DELREF method removes the URI specified in the Collection-Member\n   header from the collection specified by the Request-URI.\n\n   DELREFing a URI which is not a member of the collection is not an\n   error.  DELREFing an internal member MUST fail with a 412\n   Precondition Failed status code.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n8.6.2. Example\n\n   DELREF /~ejw/dav/ HTTP/1.1\n   Host: www.ics.udi.edu\n   Collection-Member: http://www.ietf.org/standards/dav/\n\n\n   HTTP/1.1 200 OK\n\n   This example removes the URI http://www.ietf.org/standards/dav/, an\n   external member resource, from the collection\n   http://www.ics.uci.edu/~ejw/dav/.\n\n\n8.7. GET, HEAD for Collections\n\n   The semantics of GET are unchanged when applied to a collection,\n   since GET is defined as, _retrieve whatever information (in the form\n   of an entity) is identified by the Request-URI_ [Fielding et al.,\n   1997].  GET when applied to a collection MAY return the contents of\n   an _index.html_ resource, a human-readable view of the contents of\n   the collection, or something else altogether, and hence it is\n   possible the result of a GET on a collection will bear no\n   correlation to the state of the collection.\n\n   Similarly, since the definition of HEAD is a GET without a response\n   message body, the semantics of HEAD are unmodified when applied to\n   collection resources.\n\n8.8. POST for Collections\n\n   Since by definition the actual function performed by POST is\n   determined by the server and often depends on the particular\n   resource, the behavior of POST when applied to collections cannot be\n   meaningfully modified because it is largely undefined.  Thus the\n   semantics of POST are unmodified when applied to a collection.\n\n8.9. DELETE\n\n8.9.1. DELETE Method for Non-Collection Resources\n\n   If the DELETE method is issued to a non-collection resource which is\n   an internal member of a collection, then during DELETE processing a\n   server MUST remove the Request-URI from its parent collection.  A\n   server MAY remove the URI of a deleted resource from any collections\n   of which the resource is an external member.\n\n8.9.2. DELETE for Collections\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   The DELETE method on a collection MUST act as if a Depth = Infinity\n   header was used on it.  A client MUST NOT submit a Depth header on a\n   DELETE on a collection with any value but Infinity.\n\n   DELETE instructs that the collection specified in the request-URI,\n   the records of its external member resources, and all its internal\n   member resources, are to be deleted.\n\n   If any member cannot be deleted then all of the member's progeny\n   MUST NOT be deleted, so as to maintain the namespace.\n\n   Any headers included with DELETE MUST be applied in processing every\n   resource to be deleted.  In this case, a header of special interest\n   is the Destroy header, which specifies the method to be used to\n   delete all resources in the scope of the DELETE.\n\n   When the DELETE method has completed processing it MUST return a\n   consistent namespace.\n\n   The response SHOULD be a Multi-Status response that describes the\n   result of the DELETE on each affected resource.\n\n8.9.2.1. Example\n\n   DELETE  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destroy: NoUndelete\n\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"d\"?>\n   <d:multistatus>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource1</d:href>\n          <d:href>http://www.foo.bar/container/resource2</d:href>\n          <d:status>HTTP/1.1 200 OK</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/</d:href>\n          <d:status>HTTP/1.1 420 Method Failure</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource3</d:href>\n          <d:status>HTTP/1.1 412 Precondition Failed</d:status>\n     </d:response>\n   </d:multistatus>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   In this example the attempt to delete\n   http://www.foo.bar/container/resource3 failed because the server was\n   unable to guarantee that resource3 would not be able to be\n   undeleted.  Consequently, the attempt to delete\n   http://www.foo.bar/container/ also failed, but resource1 and\n   resource2 were deleted. Even though a Depth header has not been\n   included, a depth of infinity is assumed because the method is on a\n   collection. As this example illustrates, DELETE processing need not\n   be atomic.\n\n8.10. PUT\n\n8.10.1. PUT for Non-Collection Resources\n\n   A PUT performed on an existing resource replaces the GET response\n   entity of the resource.  Properties defined on the resource MAY be\n   recomputed during PUT processing.  For example, if a server\n   recognizes the content type of the request body, it may be able to\n   automatically extract information that could be profitably exposed\n   as properties.\n\n   A PUT that would result in the creation of a resource without an\n   appropriately scoped parent collection MUST fail with a 405 Method\n   Not Allowed.\n\n8.10.2. PUT for Collections\n\n   As defined in the HTTP/1.1 specification [Fielding et al., 1997],\n   the \"PUT method requests that the enclosed entity be stored under\n   the supplied Request-URI.\"  Since submission of an entity\n   representing a collection would implicitly encode creation and\n   deletion of resources, this specification intentionally does not\n   define a transmission format for creating a collection using PUT.\n   Instead, the MKCOL method is defined to create collections.  If a\n   PUT is invoked on a collection resource it MUST fail.\n\n   When the PUT operation creates a new non-collection resource all\n   ancestors MUST already exist.  If all ancestors do not exist, the\n   method MUST fail with a 409 Conflict status code.  For example, if\n   resource /a/b/c/d.html is to be created and /a/b/c/ does not exist,\n   then the request must fail.\n\n8.11. COPY Method\n\n   The COPY method creates a duplicate of the specified resource.  All\n   DAV compliant resources MUST support the COPY method.\n\n   Support for the COPY method does not guarantee the ability to copy a\n   resource. For example, separate programs may control resources on\n   the same server.  As a result, it may not even be possible to copy a\n   resource to a location that appears to be on the same server.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n8.11.1. The Request\n\n   The COPY method creates a duplicate of the source resource, given by\n   the Request-URI, in the destination resource, given by the\n   Destination header.  The Destination header MUST be present.  The\n   exact behavior of the COPY method depends on the type of the source\n   resource.\n\n8.11.1.1. COPY for HTTP/1.1 resources\n\n   When the source resource is not a collection the body of the\n   destination resource MUST be octet-for-octet identical to the body\n   of the source resource.  Alterations to the destination resource do\n   not modify the source resource.  Alterations to the source resource\n   do not modify the destination resource.  Thus, all copies are\n   performed _by-value_.\n\n   All properties on the source resource MUST be duplicated on the\n   destination resource, subject to modifying headers, following the\n   definition for copying properties.\n\n8.11.1.2. COPY for Properties\n\n   The following section defines how properties on a resource are\n   handled during a COPY operation.\n\n   Live properties SHOULD be duplicated as identically behaving live\n   properties at the destination resource.  Since they are live\n   properties, the server determines the syntax and semantics of these\n   properties.  Properties named by the Enforce-Live-Properties header\n   MUST be live on the destination resource, or the method MUST fail.\n   If a property is not named by Enforce-Live-Properties and cannot be\n   copied live, then its value MUST be duplicated, octet-for-octet, in\n   an identically named, dead property on the destination resource.\n\n   If a property on the source already exists on the destination\n   resource and the Overwrite header is set to \"T\" then the property at\n   the destination MUST be overwritten with the property from the\n   source.  If the Overwrite header is \"F\" and the previous situation\n   exists, then the COPY MUST fail with a 409 Conflict.\n\n8.11.1.3. COPY for Collections\n\n   The COPY method on a collection without a Depth header MUST act as\n   if a Depth = infinity header was included.  A client MAY submit a\n   Depth header on a COPY on a collection with a value of \"0\" or\n   \"infinity\".  DAV compliant servers MUST support the \"0\" and\n   \"infinity\" behaviors.\n\n   A COPY of depth infinity instructs that the collection specified in\n   the Request-URI, the records of its external member resources, and\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   all its internal member resources, are to be copied to a location\n   relative to the Destination header.\n\n   A COPY of depth \"0\" only instructs that the collection, the\n   properties, and its external members, not its internal members, are\n   to be copied.\n\n   Any headers included with a COPY are to be applied in processing\n   every resource to be copied.\n\n   The exception to this rule is the Destination header. This header\n   only specifies the destination for the Request-URI.  When applied to\n   members of the collection specified in the request-URI the value of\n   Destination is to be modified to reflect the current location in the\n   hierarchy.  So, if the request-URI is \"a\" and the destination is \"b\"\n   then when a/c/d is processed it MUST use a destination of b/c/d.\n\n   When the COPY method has completed processing it MUST have created a\n   consistent namespace at the destination.  Thus if it is not possible\n   to COPY a collection with internal members, the internal members may\n   still be copied but a collection will have to be created at the\n   destination to contain them.\n\n   The response is a Multi-Status response that describes the result of\n   the COPY on each affected resource.  The response is given for the\n   resource that was to be copied, not the resource that was created as\n   a result of the copy.  In other words, each entry indicates whether\n   the copy on the resource specified in the href succeeded or failed\n   and why.\n\n   The exception to this rule is for errors that occurred on the\n   destination.  For example, if the destination was locked the\n   response would indicate the destination URL and a 421 Destination\n   Locked error.\n\n8.11.1.4. Type Interactions\n\n   If the destination resource identifies a collection and the\n   Overwrite header is _T_, prior to performing the copy the server\n   MUST perform a DELETE operation on the collection.\n\n8.11.2. Response Codes\n\n   200 OK - The source resource was successfully copied to a pre-\n   existing destination resource.\n\n   201 Created - The source resource was successfully copied.  The copy\n   operation resulted in the creation of a new resource.\n\n   412 Precondition Failed - This status code MUST be returned if the\n   server was unable to maintain the liveness of the properties listed\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   in the Enforce-Live-Properties header, or if the Overwrite header is\n   \"F\", and the state of the destination resource is non-null.\n\n   419 Insufficient Space on Resource - The destination resource does\n   not have sufficient space to record the state of the resource after\n   the execution of this method.\n\n   421 Destination Locked _ The destination resource was locked and\n   either a valid Lock-Token header was not submitted, or the Lock-\n   Token header identifies a lock held by another principal.\n\n   500 Server Error - The resource was in such a state that it could\n   not be copied.  This may occur if the Destination header specifies a\n   resource that is outside the namespace the resource is able to\n   interact with.\n\n8.11.3. Overwrite Example\n\n   This example shows resource\n   http://www.ics.uci.edu/~fielding/index.html being copied to the\n   location http://www.ics.uci.edu/users/f/fielding/index.html.  The\n   contents of the destination resource were overwritten, if non-null.\n\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n\n\n   HTTP/1.1 200 OK\n\n8.11.4. No Overwrite Example\n\n   The following example shows the same copy operation being performed,\n   except with the Overwrite header set to _F._  A response of 412\n   Precondition Failed is returned because the destination resource has\n   a non-null state.\n\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n   Overwrite: _F_\n\n\n   HTTP/1.1 412 Precondition Failed\n\n8.11.5. Collection Example\n\n   COPY /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Enforce-Live-Properties: *\n   Depth: Infinity\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"d\"?>\n   <d:multistatus>\n     <d:response>\n          <d:href>http://www.foo.bar/othercontainer/resource1</d:href>\n          <d:href>http://www.foo.bar/othercontainer/resource2</d:href>\n          <d:href>http://www.foo.bar/othercontainer/</d:href>\n          <d:href>http://www.foo.bar/othercontainer/R2/D2</d:href>\n          <d:status>HTTP/1.1 201 Created</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/othercontainer/R2/</d:href>\n          <d:status>HTTP/1.1 412 Precondition Failed</d:status>\n     </d:response>\n   </d:multistatus>\n\n   The Depth header is unnecessary as the default behavior of COPY on a\n   collection is to act as if a \"Depth: Infinity\" header had been\n   submitted.  In this example most of the resources, along with the\n   collection, were copied successfully. However the collection R2\n   failed, most likely due to a problem with enforcing live properties.\n   R2's member D2 was successfully copied.  As a result a collection\n   was created at www.foo.bar/othercontainer/R2 to contain D2.\n\n8.12. MOVE Method\n\n   The move operation on a resource is the logical equivalent of a copy\n   followed by a delete, where the actions are performed atomically.\n   All DAV compliant resources MUST support the MOVE method.\n\n   However, support for the MOVE method does not guarantee the ability\n   to move a resource to a particular destination. For example,\n   separate programs may actually control different sets of resources\n   on the same server.  Therefore, it may not even be possible to move\n   a resource within a namespace that appears to belong to the same\n   server.\n\n8.12.1. The Request\n\n   If a resource exists at the destination, the destination resource\n   will be DELETEd as a side effect of the MOVE operation, subject to\n   the restrictions of the Overwrite header.\n\n8.12.2. MOVE for Collections\n\n   MOVE instructs that the collection specified in the Request-URI, the\n   records of its external member resources, and all its internal\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   member resources, are to be moved to a location relative to the\n   Destination header.\n\n   The MOVE method on a collection MUST act as if a Depth \"infinity\"\n   header was used on it.  A client MUST NOT submit a Depth header on a\n   MOVE on a collection with any value but \"infinity\".\n\n   Any headers included with MOVE are to be applied in processing every\n   resource to be moved.\n\n   The exception to this rule is the Destination header.  The behavior\n   of this header is the same as given for COPY on collections.\n\n   When the MOVE method has completed processing it MUST have created a\n   consistent namespace on both the source and destination, creating\n   collections at the source or destination as necessary.\n\n   As specified in the definition of MOVE, a MOVE of a collection over\n   another collection causes the destination collection and all its\n   members to be deleted.\n\n   The response is a Multi-Status response that describes the result of\n   the MOVE on each effected resource.  The response is given for the\n   resource that was to be moved, not the resource that was created as\n   a result of the move.  In other words, each entry indicates whether\n   the move on the resource specified in the href succeeded or failed\n   and why.\n\n   The exception to this rule is for errors that occurred on the\n   destination.  For example, if the destination was locked the\n   response would indicate the destination URL and a 421 Destination\n   Locked error.\n\n8.12.3. Response Codes\n\n   200 OK - The move operation was successful.\n\n   409 Conflict _ The MOVE was attempted on a collection with members.\n   While the COPY part of this operation could succeed the DELETE could\n   not.  Therefore the MOVE MUST fail.\n\n   412 Precondition Failed - This status code MUST be returned if the\n   server was unable to maintain the liveness of the properties listed\n   in the Enforce-Live-Properties header, or if the Overwrite header is\n   \"F\", and the state of the destination resource is non-null.\n\n   421 Destination Locked - The destination resource was locked and\n   either a valid Lock-Token header was not submitted, or the Lock-\n   Token header identifies a lock held by another principal.\n\n   502 Bad Gateway - This may occur when the destination is\n                                                           \n                                                           o\n                                                            n another\n   server and the destination server refuses to accept the resource\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n8.12.4. Overwrite Example\n\n   This example shows resource\n   http://www.ics.uci.edu/~fielding/index.html being moved to the\n   location http://www.ics.uci.edu/users/f/fielding/index.html.  The\n   contents of the destination resource were overwritten, if non-null.\n\n   MOVE /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n\n\n   HTTP/1.1 200 OK\n\n\n8.12.5. Collection Example\n\n   MOVE /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Enforce-Live-Properties: *\n   Overwrite: False\n   Lock-Token: <OpaqueLockToken:xxxx> <OpaqueLockToken:xxxx>\n\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?>\n   <d:multistatus>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource1</d:href>\n          <d:href>http://www.foo.bar/container/resource2</d:href>\n          <d:href>http://www.foo.bar/container/</d:href>\n          <d:href>http://www.foo.bar/container/C2/R2</d:href>\n          <d:status>HTTP/1.1 201 Created</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/C2</d:href>\n          <d:status>HTTP/1.1 420 Method Failure</d:status>\n     <d:response>\n          <d:href>http://www.foo.bar/othercontainer/C2</d:href>\n          <d:status>HTTP/1.1 409 Conflict</d:status>\n     </d:response>\n   </d:multistatus>\n\n   In this example the client has submitted a number of lock tokens\n   with the request.  A lock token will need to be submitted for every\n   resource, both source and destination, anywhere in the scope of the\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   method, that is locked.  In this case the proper lock token was not\n   submitted for the destination http://www.foo.bar/othercontainer/C2.\n   This means that the resource continer/c2 could not be moved,\n   although its child container/C2/R2 could be moved.\n\n8.13. LOCK Method\n\n   The following sections describe the LOCK method, which is used to\n   take out a lock of any access type.  These sections on the LOCK\n   method describe only those semantics that are specific to the LOCK\n   method and are independent of the access type of the lock being\n   requested.  Once the general LOCK method has been described,\n   subsequent sections describe the semantics of the \"write\" access\n   type, and the write lock.\n\n8.13.1. Operation\n\n   A LOCK method invocation creates the lock specified by the Lock-Info\n   header on the Request-URI.  Lock method requests SHOULD have a XML\n   request body which contains an Owner XML element for this lock\n   request. The LOCK request MAY have a Timeout header.\n\n   A successful response to a lock invocation MUST include Lock-Token\n   and Timeout headers.  Clients MUST assume that locks may arbitrarily\n   disappear at any time, regardless of the value given in the Timeout\n   header.  The Timeout header only indicates the behavior of the\n   server if \"extraordinary\" circumstances do not occur.  For example,\n   an administrator may remove a lock at any time or the system may\n   crash in such a way that it loses the record of the lock's\n   existence. The response MUST also contain the value of the\n   lockdiscovery property in a prop XML element.\n\n8.13.2. The Effect of Locks on Properties and Collections\n\n   By default the scope of a lock is the entire state of the resource,\n   including its body and associated properties.  As a result, a lock\n   on a resource also locks the resource's properties, and a lock on a\n   property may lock a property's resource or may restrict the ability\n   to lock the property's resource.  Only a single lock token MUST be\n   used when a lock extends to cover both a resource and its\n   properties.  Note that certain lock types MAY override this\n   behavior.\n\n   For collections, a lock also affects the ability to add or remove\n   members.  The nature of the effect depends upon the type of access\n   control involved.\n\n8.13.3. Locking Replicated Resources\n\n   Some servers automatically replicate resources across multiple URLs.\n   In such a circumstance the server MAY only accept a lock on one of\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   the URLs if the server can guarantee that the lock will be honored\n   across all the URLs.\n\n8.13.4. Locking Multiple Resources\n\n   The LOCK method supports locking multiple resources simultaneously\n   by allowing for the listing of several URIs in the LOCK request.\n   These URIs, in addition to the Request-URI, are then to be locked as\n   a result of the LOCK method's invocation.  When multiple resources\n   are specified the LOCK method only succeeds if all specified\n   resources are successfully locked.\n\n   The Lock-Tree option of the lock request specifies that the resource\n   and all its internal children (including internal collections, and\n   their internal members) are to be locked.  This is another mechanism\n   by which a request for a lock on multiple resources can be\n   specified.\n\n   Currently existing locks can not be extended to cover more or less\n   resources, and any request to expand or contract the number of\n   resources in a lock MUST fail with a 409 Conflict status code. So,\n   for example, if resource A is exclusively write locked and then the\n   same principal asks to exclusively write lock resources A, B, and C,\n   the request will fail as A is already locked and the lock can not be\n   extended.\n\n   A successful result will return a single lock token which represents\n   all the resources that have been locked.  If an UNLOCK is executed\n   on this token, all associated resources are unlocked.\n\n   If the lock cannot be granted to all resources, a 409 Conflict\n   status code MUST be returned with a response entity body containing\n   a multistatus XML element describing which resource(s) prevented the\n   lock from being granted.\n\n8.13.5. Interaction with other Methods\n\n   The interaction of a LOCK with various methods is dependent upon the\n   lock type.  However, independent of lock type, a successful DELETE\n   of a resource MUST cause all of its locks to be removed.\n\n8.13.6. Lock Compatibility Table\n\n   The table below describes the behavior that occurs when a lock\n   request is made on a resource.\n\n\n   Current lock state/      Shared Lock       Exclusive\n   Lock request                               Lock\n   None                     True              True\n   Shared Lock              True              False\n   Exclusive Lock           False             False*\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   Legend: True = lock MAY be granted.  False = lock MUST NOT be\n   granted.  *=if the principal requesting the lock is the owner of the\n   lock, the lock MAY be regranted.\n\n   The current lock state of a resource is given in the leftmost\n   column, and lock requests are listed in the first row.  The\n   intersection of a row and column gives the result of a lock request.\n   For example, if a shared lock is held on a resource, and an\n   exclusive lock is requested, the table entry is _false_, indicating\n   the lock must not be granted.\n\n   If an exclusive or shared lock is re-requested by the principal who\n   owns the lock, the lock MUST be regranted.  If the lock is\n   regranted, the same lock token that was previously issued MUST be\n   returned.\n\n8.13.7. Owner XML Element\n\n   Name:       owner\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Provide information about the principal taking out a\n   lock.\n   Parent:     Any\n   Values:          XML Elements\n   Descripton: The Owner XML element provides information sufficient\n   for either directly contacting a principal (such as a telephone\n   number or Email URI), or for discovering the principal (such as the\n   URL of a homepage) who owns a lock.\n\n8.13.8. Lock Response\n\n   A successful lock response MUST contain a Lock-Token response\n   header, a Timeout header and a prop XML element in the response body\n   which contains the value of the lockdiscovery property.\n\n8.13.9. Response Codes\n\n   409 Conflict - The resource is locked, so the method has been\n   rejected.\n\n   412 Precondition Failed - The included Lock-Token was not\n   enforceable on this resource or the server could not satisfy the\n   request in the Lock-Info header.\n\n8.13.10. Example - Simple Lock Request\n\n   LOCK /workspace/webdav/proposal.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Lock-Info: LockType=Write LockScope=Exclusive\n   Timeout: Infinite; Second-4100000000\n   Content-Type: text/xml\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Content-Length: xyz\n\n   <?XML version=\"1.0\">\n   <?namespace href=\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:owner>\n      <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href>\n   </D:owner>\n\n\n   HTTP/1.1 200 OK\n   Lock-Token: opaquelocktoken:xyz122393481230912asdfa09s8df09s7df\n   Timeout: Second-604800\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:prop>\n     <D:lockdiscovery>\n          <D:activelock>\n               <D:locktype>write</D:locktype>\n               <D:lockscope>exclusive</D:lockscope>\n               <D:addlocks/>\n               <D:owner>\n                    <D:href>\n                    http://www.ics.uci.edu/~ejw/contact.html\n                    </D:href>\n               </D:owner>\n               <D:timeout>Second-604800</D:timeout>\n               <D:locktoken>\n                    <D:href>\n               opaquelocktoken:xyz122393481230912asdfa09s8df09s7df\n                    </D:href>\n               </D:locktoken>\n          </D:activelock>\n     </D:lockdiscovery>\n   </D:prop>\n\n   This example shows the successful creation of an exclusive write\n   lock on resource\n   http://webdav.sb.aol.com/workspace/webdav/proposal.doc.  The\n   resource http://www.ics.uci.edu/~ejw/contact.html contains contact\n   information for the owner of the lock.  The server has an activity-\n\n   based timeout policy in place on this resource, which causes the\n   lock to automatically be removed after 1 week (604800 seconds).  The\n   response has a Lock-Token header that gives the lock token URL that\n   uniquely identifies the lock created by this lock request.\n\n8.13.11. Example - Multi-Resource Lock Request\n\n   LOCK /workspace/webdav/proposal.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Lock-Info: LockType=Write LockScope=Exclusive\n   Addlocks=<http://webdav.sb.aol.com/workspace/><http://foo.bar/blah>\n   Timeout: Infinite, Second-4100000000\n\n   <?XML version=\"1.0\">\n   <?namespace href=\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:href>http://www.ics.uci.edu/~ejw/contact.html<D:href>\n\n\n   HTTP/1.1 409 Conflict\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?>\n   <D:multistatus>\n     <D:response>\n          <D:href>\n               http://webdav.sb.aol.com/workspace/webdav/proposal.doc\n          </D:href>\n          <D:href>\n               http://webdav.sb.aol.com/workspace/webdav/\n          </D:href>\n          <D:status>HTTP/1.1 202 Accepted</D:status>\n     </D:response>\n     <D:response>\n          <D:href>http://foo.bar/blah</D:href>\n          <D:status>HTTP/1.1 403 Forbidden</D:status>\n     </D:response>\n   </D:multistatus>\n\n   This example shows a request for an exclusive write lock on three\n   resources, http://webdav.sb.aol.com/workspace/webdav/proposal.doc,\n   http://webdav.sb.aol.com/workspace/, and http://foo.bar/blah.  In\n   this request, the client has specified that it desires an infinite\n   length lock, if available, otherwise a timeout of 4.1 billion\n   seconds, if available.  The Owner header field specifies the web\n   address for contact information for the principal taking out the\n   lock.\n\n   This lock request has failed, because the server rejected the lock\n   request for http://foo.bar/blah.  The 409 Conflict status code\n   indicates that the server was unable to satisfy the request because\n   there is a conflict between the state of the resources and the\n   operation named in the request.  Within the multistatus, the 202\n   Accepted status code indicates that the lock method was accepted by\n   the resources, and would have been completed if all resources named\n   in the request were able to be locked.  The 403 Forbidden status\n   code indicates that the server does not allow lock requests on this\n   resource.\n\n8.14. UNLOCK Method\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   The UNLOCK method removes the lock identified by the lock token in\n   the Lock-Token header from the Request-URI, and all other resources\n   included in the lock.\n\n   Any DAV compliant resource which supports the LOCK method MUST\n   support the UNLOCK method.\n\n8.14.1. Example\n\n   UNLOCK /workspace/webdav/info.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Lock-Token:opaquelocktoken:123AbcEfg1284h23h2\n\n   HTTP/1.1 200 OK\n\n\n   In this example, the lock identified by the lock token\n   \"opaquelocktoken:123AbcEfg1284h23h2\" is successfully removed from\n   the resource http://webdav.sb.aol.com/workspace/webdav/info.doc.  If\n   this lock included more than just one resource, the lock was removed\n   from those resources as well.\n\n8.15. PATCH Method\n\n   The PATCH method is used to modify parts of the entity returned in\n   the response to a GET method.  DAV compliant resources MAY support\n   the PATCH method.\n\n8.15.1. The Request\n\n   The request entity of the PATCH method contains a list of\n   differences between the resource identified by the Request-URI and\n   the desired content of the resource after the PATCH action has been\n   applied.  The list of differences is in a format defined by the\n   media type of the entity (e.g., \"application/diff\") and must include\n   sufficient information to allow the server to convert the original\n   version of the resource to the desired version.  Processing\n   performed by PATCH is atomic.  Hence all changes MUST be\n   successfully executed or the method fails.  PATCH MUST fail if\n   executed on a non-existent resource; i.e., PATCH does not create a\n   resource as a side effect.\n\n   If the request appears (at least initially) to be acceptable, the\n   server MUST transmit an interim 100 response message after receiving\n   the empty line terminating the request headers and continue\n   processing the request.  Since the semantics of PATCH are non-\n   idempotent, responses to this method are not cacheable.\n\n   While server support for PATCH is optional, if a server does support\n   PATCH, it MUST support at least the text/xml diff format defined\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   below.  Support for the VTML difference format [VTML] is\n   recommended, but not required.\n\n8.15.2. text/xml elements for PATCH\n\n   The resourceupdate XML element contains a set of XML sub-entities\n   that describe modification operations.  The name and meaning of\n   these XML elements are given below.  Processing of these directives\n   MUST be performed in the order encountered within the XML document.\n   A directive operates on the resource as modified by all previous\n   directives (executed in sequential order).  The length of the\n   resource MAY be extended or reduced by a PATCH.\n\n   The changes specified by the resourceupdate XML element MUST be\n   executed atomically.\n\n8.15.2.1. resourceupdate XML Element\n\n   Name:       resourceupdate\n   Namespace:  http://www.ietf.org/standards/dav/patch/\n   Purpose:    Contains an ordered set of changes to a non-collection,\n   non-property resource.\n   Parent:     None\n   Value=      *(insert | delete | replace)\n\n8.15.2.2. insert XML Element\n\n   Name:       insert\n   Namespace:  http://www.ietf.org/standards/dav/patch/\n   Purpose:    Insert the XML element's contents starting at the\n   specified octet.\n   Parent:     resourceupdate\n   Value:      The insert XML element MUST contain an octet-range XML\n   attribute that specifies an octet position within the body of a\n   resource.  A value of _end_ specifies the end of the resource.  The\n   body of the insert XML element contains the octets to be inserted.\n\n   Please note that in order to protect the white space contained in\n   this XML element the following attribute/value MUST be included in\n   the element: XML-SPACE = \"PRESERVE\". This attribute is defined in\n   the XML specification [Bray, Sperberg-McQueen, 1997].\n\n8.15.2.3. delete XML Element\n\n   Name:       delete\n   Namespace:  http://www.ietf.org/standards/dav/patch/\n   Purpose:    Removes the specified range of octets.\n   Parent:     resourceupdate\n   Value:      The delete XML element MUST contain an octet-range XML\n   attribute.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Discussion: The octets that are deleted are removed, which means the\n   resource is collapsed and the length of the resource is decremented\n   by the size of the octet range.  It is not appropriate to replace\n   deleted octets with zeroed-out octets, since zero is a valid octet\n   value.\n\n8.15.2.4. replace XML Element\n\n   Name:       replace\n   Namespace:  http://www.ietf.org/standards/dav/patch/\n   Purpose:    Replaces the specified range of octets with the contents\n   of the XML element.  If the number of octets in the XML element is\n   different from the number of octets specified, the update MUST be\n   rejected.\n   Parent:     resourceupdate\n   Value:      The replace XML element MUST contain an octet-range XML\n   attribute.  The contents of the entity are the replacement octets.\n\n   Please note that in order to protect the white space contained in\n   this XML element the following attribute/value MUST be included in\n   the element: XML-SPACE = \"PRESERVE\"\n                                     .\n                                       \n                                       This attribute is defined in the\n   XML specification [Bray, Sperberg-McQueen, 1997].\n\n8.15.2.5. octet-range Attribute\n\n   Name:       octet-range\n   Namespace:  http://www.ietf.org/standards/dav/patch/\n   Purpose:    Specifies a range of octets that the enclosing property\n   affects.\n   Parent:     insert | delete | replace\n   Value:      number [_-_ (number | _end_)]\n               Number = 1*Digit\n\n   Description: Octet numbering begins with 0.  If the octet contains a\n   single number then the operation is to begin at that octet and to\n   continue for a length specified by the operation.  In the case of a\n   delete, this would mean to delete a single octet.  In the case of an\n   insert this would mean to begin the insertion at the specified octet\n   and to continue for the length of the included value, extending the\n   resource if necessary.  In the case of replace, the replace begins\n   at the specified octet and overwrites all that follow to the length\n   of the included value.\n\n8.15.3. Response Codes\n\n   200 OK - The request entity body was processed without error,\n   resulting in an update to the state of the resource.\n\n   409 Conflict - If the update information in the request message body\n   does not make sense given the current state of the resource (e.g.,\n   an instruction to delete a non-existent line), this status code MAY\n   be returned.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   415 Unsupported Media Type - The server does not support the content\n   type of the update instructions in the request message body.\n\n   418 Unprocessable Entity - The entity body submitted with the PATCH\n   was not understood by the resource.\n\n   419 Insufficient Space on Resource - The resource does not have\n   sufficient space to record the state of the resource after the\n   execution of this method.\n\n8.15.4. HTML file modification Example\n\n   The following example shows a modification of the title and contents\n   of the HTML resource http://www.example.org/hello.html.\n\n   Before:\n   <HTML>\n   <HEAD>\n   <TITLE>Hello world HTML page</TITLE>\n   </HEAD>\n   <BODY>\n   <P>Hello, world!</P>\n   </BODY>\n   </HTML>\n\n   PATCH Request:                       Response:\n\n   PATCH hello.html HTTP/1.1\n   Host: www.example.org\n   Content-Type: text/xml\n   Content-Length: xxx\n\n                                        HTTP/1.1 100 Continue\n\n   <?XML version=\"1.0\">\n   <?namespace href = _http://www.ietf.org/standards/dav/patch/_ AS =\n   _D_?>\n   <D:resourceupdate>\n     <D:replace XML-SPACE = \"PRESERVE\">\n          <D:octet-range>14</D:octet-range>&003CTITLE&003ENew\n   Title&003C/TITLE&003E</D:replace>\n     <D:delete><D:octet-range>38-50</D:octet-range></D:delete>\n     <D:insert XML-SPACE = \"PRESERVE\"><D:octet-range>86</D:octet-\n   range>&003CP&003ENew paragraph&003C/P&003E</D:insert>\n   </D:resourceupdate>\n\n\n                                        HTTP/1.1 200 OK\n\n   After:\n   <HTML>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   <HEAD>\n   <TITLE>New Title</TITLE>\n   </HEAD>\n   <BODY>\n   <P>Hello, world!</P>\n   <P>New paragraph</P>\n   </BODY>\n   </HTML>\n\n\n9. HTTP Headers for Distributed Authoring\n\n9.1. Collection-Member Header\n\n   CollectionMember = \"Collection-Member\" \":\" URI   ; URI is defined in\n   section 3.2.1 of [Fielding et al., 1997]\n\n   The Collection-Member header specifies the URI of an external\n   resource to be added/deleted to/from a collection.\n\n9.2. DAV Header\n\n   DAV = \"DAV\" \":\" (\"1\" | \"2\" | extend)\n\n   This header indicates that the resource supports the DAV schema and\n   protocol to the level indicated.  All DAV compliant resources MUST\n   return the DAV header on all OPTIONS responses.\n\n9.3. Depth Header\n\n   Depth = \"Depth\" \":\" (\"0\" | \"1\" | \"infinity\")\n\n   The Depth header is used with methods executed on collections to\n   indicate whether the method is to be applied only to the collection\n   (Depth = 0), to the collection and its immediate children, (Depth =\n   1), or the collection and all its progeny (Depth = infinity).  Note\n   that Depth = 1 and Depth = infinity behavior only applies to\n   internal member resources, and not to external member resources.\n\n   The Depth header is only supported if a method's definition\n   explicitly provides for such support.\n\n   The following rules are the default behavior for any method that\n   supports the depth header. A method MAY override these defaults by\n   defining different behavior in its definition.\n\n   Methods which support the depth header MAY choose not to support all\n   of the header's values and MAY define, on a case by case basis, the\n   behavior of the method on a collection if a depth header is not\n   present. For example, the MOVE method only supports Depth = infinity\n   and if a depth header is not present will act as if a Depth =\n   infinity header had been applied.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   Clients MUST NOT rely upon methods executing on members of their\n   hierarchies in any particular order or the execution being atomic.\n   Note that methods MAY provide guarantees on ordering and atomicity.\n\n   Upon execution, a method with a depth header will perform as much of\n   its assigned task as possible and then return a response specifying\n   what it was able to accomplish and what it failed to do.\n\n   So, for example, an attempt to COPY a hierarchy may result in some\n   of the members being copied and some not.\n\n   Any headers on a method with a depth header MUST be applied to all\n   resources in the scope of the method. For example, an if-match\n   header will have its value applied against every resource in the\n   method's scope and will cause the method to fail if the header fails\n   to match.\n\n   If a resource, source or destination, within the scope of the method\n   is locked in such a way as to prevent the successful execution of\n   the method, then the lock token for that resource MUST be submitted\n   with the request in the Lock-Token request header.\n\n9.4. Destination Header\n\n   Destination = \"Destination\" \":\" URI\n\n   The Destination header specifies a destination resource for methods\n   such as COPY and MOVE, which take two URIs as parameters.\n\n9.5. Destroy Header\n\n   DestroyHeader = \"Destroy\" \":\" #Choices\n\n   Choices = \"VersionDestroy\" | \"NoUndelete\" | \"Undelete\" | extend\n\n   Extend = RFC-Reg | Coded-URL\n\n   RFC-Req = Token ; This is a token value (defined in section 2.2 of\n   [Fielding et al., 1997]) that has been published as an RFC.\n\n   Coded-URL = \"<\" URI \">\"\n\n   When deleting a resource the client often wishes to specify exactly\n   what sort of delete should be performed.  The Destroy header, used\n   with the Mandatory header, allows the client to specify the end\n   result it desires.  The Destroy header is specified as follows:\n\n   The Undelete token requests that, if possible, the resource should\n   be left in a state such that it can be undeleted.  The server is not\n   required to honor this request.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   The NoUndelete token requests that the resource MUST NOT be left in\n   a state such that it can be undeleted.\n\n   The VersionDestroy token includes the functionality of the\n   NoUndelete token and extends it to include having the server remove\n   all versioning references to the resource that it has control over.\n\n9.6. Enforce-Live-Properties Header\n\n   EnforceLiveProperties = \"Enforce-Live-Properties_ _:\" (_*_ | \"Omit\"\n   | 1*(Property-Name))\n\n   Property-Name = Coded-URL\n\n   The Enforce-Live-Properties header specifies properties that MUST be\n   _live_ after they are copied (moved) to the destination resource of\n   a copy (or move).  If the value _*_ is given for the header, then it\n   designates all live properties on the source resource.  If the value\n   is \"Omit\" then the server MUST NOT duplicate on the destination\n   resource any properties that are defined on the source resource.  If\n   this header is not included then the server is expected to act as\n\n   defined by the default property handling behavior of the associated\n   method.\n\n9.7. If-None-State-Match\n\n   If-None-State-Match = \"If-None-State-Match\" \":\" 1#Coded-URL\n\n   The If-None-State-Match header is intended to have similar\n   functionality to the If-None-Match header defined in section 14.26\n   of RFC 2068.  However the if-none-state-match header is intended for\n   use with any URI which represents state information about a\n   resource, referred to as a state token.  A typical example is a lock\n   token.\n\n   If any of the state tokens identifies the current state of the\n   resource, the server MUST NOT perform the requested method.\n   Instead, if the request method was GET, HEAD, INDEX, or PROPFIND,\n   the server SHOULD respond with a 304 Not Modified response,\n   including the cache-related entity-header fields (particularly ETag)\n   of the current state of the resource.  For all other request\n   methods, the server MUST respond with a status of 412 Precondition\n   Failed.\n\n   If none of the state tokens identifies the current state of the\n   resource, the server MAY perform the requested method.\n\n   If any of the tokens is not recognized then the method MUST fail\n   with a 412 Precondition Failed.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Note that the \"AND\" and \"OR\" keywords specified with the If-State-\n   Match header are intentionally not defined for If-None-State-Match,\n   because this functionality is not required.\n\n9.8. If-State-Match\n\n   If-State-Match = \"If-State-Match\" \":\" (\"AND\" | \"OR\") 1#Coded-URL\n\n   The If-State-Match header is intended to have similar functionality\n   to the If-Match header defined in section 14.25 of RFC 2068.\n   However the If-State-Match header is intended for use with any URI\n   which represents state information about a resource.  A typical\n   example is a lock token.\n\n   If the AND keyword is used and all of the state tokens identify the\n   state of the resource, then the server MAY perform the requested\n   method.  If the OR keyword is used and any of the state tokens\n   identifies the current state of the resource, then the server MAY\n   perform the requested method.  If the keyword requirement for the\n   the keyword used is not met, the server MUST NOT perform the\n   requested method, and MUST return a 412 Precondition Failed\n   response.\n\n   If any of the tokens is not recognized then the method MUST fail\n   with a 412 Precondition Failed.\n\n9.9. Lock-Info Request Header\n\n   LockInfo = \"Lock-Info\" \":\" DAVLockType SP DAVLockScope [SP\n   AdditionalLocks] [SP Lock-Tree]\n   DAVLockType = \"LockType\" \"=\" DAVLockTypeValue\n   DAVLockTypeValue = (\"Write\" | Extend)\n   DAVLockScope = \"LockScope\" \"=\" DAVLockScopeValue\n   DAVLockScopeValue = (\"Exclusive\" |\"Shared\" | Extend)\n   AdditionalLocks = \"AddLocks\" \"=\" 1*(\"<\" URI \">\")\n   Lock-Tree = \"Lock-Tree\" \"=\" (\"T\" | \"F\")\n\n   The Lock-Info request header specifies the scope and type of a lock\n   for a LOCK method request.  The syntax specification below is\n   extensible, allowing new type and scope identifiers to be added.\n\n   The LockType field specifies the access type of the lock.  At\n   present, this specification only defines one lock type, the \"Write\"\n   lock.  The LockScope field specifies whether the lock is an\n   exclusive lock, or a shared lock.  The AddLocks field specifies\n   additional URIs, beyond the Request-URI, to which the lock request\n   applies.  The LockTree field is used to specify recursive locks.  If\n   the LockTree field is \"T\", the lock request applies to the hierarchy\n   traversal of the internal member resources of the Request-URI, and\n   the AddLocks URIs, inclusive of the Request-URI and the AddLocks\n   URIs.  It is not an error if LockTree is \"T\", and the Request-URI or\n   the AddLocks URIs have no internal member resources.  By default,\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   the value of LockTree is \"F\", and this field MAY be omitted when its\n   value is \"F\".\n\n9.10. Lock-Token Request Header\n\n   Lock-Token = \"Lock-Token\" \":\" 1#Coded-URL\n\n   The Lock-Token request header, containing a lock token owned by the\n   requesting principal, is used by the principal to indicate that the\n   principal is aware of the existence of the lock specified by the\n   lock token.\n\n   If the following conditions are met:\n\n   1) The method is restricted by a lock type that requires the\n   submission of a lock token, such as a write lock,\n   2) The user-agent has authenticated itself as a principal,\n   3) The user-agent is submitting a method request to a resource on\n   which the principal owns a write lock,\n\n   Then:\n\n   1) The method request MUST include a Lock-Token header with the lock\n      token, or,\n   2) The method MUST fail with a 409 Conflict status code.\n\n   If multiple resources are involved with a method, such as a COPY or\n   MOVE method, then the lock tokens, if any, for all involved\n   resources, MUST be included in the Lock-Token request header.\n\n   For example, Program A, used by user A, takes out a write lock on a\n   resource.  Program A then makes a number of PUT requests on the\n   locked resource.  All the requests contain a Lock-Token request\n   header that includes the write lock state token.  Program B, also\n   run by User A, then proceeds to perform a PUT to the locked\n   resource.  However, program B was not aware of the existence of the\n   lock and so does not include the appropriate Lock-Token request\n   header.  The method is rejected even though principal A is\n   authorized to perform the PUT.  Program B can, if it so chooses, now\n   perform lock discovery and obtain the lock token.  Note that\n   programs A and B can perform GETs without using the Lock-Token\n   header because the ability to perform a GET is not affected by a\n   write lock.\n\n   Having a lock token provides no special access rights.  Anyone can\n   find out anyone else's lock token by performing lock discovery.\n   Locks are to be enforced based upon whatever authentication\n   mechanism is used by the server, not based on the secrecy of the\n   token values.\n\n9.11. Lock-Token Response Header\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Lock-Token = \"Lock-Token\" \":\" Coded-URL\n\n   If a resource is successfully locked then a Lock-Token header will\n   be returned containing the lock token that represents the lock.\n\n9.12. Overwrite Header\n\n   Overwrite = \"Overwrite\" \":\" (\"T\" | \"F\")\n\n   The Overwrite header specifies whether the server should overwrite\n   the state of a non-null destination resource during a COPY or MOVE.\n   A value of _F_ states that the server MUST NOT perform the COPY or\n   MOVE operation if the state of the destination resource is non-null.\n   By default, the value of Overwrite is _T,_ and a client MAY omit\n   this header from a request when its value is _T._ While the\n   Overwrite header appears to duplicate the functionality of the If-\n   Match: * header of HTTP/1.1, If-Match applies only to the Request-\n   URI, and not to the Destination of a COPY or MOVE.\n\n   If a COPY or MOVE is not performed due to the value of the Overwrite\n   header, the method MUST fail with a 409 Conflict status code.\n\n9.13. Propfind Request Header\n\n   Propfind = \"Propfind\" \":\" (\"allprop\" | \"propname\" | RFC-Reg |\n   1*(Property-Name))\n\n   The Propfind header is used to specify which properties are to be\n   returned in a PROPFIND method.  The properties are identified by\n   their URIs.  Two special tokens are defined for use with the\n   Propfind header, allprop and propname.  The allprop token specifies\n   that all property names and values on the resource are to be\n   returned.  The propname token specifies that only a list of property\n   names on the resource are to be returned.\n\n9.14. Status-URI Response Header\n\n   The Status-URI response header MAY be used with the 102 Processing\n   response code to inform the client as to the status of a method.\n\n   Status-URI = \"Status-URI\" \":\" *(Status-Code \"<\" URI \">\") ; Status-\n   Code is defined in 6.1.1 of [Fielding et al., 1997]\n\n   The URIs listed in the header are source resources which have been\n   affected by the outstanding method.  The status code indicates the\n   resolution of the method on the identified resource.  So, for\n   example, if a MOVE method on a collection is outstanding and a 102\n   \"Processing\" response with a Status-URI response header is returned,\n   the included URIs will indicate resources that have had move\n   attempted on them and what the result was.\n\n9.15. Timeout Header\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n   TimeOut = \"Timeout\" \":\" 1#TimeType\n   TimeType = (\"Second-\" DAVTimeOutVal | \"Infinite\" | Other)\n   DAVTimeOutVal = 1*digit\n   Other = Extend field-value   ; See section 4.2 of RFC 2068\n\n   Clients MAY include Timeout headers in their LOCK requests.\n   However, the server is not required to honor or even consider these\n   requests.  Clients MUST NOT submit a Timeout request header with any\n   method other than a LOCK method.\n\n   A Timeout request header MUST contain at least one TimeType and MAY\n   contain multiple TimeType entries. The purpose of listing multiple\n   TimeType entries is to indicate multiple different values and value\n   types that are acceptable to the client.  The client lists the\n   TimeType entries in order of preference.\n\n   The Timeout response header MUST use a Second value, Infinite, or a\n   TimeType the client has indicated familiarity with.  The server MAY\n   assume a client is familiar with any TimeType submitted in a Timeout\n   header.\n\n   The _Second_ TimeType specifies the number of seconds that MUST\n   elapse between granting of the lock at the server, and the automatic\n   removal of the lock.  A server MUST not generate a timeout value for\n   _Second_ greater than 2^32-1.\n\n   The timeout counter is restarted any time an owner of the lock sends\n   a method to any member of the lock, including unsupported methods,\n   or methods which are unsuccessful.  It is recommended that the HEAD\n   method be used when the goal is simply to restart the timeout\n   counter.\n\n   If the timeout expires then the lock is lost.  Specifically the\n   server SHOULD act as if an UNLOCK method was executed by the server\n   on the resource using the lock token of the timed-out lock,\n   performed with its override authority. Thus logs should be updated\n   with the disposition of the lock, notifications should be sent,\n   etc., just as they would be for an UNLOCK request.\n\n   Servers are advised to pay close attention to the values submitted\n   by clients, as they will be indicative of the type of activity the\n   client intends to perform.  For example, an applet running in a\n   browser may need to lock a resource, but because of the instability\n   of the environment within which the applet is running, the applet\n   may be turned off without warning.  As a result, the applet is\n   likely to ask for a relatively small timeout value so that if the\n   applet dies, the lock can be quickly harvested.  However, a document\n   management system is likely to ask for an extremely long timeout\n   because its user may be planning on going off-line.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n10. Response Code Extensions to HTTP/1.1\n\n   The following response codes are added to those defined in HTTP/1.1\n   [Fielding et al., 1997].\n\n10.1. 102 Processing\n\n   Methods can potentially take a long period of time to process,\n   especially methods that support the Depth header.  In such cases the\n   client may time-out the connection while waiting for a response.  To\n   prevent this the server MAY return a 102 response code to indicate\n   to the client that the server is still processing the method.\n\n   If a method is taking longer than 20 seconds (a reasonable, but\n   arbitrary value) to process the server SHOULD return a 102\n   \"Processing\" response.\n\n10.2. 207 Multi-Status\n\n   The response requires providing status for multiple independent\n   operations.\n\n10.3. 418 Unprocessable Entity\n\n   The server understands the content type of the request entity, but\n   was unable to process the contained instructions.\n\n10.4. 419 Insufficient Space on Resource\n\n   The resource does not have sufficient space to record the state of\n   the resource after the execution of this method.\n\n10.5. 420 Method Failure\n\n   The method was not executed on a particular resource within its\n   scope because some part of the method's execution failed causing the\n   entire method to be aborted.  For example, if a resource could not\n   be moved as part of a MOVE method, all the other resources would\n   fail with a 420 Method Failure.\n\n10.6. 421 Destination Locked\n\n   The destination resource of a method is locked, and either the\n   request did not contain a valid Lock-Info header, or the Lock-Info\n   header identifies a lock held by another principal.\n\n\n11. Multi-Status Response\n\n   The default 207 Multi-Status response body is a text/xml HTTP entity\n   that contains a single XML element called multistatus, which\n   contains a set of XML elements called response, one for each 200,\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   300, 400, and 500 series status code generated during the method\n   invocation.  100 series status codes MUST NOT be recorded in a\n   response XML element.\n\n11.1. multistatus XML Element\n\n   Name:       multistatus\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains multiple response messages.\n   Parent:     Any\n   Value:      1*response [responsedescription]\n   Description: The responsedescription at the top level is used to\n   provide a general message describing the overarching nature of the\n   response.  If this value is available an application MAY use it\n   instead of presenting the individual response descriptions contained\n   within the responses.\n\n11.2. response XML Element\n\n   Name:       response\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Holds a single response\n   Parent:     multistatus\n   Value:      href [prop] status [responsedescription]\n   Description: Prop MUST contain one or more empty XML elements\n   representing the names of properties.  Multiple properties may be\n   included if the same response applies to them all.  If href is used\n   then the response refers to a problem with the referenced resource,\n   not a property.\n\n11.3. status XML Element\n\n   Name:       status\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Holds a single HTTP status-line\n   Parent:     response\n   Value:      status-line   ;status-line defined in [Fielding et al.,\n   1997]\n\n11.4. responsedescription XML Element\n\n   Name:       responsedescription\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains a message that can be displayed to the user\n   explaining the nature of the response.\n   Parent:     multistatus | response\n   Value:      Any\n   Description: This XML element provides information suitable to be\n   presented to a user.\n\n\n12. Generic DAV XML Elements\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n12.1. href XML Element\n\n   Name:       href\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To identify that the content of the element is a URI.\n   Parent:     Any\n   Value:      URI ; See section 3.2.1 of [Fielding et al., 1997]\n\n12.2. link XML Element\n\n   Name:       link\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To identify a property as a link and to contain the\n   source and destination of that link.\n   Values=     1*src 1*dst\n   Description: Link is used to provide the sources and destinations of\n   a link.  The type of the property containing the link XML element\n   provides the type of the link.  Link is a multi-valued element, so\n   multiple Links may be used together to indicate multiple links with\n   the same type.\n\n12.2.1. src XML Element\n\n   Name:       src\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To indicate the source of a link.\n   Parent:     link\n   Values=     URI\n\n12.2.2. dst XML Element\n\n   Name:       dst\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To indicate the destination of a link\n   Parent:     link\n   Values=     URI\n\n12.2.3. Example\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <?namespace href = \"http://www.foocorp.com/Project/\" AS = \"F\"?>\n   <D:prop>\n     <D:Source>\n          <D:link>\n               <F:projfiles>Source</F:projfiles>\n               <D:src>http://foo.bar/program</D:src>\n               <D:dst>http://foo.bar/src/main.c</D:dst>\n          </D:link>\n          <D:link>\n               <F:projfiles>Library</F:projfiles>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n               <D:src>http://foo.bar/program</D:src>\n               <D:dst>http://foo.bar/src/main.lib</D:dst>\n          </D:link>\n          <D:link>\n               <F:projfiles>Makefile</F:projfiles>\n               <D:src>http://foo.bar/program</D:src>\n               <D:dst>http://foo.bar/src/makefile</D:dst>\n          </D:link>\n     </D:Source>\n   </D:prop>\n\n   In this example the resource http://foo.bar/program has a source\n   property that contains three links.  Each link contains three\n   elements, two of which, src and dst, are part of the DAV schema\n   defined in this document, and one which is defined by the schema\n   http://www.foocorp.com/project/ (Source, Library, and Makefile).  A\n   client which only implements the elements in the DAV spec will not\n   understand the foocorp elements and will ignore them, thus seeing\n   the expected source and destination links.  An enhanced client may\n   know about the foocorp elements and be able to present the user with\n   additional information about the links.  This example demonstrates\n   the power of XML markup that allows for element values to be\n   enhanced without breaking older clients.\n\n12.3. prop XML element\n\n   Name:       prop\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains properties related to a resource.\n   Parent:     Any\n   Values:     XML Elements\n   Description: The prop XML element is a generic container for\n   properties defined on resources.  All elements inside prop MUST\n   define properties related to the resource.  No other elements may be\n   used inside of a prop element.\n\n\n13. DAV Properties\n\n13.1. creationdate Property\n\n   Name:       creationdate\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    The time and date the resource was created.\n   Value:      The time and date MUST be given in ISO 8601 format\n   [ISO8601]\n   Description: This property SHOULD be defined on all DAV compliant\n   resources.  If present, it contains a timestamp of the moment when\n   the resource was created (i.e., the moment it had non-null state).\n\n13.2. displayname Property\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Name:       displayname\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    A name for the resource that is suitable for\n   presentation to a user.\n   Value:      Any valid XML character data (as defined in [Bray,\n   Sperberg-McQueen, 1997])\n   Description:This property SHOULD be defined on all DAV compliant\n   resources.  If present, the property contains a description of the\n   resource that is suitable for presentation to a user.\n\n13.3. get-content-language Property\n\n   Name:       get-content-language\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Content-Language header returned by a GET\n   without accept headers.  If no Content-Language header is available,\n   this property MUST NOT exist.\n   Value:      language-tag   ;language-tag is defined in section 14.13\n   of RFC 2068\n\n13.4. get-content-length Property\n\n   Name:       get-content-length\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Content-Length header returned by a GET\n   without accept headers.  If no Content-Length header is available,\n   this property MUST NOT exist.\n   Value:      content-length ; see section 14.14 of RFC 2068\n\n13.5. get-content-type Property\n\n   Name:       get-content-type\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Content-Type header returned by a GET\n   without accept headers.  If no Content-Type header is available,\n   this property MUST NOT exist.\n   Value:      media-type   ; defined in Section 3.7 of [Fielding et\n   al., 1997]\n\n13.6. get-etag Property\n\n   Name:       get-etag\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the ETag header returned by a GET without\n   accept headers.  If no ETag header is available, this property MUST\n   NOT exist.\n   Value:      entity-tag  ; defined in Section 3.11 of [Fielding et\n   al., 1997]\n   Description:Note that the ETag on some resource may reflect changes\n   in any part of the state of the resource, not necessarily just a\n   change to the response to the GET method.  For example, a change in\n   the ACL may cause the ETag to change.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n13.7. get-last-modified Property\n\n   Name:       get-last-modified\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Last-Modified header returned by a GET\n   method without accept headers.  If no Last-Modified header is\n   available, this property MUST NOT exist.\n   Value:      HTTP-date  ; defined in Section 3.3.1 of [Fielding et\n   al., 1997]\n   Description:Note that the last-modified date on some resource may\n   reflect changes in any part of the state of the resource, not\n   necessarily just a change to the response to the GET method.  For\n   example, a change in a property may cause the last-modified date to\n   change.\n\n13.8. index-content-language Property\n\n   Name:       index-content-language\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Content-Language header returned by an\n   INDEX without accept headers.  If no Content-Language header is\n   available, this property MUST NOT exist.\n   Value:      language-tag   ;language-tag is defined in section 14.13\n   of RFC 2068\n\n13.9. index-content-length Property\n\n   Name:       index-content-length\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Content-Length header returned by an INDEX\n   without accept headers.  If no Content-Length header is available,\n   this property MUST NOT exist.\n   Value:      content-length ; see section 14.14 of RFC 2068\n\n13.10. index-content-type Property\n\n   Name:       index-content-type\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Content-Type header returned by an INDEX\n   without accept headers.  If no Content-Type header is available,\n   this property MUST NOT exist.\n   Value:      media-type   ; defined in Section 3.7 of [Fielding et\n   al., 1997]\n\n13.11. index-etag Property\n\n   Name:       index-etag\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the ETag header returned by an INDEX without\n   accept headers.  If no ETag header is available, this property MUST\n   NOT exist.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Value:      entity-tag  ; defined in Section 3.11 of [Fielding et\n   al., 1997]\n   Description:Note that the ETag on some resource may reflect changes\n   in any part of the state of the resource, not necessarily just a\n   change to the response to the INDEX method.  For example, a change\n   in the ACL may cause the ETag to change.\n\n13.12. index-last-modified Property\n\n   Name:       index-last-modified\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Contains the Last-Modified header returned by an INDEX\n   method without accept headers.  If no Last-Modified header is\n   available, this property MUST NOT exist.\n   Value:      HTTP-date  ; defined in Section 3.3.1 of [Fielding et\n   al., 1997]\n   Description:Note that the last-modified date on some resource may\n   reflect changes in any part of the state of the resource, not\n   necessarily just a change to the response to the INDEX method.  For\n   example, a change in a property may cause the last-modified date to\n   change.\n\n13.13. lockdiscovery Property\n\n   Name:       lockdiscovery\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To discover what locks are active on a resource\n   Values=     *activelock\n   Description:The lockdiscovery property returns a listing of who has\n   a lock, what type of lock he have, the timeout type and the time\n   remaining on the timeout, and the associated lock token.  The server\n   is free to withhold any or all of this information if the requesting\n   principal does not have sufficient access rights to see the\n   requested data.  A server which supports locks MUST provide the\n   lockdiscovery property on any resource with locks on it.\n\n13.13.1. activelock XML Element\n\n   Name:       activelock\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    A multivalued XML element that describes a particular\n   active lock on a resource\n   Parent:     lockdiscovery\n   Values=     locktype lockscope [addlocks] owner timeout locktoken\n\n13.13.2. owner XML Element\n\n   Name:       owner\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Returns owner information\n   Parent:     activelock\n   Values=     XML:REF | *PCDATA\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n\n13.13.3. timeout XML Element\n\n   Name:       timeout\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Returns information about the timeout associated with\n   the lock\n   Parent:     activelock\n   Values=     TimeType\n\n13.13.4. addlocks XML Element\n\n   Name:       addlocks\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Lists additional resources associated with this lock, if\n   any.\n   Parent:     activelock\n   Values=     1*href\n\n13.13.5. locktoken XML Element\n\n   Name:       locktoken\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Returns the lock token\n   Parent:     activelock\n   Values=     href\n   Description:The href contains a Lock-Token-URL.\n\n13.13.6. Example\n\n   PROPFIND /container/ HTTP/1.1\n   Host: www.foo.bar\n   Content-Length: xxxx\n   Content-Type: text/xml\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:propfind>\n     <D:prop><lockdiscovery/></D:prop>\n   </D:propfind>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:multistatus>\n     <D:response>\n          <D:prop>\n               <D:lockdiscovery>\n                    <D:activelock>\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n                         <D:locktype>write</D:locktype>\n                         <D:lockscope>exclusive</D:lockscope>\n                         <D:addlocks>\n                              <D:href>http://foo.com/doc/</D:href>\n                         </D:addlocks>\n                         <D:owner>Jane Smith</D:owner>\n                         <D:timeout>Infinite</D:timeout>\n                         <D:locktoken>\n                              <D:href>iamuri:unique!!!!!</D:href>\n                         </D:locktoken>\n                    </D:activelock>\n               </D:lockdiscovery>\n          </D:prop>\n          <D:status>HTTP/1.1 200 OK</D:status>\n     </D:response>\n   </D:multistatus>\n\n   This resource has a single exclusive write lock on it, with an\n   infinite timeout.  This same lock also covers the resource\n   http://foo.com/doc/.\n\n13.14. resourcetype Property\n\n   Name:       resourcetype\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    This property contains a series of XML elements that\n   specify information regarding the nature of the resource.  This\n   specification only defines a single value, collection.\n   Value:      XML elements\n   Description:This property MUST be defined on all DAV compliant\n   resources.  The default value is empty.\n\n13.14.1. collection XML Element\n\n   Name:       collection\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Identifies the associated resource as a collection.\n   Collection resources MUST define this value with the resourcetype\n   property.\n   Parent:     resourcetype\n   Values:          None\n\n13.15. Source Link Property Type\n\n   Name:       source\n   Namespace:  http://www.ietf.org/standards/dav/link/\n   Purpose:    The destination of the source link identifies the\n   resource that contains the unprocessed source of the link's source.\n   Parent:     None\n   Value:      An XML document with zero or more link XML elements.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Discussion: The source of the link (src) is typically the URI of the\n   output resource on which the link is defined, and there is typically\n   only one destination (dst) of the link, which is the URI where the\n   unprocessed source of the resource may be accessed.  When more than\n\n   one link destination exists, this specification asserts no policy on\n   ordering.\n\n13.16. supportedlock Property\n\n   Name:       supportedlock\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    To provide a listing of the lock capabilities supported\n   by the resource.\n   Values:     An XML document containing zero or more LockEntry XML\n   elements.\n   Description:The supportedlock property of a resource returns a\n   listing of the combinations of scope and access types which may be\n   specified in a lock request on the resource.  Note that the actual\n   contents are themselves controlled by access controls so a server is\n   not required to provide information the client is not authorized to\n   see.  If supportedlock is available on _*_ then it MUST define the\n   set of locks allowed on all resources on that server.\n\n13.16.1. lockentry XML Element\n\n   Name:       lockentry\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Defines a DAVLockType/LockScope pair that may be legally\n   used with a LOCK on the specified resource.\n   Parent:     supportedlock\n   Values=     locktype lockscope\n\n13.16.2. locktype XML Element\n\n   Name:       locktype\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Lists a DAVLockType\n   Parent:     lockentry\n   Values=     DAVLockTypeValue\n\n13.16.3. lockscope XML Element\n\n   Name:       lockscope\n   Namespace:  http://www.ietf.org/standards/dav/\n   Purpose:    Lists a DAVLockScope\n   Parent:     lockentry\n\n   Values:     DAVLockScopeValue\n\n13.16.4. Example\n\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   Content-Length: xxxx\n   Content-Type: text/xml\n\n   <?XML version=\"1.0\">\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:propfind>\n     <D:prop><supportedlock/></D:prop>\n   </D:propfind>\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?XML version=\"1.0\">\n   <?namespace href =\"http://www.ietf.org/standards/dav/\" AS = \"D\"?>\n   <D:multistatus>\n     <D:response>\n          <D:prop>\n               <D:supportedlock>\n                    <D:LockEntry>\n                         <D:locktype>Write</D:locktype>\n                         <D:lockscope>Exclusive</D:lockscope>\n                    </D:LockEntry>\n                    <D:LockEntry>\n                         <D:locktype>Write</D:locktype>\n                         <D:lockscope>Shared</D:lockscope>\n                    </D:LockEntry>\n               </D:supportedlock>\n          </D:prop>\n          <D:status>HTTP/1.1 200 OK</D:status>\n     </D:response>\n   </D:multistatus>\n\n\n14. DAV Compliance Levels\n\n   A DAV compliant resource can choose from two levels of compliance.\n   A client can discover which level a resource supports by executing\n   OPTIONS on the resource, and examining the \"DAV\" header which is\n   returned.\n\n   Since this document describes extensions to the HTTP/1.1 protocol,\n   minimally all DAV compliant resources, clients, and proxies MUST be\n   compliant with RFC 2068 [Fielding et al., 1997].\n\n14.1. Level 1\n\n   A level 1 compliant resource MUST meet all \"MUST\" requirements in\n   all sections of this document.\n\n14.2. Level 2\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   A level 2 compliant resource MUST meet all level 1 requirements and\n   support the supportedlock property as well as the LOCK method.\n\n\n15. Internationalization Considerations\n\n   In the realm of internationalization issues, this specification is\n   substantively in compliance with the IETF Character Set Policy\n   [Alvestrand, 1997]. In this specification, human-readable fields can\n   be found in either the value of a property, or in an error message\n   returned in a response entity body.  In both cases, the human-\n   readable content is encoded using XML, which has explicit provisions\n   for character set tagging and encoding, and requires by default that\n   XML processors read XML elements encoded using the UTF-8 and UCS-2\n   encodings of the ISO 10646 basic multilingual plane.  Furthermore,\n   XML contains provisions for encoding XML elements using other\n   encoding schemes, notable among them UCS-4, which permits encoding\n   of characters from any ISO 10646 character plane.\n\n   The default character set encoding for XML data in this\n   specification, and in general, is UTF-8.  WebDAV compliant\n   applications MUST support the UTF-8 and UCS-2 character set\n   encodings for XML elements, and SHOULD support the UCS-4 encoding.\n   The XML character set encoding declaration for each supported\n   character set MUST also be supported, since it is by using this\n   encoding declaration that an XML processor determines the encoding\n   of an element.\n\n   XML also provides language tagging capability which provides the\n   ability to specify the language of the contents of a particular XML\n   element.  Although XML, and hence WebDAV, does not use RFC 1766\n   language tags for its language names, the benefit of using standard\n   XML in this context outweighs the advantage of using RFC 1766\n   language tags.\n\n   Names used within this specification fall into two categories: names\n   specific to protocol elements such as methods and headers, names of\n   XML elements, and names of properties.  Naming of protocol elements\n   follows the precedent of HTTP, using English names encoded in\n   USASCII for methods and headers.  Since these protocol elements are\n   not visible to users, and are in fact simply long token identifiers,\n   they do not need to support encoding in multiple character sets.\n   Similarly, though the names of XML elements used in this\n   specification are English names encoded in UTF-8, these names are\n   not visible to the user, and hence do not need to support multiple\n   character set encodings.\n\n   The name of a property defined on a resource is a URI.  Although\n   some applications (e.g., a generic property viewer) will display\n   property URIs directly to their users, it is expected that the\n   typical application will use a fixed set of properties, and will\n   provide a mapping from the property name URI to a human-readable\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   field when displaying the property name to a user.  It is only in\n   the case where the set of properties is not known ahead of time that\n   an application need display a property name URI to a user. We\n   recommend that applications provide human-readable property names\n   wherever feasible.\n\n   For error reporting, we follow the convention of HTTP/1.1 status\n   codes, including with each status code a short, English description\n   of the code (e.g., 421 Destination Locked).  While the possibility\n   exists that a poorly crafted user agent would display this message\n   to a user, internationalized applications will ignore this message,\n   and display an appropriate message in the user's language and\n   character set.\n\n   Since interoperation of clients and servers does not require locale\n   information, this specification does not specify any mechanism for\n   transmission of this information.\n\n\n16. Security Considerations\n   [TBD]\n\n\n17. Terminology\n\n   Collection - A resource that contains member resources.\n\n   Member Resource - A resource contained by a collection.  There are\n   two types of member resources: external and internal.\n\n   Internal Member Resource _ A member resource of a collection whose\n   URI is relative to the URI of the collection.\n\n   External Member Resource - A member resource of a collection with an\n   absolute URI that is not relative to its parent's URI.\n\n   Property - A name/value pair that contains descriptive information\n   about a resource.\n\n   Live Property _ A property whose semantics and syntax are enforced\n   by the server.  For example, a live \"content-length\" property would\n   have its value, the length of the entity returned by a GET request,\n   automatically calculated by the server.\n\n   Dead Property _ A property whose semantics and syntax are not\n   enforced by the server.  The server only records the value of a dead\n   property; the client is responsible for maintaining the consistency\n   of the syntax and semantics of a dead property.\n\n\n18. Copyright\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   The following copyright notice is copied from RFC 2026 chapter 10.4,\n   and describes the applicable copyright for this document\n\n   Copyright (C) The Internet Society November 19, 1997. All Rights\n   Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph\n   are included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English.\n\n   The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assignees.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\n\n19. Acknowledgements\n\n   A specification such as this thrives on piercing critical review and\n   withers from apathetic neglect.  The authors gratefully acknowledge\n   the contributions of the following people, whose insights were so\n   valuable at every stage of our work.\n\n   Terry Allen, Harald Alvestrand, Alan Babich, Dylan Barrell, Bernard\n   Chester, Tim Berners-Lee, Dan Connolly, Jim Cunningham, Ron Daniel,\n   Jr., Jim Davis, Keith Dawson, Mark Day, Martin Duerst, David Durand,\n   Lee Farrell, Chuck Fay, Roy Fielding, Mark Fisher, Alan Freier,\n   George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis Hamilton,\n   Steve Henning, Alex Hopmann, Andre van der Hoek, Ben Laurie, Paul\n   Leach, Ora Lassila, Karen MacArthur, Steven Martin, Larry Masinter,\n   Michael Mealling, Keith Moore, Henrik Nielsen, Kenji Ota, Bob\n   Parker, Glenn Peterson, Jon Radoff, Saveen Reddy, Henry Sanders,\n   Christopher Seiwald, Judith Slein, Mike Spreitzer, Einar Stefferud,\n   Ralph Swick, Kenji Takahashi, Richard N. Taylor, Robert Thau, John\n   Turner, Sankar Virdhagriswaran, Fabio Vitali, Gregory Woodhouse, and\n   Lauren Wood.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   One from this list deserves special mention.  The contributions by\n   Larry Masinter have been invaluable, both in helping the formation\n   of the working group and in patiently coaching the authors along the\n   way.  In so many ways he has set high standards we have toiled to\n   meet.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n20. References\n\n   [Alvestrand, 1997] H. T. Alvestrand, \"IETF Policy on Character Sets\n   and Languages.\"  Internet-draft, work-in-progress.\n   ftp://ds.internic.net/internet-drafts/draft-alvestrand-charset-\n   policy-02.txt\n\n   [Berners-Lee, 1997] T. Berners-Lee, \"Metadata Architecture.\"\n   Unpublished white paper, January 1997.\n   http://www.w3.org/pub/WWW/DesignIssues/Metadata.html.\n\n   [Bradner, 1997] S. Bradner, \"Key words for use in RFCs to Indicate\n   Requirement Levels.\"  RFC 2119, BCP 14. Harvard University.  March,\n   1997.\n\n   [Bray, Sperberg-McQueen, 1997] T. Bray, C. M. Sperberg-McQueen,\n   \"Extensible Markup Language (XML): Part I. Syntax\", WD-xml-\n   lang.html, http://www.w3.org/pub/WWW/TR/WD-xml-lang.html.\n\n   [Fielding et al., 1997] R. Fielding, J. Gettys, J. Mogul, H.\n   Frystyk, T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1.\"\n   RFC 2068. U.C. Irvine, DEC, MIT/LCS.  January, 1997.\n   ftp://ds.internic.net/rfc/rfc2068.txt\n\n   [Lasher, Cohen, 1995] R. Lasher, D. Cohen, \"A Format for\n   Bibliographic Records,\" RFC 1807. Stanford, Myricom. June, 1995.\n   ftp://ds.internic.net/rfc/rfc1807.txt\n\n   [Leach, Salz, 1997] P. J. Leach, R. Salz, \"UUIDs and GUIDs.\"\n   Internet-draft (expired), work-in-progress, February, 1997.\n   http://www.internic.net/internet-drafts/draft-leach-uuids-guids-\n   00.txt\n\n   [Maloney, 1996] M. Maloney, \"Hypertext Links in HTML.\" Internet\n   draft (expired), work-in-progress, January, 1996.\n\n   [MARC, 1994] Network Development and MARC Standards, Office, ed.\n   1994. \"USMARC Format for Bibliographic Data\", 1994. Washington, DC:\n   Cataloging Distribution Service, Library of Congress.\n\n   [Miller et al., 1996] J. Miller, T. Krauskopf, P. Resnick, W.\n   Treese, \"PICS Label Distribution Label Syntax and Communication\n   Protocols\" Version 1.1, W3C Recommendation REC-PICS-labels-961031.\n   http://www.w3.org/pub/WWW/TR/REC-PICS-labels-961031.html.\n\n   [Slein et al., 1997] J. A. Slein, F. Vitali, E. J. Whitehead, Jr.,\n   D. Durand, \"Requirements for Distributed Authoring and Versioning\n   Protocol for the World Wide Web.\" RFC XXXX. Xerox, Univ. of Bologna,\n   U.C. Irvine, Boston Univ. YYY, 1997.\n   ftp://ds.internic.net/rfc/rfcXXXX.txt\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n   [WebDAV, 1997] WEBDAV Design Team. \"A Proposal for Web Metadata\n   Operations.\" Unpublished manuscript.\n   http://www.ics.uci.edu/~ejw/authoring/proposals/metadata.html\n\n   [Weibel et al., 1995] S. Weibel, J. Godby, E. Miller, R. Daniel,\n   \"OCLC/NCSA Metadata Workshop Report.\"\n   http://purl.oclc.org/metadata/dublin_core_report.\n\n   [Yergeau, 1997] F. Yergeau, \"UTF-8, a transformation format of\n   Unicode and ISO 10646\", Internet Draft, work-in-progress, draft-\n   yergeau-utf8-rev-00.txt, http://www.internic.net/internet-\n   drafts/draft-yergeau-utf8-rev-00.txt.\n\fINTERNET-DRAFT                  WebDAV               November 19, 1997\n\n\n\n21. Authors' Addresses\n\n   Y. Y. Goland\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA 98052-6399\n   Email: yarong@microsoft.com\n\n   E. J. Whitehead, Jr.\n   Dept. Of Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425\n   Email: ejw@ics.uci.edu\n\n   A. Faizi\n   Netscape\n   685 East Middlefield Road\n   Mountain View, CA 94043\n   Email: asad@netscape.com\n\n   S. R. Carter\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   Email: srcarter@novell.com\n\n   D. Jensen\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   Email: dcjensen@novell.com\n\f", "encoding": "ascii"}