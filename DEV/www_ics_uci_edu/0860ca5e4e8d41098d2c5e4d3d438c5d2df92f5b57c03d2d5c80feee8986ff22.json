{"url": "https://www.ics.uci.edu/~kay/courses/i42/hw/hw5.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Wednesday, February 15, 2006 8:46 PM\">\n<TITLE>Fifth Homework</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"ADAB3A24\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 1, CS1, assignment, Scheme\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"An assignment for ICS H21, an honors first-quarter course in computer science in Information and Computer Science, UC Irvine, using How to Design Programs by Matthias Felleisen et al.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2001 by David G. Kay.  All rights reserved.\">\n<link href=\"/~kay/courses/i42/code.css\" rel=\"stylesheet\" type=\"text/css\" />\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<P><FONT FACE=\"Goudy Old Style\">Informatics 42 &bull; Winter 2012 &bull; David G. Kay\n  &bull; UC Irvine</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\" SIZE=6><B>Fifth Homework</B></FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\">Get your work checked and signed off by a classmate, then show it to your TA in lab by Monday, February 13.</FONT></P>\n<P><strong>Part I</strong></P>\n<P>Your local radio station wants to computerize its collection of CDs. They have asked you consider these three alternative data structures:\n<ol type=I>\n<li>A conventional linked list, in no particular order</li>\n<li>An array ordered by CD title, with an additional field that stores the number of CDs in the collection</li>\n<li>A binary search tree, ordered by CD title.</li></ol>\n<p>When we ask for O-notations below, give the closest-fit O-notation in terms of n, the number of CDs n the collection, assuming each operation is coded as efficiently as possible in Java.</p>\n<p><strong>(a)</strong> Suppose the first task is to add all the CD data into the new system. Which of the three data structures would be most efficient for this task alone? As part of your answer, give each alternative's O-notation for adding a CD to the collection. \n<!--Some will read this as asking about one addition instead of all; that's okay if their answers are consistent. List is O(n); array is O(n log n)\u2014create array, add items, sort\u2014but give credit if they say n^2 for adding them in linearly; tree is O(n log n). List wins.<br>\n  1 point for each, plus 1 point for conclusion.-->  </p>\n<p><strong>(b)</strong> A DJ spends most of his or her time looking up CDs by title. What is each data structure's O-notation for locating a CD by title? Which data structure do you most want to avoid for this task?<br>\n<!--  Searching list is O(n); searching array is O(log n) using binary search; searching the tree is O(log n); avoid List.\n\n  1 point for each, plus 1 point for conclusion (that follows from O-notation)--></p>\n<p><strong>(c)</strong> The station manager wants to know at any given moment exactly how many CDs are in the collection. Give each alternative's O-notation for determining the number of CDs and say which alternative is most efficient for this operation. Don't assume the existence of any data fields not specified above.\n  <!--\n  List is O(n) because there's no size field; array is O(1) 'cause it has size; BST is O(n). Array wins.<br>\n  1 point for each, plus 1 point for conclusion\n  --></P>\n<p><strong>(d)</strong> What would be the best data structure to use for implementing this collection, and (in one brief sentence including O-notations where appropriate) why? Assume that task (a) will be done just once and that most of the collection's usage will be split evenly between tasks (b) and (c). You may propose small modifications to the data structures described above if they would help produce a clear winner.\n  <!--\n  1/2 point for conclusion, 1/2 point for reasoning.<br>\nA variety of answers is possible, depending on how they modify the collection. What I was thinking of was adding a size field to each, which would make the array and the tree equivalent by O-notation on the two critical operations. It's okay if they just say they're tied; it's also okay if they break the tie either (a) by saying the tree is better for the one-time task of filling the collection or (b) by saying the array is better because it requires less storage per CD or (c) by saying the tree is better because it dynamically allocates just enough storage for the current size of the collection. Basically, they get the points if what they say is consistent and correct, and they don't if it's not.--></P>\n<p><strong>Part II</strong></P>\n<p><B>(a)</B> As we did in class on Thursday afternoon, draw the state transition diagram (STD) for a finite-state automaton (FSA) that accepts the language of dollars-and-cents amounts with comas in the right places. Accepted strings include:</P>\n<pre><code>$1.00     $1,234.56      $1,234,567.89       $1,234,567,890.00\n$13.27    $12,345.00     $12,345,678.90      $0.00\n$125.50   $123,456.78    $123,456,789.00     $0.25</code></pre>\n<p>Rejected strings include:</P>\n<pre><code>$1        $5.000         $123,45.00          $1,234,00      $00.00\n$25       $17.5          $1,234,5.67         $1,234,.00     $03.50\n$234.     $1234.56       $1234,567.00        $,123,456.00   $0,123.45</code></pre>\n\n<p><strong>(b) </strong>Below is some Python code that implements\n  a kind of finite-state automaton.</P>\n<PRE><code>SECRET1 = 35\nSECRET2 = 127\nSECRET3 = 33\n\nstateList = [ \"Init\", \"GotFirst\", \"GotSecond\", \"Success\" ]\n\ncount = 1\n\nstate = \"Init\"\n\nwhile state != \"Success\" and count <= 3:\n    number = get_next()\n\n    if state == \"Init\":\n        if number == SECRET1:\n            state = \"GotFirst\"\n        else:\n            state = \"Init\"\n    elif state == \"GotFirst\":\n        if number == SECRET2:\n            state = \"GotSecond\"\n        else:\n            state = \"Init\"\n    elif state == \"GotSecond\":\n        if number == SECRET3:\n            state = \"Success\"\n        else:\n            state = Init\n    count += 1\n    \nif state == \"Success\": \n    print(\"Input accepted.\")\nelse:\n    print(\"Input rejected.\")\n</code></PRE>\n\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(b.1)</B>  Draw the state transition diagram\nthat represents the FSA this program implements.  The input tokens here\nare whole integers, not individual characters.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(b.2)</B>  Describe in one brief English\nsentence what this FSA does.  Try to think of a simple, real-world, non-computer-related\nobject that this FSA models.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>Intermezzo:</B>  State transition diagrams\nare one way to describe FSAs.  Another way (which is easier to represent\nin a computer) is a <B>transition table.</B>  A transition table has a row\nfor each state and a column for each input (or each disjoint category of\ninputs); the value at each position in the table tells you what state to\ngo to when you read a given input in a given state.  Below is a transition\ntable for the program above:</FONT>\n<TABLE BORDER=1 CELLSPACING=1 WIDTH=100% CELLPADDING=1>\n<COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=31%>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>&nbsp;</TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>Secret1</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>Secret2</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>Secret3</B></FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>other</B></FONT></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>Init</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">GotFirst</FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>GotFirst</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">GotSecond</FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>GotSecond</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Success</FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\">Init</FONT></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Goudy Old Style\"><B>Success</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=31% VALIGN=TOP>\n<BR></TD>\n</TR>\n</TABLE>\n<BR>\n<FONT FACE=\"Goudy Old Style\">This table says just what the program and the\nstate transition diagram say:  If you&#39;re in Init and you read Secret1,\nyou go into state GotFirst; if you&#39;re in state Init and you read anything\nelse, you stay in Init.  If you&#39;re in state GotFirst and you read Secret2,\nyou go into state GotSecond; if you read anything else in state GotFirst\nyou go to state Init.  And finally, if you&#39;re in state GotSecond and\nyou read Secret3, you go to state Success; otherwise, you go to Init.  In\nstate Success the machine stops, so you don&#39;t make any transitions out\nof that state; it&#39;s the accept state.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">As we noted, transition tables make FSAs easy\nto represent in a computer.  In fact, we can write a very simple but very\ngeneral FSA simulator according to the following pseudocode:</FONT></P>\n\n<PRE><font size=\"2\" face=\"Courier New, Courier, monospace\">initialize TransitionTable, ListOfAcceptStates \nstate &larr; initial state\n\nwhile there are more tokens:\n    get a token;\n    state &larr; TransitionTable[state][token];\n\nif state in ListOfAcceptStates:\n    accept\nelse:\n    reject</font></PRE>\n\n<P>\n<FONT FACE=\"Goudy Old Style\">Because this code is so simple, it&#39;s the\npreferred way to implement FSAs in programs.  The only tricky part is finding\na data type that will represent the range of tokens and will at the same\ntime be acceptable as an array index in your programming language.  Scheme,\nfor example, handles symbolic names very easily, and so does Python, allowing any string to be an index into a dictionary.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(c)</B>  Think about the task of extracting\nwords from a stream of text.  In Python, you can use split() to divide lines around whitespace (or other separators), but sometimes you need to specify &quot;words&quot; idiosyncratically.\n You can do this kind of input-parsing task much more easily using state\nmachines than by writing code directly.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(c.1)</B>  Draw a state transition diagram\nthat accepts words defined as follows:  a sequence of non-separator characters\nwhose end is marked by a separator.  Separators are symbols that separate\nEnglish words&mdash;space, comma, semicolon, colon, and so on.  Note that the\nhyphen (-), the apostrophe (&#39;), and the percent sign (%) are not separators:\n treat &quot;mother-in-law,&quot; &quot;don&#39;t,&quot; and &quot;23%&quot;\nas single words.   The end of the line is a separator, unless the last word\nof the line ends with a hyphen.  That way, if a word like mother-in-law\nis hyphenated across two lines, it will still count as one word.  (We will\nassume that in our input, only words that are always hyphenated will be\nhyphenated at the end of a line; that is, you should not expect normally-unhyphenated\nwords to be broken across two lines.)  Watch for multiple separators in\na row&mdash;for example, a comma followed by a space is two separators, but there\nis no word between them.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">You could code up this FSA into a method called\ngetNextWord, and call it to parse a stream of input.\n Coding this isn&#39;t a required part of this assignment, though.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(c.2)</B>  Write a transition table for\nthe state machine you drew in part <B>(c.1)</B>.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d)</B> One of Scheme&#39;s attractions\nis that its syntax is very simple.  Unlike Python, which has quite a few different\nstatements, each with its own grammar and punctuation rules, every program\nor expression in Scheme is just a list of words surrounded by parentheses.\n This provides a rich variety of expression because a &quot;word&quot; can\nbe (a) any sequence of characters delimited (separated from other words)\nby white space, or (b) a parenthesized list of words nested within the outside\nlist.  The following are all valid Scheme expressions (each is one line\nlong except the last, which starts with the word</FONT><FONT FACE=\"AGaramond\" SIZE=4>\n</FONT><FONT FACE=\"Courier New\" SIZE=2>define</FONT><FONT FACE=\"Goudy Old Style\">):<A NAME=\"_14_6726\"></A></FONT></P>\n<PRE><font size=\"2\" face=\"Courier New, Courier, monospace\">(Fee fie fo fum)\n(+ 3.14159 1776 -45 quantity)\n(equal? (+ 2 2) (+ 3 1))\n(define square\n  (lambda (x)\n    (* x x)))</font></PRE>\n<P>\n<FONT FACE=\"Goudy Old Style\">Novice Scheme programmers sometimes worry about\nkeeping all the parentheses balanced, but most Scheme systems have &quot;syntax-based&quot;\ntext editors that automatically keep track of the parentheses, so that any\ntime you type a right parenthesis it automatically flashes the left parenthesis\nthat matches it.  That way you can see effortlessly what matches what. \n(This idea has found its way into some program editors for Python and other\nlanguages, where it&#39;s also useful.)</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Suppose you decide to write a syntax-based\neditor for Scheme, and as your first task you want to write some code that\nchecks whether the parentheses are balanced in a Scheme expression.  Astutely,\nyou start by designing an FSA.  To make it truly a <I>finite-</I>state machine,\nwe have to put an upper limit on the depth to which parentheses can be nested;\nthe example below shows the FSA for an upper limit of three-deep nesting.\n(In the diagram, &quot;other&quot; means an input symbol other than an open\nor close parenthesis.)</FONT></P>\n<P>\n<IMG SRC=\"Fifth_Homework_files/Picture_299.gif\" WIDTH=429 HEIGHT=144 ALT=\"\"></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d.1) </B>After scanning the entire Scheme\nexpression, in what state should your machine be if the parentheses were\ncorrectly balanced?</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d.2) </B>This FSA works fine in theory,\nbut for a realistic nesting depth of a few dozen, the diagram would be tediously\nrepetitious.  So you decide to simplify things and encapsulate the state\ninformation in a simple integer counter.  Then you can have a single state\non the page, and all the action happens in the transition steps, where you\nincrement the counter for each left parenthesis and decrement it for each\nright parenthesis.  [Having a variable may appear to violate the definition\nof a finite-state machine, all of whose information is encapsulated in a\nfinite number of states.  But since integer variables on computers (as opposed\nto integers in mathematics) always have a finite upper bound, we&#39;re\ntechnically safe.  If our machine used a stack to keep track of the unbalanced\nparentheses (which is what our integer counter is modeling), it would no\nlonger be an FSA&mdash;it would be a PDA (push-down automaton), which can accept\na broader class of languages.]  </FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">The modified (augmented) machine appears below.</FONT></P>\n<BR>\n<P>\n<CENTER>\n<IMG SRC=\"Fifth_Homework_files/Sidebar_292.gif\" WIDTH=530 HEIGHT=304 HSPACE=6 VSPACE=6>\n</CENTER>\n<BR>\n<FONT FACE=\"Goudy Old Style\">In the augmented machine, being in the stop\nstate is not enough to know that the Scheme program has balanced parentheses;\nthe value of the counter must be considered as well. What should the counter&#39;s\nvalue be if the machine accepts the Scheme source (that is, if the parentheses\nare correctly balanced)? What must have happened for the machine to end\nup in the error state?</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d.3) </B> Things are rarely quite as simple\nas they first seem.  Comments in Scheme programs start with a semicolon\nand extend to the end of the line.  Thus, the following is a valid Scheme\nexpression; everything to the right of the semicolon on each line is a comment.\n Of course the contents of comments are ignored when checking for balanced\nparentheses.</FONT></P>\n<PRE><code>  (define print-it        ; In this routine we\n    (lambda (p)           ; a) accept a parameter,\n      (display p)         ; b) display it, and\n      (newline)))         ; c) hit carriage return</code></PRE>\n<P>\n<FONT FACE=\"Goudy Old Style\">Draw a new FSA-like machine, similar to the\none above, to account for comments correctly; you will have to add more\nstates.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d.4)</B>  And there&#39;s one more wrinkle.\n Literal character strings in Scheme are enclosed in double-quote marks.\n As in any programming language, the contents of literal strings are ignored when analyzing\nthe syntax of the program.  The following three expressions are valid in\nScheme.</FONT></P>\n<pre><code>(display &quot;Oh; really?&quot;) \n(list  &quot;a)&quot;  &quot;b)&quot;  &quot;c)&quot; ) \n(let ((delims &quot;.,;:)((&quot;))) ; This has an extra '(' in quotes</code></pre>\n<P>\n<FONT size=\"2\" FACE=\"Goudy Old Style\"></FONT><FONT FACE=\"Goudy Old Style\">Draw a new FSA-like machine to handle both\nstrings and comments correctly.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d.5)</B>  Write a transition table for\nthe state machine you designed in part <B>(e.4)</B>.  Note that some of\nthe transitions in some conditions will also increment or decrement the\ncount of parentheses.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(d.6)</B>  Test your FSA from part <B>(e.4)\n </B>thoroughly on paper&mdash;devise a thorough test plan and work each test\nthrough your FSA.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(e)</B>  (Optional)  Available on the web\nis a program called JFLAP, written at Duke University\n(</FONT><FONT FACE=\"Courier New\" SIZE=2><A HREF=\"http://www.jflap.org/\">http://www.jflap.org/</A></FONT><FONT FACE=\"Goudy Old Style\">).\n You can download this Java application and use it to build and test your\nown simple FSAs (as well as do other formal-language activities).  Other\nstate machine simulators are available on the web; you can find some of\nthem by using search strings like &quot;state machine applet&quot; or &quot;FSA\nanimation.&quot;</FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Helvetica\" SIZE=1>Written by David G. Kay, Winter 2005. </FONT></P>\n<P>\n<FONT FACE=\"Helvetica\" SIZE=1>FSA exercises written by David G. Kay, Winter\n1991 (based on materials from 1990 and earlier).  Revised by Joe Hummel,\nNorman Jacobson, Theresa Millette, Brian Pitterle, Alex Thornton, Rasheed\nBaqai, Li-Wei (Gary) Chen, and David G. Kay, 1992-1999.</FONT></P>\n<P><font size=\"1\" face=\"Helvetica\">Modified by David G. Kay to reflect Python, Winter 2012.</font><BR CLEAR=ALL>\n</P>\n</BODY>\n</HTML>", "encoding": "utf-8"}