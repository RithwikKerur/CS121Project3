{"url": "https://www.ics.uci.edu/~majumder/VC/211HW3/vlfeat/toolbox/misc/vl_cummax.def", "content": "/** @file vl_cummax.def\n ** @brief vl_cummax MEX helper template\n ** @author Andrea Vedaldi\n **/\n\n/* Copyright\n*/\n\n/* include this file for different values of ITERATE_1 */\n#ifndef ITERATE_1\n# define ITERATE_1 1\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 2\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 3\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 4\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 5\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 6\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 7\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 8\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 9\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n# define ITERATE_1 10\n# include \"vl_cummax.def\"\n# undef ITERATE_1\n#endif\n\n/*\nFor each value of ITERATE_1, instantiate the algorithm for a different\ndata type.\n*/\n\n#if defined(ITERATE_1)\n# define __VALUE_T__ TYPE(ITERATE_1)\n\n/*\nThe algorithm scans in linear order the input data X. X indexed as\nX[i1,i2,i3,...,iD] where D is the number of dimensions. In order to\noperate on the d-th dimension, one defines the output Y as\n\n                   / MAX(Y[i1,i2,...,id - 1,...], X[i1,i2,...,id,...]),  if id > 0 (OP),\n  Y[i1,i2,...]  = <\n                   \\ X[i1,i2,...,id,...],                                if id = 0 (COPY).\n\nSo by scanning X in column major, one has id = 0 while i1,i2,...,id-1\ntraverse the first STRIDE = D1*D2*...*D_{d-1} elements and performs a\nCOPY operation. Then id is incremented by one and remains > 0 until\nD1*D2*...*D_{d-1}*Dd elemenets are visited overall, and performs OP\noperations (MAX in this case). Then id = 0 again and so on until all\nelements are visited.  */\n\nVL_INLINE void\nVL_XCAT(_vl_cummax_,__VALUE_T__)\n(mxArray * Y_array,\n mxArray const * X_array,\n vl_size stride,\n vl_size dimension)\n{\n  __VALUE_T__ const * x = (__VALUE_T__*) mxGetData(X_array) ;\n  __VALUE_T__ const * x_stop = x + mxGetNumberOfElements(X_array) ;\n  __VALUE_T__ * y = (__VALUE_T__*) mxGetData(Y_array) ;\n  while (x < x_stop) {\n    __VALUE_T__ const *  x_ops_stop  = x + stride ;\n    /* copy stride elements */\n    while (x < x_ops_stop) {\n      *y++ = *x++ ;\n    }\n    /* op stride * (dimension - 1) */\n    x_ops_stop += stride * (dimension - 1) ;\n    while (x < x_ops_stop) {\n      *y = VL_MAX(*x, *(y - stride)) ;\n      ++ y ;\n      ++ x ;\n    }\n  }\n}\n\n#undef __VALUE_T__\n#endif\n", "encoding": "ascii"}