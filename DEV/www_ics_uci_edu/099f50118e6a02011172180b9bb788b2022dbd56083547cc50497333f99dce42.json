{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/MultiConga.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Conga line closest pair algorithm\n\n#include \"MultiConga.h\"\n#include \"Error.h\"\n\n// add an edge to the graph\ninline void MultiConga::AddEdge(point in, point out, double d)\n{\n\tif (how_many_edges == 2*max_points)\n\t\terror(\"CongaLine: too many edges\");\n\tedges[how_many_edges].in = in;\n\tedges[how_many_edges].out = out;\n\tedges[how_many_edges].d = d;\n\thow_many_edges++;\n}\n\n// remove an edge from the graph\ninline void MultiConga::RemoveEdge(unsigned long e)\n{\n\tif (e >= how_many_edges) error(\"CongaLine: removing the same edge twice\");\n\tedges[e] = edges[--how_many_edges];\t// copy struct\n}\n\n// move a point to a new subset, leaving all edges in place\n// caller is responsible for calling subset_sizes.Update(p)\ninline void MultiConga::MoveToSubset(point p, unsigned long & subset_size)\n{\n\tif (where_are_the_points[p] < subset_size) return;\t// already there\n\tpoints[where_are_the_points[p]] = points[subset_size];\n\twhere_are_the_points[points[subset_size]] = where_are_the_points[p];\n\tpoints[subset_size] = p;\n\twhere_are_the_points[p] = subset_size;\n\tsubset_size++;\n}\n\n// reset all data structures by inserting all points into a single conga line\ninline void MultiConga::CleanAllGraphs()\n{\n\thow_many_edges = 0;\t\t\t// forget existing edges\n\tFindSubsetEdges(npoints);\t// make conga line for all points\n}\n\n// initialize all data structures\nMultiConga::MultiConga(long np, long mp, Distance & d)\n  : BruteForceCP(np, mp, d), edges(new CongaEdge[2*mp]),\n    how_many_edges(0), max_points(mp)\n{\t\n\tif (edges == 0) error(\"CongaLine: unable to create edge array\");\n\tCleanAllGraphs();\t\t\t// reset data structure\n}\n\n// get rid of allocated space\nMultiConga::~MultiConga()\n{\n\tdelete edges;\n}\n\n// scan edges to find closest pair\ndouble MultiConga::operator () (point & a, point & b)\n{\n\tgPairs++;\n\tif (how_many_edges < 1) error(\"CongaLine: no more edges\");\n\tunsigned long best_edge = 0;\n\tfor (unsigned long i = 1; i < how_many_edges; i++)\n\t\tif (edges[i].d < edges[best_edge].d) best_edge = i;\n\ta = edges[best_edge].in;\n\tb = edges[best_edge].out;\n\treturn edges[best_edge].d;\n}\n\n// Compute new conga line for a given subset.\n// We assume the subset is in points[0]..points[ns-1].\n// Our computation completely messes up the order of points[],\n// so after we're done, we recompute where_are_the_points[].\nvoid MultiConga::FindSubsetEdges(unsigned long ns)\n{\t\n\tif (ns == 0) return;\t// nothing to do?\n\n\t// is there enough room for the new edges we might have?\n\t// max # new edges = min(2ns, tp)-1\n\t// Note we compare to max_points not npoints;\n\t// I tried npoints and it ended up being a little slower...\n\tunsigned long tp = npoints;\t\n\tunsigned long max_edges = 2*ns - 1;\n\tif (tp - 1 < max_edges) max_edges = tp - 1;\n\tif (how_many_edges + max_edges > 2*max_points) {\n\t\tCleanAllGraphs();\t\t\t\t\t// run out of room, rebuild\n\t\treturn;\n\t}\n\t\n\t// now do Conga line\n\tpoint current = points[0];\n\tint was_in_subset = 1;\n\tunsigned long i;\n\tpoint * p = points+1;\n\tns--; tp--;\t\t\t// account for removal of first element\n\tfor (;;) {\n\t\tdouble d;\t// find nbr s.t. either current or nbr is in s\n\t\tif (was_in_subset) {\t\t\t// current is in s\n\t\t\tif (tp <= 0) break;\t\t// any points left?  if not, done\n\t\t\ti = NeighborInList(current, p, tp, d);\t// search all points in p\n\t\t} else { \n\t\t\tif (ns <= 0) break;\n\t\t\ti = NeighborInList(current, p, ns, d);\t// not in s, search only in s\n\t\t}\n\t\tAddEdge(current, p[i], d);\n\t\tcurrent = p[i];\n\t\tif (i < ns) {\t\t// neighbor is also in same subset?\n\t\t\tp[i] = p[0];\t// yes, switch to front of list\n\t\t\tp[0] = current;\n\t\t\tp++; ns--; tp--;\t// shorten list to exclude it\n\t\t\twas_in_subset = 1;\t// and remember to look everywhere next time\n\t\t} else {\n\t\t\tp[i] = p[--tp];\t// not in same subset, switch to end of list\n\t\t\tp[tp] = current;\n\t\t\twas_in_subset = 0;\n\t\t}\n\t}\n\t\n\t// Conga line all built, but points[] scrambled, recompute where_are...\n\tfor (i = 0; i < npoints; i++)\n\t\twhere_are_the_points[points[i]] = i;\n}\n\n// find index of nearest neighbor in a list, subroutine for building conga lines\nunsigned long MultiConga::NeighborInList(point pt, point * ptlist,\n\t\t\t\t\t\t\t\t\t\t unsigned long listlen, double & d)\n{\n\tunsigned long retval = 0;\n\td = dist(pt, ptlist[0]);\n\tfor (unsigned long i = 1; i < listlen; i++) {\n\t\tdouble dd = dist(pt, ptlist[i]);\n\t\tif (dd < d) {\n\t\t\td = dd;\n\t\t\tretval = i;\n\t\t}\n\t}\n\treturn retval;\n}\n\n// Point has changed. Have to treat as if newly inserted.\n// Sigh, this is slow, but it's incorrect just to move p to a new set\n// (because now some edges x->p might have become longer than x->something else)\nvoid MultiConga::UpdatePoint(point p)\n{\n\t(*this) -= p;\n\t(*this) += p;\n\tgInsertions--;\n\tgDeletions--;\n}\n\n// Distance has changed. Move both points to new subset, get rid of old pq edges.\n// Unlike UpdatePoint this is reasonably fast.\n// Note that it's safe to remove all edges p->x and q->x, not just p->q and q->p\nvoid MultiConga::UpdateDistance(point p, point q)\n{\n\t// flush any existing edges involving this pair of points\n\tunsigned long i = 0;\n\twhile (i < how_many_edges) {\n\t\tif (edges[i].in == p || edges[i].in == q) RemoveEdge(i);\t\t   \n\t\telse i++;\n\t}\n\n\t// now move p and q to new subset and make edges for it\n\tunsigned long s = 0;\n\tMoveToSubset(p,s);\n\tMoveToSubset(q,s);\n\tFindSubsetEdges(s);\n}\n\n// insert new point\nvoid MultiConga::operator += (point p)\n{\n\tBruteForceCP::operator+=(p);\t// add to points[]\n\tunsigned long s = 0;\n\tMoveToSubset(p,s);\t\t\t\t// move to front of list and count\n\tFindSubsetEdges(s);\t\t\t\t// make edge to nearest neighbor\n}\n\n// delete point\nvoid MultiConga::operator -= (point p)\n{\n\tBruteForceCP::operator-=(p);\n\t\n\t// delete edges involving p and send neighbors to new subset\n\tunsigned long s = 0;\n\tunsigned long i = 0;\n\twhile (i < how_many_edges) {\n\t\tif (edges[i].out == p) {\n\t\t\tMoveToSubset(edges[i].in,s);\n\t\t\tRemoveEdge(i);\n\t\t} else if (edges[i].in == p) RemoveEdge(i);\n\t\telse i++;\n\t}\n\t\n\t// If anything was moved, make new conga line and clean up\n\tFindSubsetEdges(s);\n}", "encoding": "ascii"}