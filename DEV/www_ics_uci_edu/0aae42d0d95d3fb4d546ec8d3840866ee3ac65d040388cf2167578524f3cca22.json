{"url": "https://www.ics.uci.edu/~rohit/ETcon-notes.txt", "content": "Speechifying\r\r[This is the kind of fuzzy crap that I just have to get out of my system. \rIt's the opposite of the clarity & conciseness needed for the thesis. \rInstead, this is a hypothetical address for the talk I'm giving at the \rO'Reilly conference in May.]\r\rI'd like to speak to you today about a new way to integrate software \racross the Internet. If we choose to view software modules as hosts on \ra network, then we can apply the same principles networking \rresearchers used to internetwork decentralized LANs to \"internetwork\" \rapplications. \r\rSpecifically, I want to introduce a new product that makes this style of \rintegration easy: an application-layer router. I believe that such a \r\"router\" is the missing element that completes the software industry's \rcurrent rush to address Internet-scale integration, under the moniker \rof \"Web Services.\"\r\rNow, you may ask yourselves, \"Don't we already have ways -- too many \rways! -- to build distributed software already?' Remote Procedure Calls, \rdataflow graphs, mobile code, and so many other architectural styles \rcome readily to mind as tools to connect software systems across the \rInternet.\r\rHowever, almost all these architectural styles assume that the Internet \ris merely an extension of the LAN. After all, an IP packet is an IP \rpacket, whether inside or outside the firewall, whether across a LAN or \ra dialup modem. \r\rBut there's a reason why, thirty years later, we are in the happy \rposition of using IP \"all the way down\"; it wasn't always the case. \rOriginally, there were a slew of competing network protocols: \rAppleTalk, DECnet, Novell IPX, and so on. IP was invented anew to \raddress the new challenge of networking networks. No single network \rprotocol was appropriate for unifying all the others.\r\rUntil IP, network protocols were tightly coupled to link-layer hardware \rand operating systems. IP, by contrast, had to address three new \rchallenges: scaling across time, space, and organizational boundaries. \r\rFirst, IP had to be stable for a long time. To let new computers, \rnetwork adapters, and operating systems invented years apart -- now \rdecades! -- to \"speak\" IP compatibly, a neutral team had to hammer out \rsimple, concrete specifications that could stand the test of time. \r\rSecond, IP had to work across larger spaces: continents, not just \rcampuses or cities. To accommodate the widely varying latency, \rbandwidth, and jitter of all sorts of communications links, IP was \rdesigned as an asynchronous \"store-and-forward\" network. Signaling \rtechniques appropriate for a few meters of copper cable running \rEthernet simply wouldn't work across the Atlantic.\r\rFinally, IP had to work across organizational boundaries. Different \rorganizations' networks had very different ways to identify hosts, \rusers, terminals, files -- you couldn't even assume everyone used 8-bit \rbytes back then! That's why internetworking required yet another new \rnamespace: IP addresses, and later, DNS names and so on. Conversely, \rIP did not include security; it left concepts such as users, passwords, \rand encryption to applications running \"on top.\"\r\rAnd yet, thirty years later, you're likely to get fired if you deploy \ranything besides IP. The experiment that was merely intended to \rintegrate separate LANs took over as the LAN format, too; while so \rmany of the once-dominant LAN protocols IP struggled to \raccommodate are nearly-extinct curiosities. \r\rSo what does this tale about networks have to do with software \rarchitectures?\r\rI claimed that today's state of the art for developing distributed \rsoftware merely treats the Internet as a slower kind of LAN, since \"it's \rall IP all the way down.\" We're still vainly trying to provide the illusion \rof a single, large-scale von Neumann computer out of all these \rdistributed parts. \r\rInstead, I claim there are brand-new concerns that arise at Internet-\rscale. We need decentralized software that can cope with vastly larger \rscales across time, space, and organizations. And to that end, I want \rto tell you why traditional middleware doesn't match up to these \rchallenges -- and that we can apply networking concepts that can.\r\rTo begin with, I'd like to illustrate the weakness of current software \rintegration technology, and compare it to SOAP. When software \rcomponents are separated by time, I mean to consider the challenge \rof interoperability when components are written years apart, by \rseparate teams. With technologies such as CORBA IIOP, Microsoft \rDCOM, Java RMI, or TIBCO's information bus, the messages sent are in \ra fragile, binary, and, often, proprietary format. This implies tight \rcoupling of components in terms of vendor, language, and interface \rversions. Using SOAP and WSDL loosens these couplings, since these \rstandards leverage XML to allow Web Services to be called from any \rplatform, and to allow interfaces & data formats to evolve gracefully. \r\rWhen software components are separated by distance, this translates \rback into time, or latency. Traditional RPC and event-based \rintegration systems assume that the network is reliable and low-\rlatency. For example, TIBCO relies on IP multicast to announce events \rto all nodes. Multicast is only efficient at LAN-scale. By contrast, a \rnomadic laptop may go days without connecting to the Internet. SOAP \racknowledges this challenge by allowing many different kinds of \rtransport, such as SMTP (email). While the calling application may still \rblock, as with a traditional RPC, SOAP at least allows developers to \rloosen coupling in time, and hence account for wider geographical \rrange.\r\rFinally, consider what happens when software components are \rseparated by organizational boundaries. In the travel industry, a \"day\" \rmeans any 24-hour period for car rentals; but only a single evening in \ra hotel. A reservation service will have to explicitly handle these \rvariances; this is the bulk of the multi-billion dollar EAI (enterprise \rapplication integration) industry. The Web Services vision, in contrast, \ris for an intelligent actor to look up the relevant schema for both \rservices in a UDDI directory and at least translate miles into \rkilometers, if not also the contractually distinct definitions of \"day\" in \rthe car rental and hotel industries. \r\rSo what's the problem, then?\r\rIt would seem that, yes, there are limitations to using today's \rintegration technology at Internet-scale, but that SOAP, WSDL, UDDI, \rand the rest of the menagerie of Web Services technologies are \rsufficiently evolved successors to them that we will be able to \rsuccessfully integrate software across the Internet. \r\rI believe these technologies are only one half of the solution. On the \rsurface, the analogy would seem to hold: the IP packet format and \rTCP protocols are all we needed to network networks; shouldn't SOAP \rmessages be all we need to network software?\r\rBut there was a complementary concept implied by the very nature of \rIP packets: the IP router. Literally, the IP specifications don't define or \rrequire a construct called a \"router\", but the router was the device \rthat unleashed the full potential of IP to actually interconnect LANs. \rSimilarly, I claim SOAP routers are necessary to actually unleash the \rfull potential of Web Services.\r\rBut that's skipping steps, my claiming that we need SOAP routers. Let \rme begin by explaining what they are and how they work.  Also, in \rstepping back from the industry hype and of-the-moment buzzwords, \rI'll put aside any mention of SOAP and specific technologies for the \rtime being. \r\rTheoretically, most integration models abstract software components \ras miniature machines. Machines have control levers and input feeds; \rwe know how to chain them together in sequence, or nest them, as in \rthe very word, \"subroutine.\" These machines are tightly coupled, in \rthat the output of one must be directly and immediately fed to the \rnext. Furthermore, \"next\" is itself well defined, unfortunately allowing \rmachines to rely on the exact implementation of the others.\r\rTo decouple these factories, \"brokers\" emerged to buy, warehouse, \rand sell intermediate goods. Integration models adopted the same \rabstraction. Object Brokers, as a generic category of middleware, \rallowed the invoking machine to dynamically bind to the \"next.\" This \rdeferred a range of choices to run-time, such as directing which actual \rcomputer to invoke the command on; enforcing that the caller had the \rappropriate security credentials; and queuing invocations to mask \rtransient connectivity failures. Even more capable variants of Object \rBrokers incorporated Transaction Monitors, so that even distributed \rinvocations could be modeled as atomic invocations.\r\rMy colleague Roy Fielding continued in this vein to catalog a wide \rrange of architectural styles for distributed software integration. \rUltimately, he synthesized a new style he suggests best represents \rthe power of the Web: REST (Representational State Transfer).\r\rTo quote Dr. Fielding: \"The central feature that distinguishes the REST \rarchitectural style from other network-based styles is its emphasis on \ra uniform interface between components.\"\r\rHis conclusion is where we'll begin.\r\rJust as the HTTP-based Web provides a uniform interface for accessing \rand transmitting any hypermedia resource, I claim SOAP-based Web \rServices provide a uniform interface for invoking and responding to \rany software component. The key addition we're making this time is \rthat, unlike hypermedia transfer, software components require \rasynchronous messaging, since we need to encompass both RPC and \revent-based integration styles.\r\r[OK, so I broke my rule about buzzwords. It's a draft! ;-]\r\rAssume I'll come back later and defend why I believe SOAP is REST \rapplied to software integration. What new powers do we gain by \rstipulating this? I'm proposing that even third parties can add \"ilities\" \r-- reliability, availability, scalability, security, extensibility, and \rvisibility -- to REST services without modifying the services or callers.\r\rOne of the most powerful, and underappreciated, implications of \rHTTP's proxy support is the potential to compose active proxies to \rextend the Web. Content can be tailored to various devices; \radvertising can be stripped out (or inserted); identities can be \ranonymized; protocols can be gatewayed; and so on. The key is that \rthird parties can assemble custom proxy chains of fourth party \rservices, all without modifying the origin server or user-agent.\r\rSimilar implications hold for SOAP intermediary support. To date, \rthese have been little-used in the early phases of RPC and \rdistributed-objects applications. However, the lessons learned in HTTP \rhave made SOAP's intermediary support even more powerful, most \rnotably by adding the mustUnderstand attribute. It affords forward-\rcompatibility for coping with future actors and headers. \r\rA subtler lesson is in the social construction of proxies. For the \rhypermedia Web, user-agents presumed there was a single, \rpermanent proxy, typically for caching or content-filtering. We simply \rdidn't envision dynamically calculating purpose-built chains of proxies \rfor given transactions. I can testify to that personally because of the \rlong-running failure of a proposal I made at W3C called PEP that called \rfor just that.\r\rBut for the services Web, SOAP has laid the groundwork for per-\rtransaction intermediation. Microsoft's Henrik Frystyk Nielsen has \rgone so far as to propose Web Services routing and referral standards \ralong these lines.\r\rIndeed, the new challenge is systematizing our ability to string \rtogether intermediaries at will. If we can call a multi-hop, multi-path \rcomposition of active proxies a route, it sounds reasonable that a \rdevice that automatically calculates and enacts such routes should be \rcalled a router.\r\rSo having named it, what does it actually do, and how does it work?\r\rA router is a device that, given a symbolic name, resolves it into an \raddress(es) of communication paths one layer below for onward \rdelivery. An IP router maps IP addresses into the MAC address(es) of a \rLAN adapter. An application-layer router maps resource names into \rapplication protocol messages. \r\rFor example, presenting an application-layer router with the \rdocument \"party tonight!\" at the URL /Rohit/announcements might be \rresolved into specific onward URLs such as \rmailto:adam@knownow.com, ftp://fred@mit.edu/inbox, and \rhttp://roy-s-webserver/logger.cgi , if there were three such routing \rrules, or \"subscriptions\" for each listening service.\r\rHow would such a router be implemented? Once again, I appeal to \rLayer 3 precedents. The key to internetworking many different LAN \rprotocols is that rather than translating them directly, each one is \rmapped to IP as an intermediate form. So a Layer-3 IP router would \rhave several kinds of LAN adapter cards, and upon receipt of any \rpacket, it would internally convert it to IP format, store away its copy, \rand then indicate to the input LAN that the data had been consumed. \rThen, at some later time, if the router hadn't been forced to throw it \raway due to memory exhaustion or aging, the destination addresses \rfor the packet would be calculated, and it would be transmitted \ronward, after being translated out to a foreign LAN format if \rnecessary.\r\rThat is exactly how I propose a Layer-7 router ought to work. Or, \rspecifically, what I term a SOAP router. Just as IP provided a \rmetaformat for encoding many different addressing schemes, \rsignaling messages, and payloads, I posit that a SOAP message is \rsimilarly flexible enough to intermediate all other major Layer-7 \rapplication protocols. \r\rSpecifically, rather than using IP addresses to identify computers, we \ruse WebDAV collections (directories) to identify topics. This way, FTP \rdirectories, mailboxes, newsgroups, and SNMP devices can all be \rmapped into WebDAV collections. Then, new or modified resources \rwithin the router's topic space can be delivered onward using the \rsame range of supported protocols.\r\r\"OK,\" you might agree, warily. \"So what?\"\r\r[... well from here on out, you had to be at the talk!]", "encoding": "ascii"}