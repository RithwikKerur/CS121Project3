{"url": "https://www.ics.uci.edu/~thornton/cs141/ProjectGuide/Project3/Examples.hs", "content": "-- Examples.hs\r\n-- CompSci 141 / CSE 141 / Informatics 101 Spring 2013\r\n-- Project #3 example\r\n\r\n-- The \"module\" directive gives a name to a set of definitions in a Haskell\r\n-- script.  It's actually part of a group of language features that support\r\n-- the organization of large programs into \"modules,\" with importing and\r\n-- exporting facilities that provide the kind of information hiding used to\r\n-- build abstract data types.  For our purposes, we'll use it to give a name\r\n-- to each script, so that you'll know, within the interpreter, which script\r\n-- you're currently working with.\r\n\r\nmodule Examples where\r\n\r\n\r\nfactorial :: Integer -> Integer\r\nfactorial 0     = 1\r\nfactorial n\r\n   | n > 0      = n * factorial (n - 1)\r\n\r\n\r\nlistLength :: [Integer] -> Integer\r\nlistLength []     = 0\r\nlistLength (x:xs) = 1 + listLength xs\r\n", "encoding": "ascii"}