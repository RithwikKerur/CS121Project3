{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/dictionaryprocessing/dictionaryreview.txt", "content": "\t\t\tDictionary Review: Building/Iterating\r\n\r\nNow that we have had two lectures on dictionaries, I would like this one to\r\nreview the fundamentals of dictionaries, concentrating on the most frequently\r\nused operators/iteration on dictionaries.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n3 Important operations (and one less important one)\r\n\r\n1) The \"in\" operator determines whether a k is associated with some values in a\r\ndictionary. We can write it as k in d, and can also be written x in d.keys().\r\n\r\nThe in operator is often important when building dictionaries, to determine\r\nwhether a key is already in the dictionary, associated with some value: often\r\nwe perform one operation to update the values associated with a key in a\r\ndictionary, but perform another operation to create a new key/value association\r\nin a dictionary. The in operator helps us determine which operation to do (see\r\nBuilding Dictionaries below).\r\n\r\n2) Indexing a dictionary with a key retrieves the value associated with a key.\r\nOften we either examine this value or update/mutate it (when building a\r\ndictionary). We write d[k] to perform this retrieval. Note that if k is not\r\na key in the dictionary, then indexing d[k] raises an exception. Of course, we\r\ncan always check whether k is in a d by using the \"in\" operator. \r\n\r\n3) There are three ways to iterate through a dictionary. By far the two most\r\ncommon iteration idioms are iterating through the keys and iterating through\r\nthe items (key value pairs, appearing in a 2-tuple). The first form is written\r\nfor k in d, and can also be written for k in d.keys(); the second form is\r\ntypically written for k,v in d.items().\r\n\r\nWe can also iterate over all the values associated with keys in a dictionary,\r\nwithout refering to keys at all, although this is uncommon: it is written\r\nfor v in d.values().\r\n\r\nNote that if nothing is stored in a dictionary, all these loops execute 0\r\niterations (never execute the code in their bodies).\r\n\r\n4) Less frequently used is the del operator, which deletes a key from a\r\ndictionary. It is written del d[k], which raises an exception if the key is\r\nnot in the dictionary; a variant is d.pop(k) which not only removes the key from\r\nthe dictionary, but returns its associate value.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nBuilding Dictionaries\r\n\r\nFor building dictionaries, there are two cases we must code\r\n\r\n  (1) The key is not already in the dictionary (initialize an associated value)\r\n  (2) The key is already in the dictionary     (update its associated value)\r\n\r\nTypically a dictionary is built by iterating through a string, range, lines is\r\na file, list, or even another dictionary.\r\n\r\nLet's look at two specific common tasks: on the left, counting how often a key\r\noccurs; on the right, adding a value to a list associated with a key. We will\r\nassume that we want to initiallize/update the dictionary for the name \"key\"\r\n(and in the list problem, add \"value\" to the list associated with \"key\").\r\n\r\n(a) Here is an example of these two case for a standard dictionary, using only\r\nthe simplest dictionary operations. Assume we originally define/initialize d as\r\neither d = {} or d = dict(): both are empty dictionaries\r\n\r\nif key not in d:\t\tif key not in d:\r\n    d[key] = 1\t\t\t    d[key] = [value]\r\nelse:\t   \t\t\telse:\r\n    d[key] += 1\t\t\t    d[key].add(value)\r\n\r\n(b) Here is an example which simplifies the if/else to just an if statement\r\nfollowed by a second statement. The if statement initializes the dictionary for\r\nthat key (if it is not there) and then the second statements updates the value\r\nassociated with the key. In both cases, the access d[key] in the second\r\nstatement will never raise an exception, because by the time it is executed\r\nkey is guaranteed to be in the dictionary: if it was not originally in the\r\ndictionary, the if statement will put it there.\r\n\r\nif key not in d:\t\tif key not in d:\r\n    d[key] = 0\t\t\t    d[key] = []\r\nd[key] += 1\t\t\td[key].add(value)\r\n\r\n\r\n(c) These forms also leads to the study/use of setdefault, to simplify this\r\ncode into a single line.\r\n\r\nd.setdefault(key,0) += 1        d.setdefault(key,[]).add(value)\r\n\r\nRecall the setdefault acts as follows, which does the if/test itself, so we\r\ndon't have to write it in our code above. It always returns a reference to\r\nthe value associated with key (even it this function itself creates the\r\nassociation).\r\n\r\ndef setdefault(key,default=None)\r\n    if key not in adict:\r\n        adict[key] = default\r\n    return adict[key]\r\n\r\n(d) In the next lecture we will learn about a more advanced kind of dictionary\r\ncalled defaultdict (which we must import from the collections module). With\r\nthis data structure we define the dictionary as follows.\r\n\r\nd = defaultdict(int)\t\td = defaultdict(list)\r\n\r\nIf a defaultdict accesses a key that is not in the dictionary, unlike for dict\r\nit does NOT raise an exception. Instead, in the first case it will put an int()\r\nassociated with that key (int() is 0; just something you need to know); in the\r\nsecond case it will put a list() associated with that key (list() is the same\r\nas the literal []: it just constructs an empty list). By using a default dict,\r\nwe need only the following\r\n\r\nd[key] += 1\t\t\td[key].add(value)\r\n\r\nIn both cases, by using a default dict we do not have to call setdefault\r\nexplicitly: setdefault's actions are automatically done by the default dict\r\n\r\nOn the left, if key exists it will be incremented; if it doesn't exist, it will\r\nbe automatically associated with the value 0 and then incremented.\r\n\r\nOn the right, if key exists it will have value appended to its list; if it\r\ndoesn't exist, it will be automatically associated with an empty list, and then\r\nwill have value appended to its list.\r\n\r\n(e) If we wanted not duplicate value in the list, the best code would be\r\n\r\n       \t  \t     \t        if key not in d:\r\n\t\t\t\t    d[key] = []\r\n\t\t\t\tif value not in d[key]\r\n       \t  \t\t\t    d[key].add(value)\r\n\r\nIf we don't want duplicates, instead of using a list associated with a key we\r\nshould use a set (which is covered in the next lecture).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterating Through Dictionaries (where order is unimportant)\r\n\r\nOnce we build a dictionary, we often examine it by iterating over its keys,\r\nand items (and less likely values). Thus, there are 3 standard ways to iterate\r\nover dictionaries. Here are three simple code fragments to print every\r\nkey/value in the dictionary.\r\n\r\n(1) Iterate over keys: use the dictionary to get the value associated with each\r\nkey. Often when iterating over just keys, the name k is used; if you know\r\nsomething more explicit about the keys (say they are all words) we can write\r\nfor word in d:\r\n\r\nfor k in d:  # or more explicitly for k in d.keys()\r\n    print(k,'->',d[k])\r\n    \r\n(2) Iterate over items (a 2-tuple): print the key (index 0) and its associate\r\nvalue (index 1); often when iterating over items, the name kv is used; if you\r\nknow something more explicit about the keys (say the keys are words and the\r\nvalues are counts) we can write for word_count in d:\r\n\r\nfor kv in d.items():\r\n    print(kv[0],'->',kv[1])\r\n\r\n\r\n(3) Iterate over items, but \"unpacking\" the 2-tuple into two names\r\n\r\nfor k,v in d.items():\r\n    print(k,'->',v)\r\n    \r\nIf we wanted to print just the values (not the keys at all) we could use any of\r\nthe three previous forms and just not print k (or kv[0]) but better is the\r\nfollowing form\r\n\r\nfor v in d.values():\r\n    print(v)\r\n\r\nTypically we iterate over keys; if we aren't concerned with their values at all,\r\nwe use the first form of iteration. But, if we iterate are going to find the\r\nvalue associated with each key, it is most convenient to use the third form of\r\niteration.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterating through Dictionaries in Special Orders\r\n\r\nGenerally, list/tuples are ordered (index 0, 1, ...), but not dictionaries. If\r\nwe want to iterate through a dictionary in a special order, we typically create\r\na list of the dictionary's keys (or a 2-tuple of its keys and their associated\r\nvalues), sort that list, and then iterate over the list. For example, for a\r\ndictionary d:\r\n\r\nkeys = list(d)         # or keys = list(d.keys): put all the keys in a list\r\nkeys.sort()\t       # sort the list (defaulting the key/reverse parameters)\r\nfor k in keys:\t       # iterate in sorted order, getting each key\r\n    print(k,'->',d[k])\r\n\r\nLikewise we could write\r\n\r\nIf we call sort and specify reverse=True then it sorts in the opposite order\r\n(high to low not low to high).\r\n\r\nIf we supply a function to the \"key\" parameter of the sort method, Python sorts\r\nnot by the standard ordering of keys but by the standard ordering of calling the\r\n\"key\" function on each key. If keys are strings, we could call\r\nkeys.sort(key=lambda x : x.upper()) in which case 'rich' and 'Rich' compare the\r\nsame. Or, we could call keys.sort(key=lambda x : x[-1])) so that the strings\r\nare sorted, but by their last letter only.\r\n\r\nBut what if we want an even more complicated order, based on items (both keys\r\nand values)? We can use a similar technique, storing items (keys and values) as\r\n2-tuples in a list, sorting that list (in even more interesting ways), and then\r\niterating over the list of keys and their values.\r\n\r\nitems = list(d.items())# put all the items, 2-tuples, in a list\r\nitems.sort()\t       # sort the list (defaulting the key/reverse parameters)\r\nfor k,v in items:      # iterate in sorted order, getting each items\r\n    print(k,'->',v)\r\n\r\nNote that when sorting 2-tuples, the values are sorted based on index 0; if two\r\ntuples have the same value for index 0, they are sorted according to index 1.\r\nSo ('a', 10) appears before ('z', 1) but after ('a', 2).\r\n\r\nSo, let's ignore dictionaries (which cause confusion because dictionaries\r\nhave keys and there is a key parameter in sorting) and focus just on lists:\r\neven if we want to sort items in a dictionary, once we put the items in a list,\r\nwe are just sorting lists.\r\n\r\nSo, if we have a dictionary d with keys that are strings and values that are\r\nintegers, we might specify l = list(d.items()). Now we have list\r\nl = [('b',3), ('a', 2), ('c',1)]. Here are some sorting examples.\r\n\r\nl.sort() changes l to be [('a', 2), ('b', 3), ('c',1)]\r\n\r\nbecause sorting tuples first orders them by index 0, then by index 1 (for all\r\ntuples with the same index 0)\r\n\r\nl.sort(key=lambda x : x[1]) changes l to be [('c',1), ('a', 2), ('b', 3)]\r\n\r\nbecause the key function used on teach tuple in the list selects the second\r\nvalue in the tuple to sort on.\r\n\r\nl.sort(key=lambda x : x[1], reverse=True)\r\n\r\n  changes l to be [('b', 3), ('a', 2), ('c',1)]\r\n\r\nbecause it uses the same key function as before (using the second tuple value),\r\nbut reverse=True reverses the order.\r\n\r\nIn fact, if we has a list of dates, where index 0 is the month, index 1 is the\r\nday, and index 2 is the year (5, 19, 2014) represents the May 19, 2014, then\r\nwe could sort a list of dates as follows.\r\n\r\nl.sort(key=lambda x : (x[2],x[0],x[1])) which would sort the list where each\r\ntuple is compared to another according to its year (first), month (second), and\r\nday (third). So (5, 19, 2014) would appear before (5, 20, 2014) because the\r\ntuples specifed by the lambdas (2014, 5, 19) < (2014, 5, 20). The general way\r\nto compare tuples is according to index 0; but if index 0 is the same, according\r\nto index 1; but if index 1 is the same, according to index 2; etc.\r\n\r\nFinally, Python allows us to simplify this process by using a function named\r\n\"sorted\". Unlike \"sort\", which is a method that mutates a list, \"sorted\" is a\r\nfunction that produces a list from anything it can iterate over. It has the\r\nsame key and reverse parameters as \"sort\".\r\n\r\nSo, we can call \"sorted\" in a for loop. So instead of writing\r\n\r\nkv = list(d.items())\r\nkv.sort(key=lambda x : x[1], reverse=True)\r\nfor k,v in kv:\r\n    print(k,'->',v)\r\n\r\nwe can write the more compact\r\n\r\nfor k,v in sorted(d.items(), key=lambda x : x[1], reverse=True):\r\n    print(k,'->',v)\r\n\r\nFor the dictionary d = {'a':2, 'b':3, 'c':1}, both of which would print \r\n\r\nb -> 3\r\na -> 2\r\nc -> 1\r\n\r\nIn fact, we can write the sorted function as\r\n\r\ndef sorted(iterable,key=None,reverse=False):\r\n   alist = list(iterable)\r\n   alist.sort(key=Key,reverse=reverse)\r\n\r\nRecall that sort has parameters key and reverse; we match those with the\r\narguments passed to key and reverse in the sorted method.\r\n", "encoding": "ascii"}