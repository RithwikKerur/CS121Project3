{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/PyGameBasics/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: PyGame Basics</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: PyGame Basics</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Writing a visual game in Python</p>\r\n\r\n<p>It is likely that you've played some kind of visual game &mdash; on a computer or a video game console &mdash; and, as you learn more about writing programs, you might rightly be wondering how you might go about building your own game.  So-called \"Triple-A\" games with their huge teams of artists and software developers (and the giant budgets to pay all of them) are obviously out of our reach at this point, but there is still something to be said for games that are small and simple; a lot of fun has been had (and even a fair amount of money has been made) with relatively simple games, particularly with the rise of smartphones, where games like <a href=\"https://en.wikipedia.org/wiki/Angry_Birds\">Angry Birds</a> captivated millions of people.</p>\r\n\r\n<p>When I was a kid, game programming of almost any kind generally required a fairly extensive skill set.  The tools being what they were at the time &mdash; machines much less than 1/1000 as powerful as today's inexpensive smartphones &mdash; it was necessary to play almost every low-level trick in the book to build even a simple game.  The earliest games that ran on the <a href=\"https://en.wikipedia.org/wiki/Atari_2600\">Atari 2600</a>, for example &mdash; a video game console I had as a young kid &mdash; had to be written with a grand total of <i>four kilobytes</i> of code (and assets, such as images and sounds) for an entire game.  Games weren't written in high-level languages like Python; they were written painstakingly, one low-level machine instruction at a time.  It was necessary to know every detail of how the hardware worked, because only then could you find a way to exploit its spartan abilities enough to make a playable, fun game run on it.</p>\r\n\r\n<p>Today, though, we have an embarrassment of riches.  Even inexpensive devices are fast, with comparatively abundant amounts of memory, and near-ubiquitous access to relatively fast networks.  That the machines are more powerful leaves us able to use higher-level languages (like Python), even though we might incur a performance cost for using them, because we don't need to push our machines to the limit to run simple games anymore.  (That said, there are still a lot of games that reach the limits of what our hardware can do, and that still requires a depth of knowledge to accomplish; the difference is that we don't need to reach the limits just to write a game like Atari's <a href=\"https://www.youtube.com/watch?v=2LxPEdUZOkE\">Combat</a> anymore.)</p>\r\n\r\n<p>It's certainly possible that you might see games as frivolous, but it's fair to say that they are actually nothing of the kind; they provide a fascinating combination of problems to be solved: software engineering, human-computer interface, computer networks, psychology and cognition, and even (in multiplayer online games) economics and sociology.  Game developers push the envelope &mdash; in some cases, further than just about any other kind of software developers &mdash; and many of these lessons can be applied in more seemingly serious contexts.  In short, games have a lot to teach us about software, so we should explore what they have to offer.</p>\r\n\r\n<p class=\"subtitle\">What do we need?</p>\r\n\r\n<p>When considering how to write a visual game in Python, the first question we need to answer is <i>What do we need?</i>  What functionality will we need in order to be successful?  What's available in Python's standard library to help us?  What third-party libraries fill the gaps, when the standard library doesn't get us where we want to go?</p>\r\n\r\n<p>Here are a few of the things we need to be able to do:</p>\r\n\r\n<ul>\r\n  <li>Generate graphical output, instead of printing text and reading keyboard input via the Python shell, as we've been doing so far.  In short, this means we need to be able to draw pictures.</li>\r\n  <li>Animation will be necessary, though this isn't much different from the graphical output we already mentioned.  Animation is nothing special, as it turns out; it's just displaying many pictures in rapid succession, rather than just displaying one picture.</li>\r\n  <li>Generate <i>audible</i> output, as well; it would be nice if we could hear something when our game is being played, as opposed to only seeing it.</li>\r\n  <li>Receive input from the keyboard, but not one line at a time.  In other words, we'd like to be able to react to keypresses as they happen, including combinations of keypresses &mdash; for example, we might like to move a character diagonally when a user is holding down both the \"up\" and \"left\" arrow keys simultaneously.</li>\r\n  <li>Receive input from other devices, such as the mouse, a joystick, or a game pad.</li>\r\n  <li>Generate random data, which is one way to make a game behave differently each time you play it.  For example, if you're building a blackjack game, you'd want the cards chosen to be different each time you play it; to do that, you'd need to generate numbers randomly and then choose the cards based on which numbers were generated.</li>\r\n</ul>\r\n\r\n<p>Few of these things are handled well in Python's standard library, as it turns out.  The standard library does have a <b>random</b> module that can help us with the random-number generation, but as soon as we get into other areas, we find it to be lacking.</p>\r\n\r\n<p>Fortunately, we're not limited only to what's in Python's standard library.  And there is a fairly full-featured library called <b>PyGame</b>, which we learned how to install in the <a href=\"../ThirdPartyLibraries\">previous set of notes</a>, that can do the rest of the things we're looking for.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Getting started with PyGame</p>\r\n\r\n<p>Like any large library, it can seem daunting to start learning about PyGame, but the best way to do it is to start with something simple and work your way up.  There are some basic concepts to learn, and most of the rest of the library is just details &mdash; and the nice thing about the fine-grained details is that they can be looked up in documentation, once you understand the concepts.</p>\r\n\r\n<p>The PyGame library is extensive enough that it is actually divided into various sections, with each of those sections focused on one kind of functionality you'd need to write a game.  Not all games will need all of the sections, but any of them will be available once you've downloaded PyGame; as you discover a need for one, you can feel free to use it.</p>\r\n\r\n<p class=\"subtitle\">Initialization and shutdown</p>\r\n\r\n<p>PyGame requires <i>initialization</i> at the beginning of your program and <i>shutdown</i> at the end.  This is needed to set up various internal data structures, load and configure the necessary components, and so on.  Each is easy to do:</p>\r\n\r\n<ul>\r\n  <li>The function <b>pygame.init()</b> initializes the PyGame library.  You'd need to call this before you can do anything else with the library.</li>\r\n  <li>The function <b>pygame.quit()</b> shuts the PyGame library down.  You'd need to call this after you're done using it.</li>\r\n</ul>\r\n\r\n<p>These functions are both part of the <b>pygame</b> module, which you would need to import before you could use it.</p>\r\n\r\n<p>All of these facts give rise to the simplest imaginable PyGame-based program you could write.</p>\r\n\r\n<blockquote><pre>\r\nimport pygame\r\n\r\n\r\ndef run() -&gt; None:\r\n    pygame.init()\r\n    pygame.quit()\r\n\r\n\r\nif __name__ == '__main__':\r\n    run()\r\n</pre></blockquote>\r\n\r\n<p>Running this program doesn't turn out to be very interesting, as you'll see no visual indication that it's doing anything, except it may take a couple of seconds to perform the initialization.  To make it more interesting, we'll need a <i>surface</i> to draw on, and we'll need it to be visible by making it the <i>display</i>.</p>\r\n\r\n<p class=\"subtitle\">Creating a display with a surface</p>\r\n\r\n<p>The <b>pygame.display</b> module contains functions that let you control how PyGame displays graphical output.  (Note that you won't need to import \"submodules\" of <b>pygame</b> such as <b>pygame.display</b> yourself; one of the things that happens when you initialize <b>pygame</b> using the <b>pygame.init()</b> function is that all of the necessary modules are imported and initialized for you automatically.)</p>\r\n\r\n<p>The first of these functions that we'll need is called <b>pygame.display.set_mode()</b>, which is how you create a new window.  It takes one argument, which is a two-element tuple that specifies the width and height of the window, measured in <i>pixels</i>.</p>\r\n\r\n<blockquote><pre>\r\nimport pygame\r\n\r\n\r\ndef run() -&gt; None:\r\n    pygame.init()\r\n\r\n    # Creates a window containing a surface that is\r\n    # 700 pixels wide and 600 pixels tall.\r\n    surface = pygame.display.set_mode((700, 600))\r\n\r\n    pygame.quit()\r\n\r\n\r\nif __name__ == '__main__':\r\n    run()\r\n</pre></blockquote>\r\n\r\n<p>If you run this program, you'll see that it's similar to the one we wrote before &mdash; it still starts and ends on its own and doesn't run for very long &mdash; but that it pops up a window that subsequently disappears.  The window is around 700 pixels wide and 600 pixels tall, and shouldn't display anything but a black background.</p>\r\n\r\n<p>If we want something to appear in the window other than its default background color, then we'll need to draw something.  The <b>pygame.display.set_mode()</b> function doesn't just cause a window to pop up; it also returns an object called a <i>surface</i>.  A surface is an object representing an image that can be displayed by PyGame, so a lot of what we'll be doing, when we want to control how graphics are displayed, is manipulating these surfaces.  The surface returned from <b>pygame.display.set_mode()</b> is the one that represents the area within our newly-created window.</p>\r\n\r\n<p class=\"subtitle\">The game loop and events</p>\r\n\r\n<p>Games like the ones we'll be building have at least a couple of things they need to be dealing with, seemingly simultaneously.</p>\r\n\r\n<ul>\r\n  <li>They need to react to inputs such a keypresses, mouse movements, or the window being resized.</li>\r\n  <li>They need to draw pictures fairly often, many times per second, to achieve smooth animation.</li>\r\n</ul>\r\n\r\n<p>PyGame provides tools that make it easy for us to organize these things within a single loop, which we'll call the <i>game loop</i>.  Many times per second, we'll do two things:</p>\r\n\r\n<ul>\r\n  <li>Check if we received any input since the last time we asked.  These will be given to us in the form of what PyGame called <i>events</i>, which specify that some kind of input needs to be processed.</li>\r\n  <li>Draw the next \"frame\" of our animation and display it.</li>\r\n</ul>\r\n\r\n<p>PyGame provides tools for doing these things (and for controlling the frequency of our game loop, so it won't do unnecessary work).  However, it should be understood that it's our loop; we're the ones who will need to write it.  PyGame provides the tools to help us build our game, but we're still the ones fundamentally structuring it.</p>\r\n\r\n<p>Since our game loop is one that runs for as long as our game runs, it won't be a <b>for</b> loop; we don't know ahead of time how many times it will run.  And we'll need a way to get out of it when we know our game is supposed to end, so we'll use a boolean variable to keep track of that.</p>\r\n\r\n<blockquote><pre>\r\nimport pygame\r\n\r\n\r\ndef run() -&gt; None:\r\n    pygame.init()\r\n\r\n    surface = pygame.display.set_mode((700, 600))\r\n\r\n    running = True\r\n\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n\r\n        pygame.display.flip()\r\n\r\n    pygame.quit()\r\n\r\n\r\nif __name__ == '__main__':\r\n    run()\r\n</pre></blockquote>\r\n\r\n<p>What we have now is the basic game loop for a PyGame-based game.  A few things are going on here:</p>\r\n\r\n<ul>\r\n  <li>The <b>running</b> variable is a boolean value that keeps track of whether we should continue running.  It starts out <b>True</b> and is set to <b>False</b> when we want the game to end; the <b>while</b> loop will end when <b>running</b> has been set to <b>False</b>.</li>\r\n  <li>The <b>pygame.event.get()</b> function returns a collection of the input events that have happened since the last time you called it.  (Why it may return more than one is that more than one even may have happened; you might have moved the mouse and pressed a key on the keyboard.)  Each event is an object we call an <i>event object</i>.  They all have a <b>type</b> attribute that describes what kind of event they are; the <b>pygame.QUIT</b> event type, for example, means that we've attempted to close the window in which our game is being displayed.</li>\r\n  <li>The <b>pygame.display.flip()</b> function means that we want to re-draw the display's surface in our window.  In other words, if we've made any changes to that surface, <b>pygame.display.flip()</b> will make those changes visible.  By doing this in each iteration of our game loop, we lay the groundwork for displaying animation; all we need to do is change the surface, and we'll see the change in our next loop iteration.</li>\r\n</ul>\r\n\r\n<p>Running this program, we'll see a window that pops up, with a black background, but which will remain visible until we close it (using a standard technique for our operating system, such as clicking the \"X\" in the top right, if we're running on Windows).</p>\r\n\r\n<p class=\"subtitle\">Colors</p>\r\n\r\n<p>If we want to draw something in our window, we'll first have to understand a little bit about colors, because everything has to have a color if we want it to be visible.  Colors are represented in PyGame as <b>pygame.Color</b> objects, each of which stores three values:</p>\r\n\r\n<ul>\r\n  <li>An amount of red, expressed as an integer from 0-255, with 0 being no red at all, and 255 being the maximum amount of red available.</li>\r\n  <li>An amount of green, expressed as an integer from 0-255, similarly.</li>\r\n  <li>An amount of blue, expressed as an integer from 0-255, similarly.</li>\r\n</ul>\r\n\r\n<p>The idea of expressing colors as a mixture of red, green, and blue is not unique to PyGame; it's a fairly standard approach known as RGB.  While there are other approaches to mixing colors, RGB has the benefit of being easy to understand, especially if you've ever mixed colors (paints, for example) before.  (Most people are unsurprised that mixing equal amounts of red and green gives a shade of yellow, for example.)</p>\r\n\r\n<p>Constructing a color in PyGame is a simple matter of constructing a <b>pygame.Color</b> object and passing three arguments to its constructor: the amount of red, green, and blue, respectively.  For example, we could create an object representing the brightest red by saying <b>pygame.Color(255, 0, 0)</b> (the maximum amount of red, no green, and no blue).  We could create a bright yellow as <b>pygame.Color(255, 255, 0)</b>.  And so on.</p>\r\n\r\n<p>There are lots of tools available online to allow you to mix colors.  One that I've found easy to use is called <a href=\"https://www.webpagefx.com/web-design/color-picker/\">Color Picker</a>, which you can fairly easily figure out how to use by playing around with it a bit.  The key thing is knowing how to extract the color you chose from it.  For our purposes, what we want is the amount of red, green, and blue, expressed as a number from 0-255; those will be displayed in the boxes marked <b>R:</b>, <b>G:</b>, and <b>B:</b>, respectively.  In the example below, the color we chose would be represented in PyGame as <b>pygame.Color(232, 111, 30)</b>.</p>\r\n\r\n<p class=\"center\"><img src=\"ColorPicker.png\" alt=\"Color Picker Example\" /></p>\r\n\r\n<p class=\"subtitle\">Drawing on our surface</p>\r\n\r\n<p>If we want to display something other than a black background, we'll need to change our surface during our game loop.  One way to do that is to fill the surface with a single color.  Suppose we updated our game loop to look like this &mdash; leaving the rest of our program the same.</p>\r\n\r\n<blockquote><pre>\r\nwhile running:\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n\r\n    surface.fill(pygame.Color(232, 111, 30))\r\n\r\n    pygame.display.flip()\r\n</pre></blockquote>\r\n\r\n<p>The <b>surface.fill()</b> function does what it sounds like: it fills an entire surface with one color.  Our window's background will now be orange instead of black, because we've done the two things necessary to change it: update the surface belonging to our window (the one returned from <b>pygame.display.set_mode()</b>) and \"flip\" the display to make the latest changes to that surface visible.</p>\r\n\r\n<p>We could make our color change over time instead by driving the color with variables instead of always filling the surface with a constant color.</p>\r\n\r\n<blockquote><pre>\r\ncolor_amount = 0\r\n\r\nwhile running:\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n\r\n    color_amount = (color_amount + 1) % 64\r\n    surface.fill(pygame.Color(color_amount, color_amount, color_amount))\r\n\r\n    pygame.display.flip()\r\n</pre></blockquote>\r\n\r\n<p>Each time we run through our game loop, we're adding 1 to an amount of color that we're using as the amount of red, green, and blue.  (Whenever red, green, and blue amounts are the same, what you'll get is a shade of gray.  All 0's will be black, all 255's will be white, and everything in between will be some shade of gray in between.)  By using the <b>%</b> operator to keep the value in the range 0..63, we're keeping the effect from being too overwhelming, but it's still much too wild; it would be nice if the change could become more gradual.  The problem is that our game loop is running as fast as it possibly can, so the number of color changes per second is limited only by the speed of our machine.  Instead, it's time we started controlling the rate at which our game loop runs.</p>\r\n\r\n<p class=\"subtitle\">Clocks</p>\r\n\r\n<p>PyGame provides a kind of object called a <i>clock</i>, which can help you to limit your game loop's frequency.  Each time a clock is \"ticked,\" it checks the time it was last ticked, then waits until the difference between the current time and the time it was last ticked is the desired amount.  The effect of doing this in each iteration of your game loop is to control the number of loop iterations per second.  Since we're drawing one picture per loop iteration, this has the effect of limiting that number of pictures.  The common terminology in animation is to say that each picture we draw is a <i>frame</i>, so the common name for the number of pictures drawn each seconds is a <i>frame rate</i>.</p>\r\n\r\n<p>The constructor <b>pygame.time.Clock()</b> is used to construct a clock.  The <b>tick()</b> method can be called on the resulting object to insert the appropriate delay.  The argument to <b>tick()</b> is not the duration of the delay, but instead is the desired frame rate; so, for example, if you pass it 30, it will wait long enough that the next iteration of your game loop would start 1/30 of a second after the previous one.</p>\r\n\r\n<blockquote><pre>\r\ncolor_amount = 0\r\nclock = pygame.time.Clock()\r\n\r\nwhile running:\r\n    clock.tick(30)\r\n\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n\r\n    color_amount = (color_amount + 1) % 256\r\n    surface.fill(pygame.Color(color_amount, color_amount, color_amount))\r\n\r\n    pygame.display.flip()\r\n</pre></blockquote>\r\n\r\n<p>We're now oscillating between the 256 shades of gray, about 30 shades per second.  So our window's background should go from being black to being white in a little over eight seconds, then revert immediately to black again and repeat.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Drawing shapes on our surface</p>\r\n\r\n<p>The <b>pygame.draw</b> library allows us to draw lines and shapes on our surface.  If we draw different shapes, or the same different shapes in different places, in each frame of our animation, we'll be able to show some fairly smooth-looking movement.</p>\r\n\r\n<p class=\"subtitle\">Coordinates</p>\r\n\r\n<p>First, we need to understand how to describe positions within our window.  We've seen before that we create our window to have a width and a height measured in <i>pixels</i>.  Each pixel is effectively a tiny rectangle, and each can be filled with a single color.  Depending on your machine (and how it's configured), there might be millions of them available to work with.  For example, the laptop computer I used to write these notes has 1,920 pixels across and 1,080 down, for a total of just over 2,000,000 pixels; this is not out of the ordinary nowadays.</p>\r\n\r\n<p>The important question, though, is how to address each pixel individually.  PyGame uses the same coordinate system that has long been typical in two-dimensional computer graphics, which will differ somewhat from what you might have become accustomed to when you learned algebra.  In two-dimensional computer graphics, it's customary for a particular point to be described by an ordered pair (<i>x</i>, <i>y</i>) of <i>coordinates</i>, just as in algebra.  However, the <i>origin point</i> (0, 0) is generally the top-left corner, with <i>x</i>-coordinates increasing as you move to the right, and <i>y</i>-coordinates increasing as you move down.  So, for example, on an area measuring 500 pixels wide and 400 pixels tall, the coordinate system will typically look like this.</p>\r\n\r\n<table border=\"0\" align=\"center\">\r\n  <tr>\r\n    <td align=\"right\">(0, 0)</td>\r\n    <td></td>\r\n    <td>(499, 0)</td>\r\n  </tr>\r\n  <tr height=\"100\">\r\n    <td></td>\r\n    <td><img src=\"coordinates.png\" alt=\"\" /></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td align=\"right\">(0, 399)</td>\r\n    <td></td>\r\n    <td>(499, 399)</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>As we'll see, when the window might be resized, it gets a little trickier to get exactly what we want (e.g., resizing the image proportionally when we resize the window); we'll see how to work around that issue in a later example.</p>\r\n\r\n<p class=\"subtitle\">Drawing a circle</p>\r\n\r\n<p>We can draw a circle on a surface by calling the <b>pygame.draw.circle()</b> function, which takes four arguments: the surface on which we want to draw the circle, the color that should be used to fill the circle, a two-element tuple containing the <i>x</i>- and <i>y</i>-coordinates where the circle should be centered, and the radius of the circle.</p>\r\n\r\n<p>For example, we could add a yellow-filled circle to our current example by adding this line into our game loop:</p>\r\n\r\n<blockquote><pre>\r\n    pygame.draw.circle(surface, pygame.Color(255, 255, 0), (350, 300), 100)\r\n</pre></blockquote>\r\n\r\n<p>The order in which we draw things is important; we'd need to draw the circle <i>after</i> we fill the surface with a color, or else filling the surface will \"paint over\" our circle.  (In general, we have to draw in layers, with things we want to appear \"above\" other things drawn later &mdash; the technique of considering how things overlay on top of each other on a display is sometimes called <i>z-ordering</i>, so named because we respect a third dimension, depth, which we could refer to as the <i>z</i>-dimension to separate it from the <i>x</i>- and <i>y</i>-dimensions we've seen already.)</p>\r\n\r\n<p>Adding that one line of code &mdash; just after the call to <b>surface.fill()</b> &mdash; will have the desired effect; we'll now see a never-changing circle filled with yellow, with the background color changing around it.  Because we centered the circle at (350, 300) &mdash; which would be the center of the window, given that it is 700 pixels wide and 600 pixels tall &mdash; the circle will be centered within the window.</p>\r\n\r\n<p>Of course, we could change the circle from one frame to the next, as well, if we wanted to animate it.  If we draw each animation frame differently from the one before it, that's the nature of a moving animation; it really is that simple.  For example, we could vary its position by centering it in a different location, or we could vary its size by changing its radius.</p>\r\n\r\n<blockquote><pre>\r\ncolor_amount = 0\r\nclock = pygame.time.Clock()\r\ncircle_center_x = 350\r\ncircle_center_y = 300\r\n\r\nwhile running:\r\n    clock.tick(30)\r\n\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n\r\n    color_amount = (color_amount + 1) % 256\r\n    circle_center_x -= 1\r\n    circle_center_y += 1\r\n\r\n    surface.fill(pygame.Color(color_amount, color_amount, color_amount))\r\n\r\n    pygame.draw.circle(\r\n        surface, pygame.Color(255, 255, 0),\r\n        (circle_center_x, circle_center_y), 100)\r\n\r\n    pygame.display.flip()\r\n</pre></blockquote>\r\n\r\n<p>One thing to note, which we'll return to in our next example: As our game loop has become more complex, it's getting harder to wrap our minds around its entire effect.  But it's actually got a fairly predictable structure, so we might be wise to break this up into smaller functions as it grows in complexity.</p>\r\n\r\n<ul>\r\n  <li>Initialize the \"world\".  (In this case, the \"world\" is the color of the background and the center point of the circle.)</li>\r\n  <li>While the loop is still running:\r\n    <ul>\r\n      <li>Pause for the next frame, so we don't go too fast.</li>\r\n      <li>Handle any input events, making adjustments to our world.  (In this case, our adjustments aren't different depending on the input, but you could imagine moving the circle using the keyboard or the mouse instead.)</li>\r\n      <li>Re-draw the world, then flip the display.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>That general structure will recur throughout our examples, and is a fairly standard way to think about the game loop of the kinds of games we'll be experimenting with in this course.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Where to find more information about PyGame</p>\r\n\r\n<p>When you want to know more about the PyGame library, a good place to start is the <a href=\"../../Notes\">Notes and Examples</a> on the course web site, where I've tried to outline the big-picture concepts and demonstrate a few examples.  Most likely, though, there will be things that you run into that don't happen to covered in those notes, so you'll also want to be able to navigate PyGame's online documentation, which is actually extensive and quite good.  You can find that documentation at the link below.</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://www.pygame.org/docs/\">PyGame documentation</a></li>\r\n</ul>\r\n\r\n<p>The documentation is organized into sections for each part of the library; you'll see links to those sections listed near the top of the page.  For example, if you're unsure about some part of the <b>pygame.display</b> library, you'll find a link titled <b>display</b>.  I generally find myself using those navigation links near the top when I want to jump around and look at the details of things I don't remember or haven't seen yet.</p>\r\n\r\n<p>There are also some tutorials available, though you'll find that they can take you into a lot of places where we won't need to go for our work.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>A complete version of the example that we developed throughout this set of notes is available below.</p>\r\n\r\n<ul>\r\n  <li><a href=\"pygame_basics.py\">pygame_basics.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}