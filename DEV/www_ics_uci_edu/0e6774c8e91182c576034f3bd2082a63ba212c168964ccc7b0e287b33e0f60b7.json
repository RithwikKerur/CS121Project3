{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990921.txt", "content": "WebDAV Advanced Collections Minutes September 21, 1999\n\nATTENDING: Judy Slein, Chuck Fay, Geoff Clemm\n\nACTION ITEMS\n\nJUDY: Check with Jim Whitehead about proposed new meeting time\nGEOFF: Present on the mailing list his arguments against protecting \nthe lock Request-URI\nJUDY: Send a note to authors only, proposing that we change the\nmeanings of Request-URI and Destination in BIND to make them match\nCOPY / MOVE.\nGEOFF: Revise the language for the mappings algorithm.\nJUDY: Propose syntax for BIND error descriptions.\nGEOFF: Write your proposal for GET, etc., with bindings that takes\ninto account executable resources, and send it to the mailing list.\nJUDY: Send the proposal that we always respond to all methods for\nredirect references with 302 to authors only.\n\nLOGISTICS\n\nCan we reschedule to accommodate Jason? \nWe propose Wednesdays 2:00 - 4:00 Eastern time, but need\nto check with Jim Whitehead\n\nDeadline for Internet-Drafts is October 22\n\nISSUE 2: PROTECTING THE URI OF A LOCKED RESOURCE \n\nChuck: Is protecting the URI required by RFC 2518?\n\nIt's implicit in the definitions in RFC 2518, and Yaron's e-mail\nimplies that it was intended.\n\nIf we decide not to require protecting the lock Request-URI, will \nthat require any ching in RFC 2518?\n\nGeoff: Unsure how hard to push on this issue.  If you have just one\ntree on one server, it's a little expensive to protect the URI if\nthe tree is deep.  But the real costs appear when you add multiple\nbindings. \n\nHow does this issue apply to Document Management Systems?\n\nDMA 1.0 outlaws cross-server containment, but allows a reference from \none server to another (more like a redirect reference). Versioning is \nall on one server, but has nothing equivalent to workspaces / \nselection rules.  Names are immutable OIIDs, though a docspace \nidentifier is part of the OIID, so that's a problem if you want to\ndo replication. \n\nDMA separates the containment hierarchy from the one true name.  \nThe containment hierarchy has names that build into paths.  DMA does\nnot support versioning of collections.\n\nSo DMA does not have the same problems as WebDAV versioning about\nprotecting the lock Request-URI.\n\nChuck: Assumed that you would implement protecting the URI by\ndefining a special kind of lock that you would put on each collection \nin the path to prevent delete/move on the collection.\n\nGeoff: That doesn't work when you are using dynamic URIs, that may\nrefer to a different resource in different circumstances based on\ncomputational rules.\n\nChuck: Simplify by assuming static URLs, and rule the others out of \nscope.\n\nGeoff: The client may not know whether urls are static or dynamic.\n\nChuck: If you lock a resource that you found using dynamic rules, \nthen would you want the lock to move with the resource? \n\nGeoff: Yes, the lock stays with resource, regardless of its name. You\nuse lock discovery to find the resource if its name changes.\n\nJudy: How does lock discovery let you do this?\n\nGeoff: You would have to do a PROPFIND on the DAV:lockdiscovery\nproperty for the whole space, or use DASL. \n\nGeoff: If we say we won't protect the lock Request-URI in versioning\nand bindings, but it is protected in RFC 2518, can people live with \nthat noninteroperability?\n\nISSSUE 23: REQUEST-URI AND DESTINATION IN BIND REQUESTS\n\nGeoff and Judy have been assuming different things about the meaning\nof the Request-URI and Destination header in BIND requests.\n\nJudy assumed (and the spec currently says) that the Request-URI\nidentifies the segment and collection, and the Destination header\nidentifies the resource for the binding.\n\nGeoff assumed that the request-URI identifies the resource, and the\nDestination header identifies the segment / collection for the binding.\n\nGeoff would like BIND to be analogous to MOVE and COPY, where the \nDestination header tells you where the resource will end up.  In\nMOVE and COPY, the Request-URI identifies the resource, and the\nDestination header tells you the collection / segment for creating\nthe binding to the resource.  Let's make BIND work the same way.\n\nJudy: When you think in English about the relationship you are\ncreating, you say \"Create a binding between this segment in this\ncollection to this resource.\" So let the request syntax reflect this\nnatural-language thought.  The Request-URI represents the\ncollection / segment, and the Destination represents the resource.\n\nGeoff: An aside: For both mappings and bindings I tend to talk\nabout mapping / binding a segment to a resource.  Others talk about\nbindings a resource to a name.  We should pick one of these and be\nconsistent about using it.\n\nCurrently the spec uses binding a name to a resource.  (To reflect \nthat in the method syntax, we would have the Request-URI be the name\nand the Destination header be the resource.)\n\nGeoff: In MOVE / COPY (and generally in HTTP methods), the Request-URI\nmust refer to a real resource.  The Destination is just a URL.\n\nGeoff: Think about the effect of Overwrite.  We want it to be analogous\nto Overwrite for COPY and MOVE.  For COPY and MOVE you are concerned\nabout whether a resource already exists at the Destination URL.  It\nshould be the same for BIND.  We don't want to be asking whether a\nresource already exists at the Request-URI for BIND, but at the\nDestination URL for COPY and MOVE.\n\nJudy will send a note to authors only, proposing that we change the\nmeanings of Request-URI and Destination in BIND to make them match\nCOPY / MOVE.\n\nISSUE 7: RESOURCE-TYPE HEADER\n\nLast time we decided to get rid of the Resource-Type header, and instead\nto return the DAV:reftarget property in the response body. \n\nJohn Stracke pointed out that HTTP already defines a response body for\n302's, so we can't do that.\n\nAgreed: We'll return a Ref-Target header (whose value is the same as\nthe DAV:reftarget property) instead.\n\nISSUE 10: ALGORITHM FOR MAPPINGS\n\nGeoff sent out proposed language this morning.\n\nChuck: In the first paragraph, it might be better to avoid using the\nterm \"members\".  It's unclear whether that's talking about collection\nmembers or set members.\n\nGeoff: I'll just say \"For each URL C-URL in C-MAP\".\n\nJudy's note pointed out that there will also be new URI mappings to\nthe descendents of R if R is a collection.  But she didn't propose\nprecise language for identifying those mappings.\n\nGeoff: Let's not try to define that precisely.  He'll combine\nthe first sentence of Judy's paragraph with his note on binding to\noneself or to a parent collection.  We won't try to be precise about\nthese, but just present them as comments on the main algorithm.\n\nChuck: Is it ok to create an infinite set of mappings?  When are they\nuseful?\n\nGeoff: It's a good representation of intrinsically recursive \nrelationship.\n\nIt's good to have this explicit remark about cycles and infinite\nsets of mappings, with the accompanying example.\n\nChuck: Did RFC 2518 say anything about cycles?\n\nNo.  It recognized that there could be multiple URL mappings to the\nsame resource (created out of band), but didn't explore that.\n\nISSUE 20: ERROR CODES\n\nThe mailing list seems to be agreeing that we should just use 501\nfor BIND failures, and describe what went wrong in the response body.\n\nDo we want to specify syntax for some common cases?\nYes for \"can't create cross-server binding\" and \"cycle not allowed\".\nMake each of these an XML element, and wrap them in some existing \nXML element.\n\nJudy will propose the syntax.\n\nISSUE 11: BINDINGS TO EXECUTABLE RESOURCES\n\nJudy: John Stracke thinks it is important to be able to bind to\nexecutable resources.\n\nGeoff: Had this new idea about how we can allow that, but still\nconstrain bindings in a useful way:  Say that GET through a given\nURL is equivalent to BINDing the resource to another place, then \nMOVEing it back to the original location, then doing the GET. That \nmeans that only the binding name can contribute to the modified \nbehavior.  Geoff will propose this to the mailing list.\n\nFor operation X, if you do X vs do BIND, MOVE to original location, \nthen do X, the results will be the same.  That is, BIND + MOVE \nis idempotent.\n\nChuck: Is this really a useful constraint on the behavior of \nbindings with these methods?\n\nGeoff: Each binding can have different semantics, but for any one \nbinding, the semantics of X must be the same.  The behavior of the\nresource can only depend on the state of the resource and the URL\nused to access it.\n\nSo if you do a PROPFIND on DAV:guid, if you create a new binding to\nit and then under the hood created a new GUID then move it back, \nyou should get original guid if you do PROPFIND again.\n\nIt's like the algebraic definition of PUSH and POP.\n\nChuck: What about live properties? Could they give different results? \nTime-dependent ones would have to be exceptions.\n\nISSUE 12: DAV:guid\n\nJudy: There was no controversy about this.  Jason asked whether we\ncan standardize on an algorithm.\n\nGeoff: Probably we should not, but we can suggest an algorithm.  Make\nthe guid a URN so that we can tell what algorithm was used.  This will\navoid collisions caused by different algorithms generating the same\nidentifier.  We might want to register a name for the algorithm.\n\nChuck: Use the same algorithm that was used for lock tokens, and\nmake up a name for it.\n\nISSUE 22: BIND WITH REQUEST-URI = \"/\"\n\nGeoff: We can't allow creation of a binding with Request-URI = \"/\".\nRoot doesn't have a parent collection; there's no segment here.\nWe could allow creation of a mapping in some special way, but there's\nreally no point in doing this.  The only thing you could do would be\nto move the root down.  Only the administrator could do anything else.\n\nAll you could do would be to hide part of the tree by moving the\nroot down, and then you would never be able to get back again.\n\nWe shouldn't make a special case for changing the root to be \nsomething that I already have access to.\n\nIf we do try to make a special case for \"/\", we'll only confuse\npeople between bindings and mappings.\n\nWe need more discussion on the list.\n\nISSUE 15: COPY SEMANTICS FOR REDIRECT REFERENCES\n\nGeoff: At the moment is inclined to go for extreme consistency.\nAny operation on a redirect reference responds with 302, unless\nPassthrough = false.  Then it's clear what should happend for new\nmethods as they come along.\n\nJudy: The only problematic cases were COPY, LOCK, MOVE, DELETE.  Of\nthese, LOCK is probably the most serious.  It would be impossible to\nlock a collection that contains any redirect references.  Down-level\nclients would have to lock every resource individually.\n\nGeoff: Doesn't find that a very serious concern (doesn't like\ndepth locking anyhow).\n\nThe rationale for having MOVE and DELETE affect the reference instead\nof responding with 302 was probably left over from direct references.\nIt was considered dangerous to let MOVE and DELETE affect the target,\nespecially if the target turned out to be a collection.  But that's\nnot a concern if the response is a 302.\n\nJim Amsden hates special cases for any method, wants to just operate\non the resource (COPY the reference).\n\nAlso, he thinks it would be least surprising to clients to copy the\nreference, so that the behavior of the copied resource would be the\nsame the client had experienced in the past from a GET on it, for\nexample.\n\nGeoff: Most resources that respond with 302's aren't copyable / \nmoveable, so it would be surprising to copy the reference.\n\nLock the reference is really the wrong thing to do because\nit makes people think (wrongly) that they've locked the target.\n\nCurrently, we say that the reference gets locked.  If you really \nwanted to lock target, you would have to lock the target separately.\n\nIf instead you get a 302, and you want to lock the reference, you\nsay Passthrough = false.\n\nThere will be lots of cases where you can't lock recursively anyhow.\nIt's not so terrible to create one more in the case of redirect\nreferences.\n\nDoes Passthrough work on depth operations? Yes, it applies\nrecursively.\n\nChuck: Agrees, it's appealing to always respond with 302 in the\nabsence of Passthrough = false.\n\nWhat will be the impact on all the depth operations: COPY, MOVE, LOCK,\nDELETE, PROPFIND?\n\nNonreferencing clients won't be able to lock a redirect reference\nor do a lock or copy with depth infinity.\n\nDELETE just removes the collection's binding.  You don't have to look\nbelow except for checking on locks.\n\nJudy will send the proposal that we always respond to all methods for\nredirect references with 302 to authors only.\n\n", "encoding": "ascii"}