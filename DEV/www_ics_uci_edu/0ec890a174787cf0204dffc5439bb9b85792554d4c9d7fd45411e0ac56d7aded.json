{"url": "https://www.ics.uci.edu/~rickl/courses/cs-171/projects_old_see_AI-projects/sudoku-solver/odometer.lisp.txt", "content": ";;; -*- Package: USER; Mode: Lisp; Base: 10.; Syntax: Common-Lisp -*-\r\n;;;\r\n;;; (C) Copyright 2013, Richard H. Lathrop.\r\n;;;     Computer Science Department.\r\n;;;     University of California, Irvine.\r\n;;;     All rights reserved.\r\n;;;\r\n;;;\r\n;;;****************************************************************\r\n;;;\r\n;;;    Odometer numbering for CS-171 Mega sudoku project.\r\n;;;\r\n\r\n;;;****************************************************************\r\n;;;\r\n\r\n(in-package \"USER\")\r\n\r\n(eval-when (:load-toplevel :execute)\r\n  (declaim (optimize (safety 3) (debug 3) (speed 0) (space 0))))\r\n\r\n;;;****************************************************************\r\n;;; changes\r\n\r\n;;; 20131120: Created.\r\n\r\n;;;****************************************************************\r\n\r\n;;;****************************************************************\r\n;;; notes\r\n\r\n;;; (1) load forms:\r\n'(load \"~/genes/genes_3.0/bin/lisp/system.lisp\")\r\n'(load (compile-file \"~/syngene/projects/odometer/odometer.lisp\"))\r\n\r\n;;; (1) test forms:\r\n'(test-it 2 T)\r\n'(test-it 5)\r\n\r\n;;; ****************************************************************\r\n;;; Utility Functions\r\n;;;\r\n\r\n;;; ****************\r\n;;; PROCEDURE ODOMETER_DIGIT_TO_FIXNUM (character ODIGIT)\r\n;;; /* Convert an odomoter digit, a character 1...9A...Z, to an unsigned fixnum, 0...34. */\r\n;;; RETURN POSITION( ODIGIT, \"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" );\r\n;;; /* POSITION returns the index of the first argument within the second argument. */\r\n;;; END\r\n\r\n(defun ODOMETER_DIGIT_TO_FIXNUM (ODIGIT)\r\n  (values\r\n   (POSITION ODIGIT\r\n\t     \"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")))\r\n\r\n;;; ****************\r\n;;; PROCEDURE FIXNUM_DIGIT_TO_ODOMETER (fixnum FDIGIT)\r\n;;; /* Convert an unsigned fixnum digit, 0...34, to an odomoter digit, a character 1...9A...Z. */\r\n;;; RETURN ELEMENT( FDIGIT, \"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ); \r\n;;; /* ELEMENT returns the character in the second argument indexed by the first argument. */\r\n;;; END\r\n\r\n(defun FIXNUM_DIGIT_TO_ODOMETER (FDIGIT)\r\n  (values\r\n   (elt \"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n\tFDIGIT)))\r\n\r\n;;; ****************\r\n;;; PROCEDURE ODOMETER_COUNT_BELOW_LENGTH (fixnum LENGTH)\r\n;;; /* Count the odometer numbers that can be expressed using fewer than LENGTH digits. */\r\n;;; BASE := 35;\r\n;;; POWER := 1;\r\n;;; ANSWER := 0;\r\n;;; TEMP := LENGTH - 1;\r\n;;; UNTIL ( TEMP <= 0 ) {\r\n;;; \tPOWER := POWER * BASE;\r\n;;; \tANSWER := ANSWER + POWER;\r\n;;; \tTEMP := TEMP - 1;\r\n;;; \t};\r\n;;; RETURN( ANSWER );\r\n;;; END\r\n\r\n(defun ODOMETER_COUNT_BELOW_LENGTH (LENGTH)\r\n  (do ((BASE 35)\r\n       (POWER 1)\r\n       (ANSWER 0)\r\n       (TEMP (1- LENGTH)))\r\n      ((<= temp 0)\r\n       (values answer))\r\n    (setf power (* power base)\r\n\t  answer (+ answer power)\r\n\t  temp (1- temp))))\r\n\r\n;;; ****************\r\n;;; PROCEDURE ODOMETER_AS_BASE35 (string ONUMBER)\r\n;;; /* Treat ONUMBER as a base 35 number using ODOMETER_DIGIT_TO_FIXNUM. */\r\n;;; BASE := 35;\r\n;;; POWER := 1;\r\n;;; ANSWER := 0;\r\n;;; NDX := LENGTH( ONUMBER ) - 1;\r\n;;; UNTIL ( NDX < 0 ) {\r\n;;; \tANSWER := ANSWER\r\n;;; \t\t  + ODOMETER_DIGIT_TO_FIXNUM( ELEMENT( NDX, ONUMBER ))\r\n;;; \t\t    * POWER;\r\n;;; \tPOWER := POWER * BASE; \r\n;;; \tNDX := NDX - 1;\r\n;;; \t};\r\n;;; RETURN( ANSWER );\r\n;;; END\r\n\r\n(defun ODOMETER_AS_BASE35 (ONUMBER)\r\n  (do ((BASE 35)\r\n       (POWER 1)\r\n       (ANSWER 0)\r\n       (NDX (1- (LENGTH ONUMBER))))\r\n      ((< ndx 0)\r\n       (values answer))\r\n    (setf answer (+ answer\r\n\t\t    (* (ODOMETER_DIGIT_TO_FIXNUM (ELT ONUMBER NDX))\r\n\t\t       POWER))\r\n\t  power (* power base)\r\n\t  ndx (1- ndx))))\r\n\r\n;;; ****************\r\n;;; PROCEDURE NUMBER_OF_ODOMETER_DIGITS (fixnum FNUMBER)\r\n;;; /* The number of odometer digits that will be required to represent FNUMBER. */\r\n;;; ANSWER := 1;\r\n;;; UNTIL ( ODOMETER_COUNT_BELOW_LENGTH( ANSWER + 1 )\r\n;;; \t\t\t>= ( FNUMBER + 1) )\r\n;;; \t\t{\r\n;;; \t\tANSWER := ANSWER + 1;\r\n;;; \t\t};\r\n;;; RETURN( ANSWER );\r\n;;; END\r\n\r\n(defun NUMBER_OF_ODOMETER_DIGITS (FNUMBER)\r\n  (do ((ANSWER 1))\r\n      ((>= (ODOMETER_COUNT_BELOW_LENGTH (1+ ANSWER))\r\n\t   (1+ FNUMBER))\r\n       (values answer))\r\n    (setf answer (1+ answer))))\r\n\r\n;;; ****************\r\n;;; PROCEDURE BASE35_AS_ODOMETER (fixnum BASE35_NUMBER, fixnum LENGTH)\r\n;;; /* Return a string that represents BASE35_NUMBER in base 35 with odometer digits. */\r\n;;; BASE := 35;\r\n;;; ANSWER := MAKE_STRING( LENGTH );\r\n;;; /* MAKE_STRING returns a garbage string the length of its argument. */\r\n;;; POWER := EXPT( BASE, LENGTH - 1 );\r\n;;; /* EXPT raises its first argument to the power of its second argument. */\r\n;;; TEMP := BASE35_NUMBER;\r\n;;; DOTIMES ( NDX, LENGTH ) {\r\n;;; /* DOTIMES is a special form that iterates its first argument */\r\n;;; /* from zero upward by one for the number of times of its second argument. */\r\n;;; \tFDIGIT := FLOOR( TEMP / POWER );\r\n;;; \t/* FLOOR is the standard mathematical function. */\r\n;;; \tANSWER[ NDX ] = FIXNUM_DIGIT_TO_ODOMETER( FDIGIT );\r\n;;; \tTEMP := TEMP - FDIGIT * POWER;\r\n;;; \tPOWER := POWER / BASE;\r\n;;; \t};\r\n;;; RETURN( ANSWER );\r\n;;; END\r\n\r\n(defun BASE35_AS_ODOMETER (BASE35_NUMBER length)\r\n  (let* ((base 35)\r\n\t (answer (make-string length))\r\n\t (power (expt base (1- length)))\r\n\t (temp BASE35_NUMBER))\r\n    (dotimes (ndx length)\r\n      (let ((fdigit (floor (/ temp power))))\r\n\t(setf (elt answer ndx) (FIXNUM_DIGIT_TO_ODOMETER FDIGIT)\r\n\t      temp (- temp (* fdigit power))\r\n\t      power (/ power base))))\r\n    (values answer)))\r\n\r\n;;; ****************************************************************\r\n;;; Odometer to Fixnum\r\n;;;\r\n\r\n;;; ****************\r\n;;; PROCEDURE ODOMETER_NUMBER_TO_FIXNUM (string ONUMBER)\r\n;;; /* Convert an odometer number, represented as a string, to an unsigned fixnum. */ \r\n;;; COUNT_BELOW := ODOMETER_COUNT_BELOW_LENGTH( LENGTH( ONUMBER ));\r\n;;; ANSWER := COUNT_BELOW + ODOMETER_AS_BASE35( ONUMBER );\r\n;;; RETURN( ANSWER );\r\n;;; END\r\n\r\n(defun ODOMETER_NUMBER_TO_FIXNUM (ONUMBER)\r\n  (let* ((COUNT_BELOW\r\n\t  (ODOMETER_COUNT_BELOW_LENGTH (LENGTH ONUMBER)))\r\n\t (answer\r\n\t  (+ COUNT_BELOW\r\n\t     (ODOMETER_AS_BASE35 ONUMBER))))\r\n    (values answer)))\r\n\r\n;;; ****************************************************************\r\n;;; Fixnum to Odometer\r\n;;;\r\n\r\n;;; ****************\r\n;;; PROCEDURE FIXNUM_TO_ODOMETER_NUMBER (fixnum FNUMBER)\r\n;;; /* Convert an unsigned fixnum to an odometer number, represented as a string. */\r\n;;; NDIGITS := NUMBER_OF_ODOMETER_DIGITS( FNUMBER );\r\n;;; COUNT_BELOW := ODOMETER_COUNT_BELOW_LENGTH( NDIGITS );\r\n;;; ANSWER := BASE35_AS_ODOMETER( (FNUMBER - COUNT_BELOW), NDIGITS );\r\n;;; RETURN( ANSWER );\r\n;;; END\r\n\r\n(defun FIXNUM_TO_ODOMETER_NUMBER (FNUMBER)\r\n  (let* ((ndigits\r\n\t   (NUMBER_OF_ODOMETER_DIGITS FNUMBER))\r\n\t (COUNT_BELOW\r\n\t  (ODOMETER_COUNT_BELOW_LENGTH ndigits))\r\n\t (answer\r\n\t  (BASE35_AS_ODOMETER\r\n\t   (- FNUMBER COUNT_BELOW) ndigits)))\r\n    (values answer)))\r\n\r\n;;; ****************************************************************\r\n;;; Testing\r\n;;;\r\n\r\n(defun test-it (max-length &optional (display-p NIL))\r\n  (let ((base 35)\r\n\t(n-so-far 0))\r\n    (dotimes (i max-length)\r\n      (test-it-at-length (1+ i) n-so-far display-p)\r\n      (setf n-so-far\r\n\t    (+ n-so-far (expt base (1+ i))))))\r\n  (values))\r\n\r\n(defun test-it-at-length (length n-so-far &optional (display-p NIL))\r\n  (let ((base 35)\r\n\t(odometer (make-string length :initial-element #\\1)))\r\n    (dotimes (i (expt base length))\r\n      (let* ((fnumber (+ i n-so-far))\r\n\t     (FIXNUM_TO_ODOMETER\r\n\t      (FIXNUM_TO_ODOMETER_NUMBER fnumber))\r\n\t     (ODOMETER_TO_FIXNUM\r\n\t      (ODOMETER_NUMBER_TO_FIXNUM odometer)))\r\n\t(when display-p\r\n\t  (FORMAT T \"~%F=~D   O2F=~D   O=~S   F2O=~S\"\r\n\t   fnumber ODOMETER_TO_FIXNUM odometer FIXNUM_TO_ODOMETER))\r\n\t(assert (string= odometer FIXNUM_TO_ODOMETER))\r\n\t(assert (= fnumber ODOMETER_TO_FIXNUM))\r\n\t(increment-odometer odometer))))\r\n  (values))\r\n\r\n(defun increment-odometer (odometer)\r\n  (let ((base 35)\r\n\t(length (length odometer)))\r\n    (dotimes (i length)\r\n      (let* ((ndx (- length (1+ i)))\r\n\t     (fdigit (ODOMETER_DIGIT_TO_FIXNUM (elt odometer ndx))))\r\n\t(cond\r\n\t ((< fdigit (1- base))\r\n\t  (setf (elt odometer ndx)\r\n\t\t(FIXNUM_DIGIT_TO_ODOMETER (1+ fdigit)))\r\n\t  ;; N.B. non-local return\r\n\t  (return))\r\n\t (t\r\n\t  (setf (elt odometer ndx)\r\n\t\t(FIXNUM_DIGIT_TO_ODOMETER 0)))))))\r\n  (values))\r\n\r\n;;; ****************************************************************\r\n;;; EOF\r\n;;; ****************************************************************\r\n", "encoding": "ascii"}