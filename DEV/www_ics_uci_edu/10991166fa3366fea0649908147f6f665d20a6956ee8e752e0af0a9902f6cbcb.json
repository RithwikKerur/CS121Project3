{"url": "https://www.ics.uci.edu/~theory/269/180511.html", "content": "<!DOCTYPE html>\n<html>\n<head>\n<title>Theory Seminar, May 11, 2018</title>\n<link rel=\"stylesheet\" href=\"../stylesheet.css\" type=\"text/css\">\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n</head>\n<body>\n<a href=\"/~theory/\"><img src=\"http://www.ics.uci.edu/~theory/logo/CATOC2.jpg\"\nalt=\"Center for Algorithms and Theory of Computation\"></a>\n<h2><a href=\"/~theory/269/\">CS 269S, Spring 2018: Theory Seminar</a><br>\nBren Hall, Room 1423, 1pm</h2>\n<hr />\n<h2>May 11, 2018:</h2>\n<h1> The amortized complexity of non-blocking binary search trees\n</h1>\n<h2>Juan Besa, UCI</h2>\n\n<p>\nWe improve upon an existing non-blocking implementation of a binary search\ntree from single-word compare-and-swap instructions. We show that the\nworst-case amortized step complexity of performing a Find, Insert or Delete\noperation op on the tree is O(h(op)+c(op)) where h(op) is the height of the\ntree at the beginning of op and c(op) is the maximum number of operations\naccessing the tree at any one time during op. This is the first bound on the\ncomplexity of a non-blocking implementation of a search tree.\n\n<p>\nPaper by\nFaith Ellen,\nPanagiota Fatourou,\nJoanna Helga,\nand\nEric Ruppert\n\n</body></html>\n\n", "encoding": "ascii"}