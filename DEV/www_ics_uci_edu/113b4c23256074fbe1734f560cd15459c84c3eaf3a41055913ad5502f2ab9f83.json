{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/tryexcept/tryexcept.txt", "content": "\t\t\t\ttry/except Statements\r\n\r\n\r\nIn this lecture we will examine the last of the statements outlined in the the\r\nlecture on if statements: the try_except_statement (which I sometimes refer to\r\nas try/except). Here is a refresher of what statements were in that group,\r\nwhich form the core of statements in Python. There are not many of them, but\r\nwhen used together we can write scripts that solve complicated tasks.\r\n\r\n  statement <= assignment_statement |\r\n               import_statement     |\r\n\t       function_call\t    |\r\n\t       method_call\t    |\r\n\t       if_statement         |\r\n\t       for_statement\t    |\r\n\t       while_statement\t    |\r\n\t       break_statement\t    |\r\n\t       try_except_statement |\r\n               pass_statement              (see end of this lecture)\r\n\r\nThere are few more statements we will learn (notably return, raise, and assert),\r\nwhich  are important, but are used in very specific contexts and simple to\r\nunderstand (once we get into those contexts: all next week).\r\n\r\nExceptions (raising and handling them) is a wide and deep topic. We will take a\r\nspiral approach to learning about exceptions, repeatedly learning more material\r\nabout exceptions throughout the quarter (and in ICS-32 and ICS-33). In this\r\nlecture we will focus on how the try_except statement leads to simple handling\r\nof exceptions that are raised by the Python operators or functions that we use.\r\n\r\nThe syntactic complexity of the try_except_statement (which I don't show all of\r\nhere) is large (and the semantic complexity will match): as we need to\r\nunderstand more, we will learn more: the spiral approach. So, what I'm telling\r\nyou is the truth, nothing but the truth, but not the whole truth. Here is the\r\nEBNF\r\n\r\n  except_clause        <= except [expression]:\r\n                              block-except\r\n\r\n  try_except_statement <= try:\r\n                              block-try\r\n                          except_clause\r\n                          {except_clause}\r\n                          [else:\r\n                              block-else]\r\n                          [finally:\r\n                              block-finally]\r\n\r\nThere is a syntax constraint that every try_except_statement: must be include\r\neither (a) at least one except_clause or (b) a finally: block-finally (of course\r\nboth can be included). The else: block-else it totally optional. The expression\r\nin except_clause can be omitted, but is typically just the name of a\r\nclass that represents an exception (see Section 4.5.1 for a list of exception\r\nnames defined in the builtins module: there are dozens; I have put them at the\r\nend of this lecture as well ). Later, when we cover tuples we will learn that\r\nexpression can also be a tuple of exception names, and how the except_clause\r\nhandle such tuples then. \r\n\r\nGiven all this syntax, the semantics is long to state but not too difficult to\r\nunderstand (there is about one rule for each option/repetition in the EBNF).\r\nStill, it will take a bit of time (and study and use, in this lecture and\r\nbeyond) to understand this language feature and become comfortable using it.\r\nLook at the EBNF when reading these semantics; we will re-examing and illustrate\r\nmore concretely the semantics in some actual examples below.\r\n\r\n  (1) Start executing block-try (which, by the semantics of blocks,\r\n      sequentially executes every statement in the block).\r\n\r\n      (1a) If no statement in block-try raises an exception, after the last\r\n             statement is executed....\r\n\r\n           (1a1) If the else: block-else option is included, execute block-else\r\n                 (like else: in for/while loops, it is executed by normal\r\n                  termination of statement (not executing break in loops, not\r\n                  raising an exception in try/except)\r\n\r\n           (1b2) If the finally: block-finally option is included, execute\r\n                   block-finally\r\n\r\n           (1b3) The try_except statement terminates\r\n\r\n      (1b) If some statement raises an exception, abandon executing any more\r\n             statements in the block-try (don't execute any more there)\r\n\r\n           (1b1) If the exception is named in any except_clause, find the first\r\n                   one that it appears in and execute its matching\r\n                   block-except; if it appears in a later except_clause, it\r\n                   will be ignored there.\r\n\r\n                 If an except_clause is just except: (no expression)\r\n    \t           execute its block-except\r\n\r\n                 (1b1a) If the finally: block-finally option is included,\r\n\t  \t          execute block-finally\r\n\r\n                 (1b1b) The try_except statement terminates\r\n  \r\n           (1b2) If the exception is NOT named in any except_clause\r\n               \r\n                 (1b2a) If the finally: block-finally option is included,\r\n\t  \t          execute block-finally\r\n\r\n                 (1b2b) The try_except statement terminates, but ....\r\n\r\n                        Python prints a trace of the exception (showing the\r\n                          execution history of the statements in the script)\r\n                          and terminates the program\r\n  \r\nTo summarize, a try tries to execute block-try; if it raises an exception,\r\nPython handles it by executing some block-except. else: block-else, if present,\r\nis executed only if block-try raises no exceptions; finally: block-finally, if\r\npresent, is always executed before terminating the try_except_statement.\r\n\r\n  We are not going to learn what happens if an exception is raised when Python\r\n  is executing statements in block-except/block-else/block-finally; well, not\r\n  now, but we learn about this possibility later in the quarter. Typically the\r\n  statements in these blocks are much simpler (and less prone to exceptions)\r\n  than the statements in block-try.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nA Trivial Script that we can use to show all aspects of the try_except_statement\r\n\r\nLet's start with a trivial example in a script that does nothing other than\r\nillustrate the semantics of try/except. It would be an excellent idea to use\r\nsingle-stepping with the Debug Perspective on this script to see, sequentially,\r\nhow Python executes it. Note that every possible part of a try_except_statement\r\nappears in the example below; in most exception handling code that we write (see\r\nthe real examples later), we can omit some of this parts (e.g., maybe else:...\r\nand/or finally: ...)\r\n\r\ntry:\r\n    print('block-try start')\r\n    #print(a_name_that_is_not_bound_to_anything) # raises NameError\r\n    print('block-try stop')\r\nexcept NameError:\r\n    print('block-except')\r\nelse:\r\n    print('block-else')\r\nfinally:\r\n    print('block-finally')\r\n\r\nWhen Python executes this script as is (with #prints...) it produces the\r\nfollowing results\r\n\r\n  block-try start\r\n  block-try stop\r\n  block-else\r\n  block-finally\r\n\r\nSo, both print statements in the block-try work: neither raises an exception.\r\nThere is an else: block-else option, so it is executed (only when no exception\r\nis raised). There is a finally: block-finally option, so it is executed\r\n(always, whether or not an exception is raised). Then, the try_except_statement\r\nterminates.\r\n\r\nNow, what would happen if we uncommented the line that tries to print a name\r\nthat is not bound to a value, causing Python to raise a NameError? When Python\r\nexecutes that variant of the script, it produces the following results\r\n\r\nblock-try start\r\nblock-except\r\nblock-finally\r\n\r\nSo, the first print statement works, but the second raises a NameError\r\nexception (so Python abandons execution of all later statements in block-try).\r\nPython finds an except_clause with this exception name, and executes its block,\r\nwhich is a print statement. There is a finally: block-finally option, so it is\r\nexecuted (always, whether or not an exception is raised). Then, the\r\ntry_except_statement terminates.\r\n\r\nIf we had omitted the name NameError, this code would work the same: an\r\n\"except\" without a name handles any exception name.\r\n\r\nAnd now we try one more variant. Change the name in the except_clause to a\r\nIndexError: a different exception (not the one raised, therefore the one raised\r\nis not handled by this try/except). Now rerun the script (still with the print\r\nstatement raising NameError). It produces the following results.\r\n\r\nblock-try start\r\nblock-finally\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\experiment\\tryexcepttest.py\", line 3, in <module>\r\n    print(a_name_that_is_not_bound_to_anything) # raises NameError\r\nNameError: name 'a_name_that_is_not_bound_to_anything' is not defined\r\n\r\n(actually sometimes the order of the information printed gets jumbled; don't\r\n worry and try to reconstuct the order of events by looking at the code).\r\n\r\nAgain, the first print statement works, but the second raises a NameError\r\nexception (so Python abandons execution of all alter statements in block-try).\r\nPython does not find an except_clause with this exception name. There is a \r\nfinally: block-finally option, so it is executed (always). Then, the\r\ntry_except_statement terminates. Python prints a trace of the exception\r\n(showing the execution history of the statements: here line 3 raised the\r\nNameError exception) in the script and terminates the program\r\n  \r\nSo, with this code we can test all sorts of variants of try/except. If you have\r\nquestions, try to alter this code and execute it to answer them.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nA real problem solved by try/except\r\n\r\nNow let's move on to a real example of a problem that is solved by try/except.\r\nIt illustrates how the kind of code in the prompt.for_int function works. If\r\nyou look at this code in the prompt module you will likely not understand it\r\n(because it is built with components that we haven't  learned yet) but we can\r\nstudy one carefully chosen aspect of its code: how Python rejects non-integer\r\nvalues.\r\n\r\nThe purpose of the code below (normally put in a function) is to prompt the\r\nuser to enter a string (using the input function available in Python, although\r\nI prefer using the prompt.for_string function in my library); if the string\r\nentered can't be converted to an int, then we must keep prompting the user until\r\nhe/she enters a string that represents a legal integer. Because we don't know\r\nhow many times we must prompt the user (once, twice, ...) before he/she enters\r\na legal integer, this is a indefinite loop, so we write a while True: loop\r\nthat contains a try/except). Here is the code, followed by an analysis of how\r\nit works for legal and illegal inputs.\r\n\r\nwhile True:\r\n    try:\r\n        string_rep = input('Enter int: ')\r\n        answer = int(string_rep)\t   # int(...) may raise ValueError\r\n        break\r\n    except ValueError:\r\n        print('Entry error (',string_rep,') is not a legal int')\r\n\r\nprint(1 + answer) # use answer: it is guaranteed to be bound to an int object\r\n\r\nHow did I know to put ValueError in the except_clause? The first time I wrote\r\nthis code I had to find out what exception was raised when the user enters an\r\nstring that cannot be converted to an integer. Here is how I did it: I started\r\nthe Python interpreter and entered int('a') and saw it raise the ValueError\r\nin a traceback. Here is an example of Python running the script above, where I\r\nenter a string that can be converted to an integer.\r\n\r\n  Enter int: 5\r\n  6\r\n\r\nWhat happens in the code above for this example: Python starts the while True:\r\nloop and executes its block; its block is a single try/except, so it executes\r\nthe block after try. The first statement is Python's prompt to the user, and\r\nI entered 5 (which input returns as the string '5'); the second statement calls\r\nthe int conversion function (successful for '5') which returns a reference to\r\nan int object with the value 5, which is bound to the name answer. The third\r\nstatement is a break, which terminates the loop so Python next does the print\r\nfunction call after the loop, which prints a value 1 bigger than answer. Why is\r\nthis break naked (not inside an if)? Why is it not always executed? See the\r\ndescription below, for when the user enters \"bad\" information.\r\n\r\nHere is an example of Python running the script, where I enter a two \"bad\"\r\nstrings (they cannot be converted to integers) before entering a good one.\r\n\r\nEnter int: x\r\nEntry error ( x ) is not a legal int\r\nEnter int: 1,024\r\nEntry error ( 1,024 ) is not a legal int\r\nEnter int: 1024\r\n1025\r\n\r\nWhat happens in the code above for this example: Python starts the while True:\r\nloop and excecutes its block; its block is a single try/except, so it executes\r\nthe block after try. The first statement is Python's prompt to the user, and\r\nI enter x (which input returns as the string 'x'); the second statement calls\r\nthe int conversion function, but it is unsuccessful for 'x' and raises the\r\nValueError exception. So Python never gets to execute the break statement\r\nbecause it stops executing the block-try to handle the exception. The clause\r\nexcept ValueError: ... handles this exception by printing an error message. Now\r\nthe try/except is finished executing, which means the block in the while True is\r\nfinished executing, so the while loop takes control and executes its block (the\r\ntry/except) again.\r\n\r\nNow Python executes the try/except again, so it executes the block after try.\r\nThe first statement is Python's prompt to the user, and I enter 1,024 (which\r\ninput returns as the string '1,024'); the second statement calls the int\r\nconversion function, but it is unsuccessful for '1,024' and again raises the\r\nValueError exception. Again, Python never gets to the break statement. The\r\nexcept ValueError: clause handles this exception by printing an error message.\r\nNow the try/except is finished executing, which means the block in the while\r\nTrue is finished executing, so the while loop executes its block (the\r\ntry/except) again.\r\n\r\nNow Python executes the try/except again, so it executes the block after try.\r\nThe first statement is Python's prompt to the user, and I enter 1024 (which\r\ninput returns as the string '1024'); the second statement calls the int\r\nconversion function (successful for '1024') which returns a reference to an\r\nint object with the value 1024, which is bound to the name answer. The third\r\nstatement is a break, which terminates the loop so Python next does the print\r\nfunction call after the loop, which prints a value 1 bigger than answer.\r\n\r\nIn summary the while True: loop repeatedly prompts the user as many times as\r\nnecessary. For each non-legal integer entered, calling the int(...) function\r\nraises an exception, which causes the break statement to NOT be executed (which\r\nkeeps Python in the loop). Finally, when the int(...) does not raise an\r\nexception, the break statement is executed and the loop terminates, and the\r\nname answer (now referring to an integer object) can be used in later code.\r\n\r\nOf course, you will never need to write this code in your programs because the\r\nprompt.for_int method has code like this in it! But now you know a bit about\r\nthe magic that is inside prompt.for_int.\r\n\r\nThis is an example of a while that loops until there is no exception. The loop\r\n(and try/except) discussed below has a different structure: its while loops\r\nuntil there is an exception. We classify the first as exception continues loop\r\nand the second as exception terminates loop.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nExample of a for_statement translated into a while_statement\r\n\r\nIn this section we are going to get some insight into, but not a complete\r\nunderstanding of, how Python translates a for_statement into a while_statement\r\nalong with a try_except_statement (and the special StopIteration exception). To\r\nsimplify this discussion and make it clearer, we are going to start by using\r\nthe simplest form of the for loop, discarding the else: block-else.\r\n\r\n  for index in iterable:\r\n      block-body\r\n\r\nPython translates this for loop into the following code, which we will see\r\ndoes what we know the for loop to do.\r\n\r\n  hidden_name = iter(iterable)\r\n  while True:\r\n      try:\r\n          index = next(hidden_name)\r\n          block-body\r\n      except StopIteration:\r\n          break\r\n\r\n\r\nThe function iter(...) takes an iterable (so far the iterables that we have\r\nstudieds are strings, ranges/iranges, and opens -for iterating over lines in\r\nfiles) and creates an object that will produce all the values, one at a time\r\nwhen the next(...) function is called. The iter(...) and next(...) functions\r\nwork a bit magically (for our present understanding of them), but we will study\r\ntheir details in ICS-33.\r\n\r\nYou can experiment a bit with the iter/next functions by executing the\r\nfollowing code\r\n\r\ns = 'abc'\r\ni = iter(s)\r\nprint(1,next(i))\r\nprint(2,next(i))\r\nprint(3,next(i))\r\nprint(4,next(i))\r\n\r\nIt prints\r\n  1 a\r\n  2 b\r\n  3 c\r\nand then prints the following (because next(...) raises the StopIteration\r\nexception.\r\n\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\zexperiment\\test.py\", line 6, in <module>\r\n    print(4,next(i))\r\nStopIteration\r\n\r\nThe object that we can call next on is bound to the name hidden_name (because\r\nPython creates a special name for us that we cannot refer to); this code calls\r\nthe next(...) function on hidden_name: each time it is called, next returns the\r\nnext value in the iterable. When hidden_name has no more values to produce,\r\ncalling next on it raises a special exception named StopIteration, which the\r\ntry/except handles: its block breaks out of the while loop (so the loop is then\r\nterminated).\r\n\r\nFor example, if itererable were 'abc' then the first time next(hidden_name)\r\nwas called it would return 'a'; the second time 'b'; the third time 'c'; the\r\nfourth time next(hidden_name) was called it would raise the StopIteration\r\nexception. Note this exception name does not end in Error, because it does\r\nnot really signal an error, just the end of the definite iteration. So\r\nexceptions include more than just errors.\r\n\r\nStudy this equivalence carefully. Python executes a while True: loop, which has\r\na try/except statement inside (just like in the example in the previous\r\nsection), but now the break is in the except StopIteration: clause. Each\r\niteration of the loop binds the result produced by next(hidden_name) to index\r\nand then executes block-body.\r\n\r\nThis rebinding/block-body execution continues until calling next(...) raises the\r\nStopIteration exception, which is handled in the except StopIteration: clause\r\nby executing a break statement and thus terminating the loop\r\n\r\nHere is a concrete example, the simple for loop\r\n\r\nfor c in 'abc'\r\n    print(c)\r\n\r\nis translated into\r\n\r\nhidden_name = iter('abc')\r\nwhile True:\r\n    try:\r\n        c = next(hidden_name)\r\n        print(c)\r\n    except StopIteration:\r\n        break\r\n\r\nCopy this code into a Python module and executed it.\r\n\r\nSo the first time through the loop, next(...) returns 'a' which is bound to c\r\nand then printed; the second time through the loop, next(...) returns 'b' which\r\nis bound to c and then printed; the third time through the loop, next(...)\r\nreturns 'c' which is bound to c and then printed; the fourth time through the\r\nloop next(...) raises the StopIteration exception, which is caught by the\r\nexception StopIteration: clause, which executes a block of just one statement\r\n-the break statement- which terminates the loop. So both loops print the three\r\nstrings 'a', 'b', 'c'.\r\n\r\nSo this while/try/except combination executes equivalently to your knowledge of\r\nhow the for loop executes.\r\n\r\nTry executing both scripts in Eclipse and observe they always produce\r\nequivalent results (even with ranges/iranges and opens). Use the Debug\r\nperspective to explore how this happens. Or, try the following script, which\r\nexplains its execution with extra print statements.\r\n\r\nhidden_name = iter('abc')\r\nwhile True:\r\n    try:\r\n        c = next(hidden_name)\r\n        print('next returns',c)\r\n        print(c)\r\n    except StopIteration:\r\n        print('StopIteration exception raised')\r\n        break\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTwo loose ends\r\n\r\n1) Recall the EBNF for except_clause\r\n\r\n  except_clause <= except [expression]:\r\n                       block-except\r\n\r\nWe have discussed what it means to discard expression: in this case the except:\r\nclause handles ALL raised exceptions (we don't have to name them). This\r\nfeature is powerful; sometimes too powerful and must be used carefully.\r\n\r\n2) The full syntax for the for_statement is\r\n\r\n  for index in iterable:\r\n      block-body\r\n  [else:\r\n      block-else]\r\n\r\nwhich Python translates to the following code\r\n\r\n  hidden_name = iter(iterable)\r\n  while True:\r\n      try:\r\n          indexes = next(hidden_name)\r\n          block-body\r\n      except StopIteration:\r\n          pass\t\t# see comment belows\r\n          [block-else]\r\n\r\nPython defines pass_statement <= pass (where pass is a keyword). We should add\r\npass_statement to the list at the top of all statements in Python. We can use\r\npass wherever we need a statement (in the except StopIteration: clause, we must\r\nhave at least ONE STATEMENT IN ITS BLOCK, and that statement is pass if the\r\nelse: option is discarded. Semantically the pass statement does nothing (so\r\ntechnically it is Python's simplest statement). It appears above as a\r\nplaceholder to ensure the block has at least one statement.\r\n\r\nThink about what happens, whether or not block-body executes a break: if it\r\ndoes, the loop terminates before StopIteration is raised/handled, so\r\n[block-else] is not executed (which is correct, because the loop did not\r\nterminate normally).\r\n\r\nIn conclusion, we have now seen how to anticpate exceptions being raised and how\r\nto use try/except to handle them. try/except won't come up much soon, but we\r\ncovered it here, along with the if/for/while/break/pass statements, because it\r\nis one of the major statements (control structures) in Python. We will continue\r\nto learn more about exceptions, and start using them more frequently, soon and\r\nall the way through the end of ICS-33.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nException names automatically imported from the builtins class\r\n\r\nArithmeticError        ImportError               ReferenceError  UnicodeEncodeError\r\nAssertionError         ImportWarning\t\t ResourceWarning UnicodeError\r\nAttributeError         IndentationError\t\t RuntimeError    UnicodeTranslateError\r\nBufferError            IndexError \t\t RuntimeWarning\t UnicodeWarning\r\nBytesWarning           KeyError \t\t StopIteration \t UserWarning\r\nDeprecationWarning     KeyboardInterrupt \t SyntaxError \t ValueError\r\nEOFError               LookupError \t\t SyntaxWarning \t Warning\r\nEnvironmentError       MemoryError \t\t SystemError \t WindowsError\r\nException              NameError \t\t SystemExit \t ZeroDivisionError\r\nFloatingPointError     NotImplementedError \t TabError\r\nExceptionFutureWarning OSError                   TypeError\r\nGeneratorExit          OverflowError             UnboundLocalError\r\nIOError                PendingDeprecationWarning UnicodeDecodeError\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblem:\r\n\r\n1) Rewrite the prompt code so that if the user failed to enter an legal value\r\nafter 5 times, it would provilde some polite feedback and assume answer to be\r\n0 (or terminate the program)? Hint: the loop should count how many times it\r\nexecutes and terminate (specially) if the count reaches 5 and the user does\r\nnot successfully enter a legal value.\r\n", "encoding": "ascii"}