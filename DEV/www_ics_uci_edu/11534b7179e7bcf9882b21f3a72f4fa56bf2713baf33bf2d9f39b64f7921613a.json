{"url": "https://www.ics.uci.edu/~ejw/authoring/orlando/minutes.html", "content": "<HTML>\n<HEAD>\n<TITLE>WebDAV WG Minutes, Orlando, IETF-43, Dec. 10, 1998</TITLE>\n</HEAD>\n<BODY>\n<H2 ALIGN=CENTER>WEBDAV WORKING GROUP</H2>\n\n<h3 align=center>Meeting Minutes<BR>\nIETF-43, Orlando, Florida<BR>\nDecember 10, 1998</h3>\n\n\n<P>The WebDAV WG met on Thursday, December 10, 1998, from 1300-1500, with\n42 people in attendance.  The meeting was chaired by Jim Whitehead,\nand meeting notes were recorded by Rohit Khare.  Final minutes were\nprepared by Jim Whitehead.</P>\n\n<P>Three main topics were discussed: advanced collections goals and\nprotocol (&lt;draft-ietf-webdav-collection-protocol-02&gt; and\n&lt;draft-ietf-webdav-collection-reqts-03&gt;), versioning\n(&lt;draft-ietf-webdav-versioning-00&gt;), and issues from the distributed\nauthoring protocol (&lt;draft-ietf-webdav-protocol-10&gt;).  There was a\nbrief discussion at the end of the meeting on additional properties\n(draft was not submitted in time for the meeting). Prior to the main\nmeeting, two informal breakout sessions were held on the topics of\nAccess Control and Advanced Collections.</P>\n\n<P>Jim Whitehead began the meeting with an agenda overview.  He also\nannounced that the WebDAV Distributed Authoring protocol specification\nwas approved as a Proposed Standard by the IESG on November 25, 1998.</P>\n\n<B>ADVANCED COLLECTIONS:</B>\n\n<P>Judith Slein led discussion on Advanced Collections, discussing the\nissues:\n<UL>\n<LI>What mechanism should be used to disable the referential capabilities of\nreference resources\n<LI>Optional backpointers\n<LI>Should it be possible to hide the target of a direct reference\n<LI>Enforcement of referential integrity\n</UL>\n\n<P>Judith announced that Jim Davis's sandbox.xerox.com test server on\n8080 has redirect and direct references working according to the\ncurrent protocol specification,\n<draft-ietf-webdav-collection-protocol-02>.\n\n<P><i>What mechanism should be used to disable the referential capabilities of reference resources:</i>\n\n<P>Judith described a proposal from the advanced collections brekout\nsession to have a header, tentatively called \"No-Passthrough\", which\nwould disable the passing-through of method invocations to the target\nof a direct reference, and the issuance of a 302 for a redirect\nreference.\n\n<P>There was discussion on what happens if you send a No-Passthrough\nheader to a resource that's a hardcoded redirect - a 302 from the\nserver/CGI-script; rather than being a 'redirected reference'. In this\ncase, a client might find it difficult to disambiguate between the\nhardcoded 302, and a redirect reference.  Due to this, a client might\nexpect the hardcoded 302 to respect the semantics of the No-Passthough\nheader, operating on the false idea that the hardcoded 302 was\nactually a redirect resource.  The hardcoded 302 (especially those\nfrom a downlevel CGI script) would very likely not respect the\nsemantics of the No-Passthrough header.  One possible solution is to\nuse the proposed Mandatory header (the Mandatory header lists other\nheaders which MUST be understood, or the method invocation fails).  It\nwas unclear how this would address the downlevel CGI script case,\nwhich would presumably not understand the Mandatory header either.  It\nwas noted that a client can tell whether the 302 redirect it receives\nis a 'normal' (hardcoded) 302, or a 302 from a redirect resource,\nsince the 302 response message from a redirect resource must contain\nthe Ref-Type header.  This allows a WebDAV-aware client to know what\nkind of resource is causing the 302 response.\n\n<P>It was noted that the proposed No-Passthrough header needs to be\nclear about the effect of the No-Passthrough header on non-redirect\nreferences.\n\n<P>A working group member noted that we should be more precise about reference vs resource: in some sense, every URI is a redirect to an actual resource.  \n\n<P>This issue will be taken to the list for further discussion.\n\n<P><I>Optional backpointers:</i>\n\n<P>Several working group members had problems with the optional\nbackpointers proposal.  One noted that if clients can't depend on the\nbackpointer property being there, and even if it is there, users can't\nbe sure what it means since there is no guarantee it contains all\nbackpointer references (since some references to this resource might\nbe located on other servers, hence outside the realm of control of the\nserver managing the resource which has the backpointer property).\nHence, this is not the business of DAV or a DAV client; this is what\n(server-specific) live properties are for.\n\n<P>It was noted that if backpointers are an arbitrary property, there\nwon't be as much interoperabilty.  This was countered by noting there\nisn't any interoperability in this scenario to begin with, due to the\nfact the property might not be present, and might not contain all\npossible backpointers.\n\n<P>One working group member suggested that the original rationale for\nhaving backpointers was to use them as a mechanism for navigating to\nthe parents of a resource, especially when the containing collection\nincludes members which are not lexically/syntactically related to the\nURL of the collection.  However, working group members disagreed with\nthis.\n\n<P>There was a suggestion that if anyone is going to provide\nbackpointer capability, it is important that we reserve a property\nname which <i>will</i> be used for this, or preserve a name which is\nreserved for future use.  There no support for this idea.  As another\nworking group member noted, there is no point to having standardized\nproperties in this case. If the property is optional and\nserver-specific, it can be interoperable and it can be handled in a\nseparate draft at later time and go to Proposed separately.\n\n<P>There was another suggestion to establish some principles about\nwhat are the responsibilities of the client, the server, and the\nrepository.\n\n<P>Discussion of optional backpointers will be taken to the list. \n\n<P><I>Should it be possible to hide the target of a direct reference:</I>\n\n<P>There was brief discussion on whether it should be possible to hide\nthe target of a direct reference. One working group member seconded\nthe idea that this be handled as a security right, and not handled in\nthe advanced collections protocol.\n\n<P><I>Enforcement of referential integrity:</I>\n\n<P>Discussion on referential integrity began by noting the following\nscenario.  At creation time, it should be possible to suspend\nreferential integrity. This would allow you to create a template\ncollection of pointers and realize the contents later.\n\n<P>One working group member moved to strike all mention and discussion\nof referential integrity.  However, another working group member noted\nthat their configuration management product does support strong and\nweak references, and they will expose it on our own if not\nstandardized.  They would like to have interoperabilty with other\nconfiguration management vendors. Another member noted that in their\ndocument management system, they initially tried to enforce integrity\nat the front end, but now the just warn the user, and do not provide\nany back-end integrity.\n\n<P>Judith stated that she will start weekly phone calls on\nAdv. Collections to bring these issues to resolution.  Jim, as chair,\nstated that these discussions have been proceeding for too long and\nhe's looking for progress or hatchets.\n\n<P><B>VERSIONING:</B>\n\n<P>Geoff Clemm led discussion on versioning.  He announced that a\nversioning goals document will appear soon. During the meeting these\nissues were discussed:\n\n<UL>\n<LI>Data model for a versioned resource\n<LI>Are checked-in resources mutable or immutable\n<LI>Semantics of checkout\n<LI>Use of lock as a mechanism for checkout\n</UL>\n\n<P><I>Data model for a versioned resource:</I>\n\n<P>Geoff presented from hand-written slides.  His presentation was on\nthe data model of a versioned resource, and differed slightly from the\ndata model discussed at the versioning and variant authoring design\nteam meeting held a week before the IETF meeting.\n\n<P>Geoff's presentation, paraphrased in sentences is:\n\n<P>There is a resource under version control. A versioned resource is\na set of (or potentially a collection of) working resources. A working\nresource supports the CHECKOUT operation, which returns a new working\nresource.  A working resource supports a LABEL, which is a reference\nto another working resource, which may take the value of \"stable\",\n\"current\", \"mine\", etc.  A working resource also supports the CHECKIN\noperation, which creates an immutable revision. A configuration has a\nselection rule (perhaps an XML description) to describe a\nconfiguration of working resources.\n\n<P>Working group discussion ensued.\n\n<P>A concern was raised about server limits.  Does the server have to\nprovide storage space for lots of client checkouts?  What are the\nrisks associated with rogue clients - could versioning be used as a\nform of denial of service attack?  Geoff stated that there is an\nimplicit put/creation of working resources. But, the working resource\ndoes not have to live on the same server - it could live in the\nclient until checked in.\n\n<P><I>Are checked-in resources mutable or immutable:</I>\n\n<P>There was some discussion on terminology. One member asked about\nthe difference between a working resource, revisions, and resources.\nAnswer: there is a set of working resources associated to every\nversioned resource.  Mutability is the base case; immutable checked-in\nrevisions are layered on top.  A revision is an immutable working\nresource. Checking out a working resource to create a new working\nresource takes a snapshot of the contents.\n\n<P>A concern was raised with this approach.  The advantage of thinking\nof revisions and revisions-which-can-be-thawed (the\nrevisions-which-can-be-thawed approach was discussed at the design\nteam meeting - in this approach, a checked-in resource may be edited\nif it supports the THAW method, and the client invokes THAW on the\nchecked-in resource) is that a versioning client would do a checkout,\nperform their edits, then checkin.  There is a tradeoff between client\nand server complexity.  Having resources be immutable by default, with\na thaw operation used to edit checked-in resources, would allow a\nclient to use the same interaction style for all versioned resources\n(checkout, edit, checkin); now, it would need to do some repository\ndiscovery to see whether it needs to perform a checkin operation.  It\nwas noted that if you only have mutabilty, the client can employ a\ncheckout-only protocol.  Another member noted that they have\nscalability concerns - for their system, a checkout is a mutex\noperation, and no one else can branch or checkin from there.\n\n<P><I>Use of lock as a mechanism for checkout:</I>\n\n<P>There was a discussion on use of the LOCK method for performing\ncheckout/checkin capability, perhaps with a versioning lock.\nArguments in favor of this approach are the ability to reuse an\nexisting method, rather than creating new methods, which is asserted\nto be more simple for clients to support, especially clients which\nunderstand WebDAV, but do not understand the versioning\nextensions. There was concern that we are not accomodating the\nsimplest kinds of clients.  It was noted that it is an explicit goal\nof the versioning design team to accomodate \"automatic versioning\", or\nversioning for HTTP/1.1 or WebDAV aware, but versioning unaware\nclients.\n\n<P>The following locking capabilities are needed:\n<OL>\n<LI>Locking a versioned resource as a whole. \n<LI>Locking a particular working resource.\n<LI>Locking an entire branch (for branch-based CM)\n</OL>\n\n<P>Arguments against using LOCK for checkout and checkin operations:\n<OL>\n<LI>Separation of concerns: the protocol is more simple by leaving locking alone.\n<LI>Locking is optional and hence cannot be depended upon to be present.\n<LI>When the design team explored using lock, the resulting protocol was complex, and added a lot of new headers. \n<LI>The lock approach does not scale up to handling configuration management. \n<LI>If all you want is temporary ability to write-protect, lock it; if you\nwant it PERMANENTLY write protected, another operation needs to be\nused.\n</OL>\n\n<P>One working group member noted that there are certain versioning\nclients that would be very displeased if revisions were\nmutable. However, they suspect that most clients wouldn't care, and\nwould prefer the freeze-thaw approach vs. checkin/checkout approach.\n\n<P>Another member wanted a clarification of mutable\nvs. immutable. They wondered whether immutable means the bit-pattern\nis fixed for all time, or that administrators still have root-like\npriviliges.  The sense of the working group was that they mean the\nformer (bit pattern is fixed for all time). Clients must be able to\ndepend on caching and repeatability of configurations.\n\n<P>Another working group member noted that HTTP has strong and weak\ne-tags (bit-by-bit equality or usable-equivalent, respectively). It\nwould make some sense to support these semantics in the web authoring\nprotocol.\n\n<P><B>ISSUES FROM LIST DISCUSSION:</B>\n\n<P>Jim Whitehead next led discussion on issues from the discussion\nlist.  Issues discussed were:\n\n<UL>\n<LI>Issues for revising the document going to Draft Standard\n<LI>Disambiguating between URI and URL \n<LI>Storing attributes submitted in XML properties\n<LI>Namespace consistency\n</UL>\n\n<P><I>Issues for revising the document going to Draft Standard:</I>\n\n<P>One working group member asked for formal interoperabilty testing\nand continued tuning of the drafts as they progress from Proposed to\nDraft Standard. Jim Whitehead stated that he is working on an HTTP\nWG-style issues list, and sees this as his responsibilty as chair.\n\n<P>Jim also suggested that, based on email he has received, a mailing\nlist specifically for implementors seems to be a good idea.  Working\ngroup members disagreed: in other groups, it's been strongly suggested\nthat reports from implementors should be kept on the main list.\nImplementors will be encouraged to submit their interoperability\nreports to the main list.\n\n<P>Another working group member suggested that the WebDAV working\ngroup should develop a canonical test suite.  There was a lot of\ndisagreement - the IETF does not perform branding. There was a\nsuggestion to spin out the branding to another organization.\n\n<P>Jim Whitehead stated that he is in the planning stages for an\ninteroperability event in Feb/Mar 99.\n\n<P>Another working group member noted that client testing has its own\nspecial set of concerns, and can be more difficult than server\ntesting.  Client testing takes lots of instrumentation, and may\nintroduce bugs into the client.  The HTTP model worked well, using the\nbakeoff model with feature-by-feature pairwise testing.  Furthermore,\nit is an IETF requirement to perform feature-by-feature tracking to\nadvance to Draft Standard.\n\n<P><I>Disambiguating between URI and URL:</I>\n\n<P>It is believed that draft-ietf-webdav-protocol-10 now correctly\ndisambiguates between URI and URL, and uses them correctly.  Larry\nMasinter noted that if you could find an implementation detail which\nactually disambiguates URI vs URL, he would be very surprised indeed.\n\n<P><I>Storing attributes submitted in XML properties:</I>\n\n<P>The specification is currently silent on the topic on what a server is\nrequired to do with XML attributes submitted as part of a PROPPATCH\n\"add\" request.  One working group member expressed quite strongly that\nhe feels the specification IS clear, that any XML element - which\nincludes attributes, must be stored.  Yaron Goland stated that the\nspec was intended to be silent, as a compromise.  Another member\nargued for storing the entire element, especially since there <I>are</I>\nlegitimate uses of XML attributes.  However, some repositories would\nhave to be changed to accomodate storage of XML attributes.  Yaron\nGoland stated that WebDAV uses XML as a transport format, not for its\nobject model.  The use of attributes was not required.  Another member\nnoted that we should not define our own variant of XML for use in\nproperties.\n\n<P>This issue will be taken to the list for more discussion.\n\n<P><I>Namespace consistency:</I>\n\n<P>One member noted that it is hard, on the face of it, to identify\nthe benefits of the namespace consistency requirements in\ndraft-ietf-webdav-protocol-10. The server has to work harder; what\nefficiencies do clients rely on?  Others noted that without\nconsistency, our collection semantics fail.  This was rebutted: how\ndoes <I>that</I> help? What is the utility of requiring namespace\nconsistency of collections? It was noted that some rationale was\nprovided on the list.\n\n<P>This discussion is being taken to the list.\n\n<P><B>COLLECTION PROPERTIES:</B>\n\n<P>Lisa Lippert led a very brief discussion on a proposal that was not\nsubmitted as an Internet-Draft before the Orlando IETF submission\ndeadline.\n\n<P>The proposal is to have a set of optional properties on collections,\nthese properties being:\n<BR>\n<BR>\nhassubs / nosubs  - Does the collection have collections as children?<BR>\nchildcount - The number of members of the collection<BR>\nreserved<BR>\nishidden - Is the resource hidden (like a \".\" file in Unix)<BR>\nid<BR>\nvisiblecount - The number of visible members<BR>\ndefaultdocument<BR>\nisfolder<BR>\nisstructureddocument - The collection is modeling a compound document<BR>\nobjectcount<BR>\n\n<P>There was some concern over whether these properties were already\nimplemented.  The specter of \"infinite implementation complexity\" was\nraised.\n\n<P>One member raised the issue of having an IANA registry of properties.  \n\n<P>*** Meeting Adjourned ***\n\n</BODY>\n</HTML>", "encoding": "ascii"}