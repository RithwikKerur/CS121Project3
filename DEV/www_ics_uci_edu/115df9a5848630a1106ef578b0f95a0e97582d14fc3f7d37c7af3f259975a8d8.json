{"url": "https://www.ics.uci.edu/~mguindan/code/BDP_final_rcode.r", "content": "### R functions for\r\n### A Bayesian Discovery Procedure\r\n### by Guindani, Muller, Zhang\r\n\r\nlibrary(MCMCpack)\r\nlibrary(mvtnorm)\r\nlibrary(Matrix)\r\n\r\n\r\n## MCMC function\r\n## for the analysis in section 5.2\r\n\r\ncDPODP <-  function(y, B=B, p0=0.5, up.mcmc=T, nu=1,  sigma=1, tau=1, alpha.sig=1, beta.sig=1, alpha.tau=1, beta.tau=1, dbg=1)\r\n{\r\n  ## y -- data (z scores)\r\n  ## B -- number of iterations\r\n  ## p0 -- prior probability of the null\r\n  ## dbg -- debug (yes/no)\r\n  ## up.mcmc=T --  mcmc update of sigma and tau\r\n  ## alpha.sig and beta.sig -- hyperparameters for sigma (up.mcmc=T)\r\n  ## alpha.tau and beta.tau -- hyperparameters for tau (up.mcmc=T)\r\n  ## sigma -- sampling variability  (up.mcmc=F)\r\n  ## tau -- G0 prior variance (up.mcmc=F)\r\n\r\n  output <- file(\"output_DP.txt\", \"w\")\r\n\r\n  MM <- length(y)\r\n  inizval <- inizcDP(y, nu, sigma, tau, p0)\r\n  label <- inizval$label\r\n\r\n  matlabel <- matrix(0, B, MM)\r\n  lpost <- rep(0, B)\r\n   if(up.mcmc==T) sigma.up <- rep(0, B)\r\n   if(up.mcmc==T) tau.up <- rep(0, B)\r\n\r\n  # runs the simulation over B iterations\r\n  for(b in 1:B){\r\n                                        #cat(b,\": \")\r\n    for(k in 1:MM){\r\n        L <- max(label)\r\n        j0 <- label[k]\r\n        label[k] <-  -1\r\n        if(j0>1)\r\n          {\r\n            if (sum(label==j0)==0) # lonely guy\r\n              label <- ifelse(label > j0, label-1, label)\r\n          }\r\n        L <- max(label)\r\n        freq <- tabulate(label[-k])\r\n\r\n        if(dbg==1){\r\n          if(sum(freq) != MM-1)\r\n            cat(\"\\n **** ERRROR something fishy with label.\\n\")\r\n        }\r\n        label[k] <- qsampleconfig(y, k, label, freq,  L, nu, sigma, tau, p0=p0, iniz=0)\r\n        L <- max(label)\r\n        freq <- tabulate(label)\r\n      }# k\r\n      ##browser()\r\n      ##end of the sweep\r\n\r\n    if(up.mcmc==T)\r\n      {\r\n        ## find centroids\r\n        L <- max(label)\r\n        freq <- tabulate(label)\r\n        centr.vec <- rep(NA, L)\r\n        yj <- rep(NA, L)\r\n        for(j in 1:L) yj[j] <- sum(y[label==j])\r\n        ## sigma update\r\n        centr.var <-  c(NA, (sigma*tau)/(tau * freq[2:L]+sigma))\r\n        centr.mean <- c(NA, (centr.var[2:L] * yj[2:L] /(sigma)))\r\n        centr.vec  <- c(0, rnorm(rep(1,(L-1)), centr.mean[2:L], sqrt(centr.var[2:L])))\r\n\r\n        alpha.sig.up <- alpha.sig+0.5*MM\r\n        sum.temp=0.0\r\n        for(j in 1:L) sum.temp <- sum.temp+sum((y[label==j]-centr.vec[j])^2)\r\n        beta.sig.up <- beta.sig+0.5*sum.temp\r\n        sigma <- 1/rgamma(1, alpha.sig.up, rate=beta.sig.up)\r\n        sigma.up[b] <- sigma\r\n\r\n        ## update tau, var of G0\r\n\r\n        alpha.tau.up <- alpha.tau+0.5*(L-1) ## L-1 because tau is not on the first component\r\n        beta.tau.up <- beta.tau+0.5*sum(centr.vec^2)\r\n\r\n        tau <- 1/rgamma(1, alpha.tau.up, rate=beta.tau.up)\r\n        tau.up[b] <- tau\r\n\r\n        llikl <- lprior  <- 0\r\n        llikl <- dnorm(yj[1:L], centr.vec[1:L], sqrt(sigma), log=T)\r\n        lprior <- dnorm(centr.vec[1:L], 0, sqrt(tau), log=T)+log(dinvgamma(tau, alpha.tau, beta.tau))+log(dinvgamma(sigma, alpha.sig, beta.sig))\r\n        lpost[b] <- sum(lprior+llikl)\r\n\r\n      }\r\n\r\n    matlabel[b,] <- label\r\n\r\n    cat(\"Iteration \", b , \" L=\",L , \" sigma=\", sigma, \" tau=\", tau, \"\\n\", file=output)\r\n  }# b\r\n  cat(\"DP done \\n\", file=output)\r\n  close(output)\r\n  list(label=label, matlabel=matlabel, logpost=lpost, sigma=sigma.up, tau=tau.up)\r\n   ## label <- last iteration labels\r\n   ## matlabel <- matrix of labels across iterations\r\n   ## lpost <- log posterior\r\n   ## sigma.up <- chain for sigmas\r\n   ## tau.up <- chain for tau\r\n}\r\n\r\n### the previous function relies on the following\r\n\r\n### initialization of the DP algorithm\r\n\r\ninizcDP <-  function(y, nu, sigma, tau, p0)\r\n{\r\n  MM <- length(y)\r\n  label <- rep(0, MM)\r\n  label[1] <- 1\r\n  for(k in 2:MM){\r\n    L <- max(label[1:(k-1)])\r\n    freq <- tabulate(label[1:(k-1)])\r\n    label[k] <- qsampleconfig(y, k, label, freq,  L, nu, sigma, tau,p0, iniz=1)\r\n    L <- max(label)\r\n  }# k\r\n  list(label=label)\r\n}\r\n\r\n### simple DP Polya Urn scheme\r\n### based on configurations (labels)\r\n### section 5.2 (data -- z scores)\r\n\r\n\r\n\r\nqsampleconfig <- function(y, k, label, freq,  L, nu, sigma, tau, p0, iniz=0, dbg=0)\r\n  {\r\n    ## y -- data (z scores)\r\n    ## k -- current update is for the k-observation (y[k])\r\n    ## label -- vector of configurations at the current iteration (excluding obs k)\r\n    ## freq -- vector of label frequencies (excluding obs k)\r\n    ## L -- current number of DP clusters\r\n    ## nu -- DP mass parameter\r\n    ## sigma -- sampling variability\r\n    ## tau -- G0 prior variance\r\n    ## p0 -- prior probability of the null\r\n    ##  iniz=1 inizialization step yes(1), no(0)\r\n    yj <- rep(0,L)\r\n    post.pred.mean <- rep(0,L)\r\n    post.pred.var <- rep(0,L)\r\n\r\n    for(j in 1:L){\r\n      yj[j] <- sum(y[label==j]) # note label[k]= -1\r\n                                        # compute p(s[k]=L+1 | ...)\r\n                                        # browser()\r\n                                        #quadyj[j] <- sum(y[label==j]%*%y[label==j])\r\n    }\r\n\r\n                                        # quadyk <- quadyj[j]+y[k]*y[k]\r\n    if((dbg==0)  & (iniz==1))\r\n      {\r\n        if (round(sum(yj),5) != round(sum(y[1:(k-1)]),5)){\r\n          cat(\"\\n **** ERRROR something fishy with yj.\\n\")\r\n          browser()}\r\n      }\r\n    q <- rep(0,L+1)\r\n    q[1] <- log(nu*p0+freq[1])\r\n    q[1] <- q[1]+dnorm(y[k],0,sqrt(sigma),log=T)\r\n\r\n    if(L>1){\r\n      ## posterior predictive parameters\r\n      post.pred.var[2:L] <- (sigma*tau)/(tau * freq[2:L]+sigma)\r\n      post.pred.mean[2:L] <- post.pred.var[2:L] *  yj[2:L]/sigma\r\n      q[2:L] <- log(freq[2:L])+dnorm(y[k], post.pred.mean[2:L], sqrt(post.pred.var[2:L]+sigma), log=T)\r\n    }\r\n    q[L+1]<- log(nu*(1-p0))+dnorm(y[k],0,sqrt(sigma+tau),log=T)\r\n\r\n    q <- exp(q-max(q))\r\n\r\n    sk <- sample(1:(L+1),1,T,q)\r\n    sk\r\n  }\r\n\r\n\r\n## BDP function for section 5.2\r\n\r\ncBayesODP <- function(z, data, label, mu0,  sigma)\r\n  {\r\n  ## z -- value where to compute BDP(z)\r\n  ## data -- z scores\r\n  ## label -- configuration taken into consideration\r\n  ## mu0 -- mean under the null\r\n  ## sigma -- sampling variability\r\n  \r\n    num <- 0.0\r\n    den <- 0.0\r\n    L <- max(label)\r\n    f <- tabulate(label)\r\n                                        # compute num (alternatives)\r\n                                        # and den (true null)\r\n    mustar <- rep(0,L)\r\n    for(j in 1:L)\r\n      {\r\n        mustar[j]=sum(data[label==j])/f[j]\r\n      }\r\n    for(i in 1:length(label))\r\n      {\r\n        if(label[i]==1)\r\n          den <- den + dnorm(z, mu0, sigma) else\r\n        {for(j in 2:L)\r\n           {\r\n             if(label[i]==j)\r\n                       num <- num + dnorm(z, mustar[j], sigma)\r\n           }\r\n       }\r\n      }\r\n    ratio <- num/den\r\n    ratio\r\n\r\n  }\r\n  \r\n  \r\n###################################\r\n## MCMC implementation\r\n## for full data in sec 5.2 (eq 16)\r\n## now we consider the raw data\r\n\r\n\r\n## MCMC function\r\n\r\n\r\ncDPODP_full <-  function(y, tlabel, B=B, p0=0.5, nu=1, sigma0, df0, const0, dbg=1)\r\n{\r\n  ##  y -- data\r\n  ## tlabel -- vector of conditions  (e.g. 1 or 2)\r\n  ## B -- number of iterations\r\n  ## p0 -- prior probability of the null\r\n  ## nu -- DP mass parameter\r\n  ## sigma0 -- prior hyperparameter for the Inv-Gamma on sigma\r\n  ## df0 -- prior hyperparameter for the Inv-Gamma on sigma\r\n  ## const0 -- k0 in the expression of G_0 (eq 16)\r\n  ## dbg -- debug (yes/no)\r\n\r\n  output <- file(\"output_DP.txt\", \"w\")\r\n\r\n  ## determine the groups (here I assume 2 groups)\r\n\r\n  MM <- dim(y)[1]\r\n\r\n  inizval <- inizcDP_full(y, tlabel, p0, nu, sigma0, df0, const0)\r\n  label <- inizval$label\r\n\r\n  matlabel <- matrix(0, B, MM)\r\n  lpost <- rep(0, B)\r\n\r\n  # runs the simulation over B iterations\r\n  for(b in 1:B){\r\n    for(k in 1:MM){\r\n        L <- max(label)\r\n        j0 <- label[k]\r\n        label[k] <-  -1\r\n        if(j0>1)\r\n          {\r\n            if (sum(label==j0)==0) # lonely guy\r\n              label <- ifelse(label > j0, label-1, label)\r\n          }\r\n        L <- max(label)\r\n        freq <- tabulate(label[-k])\r\n\r\n        if(dbg==1){\r\n          if(sum(freq) != MM-1)\r\n            cat(\"\\n **** ERRROR something fishy with label.\\n\")\r\n        }\r\n        label[k] <- qsampleconfig_full(y, k, tlabel, label, freq,  L, nu, sigma0, df0, const0, p0)\r\n        L <- max(label)\r\n        freq <- tabulate(label)\r\n      }# k\r\n\r\n    matlabel[b,] <- label\r\n\r\n    cat(\"Iteration \", b , \" L=\",L , \"\\n\")##, file=output)\r\n  }# b\r\n  cat(\"DP done \\n\", file=output)\r\n  close(output)\r\n  list(label=label, matlabel=matlabel, logpost=lpost)\r\n\r\n}\r\n\r\n## function for the initialization\r\n\r\ninizcDP_full <-  function(y,  tlabel, p0, nu, sigma0, df0, const0)\r\n{\r\n  ## y - data\r\n  ## tlabel -- samples (e.g., 1 or 2)\r\n  ## p0, nu, sigma0, df0 and const0 as in cDPODP_full\r\n  MM <- dim(y)[1]\r\n  label <- rep(0, MM)\r\n  label[1] <- 1\r\n  for(k in 2:MM){\r\n    ##if(k>5) browser()\r\n    L <- max(label[1:(k-1)])\r\n    freq <- tabulate(label[1:(k-1)])\r\n    label[k] <- qsampleconfig_full(y, k, tlabel, label, freq,  L, nu, sigma0, df0, const0, p0)\r\n    L <- max(label)\r\n    ##cat(\" k = \",  k, \" L=\", L, \"\\n\")\r\n  }# k\r\n  list(label=label)\r\n}\r\n\r\n###  DP Polya Urn scheme\r\n### based on configurations (labels)\r\n### section 5.2 (data -- full data)\r\n\r\nqsampleconfig_full <- function(y, k, tlabel, label, freq, L, nu, sigma0, df0, const0, p0, dbg=0)\r\n  {\r\n    ##  y -- data\r\n    ##  k -- current observation update is y[k]\r\n    ##  tlabel= vector of condition indicator\r\n    ##  label -- vector of indicators (excluding k)\r\n    ##  L -- total number of cluster\r\n    ##  nu -- DP mass parameter\r\n    ##  sigma0, df0, p0 as before\r\n    ##  iniz=1 inizialization step yes(1), no(0)\r\n\r\n    y1 <- y[, tlabel==1]\r\n    y2 <- y[, tlabel==2]\r\n    n1 <- length(tlabel[tlabel==1])\r\n    n2 <- length(tlabel[tlabel==2])\r\n\r\n    ## computation of the weights\r\n\r\n    q <- rep(0,L+1)\r\n    q[1] <- log(nu*p0+freq[1])\r\n    dfst <- df0+freq[1]*(n1+n2)\r\n    sigma2st <- (df0*sigma0 + sum(y[label==1,]^2))/dfst\r\n    Sigma <- sigma2st * diag(1, n1+n2)\r\n    Mu <- rep(0, (n1+n2))\r\n\r\n    q[1] <- q[1]+dmvt(y[k,], delta=Mu, sigma=Sigma, df=dfst, log=TRUE)\r\n\r\n    if(L>1){\r\n      for(j in 2:L){\r\n        q[j] <- log(freq[j])\r\n        const_st <- const0+ freq[j] * n2\r\n        dfst <- df0+freq[j]*(n1+n2)\r\n        sigma2st <- (df0*sigma0 + sum(y[label==j,]^2))/dfst\r\n        Sigma <- as.matrix(sigma2st * bdiag(diag(1, n1), (1+1/const_st)* diag(1, n2)))\r\n        Mu <- c(rep(0, n1), rep((1/const_st)*sum(y[label==j,tlabel==2]), n2))\r\n        q[j] <- q[j]+dmvt(y[k,], delta=Mu, sigma=Sigma, df=dfst, log=TRUE)\r\n      }\r\n    }\r\n    q[L+1] <- log(nu*(1-p0))\r\n    Mu <- rep(0, (n1+n2))\r\n    Sigma <- as.matrix(sigma0 *  bdiag(diag(1, n1), diag(1+1/const0, n2)))\r\n    q[L+1] <- q[L+1]+dmvt(as.vector(y[k,]), delta=Mu, sigma=Sigma, df=dfst, log=TRUE)\r\n\r\n\r\n    q <- exp(q-max(q))\r\n\r\n    sk <- sample(1:(L+1),1,T,q)\r\n    sk\r\n  }\r\n\r\n## Function to compute the BDP for the full dataset\r\n\r\ncBayesODP_full <- function(vett, f, mustar1, mustar2, sdstar1, sdstar2, vtlab1, vtlab2, nlab1, nlab2, L)\r\n  {\r\n    ## vett --  vector (matrix of data actually) to compute BDP(vett)\r\n    ## f --  vector of frequencies (computed from the vector of labels outside this function)\r\n    ##       i.e. L <- max(label); f <- tabulate(label)\r\n    ## mustar1 -- posterior mean for the samples in condition 1\r\n    ## mustar2 -- posterior mean for sample in condition 2\r\n    ## sdstar 1 -- post sd for samples in condition 1\r\n    ## sdstar 2 -- post sd for samples in condition 2\r\n    ## vtlab1 -- samples in condition 1 vtlab1 <- which(tlabel==1)\r\n    ## vtlab2 -- samples in condition 2 vtlab2 <- which(tlabel==2)\r\n    ## nlab1 -- number of samples in condition 1\r\n    ## nlab2 -- number of samples in condition 2\r\n\r\n\r\n    num <- 0.0\r\n    den <- 0.0\r\n\r\n    n  <-  dim(vett)[2]\r\n\r\n    mv.mu <- matrix(0,n, L)\r\n    mv.sd <- matrix(0,n, L)\r\n\r\n    BDP <- rep(0, dim(vett)[1])\r\n\r\n    mv.mu[vtlab1, 1:L]  <- matrix(mustar1, nlab1, L, byrow=T)\r\n    mv.mu[vtlab2, 1:L]  <- matrix(mustar2, nlab2, L, byrow=T)\r\n    mv.sd[vtlab1, 1:L]  <- matrix(sdstar1, nlab1, L, byrow=T)\r\n    mv.sd[vtlab2, 1:L]  <- matrix(sdstar2, nlab2, L, byrow=T)\r\n\r\n    for(r in 1:dim(vett)[1])\r\n      {\r\n        num <- rep(0, L)\r\n        ## semplification\r\n\r\n        den <- f[1] * dmvnorm(vett[r,], mean=mv.mu[,1],  sigma=diag(mv.sd[,1]^2, n))\r\n        for(j in 2:L) num[j]  <- f[j] * dmvnorm(vett[r,], mv.mu[,j], sigma=diag(mv.sd[,j]^2, n))\r\n\r\n        BDP[r] <- sum(num)/den\r\n\r\n\r\n      }\r\n    BDP\r\n  }\r\n", "encoding": "ascii"}