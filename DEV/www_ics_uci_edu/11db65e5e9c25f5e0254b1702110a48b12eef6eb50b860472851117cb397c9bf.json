{"url": "https://www.ics.uci.edu/~thornton/ics46/Notes/TreeTraversals/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2018, Notes and Examples: Tree Traversals</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2018 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2018<br />\r\n   Notes and Examples: Tree Traversals</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Traversals</p>\r\n\r\n<p>With the linear data structures we've seen previously, we've seen that it's possible to <i>traverse</i> them, which is to say that we <i>visit</i> each data element and do something with it.  For example, a <i>linked list traversal</i> is an algorithm in which we visit every element stored in the linked list exactly once.  The word \"visit\" may seem a little bit strange here, but that's because it's abstract: What we do to each element in a traversal depends on why we're doing the traversal in the first place.  We might be traversing the elements because we want to store them in a file, or because we want to send them across a network, or because we want to search to see whether one of them has some characteristic we're interested in.  Regardless, though, the underlying idea is the same: Use an algorithm that can get you to every element in the list exactly once, and tailor your idea of \"visiting\" to your specific needs.</p>\r\n\r\n<p>In C++ terms, traversing a linked list might look something like this:</p>\r\n\r\n<blockquote><pre>\r\nNode* current = head;\r\n\r\nwhile (current != nullptr)\r\n{\r\n    visit(current-&gt;data);\r\n    current = current-&gt;next;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Once you're comfortable with the idea of using pointers in this way, the approach is a straightforward one; at any given time, we keep a pointer to the node we're currently looking at, then move it gradually forward throughout the list, one step at a time.  Note, too, that we're visiting the <i>data</i> in each node, not the node itself; the node is just an implementation detail, while the data is what's actually important.</p>\r\n\r\n<p>When you consider how you might traverse a tree, though, the idea isn't quite so simple.  At every step in the process of traversing a linked list, there's no question about where you should go, since every node has only one node that directly follows it.  In a tree, however, the problem is more complex.  Nodes have multiple children.  Some nodes have no children.  How do you know which way to go?  What do you do when you hit a dead end?  How do you ensure you never visit the same node twice?</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Tree traversals</p>\r\n\r\n<p>A <i>tree traversal</i> is an algorithm that visits the data element in every node in a tree exactly once.  Again, the notion of \"visiting\" is an abstract one; what you do when you visit a data element can be anything you need done, but it doesn't change the core algorithm used to find every node and ensure that its data element is only visited once.  So we should concentrate on that algorithm, because once we understand that, we can use it for any purpose we'd like.</p>\r\n\r\n<p>The first question we need to consider is the order in which we'd like to find the nodes.  In some cases, we don't care; any order will do.  In others, the data is structured in a particular way &mdash; the parent/child relationship has a particular meaning &mdash; and we want to visit it in an order reflected by that structure.  So, generally, we should consider the available options, understand the tradeoffs inherent in each, and then we'll be able to make a practical choice given a real problem we need solved.</p>\r\n\r\n<p>While there are lots of ways to traverse a tree, they fall broadly into two categories: <i>breadth-first</i> and <i>depth-first</i>.  The distinction, stated simply, is between the idea of working our way across before working our way downward (that's \"breadth-first\") and the idea of working our way downward as far as that takes us before working our way across (that's \"depth-first\").</p>\r\n\r\n<p>As we proceed with our discussion, we'll use the same tree we saw in the <a href=\"../GeneralTrees\">previous Notes and Examples page</a>, duplicated below.</p>\r\n\r\n<p class=\"center\"><img src=\"GeneralTree.png\" alt=\"General Tree\" /></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Breadth-first tree traversals</p>\r\n\r\n<p>A <i>breadth-first tree traversal</i> reaches nodes in the order of their depth in the tree &mdash; the root first, then all nodes that are children of the root (i.e., at depth 1), then all nodes that are children of those nodes (i.e., at depth 2), and so on.  Many trees have no explicit notion of ordering of the children of each node, in which case it's not important what order these children are reached, but, to keep things simple for the sake of this conversation, we'll work left-to-right in the diagram whenever given a choice.  With that clarification in place, we would say that the data elements would be visited in the following order:</p>\r\n\r\n<blockquote><pre>\r\nX Q F D C N R S M H L\r\n</pre></blockquote>\r\n\r\n<p>Conceptually, that's all there is to it.  However, there's a more interesting question we should consider: How do you implement something like this?  And, once we understand that, how much time and memory does it require to do it?</p>\r\n\r\n<p>Central to the implementation of a breadth-first tree traversal is a queue of the nodes that we should consider next.  We'll dequeue nodes from that queue, visit their data, then enqueue additional nodes afterward, using the following algorithm.</p>\r\n\r\n<blockquote><pre>\r\nlet Q be an empty queue\r\n\r\nif the tree is not empty:\r\n    enqueue the root of the tree into Q\r\n\r\nwhile Q is not empty:\r\n    dequeue a node n from Q\r\n    visit n's data\r\n    enqueue n's children into Q\r\n</pre></blockquote>\r\n\r\n<p>Before you proceed, work through this algorithm on paper and convince yourself that it indeed visits every node's data element exactly once.  Pay attention to its behavior as you go; for example, note that the nodes on each level aren't enqueued until after the nodes on the previous level have all been enqueued already.  It's the use of a queue that gives this algorithm its breadth-first characteristic.</p>\r\n\r\n<p class=\"subtitle\">Asymptotic analysis</p>\r\n\r\n<p>A key property of this algorithm is that no node on level <i>i</i> is enqueued until its parent is dequeued.  In fact, we can observe that no node on level <i>i</i> is enqueued until after <i>all</i> nodes on the level <i>i</i> &minus; 1 are enqueued already.  Further, we can observe that no node on level <i>i</i> is enqueued until after <i>all</i> nodes on the level <i>i</i> &minus; 2 have been dequeued (because only then will all nodes on level <i>i</i> &minus; 1 have been enqueued).</p>\r\n\r\n<p>From these facts, there are two things we know for sure:</p>\r\n\r\n<ul>\r\n  <li>The nodes will be dequeued in level order, making this a valid breadth-first traversal.</li>\r\n  <li>When we've finished with one level of the tree, all of the nodes on the level below it will be in the queue and no others.</li>\r\n</ul>\r\n\r\n<p>Now come the two key questions: How much time is required, and how much memory is required?  Let's take each of these in turn.</p>\r\n\r\n<p>Measuring the amount of time required isn't quite as straightforward as some of the algorithms we've seen previously.  If you consider that it's centered around a loop, you might first imagine that you would need to count how many loop iterations there will be.  However, it's not that simple, because some loop iterations will take longer than others; some nodes have more children than others, while others have none.  But if we consider, in total, everything the algorithm does, a few facts emerge:</p>\r\n\r\n<ul>\r\n  <li>The total number of nodes that are dequeued across all loop iterations is <i>n</i>, the number of nodes in the tree.  Dequeuing each takes &Theta;(1) time, if we assume a good queue implementation, so this takes a total of &Theta;(<i>n</i>) time.</li>\r\n  <li>The total number of nodes enqueued across all loop iterations is also <i>n</i>.  So, again, this is a total of &Theta;(<i>n</i>) time.</li>\r\n  <li>The data in all <i>n</i> nodes is visited, as well.  We'll say that each visit step takes &Theta;(1) time &mdash; or, at the very least, that the amount of time it takes to visit one data element is not a function of any aspect of the tree (i.e., how many nodes it has, what its height is, etc.).  So, again, a total of &Theta;(<i>n</i>) time is spent.</li>\r\n</ul>\r\n\r\n<p>So, in total, it will take &Theta;(<i>n</i>) time to run the complete traversal, regardless of the tree's shape.</p>\r\n\r\n<p>Measuring how much memory we need &mdash; above and beyond the tree, which is something that already exists and isn't part of the algorithm itself &mdash; is mainly a question of how large the queue can get.  One thing we could say is that it will take <i>O</i>(<i>n</i>) memory, because if the tree was flat (i.e., one root node with every other node a child of the root), essentially every node would end up in the queue.  But this, while true, is somewhat misleading; we could do better if we described the tree in terms of something other than how many nodes it contains.</p>\r\n\r\n<p>We'll say that the tree has <i>n</i> nodes, a height of <i>h</i>, and a <i>width</i> of <i>w</i>, where the width is defined as the maximum number of nodes on any level.  Given these variables, we can say something more powerful.  Each time we finish with one level of the tree, the next entire level will be in the queue.  So, the maximum amount of memory we'd use is proportional to the tree's width, or &Theta;(<i>w</i>).  (You could also reasonably say <i>O</i>(<i>w</i>), in the sense that you won't be using the memory the entire time the algorithm runs.  It depends on whether you're talking about \"How much memory would need to be available so that I wouldn't run out?\" or \"How much memory would I be using at any given time while the algorithm runs?\")</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Depth-first tree traversals</p>\r\n\r\n<p>A <i>depth-first tree traversal</i> performs a traversal of each entire subtree before traversing the others.  Thought differently, it follows one path until it reaches a leaf, then backtracks and tries another path, and so on.  As with breadth-first tree traversals, in trees that have no explicit ordering of the children of each node, it's not important what order the subtrees are traversed, but we'll assume that we traverse them in left-to-right order when not specified.</p>\r\n\r\n<p>One important question in a depth-first tree traversal is <i>when</i> we do the visiting while we traverse.  Broadly speaking, there are two choices:</p>\r\n\r\n<ul>\r\n  <li>Visit the data in a node first, then traverse its subtrees.  We call this a <i>preorder</i> traversal, because the visit step happens before (i.e., <i>pre</i>) the subtrees.</li>\r\n  <li>Traverse a node's subtrees first, then visit its data.  We call this a <i>postorder</i> traversal, because the visit step happens after (i.e., <i>post</i>) the subtrees.</li>\r\n</ul>\r\n\r\n<p>Neither of these is right or wrong; each is a choice you might reasonably make, depending on the reason why you're traversing the tree.  If the distinction doesn't matter, you can choose either; if, on the other had, it matters (and we'll see examples later this quarter), you'd want to make the appropriate choice.</p>\r\n\r\n<p>The algorithms are most easily written recursively, with recursive calls made as you work your way down the tree, and returning from the recursive calls causing backtracking.  You could also write these iteratively, but you'd then need to maintain your own stack &mdash; the same stack that is provided implicitly by the run-time stack in a recursive function.</p>\r\n\r\n<blockquote><pre>\r\npreorder(Tree t):\r\n    visit(data in root of t)\r\n    for each subtree s of t:\r\n        preorder(s)\r\n\r\npostorder(Tree t):\r\n    for each subtree s of t:\r\n        postorder(s)\r\n    visit(data in root of t)\r\n</pre></blockquote>\r\n\r\n<p>Before you proceed, work through these two algorithms on paper and convince yourself that they indeed visit every node's data element exactly once.  Pay attention to their behavior as you go, noting how the use of recursion gives this algorithm its depth-first characteristic.</p>\r\n\r\n<p class=\"subtitle\">Asymptotic analysis</p>\r\n\r\n<p>The first step in analyzing these algorithms is realizing that they both perform exactly the same operations, albeit in a different sequence.  The same recursive calls will be made, the same visits will be done; the only difference is when.  For this reason, the analysis of one is essentially the same as the analysis of the other, so we'll just consider <b>preorder</b>, and see if we can determine how much time and memory would be required by it.</p>\r\n\r\n<p>Since the <b>preorder</b> algorithm is recursive, we could try to write a recurrence that describes how much time it spends, then solve that recurrence.  However, this turns out to be a problematic approach, because the recurrence we might write would be highly dependent on the shape of the tree.  So, instead, let's consider the overall behavior of the algorithm at once.  As we saw when we analyzed breadth-first traversals, a few key facts emerge:</p>\r\n\r\n<ul>\r\n  <li>There will be exactly one call to <b>preorder</b> for every node in the tree.  The first of these is the one that started the process; the rest are recursive calls that are made throughout.</li>\r\n  <li>The total number of iterations across all of the <b>for each</b> loops is <i>n</i> &minus; 1, since there are <i>n</i> &minus; 1 nodes in the tree other than the root.</li>\r\n  <li>Every node's data is visited exactly once, so there is a total of <i>n</i> visit steps being done.</li>\r\n</ul>\r\n\r\n<p>From these facts, we can see that, in a tree of <i>n</i> nodes, &Theta;(<i>n</i>) time will be spent in a preorder traversal of that tree &mdash; a linear amount of time to perform the visit steps, a linear amount to perform all of the recursive calls, and a linear amount to iterate through all of the loops.</p>\r\n\r\n<p>Considering memory usage, the main factor is the depth of the recursion.  While each call to <b>preorder</b> uses a constant amount of memory &mdash; say, a pointer to some node and another pointer or index that iterates through the subtrees &mdash; there will be potentially many calls to <b>preorder</b> active at any given time.  Again, let's assume the tree has <i>n</i> nodes, a height of <i>h</i>, and a width of <i>w</i>.  In this case, the height of the tree is the important thing; that determines how deep the recursion can go, since, at worst, you'll have one recursive call active for every node in some path in the tree &mdash; and the height of the tree is the length of its longest path.  So, in total, we'd say that we need a maximum of &Theta;(<i>h</i>) memory &mdash; or, thought differently, <i>O</i>(<i>h</i>) memory at any given time, since we won't always need all of it.  (It's important to remember that the run-time stack is still memory, so the fact that recursion might need to go <i>h</i> levels deep implies that we'll need <i>h</i> stack frames on the run-time stack.  That's the cost we're measuring in this case.)</p>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}