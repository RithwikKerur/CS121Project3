{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_10.html#SEC152", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Project Documentation</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Project Documentation\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Project Documentation\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC152\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_9.html#SEC148\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_11.html#SEC155\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> D. Project Documentation </H1>\n<!--docid::SEC152::-->\n<P>\n\nThis chapter presents a sample assignment and a filled-in design\ndocument for one possible implementation.  Its purpose is to give you an\nidea of what we expect to see in your own design documents.\n</P>\n<P>\n\n<A NAME=\"Sample Assignment\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC153\"></A>\n<H2> D.1 Sample Assignment </H2>\n<!--docid::SEC153::-->\n<P>\n\nImplement <CODE>thread_join()</CODE>.\n</P>\n<P>\n\n<A NAME=\"IDX184\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_join</B> (tid_t <VAR>tid</VAR>)\n<DD>Blocks the current thread until thread <VAR>tid</VAR> exits.  If <VAR>A</VAR> is\nthe running thread and <VAR>B</VAR> is the argument, then we say that\n&quot;<VAR>A</VAR> joins <VAR>B</VAR>.&quot;\n<P>\n\nIncidentally, the argument is a thread id, instead of a thread pointer,\nbecause a thread pointer is not unique over time.  That is, when a\nthread dies, its memory may be, whether immediately or much later,\nreused for another thread.  If thread <VAR>A</VAR> over time had two children\n<VAR>B</VAR> and <VAR>C</VAR> that were stored at the same address, then\n<CODE>thread_join(<VAR>B</VAR>)</CODE> and <CODE>thread_join(<VAR>C</VAR>)</CODE> would be\nambiguous.\n</P>\n<P>\n\nA thread may only join its immediate children.  Calling\n<CODE>thread_join()</CODE> on a thread that is not the caller's child should\ncause the caller to return immediately.  Children are not &quot;inherited,&quot;\nthat is, if <VAR>A</VAR> has child <VAR>B</VAR> and <VAR>B</VAR> has child <VAR>C</VAR>,\nthen <VAR>A</VAR> always returns immediately should it try to join <VAR>C</VAR>,\neven if <VAR>B</VAR> is dead.\n</P>\n<P>\n\nA thread need not ever be joined.  Your solution should properly free\nall of a thread's resources, including its <CODE>struct thread</CODE>,\nwhether it is ever joined or not, and regardless of whether the child\nexits before or after its parent.  That is, a thread should be freed\nexactly once in all cases.\n</P>\n<P>\n\nJoining a given thread is idempotent.  That is, joining a thread\nmultiple times is equivalent to joining it once, because it has already\nexited at the time of the later joins.  Thus, joins on a given thread\nafter the first should return immediately.\n</P>\n<P>\n\nYou must handle all the ways a join can occur: nested joins (<VAR>A</VAR>\njoins <VAR>B</VAR>, then <VAR>B</VAR> joins <VAR>C</VAR>), multiple joins (<VAR>A</VAR>\njoins <VAR>B</VAR>, then <VAR>A</VAR> joins <VAR>C</VAR>), and so on.\n</P>\n</DL>\n<P>\n\n<A NAME=\"Sample Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC154\"></A>\n<H2> D.2 Sample Design Document </H2>\n<!--docid::SEC154::-->\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>\n                         +-----------------+\n                         |      CS 140     |\n                         |  SAMPLE PROJECT |\n                         | DESIGN DOCUMENT |\n                         +-----------------+\n\n---- GROUP ----\n\nBen Pfaff &lt;blp@stanford.edu&gt;\n\n---- PRELIMINARIES ----\n\n&gt;&gt; If you have any preliminary comments on your submission, notes for\n&gt;&gt; the TAs, or extra credit, please give them here.\n\n(This is a sample design document.)\n\n&gt;&gt; Please cite any offline or online sources you consulted while\n&gt;&gt; preparing your submission, other than the Pintos documentation,\n&gt;&gt; course text, and lecture notes.\n\nNone.\n\n                                 JOIN\n                                 ====\n\n---- DATA STRUCTURES ----\n\n&gt;&gt; Copy here the declaration of each new or changed `struct' or `struct'\n&gt;&gt; member, global or static variable, `typedef', or enumeration.\n&gt;&gt; Identify the purpose of each in 25 words or less.\n\nA &quot;latch&quot; is a new synchronization primitive.  Acquires block\nuntil the first release.  Afterward, all ongoing and future\nacquires pass immediately.\n\n    /* Latch. */\n    struct latch \n      {\n        bool released;              /* Released yet? */\n        struct lock monitor_lock;   /* Monitor lock. */\n        struct condition rel_cond;  /* Signaled when released. */\n      };\n\nAdded to struct thread:\n\n    /* Members for implementing thread_join(). */\n    struct latch ready_to_die;   /* Release when thread about to die. */\n    struct semaphore can_die;    /* Up when thread allowed to die. */\n    struct list children;        /* List of child threads. */\n    list_elem children_elem;     /* Element of `children' list. */\n\n---- ALGORITHMS ----\n\n&gt;&gt; Briefly describe your implementation of thread_join() and how it\n&gt;&gt; interacts with thread termination.\n\nthread_join() finds the joined child on the thread's list of\nchildren and waits for the child to exit by acquiring the child's\nready_to_die latch.  When thread_exit() is called, the thread\nreleases its ready_to_die latch, allowing the parent to continue.\n\n---- SYNCHRONIZATION ----\n\n&gt;&gt; Consider parent thread P with child thread C.  How do you ensure\n&gt;&gt; proper synchronization and avoid race conditions when P calls wait(C)\n&gt;&gt; before C exits?  After C exits?  How do you ensure that all resources\n&gt;&gt; are freed in each case?  How about when P terminates without waiting,\n&gt;&gt; before C exits?  After C exits?  Are there any special cases?\n\nC waits in thread_exit() for P to die before it finishes its own\nexit, using the can_die semaphore &quot;down&quot;ed by C and &quot;up&quot;ed by P as\nit exits.  Regardless of whether whether C has terminated, there\nis no race on wait(C), because C waits for P's permission before\nit frees itself.\n\nRegardless of whether P waits for C, P still &quot;up&quot;s C's can_die\nsemaphore when P dies, so C will always be freed.  (However,\nfreeing C's resources is delayed until P's death.)\n\nThe initial thread is a special case because it has no parent to\nwait for it or to &quot;up&quot; its can_die semaphore.  Therefore, its\ncan_die semaphore is initialized to 1.\n\n---- RATIONALE ----\n\n&gt;&gt; Critique your design, pointing out advantages and disadvantages in\n&gt;&gt; your design choices.\n\nThis design has the advantage of simplicity.  Encapsulating most\nof the synchronization logic into a new &quot;latch&quot; structure\nabstracts what little complexity there is into a separate layer,\nmaking the design easier to reason about.  Also, all the new data\nmembers are in `struct thread', with no need for any extra dynamic\nallocation, etc., that would require extra management code.\n\nOn the other hand, this design is wasteful in that a child thread\ncannot free itself before its parent has terminated.  A parent\nthread that creates a large number of short-lived child threads\ncould unnecessarily exhaust kernel memory.  This is probably\nacceptable for implementing kernel threads, but it may be a bad\nidea for use with user processes because of the larger number of\nresources that user processes tend to own.\n</pre></td></tr></table><A NAME=\"Debugging Tools\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_10.html#SEC152\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_11.html#SEC155\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}