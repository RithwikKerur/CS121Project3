{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_8.html#SEC142", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: 4.4BSD Scheduler</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: 4.4BSD Scheduler\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: 4.4BSD Scheduler\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC141\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_7.html#SEC100\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_9.html#SEC148\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> B. 4.4<ACRONYM>BSD</ACRONYM> Scheduler </H1>\n<!--docid::SEC141::-->\n<P>\n\nThe goal of a general-purpose scheduler is to balance threads' different\nscheduling needs.  Threads that perform a lot of I/O require a fast\nresponse time to keep input and output devices busy, but need little CPU\ntime.  On the other hand, compute-bound threads need to receive a lot of\nCPU time to finish their work, but have no requirement for fast response\ntime.  Other threads lie somewhere in between, with periods of I/O\npunctuated by periods of computation, and thus have requirements that\nvary over time.  A well-designed scheduler can often accommodate threads\nwith all these requirements simultaneously.\n</P>\n<P>\n\nFor project 1, you must implement the scheduler described in this\nappendix.  Our scheduler resembles the one described in [ <A HREF=\"pintos_14.html#McKusick\">McKusick</A>],\nwhich is one example of a <EM>multilevel feedback queue</EM> scheduler.\nThis type of scheduler maintains several queues of ready-to-run threads,\nwhere each queue holds threads with a different priority.  At any given\ntime, the scheduler chooses a thread from the highest-priority non-empty\nqueue.  If the highest-priority queue contains multiple threads, then\nthey run in &quot;round robin&quot; order.\n</P>\n<P>\n\nMultiple facets of the scheduler require data to be updated after a\ncertain number of timer ticks.  In every case, these updates should\noccur before any ordinary kernel thread has a chance to run, so that\nthere is no chance that a kernel thread could see a newly increased\n<CODE>timer_ticks()</CODE> value but old scheduler data values.\n</P>\n<P>\n\nThe 4.4<ACRONYM>BSD</ACRONYM> scheduler does not include priority donation.\n</P>\n<P>\n\n<A NAME=\"Thread Niceness\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC142\"></A>\n<H2> B.1 Niceness </H2>\n<!--docid::SEC142::-->\n<P>\n\nThread priority is dynamically determined by the scheduler using a\nformula given below.  However, each thread also has an integer\n<EM>nice</EM> value that determines how &quot;nice&quot; the thread should be to\nother threads.  A <VAR>nice</VAR> of zero does not affect thread priority.  A\npositive <VAR>nice</VAR>, to the maximum of 20, decreases the priority of a \nthread and causes it to give up some CPU time it would otherwise receive.\nOn the other hand, a negative <VAR>nice</VAR>, to the minimum of -20, tends\nto take away CPU time from other threads.\n</P>\n<P>\n\nThe initial thread starts with a <VAR>nice</VAR> value of zero.  Other\nthreads start with a <VAR>nice</VAR> value inherited from their parent\nthread.  You must implement the functions described below, which are for\nuse by test programs.  We have provided skeleton definitions for them in\n<Q><TT>threads/thread.c</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX180\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> int <B>thread_get_nice</B> (void)\n<DD>Returns the current thread's <VAR>nice</VAR> value.\n</DL>\n<P>\n\n<A NAME=\"IDX181\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_set_nice</B> (int <VAR>new_nice</VAR>)\n<DD>Sets the current thread's <VAR>nice</VAR> value to <VAR>new_nice</VAR> and\nrecalculates the thread's priority based on the new value\n(see section <A HREF=\"pintos_8.html#SEC143\">B.2 Calculating Priority</A>).  If the running thread no longer has the\nhighest priority, yields.\n</DL>\n<P>\n\n<A NAME=\"Calculating Priority\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC143\"></A>\n<H2> B.2 Calculating Priority </H2>\n<!--docid::SEC143::-->\n<P>\n\nOur scheduler has 64 priorities and thus 64 ready queues, numbered 0\n(<CODE>PRI_MIN</CODE>) through 63 (<CODE>PRI_MAX</CODE>).  Lower numbers correspond\nto lower priorities, so that priority 0 is the lowest priority\nand priority 63 is the highest.  Thread priority is calculated initially\nat thread initialization.  It is also recalculated once every fourth\nclock tick, for every thread.  In either case, it is determined by\nthe formula\n</P>\n<P>\n\n<center>\n <TT><VAR>priority</VAR> = <CODE>PRI_MAX</CODE> - (<VAR>recent_cpu</VAR> / 4) - (<VAR>nice</VAR> * 2)</TT>,\n</center>\n</P>\n<P>\n\nwhere <VAR>recent_cpu</VAR> is an estimate of the CPU time the\nthread has used recently (see below) and <VAR>nice</VAR> is the thread's\n<VAR>nice</VAR> value.  The result should be rounded down to the nearest\ninteger (truncated).\nThe coefficients 1/4 and 2 on <VAR>recent_cpu</VAR>\nand <VAR>nice</VAR>, respectively, have been found to work well in practice\nbut lack deeper meaning.  The calculated <VAR>priority</VAR> is always\nadjusted to lie in the valid range <CODE>PRI_MIN</CODE> to <CODE>PRI_MAX</CODE>.\n</P>\n<P>\n\nThis formula gives a thread that has received CPU\ntime recently lower priority for being reassigned the CPU the next\ntime the scheduler runs.  This is key to preventing starvation: a\nthread that has not received any CPU time recently will have a\n<VAR>recent_cpu</VAR> of 0, which barring a high <VAR>nice</VAR> value should\nensure that it receives CPU time soon.\n</P>\n<P>\n\n<A NAME=\"Calculating recent_cpu\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC144\"></A>\n<H2> B.3 Calculating <VAR>recent_cpu</VAR> </H2>\n<!--docid::SEC144::-->\n<P>\n\nWe wish <VAR>recent_cpu</VAR> to measure how much CPU time each process has\nreceived &quot;recently.&quot; Furthermore, as a refinement, more recent CPU\ntime should be weighted more heavily than less recent CPU time.  One\napproach would use an array of <VAR>n</VAR> elements to\ntrack the CPU time received in each of the last <VAR>n</VAR> seconds.\nHowever, this approach requires O(<VAR>n</VAR>) space per thread and\nO(<VAR>n</VAR>) time per calculation of a new weighted average.\n</P>\n<P>\n\nInstead, we use a <EM>exponentially weighted moving average</EM>, which\ntakes this general form:\n</P>\n<P>\n\n<center>\n x(0) = f(0),\n</center>\n<center>\n x(t) = a*x(t-1) + f(t),\n</center>\n<center>\n a = k/(k+1),\n</center>\n</P>\n<P>\n\nwhere x(t) is the moving average at integer time t &gt;= 0, f(t) is the function being averaged, and k &gt; 0 controls the rate of decay.  We can iterate the formula over a few\nsteps as follows:\n</P>\n<P>\n\n<center>\n x(1) = f(1),\n</center>\n<center>\n x(2) = a*f(1) + f(2),\n</center>\n<center>\n ...\n</center>\n<center>\n x(5) = a**4*f(1) + a**3*f(2) + a**2*f(3) + a*f(4) + f(5).\n</center>\n</P>\n<P>\n\nThe value of f(t) has a weight of 1 at time t, a\nweight of a at time t+1, a**2 at time\nt+2, and so on.  We can also relate x(t) to k:\nf(t) has a weight of approximately 1/e at time t+k,\napproximately 1/e**2 at time t+2*k, and so on.\nFrom the opposite direction, f(t) decays to weight w at\ntime t + ln(w)/ln(a).\n</P>\n<P>\n\nThe initial value of <VAR>recent_cpu</VAR> is 0 in the first thread\ncreated, or the parent's value in other new threads.  Each time a timer\ninterrupt occurs, <VAR>recent_cpu</VAR> is incremented by 1 for the running\nthread only, unless the idle thread is running.  In addition, once per\nsecond the value of <VAR>recent_cpu</VAR>\nis recalculated for every thread (whether running, ready, or blocked),\nusing this formula:\n</P>\n<P>\n\n<center>\n <TT><VAR>recent_cpu</VAR> = (2*<VAR>load_avg</VAR>)/(2*<VAR>load_avg</VAR> + 1) * <VAR>recent_cpu</VAR> + <VAR>nice</VAR></TT>,\n</center>\n</P>\n<P>\n\nwhere <VAR>load_avg</VAR> is a moving average of the number of\nthreads ready to run (see below).  If <VAR>load_avg</VAR> is 1, indicating\nthat a single thread, on average, is competing for the CPU, then the\ncurrent value of <VAR>recent_cpu</VAR> decays to a weight of .1 in\nln(.1)/ln(2/3) = approx. 6 seconds; if\n<VAR>load_avg</VAR> is 2, then decay to a weight of .1 takes ln(.1)/ln(3/4) = approx. 8 seconds.  The effect is that\n<VAR>recent_cpu</VAR> estimates the amount of CPU time the thread has\nreceived &quot;recently,&quot; with the rate of decay inversely proportional to\nthe number of threads competing for the CPU.\n</P>\n<P>\n\nAssumptions made by some of the tests require that these recalculations of\n<VAR>recent_cpu</VAR> be made exactly when the system tick counter reaches a\nmultiple of a second, that is, when <CODE>timer_ticks () % TIMER_FREQ ==\n0</CODE>, and not at any other time.\n</P>\n<P>\n\nThe value of <VAR>recent_cpu</VAR> can be negative for a thread with a\nnegative <VAR>nice</VAR> value.  Do not clamp negative <VAR>recent_cpu</VAR> to 0.\n</P>\n<P>\n\nYou may need to think about the order of calculations in this formula.\nWe recommend computing the coefficient of <VAR>recent_cpu</VAR> first, then\nmultiplying.  Some students have reported that multiplying\n<VAR>load_avg</VAR> by <VAR>recent_cpu</VAR> directly can cause overflow.\n</P>\n<P>\n\nYou must implement <CODE>thread_get_recent_cpu()</CODE>, for which there is a\nskeleton in <Q><TT>threads/thread.c</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX182\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> int <B>thread_get_recent_cpu</B> (void)\n<DD>Returns 100 times the current thread's <VAR>recent_cpu</VAR> value, rounded\nto the nearest integer.\n</DL>\n<P>\n\n<A NAME=\"Calculating load_avg\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC145\"></A>\n<H2> B.4 Calculating <VAR>load_avg</VAR> </H2>\n<!--docid::SEC145::-->\n<P>\n\nFinally, <VAR>load_avg</VAR>, often known as the system load average,\nestimates the average number of threads ready to run over the past\nminute.  Like <VAR>recent_cpu</VAR>, it is an exponentially weighted moving\naverage.  Unlike <VAR>priority</VAR> and <VAR>recent_cpu</VAR>, <VAR>load_avg</VAR> is\nsystem-wide, not thread-specific.  At system boot, it is initialized to\n0.  Once per second thereafter, it is updated according to the following\nformula:\n</P>\n<P>\n\n<center>\n <TT><VAR>load_avg</VAR> = (59/60)*<VAR>load_avg</VAR> + (1/60)*<VAR>ready_threads</VAR></TT>,\n</center>\n</P>\n<P>\n\nwhere <VAR>ready_threads</VAR> is the number of threads that are\neither running or ready to run at time of update (not including the idle\nthread).\n</P>\n<P>\n\nBecause of assumptions made by some of the tests, <VAR>load_avg</VAR> must be\nupdated exactly when the system tick counter reaches a multiple of a\nsecond, that is, when <CODE>timer_ticks () % TIMER_FREQ == 0</CODE>, and not\nat any other time.\n</P>\n<P>\n\nYou must implement <CODE>thread_get_load_avg()</CODE>, for which there is a\nskeleton in <Q><TT>threads/thread.c</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX183\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> int <B>thread_get_load_avg</B> (void)\n<DD>Returns 100 times the current system load average, rounded to the\nnearest integer.\n</DL>\n<P>\n\n<A NAME=\"4.4BSD Scheduler Summary\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC146\"></A>\n<H2> B.5 Summary </H2>\n<!--docid::SEC146::-->\n<P>\n\nThe following formulas summarize the calculations required to implement the\nscheduler.  They are not a complete description of scheduler requirements.\n</P>\n<P>\n\nEvery thread has a <VAR>nice</VAR> value between -20 and 20 directly under\nits control.  Each thread also has a priority, between 0\n(<CODE>PRI_MIN</CODE>) through 63 (<CODE>PRI_MAX</CODE>), which is recalculated\nusing the following formula every fourth tick:\n</P>\n<P>\n\n<center>\n <TT><VAR>priority</VAR> = <CODE>PRI_MAX</CODE> - (<VAR>recent_cpu</VAR> / 4) - (<VAR>nice</VAR> * 2)</TT>.\n</center>\n</P>\n<P>\n\n<VAR>recent_cpu</VAR> measures the amount of CPU time a thread has received\n&quot;recently.&quot;  On each timer tick, the running thread's <VAR>recent_cpu</VAR>\nis incremented by 1.  Once per second, every thread's <VAR>recent_cpu</VAR>\nis updated this way:\n</P>\n<P>\n\n<center>\n <TT><VAR>recent_cpu</VAR> = (2*<VAR>load_avg</VAR>)/(2*<VAR>load_avg</VAR> + 1) * <VAR>recent_cpu</VAR> + <VAR>nice</VAR></TT>.\n</center>\n</P>\n<P>\n\n<VAR>load_avg</VAR> estimates the average number of threads ready to run over\nthe past minute.  It is initialized to 0 at boot and recalculated once\nper second as follows:\n</P>\n<P>\n\n<center>\n <TT><VAR>load_avg</VAR> = (59/60)*<VAR>load_avg</VAR> + (1/60)*<VAR>ready_threads</VAR></TT>.\n</center>\n</P>\n<P>\n\nwhere <VAR>ready_threads</VAR> is the number of threads that are\neither running or ready to run at time of update (not including the idle\nthread).\n</P>\n<P>\n\n<A NAME=\"Fixed-Point Real Arithmetic\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC147\"></A>\n<H2> B.6 Fixed-Point Real Arithmetic </H2>\n<!--docid::SEC147::-->\n<P>\n\nIn the formulas above, <VAR>priority</VAR>, <VAR>nice</VAR>, and\n<VAR>ready_threads</VAR> are integers, but <VAR>recent_cpu</VAR> and <VAR>load_avg</VAR>\nare real numbers.  Unfortunately, Pintos does not support floating-point\narithmetic in the kernel, because it would\ncomplicate and slow the kernel.  Real kernels often have the same\nlimitation, for the same reason.  This means that calculations on real\nquantities must be simulated using integers.  This is not\ndifficult, but many students do not know how to do it.  This\nsection explains the basics.\n</P>\n<P>\n\nThe fundamental idea is to treat the rightmost bits of an integer as\nrepresenting a fraction.  For example, we can designate the lowest 14\nbits of a signed 32-bit integer as fractional bits, so that an integer\nx represents the real number\nx/(2**14), where ** represents exponentiation.\nThis is called a 17.14 fixed-point number representation, because there\nare 17 bits before the decimal point, 14 bits after it, and one sign\nbit.<A NAME=\"DOCF6\" HREF=\"pintos_fot.html#FOOT6\">(6)</A> A number in 17.14 format represents, at maximum, a\nvalue of (2**31 - 1)/(2**14) = approx. 131,071.999.\n</P>\n<P>\n\nSuppose that we are using a p.q fixed-point format, and let f = 2**q.  By the definition above, we can convert an integer or\nreal number into p.q format by multiplying with f.  For example,\nin 17.14 format the fraction 59/60 used in the calculation of\n<VAR>load_avg</VAR>, above, is 59/60*(2**14) = 16,110.\nTo convert a fixed-point value back to an\ninteger, divide by f.  (The normal <Q><SAMP>/</SAMP></Q> operator in C rounds\ntoward zero, that is, it rounds positive numbers down and negative\nnumbers up.  To round to nearest, add f / 2 to a positive number, or\nsubtract it from a negative number, before dividing.)\n</P>\n<P>\n\nMany operations on fixed-point numbers are straightforward.  Let\n<CODE>x</CODE> and <CODE>y</CODE> be fixed-point numbers, and let <CODE>n</CODE> be an\ninteger.  Then the sum of <CODE>x</CODE> and <CODE>y</CODE> is <CODE>x + y</CODE> and\ntheir difference is <CODE>x - y</CODE>.  The sum of <CODE>x</CODE> and <CODE>n</CODE> is\n<CODE>x + n * f</CODE>; difference, <CODE>x - n * f</CODE>; product, <CODE>x * n</CODE>;\nquotient, <CODE>x / n</CODE>.\n</P>\n<P>\n\nMultiplying two fixed-point values has two complications.  First, the\ndecimal point of the result is q bits too far to the left.  Consider\nthat (59/60)*(59/60) should be slightly less than\n1, but 16,111*16,111 = 259,564,321 is much\ngreater than 2**14 = 16,384.  Shifting q bits right, we\nget 259,564,321/(2**14) = 15,842, or about 0.97,\nthe correct answer.  Second, the multiplication can overflow even though\nthe answer is representable.  For example, 64 in 17.14 format is\n64*(2**14) = 1,048,576 and its square 64**2 = 4,096 is well within the 17.14 range, but 1,048,576**2 = 2**40, greater than the maximum signed 32-bit\ninteger value 2**31 - 1.  An easy solution is to do the\nmultiplication as a 64-bit operation.  The product of <CODE>x</CODE> and\n<CODE>y</CODE> is then <CODE>((int64_t) x) * y / f</CODE>.\n</P>\n<P>\n\nDividing two fixed-point values has opposite issues.  The\ndecimal point will be too far to the right, which we fix by shifting the\ndividend q bits to the left before the division.  The left shift\ndiscards the top q bits of the dividend, which we can again fix by\ndoing the division in 64 bits.  Thus, the quotient when <CODE>x</CODE> is\ndivided by <CODE>y</CODE> is <CODE>((int64_t) x) * f / y</CODE>.\n</P>\n<P>\n\nThis section has consistently used multiplication or division by f,\ninstead of q-bit shifts, for two reasons.  First, multiplication and\ndivision do not have the surprising operator precedence of the C shift\noperators.  Second, multiplication and division are well-defined on\nnegative operands, but the C shift operators are not.  Take care with\nthese issues in your implementation.\n</P>\n<P>\n\nThe following table summarizes how fixed-point arithmetic operations can\nbe implemented in C.  In the table, <CODE>x</CODE> and <CODE>y</CODE> are\nfixed-point numbers, <CODE>n</CODE> is an integer, fixed-point numbers are in\nsigned p.q format where p + q = 31, and <CODE>f</CODE> is <CODE>1 &lt;&lt;\nq</CODE>:\n</P>\n<P>\n\n<CENTER>\n</P>\n<TABLE>\n<TR><TD>Convert <CODE>n</CODE> to fixed point:</TD>\n</TD><TD> <CODE>n * f</CODE>\n\n</TR>\n<TR><TD>Convert <CODE>x</CODE> to integer (rounding toward zero):</TD>\n</TD><TD> <CODE>x / f</CODE>\n\n</TR>\n<TR><TD>Convert <CODE>x</CODE> to integer (rounding to nearest):</TD>\n</TD><TD> <CODE>(x + f / 2) / f</CODE> if <CODE>x &gt;= 0</CODE>, <BR>\n<CODE>(x - f / 2) / f</CODE> if <CODE>x &lt;= 0</CODE>.\n\n</TR>\n<TR><TD>Add <CODE>x</CODE> and <CODE>y</CODE>:</TD>\n</TD><TD> <CODE>x + y</CODE>\n\n</TR>\n<TR><TD>Subtract <CODE>y</CODE> from <CODE>x</CODE>:</TD>\n</TD><TD> <CODE>x - y</CODE>\n\n</TR>\n<TR><TD>Add <CODE>x</CODE> and <CODE>n</CODE>:</TD>\n</TD><TD> <CODE>x + n * f</CODE>\n\n</TR>\n<TR><TD>Subtract <CODE>n</CODE> from <CODE>x</CODE>:</TD>\n</TD><TD> <CODE>x - n * f</CODE>\n\n</TR>\n<TR><TD>Multiply <CODE>x</CODE> by <CODE>y</CODE>:</TD>\n</TD><TD> <CODE>((int64_t) x) * y / f</CODE>\n\n</TR>\n<TR><TD>Multiply <CODE>x</CODE> by <CODE>n</CODE>:</TD>\n</TD><TD> <CODE>x * n</CODE>\n\n</TR>\n<TR><TD>Divide <CODE>x</CODE> by <CODE>y</CODE>:</TD>\n</TD><TD> <CODE>((int64_t) x) * f / y</CODE>\n\n</TR>\n<TR><TD>Divide <CODE>x</CODE> by <CODE>n</CODE>:</TD>\n</TD><TD> <CODE>x / n</CODE>\n</TR></TABLE>\n</CENTER>\n<A NAME=\"Coding Standards\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_8.html#SEC141\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_9.html#SEC148\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}