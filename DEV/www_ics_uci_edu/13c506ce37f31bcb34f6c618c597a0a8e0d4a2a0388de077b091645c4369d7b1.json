{"url": "https://www.ics.uci.edu/~thornton/ics46/Notes/Templates/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2018, Notes and Examples: Templates</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2018 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2018<br />\r\n   Notes and Examples: Templates</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>Includes a code example with the moniker <b>Templates</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>In C++, the demands of the static type system sometimes seem to warrant copying and pasting functions or classes whose only differences are the types of their arguments, member functions, or member variables.  Consider, for example, a simple three-line swap function that swaps a pair of integers.</p>\r\n\r\n<blockquote><pre>\r\nvoid myswap(int& a, int& b) noexcept\r\n{\r\n    int temp = a;\r\n    a = b;\r\n    b = temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>This function works wonderfully for two integers, but doesn't work at all for values of any other type.  But when you consider what you'd have to do to swap two doubles or two strings or two whatevers, you realize that it could be done with <i>exactly</i> the same code, with only the word <b>int</b> changed to something else in each place where it occurs.  For example, a version of <b>myswap</b> that swaps two doubles instead of two ints might look like this.</p>\r\n\r\n<blockquote><pre>\r\nvoid myswap(double& a, double& b) noexcept\r\n{\r\n    double temp = a;\r\n    a = b;\r\n    b = temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Because C++ allows <i>function overloading</i> (i.e., two functions with the same name, differentiated by the types of its arguments and/or return value), it will be legal to have both of these functions in the same program, and the compiler will dutifully follow its overload resolution rules to determine which version to call in which circumstance.  In fact, you could have ten, twenty, or a hundred of these functions that coexist, all with the same names and differing only in the types of their arguments and temporary variable.</p>\r\n\r\n<p>But why should we have to write the same function over and over again?  Wouldn't it be better if we could just write the function once, then tell the compiler how to convert it from one version to another based on the types in use?</p>\r\n\r\n<p>That's what <i>function templates</i> let you do.  They let you define the blueprint for an infinite set of possible functions, where you specify the ways that the different functions in the set would differ from each other.  In our case, we might like to write a function template that demonstrates how to generate <b>myswap</b> implementations for each possible type of value I might want to swap.</p>\r\n\r\n<p>Similarly, we might have a set of similar classes that differ from each other only with respect to one or more types used throughout the class.  Data structure implementations like <b>std::vector</b> are a good example of this; C++ doesn't have a (particularly usable) notion of \"Any type can go here,\" so a vector containing strings is a different type from a vector containing ints.  But rather than requiring a separate implementation of <b>std::vector</b> for every different type of element we might like to store in one, <b>std::vector</b> is instead a <i>class template</i>, which is a blueprint for an infinite set of possible classes, in which we describe how the classes in the set differ from one another.</p>\r\n\r\n<p>The devil, as they say, lies in the details, but the idea is a simple one and the need is clear.  Let's talk about how to do this properly in C++.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Function templates</p>\r\n\r\n<p class=\"subtitle\">Writing a function template</p>\r\n\r\n<p>Writing a function template is actually quite simple.  Whenever we want to write a template, we begin with the word <b>template</b>, followed by a set of template parameters (which are usually, but not always, types).  After this, we write a function in just the same way we always write them, except that we use the names of the template parameters to indicate the ways that different functions generated from our template are different.</p>\r\n\r\n<p>So, for example, if we wanted to write our <b>myswap</b> function as a function template, we would write this:</p>\r\n\r\n<blockquote><pre>\r\ntemplate &lt;typename T&gt;\r\nvoid myswap(T& t1, T& t2)\r\n{\r\n    T temp = t1;\r\n    t1 = t2;\r\n    t2 = temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The word <b>template</b> here, preceding what otherwise looks like a function definition, means that we've written a function template.  There isn't one <b>myswap</b> function; there is a potentially infinite set of them, which differ in terms of the template's parameters.  In this case, there is one parameter: the type of values being swapped.  The keyword <b>typename</b> establishes that the first parameter is a type &mdash; as opposed to something else, like an <b>int</b> constant &mdash; and <b>T</b>, in this case, is a name used throughout the function to describe that type.</p>\r\n\r\n<p>You may have noticed that I left the <b>noexcept</b> specifier out of our function template's signature, even though I included it in my original two examples of implementing <b>myswap</b> functions for integers and doubles.  This was not an accident.  Depending on the type of T, <b>myswap&lt;T&gt;</b> might not be able to guarantee that it doesn't throw an exception.  For example, it <b>T</b> is <b>int</b> or <b>double</b>, it will never throw; if <b>T</b> is <b>std::string</b> (which can perform dynamic allocation when you create one or copy one), it might.  So if we're going to say definitively whether our function template is either <b>noexcept</b> or not, it's clearly not.  (If we're willing to say it more carefully, we can get the best of both words; more on that in a little while.)</p>\r\n\r\n<p class=\"subtitle\">Instantiating a function template</p>\r\n\r\n<p>When you call a function template in a source file, the C++ compiler stops to decide whether it's seen that use of the function template before.  For example, imagine this source file:</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int i = 3;\r\n    int j = 4;\r\n    myswap(i, j);\r\n}\r\n</pre></blockquote>\r\n\r\n<p>At the point where <b>myswap</b> has been called, the compiler realizes that this particular call to <b>myswap</b> would only make sense if the type <b>T</b> in the template was <b>int</b>, because the parameters being passed are both of type <b>int</b>.  (Standard C++ overloading rules apply, so exact matches are favored over inexact ones, while the fact that the parameters are passed by reference dramatically reduces the set of possibilities.)  If the compiler can't make a concrete determination, we would have to specify the template argument ourselves, but this turns out to be unnecessary for many function templates:</li>\r\n</ul>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int i = 3;\r\n    int j = 4;\r\n    myswap&lt;int&gt;(i, j);   // legal, but unnecessary in many cases\r\n}\r\n</pre></blockquote>\r\n\r\n<p>So we now need the compiler to <i>instantiate</i> the template, which is to say that we need it to generate an actual function from it, where <b>T</b> = <b>int</b>.  A function template describes a potentially infinite set of functions, but none of those functions exists until we instantiate the template (i.e., we call the function with a particular set of template parameters for the first time).</p>\r\n\r\n<p>So, at this point, we need the compiler to actually compile the <b>myswap</b> function template with <b>T</b> = <b>int</b>.  That means the entire body of the <b>myswap</b> function template &mdash; not just its declaration, but its definition &mdash; needs to be available to the compiler.  For that reason, we generally implement function templates in header files as opposed to source files &mdash; except when we want to write a function template that is \"local\" to a particular source file.</p>\r\n\r\n<p>Note that this means that there may ultimately be multiple definitions of the same function template in separate source files (e.g., if two source files make calls to <b>myswap&lt;int&gt;</b>).  Fortunately, C++ linkers allow this for templates and are able to handle it for us, which is necessary for the template feature in C++ to actually work.</p>\r\n\r\n<p class=\"subtitle\">Constraints on template parameters</p>\r\n\r\n<p>As written, the only explicit constraint on the type parameter <b>T</b> in <b>myswap</b> is that it's some type.  However, there are constraints on what <b>T</b> is allowed to be, implicitly arising from the things we do with <b>T</b>'s inside of the function.  As we look at the function, we can see that we do the following things with <b>T</b>'s:</p>\r\n\r\n<ul>\r\n  <li>The line <b>T temp = t1;</b> invokes T's copy constructor.</li>\r\n  <li>The lines <b>t1 = t2;</b> and <b>t2 = temp;</b> invoke T's assignment operator.</li>\r\n  <li>Since <b>temp</b> is statically-allocated, <b>T</b>'s destructor will be called on <b>temp</b> when the function ends.</li>\r\n</ul>\r\n\r\n<p>It may sound strange, but there are types in C++ that disallow some or all of these features.  For example, we could declare the following class <b>X</b> with neither a copy constructor nor an assignment operator.</p>\r\n\r\n<blockquote><pre>\r\nclass X\r\n{\r\npublic:\r\n    X();\r\n    X(const X& x) = delete;\r\n    X& operator=(const X& x) = delete;\r\n};\r\n</pre></blockquote>\r\n\r\n<p>It would now be impossible to call <b>myswap</b> and pass it two <b>X</b>'s, because swapping them requires both a copy constructor and an assignment operator.</p>\r\n\r\n<p class=\"subtitle\">The power of conditional noexcept</p>\r\n\r\n<p>We saw previously that you can declare the <b>noexcept</b> specifier on a function conditionally, by writing an expression that can be evaluated at compile time to determine whether or not a function is <b>noexcept</b>.  We also saw the <b>noexcept</b> operator, which can evaluate whether or not an expression is <b>noexcept</b> (i.e., whether or not it's true that it is declared not to throw an exception).  Putting these features together, we can specify precisely when our <b>myswap</b> function template will be <b>noexcept</b>.</p>\r\n\r\n<p>First of all, we need to understand what we're trying to say.  Under what conditions will a particular instantiation of our <b>myswap</b> function template be <b>noexcept</b>?  Take a look at what the function does.</p>\r\n\r\n<ul>\r\n  <li>The first line of the body copy-constructs a <b>T</b> object.  This would need to be something that would be guaranteed not to throw.</li>\r\n  <li>The second and third lines of the body assign one <b>T</b> object to another.  This would also need to be something that would be guaranteed not to throw.</li>\r\n</ul>\r\n\r\n<p>The <b>noexcept</b> operator will let you ask whether something <i>cannot</i> throw an exception without actually performing the operation at run-time.  Used in a function's signature, we can even use the function's parameters if needed, because we're really just asking questions about <i>potential</i> uses of them; we need not worry about whether there would be side effects of the expressions, because the expressions won't be executed at run time, anyway.  Given that, we could write our function template this way:</p>\r\n \r\n<blockquote><pre>\r\ntemplate &lt;typename T&gt;\r\nvoid myswap(T&amp; t1, T&amp; t2)\r\n    noexcept(noexcept(T{t1}) &amp;&amp; noexcept(t1 = t2))\r\n{\r\n    T temp = t1;\r\n    t1 = t2;\r\n    t2 = temp;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The reason we're saying <b>noexcept</b> inside of <b>noexcept</b> is because there are two different uses of this keyword:</p>\r\n\r\n<ul>\r\n  <li>The outermost <b>noexcept</b> is being used as the <b>noexcept</b> specifier; we're saying \"These are the conditions under which this function template cannot throw an exception.\"</li>\r\n  <li>The two inner <b>noexcept</b> occurrences are the <b>noexcept</b> operator; in those cases, we're saying to the compiler, \"Figure out whether it's true that these two expressions cannot throw.\"</li>\r\n</ul>\r\n\r\n<p>So, all in all, we've said \"The <b>myswap</b> function template is guaranteed not to throw an exception when it is guaranteed that copy-constructing a <b>T</b> object from <b>t1</b> will not throw <i>and</i> when it is guaranteed that assigning <b>t2</b> into <b>t1</b> will not throw.\"</p>\r\n\r\n<p>On the one hand, you might react to this with disdain: It seems a complicated thing to have to say.  And, in truth, you wouldn't likely find yourself writing this kind of thing in the upper levels of application software.  Particularly when you're writing libraries, though &mdash; and this is something we're focused on in this course, in the sense that data structures are foundational things that we build programs on top of &mdash; this is the kind of thing where focusing your energies benefits everyone.  The implementers of the C++ Standard Library, for example, have gone to a lot of trouble in recent years to nail down <b>noexcept</b> specifiers throughout, but that's because the benefit is that <i>everyone</i> who uses the C++ Standard Library is better off: The code says what it means and means what it says, and (perhaps even more importantly) large-scale performance optimizations become available that wouldn't be otherwise.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Class templates</p>\r\n\r\n<p>Consider again what classes are in C++.  They are a blueprint for a kind of object, specifying what information objects of that class store and how objects of that class behave.  As you've no doubt seen previously, C++ has an aggressive static type system, requiring classes to be pretty specific about the types of data their objects work with.  This is with good reason: C++ compilers, given a class declaration, need to make decisions about things like object layout and the sizes of the parameters being passed to functions, all of which require knowing the specifics of the types involved.</p>\r\n\r\n<p>It doesn't take much thinking to realize that classes might benefit from templates the same way that functions do.  C++ provides us the ability to write <i>class templates</i>, which are a solution to a similar kind of problem.  A class template is a blueprint for a set of classes, each of which becomes a distinct, separate type.  The instantiations of a class template are similar in the sense that they all contain the same code (with uses of template parameters replaced by something concrete), but they aren't related by inheritance &mdash; or in any other way, unless you explicitly set them up that way &mdash; and are fundamentally incompatible with each other.</p>\r\n\r\n<p>Like function templates, class templates take a set of template parameters that describe the things that make one instantiation of the template different from another.  Most of the time, these are types, though, once in a while, constant values (such as ints) are used instead.  Data structure implementations are a common example where you see class templates used, because how a data structure works is often quite separate from the kinds of objects stored within it.  <b>std::vector</b> in the C++ Standard Library is a class template for exactly this reason; a vector doesn't behave differently if it stores <b>int</b> objects than it does if it stores <b>std::string</b> objects or <b>Person</b> objects or even pointers.  But it does allocate a different amount of memory for each cell in its underlying array, each kind of vector allows only correctly-typed values to be added into it, and so on.  So <b>std::vector</b> is a class template, with a template parameter that specifies what type of value will be stored in the vector.  A <b>std::vector&lt;int&gt;</b> is a vector that stores integers; a <b>std::vector&lt;std::string&gt;</b> is a vector that stores strings; and so on.  And while they're similar, they're not compatible; you can't assign a <b>std::vector&lt;std::string&gt;</b> into a <b>std::vector&lt;int&gt;</b>, or pass one as a parameter to a function expecting the other.</p>\r\n\r\n<p class=\"subtitle\">Writing a class template</p>\r\n\r\n<p>We write class templates in the same way that we write function templates: We begin with the word <b>template</b>, followed by the template's parameters listed between angle brackets and separated by commas.  So, for example, a class like the <b>std::vector</b> class in the standard library might look something like this:</p>\r\n\r\n<blockquote><pre>\r\ntemplate &lt;typename ElementType&gt;\r\nclass Vector\r\n{\r\n    ...\r\n};\r\n</pre></blockquote>\r\n\r\n<p>where <b>ElementType</b> is a parameter used to describe the type of element being stored in a particular <b>Vector</b>.  Within the class declaration, we would use <b>ElementType</b> whenever we want to specify \"The type of element being stored in this Vector,\" rather than using something specific like <b>int</b> or <b>std::string</b>.</p>\r\n\r\n<p class=\"subtitle\">Instantiating a class template</p>\r\n\r\n<p>Every time the compiler sees a new use of a class template &mdash; with a set of template parameters that hasn't been used before in that source file &mdash; it generates a new class on the fly, including only the member functions that are actually being used on an object of that class (which saves code size and also offers some flexibility, as we'll see later).  As with function templates, all of the code needs to be generated by the compiler when used, so we typically implement class templates, including definitions of member functions, in header files, so all of the code will be available to the compiler at the point where the class template is instantiated.</p>\r\n\r\n<p>As with function templates, there is no way to explicitly limit what the type <b>ElementType</b> is allowed to be, though there is an implicit limitation brought about by the things you do to <b>ElementType</b> objects inside the class.  For example, if we wrote this code in a member function in our <b>Vector</b> class:</p>\r\n\r\n<blockquote><pre>\r\nElementType e;\r\ne.foo();\r\n</pre></blockquote>\r\n\r\n<p>then we'd be introducing three constraints on <b>ElementType</b>:</p>\r\n\r\n<ul>\r\n  <li>It must be possible to default-construct an <b>ElementType</b> (i.e., <b>ElementType</b> has a constructor that takes no parameters).</li>\r\n  <li><b>ElementType</b> has a destructor &mdash; a necessity because the statically-allocated variable <b>e</b> will be destroyed when it falls out of scope.</li>\r\n  <li><b>ElementType</b> must have a member function <b>foo</b> that takes no parameters, though there is no limitation on what its return type is (since we're not doing anything with the return value).</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">This particular code example</p>\r\n\r\n<p>This code example demonstrates how to write a class template, and how to write function templates that implement member functions of a class template.  The example is of a classs template called <b>Point</b>, which represents a point in a three-dimensional space.  A point is made up of three coordinates (<i>x</i>, <i>y</i>, and <i>z</i>), but the types of these coordinates is flexible; any given point can have coordinates of different types (e.g., <b>double</b>, <b>int</b>, etc.).  So <b>Point</b> is a class template with one parameter, <b>CoordinateType</b>, which specifies the type of each coordinate.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>Templates</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download Templates</b> to download the code example into your project directory's <b>app</b>, <b>core</b>, <b>exp</b>, and <b>gtest</b> directories.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"Templates.tar.gz\">Templates.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}