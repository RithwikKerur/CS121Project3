{"url": "https://www.ics.uci.edu/~thornton/ics45c/Notes/StandardIO/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2019, Notes and Examples: Standard Input and Output</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"../../GradeCalculator\">Grade Calculator</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2019<br />\r\n   Notes and Examples: Standard Input and Output</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>Includes a code example with the moniker <b>StandardIO</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Like most programming languages, C++ provides some built-in mechanisms in its standard library for getting input into a program and output out of it.  There are fewer of these mechanisms built into C++ than you might be used to &mdash; some, like network-based I/O or graphical user interfaces, are supported only in third-party libraries &mdash; but there are some.  Most notably, C++ provides a way to perform I/O via the <i>standard input</i> and <i>standard output</i> of a program, along with file-based I/O.  This example focuses on the standard input, though many of the concepts are also used when dealing with files (except that you also have to deal with issues such as reaching the end of the file or the inability to open a file).</p>\r\n\r\n<p class=\"subtitle\">What are the \"standard input\" and \"standard output\"?</p>\r\n\r\n<p>On most operating systems, when a program is started, it has a handful of input and output streams associated with it by default.  Traditionally, the simplest way to send input into a program is to send it to the program's <i>standard input</i>, while the simplest way to get output from it is for the program to write it to its <i>standard output</i>.  From the program's perspective, the standard input is simply a stream of bytes that the program can consume, and the standard output is simply a stream of bytes that the program can write to.</p>\r\n\r\n<p>The most common arrangement when you run a program on Linux via the shell (e.g., on the ICS 45C VM) is for the standard input and standard output to also be connected to the shell.  On the ICS 45C VM, when you execute a program via the shell prompt by executing the <b>./run</b> script, anything sent to the program's standard output will appear in your shell window, while an attempt by your program to read from its standard input may require you to type something in the shell window with the keyboard.  (Note that it doesn't have to be this way.  When you run a program, you can use a technique called <i>redirection</i> to connect standard input or standard output to other places.  For example, you can have a program read its standard input from a file while writing its standard output to the shell prompt.  Even more powerful is the technique of <i>piping</i>, which allows you to send the standard output of one program into the standard input of another automatically, which enables programs to be connected together in many useful ways, including ways that the original programmers never thought of.)</p>\r\n\r\n<p>In the C++ Standard Library, the standard header <b>&lt;iostream&gt;</b> contains declarations of a variety of things you'd need in order to perform I/O using the standard input and standard output.  Having included that header, you'll have access to the objects and functions described in this example; most notably, you'll have:</p>\r\n\r\n<ul>\r\n  <li>An object called <b>std::cin</b>, which represents the program's standard input.</li>\r\n  <li>An object called <b>std::cout</b>, which represents the program's standard output.</li>\r\n  <li>An object called <b>std::endl</b>, which you can think of as a constant representing an end-of-line sequence that you'd like to write to the standard output.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Writing some simple output to std::cout</p>\r\n\r\n<p>Output streams like <b>std::cout</b> provide the capability to write formatted output, and know intrinsically how to format the built-in types (not just strings, but also integers, doubles, etc.).  As we'll see later this quarter, you can also specify how formatting of your own types is to be done, though we'll need to learn more about specifying our own types before we can go down that road.</p>\r\n\r\n<p>Writing an object to <b>std::cout</b> is most easily done using the <b>&lt;&lt;</b> operator, which, when used on an object stream, is sometimes called the \"put\" operator, because it lets you \"put\" an object on to the stream.  Depending on the object's type, it will be formatted to an appropriate textual representation, then the text will be written to the standard output.  A subsequent use of the <b>&lt;&lt;</b> operator on <b>std::cout</b> will write another object directly afterward, with no spaces included in between them.</p>\r\n\r\n<p>Uses of the <b>&lt;&lt;</b> operator can be strung together into a single expression, so it's not necessary to write a separate line of code for each object you want to output.  You'll want to exercise some judgment about how long your expressions are; a good rule of thumb is not to write lines of code longer than about 80 characters.  (My general rule is not to write code that will require me to horizontally scroll in an editor if I want to read it.  Because different people have editor windows of different width, I tend to aim for about 80-100 characters at the most.)</p>\r\n\r\n<p>To write an end-of-line sequence to <b>std::cout</b>, so that subsequent output will appear at the beginning of the next line, you'd put the object <b>std::endl</b> on to the standard output.</p>\r\n\r\n<p>Putting these ideas together, consider the following code fragment.</p>\r\n\r\n<blockquote><pre>\r\nint i = 3;\r\ndouble d = 12.75;\r\nstd::string s = \"Boo\";\r\n\r\nstd::cout &lt;&lt; i &lt;&lt; d &lt;&lt; s &lt;&lt; std::endl;\r\nstd::cout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; d &lt;&lt; std::endl;\r\n</pre></blockquote>\r\n\r\n<p>This code fragment would write the following text to the standard output:</p>\r\n\r\n<blockquote><pre>\r\n312.75Boo\r\nBoo 12.75\r\n</pre></blockquote>\r\n\r\n<p>A couple of things to note about this:</p>\r\n\r\n<ul>\r\n  <li>There are two lines of output being written and I've chosen to split them into two separate lines of code.  This is not a requirement, per se &mdash; you could write each object on a separate line, or even write all of these objects on a single line &mdash; though I've found that maintaining some sanity in the patterns of code you write to generate output, so that the \"shape\" of the code roughly mirrors the \"shape\" of what you're writing to the output, helps your code to be more understandable.</li>\r\n  <li>Note that there are ways to control formatting more carefully &mdash; e.g., specifying the number of digits to show after a decimal point &mdash; but these aren't important for our current uses, so we'll skip that detail for now, though you can feel free to research that on your own if you're curious.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Reading input from std::cin</p>\r\n\r\n<p>Just as there is an object, <b>std::cout</b>, that represents a program's standard output, the object <b>std::cin</b> represents a program's standard input.  Reading input from <b>std::cin</b> is relatively straightforward, but there are a few things you need to know in order to do so effectively.</p>\r\n\r\n<p>By default, a program's standard input is generally connected to a text-based input device.  For example, when you run a program from a Linux shell prompt, as you would when using the ICS 45C VM, input is typed into the shell window when required.  But you'll need a mental model of how the typed input is processed.  Depending on what languages you've programmed in previously, you may find that you have a mental model, but that it doesn't match the reality in C++.  Reading from the standard input essentially works like this:</p>\r\n\r\n<ul>\r\n  <li>The first time you try to read anything from <b>std::cin</b>, you'll need to type an entire line of input into the shell window.  By \"an entire line,\" I mean you can type anything you'd like and then hit Enter; it's the act of hitting Enter that terminates the line.  All of the input you typed &mdash; including the newline character! &mdash; is stored in an <i>input buffer</i>.</li>\r\n  <li>Each time you read from <b>std::cin</b>, available text in the input buffer is consumed first; if there's enough text available to satisfy the request, that text is consumed and the input operation is completed without user intervention.  If all of the available text has been consumed and the request still isn't satified, you'll need to type another line of text into the shell window.</li>\r\n  <li>You can think of the input buffer as having a <i>cursor</i> that tracks the next character that hasn't yet been read from the input buffer.  As characters are consumed from the input buffer, this cursor moves.  When the cursor reaches the end of the buffer, you'd then need to enter another line of input into the shell window and hit Enter.</li>\r\n</ul>\r\n\r\n<p>There is a <b>&gt;&gt;</b> operator &mdash; in this context, it's often called a <i>get</i> operator &mdash; that allows you to consume a single object (e.g., an integer, a double) from an input stream such as <b>std::cin</b>.  Depending on the type of object you're trying to consume, things will work a little bit differently, but the general rule is that this will skip initial whitespace (like spaces, tabs, and newlines), then greedily consume characters until one is found that isn't intended to be part of the object being built.  If the input buffer is exhausted before the object is fully built, the user will need to enter another line of input into the shell window and press Enter.</p>\r\n\r\n<p>The precise rules for what is consumed depends on the type of variable you're reading input into.  A few examples (with some more esoteric details sometimes left out for brevity) are:</p>\r\n\r\n<ul>\r\n  <li>If you're reading into an <b>int</b> variable, initial whitespace is skipped, then (optionally) a &minus; (minus sign) might be consumed, followed by however many digits appear.  As soon as anything else &mdash; a letter, a space, another minus sign, a dot &mdash; appears, the consuming of input stops and the consumed characters are formed into a corresponding <b>int</b> value.\r\n    <ul>\r\n      <li>If the input buffer had three spaces followed by <b>-407alex</b> followed by a newline character, the spaces would be thrown away, <b>-407</b> would be consumed, the input buffer's cursor would point to the <b>a</b> in <b>alex</b>, and the <b>int</b> value -407 would be stored in the variable.</li>\r\n    </ul>\r\n  </li>\r\n  <li>If you're reading into a <b>double</b> variable, the rules are similar: initial whitespace is skipped, then a number is consumed, but that number might have a decimal point and more digits after it.  The resulting floating-point value would be stored.</li>\r\n  <li>If you're reading into a <b>std::string</b> variable, the next \"word\" (i.e., after skipping whitespace, all characters up to <i>but not including</i> the next whitespace) is stored.</li>\r\n</ul>\r\n\r\n<p>Putting all of these ideas together into a short example, consider this code fragment:</p>\r\n\r\n<blockquote><pre>\r\nint i;\r\ndouble d;\r\nstd::string s;\r\n\r\nstd::cin >> i >> s >> d;\r\n</pre></blockquote>\r\n\r\n<p>If you executed this code fragment and this was the first use of <b>std::cin</b> (or the input buffer is empty), the user would need to type a line of input into the shell window and hit Enter.  Suppose the user typed <b>100 CMG 475.875</b> and hit Enter.  Here's what would happen:</p>\r\n\r\n<ul>\r\n  <li>The text <b>100 CMG 475.875</b> would enter the input buffer, along with a newline character at the end.  The cursor would be pointing to the first character.</li>\r\n  <li>The first attempt to read input is into the <b>int</b> variable <b>i</b>, so the <b>100</b> would be consumed, at which point <b>i</b> will be <b>100</b> and the input buffer's cursor will point to the space immediately following the <b>100</b>.</li>\r\n  <li>The second attempt to read input is into the <b>std::string</b> variable <b>s</b>.  The space under the input buffer's cursor will be skipped, then the word <b>CMG</b> will be consumed.  <b>s</b> will have the value <b>\"CMG\"</b> and the input buffer's cursor will now point to the space immediately following <b>CMG</b>.</li>\r\n  <li>The third attempt to read input is into the <b>double</b> variable <b>d</b>.  The space will again be skipped, then <b>475.875</b> will be consumed.  The value of <b>d</b> will now be <b>475.875</b> and the input buffer's cursor will now point to the newline character immediately following <b>475.875</b>.</li>\r\n  <li>An important detail to understand at this point: The input buffer is not yet empty.  There is still a newline character that hasn't been consumed!</li>\r\n</ul>\r\n\r\n<p>Additionally, the function <b>std::getline(<i>an input stream</i>, <i>a string variable</i>)</b> is a handy tool, albeit one that's a little bit different than the one above.  It consumes all of the text in the input buffer, up until it reaches a newline character, storing all of the text in the given string variable.  Only if the input buffer was <i>completely empty</i> (i.e., nothing, not even a newline character!) will this require a user to type input into the shell window and press Enter.  It's important to understand that this function may store the empty string into the string variable you give it if there is nothing but a newline character in the buffer; this is an important nuance to get right when you mix uses of the <b>&gt;&gt;</b> operator with the <b>std::getline</b> function, but not particularly hard to get right once you understand how things work.  (One important detail to understand is that the newline character appearing at the end of each line of input is considered whitespace, so you'll quite often have a newline character in the input buffer in cases where you might intuitively expect it to be empty.)</p>\r\n\r\n<p>One last tool that can be helpful is a member function you can call on <b>std::cin</b> called <b>ignore</b>, which you can use to skip a certain number of characters in the input buffer.  For example, <b>std::cin.ignore(1)</b> would skip one character in the input buffer (i.e., move the input buffer's cursor forward one character).</p>\r\n\r\n<p>For the time being, we'll ignore input that is erroneous with respect to type, such as the word <b>Boo</b> where an integer is expected, as it's not a particularly interesting problem to solve and requires techniques that can be tedious to get right, though you can certainly feel free to research parsing and error-checking techniques if you're interested in them.  Practical programs are generally written to handle erroneous input in a graceful way, but we need to pick our battles in this course &mdash; we only have ten weeks! &mdash; so we'll leave this one to be fought another time.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>Some of the <a href=\"../../Notes\">Notes and Examples</a> pages this quarter will include a code example that you download and use on your ICS 45C VM.  These code examples include not only code but comments that explain what it's doing and why, so they can be instructive in understanding the concepts that we're learning about.</p>\r\n\r\n<p>When there is a code example, it will have an official <i>moniker</i>, a name that uniquely identifies it and hooks into some automation tools in the ICS 45C VM, which will be listed at the top of the page.  The official moniker of this one is <b>StandardIO</b>.</p>\r\n\r\n<p class=\"subtitle\">Downloading code examples for use on the ICS 45C VM</p>\r\n\r\n<p>If you want to view, compile, and run the code examples on the ICS 45C VM, I've set up some automated tools to make that job easier.</p>\r\n\r\n<p>First of all, you may need to refresh your ICS 45C VM environment, to make sure that you have the necessary project template.  You can do that by issuing this command:</p>\r\n\r\n<blockquote><pre>\r\nics45c refresh\r\n</pre></blockquote>\r\n\r\n<p>Once you've done that, you will have a project template called <b>example</b>, which includes a script called <b>download</b> that can be used to download a code example from the course web site and install it into your project automatically.  Choose a name for your new project, then issue the following commands to start a new project and download the code example into it.</p>\r\n\r\n<blockquote><pre>\r\nics45c start <b><i>YOUR_CHOSEN_PROJECT_NAME</i></b> example\r\ncd ~/projects/<b><i>YOUR_CHOSEN_PROJECT_NAME</i></b>\r\n./download StandardIO\r\n</pre></blockquote>\r\n\r\n<p>Having issued these three commands, the <b>app</b>, <b>exp</b>, and <b>gtest</b> directories in your new project directory should contain all of the header and source files that comprise the code example.  You can use the <b>./build</b> and <b>./run</b> scripts, as usual, to compile and run the example program, and you can use any editor to view it.</p>\r\n\r\n<p>Alternatively, I'll provide a link that will let you download the code example manually, if you'd prefer to view it outside of the ICS 45C VM.  The complete, commented code for this example can be downloaded by clicking the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"StandardIO.tar.gz\">StandardIO.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}