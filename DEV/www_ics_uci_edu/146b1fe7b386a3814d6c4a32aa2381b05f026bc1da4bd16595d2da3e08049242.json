{"url": "https://www.ics.uci.edu/~mayur/killer_app.html", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"DTD/xhtml1-transitional.dtd\">\r\n<html lang=\"en\">\r\n<head>\r\n\r\n<title>Writing the Next Killer Peer-To-Peer (P2P) Application</title>\r\n\r\n<!-- BEGIN META TAG INFO -->\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\r\n<meta name=\"author\" content=\"Mayur Deshpande\">\r\n<link rel=\"index\" href=\"http://www.ics.uci.edu/~mayur/index.html\">\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/fonts.css\" media=\"screen\">\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/print.css\" media=\"print\">\r\n<link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"./images/favicon.ico\">\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/3col.css\" title=\"style\">\r\n<style type=\"text/css\" media=\"all\"></style>\r\n<!-- END META TAG INFO -->\r\n</head>\r\n\r\n\r\n<body>\r\n\r\n<div id=\"banner\">\r\n<h4> Writing That Next Killer P2P App &nbsp;\r\n</h4>\r\n</div>\r\n\r\n\r\n<div id=\"leftcontent\">\r\n<h1>\r\n<a href=\"index.html\"> Home </a>\r\n</h1>\r\n<h1>\r\n<a href=\"Research.html\"> Research </a>\r\n</h1>\r\n<h1>\r\n<a href=\"Software.html\"> Software </a>\r\n</h1>\r\n<h1>\r\n<a href=\"Publications.html\"> Publications </a>\r\n</h1>\r\n<h1>\r\n<a href=\"Industry.html\"> Industry </a>\r\n</h1>\r\n<h1>\r\n<a href=\"Mayur_Resume.pdf\"> Resume </a>\r\n</h1>\r\n<h1>\r\n<a href=\"http://flashback.calit2.uci.edu\"> Flashback! </a>\r\n</h1>\r\n</div>\r\n\r\n\r\n<div id=\"centercontent\">\r\n<h2>::Introduction</h2>\r\n<p>\r\nSo, you have the idea for the next killer P2P app. How do you go about building it?\r\nAnd testing it?\r\n<br>\r\nThis is a chronicle (of some sorts) where I explore how one might\r\ngo about building and testing a P2P app. This is the path that I took and it may/not\r\nbe the best way for your needs, but in the least it should serve as a guide for some\r\nof the difficulties and tradeoffs involved.\r\n<br>\r\nThis is reverse chronological. So first, I describe how one can test and get some concrete\r\nnumbers on how the app might behave in the real world. Next (or before), how to simplify\r\nthe building process using middleware. And of course, the all important question of\r\nwhich programming language to use ;-)  Other `side' issues will be discussed as and when\r\nappropriate.\r\n<br>\r\nNote: I just started writing out this and it'll be continually updated over time (hopefully :)\r\nso, this page has the cliched `under construction indefinitely' tag.\r\n</p>\r\n\r\n<h2>::Testing the app</h2>\r\n<p>\r\nNothing is as important as getting that warm fuzzy feeling that your app will run\r\nperfectly on an Internet scale. So, short of recruiting zombie machines, how does one\r\ntest a distributed app?\r\n<br>\r\nSpending a couple of thousand (green) bucks will get you the required hardware to set up\r\na fairly decent WAN (Wide Area Network) emulator. Such a setup\r\nallows you to run hundreds of your application instances on `virtual nodes' and data traffic\r\nis shaped underneath by the emulator in real time. No change is required on part of the application\r\nto run on the emulator. I describe one such emulator, Modelnet, in more detail\r\n<a href=\"model-net-details.html\"> here</a>.\r\n<br>\r\nFor Modelnet, you will need one beefy machine and as many smaller machines as you can afford. Plus,\r\na gigabit switch (a decent 16-port one costs around $200). In my current setup I have one Dell 2-cpu,\r\n2.6Ghz machine and 4 Dell PowerEdge machines running at 2.8Ghz. The four Powerdge machines cost less\r\nthat $1,200 together! It is also worthwhile to beef up the RAM on the main emulator machine (2-4GB would\r\nbe neat). And make sure all machines have gigabit NIC cards.\r\n</p>\r\n\r\n<h3>How much hardware? </h3>\r\n<p>\r\nAn important point in deciding how much hardware you need for a good wamm fuzzy feeling\r\nis deciding what target machines the final P2P will run it: desktop machines on a LAN,\r\nPCs on DSL and cable, PCs on dial-up or all of the above. There are multiple constraints\r\nof network bandwidth on one machine, the router, CPU usage and RAM which dictate how many\r\nvirtual nodes you can run on one physical machine and how many virtual nodes you can run in\r\ntotal. Plus, the nature of the appplication plays a role as well: is the application more I/O\r\nbound or CPU bound? There is no easy answer for this but an example may provide some rules of thumb.\r\n</p>\r\n<h3>Example of Tradeoffs</h3>\r\n<p>\r\nSuppose you wanted to emulate nodes that all sit on 10Mbps interfaces. Then, if each machine has a gigabit\r\ninterface, you will be able to run 100 instances of your application on one machine (theoretically) before\r\nthe NIC bandwidth becomes the bottleneck. More than likely in this situation, running 100 instances of the\r\napplication on one machine will invoke the OS scheduler pretty often. This is more than likely to impact the\r\nfinal results. Moreover, depending upon the application and the RAM space, the OS may actually place some\r\napps on the swap space: this is disastrous for timing results. So, when you run many instances of your app\r\non a node, the first thing you want to check is that the swap is not being hit.\r\n<br>\r\nSo, you now figure out that you can run 25 processes on a node before you hit the swap space. This means,\r\nthe total data generated by all the virtual nodes is now 250Mbps; you still have 750Mbps leftover. The next\r\nstep is obvious: get three more machines and run 25 apps on each of them: now you are still under\r\nthe bandwidth bottlneck, not on the individual NIC cards but of that of the router. Plus, you are not hitting\r\nthe swap space.\r\n<br>\r\nNext, you check, the CPU usage on each of the individual PCs. Ideally, you would like to stay below 10% of\r\nCPU usage on each machine. If your apps are CPU intensive and your CPU usage is high when you run 25 instances,\r\nthen you know what to do: run less number of instances on each machine and buy more machines.\r\n<br>\r\nIn most cases, P2P apps are more I/O bound than CPU bound i.e. the network bandwidth is the usual bottleneck.\r\nYou would easily be able to run 40 application instances without significantly using up CPU. Additionally, the\r\nTCP/IP stacks have improved considerably in scalability and performance; you can do large amounts of\r\ndata transfers with very little CPU help.\r\n</p>\r\n\r\n\r\n</div>\r\n\r\n\r\n\r\n<div id=\"rightcontent\">\r\n<h2> Links</h2>\r\n<p>\r\n<a href=\"model-net-details.html\">WAN Emulator</a>\r\n<br>\r\n<a href=\"\">C++ or (Java/Python/...)?</a>\r\n<br>\r\n<a href=\"\">RPC Middleware</a>\r\n<br>\r\n</p>\r\n</div>\r\n\r\n\r\n<script src=\"http://www.google-analytics.com/urchin.js\" type=\"text/javascript\">\r\n</script>\r\n<script type=\"text/javascript\">\r\n_uacct = \"UA-556186-1\";\r\nurchinTracker();\r\n</script>\r\n\r\n\r\n<!-- START INCLUDED FOOTER -->\r\n<center>\r\n<br>\r\n<br>\r\n<br>\r\n<span class=\"G9G\"><a href=\"http://validator.w3.org/check?uri=referer\" title=\"W3C HTML Validation\" target=\"_blank\">HTML</a> &#8226; <a href=\"http://jigsaw.w3.org/css-validator/check/referer/\" title=\"W3C CSS Validation\" target=\"_blank\">CSS</a> &#8226; <a href=\"http://bobby.watchfire.com/\" title=\"U.S. Section 508 Accessibility\" target=\"_blank\">508</a></span>\r\n\r\n<br>\r\n<!-- END INCLUDED FOOTER -->\r\n</body>\r\n</html>\r\n</center>", "encoding": "ascii"}