{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/13.lca", "content": "Least common ancestor problem\n\nProblem statement\n\nHistory:\n\tHarel (ICS grad student) & Tarjan, 1984\n\tSchieber-Vishkin simplification 1988\n\t...more work e.g. parallel algorithms...\n\tBender & Farach-Colton 2000\n\t\t(linked to on course web page)\n\nRange minimization problem statement\n    with integer range endpoints, or (next week) integer searching strux\n\nCartesian tree = heap-ordered binary tree on input sequence\n\n    Range min = LCA(endpoints) in Cartesian tree\n\tbuild tree by inserting in sorted order, then\n\t    values earlier than LCA don't split endpoints\n\t    LCA does split them (so is in range)\n\t    values later than LCA are larger\n\n    Efficient construction of Cartesian tree\n\n\tparent(x) = larger of nearest smaller values on left,right\n\n\tdef nearest_smaller(L):\n\t    make empty stack\n\t    for x in L:\n\t\twhile stack and stack top > x:\n\t\t    pop stack\n\t\tleft neighbor of x = stack top\n\nExample: 3,1,4,0,5,9,2,6\n\n\nConversion in the other direction: LCA->Range min\nGiven tree T\nform arrays:\n\tE[i] = i'th node in Euler tour of T\n\t\tE for Euler\n\tL[i] = level of i'th node in tour\n\t\tL for level\n\tR[i] = pos of 1st occurrence of tree node i in the tour\t\n\t\tR for representative\n\n\tthen: LCA[x,y] = shallowest node of tour between R[x] and R[y]\n\t\t(tour visits path and some descendants, descs are lower)\n\n\t\t= E[z] where z = argmin_{min(R[x],R[y]) <= i <= max} L[i]\n\n\nThis is a special range min problem!\nLevels change by +/- 1 at each step\n\nFrom now on, consider this special problem on array X[i] of n numbers\n\nSolutions:\n    - array Q[x,y] stores answer (X[i],i) for query x,y\n\tspace O(n^2), query time O(1)\n\n    - array QQ[x,i], 0<=i<=log n, stores A[x,x+2^i]\n\tspace O(n log n), query time 1:\n\t\tlet 2^i <= y-x <= 2^{i+1}\n\t\tthen Q[x,y] = min(QQ[x,i], QQ[y-2^i,i])\n\n    - partition X into 2n/log n blocks of <= (log n/2) values each\n\tlet A[i] = min(block i)\n\t\n\tto handle query x<y where x and y are in DIFFERENT blocks:\n\t\tfind min(rest of x's block) [precompute for each x]\n\t\tfind min(start of y's block) [precompute for each y]\n\t\tuse QQ on array A (space O(n), time O(1))\n\n\tto handle queries within a single block:\n\t    normalize each block by subtracting first block value\n\t\t(so block value sequence goes 0, +-1, ...)\n\t\tdoesn't change block value\n\n\t    2^{(log n)/2} = sqrt n possible different blocks\n\t\t(binary choice +/- 1 for each value)\n\t\n\t    precompute table of all possible blocks,\n\t\tuse Q solution for each precomputed block,\n\t\tmake index pointing from each data block to its\n\t\t\tprecomputed solution\n\t\tspace O(sqrt n log n), time O(1)\n", "encoding": "ascii"}