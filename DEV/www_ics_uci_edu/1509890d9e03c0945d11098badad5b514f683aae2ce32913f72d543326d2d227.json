{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990525.txt", "content": "Advanced Collections Minutes - May 25, 1999\n\nAttending: Judy Slein, Jim Whitehead, Geoff Clemm, Jason Crawford, Chuck Fay\n\nACTION ITEMS\n\nJim W: Revise definitions / write text to explain how the definitions\nrelate to RFC 2518.\n\nJudy: Revise proposed language for LOCK and MOVE / DELETE.\n\nJudy: Try to draft an operational definition of the integrity constraints on\nbindings.\n\nMISCELLANEOUS LOGISTICS\n\n6/25 submit spec and requirements to Internet Drafts\nIron out major issues by 6/8 meeting if possible, then edit for 2 weeks\nSubmit on 6/25 even if there are outstanding issues or inconsistencies\n\nGeoff is presenting the advanced collections spec to the versioning\nteam tomorrow.\n\nGeoff is willing to lead a session on the advanced collections spec at\nthe Oslo IETF.  Jim will try to schedule a session.\n\nTERMINOLOGY: INTERNAL MEMBERS VS. MEMBERS\n\nGeoff: We need to be able to distinguish between immediate members and\nall members at whatever depth (transitive closure of members)\n\nWe could use \"internal members\" for members at depth 1, \"members\" for\nmembers at any depth.\nOr we could use \"members\" for depth 1, and some other term for\nmembers at all depths.\n\nLet's stick with the terminology people are used to.\n\n\"Internal\" in RFC 2518 was supposed to distinguish internal from external \nmembers (resources that are referenced and really reside in a different \ncollection hierarchy).  \"Internal\" is really obsolete now, as referencing / \nbindings have evolved.\n\nKeep using it because people are used to it. \n\n\"Internal\" gives the sense that it's part of the collection's state, which\nis not what we intend.\n\nCan we use plain \"member\" to mean the whole hierarchy?  There is the danger\nthat people will map \"member\" to \"internal member\". We want an adjective to \ngo with it when we are talking about the transitive closure of members. \n\nCandidates:\n\ninternal members vs. transitive members, member by itself is either\n\ndeep members, depth members\n\nancestor / descendent, parent / child\n\nAGREED: We will always use a qualified form, either \"internal\nmember\" or \"transitive member\". \n\nWHAT ARE COLLECTION MEMBERS?\n\nIn RFC 2518 a collection member is a URL.  A binding is *not* just a URL.\nA binding is an association between a URL segment and a resource.\n\nGeoff: Let's not talk about member bindings.  Members are neither bindings\nnor segments, but absolute (or maybe relative) URLs.\n\nJudy: If members are not bindings, but bindings are part of the state of\ncollections, then we have redundant or overlapping state. It would be strange to say\nthat a collection's membership is not part of its state.  There's a dependency\nbetween one end of a binding and a member URL. \n\nJim W: If we say that a member is an absolute URL, how do we decide which\none?  Any binding may generate many mappings. \n\nGeoff: The member is the URL that is induced by the URL of the collection.\nThere may be many member URLs for a single binding.  If a collection is \nidentified by URLs /x/ and /y/, the members of /x/ are /x/a and /x/b, and\nthe members of /y/ are /y/a and /y/b.  The member names are induced by \nthe collection name.\n\nGeoff: PROPFIND returns one URL for each member.  It is the URL that is the \nparent collection's URL (determined by the request-URI) + segment.  It's\nok to allow PROPFIND to return relative URLs.\n\nJim W: Doesn't want members to be relative URLs. RFC 2518 wants full URLs.\n\nJim: if we want to preserve member to be full URL, how do we define member?\n\nWe need to make it clear what the relationship is between member and binding.\n\nA member is not part of the state of anything. It just shows up in reports.\nA collection's state is a set of bindings, not its members.\nA member URL is not part of the state of a collection. (arbitary, infinite set of URLs\nthat identify members -- pick one relative to request-URI)\n\nDon't let people think that the strings that came back from PROPFIND are \npart of the state of a collection.\n\nPeople tend to think the members are the URLs, the mapping names.  Bindings induce\nthese URLs in a predictable way.  The binding is the underlying thing.\n\nRFC 2518 says that collection members are URIs \n\nAre the member URIs relative or absolute? In RFC 2518, they were immediately\nrelative to the URI of the collection.\n\nGeoff can live with either relative or absolute.\n\nMust distinguish between a list of segments and a list of bindings.  If you \nassociate the same segment with a different resource, you've changed the \nstate of the collection. Make sure people know the state is a set of bindings, \nnot a set of segments.\n\nGeoff: There aren't any free-floating bindings.  All bindings are part of the state\nof some collection.\n\nJason: We may need to keep the term \"member bindings\" to contrast with \nthe bindings of the collection to its parents.\n\nWe need to decide what kinds of things the members of a collecton are: bindings\nor URIs.\n\nConsistency with RFC 2518 would mean we say that collection members are URIs.\n\nAdd a paragraph on how bindings are related to collection members.\n\nJim W: Keep definitions basically as they are. Just talk about how they are\nrelated to RFC 2518.\n\nGeoff: Use \"member\" to be the thing that's in a collection, and explain\nthe relationship of that thing to bindings, URIs, etc.\nTell people how to read RFC 2518: the member URIs are not the collection's\nstate; bindings are.\n\nACTION: Jim W will write modifications to definitions or text to go around the \ndefinitions, might get rid of \"member binding\".\n\nALL-BINDINGS HEADER\n\nYaron didn't protest about All-Bindings.  Probably no one else thought about it.\n\nJim W: The only problem with an All-Bindings header is that if a server doesn't \nunderstand All-Bindings, it will ignore the header and will still return 2xx.\nBut since the server is doing less than it claims, that's probably ok.  \n\nGeoff: You can only create multiple bindings BIND, so any server that doesn't\nunderstand All-Bindings won't have multiple bindings to the same resource\nanyhow.\n\nJudy: No, you could create them out-of-band.\n\nGeoff: You can only create mappings out-of-band, not bindings.\n\nJim W: A binding is like a resource, it's an abstraction. So there can be \nout-of-band ways to create them.\n\nJudy: Anyhow, I'm ok with servers that don't understand All-Bindings reporting\nsuccess.\n\nAdd All-Bindings to the spec. AGREED.\n\nLOCK AND DELETE/MOVE\n\nJim W: Thought we agreed in e-mail that the least restrictive requirement to \ninsure the mapping used in the LOCK request stays intact is the right thing.\n\nJim W: Agrees with Geoff that it's better not to talk in terms of locking \nbindings.  Just say that a LOCK acts to preserve the mappings.\n\nLeave it up to the server to decide how to make that happen.\n\nFollow Geoff's suggestion to get rid of language about bindings.\n\nACTION: Judy will revise her proposed language.\n\nINTEGRITY OF BINDINGS\n\nRoy noted that a URI can end up pointing to different things over \nits lifetime.  \n\nJudy: Right.  The text I drafted isn't expressed very well.  I think what's really\ntrue is that the identity of a binding is determined by the segment (in its\ncollection) and the resource that the binding associates.  If the same segment gets \nassociated with a different resource, that means the original binding was destroyed and\na different binding now exists.  So what I want to guarantee is that once created,\na binding will not be destroyed except by a DELETE request on a mapping induced\nby that binding.\n\nGeoff: This is not verifiable via the protocol, so can't be interpreted consistently.\n\nJim: We need an operational definition.\n\nJudy will try again, for an operational definition.\n\nlate binding / early binding -- late binding means underlying resource can be \ndifferent\nwarn that there may be late binding\n\nWhat are we trying to help the server implementer to do?\n\nJust say in DELETE section that if you delete a binding, resource continues \nto return the entity for requests through the remaining bindings.\n\nJudy: The problem is that for off-server bindings, the server where the resource\nlives may think there are no more bindings (and so think it's ok to do\ngarbage collection) when there are still off-server bindings to the resource.\nSo the server where the binding lives bears some responsibility for guaranteeing\nintegrity.\n\nOperationally, you are trying to make sure that certain DELETEs don't happen \nor certain BINDs don't happen, so say\n   Fail the DELETE unless . . .\n   Fail the BIND unless . . .\nThere's only a problem for multiple bindings, so only need to talk about it\nin the context of BIND (the only way you can get multiple bindings to the same\nresource).\n\nThe client needs to understand why its getting a certain status back.\n\nJudy ACTION: Send mail describing what cases do you want to prevent, try \nwriting a minimal set of rules, or propose language for the spec.\n\nJUDY'S ISSUE #4: SEMANTICS OF BINDINGS\n\nAll the parts of this have been addressed except the question whether there\nis any difference between COPY as defined in RFC 2518 and COPY as we define\nit.\n\nGeoff: The semantics are the same.\n\nJim W: It's worth saying that when you do a copy, don't duplicate all the \nbindings at the destination.\n\nGeoff: You just create a new resource, and a new binding to it.\n\nJudy: Didn't want to suggest removing anything Jim had included, but just perhaps\nto point out that there is really no change in the semantics, just a change in\nvocabulary.\n\n", "encoding": "ascii"}