{"url": "https://www.ics.uci.edu/~aburtsev/143A/2017fall/hw/hw1-shell.html", "content": "<HTML>\n<HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">\n<TITLE>143A Principles of Operating Systems</TITLE>\n<LINK HREF=\"./css/main.css\" TYPE=\"text/css\" REL=\"stylesheet\">\n<META NAME=\"Description\" CONTENT=\"Home page of Anton Burtsev.\">\n<META NAME=\"Keywords\" CONTENT=\"Anton Burtsev, Burtsev, Anton, cs5460\">\n<SCRIPT SRC=\"./scripts/image_switcher.js\" LANGUAGE=\"JavaScript\"></SCRIPT>\n</HEAD>\n\n<BODY BGCOLOR=\"#FFFFFF\" LEFTMARGIN=\"0\" TOPMARGIN=\"0\" MARGINWIDTH=\"0\" MARGINHEIGHT=\"0\">\n\t<TABLE  ID=\"text\" ALIGN=\"CENTER\" WIDTH=\"600\" BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD>\n\t\t<DIV ID=\"tech_nav\">\n\t\t\t<A HREF=\"../index.html\">Home</A>\n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"30\" ALT=\"\" BORDER=\"0\"/>\n\t\t</DIV>\n\t</TD>\n\t</TR>\t\n\t<TR>\n\t<TD COLSPAN=\"4\" ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\">\n\n\n\t\t<P>\n\n<h1>Homework 1: shell</h1>\n\n<p>This assignment will make you more familiar with the Unix system call\ninterface and the shell by implementing several features in a small shell, which\nwe will refer to as the 143A shell.  You can do this assignment on any\noperating system that supports the Unix API (Linux andromeda-XX.ics.uci.edu machines, your laptop\nwith Linux or MacOS, etc.).  Submit your 143A shell through Canvas <a\n href=\"https://canvas.eee.uci.edu/courses/6422\">Canvas HW1 Shell</a>\nsee instructions at the bottom of this page. \n\n<p>Read Chapter 0 of the <a href=\"https://pdos.csail.mit.edu/6.828/2016/xv6/book-rev9.pdf\">xv6 book</a>.\n\n<p>If you are not familiar with what a shell does, do the <a\nhref=\"http://web.mit.edu/6.033/2015/wwwdocs/assignments/handson-unix.html\">Unix\nhands-on</a> from 6.033 class at MIT (this is optional and will not be graded in 143A). \n\n<p>Download the <a href=\"sh.c\">143A shell</a>, and look it\nover. The 143A shell contains two main parts: parsing shell commands and\nimplementing them. The parser recognizes only simple shell commands such as the\nfollowing:\n\n<pre>\nls > y\ncat < y | sort | uniq | wc > y1\ncat y1\nrm y1\nls |  sort | uniq | wc\nrm y\n</pre>\nCut and paste these commands into a file <tt>t.sh</tt>\n\n<p>To compile <tt>sh.c</tt>, you need a C compiler, such as gcc.  On openlab.ics.uci.edu, you\ncan compile the skeleton shell as follows:\n<pre>\n$ gcc sh.c\n</pre>\nwhich produces an <tt>a.out</tt> file, which you can run:\n<pre>\n$ ./a.out < t.sh\n</pre>\nThis execution will print error messages because you have not implemented several features. In\nthe rest of this assignment you will implement those features.\n\n<h2>Executing simple commands</h2>\n\n<p>Implement simple commands, such as:\n<pre>\n$ ls\n</pre>\n\n<p> The parser already builds an <tt>execcmd</tt> for you, so the only code you\nhave to write is for the ' ' case in <tt>runcmd</tt>. You might find it useful\nto look at the manual page for exec; type \"man 3 exec\", and read about\n<tt>execv</tt>.  Print an error message when exec fails.\n\n<p>To test your program, compile and run the resulting a.out:\n<pre>\n143A$./a.out\n</pre>\n\nThis prints a prompt and waits for input.  <tt>sh.c</tt> prints as prompt\n<tt>143A$</tt> so that you don't get confused with your computer's shell.\n\nNow type to your shell:\n<pre>\n143A$ ls\n</pre>\n\n<p>Your shell may print an error message (unless there is a program named\n<tt>ls</tt> in your working directory or you are using a version\nof <tt>exec</tt> that searches <tt>PATH</tt>).  Now type to your shell:\n\n<pre>\n143A$ /bin/ls\n</pre>\n\n<p>This should execute the program <tt>/bin/ls</tt>, which should print out the\nfile names in your working directory.  You can stop the 143A shell by typing\nctrl-d, which should put you back in your computer's shell.\n\n<p>You may want to change the 143A shell to always try <tt>/bin</tt>, if the program\ndoesn't exist in the current working directory, so that below you don't have to\ntype \"/bin\" for each program.  If you are ambitious you can implement support\nfor a <tt>PATH</tt> variable.\n\n<h2>I/O redirection</h2>\n\n<p>Implement I/O redirection commands so that you can run:\n<pre>echo \"143A is cool\" > x.txt\ncat < x.txt\n</pre>\n\n<p>The parser already recognizes \">\" and \"<\", and builds a <tt>redircmd</tt> for\nyou, so your job is just filling out the missing code in <tt>runcmd</tt> for\nthose symbols. You might find the man pages for open and close useful.\n\n<p>Note that the <tt>mode</tt> field in <tt>redircmd</tt> contains access modes\n  (e.g., <tt>O_RDONLY</tt>), which you should pass in the <tt>flags</tt>\n  argument to <tt>open</tt>; see <tt>parseredirs</tt> for the mode values that\n  the shell is using and the manual page for <tt>open</tt> for\n  the <tt>flags</tt> argument.\n\n<p>Make sure you print an error message if one of the system calls you are using fails.\n\n<p>Make sure your implementation runs correctly with the above test input.  A\ncommon error is to forget to specify the permission with which the file must be\ncreated (i.e., the 3rd argument to open).\n\n<h2>Implement pipes</h2>\n\n<p>Implement pipes so that you can run command pipelines such as:\n<pre>\n$ ls | sort | uniq | wc\n</pre>\n\n<p>The parser already recognizes \"|\", and builds a <tt>pipecmd</tt> for you, so\nthe only code you must write is for the '|' case in <tt>runcmd</tt>.  You might\nfind the man pages for pipe, fork, close, and dup useful.\n\n<p>Test that you can run the above pipeline. The <tt>sort</tt> program may be in\nthe directory <tt>/usr/bin/</tt> and in that case you can type the absolute\npathname <tt>/usr/bin/sort</tt> to run sort.  (In your computer's shell you can\ntype <tt>which sort</tt> to find out which directory in the shell's search path\nhas an executable named \"sort\".)\n\n<p>Now you should be able to run the following command correctly:\n<pre>\n143A$ a.out < t.sh\n</pre>\n\n<p>Make sure you use the right absolute pathnames for the programs.\n\n<p>Don't forget to submit your solution through \nCanvas <a href=\"https://canvas.eee.uci.edu/courses/6422\">Canvas HW1 Shell</a>\n(as a source file \"sh.c\"). If you decide to submit a challenge exercise submit a \nsource file \"sh-extra.c\" and a shell script \"extra.sh\" that contains an example \nextra command that your shell can handle. Please write me a comment at the top of \n\"sh-extra.c\" explaining  which extra features you decided to handle. \n\n<h2>Challenge exercises (extra 21%, 7% each)</h2>\n\n<p>You can add any feature of your choice to your shell.  But, you may want to consider\nthe following as a start:\n<ul>\n<li> Implement lists of commands, separated by \";\"\n<li> Implement sub shells by implementing \"(\" and \")\"\n<li> Implement running commands in the background by supporting \"&\" and \"wait\"\n</ul>\nAll of these require making changes to the parser and the <tt>runcmd</tt>\nfunction.\n\n\n\t</TD>\t\t\t\n\t</TR>\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD COLSPAN=\"4\">\n\t\t<DIV ID=\"tech\">Updated: October, 2017</DIV>\n\t</TD>\n\t</TR>\n\t</TABLE>\n</BODY>\n</HTML>\n\n", "encoding": "ascii"}