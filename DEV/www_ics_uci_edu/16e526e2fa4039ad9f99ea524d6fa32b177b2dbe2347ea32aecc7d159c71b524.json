{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/draft-ietf-webdav-collection-reqts-02.txt", "content": "     WEBDAV Working Group                       J. Slein, Xerox Corporation\n     INTERNET DRAFT                             J. Davis, Xerox Corporation\n     <draft-ietf-webdav-collection-reqts-02>                  July 20, 1998\n     Expires January 20, 1999\n\n          Requirements for Advanced Collection Functionality in WebDAV\n\n     Status of this Memo\n\n        This document is an Internet-Draft. Internet-Drafts are working\n        documents of the Internet Engineering Task Force (IETF), its\n        areas, and its working groups. Note that other groups may also\n        distribute working documents as Internet-Drafts.\n\n        Internet-Drafts are draft documents valid for a maximum of six\n        months and may be updated, replaced, or made obsolete by other\n        documents at any time. It is inappropriate to use Internet-Drafts\n        as reference material or to cite them other than as \"work in\n        progress\".\n\n        To view the entire list of current Internet-Drafts, please check\n        the \"1id-abstracts.txt\" listing contained in the Internet-Drafts\n        Shadow Directories on ftp.is.co.za (Africa), ftp.nordu.net\n        (Northern Europe), ftp.nis.garr.it (Southern Europe),munnari.oz.au \n        (Pacific Rim), ftp.ietf.org (US EastCoast), or ftp.isi.edu (US West\n        Coast).\n\n        Distribution of this document is unlimited. Please send comments\n        to the Distributed Authoring and Versioning (WebDAV) working group\n        at <w3c-dist-auth@w3.org>, which may be joined by sending a\n        message with subject \"subscribe\" to <w3c-dist-auth-\n        request@w3.org>.\n\n        Discussions of the WEBDAV working group are archived at URL:\n        <http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\n     Abstract\n\n        The base WebDAV protocol [Goland et al., 1998] provides basic\n        support for collections.  It defines a MKCOL method for creating\n        collections and specifies how other HTTP and WebDAV methods\n        interact with collections.  It supports internal members of\n        collections, which it defines as members whose URIs are\n        immediately relative to the URI of the collection.\n\n        This draft sets out requirements for more advanced, optional\n        collection functionality. It extends the base functionality in two\n        general directions: support for referential members, and support\n        for ordered collections.  A separate WebDAV specification is\n        expected to define protocol elements providing the functionality\n        described here.\n\n     1  Terminology\n\n        The terminology used here follows and extends that in the base \n        WebDAV protocol specification [Goland et al., 1998].\n\n\nSlein & Davis                                                    Page 1\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n        Collection\n           A resource that contains member resources\n\n        Member Resource\n           A resource contained by a collection\n\n        Referential Resource (or Reference)\n           A resource that has no content of its own, but rather is\n           a reference to another resource\n\n        Ordinary Resource\n           A resource that is not a reference to another resource\n\n        Target Resource\n           The resource referenced by a referential resource\n\n        Direct Reference\n           A reference that has the property that operations on it are\n           passed through to its target\n\n        Indirect Reference\n           A reference that has the property that operations on it do\n           not affect its target\n\n        Strong Reference\n           A reference whose referential integrity is guaranteed by the\n           server\n\n        Weak Reference\n           A reference whose referential integrity is not guaranteed by the\n           server\n\n        Referential Integrity\n           A server guarantees the integrity of a reference if it ensures\n           that the reference will not be broken, or enables the\n           reference's owner to ensure that the reference will not be\n           broken.\n\n     2  Introduction and Rationale\n\n        The simple collections that the base WebDAV specification supports\n        are powerful enough to be widely useful.  They provide for the\n        hierarchical organization of resources, with mechanisms for\n        creating and deleting collections, copying and moving them,\n        locking them, adding resources to them and deleting resources from\n        them, and getting listings of their members.  Delete, copy, move,\n        list, and lock operations can be applied recursively, so that a\n        client can operate on whole hierarchies with a single request.\n\n        Many applications, however, need more powerful collections.  There\n        are two areas in particular where more powerful functionality is\n        often needed: referential members and ordering.  This draft\n        details the additional functionality that is needed in these two\n        areas.\n\n\nSlein & Davis                                                    Page 2\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n     2.1  Referential Resources\n\n        Referential resources make it possible for many collections, on the\n        same or different servers, to share the same resource.  Because\n        the collections share the resource by referencing it, only one\n        physical copy of the resource need exist, and any changes made in\n        the resource are visible from all the collections that reference\n        it.\n\n        So, for example, the mathematics department at one university can\n        create a collection of resources on fractals that contains some\n        local resources, but also references resources at several other\n        universities.\n\n        A manufacturing company develops and maintains its product\n        maintenance manuals on the Web, with a separate collection for\n        each product manual.  Each manual is divided into sections, one\n        section for every product component.  Since many of the company's\n        products contain some of the same components, many of the product\n        maintenance manuals have sections in common.  Each manual may have\n        some unique sections, which are internal members of its\n        collection.  But for product components that are common to\n        multiple products, the manual has a referential member that\n        references a resource in a shared library.\n\n        Strong references and weak references are both useful in different\n        contexts.  Some applications cannot tolerate broken links.\n        A software development application, for example, must be able to\n        rely on the integrity of references to component modules.  Such\n        applications must be able to request strong references.  Other\n        applications may want to reference target resources on multiple\n        servers, where referential integrity cannot be guaranteed, and may\n        be less concerned about possible broken references.  Both strong\n        references and weak references should eventually be supported by\n        WebDAV, although the complexities of enforcing referential\n        integrity make it unlikely that strong references will be supported\n        in the short term.\n\n        Similarly, both indirect and direct references may be useful.  Each\n        of these types of references is implemented in existing systems.\n        Existing HTTP servers are capable of supporting both types of\n        references.  In effect, indirect references give clients access to\n        the reference itself, and allow the reference to bear properties.\n        Direct references, once created, simplify access to the target\n        resource by hiding from clients the fact that there is a reference\n        mediating between the client and the target resource.  Although it\n        is desirable for WebDAV to support both indirect and direct\n        references, the difficulties of supporting direct references make\n        it unlikely that they will be supported in the short term.\n\n     2.2  Ordered Collections\n\n        For many applications, it is useful to be able to impose an\n        ordering on a collection.  In the product manual application\n        above, the sections of each manual may be ordered so that they can\n\nSlein & Davis                                                    Page 3\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n        be printed together as a book.  A configuration management\n        application might use a collection to represent a version series,\n        in which case the \"derives from\" relationship might be represented\n        as an ordering on the collection.\n\n        A collection ordering may sometimes be based on property values.\n        An example of such an ordering is one that is alphabetical by\n        author's last name, or one from most recent to oldest last-\n        modified-date.  An ordering need not be based on property values,\n        however.  A professor may order a collection of course readings in\n        the sequence that makes sense to coordinate them with her lectures,\n        where there is no property on the member resources that could be\n        used to create this ordering.  This set of requirements is\n        primarily concerned with orderings that are not based on property\n        values.\n\n        Another useful distinction is between server-maintained and\n        client-maintained orderings.  In server-maintained orderings, the\n        server enforces the semantics of the ordering by placing each\n        collection member at the appropriate position in the ordering;\n        clients cannot alter the ordering.  In client-maintained orderings,\n        the client places each collection member in the ordering based on\n        its understanding of the semantics of the ordering; the server\n        does nothing to validate the client's positioning of the member\n        in the ordering.  This set of requirements is concerned only with\n        client-maintained orderings.\n\n        WebDAV already provides tools that could be used for creating and\n        maintaining ordered collections.  For example, using only the base\n        WebDAV specification, an application could create a WebDAV property\n        called \"Order\" on a collection resource.  The value of this\n        property might be a list of the URIs of the collection members.\n\n        What the base WebDAV specification does not do is standardize a\n        single way to represent orderings for collections.\n\n        Different applications and services should be able to operate on\n        the same collection without private agreements about how to manage\n        and examine its order.  To make this possible, there needs to be a\n        standard way to manipulate and retrieve the order of a collection,\n        and a standard representation of the ordering.\n\n        In any situation where collaborative management of a collection\n        takes place, and different authoring tools or WebDAV servers might\n        be used by the collaborators, standardization is important.  It is\n        also important where a different tool may be used to view the\n        collection from the one that was used to create it.\n\n        So for example, two users from different organizations, using\n        different authoring tools, are working together to create a\n        collection.  One of the tools uses a property on the collection\n        called \"Order\" to store an ordering of the collection.  The other\n        tool uses a property on the member called \"SequenceNumber\".  If\n        each user adds some members to the collection, there will be no\n        reliable ordering.\n\nSlein & Davis                                                    Page 4\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n\n     3  Requirements\n\n     3.1  Referential Resources\n\n        Requirements 3.1.1 - 3.1.7 apply to referential resources in\n        general.  Requirements 3.1.8 - 3.1.10 apply to referential \n        resources only in the context of collections.  Requirements\n        3.1.11 - 3.1.14 apply only to indirect references.  Requirements\n        3.1.15 - 3.1.17 apply only to direct references.  Requirements\n        3.1.18 - 3.1.20 relate to strong references and guarantees of\n        referential integrity.  The initial release of the WebDAV\n        collections protocol specification is expected to focus on indirect\n        references and weak references.  It is not expected to satisfy\n        either the requirements for strong references or the requirements\n        for direct references.\n\n     3.1.1  A single target resource may be referenced by multiple\n            referential resources.\n\n        This is the primary benefit that referential resources bring.\n        They allow resources to be shared by multiple collections, which\n        may reside on the same server as the shared resource or on other\n        servers.\n\n     3.1.2  It is possible to create a referential resource.\n\n     3.1.3  It is possible to delete a referential resource.\n\n        It is important to note that this is a different operation from\n        deleting the referential resource's target resource.  It must\n        be possible to delete a reference without deleting its target.\n\n     3.1.4  A referential resource is itself a resource.\n\n        This makes explicit what is suggested by several of the other\n        requirements.  Requirement 3.1.14 in particular, that indirect\n        references carry their own properties, forces referential resources\n        to be resources.  WebDAV properties can belong only to resources.\n\n     3.1.5  Operations on a target resource do not affect references to it\n            except as needed to enforce referential integrity.\n\n        We do not expect operations on a target to affect references to\n        it.  For indirect references, locking a target does not cause the\n        indirect references to it to be locked.  Modifying the properties\n        of a target does not cause changes in the properties of indirect\n        references to it.  Etc.  For direct references, this issue is moot,\n        since clients cannot operate on them in any case except to create\n        them or delete them.  Clients cannot view their properties or\n        headers.\n\n        Just as in 3.1.11 passing operations through to the target can be\n        problematic, so here reflecting operations back to the referencing\n        resource can be problematic if the referential resource and the\n\nSlein & Davis                                                    Page 5\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n        target resource are on different servers.  Issues about what\n        credentials to use would need to be addressed.\n\n        This requirement must be qualified to allow for strong references,\n        however.  For strong references, whether direct or indirect, some\n        operations on targets must cause changes in the references to them.\n        For example, if the target of a strong reference is moved, the\n        reference must change to reflect the new location of the target.\n\n     3.1.6  A plain HTTP 1.1 browser should be able to use a referential\n            resource to access its target.\n\n        This minimal level of compatibility with older browsers is needed\n        to make deployment of WebDAV collection functionality feasible.\n        References are a new type of resource whose main purpose is to\n        allow ordinary resources to be shared by multiple collections.\n        Although WebDAV clients may be needed to create and manipulate\n        these new resources, older clients should be able to read and\n        make use of the collections built using references.\n\n     3.1.7  There is no requirement that references be acyclic.\n\n        From a practical standpoint, servers generally cannot control what\n        happens on other servers.  If a reference R on one server points to\n        a target T on another server, R's server cannot prevent T from\n        being changed to point back to R.  In addition, there may be\n        applications where cyclic references are desirable.\n\n     3.1.8  A listing of the members of a collection shows both its\n            ordinary members and its referential members.\n\n        A listing of collection members with Depth = 1 or Depth = infinity\n        shows all members of the collection, whether ordinary or \n        referential.  It follows from the definitions if indirect and\n        direct references that their behaviors in a listing of collection\n        members will differ from each other.\n\n        For indirect references, the reference itself, and not its target,\n        will be listed.  If Depth = infinity, the listing will not\n        follow references into any collections to which they may refer.\n        This is to minimize the risk of being caught in a circle of\n        references or a long chain of references.\n\n        For direct references, the target will be listed.  If Depth =\n        infinity and the target is a collection, the members of the target\n        collection will also be listed.\n\n     3.1.9  Multiple referential resources with the same target may reside\n            in the same collection.\n\n        It is often useful to allow the same resource to be referenced in\n        a collection multiple times.  Typically, these are cases where the\n        collection is ordered.  Consider a case where a collection\n        represents a book, with one member resource for each page in the\n        book.  A particular graphic needs to appear in several places in\n\nSlein & Davis                                                    Page 6\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n        the book, and so needs to appear in the collection several times.\n\n     3.1.10 A reference and its target may both be in the same collection.\n\n        In the example just described, the collection might contain the\n        graphic as an ordinary member, which is also referenced by\n        referential members of the same collection so that it can appear\n        multiple times in the book.\n\n     3.1.11 Operations on an indirect reference do not affect its target\n            resource except as needed to enforce referential integrity.\n\n        This requirement is really a restatement of the definition of\n        an indirect reference.  There are many reasons for wanting to\n        support this sort of resource.\n\n        Indirect references allow clients to operate on the referential\n        resource itself.  For example, they can store properties on the\n        reference distinct from those on its target.  If requests to the\n        referential resource were automatically redirected to its target\n        resource, this would not be possible.\n\n        Passing operations through to the target resource exposes \n        servers to the risks of circular references and long chains of\n        references that refer to other references.\n\n        In addition, passing operations through to the target resource can\n        be problematic if the referential resource and the target resource\n        are on different servers.  Issues about what credentials to use\n        would need to be addressed.\n\n        This requirement must be qualified to allow for strong references,\n        however.  Strong references are those whose referential integrity\n        is guaranteed by the server.  Requirement 3.1.n makes it possible\n        that some servers will support strong references.  For some \n        implementations of strong references, operations on the \n        references may cause changes in their targets.  For example, if a\n        server maintains a list of the strong references to a target in a\n        property on the target resource, creating or deleting a strong\n        reference will cause a change in this property of the target.\n\n     3.1.12 For any indirect referential resource, it is possible to obtain\n            the URI of its target resource.\n\n        This will allow clients to resolve indirect references themselves\n        in order to operate on the target resources.\n\n     3.1.13 For any resource, it is possible to discover whether it is an\n            indirect reference.\n\n        Since operations on indirect references are not passed through to\n        their targets, it is important for clients to be able to discover\n        which resources are indirect references.  Then the client can\n        resolve the references in order to perform operations on their\n        targets.\n\nSlein & Davis                                                    Page 7\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n\n     3.1.14 It is possible for an indirect reference to carry its own\n            properties, distinct from those of its target.\n\n        There are properties like \"who created this reference\" and \"when \n        was this reference created\" that clearly belong to the indirect\n        reference, and not to its target resource, which may be referenced\n        by many different referential resources.\n\n     3.1.15 Operations on a direct reference, except for creation and\n            deletion of the reference itself, are passed through to its\n            target resource.\n\n        This requirement is really a restatement of the definition of\n        a direct reference.  There are several reasons for wanting to\n        support this sort of resource.\n\n        Direct references simplify operations for clients, hiding from them\n        the fact that a reference is mediating between their requests and\n        the target resource.\n\n        Many existing systems, including HTTP servers, implement direct\n        references.\n\n        Supporting direct references does introduce issues that make it\n        unlikely that WebDAV will support them in the short term.  Passing\n        operations through to the target resource exposes servers to the\n        risks of circular references and long chains of references that\n        refer to other references.  In addition, passing operations through\n        to the target resource can be problematic if the referential\n        resource and the target resource are on different servers.  Issues\n        about what credentials to use would need to be addressed.\n\n     3.1.16 For any resource, it is possible to discover whether it is a\n            direct reference.\n\n        Since the behavior of direct references is radically different from\n        the behavior of indirect references, it is important for clients\n        to be able to discover whether they are operating on a direct\n        reference.  The client must have a way of finding out whether the\n        properties it sets will be stored on the reference or on its\n        target, etc. \n\n     3.1.17 It is not possible for a client to set or view properties of\n            a direct reference, distinct from those of its target.\n\n        Again, this follows from the definition of a direct reference.\n        Since all operations except creating the reference and deleting\n        the reference are passed through to the target, the client can\n        operate only on properties of the target.\n\n     3.1.18 It is possible to request creation of a referential resource\n            that the server will guarantee to have referential integrity.\n\n        For some applications, broken references are unacceptable.  \n\nSlein & Davis                                                    Page 8\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n        Breakage may be unavoidable when a target resource resides on a \n        different server from the referential resource that references it.\n        Servers can, however, maintain the integrity of referential \n        resources when they receive MOVE or DELETE requests for target \n        resources under their own control.  For applications that require\n        referential integrity, it must be possible to specify in a\n        request for creation of a referential resource that its integrity\n        be guaranteed.  If the server cannot honor this request, it must\n        decline to create the referential resource.  A referential resource\n        whose integrity is guaranteed by the server is called a strong\n        reference.\n\n     3.1.19 These requirements are silent as to what policy should be used\n            to ensure referential integrity.\n\n        A server guarantees the integrity of a reference if it ensures that\n        the reference will not be broken, or enables the reference's owner\n        to ensure that the reference will not be broken.\n\n        There are many policies that could be adopted to fulfill this\n        commitment.  For example, a server could refuse to allow a target\n        to be deleted while there are strong references to the target.\n        Alternatively, the server could delete the strong references along\n        with the target.  Alternatively, the server could flag the strong\n        references \"Target Deleted\" when it deletes the target.  Or the\n        server could notify the owners of all strong references when it\n        deletes a target, allowing the owners to take whatever action they\n        wish.  These requirements say nothing about what policy should be\n        used to enforce referential integrity.\n\n     3.1.20 It is possible to discover whether a referential resource is a \n            strong reference or a weak reference.\n\n        Knowing whether a referential resource is strong or weak allows a\n        client to intelligently choose its own strategy for working with\n        referential resources.  For example, if a client does not know\n        whether a particular reference is strong or weak, it may choose to\n        recreate that referential resource to be sure of referential\n        integrity; but if it knows that the reference is strong, it will\n        not bother to do this.\n\n     3.1.21 It is possible to discover whether a resource is the target of\n            a strong reference.\n\n        This requirement insures that both ends of a referential integrity\n        relationship have the same information available.\n\n     3.2  Ordered Collections\n\n     3.2.1  Ordering is sufficiently standardized that different \n            applications and servers can operate on the same ordering \n            without private agreements.\n\n        Applications and servers can apply an ordering to a collection's \n        members or discover the ordering of a collection's members without\n\nSlein & Davis                                                    Page 9\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n        private agreements.  They can also modify an ordering, at least\n        with the help of a human user for semantics (See 3.2.3), without\n        private agreements.\n\n        This is the minimum that is needed to support collaborative\n        management of an ordered collection, where different authoring\n        tools might be used by the collaborators.  It is also what allows\n        a different tool to be used to view the collection from the one\n        that was used to create it.  Finally, it is needed in order for\n        servers to list collection members in order, as required by 3.2.6.\n\n     3.2.2  A collection is not required to be ordered.\n\n        A WebDAV server may support collections without supporting ordered\n        collections.  Even if the server supports ordered collections, \n        there is no requirement that every collection on that server be\n        ordered.  Since these requirements concern only client-maintained\n        orderings, clients will decide whether any given collection is\n        ordered.\n\n        The remaining requirements apply only to collections that are\n        ordered.\n\n     3.2.3  The semantics of an ordering are discoverable.\n\n        The semantics of an ordering is the principle or rule according to\n        which the collection members are ordered.  This principle must be\n        discoverable if someone (or some application) other than the one\n        that created a collection is to be able to add a member to it and\n        determine where it makes sense to position the new member in the\n        collection's ordering.\n\n        In some cases it may be possible for the semantics to be expressed\n        in a machine-usable way, so that an application could automatically\n        position a new member in the ordering.  In other cases the \n        semantics may require a human user to apply them.  In either case\n        they should be discoverable.\n\n     3.2.4  Each collection member appears in the ordering exactly once.\n\n        It would be possible to support orderings that contain only a\n        subset of the collection members, or orderings that can contain\n        a single collection member more than once.  It is not necessary,\n        however, since the same result can be achieved by creating a\n        new collection with exactly the desired members, and including\n        each member of the new collection in its ordering exactly once.\n\n        This requirement implies that the server will check, whenever a\n        member is added to an ordering, to make sure that it is not already\n        in the ordering.  It also implies that either the protocol itself\n        or the server will insure that whenever a new member is added to\n        a collection, it is also added to the collection ordering.\n\n     3.2.5  An ordering does not include any resources that are not members\n            of the collection.\n\nSlein & Davis                                                    Page 10\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n\n        The server must insure that when a member is removed from a \n        collection, it is also removed from the collection's ordering.\n\n     3.2.6  When a client requests a listing of the members of a\n            collection, this listing is returned in the order specified by\n            the collection.\n\n        This requirement frees clients from the burden of applying the\n        ordering to the member listing.\n\n     3.2.7  It is possible to order the members of a collection in a\n            client-specified way, not necessarily based on property values.\n\n        Orderings that are based on property values can be obtained by a\n        search protocol that supports sorted result sets.  This set of\n        requirements is not concerned with such orderings.  It is intended\n        primarily to support orderings that cannot be obtained by sorting\n        on property values.\n\n        A property is not always available that can serve as the basis for\n        a desired ordering.  For example, a professor may wish to order a \n        collection of course readings in the sequence that makes sense to \n        coordinate the readings with her lectures.  But the properties of\n        resources at the Web site are standardized and do not include one\n        that is appropriate to use for this purpose.\n\n        Even if the professor in the example could create a \n        \"sequencenumber\" property to use in sorting the collection, this\n        strategy would be undesirable unless she knew she would not be\n        adding any readings or changing the order of her lectures once the\n        values of sequencenumber were set.  Inserting a new reading into\n        the sequence would require updating the sequencenumber property of\n        each reading that comes after the new one in the sequence.  Ordered\n        collections are intended to support this sort of case, where\n        sorting based on a property value is impossible or inefficient.\n\n     3.2.8  A single ordering may contain both ordinary and referential\n            resources. \n\n        The professor in the previous example may store some readings as\n        internal resources of the collection, but reference others from\n        servers at another university.  Nevertheless, all the readings\n        need to be included in the ordering for her students' use.\n\n     4  Acknowledgements\n\n        This draft has benefited from thoughtful discussion by Alan Babich,\n        Steve Carter, Ellis Cohen, Spencer Dawkins, Rajiv Dulepet, \n        Chuck Fay, Roy Fielding, Yaron Goland, Fred Hitt, Alex Hopmann,\n        Rohit Khare, Daniel LaLiberte, Steve Martin, Surendra Koduru Reddy,\n        Sam Ruby, Nick Shelness, John Stracke, John Turner, Jim Whitehead,\n        and others. \n\n     5  References\n\nSlein & Davis                                                    Page 11\n\fINTERNET-DRAFT            WebDAV Collection Protocol          July 1998\n\n\n        [Goland et al., 1998] Y. Y. Goland, E. J. Whitehead, Jr., A.\n        Faizi, S. R. Carter, D. Jensen, \"Extensions for Distributed\n        Authoring on the World Wide Web - WebDAV.\" work in progress,\n        Draft-ietf-webdav-protocol-08. Microsoft, U.C. Irvine, Netscape,\n        Novell. April, 1998.\n\n     6  Authors' Addresses\n\n        J. Slein\n        Xerox Corporation\n        800 Phillips Road\n        Webster, NY 14580\n        Email: slein@wrc.xerox.com\n\n\tJ. Davis\n\tXerox Corporation\n        3333 Coyote Hill Road\n        Palo Alto, CA 94304\n\tEmail: jdavis@parc.xerox.com\n\n     Expires January 20, 1999\nSlein & Davis                                                    Page 12\n", "encoding": "ascii"}