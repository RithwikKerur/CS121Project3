{"url": "https://www.ics.uci.edu/~thornton/ics142/LabManual/Assignment5/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course2.css\" type=\"text/css\" />\r\n\r\n<title>ICS 142 Winter 2004, Assignment #5</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 142 Winter 2004 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../LabManual\">Lab Manual</a> |\r\n<a href=\"news:ics.142\">ics.142 newsgroup</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 142 Winter 2004<br />\r\n   Assignment #5</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Thursday, March 11, 11:59pm</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>Before we can write programs in any programming language, we first must decide how to map the problem into the abstractions provided by the programming language we intend to use.  In the case of a language like Java, that means we have to make object-oriented design decisions, taking a data-centric viewpoint that decides what kind of objects will comprise the system and how these objects will interact.  Similarly, before the back end of a compiler can begin generating intermediate code or target code that is equivalent to some source program, it's necessary to map the abstractions provided by the source language into the (probably lower-level) abstractions provided by the intermediate language or target language.</p>\r\n\r\n<p>For a lower-level intermediate code such as ILOC (which is presented in the textbook and was discussed in lecture), some of the first decisions that will need to be made center around the use of memory, though there are a variety of other decisions that will need be made, as well.  If we were compiling Java and decided to use ILOC as an intermediate language, we'd have to consider many issues, such as:</p>\r\n\r\n<ul>\r\n  <li>How to represent objects in memory.</li>\r\n  <li>Where to put static variables and how to lay them out.</li>\r\n  <li>How to manage heap-allocated variables (including both allocation and garbage collection).</li>\r\n  <li>How to manage the calling of methods (including parameter passing, return values, and the saving and restoring of the caller's state).</li>\r\n  <li>How to implement dynamic binding of method calls (i.e. polymorphism).</li>\r\n  <li>If and how to represent and manage multiple threads.</li>\r\n</ul>\r\n\r\n<p>Fortunately, for a language such as Monkie2004, the number of decisions that need to be made is much smaller.  This assignment will explore a few of them: the placement of variables in memory and their subsequent use in expressions and assignment statements.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Syntax-directed analysis</p>\r\n\r\n<p>In the previous two assignments, the output of the parser was an abstract syntax tree that represented all the meaningful information in the source program.  The code that built up the abstract syntax tree was embedded into the grammar, with actions included in the CUP script that built nodes and passed them up the parse tree.  After building the abstract syntax tree, we performed semantic checking on it in Assignment #3, then interpreted it in Assignment #4.</p>\r\n\r\n<p>It should be noted that, for the work that was done in Assignment #3, there was another strategy that would also have worked.  The analysis itself could have been embedded into the actions in the CUP script, rather than building the entire AST first, then performing analysis on it.  (The primary reasons for having you build the AST were to keep your analysis separate from your parser while you were still learning the details of how to use CUP, and also to seed your work on the interpreter in Assignment #4.)  For example, assuming that there was a global symbol table called <b>st</b> available to all the actions in the CUP script, the following action could have been embedded into the rule for an addition expression, assuming that a Type object was associated with each Expression.  (I've simplified things somewhat for the purposes of the example.)</p>\r\n\r\n<pre>\r\n  Expr5 ::=\r\n      Expr5:e5 ADDITION_OP Expr6:e6\r\n          {:\r\n              if (e5 != st.lookupType(\"integer\") || e6 != st.lookupType(\"integer\"))\r\n              {\r\n                  reportSemanticError(\"both operands in addition must be integers\");\r\n                  RESULT = null;\r\n              }\r\n              else\r\n              {\r\n                  RESULT = st.lookupType(\"integer\");\r\n              }\r\n          :}\r\n  ;\r\n</pre>\r\n\r\n<p>Similarly, the rest of the rules in the grammar could have contained actions that performed semantic checking while the program was being parsed.  At the conclusion of parsing the program, then, semantic checking could be complete.</p>\r\n\r\n<p><i>Syntax-directed analysis</i> is the performing of analysis on a source program as it's being parsed.  While we didn't use that strategy for our semantic analyzer, there are other analyses that we might perform on the program during parsing.  In order to set you up for this, however, I first need to introduce you to a feature of CUP that we haven't discussed before: embedding an action in the middle of a grammar rule, as opposed to placing it at the end of one.</p>\r\n\r\n<p>We've discussed in class and in previous assignment write-ups how to embed actions at the end of a grammar rule in a CUP script.  Actions may also be embedded in the middle of rules.  For example, consider the following brief CUP script (with irrelevant parts left out):</p>\r\n\r\n<pre>\r\n    Goal ::=\r\n        Happies {: System.out.println(\"No more happies!\"); :}\r\n        Monkies {: System.out.println(\"No more monkies!\"); :}\r\n    ;\r\n\r\n    Happies ::=\r\n        Happies HAPPY {: System.out.println(\"Happy!\"); :}\r\n    |   HAPPY         {: System.out.println(\"Happy!\"); :}\r\n    ;\r\n    \r\n    Monkies ::=\r\n        Monkies MONKIE {: System.out.println(\"Monkie!\"); :}\r\n    |   MONKIE         {: System.out.println(\"Monkie!\"); :}\r\n    ;\r\n</pre>\r\n\r\n<p>Notice that there is only one rule for Goal: Happies followed by Monkies.  The action after Happies is within the rule.  (You can discern this from the script, since there is no '|' character between Happies and Monkies.)  So, the grammar accepts any input file with one or more HAPPY tokens followed by one or more MONKIE tokens.</p>\r\n\r\n<p>Actions in the middle of a CUP rule are executed after the preceding portion of the rule has been matched, but before the rest of the rule has been matched.  They are equivalent to placing a dummy nonterminal symbol into the middle of the rule, along with the addition of an epsilon rule for the dummy nonterminal symbol; in other words, the Goal rule in the example above is equivalent to these two rules:</p>\r\n\r\n<pre>\r\n    Goal ::=\r\n        Happies Dummy Monkies {: System.out.println(\"No more monkies!\"); :}\r\n    ;\r\n    \r\n    Dummy ::=\r\n        /* epsilon */   {: System.out.println(\"No more happies!\"); :}\r\n    ;\r\n</pre>\r\n\r\n<p>However, the original version, with the action in the midst of the rule, more clearly indicates the intent, which is to execute an action after the Happies, but before the Monkies.  All in all, the effect of the example is to do the following:</p>\r\n\r\n<ul>\r\n  <li>Print out <b>Happy!</b> for every HAPPY token in the input.</li>\r\n  <li>Print out <b>No more happies!</b> after all the HAPPY tokens.</li>\r\n  <li>Print out <b>Monkie!</b> for every MONKIE token in the input.</li>\r\n  <li>Print out <b>No more monkies!</b> after all the MONKIE tokens.</li>\r\n</ul>\r\n\r\n<p>This is a useful technique for performing some forms of syntax-directed analysis.  For example, if we were implementing the semantic checker using a syntax-directed technique, we might want an action embedded within the Procedure rule, after the ParameterList had been matched, but before the BlockStatement.  This action would declare the parameters into the SymbolTable before proceeding to analyze the BlockStatement.  For some of the work you'll be doing in this assignment, you may find this technique to be of great benefit.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The program</p>\r\n\r\n<p>Your program will take a Monkie2004 program as input.  Its output will be an indication of a few things:</p>\r\n\r\n<ul>\r\n  <li>For each procedure and function, the layout of its activation record (AR).  Details will be shown below, but AR's will be laid out similarly to how they were described in lecture, with local variables at the top, parameters at the bottom, and some other relevant information in between.</li>\r\n  <li>The layout of global variables into static memory.  Rather than report an absolute address for each global variable, we'll assume that there is one contiguous block of memory that will be used for all global variables.  Global variable addresses, then, will be reported as offsets into that block.</li>\r\n  <li>For each use of a variable in an assignment statement or an expression, information that would allow calculation of an access path to it.  This will be described in more detail below.</li>\r\n</ul>\r\n\r\n<p>You will be required to perform your analysis while parsing the program, with actions embedded within your CUP script.  You will, of course, need to use auxiliary data structures to store relevant information, such as activation record layouts.  But you may not build an abstract syntax tree and then analyze it, as you did in the previous two assignments.  Part of what I'd like you to get out of this assignment is experience doing syntax-directed analysis.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Changes to the Monkie2004 language for this assignment</p>\r\n\r\n<p>In order to introduce a couple of wrinkles into this assignment and iron out another, two changes have been introduced into the Monkie2004 language for this assignment.</p>\r\n\r\n<ul>\r\n  <li><b>ref</b> parameters have been dropped entirely from the language.  The corresponding rule has been removed from the grammar, and all parameters are assumed to be passed by value.</li>\r\n  <li>Procedure and function declarations may now be nested, meaning that they may occur as statements in the language.  It is assumed that static scoping will be used to resolve references to non-local variables.  The rules for calling nested procedures and functions are not relevant to this assignment, but you may assume that standard rules from other programming languages such as Pascal apply.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Memory layout requirements</p>\r\n\r\n<p class=\"subtitle\">Data widths</p>\r\n\r\n<p>We'll operate under the assumption that all data must be laid out on four-byte boundaries.  To accommodate this assumption, we'll make the following rules about the widths of data in Monkie2004:</p>\r\n\r\n<ul>\r\n  <li>Integer and boolean variables will occupy four bytes.</li>\r\n  <li>Strings, of course, are more complicated, since the lengths of strings may vary widely.  We'll say that string variables occupy eight bytes in either global memory or activation records, operating under a couple of assumptions:\r\n    <ul>\r\n      <li>A string variable will require four bytes for its length and four bytes for a pointer to its heap-allocated contents.</li>\r\n      <li>It is assumed that any change to a string (e.g. concatenation, assignment) or copying of a string (e.g. pass by value) will cause an automatic heap allocation of the appropriate size, as well as any necessary deallocation.  This behavior will not be modeled in this program.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Global memory</p>\r\n\r\n<p>All of the global variables in the program will be allocated into one area of memory called the <i>global area</i>.  Global variables should be laid out in the global area in the order seen, with the first one at offset 0, and subsequent ones at higher offsets.  For example, if the following three global variables are declared in an input program:</p>\r\n\r\n<pre>\r\nvar i: integer;\r\nvar s: string;\r\nvar b: boolean;\r\n</pre>\r\n\r\n<p>...then they would be laid out as follows:</p>\r\n\r\n<ul>\r\n  <li>i would appear at offset 0 of the global area</li>\r\n  <li>s would appear at offset 4 of the global area</li>\r\n  <li>b would appear at offset 12 of the global area</li>\r\n</ul>\r\n\r\n<p>...and the total size of the global area would be 16 bytes.</p>\r\n\r\n<p>Since the lifetime of global variables is the entire duration of the program's execution, no overlaying is ever done to save memory in the global area.</p>\r\n\r\n<p class=\"subtitle\">Activation records</p>\r\n\r\n<p>Each subprogram, including nested subprograms, has its own activation record.  Activation records contain local variables, parameters, and three additional values: a pointer to the caller's AR, a static link, and a return address.  Functions have a fourth additional value: a pointer to the return value.  Each of these additional values occupies four bytes.</p>\r\n\r\n<p>Activation records are assumed to all be stack-allocated, with the stack growing from higher to lower addresses.  It is assumed that, during an activation, the current AR pointer will point to the location of the caller's AR in the current activation record.  Local variables will appear above the caller's AR, at negative offsets; parameters will appear below the return address and/or return value pointer, at positive offsets.  The order of the local variables and parameters will be considered important, and can be determined from the example below.</p>\r\n\r\n<p>Consider the following Monkie2004 function:</p>\r\n\r\n<pre>\r\n    function foo(s: string, i: integer, b: boolean): integer\r\n    [\r\n        var ii: integer;\r\n        var ss: string;\r\n        var bb: boolean;\r\n        \r\n        -- ...\r\n    ]\r\n</pre>\r\n\r\n<p>The layout for foo's AR is:</p>\r\n\r\n<ul>\r\n  <li>local variable <b>bb</b> at offset -16</li>\r\n  <li>local variable <b>ss</b> at offset -12</li>\r\n  <li>local variable <b>ii</b> at offset -4</li>\r\n  <li>caller's AR pointer at offset 0</li>\r\n  <li>static link at offset 4</li>\r\n  <li>return address at offset 8</li>\r\n  <li>return value pointer at offset 12</li>\r\n  <li>parameter <b>s</b> at offset 16</li>\r\n  <li>parameter <b>i</b> at offset 24</li>\r\n  <li>parameter <b>b</b> at offset 28</li>\r\n</ul>\r\n\r\n<p>...and the size of foo's AR is 48 bytes.</p>\r\n\r\n<p class=\"subtitle\">Overlaying local variables in activation records</p>\r\n\r\n<p>Activation records should be minimally-sized, meaning that memory within them should be reused whenever possible.  The easiest way to ensure that the minimum amount of memory is used is to layout variables that are guaranteed never to live simultaneously into the same offsets of the AR.  Given Monkie2004's block structure, and the rule that the lifetime of local variables within a block statement is only within that block statement, this reuse is fairly straightforward to achieve.  Consider the following example:</p>\r\n\r\n<pre>\r\n    procedure bar()\r\n    [\r\n        var i: integer;\r\n        var j: integer;\r\n        \r\n        [\r\n            var k: integer;\r\n            \r\n            -- ...\r\n        ]\r\n        \r\n        [\r\n            var m: integer;\r\n            var n: integer;\r\n            \r\n            -- ...\r\n            \r\n            [\r\n                var p: integer;\r\n                \r\n                -- ...\r\n            ]\r\n            \r\n            [\r\n                var q: integer;\r\n                var r: integer;\r\n                \r\n                -- ...\r\n            ]\r\n        ]\r\n        \r\n        -- ...\r\n    ]\r\n</pre>\r\n\r\n<p>The layout of the local variables in the activation record for <b>bar</b> should be as follows:</p>\r\n\r\n<ul>\r\n  <li><b>r</b> at offset -24</li>\r\n  <li><b>p</b> and <b>q</b> at offset -20</li>\r\n  <li><b>n</b> at offset -16</li>\r\n  <li><b>k</b> and <b>m</b> at offset -12</li>\r\n  <li><b>j</b> at offset -8</li>\r\n  <li><b>i</b> at offset -4</li>\r\n</ul>\r\n\r\n<p>This kind of layout can be achieved programmatically using a technique similar to the scoped symbol tables you've used in the previous two assignments.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Static-distance coordinates</p>\r\n\r\n<p>Recall that in statically-scoped languages, when accessing non-local variables, the proper way to find them does not involve searching through the call stack looking for the first declaration of a variable with the desired name.  (There's another name for this approach: it's called <i>dynamic scoping</i>.)  In a statically-scoped language, uses of non-local variables are resolved based on static properties of the program: specifically, its lexical structure.  Uses of non-local variables are resolved by finding the syntactically closest declaration for that variable.  So, in the following example:</p>\r\n\r\n<pre>\r\n    var i: integer;\r\n\r\n    procedure program()\r\n    [\r\n        var i: integer;\r\n        \r\n        procedure foo()\r\n        [\r\n            i <- i + 1;\r\n        ]\r\n        \r\n        procedure bar()\r\n        [\r\n            var i: integer;\r\n            foo();\r\n        ]\r\n        \r\n        bar();\r\n    ]\r\n</pre>\r\n\r\n<p>...the assignment to <b>i</b> in foo should assign the <b>i</b> that is declared in <b>program</b>, not the one declared in <b>bar</b> (<b>foo</b>'s caller).</p>\r\n\r\n<p>To implement this behavior at run-time, activation records need to store two links to other AR's: one to the caller's AR (often called the <i>dynamic link</i>) and another to the AR of the most recent activation of the lexically-enclosing procedure (often called the <i>static link</i>).  In other words, while <b>foo</b> is executing, its dynamic link will point to <b>bar</b>'s AR, while its static link will point to the AR for the most recent activation of <b>program</b>.  Details of how static links are maintained at run-time are not relevant to this assignment.</p>\r\n\r\n<p>Assuming that static links are present in every AR, accessing a non-local variable is a relatively straightforward process.  When <b>foo</b> assigns to <b>i</b>, it is known that the static link in <b>foo</b>'s AR will always point to the AR for the most recent activation of <b>program</b>.  So, finding the address of the appropriate <b>i</b> is a matter of doing two things:</p>\r\n\r\n<ul>\r\n  <li>Placing <b>foo</b>'s static link into a register.</li>\r\n  <li>Adding the offset of <b>i</b> in <b>program</b>'s AR to it.</li>\r\n</ul>\r\n\r\n<p>To easily summarize this process, we can say that every use of a variable, in either an assignment or an expression, can be characterized by a <i>static-distance coordinate</i>.  The static-distance coordinate (<i>d</i>, <i>o</i>) is an ordered pair containing the distance <i>d</i> (i.e. the number of static links that must be followed to get to a variable) and the offset <i>o</i> (i.e. the offset of that variable in its AR).  So, in the example above, the uses of <b>i</b> in <b>foo</b> have a static-distance coordinate of (1, -4), assuming that the offset of <b>i</b> in <b>program</b>'s AR is -4.</p>\r\n\r\n<p>The static-distance coordinate for a local variable is (0, <i>o</i>), where <i>o</i> is the offset of the variable in the current AR.</p>\r\n\r\n<p>It should be pointed out that static distance coordinates do not apply to global variables.  Any access to a global variable can be resolved using an address known at compile time, i.e. an offset into the global area.  So there's no need to follow static links in order to access global variables; they can be accessed much more quickly by using their statically-determined address.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Sample input and output</p>\r\n\r\n<p>As stated earlier, your program will calculate and display three kinds of information while parsing an input program:</p>\r\n\r\n<ul>\r\n  <li>The layout and size of the activation record for each procedure and function.</li>\r\n  <li>The layout and size of the global area.</li>\r\n  <li>The static-distance coordinate or global area offset of every assignment to, or use of, every variable.</li>\r\n</ul>\r\n\r\n<p>Since I'm asking you to calculate and display the information while parsing the program, certain limitations on the order of your output are implied.  For example, you won't be able to report the layout and size of an AR until <i>after</i> you've finished parsing its procedure or function.  You won't be able to report the layout and size of the global area until you've finished parsing the input program.  Static-distance coordinates, on the other hand, may be reported immediately, since all variables are declared before they are used.</p>\r\n\r\n<p>With these facts in mind, here is an example Monkie2004 program and a sample of what your output should look like:</p>\r\n\r\n<p class=\"subtitle\">Sample input</p>\r\n\r\n<pre>\r\nvar calls: integer;\r\n\r\nprocedure program()\r\n[\r\n    function factorial(n: integer): integer\r\n    [\r\n        calls <- calls + 1;\r\n        \r\n        if n == 0 then\r\n        [\r\n            Result <- 1;\r\n        ]\r\n        else\r\n        [\r\n            Result <- n * factorial(n - 1);\r\n        ]\r\n    ]\r\n    \r\n    calls <- calls + 1;\r\n    \r\n    var i: integer;\r\n    i <- 1;\r\n\r\n    var j: integer;\r\n    j <- 0;\r\n    \r\n    while i < 10 do\r\n    [\r\n        print_integer(factorial(i));\r\n        print_endline();\r\n    ]\r\n    \r\n    print_integer(calls);\r\n    print_endline();\r\n]\r\n</pre>\r\n\r\n<p class=\"subtitle\">Sample output</p>\r\n\r\n<pre>\r\nprocedure program\r\n[\r\n    function factorial\r\n    [\r\n        assignment to 'calls' @ global area offset 0\r\n        use of 'calls' @ global area offset 0\r\n        use of 'n' @ static-distance coordinate (0, 16)\r\n        assignment to 'Result' @ static-distance coordinate (0, 12)\r\n        assignment to 'Result' @ static-distance coordinate (0, 12)\r\n        use of 'n' @ static-distance coordinate (0, 16)\r\n        use of 'n' @ static-distance coordinate (0, 16)\r\n    ]\r\n    factorial AR layout (size = 20)\r\n    [\r\n        offset 0 - caller's ARP\r\n        offset 4 - static link\r\n        offset 8 - return address\r\n        offset 12 - return value pointer\r\n        offset 16 - parameter 'n'\r\n    ]\r\n    assignment to 'calls' @ global area offset 0\r\n    use of 'calls' @ global area offset 0\r\n    assignment to 'i' @ static-distance coordinate (0, -4)\r\n    assignment to 'j' @ static-distance coordinate (0, -8)\r\n    use of 'i' @ static-distance coordinate (0, -4)\r\n    use of 'i' @ static-distance coordinate (0, -4)\r\n    use of 'calls' @ global area offset 0\r\n]\r\nprogram AR layout (size = 20)\r\n[\r\n    offset -8 - local variable 'j'\r\n    offset -4 - local variable 'i'\r\n    offset 0 - caller's ARP\r\n    offset 4 - static link\r\n    offset 8 - return address\r\n]\r\nglobal area layout (size = 4)\r\n[\r\n    offset 0 - 'calls'\r\n]\r\n</pre>\r\n\r\n<p class=\"subtitle\">Sample input #2</p>\r\n\r\n<p>Here's a second example, presented because it shows an example of overlaying of variables in an activation record, accompanied by sample output that shows how your output should reflect it:</p>\r\n\r\n<pre>\r\nprocedure program()\r\n[\r\n    var i: integer;\r\n    i <- read_integer();\r\n    \r\n    if i /= 0 then\r\n    [\r\n        var j: boolean;\r\n        j <- read_boolean();\r\n        \r\n        print_string(\"the input was \");\r\n        print_boolean(j);\r\n        print_endline();\r\n    ]\r\n    else\r\n    [\r\n        var k: integer;\r\n        k <- read_integer();\r\n        \r\n        print_string(\"the input was \");\r\n        print_integer(k);\r\n        print_endline();\r\n    ]\r\n]\r\n</pre>\r\n\r\n<p class=\"subtitle\">Sample output #2</p>\r\n\r\n<pre>\r\nprocedure program\r\n[\r\n    assignment to 'i' @ static-distance coordinate (0, -4)\r\n    use of 'i' @ static-distance coordinate (0, -4)\r\n    assignment to 'j' @ static-distance coordinate (0, -8)\r\n    use of 'j' @ static-distance coordinate (0, -8)\r\n    assignment to 'k' @ static-distance coordinate (0, -8)\r\n    use of 'k' @ static-distance coordinate (0, -8)\r\n]\r\nprogram's AR layout (size = 20)\r\n[\r\n    offset -8 - overlay\r\n    [\r\n        local variable 'j'\r\n        local variable 'k'\r\n    ]\r\n    offset -4 - local variable 'i'\r\n    offset 0 - caller's ARP\r\n    offset 4 - static link\r\n    offset 8 - return address\r\n]\r\nglobal area layout (size = 0)\r\n[\r\n]\r\n</pre>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What about erroneous Monkie2004 programs?</p>\r\n\r\n<p>You may assume that only legal Monkie2004 programs will be used as input to your program.  Bear in mind that a couple of changes have been made to the language, as described above, so the notion of a \"legal Monkie2004 program\" has changed to include those with nested subprograms and to exclude those with pass-by-reference parameters.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Starting point</p>\r\n\r\n<p>Because it's neither necessary nor acceptable to use an AST to solve this problem, the starting point is <i>not</i> your code from the previous two assignments.  I'm providing a starting point, which consists of only a complete scanner, a CUP script (monkie.cup) with all of the actions removed from it, and a Driver class that sets things up and runs the program for you.  As usual, the starting point is provided as a Zip archive:</p>\r\n\r\n<ul>\r\n  <li><a href=\"StartingPoint.zip\">Zip archive</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>Place your completed CUP script and all of the .java files that comprise your program into a Zip archive, then submit that Zip archive.  You need not include the .java files created by CUP (Parser.java and Tokens.java), but we won't penalize you if you do.  However, you should be aware that we'll be regenerating these ourselves during the grading process, to be sure that they really did come from your CUP script.  Please don't include other files, such as .class files, in your Zip archive.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingAssignments.html\">this link</a> for a discussion of how to submit your assignment.  Remember that we do not accept paper submissions of your assignments, nor do we accept them via email <i>under any circumstances</i>.</p>\r\n\r\n<p>In order to keep the grading process relatively simple, we require that you keep your program designed in such a way as it can be compiled and executed with the following set of commands:</p>\r\n\r\n<pre>\r\n    cup monkie.cup\r\n    javac *.java\r\n    java Driver inputfile.m\r\n</pre>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Limitations</p>\r\n\r\n<p>You may not make changes to the Monkie2004 grammar that was given to you, except that you naturally must add actions to it, add names to the symbols on the right-hand sides of rules, add types to the nonterminal symbols, and add code into the \"action code\" section, if necessary.  Other changes to the CUP script are not permitted.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Originally written by Alex Thornton, Winter 2004.</li>\r\n</ul>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}