{"url": "https://www.ics.uci.edu/~thornton/ics46/ProjectGuide/Project5/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2018, Project #5: Rock and Roll Stops the Traffic</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2018 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2018<br />\r\n   Project #5: <i>Rock and Roll Stops the Traffic</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, June 8, 11:59pm</i></b></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>As residents of southern California, most of us face the realities of having to drive or ride from one place to another on streets and freeways.  Given that this is a heavily populated area, we also have to contend with traffic.  If we attempt to drive on a local freeway during rush hour, we often experience traffic jams and long delays, requiring us to find alternative routes or simply put up with the traffic and wait.</p>\r\n\r\n<p>Fortunately, technology offers at least some assistance.  With ubiquitous wireless Internet connections feeding data to powerful devices embedded into cars and available in a mobile form, we have easy access to information that can help.  Aside from providing the obvious ability to download traffic reports and maps on demand, these devices can go a step further; given up-to-the-minute traffic information and a little computing power, your device can actively aid you in finding the best way to get from one place to another, optimized not only for distance, but also for the shortest driving time given the current traffic conditions.  Further, if all cars used such a system, as drivers were diverted around the scene of an accident, traffic conditions would change, and the advice offered by drivers' in-car or mobile devices would also change, optimally routing cars around a traffic jam by sending different cars down different alternate paths.  This way, even the alternatives might flow as quickly as possible.  (And, taking things a step further, Google has made a lot of recent progress on self-driving cars, which can optimize the traffic problem even further.)</p>\r\n\r\n<p>This is hardly science fiction; many of these features are already available on smartphones and in-car systems.  And while there are a lot of different kinds of technology you need in order to build a system like this, the core of the problem is actually one that's familiar to us in ICS 46.  For this project, you will write a simplified version of an important piece of such a system: given a map of streets and freeways, along with a snapshot of the current traffic between points on the map, your program will be capable of finding the shortest distance or fastest route to get from one location on the map to another.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Getting started</p>\r\n\r\n<p>Before you begin work on this project, there are a couple of chores you'll need to complete on your ICS 46 VM to get it set up to proceed.</p>\r\n\r\n<p class=\"subtitle\">Refreshing your ICS 46 VM environment</p>\r\n\r\n<p>Even if you previously downloaded your ICS 46 VM, you may need to refresh its environment before proceeding with this project.  Log into your VM and issue the command <b>ics46 version</b> to see what version of the ICS 46 environment you currently have stored on your VM.  Note, in particular, the timestamp; if you see a version with a timestamp older than the one listed below, you'll want to refresh your environment by running the command <b>ics46 refresh</b> to download the latest one before you proceed with this project.</p>\r\n\r\n<blockquote><pre>\r\n2018-05-20 20:53:39\r\nProject #5 template added\r\n</pre></blockquote>\r\n\r\n<p>If you're unable to get outgoing network access to work on the ICS 46 VM &mdash; something that afflicts a handful of students each quarter &mdash; then the <b>ics46 refresh</b> command won't work, but an alternative approach is to download the latest environment from the link below, then to upload the file on to your ICS 46 VM using SCP.  (See the <a href=\"../Project0\">Project #0</a> write-up for more details on using SCP.)  Once the file is on your VM, you can run the command <b>ics46 refresh_local NAME_OF_ENVIRONMENT_FILE</b>, replacing <b>NAME_OF_ENVIRONMENT_FILE</b> with the name of the file you uploaded; note that you'd need to be in the same directory where the file is when you run the command.</p>\r\n\r\n<ul>\r\n  <li><a href=\"../../vm/ics46-2018spring-environment.tar.gz\">ics46-2018spring-environment.tar.gz</a></li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Creating your project directory on your ICS 46 VM</p>\r\n\r\n<p>A project template has been created specifically for this project, containing a similar structure to the other templates you've seen previously, including some code that is being provided as a starting point and that you are required to work from.  So you'll absolutely need to use the <b>project5</b> template for this project, as opposed to the <b>basic</b> one or one from a previous project.</p>\r\n\r\n<p>Decide on a name for your project directory, then issue the command <b>ics46 start <i>YOUR_CHOSEN_PROJECT_NAME</i> project5</b> to create your new project directory using the <b>project5</b> template.  (For example, if you wanted to call your project directory <b>proj5</b>, you would issue the command <b>ics46 start proj5 project5</b> to create it.)  Now you're ready to proceed!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The project directory</p>\r\n\r\n<p>Change into your project directory and take a look around.  What you will see will look very familiar.  Once again, your project directory is capable of building three separate programs that you can run by issuing the commands <b>./run app</b>, <b>./run exp</b>, or <b>./run gtest</b>.  As in the previous project, there are no precompiled libraries, though there is a fair amount of pre-written code; after reading through the project write-up, take a look through the provided code and be sure you understand what problems it solves, so you can understand what parts of the problem you'll need to solve yourself.  The usual <b>app</b>, <b>core</b>, <b>exp</b>, and <b>gtest</b> directories are available for writing your code, and they serve the same purpose as always.</p>\r\n\r\n<p>Note that you'll be required to write code in the <b>app</b>, <b>core</b>, and <b>gtest</b> directories during this project.  (More on this later.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Our abstraction of a street map</p>\r\n\r\n<p>Real-life street maps, such as those you see online like Google Maps or those displayed by navigation systems in cars, are a handy way for people to determine an appropriate route to take from one location to another.  They present an abstraction of the world as a scaled-down drawing of the actual streets.  In order to be useful to us, a street map needs to give us the names of streets and freeways, to accurately demonstrate distances and directions, and to show us where the various streets and freeways intersect.</p>\r\n\r\n<p>For our program, we'll need to develop a different abstraction of a street map.  Our abstraction must contain the information that is pertient to the problem we're trying to solve, presented in a way that will make it as easy as possible for our program to solve it.  Not surprisingly, a picture made up of lines and words is not an abstract that is useful to our program; it would require a tremendous amount of effort to design and implement an algorithm to interpret the lines and words and build up some alternative representation that's more convenient.  It's better that we first design the more convenient representation, then train our program to read and understand an input file that specifies it.  To do so, we'll need to consider the problem a bit further.</p>\r\n\r\n<p>Our program's main job is to discover the shortest distance or driving time between two <i>locations</i>.  There's no reason we couldn't think of locations as being any particular point on a street map (for example, any valid street address, or even any valid GPS coordinate).  For simplicity, though, we'll think of them as points on the map in which decisions would need to be made, such as:</p>\r\n\r\n<ul>\r\n  <li>The intersection of two or more streets</li>\r\n  <li>A point on a freeway at which there is an entrance and/or an exit</li>\r\n</ul>\r\n\r\n<p>Connecting pairs of locations on the map are stretches of road.  In order to solve our problem, we'll need to know two things about each stretch of road:</p>\r\n\r\n<ul>\r\n  <li>Its length, in miles</li>\r\n  <li>The current speed of traffic traveling on it, in miles per hour</li>\r\n</ul>\r\n\r\n<p>Our map will consist of any kind of road that a car can pass over (e.g., <i>streets</i> or <i>freeways</i>), though it will not make a clear distinction between them.  In general, all of these are simply stretches of road that travel in a single direction.  For example, you could think of a simple two-lane street as a sequence of intersections, connected by stretches of road of equal length running in opposite directions; note, though, that the speed of traffic on either side of the street might be different.</p>\r\n\r\n<p>In real life, many intersections control traffic using stop signs or traffic lights.  Our program will ignore these controls; we'll instead assume that the traffic speeds on streets have been adjusted appropriately downward to account for the average time spent waiting at stop signs and lights.</p>\r\n\r\n<p>Also, to keep the problem relatively simple, absolute directions (i.e., north, south, east, and west) will not be considered by our program or reported in its output.  For that reason, they won't be included in our abstraction of a street map, except optionally in the names of locations.</p>\r\n\r\n<p>The output of our program will be a <i>trip</i>.  A trip is a sequence of visits to locations on the map.  For example, when I used to live in Costa Mesa (and parked my car at UCI in a parking lot where Bren Hall now stands; this wasn't recent!), my typical trip home from UCI looked like this:</p>\r\n\r\n<ul>\r\n  <li>Begin at Peltason &amp; Los Trancos</li>\r\n  <li>Continue to Bison &amp; Peltason</li>\r\n  <li>Continue to Bison &amp; California</li>\r\n  <li>Continue to Bison &amp; 73N on-ramp</li>\r\n  <li>Continue to 73N @ Birch</li>\r\n  <li>Continue to 73N @ 73N-to-55N transition</li>\r\n  <li>Continue to 55N @ Baker</li>\r\n  <li>Continue to 55N Baker/Paularino off-ramp &amp; Baker</li>\r\n  <li>Continue to Baker &amp; Bristol</li>\r\n</ul>\r\n\r\n<p>In addition to the information above, your program will also output information about the distance in miles and (sometimes) driving time of each of the segments of the trip, as well as the overall distance and (sometimes) driving time for the whole trip.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Representing our abstraction of a street map</p>\r\n\r\n<p>If you consider all of the data that we'll need to represent this abstraction, the task of organizing it can seem overwhelming.  However, there is a well-known data structure that represents this system in a straightforward way: a <i>directed graph</i>.  Using a directed graph, locations on our map can be represented as <i>vertices</i>, and the stretches of road connecting locations can be represented as <i>edges</i>.  (Since traffic travels in only one direction on a given stretch of road, it makes good sense that the graph should be directed.)</p>\r\n\r\n<p>Each vertex in the graph will have a human-readable name for the location it represents.  For example, a vertex might be named <b>Culver &amp; Harvard</b>, or it might be named <b>I-405N @ Jamboree</b>.  The name will be used only for display purposes; it won't have any significance in our algorithm.  The vertices should be numbered uniquely and consecutively, starting at zero.  If there are <i>n</i> vertices, they should be numbered 0 .. <i>n</i> &minus; 1.</p>\r\n\r\n<p>Each edge will contain the two necessary pieces of information about the stretch of road it represents: the distance between the two vertices (in miles, stored as a <b>double</b>) and the current speed of traffic (in miles per hour, also stored as a <b>double</b>).</p>\r\n\r\n<p>Since a trip is a sequence of visits to adjacent locations on the map, locations are represented as vertices, and two locations are adjacent only when there is a stretch of road (i.e., an edge) connecting them, a trip can be represented as a path in the graph.  So our main goal is to implement a kind of <i>shortest path</i> algorithm.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The program</p>\r\n\r\n<p>The goal of your program is to take as standard input (i.e., via <b>std::cin</b>) a description of all of the locations on a map and the stretches of road that connect them.  It then performs two tasks:</p>\r\n\r\n<ol>\r\n  <li>Ensures that it is possible for every location to be reached from every other location.  If we think of the locations and roads as a directed graph, that boils down to the problem of determining whether the graph is <i>strongly connected</i>.  If not, the message <b>Disconnected Map</b> should be output and the program should end.</li>\r\n  <li>Determines, for a sequence of <i>trip requests</i> listed in the input, shortest distances or shortest times between pairs of locations.</li>\r\n</ol>\r\n\r\n<p>Check out this <a href=\"sample.txt\">sample input</a>, a copy of which you'll find in the <b>inputs</b> directory in your project directory.  A description of its format follows.</p>\r\n\r\n<p>The input is separated into three sections: the locations, the road segments connecting them, and the trips to be analyzed.  Blank lines (and, similarly, lines containing only spaces) should be ignored.  Lines beginning with a <b>#</b> character indicate comments and should likewise be ignored.  This allows the input to be formatted and commented, for readability.</p>\r\n\r\n<p>The first section of the input defines the names of the map locations.  First is a line that specifies the number of locations.  If there are <i>n</i> locations, the next <i>n</i> lines of the input (not counting blank lines or comments) will contain the names of each location.  The locations will be stored in a directed graph as vertices.  Each vertex is to be given a number, with the numbers assigned consecutively in the order they appear in the input, starting at 0.</p>\r\n\r\n<p>The next section of the input defines the road segments.  Each road segment will be an edge in the directed graph.  The first line of this section specifies the number of segments.  Following that are the appropriate number of road segment definitions, with each segment defined on a line with four values on it:</p>\r\n\r\n<ol>\r\n  <li>The vertex number where the segment begins</li>\r\n  <li>The vertex number where the segment ends</li>\r\n  <li>The distance covered by the segment, in miles</li>\r\n  <li>The current speed of the traffic on the segment, in miles per hour</li>\r\n</ol>\r\n\r\n<p>Finally, the trips are defined.  Again, the section begins with a line specifying the number of trips.  Following that are an appropriate number of trip requests, with each trip request appearing on a line with three values on it:</p>\r\n\r\n<ol>\r\n  <li>The starting location for the trip</li>\r\n  <li>The ending location for the trip</li>\r\n  <li><b>D</b> if the program should determine the shortest distance, or <b>T</b> if the program should determine the shortest driving time</li>\r\n</ol>\r\n\r\n<p>Your program should read the vertices and edges from the input, build the graph, then process the trip requests in the order that they appear.  The output for each trip request is described later in this write-up.</p>\r\n\r\n<p>You may assume that the input will be formatted according to the rules described above, but you <i>may not</i> assume that the input we'll use to test the program will be identical to the sample.  Different numbers of vertices, different configurations of edges, different names, difference distances and speeds, etc., are possible.</p>\r\n\r\n<p class=\"subtitle\">How the program works when you first start</p>\r\n\r\n<p>The program compiles, but doesn't do anything when you run it.  The member functions declared in the <b>Digraph</b> class template &mdash; see below &mdash; are not yet implemented, and the <b>app</b> contains a fair amount of code, but has an empty <b>main()</b> function.  It's up to you to fill in the missing details.  (More on this below.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Implementing your Digraph</p>\r\n\r\n<p>You'll be implementing a class template <b>Digraph&lt;VertexInfo, EdgeInfo&gt;</b>, which is a directed graph that carries an object of type <b>VertexInfo</b> associated with each vertex and an object of type <b>EdgeInfo</b> associated with each edge.  While your program will use your <b>Digraph</b> class template with one particular kind of each &mdash; your <b>VertexInfo</b> might be a string containing the location's name, while your <b>EdgeInfo</b> might be a structure specifying distance and speed &mdash; your <b>Digraph</b> class template should be generic and reusable, so it should not make assumptions about the program as a whole.</p>\r\n\r\n<p>You'll find a declaration of <b>Digraph</b> in the file <b>core/Digraph.hpp</b> in your project directory.  One of the primary goals of this project is to implement that class template, including all of the member functions declared in <b>Digraph.hpp</b>.  Note that we will be running our own unit tests against your implementation, so <i>you cannot</i> change the signatures of public member functions in any way, and you cannot change the fact that <b>Digraph</b> is a template with two type parameters (VertexInfo and EdgeInfo), as our unit tests will presume that these things have not changed.  You can, however, add any additional member functions and member variables to the class you'd like; it's just important that existing members remain unaltered.</p>\r\n\r\n<p class=\"subtitle\">Implementation tradeoffs</p>\r\n\r\n<p>There are two well-known approaches that can be used to implement a graph: an <i>adjacency matrix</i> and <i>adjacency lists</i>.  As we've discussed in class, sparse graphs (that is, graphs with few edges outgoing from each vertex) are better implemented using adjacency lists, since an adjacency matrix would waste substantial amounts of memory and time storing and processing the vast number of blank cells in the matrix.  Our street map is clearly a sparse graph, since each vertex will have edges to and from only a few relatively \"nearby\" vertices.  So, adjacency lists are a clearly superior approach in our case.  You are required to use this approach to represent your graph.</p>\r\n\r\n<p>One approach is to primarily store a <b>std::map</b> with keys being vertex numbers (which are not necessarily consecutive or zero-based, making something like <b>std::vector</b> or an array a tougher choice) and values being a structure containing information about each vertex (among other things, a <b>std::list</b> containing information about each edge outgoing from that vertex).</p>\r\n\r\n<p>Erring on the side of using well-behaved classes wherever possible in your <b>Digraph</b> implementation will reduce the complexity of memory management significantly; consider that when you're making your choices.</p>\r\n\r\n<p class=\"subtitle\">Constraints on the template arguments</p>\r\n\r\n<p>You have somewhat more freedom here to choose reasonable constraints for your template arguments.  You might be surprised how few constraints you need to impose on them, because there is relatively little that your <b>Digraph</b> needs to do with <b>VertexInfo</b> and <b>EdgeInfo</b> objects besides store them, find them, and return them.  In a comment near the top of <b>Digraph.hpp</b>, list any constraints on the <b>VertexInfo</b> and <b>EdgeInfo</b> type parameters introduced by your template.</p>\r\n\r\n<p class=\"subtitle\">Sanity-checking your Digraph implementation</p>\r\n\r\n<p>To ensure that your Digraph is compatible with our unit tests, a set of \"sanity-checking\" unit tests are included in the <b>gtest</b> directory in your project directory.  They make no attempt to validate any of the Digraph's functionality, but they do at least ensure that your Digraph contains all of the necessary member functions and will be compatible with our unit tests.  Initially, the sanity-checking unit tests will not compile &mdash; this is why they are all commented out &mdash; but as you work, you'll be able to gradually uncomment them and see them compile.  If you haven't successfully uncommented and compiled all of the sanity-checking unit tests, your Digraph will not compile against our unit tests.</p>\r\n\r\n<p>As you work, you may discover that the sanity-checking tests that once compiled and linked successfully suddenly don't anymore; this is actually a clue that something important may have changed, so you'll want to be cognizant of it.  Many of the errors you'll get from the sanity-checking tests are actually linker errors, which can be a bit difficult to unravel when you haven't had a lot of practice with them, but if you compile relatively often, there won't be many candidates whenever you have a problem; focus on changes you made most recently and you'll find your likely culprit.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Finding the shortest paths</p>\r\n\r\n<p>The problem we need to solve, that of finding the fastest or shortest trip along a network of roads, is not an uncommon one in computing.  In fact, it's so common that it's already been solved abstractly.  Our problem is an instance of the <i>single-source, positive-weighted, shortest-path problem</i>.  In other words, from one particular vertex (a \"single source\"), we'll be finding the shortest path to another vertex, where all of the edges have a \"positive weight\" (in our case, distance or speed, neither of which will ever be negative or zero) associated with them.  We'll use a well-known algorithm called Dijkstra's Shortest-Path Algorithm to solve this problem.</p>\r\n\r\n<p>Dijkstra's Algorithm actually finds the shortest path from some start vertex to <i>all</i> the other vertices in a graph &mdash; this doesn't slow the algorithm down, since it needs to calculate them all in order to find the desired answer &mdash; though we're only interested in one of the paths that it will find.  There's a benefit to Dijkstra's calculation of all the shortest paths from some vertex.  Suppose the file has multiple trips starting from the same vertex.  With Dijkstra's Algorithm, we can compute shortest paths from any particular start vertex to all other vertices once for distance and once for time, storing the results in memory.  Then, to learn the shortest path from that start vertex to any other vertex, we can just look up the answer.  Use this approach in your program; it is likely the file will contain multiple trips that start from a particular place, and only a poorly-designed solution would require the program to re-compute data it has already computed, unless memory was at such a premium that there wasn't enough space to store previous results (and, since this program is running on PCs and laptops, there will be plenty of memory avaliable).</p>\r\n\r\n<p>For each vertex <i>v</i>, Dijkstra's Algorithm keeps track of three pieces of information: <i>k<sub>v</sub></i>, <i>d<sub>v</sub></i>, <i>p<sub>v</sub></i>.</p>\r\n\r\n<ul>\r\n  <li><i>k<sub>v</sub></i> is a boolean flag that indicates whether the shortest path to vertex <i>v</i> is known.  Initially, <i>k<sub>v</sub></i> is <b>false</b> for all vertices.</li>\r\n  <li><i>d<sub>v</sub></i> is the length of the shortest path found thusfar from the start vertex to <i>v</i>.  When the algorithm begins, no paths have been considered, so <i>d<sub>v</sub></i> is initially set to &infin; for all vertices, except the start vertex, for which <i>d<sub>v</sub></i> = 0.</li>\r\n  <li><i>p<sub>v</sub></i> is the predecessor of the vertex <i>v</i> on the shortest path found thusfar from the start vertex to <i>v</i>.  Initially, <i>p<sub>v</sub></i> is <b>unknown</b> for all vertices, except for the start vertex, for which <i>p<sub>v</sub></i> is <b>none</b>.</li>\r\n</ul>\r\n\r\n<p>As the algorithm proceeds, it will need to calculate the <i>cost</i> for individual edges.  The cost of the edge from <i>v</i> to <i>w</i> will be called <i>C</i>(<i>v</i>, <i>w</i>).  How you calculate the cost depends on whether you're minimizing driving distance or driving time:</p>\r\n\r\n<ul>\r\n  <li>If you're minimizing driving distance, <i>C</i>(<i>v</i>, <i>w</i>) is the number of miles on the edge from <i>v</i> to <i>w</i>.</li>\r\n  <li>If you're minimizing driving time, <i>C</i>(<i>v</i>, <i>w</i>) is the amount of time (in seconds, let's say) required to drive along the edge from <i>v</i> to <i>w</i>, given its length and traffic speed.</li>\r\n</ul>\r\n\r\n<p>Dijkstra's Algorithm proceeds in phases.  The following steps are performed in each pass:</p>\r\n\r\n<ol>\r\n  <li>From the set of vertices for which <i>k<sub>v</sub></i> is <b>false</b>, select the vertex <i>v</i> having the smallest <i>d<sub>v</sub></i>.  In other words, of the shortest paths to each vertex that we've found that we're not yet sure about, pick the one that is the shortest.</li>\r\n  <li>Set <i>k<sub>v</sub></i> to <b>true</b> for the vertex you picked in step 1.  The shortest of the \"unknown\" paths is now considered to be known.</li>\r\n  <li>For each vertex <i>w</i> adjacent to <i>v</i> (i.e., there is an edge from <i>v</i> to <i>w</i>) for which <i>k<sub>w</sub></i> is <b>false</b>, test whether <i>d<sub>w</sub></i> is greater than <i>d<sub>v</sub></i> + <i>C</i>(<i>v</i>, <i>w</i>).  If it is, set <i>d<sub>w</sub></i> to <i>d<sub>v</sub></i> + <i>C</i>(<i>v</i>, <i>w</i>) and set <i>p<sub>w</sub></i> to <i>v</i>.  In other words, if the path through <i>v</i> to <i>w</i> is better than the shortest path we'd found to <i>w</i> so far, the shortest path to <i>w</i> (so far) is the path we've just found through <i>v</i> to <i>w</i>.</li>\r\n</ol>\r\n\r\n<p>For each pass, exactly one vertex has its <i>k<sub>v</sub></i> set to <b>true</b> (in other words, we discover one known shortest path per pass).</p>\r\n\r\n<p>Here is psuedocode for the algorithm.  Notice the use of a priority queue, which allows you to efficiently find the vertex with the smallest <i>d<sub>v</sub></i> in step 1.</p>\r\n\r\n<pre>\r\n    for each vertex v\r\n    {\r\n        set k<sub>v</sub> to false\r\n        set p<sub>v</sub> to unknown (or none, if v is the start vertex)\r\n        set d<sub>v</sub> to &infin; (or 0, if v is the start vertex)\r\n    }\r\n\r\n    let pq be an empty priority queue\r\n    enqueue the start vertex into pq with priority 0\r\n    \r\n    while (pq is not empty)\r\n    {\r\n        vertex v = the vertex in pq with the smallest priority\r\n        dequeue the smallest-priority vertex from pq\r\n        \r\n        if (k<sub>v</sub> is false)\r\n        {\r\n            k<sub>v</sub> = true\r\n\r\n            for each vertex w such that edge v &rarr; w exists\r\n            {\r\n                if (d<sub>w</sub> &gt; d<sub>v</sub> + C(v, w))\r\n                {\r\n                    d<sub>w</sub> = d<sub>v</sub> + C(v, w)\r\n                    p<sub>w</sub> = v\r\n                    enqueue w into pq with priority d<sub>w</sub>\r\n                }\r\n            }\r\n        }\r\n    }\r\n</pre>\r\n\r\n<p>At the conclusion of the main loop, the <i>d<sub>v</sub></i> value corresponding to the end vertex will be the amount of the shortest path.  You can find the actual path of vertices by working your way backward from the end vertex to the start vertex, following the <i>p<sub>v</sub></i> values as you go along.  (This implies, of course, that you need to store all the <i>p<sub>v</sub></i> values.)</p>\r\n\r\n<p>Remember that, after the algorithm has finished, you should store the results in memory so that you can look them up later.  I suggest storing the <i>p<sub>v</sub></i> values long-term.  There's no reason to store the <i>k<sub>v</sub></i> values, because they will all be <b>true</b> after the algorithm is completed.  And there's no need to store the <i>d<sub>v</sub></i> values, because you will need to lookup the times or distances between each vertex in the path anyway, since we always output all of the segments of a trip, and you can easily sum these up to calculate a total while you're generating your answer.</p>\r\n\r\n<p>As you can see from the pseudocode, you will need to use a priority queue in order to implement Dijkstra's Algorithm efficiently.  You can implement your own priority queue, if you'd like &mdash; though it should perform its enqueues and dequeues in <i>O</i>(log <i>n</i>) time if you do &mdash; but you can also use <b>std::priority_queue</b> from the C++ standard library if you prefer.  Note that <b>std::priority_queue</b> is a little bit trickier than it looks.  In particular, it stores objects without separate priority values; it then uses a <i>compare function</i> to determine which object is considered to be more important.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The output</p>\r\n\r\n<p>For each of the trip requests in the input file, your program should output a neatly-formatted report to the console that includes each leg of the trip with its distance and/or time (as appropriate), and the total distance and/or time for the trip.</p>\r\n\r\n<p>If the trip request asks for the shortest distance, the output might look something like the following.  (These are phony trips, to show you the output format; they are not related to the sample data file provided above.)</p>\r\n\r\n<pre>\r\nShortest distance from Alton & Jamboree to MacArthur & Main\r\n  Begin at Alton & Jamboree\r\n  Continue to Main & Jamboree (1.1 miles)\r\n  Continue to Jamboree & I-405N on ramp (0.3 miles)\r\n  Continue to I-405N @ MacArthur (1.3 miles)\r\n  Continue to MacArthur & I-405N off ramp (0.1 miles)\r\n  Continue to MacArthur & Main (0.2 miles)\r\nTotal distance: 3.0 miles\r\n</pre>\r\n\r\n<p>On the other hand, if the trip request asks for the shortest time, the output might look like this:</p>\r\n\r\n<pre>\r\nShortest driving time from Alton & Jamboree to MacArthur & Main\r\n  Begin at Alton & Jamboree\r\n  Continue to Alton & MacArthur (2.7 miles @ 33.7mph = 4 mins 48.8 secs)\r\n  Continue to Main & MacArthur (1.1 miles @ 40.1mph = 1 min 38.7 secs)\r\nTotal time: 6 mins 27.5 secs\r\n</pre>\r\n\r\n<p>When outputting a time, you should separate it into its components &mdash; hours, minutes, and seconds &mdash; as appropriate.  Here are some examples:</p>\r\n\r\n<pre>\r\n32.5 secs\r\n2 mins 27.8 secs\r\n13 mins 0.0 secs\r\n3 hrs 13 mins 12.3 secs\r\n6 hrs 0 mins 0.0 secs\r\n</pre>\r\n\r\n<p>Don't show hours if there are zero of them.  Don't show hours or minutes if there are zero of both of them.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The provided code</p>\r\n\r\n<p>A fair amount of code has been provided already in the <b>app</b> directory in your project directory, so some of what is described above is actually already implemented.  In particular, you'll find these things useful:</p>\r\n\r\n<ul>\r\n  <li>All of the input parsing is already implemented.  In particular, check out the <b>InputReader</b> class, which handles the detail of reading lines of input and skipping the non-meaningful ones (the comments and blank lines); the <b>RoadMapReader</b> class, which reads the map information from the input and returns a <b>RoadMap</b> (which is a particular instantiation of the <b>Digraph</b> class template); and the <b>TripReader</b> class, which reads the trip requests from the input and returns a vector of <b>Trip</b> structures (each describing one trip request).</li>\r\n  <li>A <b>RoadMapWriter</b> class will allow you to see a human-readable representation of your graph, which you might find useful in debugging.</li>\r\n  <li>Some data types that you'll probably need are defined: <b>RoadMap</b>, <b>RoadSegment</b>, <b>Trip</b>, and <b>TripMetric</b>.</li>\r\n</ul>\r\n\r\n<p>Any of the provided code in the <b>app</b> directory can be replaced or removed; it's up to you.  This code is provided primarily to let you focus on the interesting parts of the project, without spending too much time on grunt work.</p>\r\n\r\n<p>Note, too, that the provided code will compile but will not link initially.  That's because it depends on implementations of the member functions of the <b>Digraph</b> class template, which are missing (and which you'll need to implement).</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Unit testing</p>\r\n\r\n<p>It would be a good idea to separately unit test your <b>Digraph</b> implementation.  While this is not an explicit requirement, we will be running a set of unit tests as part of how we grade the project, so you'll want to be sure you handled the various scenarios correctly, including those that didn't come up directly in the application you're building; unit tests are a great, simple way to do that.</p>\r\n\r\n<p>Before building a program atop a data structure implementation, it's vital to be sure that the data structure actually works as intended, so you'd be well-advised to implement your unit tests alongside your <b>Digraph</b> implementation work, proceeding with the rest of the program only once you've got a <b>Digraph</b> that is complete and correct.  (This is the right strategy if you're thinking about partial credit for incomplete work, as a large part of the challenge here &mdash; and, therefore, a large portion of the credit &mdash; is allocated to your <b>Digraph</b>.)</p>\r\n\r\n<p>As usual, write your unit tests in the <b>gtest</b> directory in your project directory.  Write them in a source file <i>other than</i> the provided one that contains sanity-checking unit tests; your unit tests have a separate goal.</p>\r\n\r\n<p>Writing your own unit tests is not a requirement, but I would strongly recommend it.  Among other reasons, this gives you a way to work on your <b>Digraph</b> implementation and verify that it works piecemeal, even though the provided code in the <b>app</b> directory won't link until many of the parts of <b>Digraph</b> are implemented.  Simply work on whichever part of <b>Digraph</b> you want to implement, write unit tests for it, and run the <b>./build gtest</b> command to build <i>only</i> your unit tests, and it won't matter that the <b>app</b> is not ready to be built yet.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>After using the <b>gather</b> script in your project directory to gather up your C++ source and header files into a single <b>project5.tar.gz</b> file (as you did in <a href=\"../Project0\">Project #0</a>, submit that file (and only that file) to Checkmate.  Refer back to <a href=\"../Project0\">Project #0</a> if you need instructions on how to do that.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for a discussion of how to submit your project via Checkmate.  Be aware that I'll be holding you to all of the rules specified in that document, including the one that says that you're reponsible for submitting the version of the project that you want graded.  We won't regrade a project simply because you submitted the wrong version accidentally.  (It's not a bad idea to look at the contents of your tarball before submitting it; see <a href=\"../Project0\">Project #0</a> for instructions on how to do that.)</p>\r\n\r\n<p class=\"subtitle\">Can I submit after the deadline?</p>\r\n\r\n<p>Yes, it is possible, subject to the late work policy for this course, which is described in the section titled <i>Late work</i> at <a href=\"../index.html\">this link</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Additional clarifications by Alex Thornton, Winter 2018.</li>\r\n  <li>Additional clarifications by Alex Thornton, Spring 2017.</li>\r\n  <li>A few updates and tweaks by Alex Thornton, Spring 2016.</li>\r\n  <li>Originally written by Alex Thornton, Spring 2014, with heavy influence from a similarly-named project from ICS 23.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}