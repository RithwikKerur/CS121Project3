{"url": "https://www.ics.uci.edu/~kay/courses/141/hw/hw3.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Saturday, February 5, 2000 4:50 PM\">\n<TITLE>Asst. 3 * Syntax, Vars, Real F.P</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"64274B8F\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Programming languages, homework, functional programming, syntax, scope, variables, semantics\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Assignment 3 on functional programming, syntax, and variables  for ICS 141, an undergraduate course in the concepts of programming languages taught by David G. Kay in the Department of Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 1999 , 2000 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"asst_3_syntax_vars_f_files/sidebar_73.gif\" WIDTH=468 HEIGHT=78>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4>This assignment is due on Monday, February\n7, by 7:00 p.m. in the locking box in CS 189.  Turn in everything you have\ncompleted at that time; we can&#39;t grade straggling assignments.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Summary:</B>  In this assignment you will\nwork with some realistic functional programs.  You&#39;ll also get experience\nwith BNF and with issues of scoping and binding.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Readings and review questions:</B>  This\nassignment covers more of Sebesta, chapters 3 and 4.  You should know the\nanswers to the review questions listed below, but you do not have to turn\nthem in.  This list should help you identify some of the more important\nconcepts in the text.  (On the other hand, don&#39;t infer that the topics\nwe skip or omit are entirely <I>un</I>important.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 3:  1, 7, 8, 14</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Chapter 4:  1, 2, 4, 6-14, 16, 18-23.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part I:</B>  Syntax description</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  In the Sebesta text, do the following\nproblems in the problem set starting on page 152: pick one of the five parts\nof problem 2; pick two of the four parts of problem 4; problem 6; problem\n8; problem 10; and problem 11 (which, as written, is a trick question).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Write an EBNF grammar for HTML\ndocuments.  You don&#39;t have to cover all of HTML; just handle about ten\nof the most popular tags (including &lt;A&gt;&lt;/A&gt;) in their basic\nforms.  Use <U>|&#160;boxed text |</U> instead of &lt;angle brackets&gt;\nfor your nonterminals, so you don&#39;t get confused with the angle brackets\nthat are part of HTML itself.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part II:</B>  Scoping and binding</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>In the Sebesta text, do the following problems\nin the problem set starting on page 189 (this is labeled &quot;problem set,&quot;\nnot &quot;review questions.&quot;): 2, 4, 6, 9.  Draw two contour models\nfor problem 9 (one for static scoping, one for dynamic), as we did in class;\nit will help a lot.  The other problems in the section aren&#39;t required,\nbut if you don&#39;t feel comfortable with the scoping issues you should\ntry to work them out.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Part III:</B>  Functional programming in\nreal programs</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  Attached to this assignment is\na simple Scheme program to maintain a database of restaurant objects.  It&#39;s\navailable on the lab server.  Load the program into EdScheme (click the\nlambda button) and play around with it for a while:  Evaluate </FONT><FONT FACE=\"Courier New\">(restaurants)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nin the transcript window and give commands to add, remove, print, and search\nfor restaurants.  (Represent restaurant names either as double-quoted strings\nor as Lisp lists of symbols--just keep to one representation consistently.)\n You don&#39;t have to turn anything in to demonstrate your experimentation.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.1)</B>  Modify the program code so that\nit gives the user an additional menu choice:</FONT></P>\n<P>\n<FONT FACE=\"Courier New\">&#160;&#160; c:  Clear all the restaurants from\nthe collection</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>When the user types &#39;</FONT><FONT FACE=\"Courier New\">c</FONT><FONT FACE=\"AGaramond\" SIZE=4>&#39;,\nthe program should remove all the restaurants from the collection (so that\nif the next command were &#39;</FONT><FONT FACE=\"Courier\"><TT>p</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>&#39;,\nfor example, nothing would be printed).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>This will require modifications or additions\nin a few places; you can do the main part of the work very easily indeed,\nwith a single function call.  The key is to think functionally, not of changing\nvalues but of describing or creating the new value.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.2)</B>  The search command currently\nallows the user to search only for restaurants by name.  We know that </FONT><FONT FACE=\"Courier New\">collection-select</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nallows much more flexible searching, however.  </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Modify the </FONT><FONT FACE=\"Courier New\">search-collection</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nroutine in the main program to give the user a choice of searching by name\nor by cuisine.  If the user chooses to search by cuisine, prompt for the\ntype of cuisine and perform the requested search with appropriate calls\nto </FONT><FONT FACE=\"Courier New\">collection-select</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n  [Hint:  Consider using some of the code on the second page of the &quot;Notes\non Scheme&quot; handout.]</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.3)  </B>Now, ask yourself how much code\nit would have taken to accomplish the same thing in C++.  You don&#39;t\nhave to write an answer, but it&#39;s worth thinking about.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Also attached to this assignment\nis an implementation of binary search trees in Scheme.  It, too, is available\non the server.  Load it and experiment with it.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.1)</B>  What happens when you add a\nduplicate item (an item whose value is already in the tree)?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.2)  </B>Enhance the implementation by\nadding a &quot;count&quot; field to each node, so that when a duplicate\nis added, the count is increased, and when an item is deleted, its count\nis decreased (and the node isn&#39;t actually deleted until the count reaches\nzero).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.3)</B>  After saving a copy of your\ncode from <B>(b.2)</B>, modify it to implement &quot;lazy deletion&quot;\nof nodes:  Instead of actually removing a node from the tree when its count\ngets to zero, just mark it as deleted (and alter the routines for searching\nand adding appropriately).  This is useful in situations where the same\nvalues enter and leave the tables repeatedly.  Turn in your final code for\nthis part on paper and electronically, to the ICS 141 dropbox on the Masterhit\nserver in the lab, labeled clearly with your name and student ID.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.4)</B>  Go back to the original binary\nsearch tree code, before you made your modifications for parts <B>(b.2)</B>\nand <B>(b.3)</B>.  Note that </FONT><FONT FACE=\"Courier New\">bst-add</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">bst-delete</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nhave a common structure.  Combine them, as we did with </FONT><FONT FACE=\"Courier New\">find-all-matches</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">remove-all-matches</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nin the &quot;Notes on Scheme&quot; handout.  You can do this on paper; you\ndo not have to turn it in electronically.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.5)</B>  (extra credit)  Once lazy deletion\nand a count field are implemented, handling normal (non-lazy) deletion is\njust a question of doing something different when the node&#39;s count gets\nto zero.  Modify your code from <B>(b.3)</B> to let the user specify when\ncreating the tree whether it should use lazy or normal deletion.  You&#39;d\nneed to modify the &quot;constructor&quot; to take another parameter (whose\nvalue would be either </FONT><FONT FACE=\"Courier New\">&#39;lazy</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nor </FONT><FONT FACE=\"Courier New\">&#39;normal</FONT><FONT FACE=\"AGaramond\" SIZE=4>--or,\nyou could make it an <I>optional</I> parameter, using normal deletion as\nthe default case).  You&#39;d store with each new tree an indication of\nwhich kind of deletion it uses, and you&#39;d do that kind of deletion when\ncalled for.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.6)</B>  (extra credit)  Allow for more\ncomplex values (like structures) in the tree, in essence building a &quot;templated\nclass.&quot;  You&#39;ll need to supply key-selector and key-comparison\nfunctions when you create a tree.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.7)</B>  (extra credit)  Implement your\nfavorite tree-balancing algorithm.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)  </B>(extra credit)  Find as many indications\nas you can in the Sebesta text that Sebesta doesn&#39;t &quot;get&quot;\nfunctional programming or Scheme--that he doesn&#39;t treat Scheme as completely\nor seriously as other popular languages.  Look for omissions and subtleties\nin the wording. </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(d)</B>  For some examples of the practical\napplications of functional programming, check out the web site <A HREF=\"http://www.cs.bell-labs.com/~wadler/realworld/\">Functional Programming in the Real World</A>,\n</FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.cs.bell-labs.com/~wadler/realworld/\">http://www.cs.bell-labs.com/~wadler/realworld/</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n You should also take a look at </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.scheme.com\">www.scheme.com</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich describes a Scheme implementation that claims to generate code with\nthe same performance as C.  There&#39;s nothing to turn in for this.</FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}