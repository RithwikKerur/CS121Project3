{"url": "https://www.ics.uci.edu/~thornton/ics46/Notes/Randomness/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2018, Notes and Examples: Randomness</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2018 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2018<br />\r\n   Notes and Examples: Randomness</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What is randomness and why do we want it?</p>\r\n\r\n<p>The word <i>random</i> and its cousins, like <i>randomness</i>, are thrown around quite a lot in day-to-day speech, but, from a computing perspective, randomness actually has a somewhat more precise definition than we may normally be accustomed to using.  We say that a sequence of values is random if we cannot deduce any sort of pattern that describes it.  Statistics has much to say about what constitutes randomness &mdash; for example, how varied do the values of a sequence have to be? &mdash; and the deep specifics are beyond the scope of our interest at the moment, but what's important is that we can obtain a sequence of values that is varied and unpredictable when we need it.</p>\r\n\r\n<p>You might wonder why you would ever want something like this in the first place.  What good is a sequence of values whose values you can't predict?  It turns out that such a sequence can solve a diverse set of interesting and important problems.  A few examples follow.</p>\r\n\r\n<ul>\r\n  <li>Encryption is how we keep communication secret, so that it can be understood only by the parties involved, while appearing as gibberish to eavesdroppers.  The cornerstone of many forms of encryption is the selection of a <i>key</i>, which can be used in conjunction with an encryption algorithm to translate the original text into a \"scrambled\" version that can be read only by another party who has that same key (or a compatible one), and only by running a corresponding decryption algorithm to obtain the original text from the \"scrambled\" version.  If the keys are selected in a manner that's predictable, other parties will be able to guess the key; if the keys are selected in a manner that's random, that problem becomes much harder to solve, because there will be no foreknowledge of what the key might be.</li>\r\n  <li>Many computer games rely on randomness to generate at least some of the behavior of the game world you interact with.  Particularly in the case of the elements of that world that aren't controlled by human players, randomness allows the gameplay to be varied, so the game can feel at least a little bit different every time you play it; computer-controlled characters might each behave a little bit differently, certain items may fail some of the time when you try to use them, and so on.</li>\r\n  <li>Computer simulations quite often make use of randomness.  For example, we may wish to run many separate simulations starting from the same point in time, but randomly change some of the behavior in ways that correlate with the statistical properties of what's being simulated (e.g., a simulation of cell reproduction might introduce slight DNA mutations at the same frequency as has been observed in real-world studies), so we can gain an understanding of how frequently certain effects might be seen in the real world.</li>\r\n</ul>\r\n\r\n<p>The need is clear.  The question is what kind of random sequences we might want when we're solving real problems and how we obtain them in a C++ program.  A fairly recent version of the C++ standard, C++11, introduced a new library for generating random sequences of values.  The new library, being superior in (more or less) every way to its ancient predecessor from the Standard C Library, is worth our time to learn a little bit about.  But, first, we need to understand more about how computers generate randomness.  Like a lot of things, it helps to understand the problem before you investigate the solution.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Entropy</p>\r\n\r\n<p>First thing's first: If we want to generate a sequence of random values, where do we get it from?  It's actually not as simple as it sounds.  If you think about the programs you've written, you may have noticed that they're mainly <i>deterministic</i>, which is to say that they always do the same thing given the same inputs in the same situation.  Algorithms tend to be this way; we tell a computer exactly what we want done, and exactly <i>how</i> we want it done, and the computer does it that way.  But when we want varied behavior, that's a tougher nut to crack, unless we have the right tools.</p>\r\n\r\n<p>What we need is a source of <i>entropy</i>: a sequence of bits that is unpredictable &mdash; that is, if we picked any bit in that sequence, it would have an equal probability of being a 0 or a 1, and even if we saw a huge number of those bits, it would give us no way to predict what the next bit would be.  This is actually easier said than done.  Where do we get this magical source of entropy from?  The answer, in practice, is varied.  Some operating systems gather entropy by observing aspects of their internal operation &mdash; mouse movements, network traffic, hard drive movement, and so on &mdash; that would be difficult to predict.  Some computer hardware gathers it by observing other ambient factors, like tracking small fluctuations in temperature or other physical effects over time.</p>\r\n\r\n<p>The problem, though, is that our sources of entropy are limited.  In a given space of time, there are only so many operations that our operating systems can observe, and there are only so many meaningful measurements of physical effects that can be made.  So, unfortunately, our primary sources of entropy might not be enough to supply us with the randomness we need.  If we're running a high-powered simulation that requires many megabits of randomness every second, we may run out of entropy, which means we either have to run our simulation more slowly, or we have to be more clever about how we obtain the randomness we're looking for.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Pseudorandomness</p>\r\n\r\n<p>There's an important detail worth considering, which sounds philosophical but is actually vital.  Do we need a sequence that is actually random, or will the appearance of randomness be enough?  If I chose a ridiculously long sequence of <i>n</i> bits and you had no reasonable way to use the first <i>n</i> &minus; 1 bits to guess what the <i>n</i><sup><small>th</small></sup> bit would be, would you care whether or not I used a deterministic algorithm to produce it?  In practice, the answer is generally \"no.\"  What we want is the ability to generate values so that they <i>appear to be random</i>; we want them to be varied, and we want it to be essentially impossible to guess what the next one will be, if all you've seen are the values that have been generated so far.  Whether they're coming directly from a source of entropy or from a straightforward algorithm is irrelevant for most uses.</p>\r\n\r\n<p>You might wonder, though, how a deterministic algorithm &mdash; one that always yields the same outputs given the same inputs &mdash; could ever generate anything but a predictable sequence of results.  The answer lies in how we choose the algorithm, and also in how we start the sequence.</p>\r\n\r\n<p>Suppose the first input to our algorithm comes from a legitimate source of entropy, such as the ones described in the previous section; we'll call this value the <i>seed</i>.  Now suppose that our algorithm is designed in such a way that it will generate a sequence that has the following properties:</p>\r\n\r\n<ul>\r\n  <li>At each step, our seed value is used as input to a calculation.  The result of that calculation is returned from our algorithm <i>and</i> it becomes our new seed value, so that it becomes the input to our next calculation.</li>\r\n  <li>If the algorithm is used to generate a long sequence of values, that sequence will satisfy statistical tests of randomness (i.e., it will demonstrably \"appear\" to be random) and will have a long periodicity (i.e., we can generate a very long sequence of values before the sequence begins to repeat).</li>\r\n</ul>\r\n\r\n<p>Such algorithms are known as <i>pseudorandom generators</i>, because while their output isn't random, it nonetheless passes statistical tests of randomness.  As long as you seed them with a legitimate source of entropy, they can generate fairly long sequences of random values without the sequence repeating, and since you couldn't easily guess the seed (assuming your entropy source was legitimate), you wouldn't be able to guess any of the others, either.  How to design such an algorithm is well beyond the scope of this course, but, fortunately, we can stand on the shoulders of giants and use well-known algorithms that have already been designed for this purpose, such as Mersenne Twister or a Linear Congruential method.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Distributions</p>\r\n\r\n<p>So far, we've developed a nice set of ideas for generating a long pseudorandom sequence of bits:</p>\r\n\r\n<ol>\r\n  <li>Using a (quite possibly limited) source of entropy, seed a pseudorandom generator.</li>\r\n  <li>Use the pseudorandom generator to generate the sequence of bits we need.</li>\r\n</ol>\r\n\r\n<p>There is one more problem we need to solve, though.  In practice, we generally don't want just a long sequence of bits; instead, we want a sequence of values that has additional properties.</p>\r\n\r\n<ul>\r\n  <li>If we're simulating a game involving dice, we might want to generate a sequence of <b>unsigned int</b> values in the range 1 to 6 (inclusive).</li>\r\n  <li>If we're simulating people arriving at a movie theater, we might want them to choose the movies they want to see on the basis of some notion of popularity, with some more popular (and, thus, chosen more often) than others.</li>\r\n  <li>If we're implementing a computer game with a large population of non-human-played characters, we might like them to have varied characteristics, so that some are better than others at various tasks.  Perhaps we'd like them to be distributed normally (i.e., most being closer to the average, with fewer outliers).</li>\r\n</ul>\r\n\r\n<p>So when we're solving actual problems that involve randomness, what we really want is a <i>distribution</i> of random values that satisfies our actual needs.  And that's actually tricky to get right; taking a sequence of random bits and turning it into a sequence of the kinds of values described above, if done improperly, will yield results that are biased or just plain incorrect.</p>\r\n\r\n<p>Ideally, we'd have a function we could call for this purpose, one that would take a sequence of random bits and turn it into the distribution of random values that we actually need.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Putting it all together in C++11 and later</p>\r\n\r\n<p>All of these concepts that we've been talking about describe the various parts of the <b>&lt;random&gt;</b> library that was added in the C++11 standard.  Once you know how these pieces fit together, there are only a few minor details left to get right.  In C++11:</p>\r\n\r\n<ul>\r\n  <li>A source of entropy is called a <b>random_device</b>.  A C++ implementation is free to implement this in any way, though the goal is for it to use a legitimate source of entropy (e.g., operating system or hardware) whenever available.  Again, sources of entropy are usually somewhat limited &mdash; they can't generate a long sequence of bits in a short amount of time and maintain their randomness &mdash; so we use these sparingly.</li>\r\n  <li>A pseudorandom generator is called a <i>random engine</i>.  Different engines use different algorithms, and you can choose from among several that are built into the library, though there is always a <b>default_random_engine</b>, which is a good choice if you don't have a good reason to choose one algorithm in particular.  And, of course, you can build your own, if you'd like, though this is pretty rarely going to be a good idea.</li>\r\n  <li>Finally, there are <i>random distributions</i>, which take a sequence of pseudorandom bits from a random engine and generate values that conform to our actual needs.  There are a number of different distributions built into the library, and you can build your own, too, if you'd like.</li>\r\n</ul>\r\n\r\n<p>So, if you want to generate a pseudorandom sequence of rolls of a single six-sided die, you could do something like this.</p>\r\n\r\n<blockquote><pre>\r\n#include &lt;random&gt;\r\n\r\n...\r\n\r\n// Creates an object that lets us tap into our source of entropy.  Note\r\n// that we only want to do this once and then use it sparingly.  Once created,\r\n// the device can be called like a function.\r\nstd::random_device device;\r\n\r\n// Now that we want to generate a pseudorandom sequence of bits, we seed a\r\n// random engine using our random_device.  While we wouldn't want to use the\r\n// random_device over and over again, we can use it to seed a pseudorandom\r\n// generator, and then let the algorithm's properties of seeming randomness\r\n// take over from there.\r\nstd::default_random_engine engine{device()};\r\n\r\n// Finally, we need a distribution, so we can specify what kinds of values we\r\n// actually want.  A uniform_int_distribution is one that generates integer\r\n// values between a given minimum and maximum (inclusive), so, for example,\r\n// the one below generates values between 1 and 6 (inclusive), with each of\r\n// those possible values being equally likely.\r\nstd::uniform_int_distribution&lt;int&gt; distribution{1, 6};\r\n\r\n// Now that we have all of the pieces set up, we're ready to generate our\r\n// sequence of die rolls.  Notice that the distribution can also be called\r\n// like a function whenever we want our next value, and that we pass the\r\n// engine as a parameter.  When the distribution needs more pseudorandom\r\n// bits, it asks the engine for them, so we don't have to worry about that\r\n// part of it; we simply say \"Give us numbers between 1 and 6\" and we'll\r\n// get a non-biased, uniformly-distributed sequence of numbers.\r\nfor (int i = 0; i &lt; 1000; ++i)\r\n{\r\n    std::cout &lt;&lt; distribution(engine) &lt;&lt; \" \";\r\n}\r\n\r\nstd::cout &lt;&lt; std::endl;\r\n</pre></blockquote>\r\n\r\n<p>Remember what's really going on here; this isn't something you just want to copy and paste without understanding what it does.  When you're solving problems that involve randomness, be sure you're clear on what each of these parts actually does.  If, for example, you did all of this &mdash; create a random device, then an engine, then a distribution &mdash; every time you generated a new value, then you'd essentially be using the random device every time, and you'd quickly run out of meaningful entropy.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Additional, in-depth information</p>\r\n\r\n<p>For a fuller explanation of the C++11 library for generating random sequences of values, you can also check out the original paper that describes it:</p>\r\n\r\n<ul>\r\n  <li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3551.pdf\">Random Number Generation in C++11</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}