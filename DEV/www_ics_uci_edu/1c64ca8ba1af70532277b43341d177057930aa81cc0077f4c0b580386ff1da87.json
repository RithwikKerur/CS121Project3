{"url": "https://www.ics.uci.edu/~majumder/VC/211HW3/vlfeat/vl/ikmeans_elkan.tc", "content": "/** @file ikmeans_elkan.tc\n ** @brief Integer K-Means - Elkan Algorithm - Definition\n ** @author Andrea Vedaldi\n **/\n\n/*\nCopyright (C) 2007-12 Andrea Vedaldi and Brian Fulkerson.\nAll rights reserved.\n\nThis file is part of the VLFeat library and is made available under\nthe terms of the BSD license (see the COPYING file).\n*/\n\n#include \"mathop.h\"\n\n/** @internal\n ** Update inter cluster distance table.\n **/\n\nstatic void\nvl_ikm_elkan_update_inter_dist (VlIKMFilt *f)\n{\n  vl_uindex i, k, kp ;\n\n  /* inter cluster distances */\n  for(k = 0 ; k < f->K ; ++ k) {\n    for(kp = 0 ; kp < f->K ; ++ kp) {\n      vl_ikmacc_t dist = 0 ;\n      if (k != kp) {\n        for(i = 0 ; i < f->M ; ++i) {\n          vl_ikmacc_t delta  = f->centers [kp * f->M + i] - f->centers [k * f->M + i] ;\n          dist  += delta * delta ;\n        }\n      }\n      f->inter_dist [k * f->K + kp] = f->inter_dist [kp * f->K + k] = dist >> 2 ;\n    }\n  }\n}\n\n/** @internal\n ** @brief Helper function to initialize filter for Triangle algorithm\n ** @param f filter.\n **/\n\nstatic void\nvl_ikm_init_elkan (VlIKMFilt *f)\n{\n  if (f->inter_dist) {\n    vl_free (f-> inter_dist) ;\n  }\n  f->inter_dist = vl_malloc (sizeof(*f->inter_dist) * f->K * f->K) ;\n  vl_ikm_elkan_update_inter_dist (f) ;\n}\n\n\n/** @internal\n ** @brief Elkan algorithm\n ** @param f     IKM quantizer.\n ** @param data  Data to quantize.\n ** @param N     Number of data elements.\n **/\n\nstatic int\nvl_ikm_train_elkan (VlIKMFilt* f, vl_uint8 const* data, vl_size N)\n{\n  /* REMARK !! All distances are squared !! */\n  vl_uindex i,pass,c,cp,x,cx ;\n  vl_size dist_calc = 0 ;\n\n  vl_ikmacc_t dist ;\n  vl_ikmacc_t *m_pt = vl_malloc(sizeof(*m_pt) * f->M * f->K) ; /* new centers (temp) */\n  vl_ikmacc_t *u_pt = vl_malloc(sizeof(*u_pt) * N) ; /* upper bound (may str) */\n  char *r_pt = vl_malloc(sizeof(*r_pt) * 1 * N) ; /* flag: u is strict */\n  vl_ikmacc_t *s_pt = vl_malloc(sizeof(*s_pt) * f->K) ; /* min cluster dist. */\n  vl_ikmacc_t *l_pt = vl_malloc(sizeof(*l_pt) * N * f->K) ; /* lower bound  */\n  vl_ikmacc_t *d_pt = f->inter_dist ; /* half inter clst dist  */\n  vl_uint32 *asgn = vl_malloc (sizeof(*asgn) * N) ;\n  vl_uint32 *counts =vl_malloc (sizeof(*counts) * N) ;\n\n  int done = 0 ;\n\n  /* do passes */\n  vl_ikm_elkan_update_inter_dist (f) ;\n\n  /* init */\n  memset(l_pt, 0, sizeof(*l_pt) * N * f->K) ;\n  memset(u_pt, 0, sizeof(*u_pt) * N) ;\n  memset(r_pt, 0, sizeof(*r_pt) * N) ;\n  for(x = 0 ; x < N ; ++x) {\n    vl_ikmacc_t best_dist ;\n\n    /* do first cluster `by hand' */\n    dist_calc ++ ;\n    for(dist = 0, i = 0 ; i < f->M ; ++i) {\n      vl_ikmacc_t delta = (vl_ikmacc_t)data[x * f->M + i] - f->centers[i] ;\n      dist += delta*delta ;\n    }\n    cx = 0 ;\n    best_dist = dist ;\n    l_pt[x] = dist ;\n\n    /* do other clusters */\n    for(c = 1 ; c < f->K ; ++c) {\n      if(d_pt[f->K * cx + c] < best_dist) {\n        /* might need to be updated */\n\n        dist_calc++ ;\n        for(dist=0, i = 0 ; i < f->M ; ++i) {\n          vl_ikmacc_t delta =\n          (vl_ikmacc_t)data[x * f->M + i]\n          - f->centers[c * f->M + i] ;\n          dist += delta * delta ;\n        }\n\n        /* lower bound */\n        l_pt[N*c + x] = dist ;\n\n        if(dist < best_dist) {\n          best_dist = dist ;\n          cx        = c ;\n        }\n      }\n    }\n\n    asgn[x] = (vl_uint32)cx ;\n    u_pt[x] = best_dist ;\n  }\n\n  /* --------------------------------------------------------------------\n   *                                                               Passes\n   * ------------------------------------------------------------------ */\n\n  for (pass = 0 ; 1 ; ++ pass) {\n\n    /* ------------------------------------------------------------------\n     *                                                 Re-calculate means\n     * ---------------------------------------------------------------- */\n    memset(m_pt, 0, sizeof(*m_pt) * f->M * f->K) ;\n    memset(counts, 0, sizeof(*counts) * f->K) ;\n\n    /* accumulate */\n    for(x = 0 ; x < N ; ++x) {\n      int cx = asgn[x] ;\n      ++ counts[ cx ] ;\n      for(i = 0 ; i < f->M ; ++i) {\n        m_pt[cx * f->M + i] += data[x * f->M + i] ;\n      }\n    }\n\n    /* normalize */\n    for(c = 0 ; c < f->K ; ++c) {\n      vl_ikmacc_t n = counts[c] ;\n      if(n > 0) {\n        for(i = 0 ; i < f->M ; ++i) {\n          m_pt[c * f->M + i] /= n ;\n        }\n      } else {\n        for(i = 0 ; i < f->M ; ++i) {\n          /*m_pt[c*M + i] = data[pairs_pt[c].j*M + i] ;*/\n        }\n      }\n    }\n\n    /* ------------------------------------------------------------------\n     *                                                      Update bounds\n     * --------------------------------------------------------------- */\n    for(c = 0 ; c < f->K ; ++c) {\n\n      /* distance d(m(c),c) and update c */\n      dist_calc++ ;\n      for(dist = 0, i = 0 ; i < f->M ; ++i) {\n        vl_ikmacc_t delta =\n        (vl_ikmacc_t)m_pt[c * f->M + i]\n        - f->centers[c * f->M + i] ;\n        f->centers[c * f->M + i] = m_pt[c * f->M +i] ;\n        dist += delta * delta ;\n      }\n      for(x = 0 ; x < N ; ++x) {\n        vl_ikmacc_t lxc = l_pt[c * N + x] ;\n        vl_uindex cx  = (int) asgn[x] ;\n\n        /* lower bound */\n        if(dist < lxc) {\n          lxc = (vl_ikmacc_t) (lxc + dist - 2*(vl_fast_sqrt_ui64(lxc)+1)*(vl_fast_sqrt_ui64(dist)+1)) ;\n        } else {\n          lxc = 0 ;\n        }\n        l_pt[c*N + x]  = lxc ;\n\n        /* upper bound */\n        if(c == cx) {\n          vl_ikmacc_t ux = u_pt[x] ;\n          u_pt[x] = (vl_ikmacc_t) (ux + dist + 2 * (vl_fast_sqrt_ui64(ux)+1)*(vl_fast_sqrt_ui64(dist)+1)) ;\n          r_pt[x] = 1 ;\n        }\n      }\n    }\n\n    /* inter cluster distances */\n    for(c = 0 ; c < f->K ; ++c) {\n      for(cp = 0 ; cp < f->K ; ++cp) {\n        dist = 0 ;\n        if( c != cp ) {\n          dist_calc++;\n          for(i = 0 ; i < f->M ; ++i) {\n            vl_ikmacc_t delta = f->centers[cp * f->M + i] - f->centers[ c * f->M + i] ;\n            dist += delta*delta ;\n          }\n        }\n        d_pt[c * f->K + cp] = d_pt[cp * f->K + c] = dist>>2 ;\n      }\n    }\n\n    /* closest cluster distance */\n    for(c = 0  ; c < f->K ; ++c) {\n      vl_ikmacc_t best_dist = VL_IKMACC_MAX ;\n      for(cp = 0 ; cp < f->K ; ++cp) {\n        dist = d_pt[c * f->K + cp] ;\n        if(c != cp && dist < best_dist) best_dist = dist ;\n      }\n      s_pt[c] = best_dist >> 2 ;\n    }\n\n\n    /* ------------------------------------------------------------------\n     * Assign data to centers\n     * ---------------------------------------------------------------- */\n    done = 1 ;\n    for(x = 0 ; x < N ; ++x) {\n      vl_uindex cx = (vl_uindex) asgn[x] ;\n      vl_ikmacc_t ux = u_pt[x] ;\n\n      /* ux is an upper bound of the distance of x to its\n         current center cx. s_pt[cx] is half of the minum distance\n         between the cluster cx and any other cluster center.  If\n         ux <= s_pt[cx] then x remains attached to cx. */\n\n      if(ux <= s_pt[cx])  continue ;\n\n      for(c = 0 ; c < f->K ; ++c) {\n        vl_ikmacc_t dist = 0 ;\n        /* so x might need to be re-associated from cx to c. We can\n           exclude c if\n\n           1 - cx = c (trivial) or\n           2 - u(x) <= l(x,c)    as this implies d(x,cx) <= d(x,c) or\n           3 - u(x) <= d(cx,c)/2 as this implies d(x,cx) <= d(x,c).\n        */\n        if(c  == cx ||\n           ux <= l_pt[N * c +  x] ||\n           ux <= d_pt[f->K * c + cx])\n          continue ;\n\n        /* we need to make a true comparison */\n\n        /* if u_pt[x] is stale (i.e. not strictly equal to\n           d(x,cx)), then re-calcualte it. */\n        if( r_pt[x] ) {\n          dist_calc++;\n          for(dist = 0, i = 0 ; i < f->M ; ++i) {\n            vl_ikmacc_t delta = (vl_ikmacc_t)data[x * f->M + i] - f->centers[cx * f->M + i] ;\n            dist += delta*delta ;\n          }\n          ux = u_pt[x] = dist ;\n          r_pt[x] = 0 ;\n\n          /* now that u_pt[x] is updated, we check the conditions\n             again */\n          if(\n             ux <= l_pt[N * c +  x]  ||\n             ux <= d_pt[f->K * c + cx]  )\n            continue ;\n        }\n\n        /* no way... we need to compute the distance d(x,c) */\n        dist_calc++ ;\n        for(dist = 0, i = 0 ; i < f->M ; ++i) {\n          vl_ikmacc_t delta = (vl_ikmacc_t)data[ x * f->M + i] - f->centers[c * f->M + i] ;\n          dist += delta * delta ;\n        }\n\n        l_pt[N * c + x] =  dist ;\n\n        if (dist < ux) {\n          ux = u_pt[x] = dist ;\n          /* r_pt[x] already 0 */\n          asgn[x] = (vl_uint32)c ;\n          done = 0 ;\n        }\n      }\n    } /* next data point */\n\n      /* stopping condition */\n    if(done || pass == f->max_niters) {\n      break ;\n    }\n  }\n\n  vl_free (counts) ;\n  vl_free (asgn) ;\n  vl_free (l_pt) ;\n  vl_free (s_pt) ;\n  vl_free (r_pt) ;\n  vl_free (u_pt) ;\n  vl_free (m_pt) ;\n\n  if (f-> verb) {\n    VL_PRINTF (\"ikm: Elkan algorithm: total iterations: %d\\n\", pass) ;\n    VL_PRINTF (\"ikm: Elkan algorithm: distance calculations: %d (speedup: %.2f)\\n\",\n               dist_calc, (float)N * f->K * (pass+2) / dist_calc - 1) ;\n  }\n  return 0 ;\n}\n\n/** @internal\n ** @brief Elkan algorithm\n ** @param f    IKM quantizer.\n ** @param asgn Assignment of data to centers (out).\n ** @param data Data to quantize.\n ** @param N    Number of data elements.\n **/\n\nstatic void\nvl_ikm_push_elkan (VlIKMFilt *f, vl_uint32 *asgn, vl_uint8 const *data, vl_size N)\n{\n  vl_uindex i,c,cx,x ;\n  vl_size dist_calc = 0 ;\n  vl_ikmacc_t dist, best_dist ;\n  vl_ikmacc_t *d_pt = f->inter_dist ;\n\n  /* assign data to centers */\n  for(x = 0 ; x < N ; ++x) {\n    best_dist = VL_IKMACC_MAX ;\n    cx = 0 ;\n\n    for(c = 0 ; c < f->K ; ++c) {\n      if(d_pt[f->K * cx + c] < best_dist) {\n        /* might need to be updated */\n        dist_calc ++ ;\n        for(dist=0, i = 0 ; i < f->M ; ++i) {\n          vl_ikmacc_t delta = data[x * f->M + i] - f->centers[c * f->M + i] ;\n          dist += delta * delta ;\n        }\n\n        /* u_pt is strict at the beginning */\n        if(dist < best_dist) {\n          best_dist = dist ;\n          cx        = c ;\n        }\n      }\n    }\n    asgn[x] = (vl_uint32)cx ;\n  }\n}\n\n/*\n * Local Variables: *\n * mode: C *\n * End: *\n */\n", "encoding": "ascii"}