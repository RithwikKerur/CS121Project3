{"url": "https://www.ics.uci.edu/~eppstein/163/s16-hw2.html", "content": "\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n<html>\n<head>\n<title>CompSci 163/265, Spring 2016, Homework 2</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script type=\"text/javascript\" src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n</head>\n<body>\n<h1>CompSci 163/265, Spring 2016, Homework 2</h1>\n<ol>\n<li><p>(163 students:) Prove that the smallest and second-smallest\nweight edges in an undirected graph are always both part of the minimum\nspanning tree. (Hint: what does Kruskal's algorithm do with these\nedges?)</p>\n<p>(265 students:) Suppose that the vertices of a graph are colored\nblack and white. Define an edge to be white if both its endpoints are\nwhite, black if both its endpoints are black, and gray if it has one\nblack and one white endpoint. The blue rule shows that the smallest gray\nedge is always part of the minimum spanning tree. Is the second-smallest\ngray edge also always part of the minimum spanning tree? If so, prove\nit. If not, find an example where it is not.</p></li>\n<li><p>What are the smallest and largest possible numbers of rounds that\nBoruvka's algorithm can take to compute the minimum spanning tree of an\neight-vertex connected graph? (Here a \"round\" means that each spanning\ntree in the current forest finds its smallest outgoing edge, and all\nthese edges are added to the forest. As usual, we assume that there are\nno two edges with equal weights.) Give an example of an eight-vertex\ngraph that uses the smallest possible number of rounds, and another\neight-vertex graph that uses the largest possible number of\nrounds.</p></li>\n<li><p>The red rule can be used to prove the correctness of a \"backwards\nKruskal\" algorithm that sorts the edges in descending order by weight\nand then loops through the edges in that order, deleting any edge that\nbelongs to a cycle in the remaining graph. To test whether an edge\nbelongs to a cycle, we can use depth first search to look for a path\nthat does not go through the edge but connects its endpoints. What is\nthe running time of this algorithm, including both the time for the\nsorting step and the time to do a depth first search for each edge?\nExpress your answer in $O$-notation, as a function of $n$, the number of\nvertices, and $m$, the number of edges. (This algorithm is described in\nWikipedia as\nthe <a href=\"https://en.wikipedia.org/wiki/Reverse-delete_algorithm\">reverse-delete\nalgorithm</a> but the analysis on Wikipedia uses different variable\nnames and a more sophisticated method than depth-first search to find\ncycles, and should not be used for your answer. Your answer should\nbe simplified as much as possible; you may assume that $m > n$.)</p></li>\n<li><p>Give an example of a system of voter preferences for which\nthe <a href=\"https://en.wikipedia.org/wiki/Borda_count\">Borda count</a>\ndoes not obey\nthe <a href=\"https://en.wikipedia.org/wiki/Condorcet_method\">Condorcet\nproperty</a>. That is, for each of the $k!$ permutations of the set of\n$k$ candidates, you should specify how many voters prefer that\npermutation. This specification should have the property that there is\none candidate who wins all head-to-head competitions against individual\nother candidates (the Condorcet winner), but that the Borda count\nchooses a different winner than this candidate. As part of your answer,\nspecify who the Condorcet winner is and who the Borda winner\nis.</p></li>\n</ol>\n</body>\n</html>\n", "encoding": "ascii"}