{"url": "https://www.ics.uci.edu/~thornton/cs141/ProjectGuide/Project2/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\n\n<title>CompSci 141 / CSE 141 / Informatics 101 Spring 2013, Project #2</title>\n</head>\n<body>\n\n<div class=\"navbar\">\n\n<p>\nCompSci 141 / CSE 141 / Informatics 101 Spring 2013 |\n<a href=\"../../index.html\">News</a> |\n<a href=\"../../CourseReference.html\">Course Reference</a> |\n<a href=\"../../Schedule.html\">Schedule</a> |\n<a href=\"../../ProjectGuide\">Project Guide</a> |\n<a href=\"../../CodeExamples\">Code Examples</a> |\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\n</p>\n\n<hr />\n\n</div>\n\n<div class=\"header\">\n\n<p>CompSci 141 / CSE 141 / Informatics 101 Spring 2013<br />\n   Project #2</p>\n\n</div>\n\n<div class=\"section\">\n\n<p class=\"center\"><b>Due date and time:</b> <i>Monday, April 29, 11:59pm</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Introduction</p>\n\n<p>Following from our recent discussion of static type systems and generic programming in Java during lecture, this project asks you to write a few generic classes in Java that interact with one another.  In addition to the straightforward style of generics exhibited by the Stack example in lecture, this assignment will include concepts such as <i>bounded type parameters</i>, <i>comparability</i>, <i>iteration</i>, and the <i>\"foreach\" loop</i>, making for an interesting tour of some of the depth in Java's type system.</p>\n\n<p>The task itself will have a somewhat algorithmic bent, though I'll provide you with details of how to implement the algorithms &mdash; I don't expect you to have built something like this before, but I do expect that your prior coursework will have prepared you to do so, given a description.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Background information</p>\n\n<p>There are a few relatively brief articles you should read to give you more background on the Java features you'll be using in this assignment.  If you attended the lecture on this topic, you've seen much of this &mdash; but certainly not all of it &mdash; already.  If you missed the lecture, this reading will be a reasonable substitute.</p>\n\n<ul>\n  <li><a href=\"http://java.sun.com/docs/books/tutorial/java/generics/index.html\">The Generics lesson from \"The Java Tutorial\"</a>, which is a complete tutorial on the subject of Java generics.  It would be wise to go through all of this material, even though some of it goes a bit beyond the scope of what we talked about in lecture.</li>\n  <li><a href=\"http://java.sun.com/docs/books/tutorial/extra/generics/index.html\">A more thorough lesson on generics</a> from Gilad Bracha.  You don't have to read this, but it will provide you with some deeper insights if you're so inclined.</li>\n  <li><a href=\"http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html\">The Java Generics FAQ</a> from Angelika Langer is a comprehensive set of information about generics in a question-and-answer format.  Much of this is well beyond the scope of our needs in this course, but if you have a question about some of the inner workings of generics, you'll very likely find the answer to it here.</li>\n</ul>\n\n<p>Additionally, be sure to have a look at my commented code example, a <a href=\"../../CodeExamples/GenericStack.zip\">generic, iterable Stack class in Java</a>, much of which we went through in lecture.  Part of this project will require the use of a stack.  You may use this provided stack class as-is if you wish, or adapt it if you'd like it to behave differently.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">The program</p>\n\n<p>For this project, you will be required to build a generic binary search tree implementation of the classical <i>map</i> data structure.  Recall that, abstractly, a map is a set of <i>associations</i>, each of which contains a unique <i>key</i> and a <i>value</i> (not necessarily unique) that is associated with that key.  Maps typically provide common operations such as adding a new key/value pair, looking up the value associated with a key, and removing a key/value pair given its key, among other possibilities.</p>\n\n<p>In addition to implementing the basic concept of a map, binary search trees also add the ability to keep the keys sorted automatically, so, for example, you can iterate them in ascending order.  In order to keep the keys sorted, the keys must be <i>comparable</i>, in the sense that it must be possible to compare two keys and decide which is smaller; this property also allows the tree to be constructed in a way that it can be efficiently searched.</p>\n\n<p>Your binary search tree will need to be <i>iterable</i>, meaning that its associations can be accessed sequentially using an iterator.  You are required to implement this iteration using the standard Java techniques that are demonstrated in the <a href=\"../../CodeExamples/GenericStack.zip\">generic Stack example</a>.</p>\n\n<p>In addition to the generic binary search tree class, you will need to build a short program that demonstrates its functionality.  Be sure that you've instantiated at least two different kinds of binary search trees (i.e., binary search trees with different actual type parameters) and demonstrated each of the methods in your binary search tree class, along with iteration both with and without the use of the \"foreach\" loop.  For at least one of the instantiations, I'd like you to define and use a class of your own design that implements the Comparable&lt;E&gt; interface, which is discussed later in the write-up; the class can otherwise encapsulate whatever abstraction you'd like.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Recalling binary search trees</p>\n\n<p>Recall, again, that a binary search tree is one way of implementing a map.  It is a binary tree with one association (key/value pair) stored in each node, with the following rules used to enforce an ordering on the keys within the tree:</p>\n\n<ul>\n  <li>For all nodes <i>n</i> containing a key <i>k</i>:\n    <ul>\n      <li>All of the keys in the left subtree of <i>n</i> will have keys less than <i>k</i>.</li>\n      <li>All of the keys in the right subtree of <i>n</i> will have keys greater than <i>k</i>.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>With these rules in place, fast searching for keys (O(log <i>n</i>) time in a tree with <i>n</i> nodes) is possible (assuming that the tree is relatively balanced) by following one \"path\" from the root of the tree downward toward the key in question.</p>\n\n<p class=\"subtitle\">Three fundamental binary search tree algorithms</p>\n\n<p>The three most fundamental algorithms that you'll need to implement in a binary search tree are adding a new key/value pair, removing a key/value pair given its key, and looking up the value associated with a key.  They are summarized in pseudocode below, which you're free to adapt into Java and use in your solution.  Each of these algorithms is implemented recursively, though iterative implementations are also possible, and either is fine for this assignment.</p>\n\n<pre>\n    // Add a new association with key k and value v to a subtree whose\n    // root is n, returning the resulting subtree.\n    Node add(Node n, Key k, Value v):\n        if n == null:\n            return new Node(k, v);\n        else if k < n.key:\n            n.left = add(n.left, k, v);\n            return n;\n        else // k > n.key\n            n.right = add(n.right, k, v);\n            return n;\n\n\n    // Lookup the value associated with the key k in the subtree whose\n    // root is n.\n    Value lookup(Node n, Key k):\n        if n == null:\n            return an error (e.g., throw an exception);\n        else if k == n.key:\n            return n.value;\n        else if k < n.key:\n            return lookup(n.left, k);\n        else // k > n.key\n            return lookup(n.right, k);\n\n\n    // Remove the key/value pair with key k from the subtree whose root\n    // is n, returning the resulting subtree.  Depends on two helper\n    // functions:\n    //    * findMin, which returns the node with the minimum key\n    //      in a subtree\n    //    * removeMin, which removes the node with the minimum key\n    //      in a subtree\n    Node remove(Node n, Key k):\n        if n == null:\n            return an error (e.g., throw an exception);\n        else if k == n.key:\n            if n.left == null && n.right == null:\n                return null;\n            else if n.left != null && n.right != null:\n                Node min = findMin(n.right);\n                n.key = min.key;\n                n.value = min.value;\n                removeMin(n.right);\n                return n;\n            else if n.left != null:\n                return n.left;\n            else // n.right != null\n                return n.right;\n        else if k < n.key:\n            n.left = remove(n.left, k);\n            return n;\n        else // k > n.key\n            n.right = remove(n.right, k);\n            return n;\n</pre>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Bounded type parameters</p>\n\n<p>The data-ordering rules of binary search trees &mdash; as well as the sketched algorithms above for implementing them &mdash; make clear a constraint on the keys: it must be possible to compare them to one another for the purposes of determining, for all pairs of keys <i>x</i> and <i>y</i>, which of the following relationships holds between them: <i>x</i> = <i>y</i>, <i>x</i> &lt; <i>y</i>, or <i>x</i> &gt; <i>y</i>.  Furthermore, this relationship must always be the same for any pair of keys, so that searches for a key will proceed along the same path as that followed during its insertion.  Types for which these kinds of comparisons must not be eligible to be used as keys, because there would be no way to determine their appropriate order.</p>\n\n<p>Generic classes, as we've discussed them, allow type parameters to be specified, for the purposes of making the class generic (allowing it to, say, store any kind of data) without resorting to the use of Object references (which are not type-safe, because there's no way to tell at compile time what type of objects the references will actually point to).  For example, the provided Stack&lt;E&gt; class is an improvement over a non-generic Stack class, because it allows you to specify in your program &mdash; so that it can be known at compile time &mdash; what types of objects you intend to store in each stack you instantiate.  Armed with this knowledge, the compiler can report an error when a program attempts, for example, to push a Student object into a Stack&lt;String&gt;, taking type errors that would otherwise be run-time errors and turning them into compile-time errors instead, which is the primary advantage of programming in a statically-typed language like Java.</p>\n\n<p>The problem with generic classes that have unrestricted type parameters is that they can be, in a sense, <i>too</i> generic; in a particular instantiation of Stack&lt;E&gt;, E can be any kind of object.  This is fine for stacks, since there's no reason why any kind of object couldn't be stacked.  However, this causes a serious problem when you're talking about a class like BinarySearchTree&lt;K, V&gt;, where there needs to be a restriction placed on the types of the keys, namely that only \"comparable\" types can be used as keys.</p>\n\n<p>One way to solve this problem is to check the keys at run time; any time a key of a non-comparable type is added to a binary search tree, an exception can be thrown.  Of course, this solution negates part of the benefit of using generic classes in the first place.  We want type errors to be caught at compile time, rather than run time, if they can be; inserting a key of a non-comparable type <i>is</i> a type error!  It is important, then, that we empower the compiler with enough information to be able to report compile-time errors when an attempt is made to instantiate BinarySearchTree with a type of key that is not comparable.</p>\n\n<p>This issue was not lost on the designers of generic classes in Java.  The solution provided in Java is the use of <i>bounded type parameters</i>.  Bounded type parameters are type parameters that are restricted.  In particular, they are restricted to types that extend from some class or implement some interface.  In general, <b>class Foo&lt;E extends F&gt;</b>, means:</p>\n\n<ul>\n  <li>The class Foo takes one type parameter, E.</li>\n  <li>If F is a class, Foo must be instantiated with either the class F or a class that extends F.  So, for example, Foo&lt;F&gt; would be a legal instantiation, as would Foo&lt;G&gt;, if G extends F.</li>\n  <li>If F is an interface, Foo must be instantiated with either the interface F or a class that implements F.</li>\n</ul>\n\n<p>(Curiously, the keyword \"extends\" is used in this context whether F is a class or an interface.)</p>\n\n<p>In the Java library, an interface called <b>Comparable&lt;E&gt;</b> exists that embodies the notion of comparability, as we've talked about it.  It contains one method called <b>compareTo</b> that is intended to be used to compare pairs of objects to see which is smaller than the other (or if they're equal).  You should read more about it in the <a href=\"http://docs.oracle.com/javase/7/docs/api/\">Java 7 API documentation</a> if you're unfamiliar with it, as I'll expect you to be able to use it appropriately in this project.</p>\n\n<p>Comparable&lt;E&gt;, as you might imagine when you see that it takes a type parameter, is generic.  Its type parameter, E, refers to the type of object that something can be compared to.  For example, String implements Comparable&lt;String&gt;, which means that Strings can be compared to other Strings.  The technical reason that the type parameter is included is this: its compareTo method takes an object of some type as a parameter, comparing \"this\" object to the object passed as a parameter.  If the Comparable interface was not generic, this method would be forced to take a parameter of some non-specific type such as Object, and then cast its parameter before making its comparison.  By making the interface generic, it becomes possible to say that the objects of some class can be compared, but that they can only be compared to objects of a certain type.  Most commonly, a class X that is intended to be comparable will implement Comparable&lt;X&gt;, to establish the fact that X's are comparable only to other X's.</p>\n\n<p>Since implementing the Comparable&lt;E&gt; interface is the standard way in Java to specify that the objects of a class are comparable to one another, it makes sense to restrict the keys in a generic binary search tree class to be of some class that implements the Comparable&lt;E&gt; interface.  On the other hand, there is no restriction necessary on the values; they can be any kind of object.  So, the appropriate generic name for a binary search tree class, and the one I'll expect you to use in this assignment, is <b>BinarySearchTree&lt;K extends Comparable&lt;K&gt;, V&gt;</b>.  In other words, a BinarySearchTree takes two parameters: a key type K (where keys must be comparable to other objects of that same type K), and a value type V, which is unconstrained.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Design of the various classes</p>\n\n<p>I would like you to break up the implementation of your binary search tree into the following classes.  This is not necessarily an exhaustive list of the classes you'll need, but will give you a good idea of the design that I'm asking you to pursue.  The emphases here are type safety and support of the standard Java iteration feature.</p>\n\n<ul>\n  <li><b>BinarySearchTree&lt;K extends Comparable&lt;K&gt;, V&gt; implements Iterable&lt;Association&lt;K, V&gt;&gt;</b>.  This class encapsulates a binary search tree with keys of type K and values of type V.  Note that K is a bounded type parameter, as discussed in the previous section.  On the other hand, V is not bounded, since any type of object can be used as a value.  For our purposes, we'll say that iterating a BinarySearchTree should return key/value pairs, so that either the keys or the values can be iterated.  These are implemented as Associations, which are described next; this is why the class implements Iterable&lt;Association&lt;K, V&gt;&gt;, rather than Iterable&lt;K&gt; or Iterable&lt;V&gt;.  (The next section of the write-up provides more details about the Iterable interface, which is part of the Java library.)</li>\n  <li><b>Association&lt;K, V&gt;</b>.  This class encapsulates one association (a key/value pair).  This may seem like an implementation detail, one that should be hidden as a private member of the BinarySearchTree class, but the class should actually be defined separately from, and outside of, BinarySearchTree.  The reason is that an Iterator over a BinarySearchTree should return Associations, not keys or values by themselves.  So, code outside of the BinarySearchTree class needs to be aware of the existence of Associations.  As a protection, Associations should be <i>immutable</i>, meaning that you may not modify what keys/values are stored in them.  This is vitally important for keys, since BinarySearchTree has the sole responsibility of ensuring that all keys in the tree are unique and that they're stored in an ordered fashion that will allow for fast lookups.  It's philosophically important for values, too, since we're entrusting BinarySearchTree with the task of managing relationships between keys and values.\n    <ul>\n      <li>Note that Associations are not nodes.  The BinarySearchTree should consist of a collection of nodes, with each node storing an Association.  You may well want to include the node class within the BinarySearchTree class and make it private.</li>\n    </ul>\n  </li>\n  <li><b>BSTIterator implements Iterator&lt;Association&lt;K, V&gt;&gt;</b>.  This class should be defined privately within the BinarySearchTree class, similarly to the StackIterator implemented in the <a href=\"../../CodeExamples/GenericStack.zip\">generic Stack code example</a>.  It should iterate the nodes of the tree in ascending order of the keys.  You are not required to support the remove( ) operation, but you will need to implement the remove( ) method.  However, the Java library allows an iterator to forego support for the remove( ) method by having it throw UnsupportedOperationException whenever it's called.  This is perfectly okay for this assignment, though you may implement the remove( ) method if you wish.</li>\n  <li><b>Stack&lt;E&gt;</b>.  This class will be needed in your implementation of BSTIterator.  You may use the Stack&lt;E&gt; class that I provided, or you may write your own.  More information about how to use the stack in your iterator implementation follows in the next section of the write-up.</li>\n</ul>\n\n<p>In addition to iteration (and presumably some kind of node class), your BinarySearchTree class must support the following operations:</p>\n\n<ul>\n  <li>Adding a new association, given a key and a value.  Remember that keys must be unique in a binary search tree.  You may handle this problem however you wish (e.g., by throwing an exception or replacing the old value with the new one).  This method should take a key and a value as a parameter, rather than an Association.  In other words, you shouldn't require a user of this class to create a new Association object in order to call this method.</li>\n  <li>Removing an association, given a key.  (You are not required to support removal through an iterator, but I do want you to have an operative remove method in the BinarySearchTree class.)</li>\n  <li>Look up a value, given a key.  This should run in <i>O</i>(log <i>n</i>) time, assuming that the tree is relatively balanced.</li>\n  <li>Look up a key, given a value.  This will require a full tree traversal, which might easily be implemented by using an iterator.  (More details about iterators follow in the next section.)</li>\n  <li>Clear a tree out, removing all of the associations.</li>\n  <li>Get the number of associations in the tree.</li>\n</ul>\n\n<p>The algorithms for doing adds, removes, and lookups are summarized in the section titled <i>Recalling binary search trees</i> above.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Implementing an iterator over a binary search tree</p>\n\n<p class=\"subtitle\">Iterator&lt;E&gt; and Iterable&lt;E&gt; in Java</p>\n\n<p>An <i>iterator</i> is an object that allows access to all of the elements in some collection (e.g., the objects in a linked list, the associations in a binary search tree, or even the lines of text in a text file) without exposing details of how the collection is implemented.  This is a powerful abstraction, since it not only insulates code outside of the collection from changes in the implementation of that collection, but it also allows code to iterate over a collection without even knowing what kind of collection it's iterating, allowing it to work in a variety of contexts instead of being limited to just one.  For instance, you could write a method <b>printAll( )</b> that could print all of the elements in any kind of collection, simply by having the method take an iterator as a parameter, rather than a collection.  In this way, not only can classes be generic, but so can algorithms.</p>\n\n<p>The standard Java iterator, defined in the Iterator&lt;E&gt; interface in the Java library, supports three methods.</p>\n\n<table class=\"normal\">\n  <tr class=\"top\"><td>Method signature</td><td>Brief description</td></tr>\n  <tr><td>boolean hasNext()</td><td>returns true if there are more elements not yet returned by this iterator</td></tr>\n  <tr><td>E next()</td><td>returns the next element in the underlying collection</td></tr>\n  <tr><td>void remove()</td><td>removes the last element returned by next() from the underlying collection</td></tr>\n</table>\n\n<p>(Be sure to look at the <a href=\"http://docs.oracle.com/javase/7/docs/api/\">Java 7 API documentation</a> for a more thorough description of this and other relevant parts of the Java library.)</p>\n\n<p>We say that objects of a class are <i>iterable</i> if an iterator can be created to iterate over their contents.  For example, we might like a linked list to be iterable, meaning that an iterator can be created and used to iterate over each of the elements in the list.  In Java, the standard way of specifying that objects of a class are iterable is to have the class implement the Iterable&lt;E&gt; interface.  If you were to build a LinkedList&lt;E&gt; class, you might have it implement the Iterable&lt;E&gt; interface.  The Iterable&lt;E&gt; interface supports one method.</p>\n\n<table class=\"normal\">\n  <tr class=\"top\"><td>Method signature</td><td>Brief description</td></tr>\n  <tr><td>Iterator&lt;E&gt; iterator()</td><td>returns a new Iterator&lt;E&gt; that can be used to iterate over the elements of a collection</td>\n</table>\n\n<p>The \"E\" in all of these places links together the type of elements in the linked list with the type of elements that will be returned when you iterate through the list.  A LinkedList&lt;String&gt; implements Iterable&lt;String&gt;, which means that you can ask the list to create an Iterator&lt;String&gt; that can be used to iterate over its elements.  Notice that String is the type parameter in all of these cases, since you ought to get back Strings when you access the elements of a LinkedList of Strings.</p>\n\n<p>Your binary search tree class is required to support iteration in the standard way that Java collections support it, meaning that it should be iterable and the iterator should, in this case, return associations (key/value pairs) in ascending order of the keys stored in the tree.</p>\n\n<p class=\"subtitle\">Iterable and Iterator enables the \"foreach\" loop</p>\n\n<p>Java 5, released a decade or so ago, introduced not only generics, but also a loop that is commonly called the \"foreach\" or \"enhanced for\" loop.  It abstracts the typical usage pattern of creating an iterator and iterating through the elements of a collection, wrapping it into a simple piece of syntax with the repetitive details hidden.  For example, given an ArrayList&lt;String&gt; called <i>a</i>, the following code prints out the elements of that ArrayList in the order they're stored:</p>\n\n<pre>\n    for (String s : a)\n        System.out.println(s);\n</pre>\n\n<p>This is a form of what is called <i>syntactic sugar</i>.  Syntactic sugar is something that makes a language easier to use without introducing any new capabilities.  In this case, the \"foreach\" loop above could have been written like this instead:</p>\n\n<pre>\n    Iterator&lt;String&gt; i = a.iterator();\n    \n    while (i.hasNext())\n    {\n        String s = i.next();\n        System.out.println(s);\n    }\n</pre>\n\n<p>In fact, a Java compiler will effectively take the \"foreach\" loop shown here and turn it into the lengthier code using the Iterator.  This means that you won't need to write the lengthier code in the vast majority of cases, where the only thing you need the iterator for is to get the value of each element and do something with it.  (In some cases, such as cases where you might need to call remove() on the iterator, or when you need to access the elements in an order other than the order that the iterator will return them, you'll need to write more specific code.)</p>\n\n<p>Hooking your own class into the \"foreach\" loop turns out to be relatively easy in Java: have your class implement the Iterable interface and implement an iterator for it.  When you're done with your BinarySearchTree, it will be possible to use the \"foreach\" loop to iterate over its associations.</p>\n\n<p class=\"subtitle\">How iterators and traversals are different</p>\n\n<p>Recall that an inorder traversal of a binary search tree visits all of the keys in ascending order.  An inorder traversal is typically written as a recursive algorithm, roughly like this:</p>\n\n<pre>\n    inorder(Tree T):\n        if T has a left subtree:\n            inorder(left subtree of T)\n        \n        visit the root of T\n        \n        if T has a right subtree:\n            inorder(right subtree of T)\n</pre>\n\n<p>The \"visit\" step in the algorithm is abstract; it can be used for different things in different contexts.  It might involve printing a key/value pair to the screen, saving a key/value pair to a file, checking to see if a key/value pair meets some search criteria, or whatever.</p>\n\n<p>This algorithm visits all of the keys in ascending order, by definition of a binary search tree: for all subtrees S of the tree T (including T itself), all of the keys in the left subtree of S are guaranteed to be less than the key in S's root, while all of the keys in the right subtree of S are guaranteed to be greater than the key in S's root.  This recursive algorithm visits all of the keys in the left subtree before visiting the root, and it visits the root before visiting the keys in the right subtree.  So the keys are visited in ascending order.</p>\n\n<p>The simplest way to implement this kind of traversal is to write a recursive method that does the same thing that the algorithm above does, returning when the entire traversal is complete.  However, in Java, this kind of implementation is incompatible with the notion of an iterator, which is intended to perform a traversal one step at a time.  In other words, an iterator will traverse to the \"next\" key in ascending order every time its next( ) method is called, then pause until the next( ) method is called again.  When the next( ) method is called again, it will pick up where it left off, traversing to the \"next\" key in ascending order again, then pause again until the subsequent call to next( ).  The key to implementing an iterator is to be able to \"pause\" the iteration, allowing it to pick up where it left off next time you ask for the \"next\" key.</p>\n\n<p>Why Java makes this kind of implementation difficult is that there's no straightforward way to \"pause\" a method and have it pick up where it left off.  (This is not to say that it can't be done in Java; for example, threading would allow it.  But threading is a heavyweight solution to what should, in this case, be a lightweight problem.  We'll see examples from other languages later this quarter in which implementing iterators becomes no more difficult than a straightforward traversal.)</p>\n\n<p>One solution to this problem is to perform an entire traversal in the iterator's constructor, saving the key/value pairs into an ArrayList or other \"flat\" data structure in ascending order of the keys.  However, if the tree is large, this approach is neither memory- nor time-efficient.  A better approach is to perform the traversal one step at a time, each time the next( ) method is called.  This requires a bit of extra complexity in the implementation of the iterator, but this is a small price to pay for a large improvement in memory usage.  You are required to implement your iterator <i>without</i> performing an entire traversal up-front; instead, you'll need to run the traversal step by step, moving to the next key only when next( ) is called.</p>\n\n<p class=\"subtitle\">Running the traversal step by step in the iterator</p>\n\n<p>In place of a recursive algorithm that runs the entire traversal to completion before returning, you'll instead need to implement your iterator so that it performs the traversal step by step, doing a little bit of work each time next( ) is called, then saving its state so it can pick up where it left off in the subsequent call to next( ).  In order to implement your iterator this way, you'll first need to decide what state needs to be saved between calls to next( ).</p>\n\n<p>At any given time throughout a traversal implemented using the recursive algorithm, the run-time stack is essentially keeping track of two things:</p>\n\n<ol>\n  <li>The current node on the top of the run-time stack, its parent below it, its parent's parent below it, and so on.</li>\n  <li>Along with each node, an indication of whether the left and right subtrees of the node have already been traversed.</li>\n</ol>\n\n<p>Since you will not be implementing a recursive traversal that runs to completion, you will need to store this information yourself between calls to next( ).  This is the reason why I suggested writing a Stack&lt;E&gt; class (or using the one that I provided).  You'll need it to store this state information.  (Note that the goal of using a Stack is <i>not</i> to push all of the binary search tree's elements into it, then pop them one at a time.)</p>\n\n<p>With this in mind, the rough approach for implementing the iterator goes something like this.  (I've purposefully left some of the details unspecified.)</p>\n\n<ul>\n  <li>In the iterator's constructor, begin by pushing the root node on to the stack, along with an indication that neither of its subtrees have been traversed yet.  If the tree is empty, leave the stack empty as well.</li>\n  <li>The hasNext( ) method returns false if and only if the stack is empty.</li>\n  <li>In the next( ) method, the top of the stack is interpreted to be the \"current node.\"  You'll do different things here, depending on whether the current node's left and/or right subtrees have been traversed already.  After each call to next( ), the current node should be the next node in ascending order of keys whose key/value pair has not yet been returned.  As you advance your traversal down the tree, push nodes on to the stack; as your traversal moves up the tree, pop nodes from the stack.  At all times, the stack should contain, from the top of the stack to the bottom, the entire path from the current node to the parent.  Each node should be accompanied in the stack by an indication of whether its left and/or right subtrees have already been traversed.  (Note that these indications should be stored in the stack, <i>not</i> in the tree nodes themselves.  This is because multiple iterators may be iterating over a tree simultaneously.)</li>\n</ul>\n\n<p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">For us, \"unchecked\" and \"raw type\" warnings are errors</p>\n\n<p>The main purpose of this assignment is to give you practice with generic classes in Java.  If you're using generics properly, you will have no type errors and will need no typecasts in your code.  For this reason, when we grade this assignment, \"unchecked\" or \"raw type\" warnings will be considered errors.  These indicate a problem with your use of generics (usually caused by leaving the type parameter off of a declaration somewhere) and, thus, need to be fixed.  So you'll want to be sure that your compiler is configured to give you these warnings.</p>\n\n<p>Be sure that your program compiles this way with no errors and no warnings before you submit it.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Limitations</p>\n\n<p>You may not use a pre-existing binary search tree implementation (e.g., java.util.TreeMap) for this assignment.  I'd like you build your binary search tree class from scratch.  As stated earlier, you may use the provided generic Stack&lt;E&gt; class as part of your implementation of the binary search tree iterator, though you may not use the pre-existing java.util.Stack from the Java library.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Deliverables</p>\n\n<p>You need to submit all of your Java source files (.java), including any that were provided to you.  Do not submit compiled versions of your program, or other files generated by your development environment.</p>\n\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for a discussion of how to submit your project.  Remember that we do not accept project submissions via email <i>under any circumstances</i>.</p>\n\n</div>\n\n<div class=\"history\">\n\n<hr />\n\n<ul class=\"nomarker\">\n  <li>Some clarifications and additional background added by Alex Thornton, Spring 2013.</li>\n  <li>Cleaned up, with additional explanation about binary search tree algorithms added, by Alex Thornton, Fall 2007.</li>\n  <li>Updated to properly require the use of the Comparable&lt;E&gt; interface (rather than Comparable with no type parameter) along with some additional explanation, by Alex Thornton, Fall 2005.</li>\n  <li>Additional sections added by Alex Thornton, Winter 2005.</li>\n  <li>Originally written by Alex Thornton, Fall 2004.</li>\n</ul>\n\n</div>\n\n</body>\n</html>\n", "encoding": "ascii"}