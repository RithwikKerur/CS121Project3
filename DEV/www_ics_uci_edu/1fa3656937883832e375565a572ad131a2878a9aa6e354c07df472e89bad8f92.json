{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/template.txt", "content": "\t\t\tUsing the ICS46 Template Library Classes\r\n\r\n\r\nIntroduction:\r\n\r\nIn this lecture we will discuss five standard data types: Stack, Queue, Priority\r\nQueue, Set, and Map. The code (each is a templated classes) for concrete\r\nimplementations of these data type appears in the courselib you downloaded, in\r\nfiles named like array_queue.hpp. For now, we will focus on the information\r\nappearing at the top of these .hpp files: code that declares all the operations\r\napplicable to these data types. We will pay special attention to the public\r\nmethods, operators, and constructors they declare, including the nested Iterator\r\nclass and the methods and operators specified in it: they allow us to iterate\r\nover the information stored in any of these five data types.\r\n\r\nBy the end of this lecture, we should be able to understand how to write code\r\nthat USES these templated classes, without having to understand how they are\r\nIMPLEMENTED. In fact, throughout the quarter we will see/write different\r\nimplementations (using different data structures) for these data types, which\r\nall exhibit the same external/logical behavior, but whose use of resources\r\n(performance, e.g., time/space) varies.\r\n\r\nIn Friday's lecture, we will focus on how to implement these classes: define\r\ntheir methods, operators, and constructors using an actual data structure. We\r\nwill study how to use a simple, low-level dynamic array data structure (which\r\ncan grow) to implement all five data types: specifically we will examine the\r\ncode for implementing\r\n\r\n  (a) the constructors/destructor for these templated classes\r\n  (b) the standard methods and operators for these templated classes\r\n  (c) iterator methods and operators for these templated classes\r\n\r\nThis code appears in the courselib you downloaded, in files named like\r\narray_set.hpp. We will briefly look at the complexity classes of these\r\nimplementations and expand on this topic later in the quarter when we study\r\nmore complicated/efficient data structures for these implementation\r\n\r\nThis sequence of lectures are followed by Programming Assignment #1, which asks\r\nyou to represent and solve various problems using combinations of these data\r\ntypes. In that assignment, you will focus on understanding/exploiting these data\r\ntypes, using the simple but slow array implementations that I have provided. In\r\nProgramming Assignments #2, #3, and #4, you will reimplement some of these data\r\ntypes using some of the more sophisticated and efficient data structures that we\r\nwill study in this course. In Quiz #7 and Programming Assignment #5 (the last\r\none), you will once again use these data types (and their more efficient\r\nimplementations that you have written) to implement two new data types:\r\nEquivalence classes and Graphs.\r\n\r\nAfter we learn more formally about using analysis of algorithms to study  the\r\nresource use (performance) of different data structures implementing data\r\ntypes, we will have started to cover the three major topics in this course:\r\ndata types, data structures implementing data types, and efficiency analysis.\r\nWe will continue to explore their relationships throughout the rest of the\r\ncourse.\r\n\r\nPlease recognize and take some time/effort to understand the difference\r\nbetween the terms \"data type\" and \"data structure\". Getting a good intuitive\r\nundestanding of the difference is a major goal of this course, and it does take\r\na bit of time to sort out their different meanings.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFive Data Types/Templated Classes:\r\n\r\nIn this lecture we will examine the five most important data types in three\r\ngroups (based on the similarity of their operations) in the following order:\r\n   (1) Stack, Queue, Priority Queue\r\n   (2) Set\r\n   (3) Map (and pair: a simple class used implicitly and explictly with Maps)\r\n\r\nAfter discussing ArrayQueue (as a representative of the first group) we will\r\nalso discuss iterators for ArrayQueues in detail. Similar iterators are present\r\nfor all of these data types, independent of what type of information they are\r\niterating over. The behavior of these iterators must follow the same rules,\r\nregardless of what data structure we use to implement the data type. Sometimes\r\nthe rules specify that the order of iteration is undetermined (sets and maps),\r\nso we have latitude to implement different orders based on what data structures\r\nwe use for the implementation (so we can implement simple and efficient ones). \r\n\r\n-->IMPORTANT:\r\n-->You should have already downloaded the test_all_data_types project folder.\r\n-->If you have not, follow the Sample Programs link from the course home-page\r\n-->index to find it and download it.\r\n-->\r\n-->This project folder provides drivers and GoogleTests for the array\r\n-->implementations (which you downloaded in the courselib folder) of all these\r\n-->data type types. Taking a cue (not a Queue!) from programming Assignment #0,\r\n-->you can easily switch your driver.cpp code to test drive any of the array\r\n--> implementations, or switch to the GoogleTest for any of these data types.\r\n-->\r\n-->Using the drivers, you can experiment with the methods and operators for\r\n-->these data types. You can also write small programs to test your under-\r\n-->standing of their methods and operators. Typically it takes just a small\r\n-->amount of code to do so.\r\n-->\r\n-->I have also provided a project folder (cross_reference) for a program (see\r\n-->the end of this lecture note) that combines some of these data types to\r\n-->solve a problem similar to those you need to write for Programming\r\n-->Assignment #1. Again, follow the Sample Programs link from the course\r\n-->home-page index to find it and download it.\r\n-->\r\n-->Finally, Quiz #1 will test this material in isolated functions, but similar\r\n-->to the larger tasks that appear in Programming Assignment #1.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nStacks, Queues, and Priority Queues\r\n\r\nThe Stack, Queue, and Priority Queue data types are similar, because they are\r\nall data types that access their values in a predefined order. That is, when we\r\nremove values from these collections (by operations named \"pop\" and \"dequeue\"),\r\nthe order of removal is determined by the data type of the collection. The\r\norders are: Last-In-First-Out (LIFO, for a stack), First-In-First-Out (FIFO,\r\nfor a queue), and Highest-Priority-First-Out (for a priority queue: we will use\r\na special \"gt\" function that compares whether or not one value is \"greater than\"\r\nanother to determine the ordering). We will often use a priority queue when we\r\nneed to process (e.g., print) values of another data type in a sorted order:\r\nthe Priority Queue does the \"sorting\" for us.\r\n\r\nThese templated classes are all similar. The biggest difference among them\r\ninvolves naming: adding/removing a value for a Stack uses the names push/pop,\r\nwhereas the names for the other two classes are enqueue/dequeue. The names of\r\nmany other \"bookkeeping\" operations are the same: e.g. size, empty, clear. So,\r\nfor example, let's take a look at array_queue.hpp.\r\n\r\nNotes:\r\n  1) All the classes appearing in courselib are put in the ics namespace,\r\n     to contrast with the std namespace. Remember to use this namespace to\r\n     qualify the names declared in it.\r\n\r\n  2) Other classes that implement these data types will have the same\r\n     destructor, methods, and operations, and similar (or the same)\r\n     constructors.\r\n\r\nYou can read the actual C++ code in these templated classes. I am changing the\r\nformat of the ArrayQueue class a bit here, for simplicity of presentation: e.g.,\r\nnot showing \"private\" information, which would be different in every different\r\nimplementation: private information relates to data structures.\r\n\r\nnamespace ics {\r\n\r\n\r\ntemplate<class T> class ArrayQueue {\r\n  public:\r\n    //Destructor/Constructors\r\n    ~ArrayQueue();\r\n\r\n    ArrayQueue          ();\r\n    explicit ArrayQueue (int initialLength);\r\n    ArrayQueue          (const ArrayQueue<T>& to_copy);\r\n    explicit ArrayQueue (const std::initializer_list<T>& il);\r\n\r\n    //Iterable class must support \"for-each\" loop: .begin()/.end()/.size() and prefix ++ on returned result\r\n    template <class Iterable>\r\n    explicit ArrayQueue (const Iterable& i);\r\n\r\n\r\n    //Queries\r\n    bool empty      () const;\r\n    int  size       () const;\r\n    T&   peek       () const;\r\n    std::string str () const; //supplies useful debugging information; contrast to operator <<\r\n\r\n\r\n    //Commands\r\n    int  enqueue (const T& element);\r\n    T    dequeue ();\r\n    void clear   ();\r\n\r\n    //Iterable class must support \"for-each\" loop: .begin()/.end() and prefix ++ on returned result\r\n    template <class Iterable>\r\n    int enqueue_all (const Iterable& i);\r\n\r\n\r\n    //Operators\r\n    ArrayQueue<T>& operator = (const ArrayQueue<T>& rhs);\r\n    bool operator == (const ArrayQueue<T>& rhs) const;\r\n    bool operator != (const ArrayQueue<T>& rhs) const;\r\n\r\n    template<class T2>\r\n    friend std::ostream& operator << (std::ostream& outs, const ArrayQueue<T2>& q);\r\n\r\n    Iterator begin () const;\r\n    Iterator end   () const;\r\n\r\n...\r\n\r\n}\r\n\r\nNote that this is a templated class; it will store values from the generic type\r\nT: e.g., enqueue takes an element of type T and dequeue returns an element of\r\ntype T. The last constructor and the \"enqueue_all\" method are further templated\r\nby a type named Iterable, which can correctly match any class that implements\r\nfor-each iteration (begin/end methods and the ++ operator): all five data types\r\nsupport these operations, so all can be arguments to Iterable constructors. For\r\nexample, we can iterate through a queue and put all its values into a set. If\r\nwe try to pass to Iterable some object that is defined in a class that doesn't\r\nimplement these methods, the C++ compiler will indicate an error.\r\n\r\nThis class also includes/refers to its nested Iterator class (which is also\r\ntemplated by type T). For reference, this class appears as follows (for\r\nsimplicity, it both declares and defines \"operator <<\" for Iterator objects).\r\n\r\nclass Iterator {\r\n      public:\r\n        //Private constructor called in begin/end, which are friends of ArrayQueue<T>\r\n        ~Iterator();\r\n        T           erase();\r\n        std::string str  () const;\r\n        ArrayQueue<T>::Iterator& operator ++ ();\r\n        ArrayQueue<T>::Iterator  operator ++ (int);\r\n        bool operator == (const ArrayQueue<T>::Iterator& rhs) const;\r\n        bool operator != (const ArrayQueue<T>::Iterator& rhs) const;\r\n        T& operator *  () const;\r\n        T* operator -> () const;\r\n        friend std::ostream& operator << (std::ostream& outs, const ArrayQueue<T>::Iterator& i) {\r\n          outs << i.str(); //Use the same meaning as the debugging .str() method\r\n          return outs;\r\n        }\r\n        friend Iterator ArrayQueue<T>::begin () const;\r\n        friend Iterator ArrayQueue<T>::end   () const;\r\n\r\n...\r\n\r\n}\r\n\r\nWe will talk about how iterators are used after discussing the other methods\r\nin ArrayQueue. In fact, iterators are pretty much used identically in all five\r\ndata types. So, once we know how iterators work in ArrayQueue, we will have a\r\ngood model for how they work in the other four data types as well. Of course,\r\nyou can always write/run small programs to test your understanding of these five\r\ndata types and their iterators.\r\n\r\nWe will classify methods into two main categories: Commands (also known as\r\n\"mutators\") which change/mutate the state of the data structure implementing\r\nthe objects they act on; and Queries (also known as \"accessors\") which examine,\r\nbut do not change the state of the data structure implementing the objects they\r\nact on. Queries always return a result. Commands can be void (e.g., clear) or\r\nreturn some kind of result related to the command (e.g, enqueue, dequeue).\r\n\r\nLet's examine each of the Queue methods, operators, and constructors/destructor\r\nmore closely. To a large degree, the operations here have almost identical\r\nmeanings for the Stack, Queue, and Priority Queue data types: the biggest\r\ndifference is in how their removal methods (\"pop\" vs. \"dequeue\") work: see the\r\ndescriptions above, where we characterize Stacks as LIFO, Queues as FIFO, and\r\nPriority Queues as HPFO.\r\n\r\nFinally, the courselib includes two files named ics_exceptions (both a .hpp\r\nand .cpp file). These files declare/define common exceptions that are raised by\r\nmethods defined in all implementations of these data types: e.g.,\r\nics::EmptyError, when we try to pop/dequeue a value from an empty stack/queue\r\nor priority queue.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCommands (for Queue: Stack and PriorityQueue are similar):\r\n      \r\nThe \"enqueue\" method adds (includes) a value into the Queue. We don't need to\r\nunderstand here \"how\" this is accomplished by the data structure that implements\r\na Queue, but only that it will be correctly accomplished, setting up for\r\n\"dequeue\" to remove the correct value.\r\n\r\n  \"enqueue\" returns an int result specifying the number of values enqueued: for\r\n  Queues this method always returns 1, because we can add duplicate values into\r\n  Queues. Contrast this property with Sets, which allows NO DUPLICATES. For\r\n  Sets, sometimes calling \"insert\" (the Set method for adding into a Set) will\r\n  return 0 (the value to be added was already in the Set, so the Set remains\r\n  unchanged) and sometimes it will return 1 (the value to be added was NOT\r\n  already in the set, so the set changes to include that value).\r\n\r\nThe \"dequeue\" method removes (discards) the \"next\" value from the Queue, also\r\nreturning that value: for queues, \"next\" is the least recently added value (for\r\nStacks remove the most recently added value and for Priority Queues remove the\r\nvalue with the highest priority). The data structure implementing the enqueue\r\nand dequeue methods work together to accomplish this requirement, although when\r\nusing queues in our program, we don't care HOW this external/logical behavior\r\nis accomplished, so long as it is accomplished CORRECTLY. Finally, note that\r\nthe dequeue operation can fail, if there are no values in the Queue to remove\r\n(when the empty() query returns true; or the size() query returns 0): in such\r\ncases this method indicates its failure by throwing the ics::EmptyError\r\nexception.\r\n\r\nThe \"clear\" method removes all the values currently the Queue; its return type\r\nis void, so it returns nothing (instead, it could return an int specifying the\r\nnumber of values removed; but we will stay with void this quarter; we can call\r\nsize -see below- before clear to compute this number). Calling the empty() and\r\nsize() queries after calling \"clear\" will return a result of true and 0\r\nrespectively, regardless of the data structure implementing this data type: that\r\nrelationship between methods is based on the data type itself, so all\r\nimplementations must ensure that it is true.\r\n\r\n  For efficiency purposes, clear in an array with N values doesn't have to do\r\n  the equivalent of N dequeues. In ArrayQueue, it just sets the used instance\r\n  variable to 0, indicating there are no values in the array representing the\r\n  queue. In a LinkedQueue, this operation might need to deallocate all the\r\n  linked list nodes, taking much longer for large N; or maybe it will just\r\n  set the head of the linked list to empty and save the linked list nodes for\r\n  use when other values are enqueued; but what if there are going to be no more\r\n  enqueues: that space would be wasted. As with many implementations, there are\r\n  often interesting time/space tradeoffs.\r\n\r\nThe \"enqueue_all\" method is further templated by \"Iterable\", which can be\r\ninstantiated by every data type that we define (and others too: technically the\r\nclass must support at least a \"begin\", \"end\", prefix increment and dereference\r\noperators). It enqueues all the values produced by an Iterator for that data\r\ntype. It also returns an int result specifying how many values were added to\r\nthe Queue, which is the number of values the iterator produces. Note that\r\n\"enqueue_all\" may return 0, but only if the iterator parameter produce NO\r\nVALUES; if it produces even one value, that value will be added to the Queue so\r\nthe returned result will be > 0. \r\n\r\n  We often use this method to copy all the values from one object into another\r\n  object, often of different types (for the same type, a copy constructor will\r\n  do the job more efficiently): if q is an ArrayQueue and s is an ArrayStack,\r\n  and we want to copy successive values from the top of the stack into the\r\n  queue, we can do so by writing q.enqueue_all(s). The stack remains unchanged\r\n  because enqueue_all use the iterators that we will discuss in more detail\r\n  soon to examine all the values in the stack.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nQueries (for Queue: Stack and PriorityQueue are similar):\r\n      \r\nThe \"empty\" method returns whether or not there are any values in the Queue.\r\nIt is a convenient boolean method equivalent to testing whether size() == 0\r\n(see below). Contrast empty (query) with clear (command).\r\n\r\nThe \"size\" method returns the number of values currently in the Queue. Often,\r\nbut not always, a Queue implementation will store the size of the Queue as a\r\ncounter. In these implementations, the enqueue method increments this counter\r\nby 1 and the dequeue method decrements this counter by 1 (if there is at least\r\none value in the Queue so that dequeue does not throw an exception). So, it\r\ndoesn't have to repeatedly scan the data structure and count all the values in\r\nit to compute the size (but a type can be implemented this way, which costs\r\nmore time but saves a bit of space by not storing the counter). We use the term\r\n\"caching\" when we store/update a value rather than recomputing it from scratch.\r\nCaching is a standard time(faster) for space(uses more memory) tradeoff.\r\n\r\nThe \"peek\" method returns the same value as would calling the \"dequeue\" method\r\n(or throws the same exception) but DOES NOT REMOVE that value from the Queue.\r\nRecall that queries DO NOT change the state of the data structure implementing\r\nthe object they act on. So calling \"peek\" a second time returns the same value\r\nas calling \"peek\" the first time (if no commands are called in between).\r\nAlthough we cannot directly peek at the second value in a queue, we can use\r\niterators to get the equivalent information, but at a higher resource cost.\r\n\r\nThe \"str\" method is discussed below, along with the overloaded the << operator:\r\nthey are closely related but there is an important distinction between them:\r\nfundamentally, all Queue implementations must produce identical results for\r\n\"operator <<\" (independent of how they are implemented) but they can -and often\r\ndo- produce different results for the \"str()\" method; the difference includes\r\ninformation in \"str()\" that depends on the implementation used: for example,\r\narray and linked list implementations return different information for \"str()\".\r\nSuch information is most useful when debugging different implementations of a\r\ndata type.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nConstructors (for Queue: Stack and PriorityQueue are similar):\r\n\r\nEvery class implementing a Queue will specify a destructor and at least four\r\nconstructors. There should always be...\r\n\r\n  (1) A default constructor;\r\n      The constructed object is empty.\r\n\r\n  (2) A copy constructor;\r\n      The constructed object is a copy of it argument (which is the same type).\r\n      In fact, we could substitute the default constructor followed by\r\n        calling enqueue_all (which iterates over the argument queue) to achieve\r\n        the same result, although for more interesting data structures and their\r\n        implementations, there is often a faster way to \"copy\" the argument.\r\n\r\n  (3) An initializer_list constructor (new in C++11);\r\n      The constructed object contains all the values in the initializer_list.\r\n\r\n  (4) An Iterable constructor, which iterates through any data type,\r\n        enqueuing all the iterated-over values onto the constructed Queue.\r\n        In fact, we could again substitute the default constructor followed by\r\n        calling enqueue_all on the iterable to ahcieve the same effect.\r\n      The constructed object contains all the values produced by the iterable.\r\n\r\nNote that (3) and (4) are explicit. We can use them to EXPLICITLY construct\r\nArrayQueues or convert initializer_lists and Iterables into ArrayQueues.\r\n\r\nAn example of (3: initializer_list) is\r\n\r\n  ics::ArrayQueue<int> small_primes({2,3,5,7,11}); \r\n\r\nAn example of (4: iterable) is\r\n\r\n  ics::ArraySet<int> primes(small_primes); \r\n\r\nNote that the Set primes now contains all the values in the Queue small_primes.\r\nIf we wrote\r\n\r\n  ics::ArrayQueue<int> primes(small_primes); \r\n\r\nthen C++ would use (2: copy-constructor) to accomplish the construction.\r\n\r\nFinally, becaue the Iterable constructor for ArraySet is explicit, we could not\r\nwrite the following (which C++ would flag as a complation error).\r\n\r\n  ics::ArraySet<int> primes = small_primes;\r\n\r\nIf the Iterable constructor were not explict, C++ could automatically use it to\r\nconvert small_primes (iterable, as an ArrayQueue<int>) into an ArraySet<int>,\r\nand then perform the = operator. This two-step process would be less efficient.\r\n\r\nA templated class may define more constructors, depending on the implementation,\r\nbut it should always define these four. We will study all these constructors in\r\nthe next lecture (and one more, special to array implementations), when we\r\nstudy one actual data structure (arrays) that implements these data types.\r\n\r\nFor Array implementations, there is an additional constructor that specifies\r\nthe initial length of the array to allocate for storing the data type. In a\r\ndefault constructor, an array of length 0 or 1 is typically used (and the array\r\nsize is increased when necessary). If we know the approximate number of values\r\nthe data type will hold, specifying that number here can reduce the time taken\r\nto put all the values into the data type because its underlying array will not\r\nhave to be copied when reallocated with a larger size.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nOperators/Miscellaneous (for Queue: Stack and PriorityQueue are similar):\r\n\r\nThe = operator is overloaded for Queues. So if q1 and q2 are ArrayQueues storing\r\nthe same type of information, then we can write the statement q1 = q2; now the\r\ninformation q1 originally stored is gone, and q1 contains all the information\r\nin q2 (for the == operator, now q1 == q2 should return true).\r\n\r\nThe == and != operators are overloaded for Queues. The definition for equality\r\nbetween Queues is that they must contain the same values in the same order\r\n(Stacks have the same definition; Priority Queues must store the same values\r\nand use the same \"gt\" (greater than function that specifies the ordering):\r\nmeaning that these values would be dequeued from the PriorityQueues in the same\r\norder). Note that assignment (=) of priority queues store the right-hand sides's\r\n\"gt\" function into the (target) left-hand side, so afterward the priority\r\nqueues will be ==.\r\n\r\nThe << operator is overloaded for Queues. So, if q is an ArrayQueue we can write\r\nstd::cout << q << std::endl. We can also use << along with an ostringstream \r\nvariable to build a string with the textual representation of a Queue inserted.\r\nSemantically, the << operator includes just the word \"queue\" with the queue\r\nvalues in square brackets (\"[]\"), separated by commas, and followed by the\r\nstring \":rear\", showing where the rear is (with the front implicitly at the\r\nother  side). For a Queue with the two values \"a\" (first) and \"b\" (last), the\r\nstring \"queue[a,b]:rear\" would be inserted on the stream.\r\n\r\nRelated to the overloading of << is the .str() query. It returns a string that\r\nincludes a variant of the information that << inserts, followed in parentheses\r\nby any information that is relevant to class implementing the Queue. So if q is\r\nan ArrayQueue storing the example queue shown in the previous paragraph, calling\r\nq.str() would return a string like\r\n\r\n  \"ArrayQueue[0:a,1:b,2:,3:](length=4,front=0,rear=2,mod_count=2)\"\r\n\r\nin which private instance variables and their values appear in parentheses,\r\nagain separated by commas. Likewise, if q is a LinearArrayQueue (see Programming\r\nAssignment #0) storing the same values, it would return a string like\r\n\"LinearArrayQueue[0:a,1:b](length=2,used=2,mod_count=2)\". \r\n\r\nRegardless of which implementation we use, << inserts the same information for\r\nboth these Queues: \"queue[a,b]:rear\".\r\n\r\n  Note: the mod_count (modification count) instance variable allows us to\r\n  implement FAIL-FAST iterators on a Queue that we are iterating over: iterators\r\n  fail if we mutate the data that they are iterating over. This variable and\r\n  these concepts are discussed in more detail below, when we discuss iterators.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nAn Introduction to Using Iterators (on Queues):\r\n\r\nThe \"begin\" and \"end\" methods respectively return an iterator representing a\r\ncursor/index TO (a) the first value in the Queue and (b) ONE BEYOND the last\r\nvalue in the Queue. One way to print all the values in an ArrayQueue storing\r\nstd::string values is to iterate over all the values using the following \"for\"\r\nloop.\r\n\r\n  for (ics::ArrayQueue<std::string>::Iterator i = q.begin(); i != q.end(); ++i)\r\n    std::cout << *i << std::endl;\r\n\r\nIn this loop i is defined as an iterator initialized to index the first value\r\n(at the front of the Queue), incrementing (++i) until i indexes a value that is\r\n== to an iterator indexing ONE BEYOND the last value in the Queue. For each\r\nindex i, *i (using the * operator) returns a reference to the value at that\r\nindex in the Queue. Examine the Iterator class (shown above) to see that it\r\noverloads the ==, !=, ++ (both prefix and postfix), *, ->, and << operators, as\r\nwell as declaring the \"erase\" and \"str\" methods.\r\n\r\nThe order that the values are iterated over is defined to be the order in which\r\nthey would be dequeued from the Queue (and popped from a Stack, and dequeued\r\nfrom a Priority Queue, if those data types were iterated over).\r\n\r\nIn fact, if we compare the code above to the following code fragment\r\n\r\n  while (!q.empty())\r\n    std::cout << q.dequeue() << std::endl;\r\n\r\nwe will find that both PRINT THE SAME VALUES IN THE SAME ORDER. The difference\r\nis that in the first code fragment, q remains UNCHANGED (we iterate over the\r\nqueue but it still contains all its original values) while in the second code\r\nfragment q is now EMPTY (which is the condition that terminates the \"while\"\r\nloop).\r\n\r\nCan you explain why the code\r\n\r\n  for (int i = 0; i < q.size(); ++i)\t\t//Incorrect Code\r\n    std::cout << q.dequeue() << std::endl;\t//Incorrect Code\r\n\r\nFAILS to print all the values in the Queue? Can you explain what it does print?\r\nCan you write a simlar for loop that works correctly? If you cannot, write a\r\nsmall program that executes this code and use the results you see to determine\r\nthese answers.\r\n\r\nAs another example, we can use the following code fragment to iterate over a\r\nQueue of int values, to find the largest one, without modifying the Queue.\r\n\r\n  int largest = numeric_limits<int>::min(); //All int values are >= this one\r\n\r\n  for (ics::ArrayQueue<int>::Iterator i = q.begin(); i != q.end(); ++i)\r\n    if (*i > largest)\r\n      largest = *i;\r\n\r\nIn fact, there is a \"for-each\" loop in C++ that is even easier to use to iterate\r\nover a Queue. Here is a code fragment for the \"for-each\" loop that solves the\r\nsame maximum problem, but much more simply.\r\n\r\n  for (int v : q)\r\n    if (v > largest)\r\n      largest = v;\r\n\r\nHere, the \"for-each\" loop implicitly iterate over all values in q, assigning to\r\nv each successive value in the Queue: C++ automatically defines an iterator,\r\nstarting it at the beginning of the queue and going one beyond the end, and\r\nstoring into v each value iterated over in the Queue: it is a shorter/simpler\r\nway to write the standard iterator loop: one also not requiring explicit\r\nindexing nor the use of the * operator. If we need to iterate over all the\r\nvalues in a Queue (or Stack or Priority Queue), this is the most elegant way to\r\ndo so.\r\n\r\nBut wait, there's more! We can even use the \"auto\" feature to simplify this loop\r\nas follows (substituting auto for int).\r\n\r\n  for (auto v : q)\r\n    if (v > largest)\r\n       largest = v;\r\n\r\nThat isn't much of an improvement, but we can use auto to simplify the original\r\nexample, to become\r\n\r\n  for (auto i = q.begin(); i != q.end(); ++i)\r\n\r\nLater we will see examples of \"for-each\" loops iterating over maps, like\r\n\r\n  for (const ics::pair<std::string,ics::ArraySet<std::string>>& kv : a_map)\r\n    ...\r\n\r\nwhich we can simplify using auto to\r\n\r\n  for (const auto& kv : a_map)\r\n    ...\r\n\r\nOf course, with \"auto\" we don't explicitly see in our code the type of value\r\nthat the \"for-each\" loop is iterating over. It is sometimes useful information\r\nto know (to see explicitly) that relates to how kv is used in the body of the\r\nloop. Using auto, C++ automatically deduces the type from the type of \"a_map\",\r\nand we should be able to do so too, but writing this type explicitly saves us\r\nthe step of deducing it each time we examine the loop. Of course, we could also\r\nput the type in a comment to make it clear to anyone reading the code.\r\n\r\nIterating over a Queue allows us to examine every value without changing the\r\nQueue's contents....unless we want to. For one example, we can erase selected\r\nvalues. To do that we can call the \"erase\" method declared for Iterators. Here\r\nis a simple example. Suppose that we have a Queue of int and we want to remove\r\nall even values. We can do this task with the following code fragment\r\n\r\n  for (ics::ArrayQueue<int>::Iterator i = q.begin(); i != q.end(); ++i)\r\n    if (*i % 2 == 0)\r\n      i.erase();\r\n\r\nTo call \"erase\" we need to declare/use an explict Iterator (to call it on; so,\r\nwe cannot use the \"for-each\" style of loop for this task). When we call \"erase\",\r\nthe Iterator's state becomes such that we cannot call \"erase\" again until after\r\nwe increment the Iterator, to get to the next value to erase (done above by ++i\r\nin the last part of the for loop); For example, if we wrote\r\n\r\n  ics::ArrayQueue<std::string>::Iterator i = q.begin();\r\n  i.erase();  //erases first value\r\n  i.erase();  //throws ics::CannotEraseError exception\r\n\r\nthe second call would throw the ics::CannotEraseError exception because the\r\niterator is still referring to a previously erased value (which cannot be erased\r\nagain). The following code fragment would correctly erase the first two values\r\nin the Queue, so long as q.size() is initially >= 2. So, we cannot erase the\r\nsame value twice or somehow erase a value earlier than the one the current\r\nIterator refers to (in the ICS46 Template Library we restrict iterators to\r\nmoving forward; some data types in the C++ STL allow iteration both forwards\r\nand backwards).\r\n\r\n  ics::ArrayQueue<std::string>::Iterator i = q.begin();\r\n  i.erase();  //erases first value\r\n  ++i;\t      //advances iterator to \"second\" value; could also execute i++;\r\n  i.erase();  //erases second value\r\n\r\nCalling \"erase\" also throws a CannotEraseError exception if the Iterator indexes\r\ndata beyond the end of the queue: e.g., is == to an iterator ONE BEYOND the\r\nlast value in the Queue. These rules are a bit complicated for beginners, but\r\nthely will become more intuitive, and we'll understand them better when we write\r\ncode USING iterators and again when we have to write code IMPLEMENTING iterators\r\nfor the more advanced data stuctures that we use to implement data types. In the\r\nnext lecture we will study in detail how iterators work in the ArraySet class:\r\nhow they index values in an array.\r\n\r\nNote that the following code increments every value in the Queue by 1.\r\n\r\n  for (int& v : q) //Note type int& for the index, not just int\r\n    ++v;\r\n\r\nIt is equivalent to the loop\r\n\r\n  for (ics::ArrayQueue<int>::Iterator i = q.begin(); i != q.end(); ++i)\r\n    (*i)++;\r\n\r\nNote that the * operator here returns a reference to a value in the Queue, not\r\njust the value itself, so the value at that reference can be mutated by ++.\r\n\r\nFor for-each loops that do not modify their argument, it is often more\r\nefficient to write them using const and &:\r\n\r\n  for (const int& v : q)\r\n    if (v > largest)\r\n       largest = v;\r\n\r\nHere, v references each of the values in q. This form saves copying each value\r\nin the queue into v. For ints the cost is not high (about the same as copying\r\nthe int), but for more complicated values being iterated over, there can be\r\nsubstantial time savings using this form.\r\n\r\nThere is one more exception related to Iterators. If we are iterating through a\r\nQueue and we change the Queue (e.g., call the \"enqueue\" or \"deqeueue\" commands\r\n-which are mutator methods) in any way OTHER THAN THROUGH THE ERASE ON THE\r\nITERATOR any subsequent use of that Iterator on the queue will throw a\r\nConcurrentModificationError exception. \r\n\r\nThe basic idea here is that if we change a Queue while we are in the process\r\nof iterating over it (with one or more interators), then the meaning of\r\ncontinuing any iteration becomes unclear, so all started iterations refuse to\r\nwork further. Iterators that do this are known as FAIL-FAST Iterators, as they\r\nfail quickly if their underlying Queue is changed (by either a command or\r\nperforming an erase by another iterator).\r\n\r\nThat is, if we are iterating over a queue and changing the queue, how will the\r\niteration be affected by enqueues and dequeue. The rules say it would be too\r\nhard to specify (and might have to depend on the data structure we are using,\r\nwhich would mean different implementations would produce different results), so\r\nit is eaiser to specify that the iterator cannot continue running on a mutated\r\nqueue: instead it throws an exception.\r\n\r\nNote that this problem does not apply to an Iterator itself changing the Queue\r\nby calling \"erase\": it should still be able to continue its iteration (but every\r\nother Iterator currently iterating through the Queue -there may be multiple\r\nIterators active for the same Queue,  must now fail). This situation is too\r\nadvanced to cover in detail here, but we will pick up this discussion later in\r\nthese notes (for Set) and much more in the next lecture when we look at how we\r\nimplement a templated class with a data structure and how the data structure is\r\niterated over and decides about throwing ConcurrentModificationError exceptions.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nPriorityQueue: Special Template and Constructors\r\n\r\nPriorityQueues are special, because each MUST be supplied with a \"gt\" function\r\nthat determines the relative priority between any two values enqueued into a\r\nPriorityQueue. A call to gt(a,b) should return true, if a has a HIGHER priority\r\nthan b: a is greater than b. Note that we DO NOT need to compute a priority for\r\neach value, only to compute whether the priority of one value exceeds another.\r\n\r\n  Think about the difficulty in computing an integer priority of strings (with\r\n  any number of characters): there are an infinite number of different strings,\r\n  so we would need to compute an infinite number of different integers. But the\r\n  int type is finite. On the other hand, given two strings, simple algorithms\r\n  can compute whether or not one has a higher priority than the other (using\r\n  the standard relational operators on strings). If you don't like the infinite\r\n  argument, there are 52^N different strings of length N containing only\r\n  letters; even for a relatively small N, that would exceed the number of int\r\n  values.\r\n\r\nFirst, each implementation of a queue will define (if no other queue\r\nimplementation has been included in the code being compiled) a special\r\nundefinedgt function. This is done with the following macro.\r\n\r\n#ifndef undefinedgtdefined\r\n#define undefinedgtdefined\r\ntemplate<class T>\r\nbool undefinedgt (const T& a, const T& b) {return false;}\r\n#endif /* undefinedgtdefined */\r\n\r\nThis undefinedgt function is used as a default in the template/constructors as\r\ndescribed below. Obviously we don't ever want to actually use this gt function\r\n(maybe it would be better to have it always throw an exception).\r\n\r\nThere are two opportunities to supply a \"gt\" function to a PriorityQueue.\r\n\r\n  1) As part of the template, when the type of the PriorityQueue is instantiated\r\n  2) During a call to a constructor\r\n\r\nOne of these opportunities MUST supply an explicit function pointer (not the\r\n\"undefinedgt\" function that is the default value in both the template and\r\nconstructors): if NEITHER opportunity is taken, or if BOTH are taken AND the\r\ntwo function pointers are DIFFERENT, the constructor will raise a\r\nFunctionTemplateError exception. See below for some examples.\r\n\r\nOnce a PriorityQueue is constructed, its \"gt\" function generally cannot change,\r\nunless it appears on the (target) left-hand side in an assignment (=) statement,\r\nin which case the \"gt\" of the target becomes the \"gt\" function of the right-hand\r\nside (so the resulting priority queues will be ==).\r\n\r\nThe template for PriorityQueues looks like (note: tgt represents the TEMPLATE'S\r\ngt function and cgt represents the CONSTRUCTOR'S gt function):\r\n\r\n//Instantiate the templated class supplying tgt(a,b): true, iff a has higher priority than b.\r\n//If tgt is defaulted to undefinedgt in the template, then a constructor must supply cgt.\r\n//If both tgt and cgt are supplied, then they must be the same (by ==) function.\r\n//If neither is supplied, or both are supplied but different, TemplateFunctionError is raised.\r\n//The (unique) non-undefinedgt value supplied by tgt/cgt is stored in the instance variable gt.\r\ntemplate<class T, bool (*tgt)(const T& a, const T& b) = undefinedgt<T>>\r\n   class ArrayPriorityQueue {\r\n\r\nThe constructors look like:\r\n\r\nArrayPriorityQueue          (bool (*cgt)(const T& a, const T& b) = undefinedgt<T>);\r\nexplicit ArrayPriorityQueue (int initial_length, bool (*cgt)(const T& a, const T& b) = undefinedgt<T>);\r\nArrayPriorityQueue          (const ArrayPriorityQueue<T,tgt>& to_copy, bool (*cgt)(const T& a, const T& b) = undefinedgt<T>);\r\nexplicit ArrayPriorityQueue (const std::initializer_list<T>& il, bool (*cgt)(const T& a, const T& b) = undefinedgt<T>);\r\n\r\ntemplate <class Iterable>\r\nexplicit ArrayPriorityQueue (const Iterable& i, bool (*cgt)(const T& a, const T& b) = undefinedgt<T>);\r\n\r\n\r\nFor Array implementations, besides the four standard constructors, there is\r\nanother one that specifies the initial length of the array storing the\r\nPriorityQueue. In a default constructor, an array of length 0 is used.\r\n\r\nLet's assume that we are using an ArrayPriorityQueue to store ints, and we want\r\nthe SMALLEST int to be dequeued FIRST. We can first define the \"gt\" function as\r\n\r\n  bool gt(const int& a, const int& b) // a gt b (in priority) if a < b\r\n  {return a < b;}                     // smaller values have higher priorities\r\n\r\nThen, the following three statements produce equivalent ArrayPriorityQueues:\r\n\r\n  ArrayPriorityQueue<int,gt> x;\t     //Specify \"gt\" as template argument\r\n  ArrayPriorityQueue<int>    x(gt);  //Specify \"gt\" as constructor argument\r\n  ArrayPriorityQueue<int,gt> x(gt);  //Specify same \"gt\" in template/constructor\r\n\r\nAll define an empty PriorityQueue whose \"gt\" function is the one declared\r\nabove. There are different reasons to prefer different forms, which we will\r\ndiscuss during the quarter. One difference is that the second form can use a\r\nlambda for gt, so we could also write it more directly -not declaring the gt\r\nfunction explicitly- as\r\n\r\n  ArrayPriorityQueue<int> x(\r\n   (bool (*)(const int& a, const int& b))\r\n   {[](const int& a, const int& b) {return a < b;}}\r\n  );\r\n\r\n-----------\r\nInterlude:\r\n  The use of a lambda in a \"default\" constructor for ArrayPriorityQueue requires\r\n  a special C++ construct: T{e} which tells C++ that e has type T.\r\n\r\n  The problem is that unlike named functions, lambdas DO NOT have any types in\r\n  C++. When attempting to use a constructor and supplying just one argument,\r\n  we must tell C++ to use the default constructor, with the argument specifying\r\n  its cgt parameter, not the iterable constructor, with the argument specifying\r\n  its i parameter and defaulting the cgt parameter to nullptr.\r\n\r\n  The rules for deciding which constructor to use are based on matching types,\r\n  but lambdas have no types!\r\n\r\n  So, in the code above for T{e}, T is (bool (*)(const int& a, const int& b))\r\n  and e is [](const int& a, const int& b) {return a < b;}.\r\n\r\n  We do NOT need to use the construct T{e} if we are supplying two arguments to\r\n  the constructors. For example, if s is an ArraySet<int>, whose values we want\r\n  to put into a priority queue prioritized by a lambda, we can write just\r\n\r\n  ArrayPriorityQueue<int> x(s,[](const int& a, const int& b) {return a < b;});\r\n\r\n  not needing the construction T{e} to specify the type of the typeless lambda.\r\n  C++ will still correctly choose the correct/matching Iterable constructor.\r\n  Likewise if the first argument is an ArrayPriorityQueue, C++ will use the copy\r\n  constructor); if it is an initializer list (it will use the initializer list\r\n  constructor).\r\n-----------\r\n\r\nNote that we CANNOT use a lambda when specifying the template argument; in the\r\ntemplate we must use the name of an explicitly defined function. This is related\r\nto the fact that lambdas have no types.\r\n\r\nFinally, in\r\n\r\n  ArrayPriorityQueue<int,gt> x;\r\n  ArrayPriorityQueue<int>    y(gt);\r\n  ArrayPriorityQueue<int,gt> z(gt);\r\n\r\nthe TYPES of x and y are DIFFERENT; the TYPES of x and z are the same. The type\r\nis related to how the template is instantiated: the type of x has tgt = gt and\r\nthe type of y has tgt = undefinedgt<T>. So we cannot write x = y; because there\r\nwould be a type mismatch. We could use the explicit iterable constructor to\r\ntranslate between them: writing this line instead as\r\n\r\nx = ArrayPriorityQueue<int,gt>(y);\r\n\r\nNote that the type of x and z are the same, because the template is instantiated\r\nthe same way (with tgt = gt); for z, only that same gt function can be used in\r\nthe constructor. So we could write x = z; as well as z = x;\r\n\r\nIn fact, if we had a gt_reverse function\r\n  bool gt(const int& a, const int& b) // a gt b (in priority) if a > b\r\n  {return a > b;}\r\n\r\n we could still legally write\r\n\r\n  ics::ArrayPriorityQueue<int,gt> x;\r\n  ics::ArrayPriorityQueue<int>    y(gt_reverse);\r\n  x = ics::ArrayPriorityQueue<int,gt>(y);\r\n\r\nThe last line uses the explicit iterable constructor to create a priority queue\r\nthat is organized by gt and contains y's values (which are organized in y by\r\ngt_reverse), so then the assignment statement is legal, although x's gt is not\r\nthe the same as y's (y's is gt_reverse). If we wanted all of y's value to be in\r\nx organized by x's gt, we could also write\r\n\r\n  x.clear();\r\n  x.enqueue_all(ics::ArrayPriorityQueue<int,gt>(y));\r\n\r\nHere we need to use the iterable constructor in the argument.\r\n\r\nTrying\r\n\r\n  x = ics::ArrayPriorityQueue<int,gt>(y,gt_reverse);\r\n\r\nwould fail, because the iterable constructor has two different \"gt\" functions\r\nspecified, which is not legal (and will throw a TemplateFunctionError).\r\n\r\n-----\r\nInterlude:\r\n  So why have \"gt\" specified in the template argument at all? The main reason is\r\n  if that type were to be used as the type for a value associated with a key in\r\n  a Map (more details about Maps, read below), we would need to specify the \"gt\"\r\n  function as part of the template, to be part of its type.\r\n\r\n  If we wanted to define an ArrayMap whose keys are std::string and whose\r\n  associated values are ArrayPriorityQueues of ints (so that the smallest int\r\n  value has the highest priority), we would write it as\r\n\r\n    bool gt(const int& a, const int& b)\r\n    {returns a < b;}\r\n\r\n    typedef ArrayPriorityQueue<int,gt>  intPQ;\r\n    typedef ArrayMap<std::string,intPQ> Map;\r\n  \r\n    Map m;\r\n\r\n  Now, all the ArrayPriorityQueues constructed implicitly for Map values, will\r\n  use this \"gt\" function specified in the intPQ template. It is part of the\r\n  intPQ type itself, not something that must be supplied when each\r\n  ArrayPriorityQueue is constructed: sometimes the construction is done\r\n  implicitly, as here because it is the value type in the ArrayMap, where we\r\n  have no further control over its \"gt\" function.\r\n\r\n  We will also see this kind of duplication again, when we cover data types\r\n  implemented by the binary search trees and hash table data structures\r\n  (which require a \"lt\" and \"hash\" function respectively). And, some programming\r\n  assignments at the end of the quarter will require that we specify a function\r\n  as a template argument (I will remind you to reread this section then).\r\n-----\r\n\r\nOne more example:\r\n\r\nSuppose that we have a std::string x[] = ... storing x_length values and we\r\nwant to sort this array of strings, alphabetically. We could use the following\r\n\"gt\" function and ArrayPriorityQueue.\r\n\r\n  bool gt_alphabetic (const std::string& a, cont std::string& b)\r\n  {return a < b;}\r\n\r\nGenerally, this function must return true when its first argument has a higher\r\npriority than its second argument. Here, it returns true if a comes before b\r\nalphabetically, using the standard < on std:string.\r\n\r\nTo alphabetize the words in array x, we could execute the following code. It\r\n(a) puts all the values into the ArrayPriorityQueue and then (b) removes them\r\nin alphabetical order, storing them back into the original array.\r\n\r\n  ics::ArrayPriorityQueue<std::string,gt_alphabetic> pq;\r\n\r\n  for (int i=0; i<x_length; ++i)\r\n    pq.enqueue(x[i]);\r\n\r\n  for (int i=0; i<x_length; ++i)\r\n    x[i] = pq.dequeue();\r\n\r\nWe could also specify this as\r\n\r\n  ics::ArrayPriorityQueue<std::string> pq(gt_alphabetic);\r\n\r\nIn C++11, we can also use a lambda for this function, writing the constructor\r\ncall as\r\n\r\n  ics::ArrayPriorityQueue<std::string>\r\n     pq(\r\n      (bool (*)(const std::string& a, const std::string& b))\r\n      {[](const std::string& a, const std::string& b){return a < b;}});\r\n\r\nwhich uses an anonymous lambda instead of defining and passing a reference to\r\nthe gt_alphabetic function.\r\n\r\nFinally, we CANNOT write\r\n\r\n  ics::ArrayPriorityQueue<std::string,[](const std::string& a, const std::string& b){returns a < b;}) pq;\r\n\r\nbecause we CANNOT use lambdas to instantiate templates (but can pass lambdas as\r\narguments to constructors).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSets\r\n\r\nBelow is a slightly simplified version of the array_set.hpp file (not including\r\nthe nested Iterator class, which is the same as the one shown in ArrayQueue,\r\nexcept for the substitution of ArraySet<T> for ArrayQueue<T>). In many ways it\r\nis similar to the array_queue.hpp file. Again, below I show only the \"public\"\r\nparts.\r\n\r\nLike a Stack, Queue, and Priority Queue, we can add (here \"insert\") values into\r\na Set and remove (here \"erase\") specific values from a Set. The primary\r\ncharacteristic of a Set is that it does not contain duplicates (see the\r\n\"insert\" method below for details). Also notice that it declares many relational\r\noperators, because there are many different ways to compare sets mathematically\r\n(using the proper/normal subset/superset relationships), not just for equality\r\nand inequality.\r\n\r\nnamespace ics {\r\n\r\n\r\ntemplate<class T> class ArraySet {\r\n  public:\r\n    //Destructor/Constructors\r\n    ~ArraySet();\r\n\r\n    ArraySet();\r\n    explicit ArraySet(int initialLength);\r\n    ArraySet         (const ArraySet<T>& to_copy);\r\n    ArraySet         (const std::initializer_list<T>& il);\r\n\r\n    //Iterable class must support \"for-each\" loop: .begin()/.end() and prefix ++ on returned result\r\n    template <class Iterable>\r\n    ArraySet (const Iterable& i);\r\n\r\n\r\n    //Queries\r\n    bool empty        () const;\r\n    int  size         () const;\r\n    bool contains     (const T& element) const;\r\n    std::string str () const; //supplies useful debugging information; contrast to operator <<\r\n\r\n    //Iterable class must support \"for-each\" loop: .begin()/.end() and prefix ++ on returned result\r\n    template <class Iterable>\r\n    bool contains_all (const Iterable& i) const;\r\n\r\n\r\n    //Commands\r\n    int  insert (const T& element);\r\n    int  erase  (const T& element);\r\n    void clear  ();\r\n\r\n    //Iterable class must support \"for\" loop: .begin()/.end() and prefix ++ on returned result\r\n\r\n    template <class Iterable>\r\n    int insert_all(const Iterable& i);\r\n\r\n    template <class Iterable>\r\n    int erase_all(const Iterable& i);\r\n\r\n    template<class Iterable>\r\n    int retain_all(const Iterable& i);\r\n\r\n\r\n    //Operators\r\n    ArraySet<T>& operator = (const ArraySet<T>& rhs);\r\n    bool operator == (const ArraySet<T>& rhs) const;\r\n    bool operator != (const ArraySet<T>& rhs) const;\r\n    bool operator <= (const ArraySet<T>& rhs) const;\r\n    bool operator <  (const ArraySet<T>& rhs) const;\r\n    bool operator >= (const ArraySet<T>& rhs) const;\r\n    bool operator >  (const ArraySet<T>& rhs) const;\r\n\r\n    template<class T2>\r\n    friend std::ostream& operator << (std::ostream& outs, const ArraySet<T2>& s);\r\n\r\n    Iterator begin () const;\r\n    Iterator end   () const;\r\n\r\n...\r\n\r\n}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCommands (for Set):\r\n      \r\nThe \"insert\" method adds (includes) a value into the Set. We don't need to\r\nunderstand here \"how\" this is accomplished by the data structures that implement\r\na Set, but only that it will be correctly accomplished, setting up for the\r\nother operations to work correctly on Sets.\r\n\r\n  \"insert\" returns an int result specifying the number of values inserted: for\r\n  a Set, it will return 0 if the value to be added was already in the Set, so\r\n  in this case the Set remains unchanged; it will return 1 if the value to be\r\n  added was NOT already in the set, so the set changes to include that value.\r\n\r\nThe \"erase\" method removes (discards) the specified value from the Set and\r\nreturns the number of values it removed: the result will be 0 if the specified\r\nvalue is not in the Set and 1 if it is in the Set. Unlike removal from a Stack,\r\nQueue, or Priority Queue, this methods do not throw an exception (trying to\r\nerase an absent value just returns 0); also unlike \"pop\" and \"dequeue\", we must\r\nspecify which value to \"erase\".\r\n\r\nThe \"clear\" method removes all the values currently the Set; its return type\r\nis void, so it returns nothing (instead, it could return an int specifying the\r\nnumber of values removed; but we will stay with void this quarter; we can call\r\nsize -see below- before clear to compute this number). Calling the empty() and\r\nsize() queries after calling \"clear\" will return a result of true and 0\r\nrespectively, regardless of the data structure implementing this data type: that\r\nrelationship between methods is based on the data type itself, so all\r\nimplementations must ensure that it is true.\r\n\r\nThe \"insert_all\" method is futher templated by \"Iterable\", which can be\r\ninstantiated by every data type that we define (and others too: technically the\r\nclass must support only a \"begin\", \"end\", and prefix increment and dereference\r\noperators). It inserts all the values produced by an Iterator for that data\r\ntype. It also returns an int result specifying how many values were added to\r\nthe Set. Note that \"insert_all\" may return 0, either if the iterator produce\r\nNO VALUES or it produces only values that are ALL ALREADY IN THE Set. The\r\nmaximum result it can return is the number of values the iterator produces,\r\nwhere each value produced is not already in the Set.\r\n\r\n  We often use this method to copy all the values from one object into another\r\n  object, often of different types (for the same type, a copy constructor will\r\n  do the job more efficiently): if s is an ArraySet and q is an ArrayQueue, and\r\n  we want to compute whether all the values in the Queue are UNIQUE, we can do\r\n  so by writing s.insert_all(q) and checking whether its returned result has the\r\n  same size as the Queue. We can also use the \"Iterable\" constructor for\r\n  ArraySet both to define and initialize such a Set: e.g., ArraySet<int> s(q);\r\n\r\n  Note that we could design insert_all to return the object it was called on\r\n  instead of the number of new values it had. Then we could test for unique\r\n  queue values by writing s.insert_all(q).size() == q.size().\r\n\r\nThe \"erase_all\" method is futher templated by \"Iterable\", which can be\r\ninstantiated by every data type that we define (and others too: technically the\r\nclass must support only a \"begin\", \"end\", and prefix increment and derefence\r\noperators). It erases all the values produced by an Iterator for that data type.\r\nIt also returns an int result specifying how many values were removed from the\r\nSet. Note that this \"erase\" may return 0, either if the iterator produces NO\r\nVALUES or it produces only values that are ALL NOT IN THE Set. The maximum\r\nresult it can return is the size of the Set, if the iterator produces every\r\nvalue in the Set.\r\n\r\nThe \"retain_all\" method is futher templated by \"Iterable\", which can be\r\ninstantiated by every data type that we define (and others too: technically the\r\nclass must support only a \"begin\", \"end\", and prefix increment and derefernce\r\noperators). It erases every value in the Set that is NOT one of the values\r\nproduced by the iterator for that data type: it retains only those values,\r\nwhich is equivalent to \"intersecting\" the set with the iterable. It also\r\nreturns an int result specifying how many values were removed (not retained)\r\nfrom the Set. Note that \"retain_all\" may return 0 if the iterator produces ALL\r\nTHE VALUES in the Set. It can return the initial size of the Set, if the\r\niterator parameter produce NO VALUES that are in the Set (this includes an\r\niterator that produces no values). Note that this method doesn't return the\r\nnumber of values retained in the Set, because we can call the \"size\" method\r\n(see below) after \"retain_all\" to compute that value easily.\r\n\r\n  Here is a an example: if a Set of int contains the value 1, 2, 3, 4, and 5,\r\n  and we retain the values 1, 3, 5, and 7 (produced by an iterator), then the\r\n  resulting Set contains the values 1, 3, 5 and \"retain\" returns 2, because it\r\n  removes 2 values; it does not return the number of values retained, 3, which\r\n  is just the size of the remaining Set.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nQueries (for Set):\r\n      \r\nThe \"empty\" method returns whether or not there are any values in the Set.\r\nIt is a convenient boolean method equivalent to testing whether size() == 0\r\n(see below).\r\n\r\nThe \"size\" method returns the number of values currently in the Set. Often, but\r\nnot always, a Set implementation will store the size of the Set as a counter.\r\nIn these implementations the insert method increments this counter by 1 if the\r\nvalue to insert is not in the Set and the erase method decrements this counter\r\nby 1 if the value to erase is in the Set.  So, it doesn't have to repeatedly\r\ncount all the values in the data structure to compute the size (but it can be\r\nimplemented this way, which costs time but saves space). We use the term\r\n\"caching\" when  we store/update a value rather than recomputing it from scratch.\r\n\r\nThe \"contains\" method returns whether or not the specified value is stored in\r\nthe Set.\r\n\r\nThe \"str\" method is discussed below, along with the overloaded the << operator:\r\nthey are closely related but there is an important distinction between them:\r\nfundamentally, all Set implementations must produce identical-looking results\r\nfor \"operator <<\" (identical-looking, because the values in the Set might\r\nappear in any order) but they can (and often do) produce different results for\r\nthe \"str()\" method; the difference includes information in \"str()\" that depends\r\non the implementations. For example, array and linked list implementations\r\nreturn different information for \"str()\". Such information can be useful when\r\ndebugging different implementations of a data type.\r\n\r\nThe \"contains_all\" method is futher templated by \"Iterable\", which can be\r\ninstantiated by every data type that we define (and others too: technically the\r\nclass must support only a \"begin\", \"end\", and prefix increment operator). It\r\nreturns whether or not ALL the values produced when its start parameter\r\niterates to its end parameter are contained in the Set. If the iterator\r\nparameter produces NO VALUES, this function returns true, because it produces\r\nNO VALUES that are NOT in the Set.\r\n\r\n\r\nOperators/Miscellaneous (for Set):\r\n\r\nThe = operator is overloaded for Set. So if s1 and s2 are ArraySets storing\r\nthe same type of information, then we can write the statement s1 = s2; now the\r\ninformation s1 originally stored is gone, and s1 contains all the information\r\nin s2 (for the == operator, now s1 == s2 should return true).\r\n\r\nThe == and != operators are overloaded for Sets. The definition for equality\r\nbetween Sets is that they must contain the same values; recall with Sets there\r\nreally is no mention of in which order the values are. If << for s1 is\r\n\"set[1,2]\" and << for s2 is \"set[2,1]\" then s1 == s2 returns true because these\r\nsets store the same values. Note that s1 == s1 is always true.\r\n\r\nThe <, <=, >, and >= operators are also overloaded for Sets (but no other data\r\ntype that we will study). These specify subsets and supersets. Here are the\r\nsemantics of these operators.\r\n\r\n  s1 <= s2 if every value is s1 is in s2 (the sets may be == ): subset\r\n  s1 <  s2 if every value is s1 is in s2 (the sets must be !=): proper subset\r\n  s1 >  s2 is the same as s2 < s1                             : proper superset\r\n  s1 >= s2 is the same as s2 <= s1                            : superset\r\n  \r\nAs with a Queue, a Set both overloads the << operator and defines a .str()\r\nmethod. A Set storing the values 1 and 2 will insert \"set[1,2]\" on a stream;\r\nbut be careful here: the values in a Set have no special order, so this Set\r\nmight insert \"set[2,1]\" just as easily. This \"unordered\" feature is even more\r\nimportant when we learn about iterating over all the values in a Set. If s is\r\nan ArraySet storing these values, the .str() method would return a string like\r\n\"set[1,2](length=2,used=2,mod_count=2)\" in which instance variables and their\r\nvalues appear in parentheses, separated by commas.\r\n\r\nThe \"begin\" and \"end\" methods return an iterator representing a cursor/index TO\r\nthe \"first\" value in the Set and ONE BEYOND the \"last\" value in the Set\r\nrespectively (for a Set of size() == 0, it returns the same iterator for both).\r\nAs we discussed there really is no order among the values in Sets, but when we\r\niterate over Sets they must produce these values in some order: not only can we\r\nnot predict the order for different implementations, but different times that\r\nwe iterate over a Set its values can be produced in a different order! DO NOT\r\nMAKE ANY ASSUMPTIONS ABOUT THE ORDER VALUES ARE PRODUCED BY Set ITERATORS:\r\norder is NOT an behavioral/logical property of a Set, the way it is for Stacks,\r\nQueues, and PriorityQueues.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nConstructors (for Set)\r\n\r\nEvery class implementing a Set will specify a destructor and at least four\r\nconstructors. There should always be...\r\n\r\n  (1) A default constructor;\r\n      The constructed object is empty.\r\n\r\n  (2) A copy constructor;\r\n      The constructed object is a copy of it argument.\r\n\r\n  (3) An initializer_list constructor (new in C++11);\r\n      The constructed object has all the values in the initializer_list.\r\n\r\n  (4) An Iterable constructor, which iterates through any data type,\r\n        enqueuing all the iterated over values onto the constructed Set.\r\n        It is similar in form and function to the \"enqueue_all\" method.\r\n      The constructed object has all the values produced by the iterable.\r\n        \r\nNote that (3) and (4) are explicit. We can use them to EXPLICITLY construct\r\nArraySets or convert initializer_lists and Iterables into ArraySets.\r\n\r\nAn example of (3) is\r\n  ics::ArraySet<int> primes({2,3,5,7,11}); \r\n\r\nA templated class can define more constructors depending on the implementation\r\nbut it should always have these four. We will study all these constructors in\r\nthe next lecture, when we study actual data structures that implement these\r\ndata type.\r\n\r\nFor Array implementations, there is a constructor that specifies the initial\r\nlength of the array storing the Set. In a default constructor, an array of\r\nlength 0 is used.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nUsing Iterators (on Sets):\r\n\r\nEverything that we know about Queue iterators applies to Set iterators. So I\r\nwill not reproduce all that coverage here. Note that the following code fragment\r\nuses a Set Iterator to remove from Set s all strings whose length exceeds 10.\r\n\r\n  for (ics::ArraySet<std::string>::Iterator i = s.begin(); i != s.end(); ++i)\r\n    if ((*i).length() > 10)\r\n      i.erase();\r\n\r\nIn fact, we can use the -> to simplify this code a bit, rewriting it as\r\n\r\n  for (ics::ArraySet<std::string>::Iterator i = s.begin(); i != s.end(); ++i)\r\n    if (i->length() > 10)\r\n      i.erase();\r\n\r\nThe following code is more elegant but it is WRONG. It FAILS to do this job;\r\ninstead it throws a ConcurrentModificationError exception. Can you explain why?\r\nCarefully examine the difference between the calls to the erase method.\r\n\r\n  for (auto v : s)          //WRONG CODE   for (const auto& v : s) is wrong too\r\n    if (v.length() > 10)    //WRONG CODE\r\n      s.erase(v);           //WRONG CODE   not erase called on s, not iterator\r\n\r\nNext, let's examine some code that fills a Set with 5 different string values,\r\ngotten by prompting the user (see my ics46goody.hpp file for the prompt_string\r\nfunction and a few other very useful programming goodies). What is interesting\r\nabout this example is that we can write more elegant code if we leverage off a\r\ngood understanding of Sets and all their methods.\r\n\r\n  ics::ArraySet<std::string> s;\r\n  int count = 0;\r\n  while (count < 5) {\r\n    std::string attempt = ics::prompt_string(\"Enter a String\");\r\n    if (! s.contains(attempt) ) {\r\n      s.insert(attempt);\r\n      ++count;\r\n    }\r\n  }\r\n\r\nFirst, notice that we don't need a local variable to count the number of values\r\nin the Set (it has a query method for that). So we can simplify this code by\r\nremoving all references to count, to be\r\n\r\n  ics::ArraySet<std::string> s;\r\n  while (s.size() < 5) {\r\n    std::string attempt = ics::prompt_string(\"Enter a String\");\r\n    if (! s.contains(attempt) )\r\n      s.insert(attempt);\r\n  }\r\n\r\nSecond, notice what it if we add a string that is already in the Set, the Set\r\nremains unchanged. So, we don't need to test whether it is already contained in\r\nSet s before adding it; in fact, for most implementations performing the test\r\ntakes about the same amount of time as just performing the insert, so just doing\r\njust the insert takes 1/2 the time doing a check and then insert. Thus, we can\r\nfurther simplfy this code to be\r\n\r\n  ics::ArraySet<std::string> s;\r\n  while (s.size() < 5) {\r\n    std::string attempt = ics::prompt_string(\"Enter a String\");\r\n    s.insert(attempt);\r\n  }\r\n\r\nFinally, we don't really need the variable \"attempt\" (now that its value is\r\nused in just one place), so we can simplify this code to be\r\n\r\n  ics::ArraySet<std::string> s;\r\n  while (s.size() <5)\r\n    s.insert(ics::prompt_string(\"Enter a String\"));\r\n\r\nHere is another interesting equivalence.\r\n\r\n  ics::ArraySet<std::string> s;\r\n  int successful_erases = 0;\r\n  ...\r\n  std::string value = ics::prompt_string(\"Enter a String to Erase\");\r\n  if (s.contains(value)){\r\n    s.erase(value);\r\n    ++successful_erases;\r\n  }\r\n\r\nNotice that because erase returns an int (1 if it erased a value, 0 if it\r\ndidn't), we can simplfy this code to be\r\n    \r\n  ics::ArraySet<std::string> s;\r\n  int successful_erases = 0;\r\n  ...\r\n  std::string value = ics::prompt_string(\"Enter a String to Erase\");\r\n  successful_erases += s.erase(value);\r\n\r\nOf course, because value is now used just once, this could even be reduced to \r\n\r\n  successful_erases += s.erase( ics::prompt_string(\"Enter a String to Erase\") );\r\n\r\nbut I think that doesn't really simplify things; the \"value\" name is useful, if\r\ntechnically redundant.\r\n\r\nThe more you think about and practice using the methods in the Set class (and\r\nothers), the simpler and more elegant your code will become. When making\r\ndecisions about whether/what a method should return, the designer should think\r\nabout what will allow commonly written code to be simplified.\r\n\r\nHow can we write code to retrieve a random value from a Set of strings and\r\nerase that value from the set? We could have required this operation be part of\r\nthe Set data type, in which case every implementation would have to implement\r\nit (but do so efficiently for its data structure). But we can implement it using\r\nthe current features of the Set data type. We can use a random number generator\r\nand an Iterator as follows.\r\n\r\n  ics::ArraySet<std::string> s;\r\n  ...\r\n  std::string chosen;\r\n  int choose = random() % s.size(); \r\n  ics::ArraySet<std::string>::Iterator i = s.begin();\r\n  for (int on = 0; on < choose; ++on)\r\n    ++i;\r\n  std::string chosen = *i;\r\n  s.erase(chosen);  //could also erase using iterator: i.erase();\r\n\r\nCan you explain how/why this works, say for a Set of 5 values (to be concrete)?\r\n\r\nIn fact, we could simplify this to work  more quickly by just always returning\r\nand removing the FIRST value iterated over (since there is no special ordering\r\nfor Sets, the first value is as good as a random one).\r\n\r\n  ics::ArraySet<std::string> s;\r\n  ...\r\n  ics::ArraySet<std::string>::Iterator i = s.begin();\r\n  std::string chosen = *i;\r\n  s.erase(chosen);  //could also erase using iterator: i.erase();\r\n\r\nSo, we might need to better understand what we mean by \"random\".\r\n  \r\n------------------------------------------------------------------------------\r\n\r\nMaps and Pairs\r\n\r\nMaps are the most interesting and useful of the five data types. A map\r\nassociates \"keys' (of some type) with \"values\" (of some type, which can be\r\nthe same or different than the key type). Often the key is a simple type (e.g.,\r\nstring) while the value is some more complicated data type (e.g., Set). Each\r\nkey is \"associated with\"/\"mapped to\" one value at any time. Typically once we\r\nassociate/map a value with a key, we will later use the key to retrieve/get its\r\nassociated value (and possibly change the value: e.g., if the value is a Set,\r\nwe may add to or remove something from that Set). We can also erase a key, ask\r\nwhether a key or value is in a map, and iterate through all mappings\r\n(represented by a pair, consisting of a key and its associated value).\r\n\r\nA Map in C++ is used like a dict in Python (really is is more like a\r\ndefaultdict, because accessing a non-existant key automatically creates a new\r\nmapping from that key to a value created by the default constructor for the type\r\nof the value). Recall the discussion of default constructors for PriorityQueues:\r\none reason why the \"gt\" function appears as part of the class template is to\r\nallow us to specify a default constructor in an ArrayPriorityQueue; the default\r\nconstructor doesn't require specification of a gt function as an argument.\r\n\r\nBelow is a slightly simplified version of the array_map.hpp file. Note that\r\nit is doubly templated, with both a KEY (specifying the type of the keys in the\r\nMap), and a T (specifying the type of the values in the Map); both KEY and T\r\nare used when specifying some of the prototypes of the methods: e.g., put takes\r\na key of type KEY and a value of  type T; erase takes a key of type KEY and\r\nreturns a value of type T. Also examine\r\n  typedef ics::pair<KEY,T> Entry;\r\nwhich specifies that each Entry in a Map is an ics::pair of these two types.\r\n\r\n-----------\r\n\r\nJust a heads-up here, when discussing Map iterators, we will show how to print\r\nall the keys and their associated values in a Map. For this example lets assume\r\nthat ArrayMap m has keys of type std::string and values of type\r\nics::ArraySet<std::string>.\r\n\r\n  for (const ics::pair<std::string,ics::ArraySet<std::string>>& kv : m)\r\n    std::cout << kv.first << \"->\" << kv.second << std::endl;\r\n\r\nNote that iterating through a map means iterating over entries (key/value pairs,\r\nwhere pair is a class defined in the ics namespace). Using auto we can simplify\r\nthis code to just\r\n\r\n  for (const auto& kv : a_map)            //faster than for (auto kv : a_map) \r\n    std::cout << kv.first << \"->\" << kv.second << std::endl;\r\n\r\nWe will discuss this code more detail after discussing Maps belows.\r\n\r\n-----------\r\n\r\n------------------------------------------------------------------------------\r\n\r\nnamespace ics {\r\n\r\n\r\ntemplate<class KEY,class T> class ArrayMap {\r\n  public:\r\n    typedef ics::pair<KEY,T> Entry;\r\n\r\n    //Destructor/Constructors\r\n    ~ArrayMap();\r\n\r\n    ArrayMap();\r\n    explicit ArrayMap(int initialLength);\r\n    ArrayMap         (const ArrayMap<KEY,T>& to_copy);\r\n    ArrayMap         (const std::initializer_list<Entry>& il);\r\n\r\n    //Iterable class must support \"for-each\" loop: .begin()/.end() and prefix ++ on returned result\r\n    template <class Iterable>\r\n    ArrayMap (const Iterable& i);\r\n\r\n\r\n    //Queries\r\n    bool empty      () const;\r\n    int  size       () const;\r\n    bool has_key    (const KEY& key) const;\r\n    bool has_value  (const T& value) const;\r\n    std::string str () const; //supplies useful debugging information; contrast to operator <<\r\n\r\n\r\n    //Commands\r\n    T    put   (const KEY& key, const T& value);\r\n    T    erase (const KEY& key);\r\n    void clear ();\r\n\r\n    //Iterable class must support \"for-each\" loop: .begin()/.end() and prefix ++ on returned result\r\n    template <class Iterable>\r\n    int put_all(const Iterable& i);\r\n\r\n\r\n    //Operators\r\n\r\n    T&       operator [] (const KEY&);\r\n    const T& operator [] (const KEY&) const;\r\n    ArrayMap<KEY,T>& operator = (const ArrayMap<KEY,T>& rhs);\r\n    bool operator == (const ArrayMap<KEY,T>& rhs) const;\r\n    bool operator != (const ArrayMap<KEY,T>& rhs) const;\r\n\r\n    template<class KEY2,class T2>\r\n    friend std::ostream& operator << (std::ostream& outs, const ArrayMap<KEY2,T2>& m);\r\n\r\n    Iterator begin () const;\r\n    Iterator end   () const;\r\n\r\n...\r\n\r\n}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCommands (for Map):\r\n      \r\nThe \"put\" method maps a key to a value (adds a pair consisting of the key and\r\nthe value into the Map). Within a Map, such a pair is called an \"Entry\". If\r\nthat key was already in the Map, put returns the value that it PREVIOUSLY\r\nMAPPED TO; if it wasn't already in the Map, it returns the value it is NOW\r\nMAPPED TO (just the second parameter). This method is like \"push\", \"enqueue\",\r\n\"insert\" in the other templated classes, but it returns not an int, but the old\r\nvalue that the key mapped to (or the current value if the key is new to the\r\nMap). We will see that by overloading the [] operator there is another way to\r\nput a key/value pair (or Enry) into Map: but which doesn't return anything; each\r\nform has its appropriate uses.\r\n\r\nThe \"erase\" method removes (discards) the key and whatever value it maps to\r\nin the Map. It also returns the value that the key (now removed) was PREVIOUSLY\r\nMAPPED TO. If the key is not in the Map, \"erase\" throws the KeyError exception.\r\n\r\nThe \"clear\" method removes all the entries currently in the Map; its return type\r\nis void, so it returns nothing (instead, it could return an int specifying the\r\nnumber of values removed; but we will stay with void this quarter). Calling the\r\nempty() and size() queries after calling \"clear\" will return a result of true\r\nand 0 respectively, regardless of the data structure implementing this data\r\ntype: that relationship between methods is based on the data type itself, so all\r\nimplementations must ensure that it is true.\r\n\r\nThe \"put_all\" method is further templated by \"Iterable\", which can be\r\ninstantiated by every data type that we define (and others too: technically the\r\nclass must support only a \"begin\", \"end\", and prefix increment and dereference\r\noperators). It puts into the Map all the entries produced by an iterator for\r\nthat data type (think of it as breaking each entry into its key and associated\r\nvalue part, and doing a \"put\" with that key and value). It also returns an int\r\nresult specifying how many entries were put in the Map (regardless of whether\r\nthey were in the Map before): so really, it returns the number of values that\r\nthe iterator produces.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nQueries (for Map)\r\n      \r\nThe \"empty\" method returns whether or not there are any values in the Map.\r\nIt is a convenient boolean method equivalent to testing whether size() == 0\r\n(see below).\r\n\r\nThe \"size\" method returns the number of values currently in the Map. Often, but\r\nnot always, a Map implementation will store the size of the Map as a counter.\r\nIn these implementations the put method increments this counter by 1 if the\r\nkey to put is not in the Map and the erase method decrements this counter\r\nby 1 if the key to erase is in the Map. So, it doesn't have to count the\r\nkey/value pairs to compute the size (but it can be implemented this way, which\r\ncosts time but saves space).\r\n\r\nThe \"has_key\" method returns whether or not the specified key is stored in the\r\nMap.\r\n\r\nThe \"has_value\" method returns whether or not the specified value is associated\r\nwith some (one or more) keys in the Map.\r\n\r\n  When we learn more advanced data structures for implementing Maps, we will\r\n  find that the \"has_key\" method will typically perform much more quickly than\r\n  the \"has_value\" method (and looking up the value associated with a key will\r\n  perform at the same quick speed). Maps are organized by their keys, e.g., in\r\n  binary search trees or hash tables, to provide a performance advantage for\r\n  lookup by key.\r\n\r\nThe \"str\" method is discussed below, along with the overloaded the << operator:\r\nthey are closely related but there is an important distinction between them:\r\nfundamentally, all Set implementations must produce identical-looking results\r\nfor \"operator <<\" (identical-looking, because the entries in the Map might\r\nappear in any order) but they can (and often do) produce different results for\r\nthe \"str()\" method; the difference includes information in \"str()\" that depends\r\non the implementations. For example, array and linked list implementations\r\nreturn different information for \"str()\". Such information can be useful when\r\ndebugging different implementations of a data type.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nConstructors (for Map)\r\n\r\nEvery class implementing a Map will specify a destructor and at least four\r\nconstructors. There should always be...\r\n\r\n  (1) A default constructor;\r\n      The constructed object is empty.\r\n\r\n  (2) A copy constructor;\r\n      The constructed object is a copy of it argument.\r\n\r\n  (3) An initializer_list constructor (new in C++11);\r\n      The constructed object has all the values in the initializer_list.\r\n\r\n  (4) An Iterable constructor, which iterates through any data type,\r\n        enqueuing all the iterated over values onto the constructed Queue.\r\n        It is similar in form and function to the \"enqueue_all\" method.\r\n      Constructed object has all the values produced by the iterable\r\n        \r\nNote that (3) and (4) are explicit. We can use them to EXPLICITLY construct\r\nArrayMaps or convert initializer_lists and Iterables into ArrayMaps.\r\n\r\nAn example of (3) is\r\n    typedef ics::pair<std::string,int> Entry;\r\n    ics::ArrayMap<std::string,int> small_numbers(\r\n      {Entry(\"one\",1), Entry(\"two\",2), Entry(\"three\",2)});\r\n\r\nwhich would print as\r\n\r\n  map[one->1,two->2,three->2]\r\n\r\nthe order might be different for Maps not implemented by arrays; the order is\r\nnot part of the Map data type (and not part of the Set data type either, but the\r\norder is part of the Qeueue, Stack, and PriorityQueue data types).\r\n\r\nA templated class can define more constructors depending on the implementation\r\nbut it should always have these four. We will study all these constructors in\r\nthe next lecture, when we study actual data structures that implement these\r\ndata type.\r\n\r\nFor Array implementations, there is a constructor that specifies the initial\r\nlength of the array storing the Map. In a default constructor, an array of\r\nlength 0 is used.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nOperators/Miscellaneous (for Map):\r\n\r\nThe [] operator is overloaded, most importantly to allow us to retrieve the\r\nvalue associated with a key. So in Map m, if k is a value of type KEY we can \r\nwrite m[k] to retrieve the value; if the value is a Set, we could write the\r\nstatement m[k].insert(...value...);  to mutate the Set associated with the key.\r\nWe DON'T NEED TO RE-PUT the new set in the Map: it is already there, associated\r\nwith the key k, but now mutated to contain a new value. THINK HARD ABOUT WHAT I\r\nJUST WROTE. Reread it.\r\n\r\nIf key k does not exist in m, then it will be put in m, associated with whatever\r\nvalue is constructed by the default constructor for T (the second class\r\ntemplating a Map). In this case it will return a reference to the new (empty)\r\nvalue associated with k. It is similar to a defaultdict in Python.\r\n\r\nFinally, if v is a type T value, writing m[k] = v; updates the Map m\r\nequivalently to m.put(k,v); except unlike \"put\", this assignment statement does\r\nnot return a value (OK, technically x = y is an expression that does return a\r\nvalue: a reference to the x; so more accurately, it always returns the new value\r\nstored in m[k], which is v; one could write (m[k] = v).method call(...);)\r\nFor example, executing\r\n\r\n  ArrayMap<std::string,std::string> m;\r\n  (m[\"a\"] = \"b\").append(\"c\");\r\n  std::cout << m << std::endl;\r\n\r\nprints associates the key \"a\" with the value \"b\" but then mutates it to \"bc\" so\r\nultimately prints\r\n\r\n  map[a->bc];\r\n\r\nThe = operator is overloaded for Maps. So if m1 and m2 are ArrayMap storing the\r\nsame type of information, then we can write the statement m1 = m2; now the\r\ninformation m1 originally stored is gone, and m1 contains all the information\r\nin m2 (for the == operator, now m1 == m2 should return true).\r\n\r\nThe == and != operators are overloaded for Maps. The definition for equality\r\nbetween Maps is that they must contain the same keys mapped to the same values\r\n(said another way, they must contain the same entries). The order in which such\r\nmaps would print is irrelevant. Note that m == m is always true.\r\n\r\nAs with other data types, a Map both overloads the << operator and defines a\r\n.str() method. A Map storing two entries (Mapping \"a\" to 1 and \"b\" to 2) will\r\ninsert \"map[a->1,b->2]\" on a stream; but be careful here: like Sets, a Map has\r\nno special order, so this Map might insert \"map[b->2,a->1]\" just as easily.\r\nThis \"unordered\" feature is even more important when we learn about iterating\r\nover all the entries in a Map. If m is an ArrayMap storing these entries, the\r\n.str() method would return a string like\r\n\"ArrayMap[a->1,b->2](length=2,used=2,mod_count=2)\" in which instance variables\r\nand their values appear in parentheses, separated by commas.\r\n\r\nThe \"begin\" and \"end\" methods return an iterator representing a cursor/index TO\r\nthe \"first\" entry (of type ics::pair) in the Map and ONE BEYOND the \"last\" \r\nentry in the Map respectively (for a Map of size() == 0, it returns the same\r\niterator for both).  As we discussed there really is no order among the entries\r\nin Map, but when we iterate over them, these entries  must produced in some\r\norder: not only can we not predict the order for different implementations, but\r\ndifferent times that we iterate over a Map its entries can be produced in a\r\ndifferent order! DO NOT MAKE ANY ASSUMPTIONS ABOUT THE ORDER ENTRIES ARE\r\nPRODUCED BY Map ITERATORS: order is not a behavioral/logical property of a Map\r\n(or Set), the way it is for Stacks, Queues, and PriorityQueues.\r\n\r\nNote that we can refer to the public .first and .second instance variables of\r\neach ics::pair (which represents an entry). We refer to these instance variables\r\ndirectly, not through accessors.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nSimple Uses of Maps\r\n\r\nLet us assume for simplicity that we have declared the following typedefs,\r\nwhich we will frequently use then using the ITL (here they have very generic\r\nnames, in a real program the names should be more specific).\r\n\r\n  typdef std::string                 Key;\r\n  typdef icc::ArraySet<std::string>  Value;\r\n  typdef ics::pair<Key,Value>        Entry;\r\n  typdef ics::ArrayMap<Key,Value>    Map;\r\n  \r\n  Map m;\r\n\r\nWe have seen that the following code prints all the key/value associations in\r\na Map, one per line. It iterates over every entry (Key/Value pair, so I often\r\ngenerically use kv for my interation variables) printing it. If you have more\r\nspecific information about the keys/values, use a more specific name.\r\n\r\n  for (const Entry& kv : m)\r\n    std::cout << kv.first << \"->\" << kv.second << std::endl;\r\n\r\nAgain, using auto we can simplify this code to the following: but now that we\r\nare using typedefs to name interesting types,the code above is explicit by not\r\nso complicated (so auto is not so useful in the case where we have an Entry\r\ntypedef).\r\n\r\n  for (const auto& kv : m)\r\n    std::cout << kv.first << \"->\" << kv.second << std::endl;\r\n\r\nBecause iterators produce key/value entries in no special order, we often\r\nneed to use the following, more complicated code to print all the key/value\r\nassociations in a Map, IN ALPHABETICAL ORDER ACCORDING TO k, using the\r\nentry_gt function, which we can write as follows. Note that entry_gt(a,b)\r\nreturns true if the key of a has a higher priority than the key of b, meaning\r\nthe key of a comes alphabetically BEFORE the key of b.\r\n\r\n  bool entry_gt (const Entry& a, const Entry& b)\r\n  {return a.first < b.first;}\r\n\r\n  ics::ArrayPriorityQueue<Entry> sorted(entry_gt);\r\n  sorted.enqueue_all(m);\r\n\r\nor rewrite the second part by using entry_gt to instantiate the template\r\n\r\n  ics::ArrayPriorityQueue<Entry,entry_gt> sorted;\r\n  sorted.enqueue_all(m);\r\n\r\nBoth pairs of statements define an ArrayPriorityQueue named sorted, which is\r\nfilled with the entries from Map m; they will be removed from the priority queue\r\nin an ordered dictated by entry_gt.\r\n\r\nNow, we can iterate over the priority queue, resulting in the Map's keys being\r\nprinted in sorted order: the biggest entry (highest priority), according to\r\nentry_gt, is printed first.\r\n\r\n  for (const Entry& kv : sorted)\r\n    std::cout << kv.first << \"->\" << kv.second << std::endl;\r\n\r\nIn fact, we can use a special ArrayPriorityQueue constructor (Iterable) to\r\ndefine and fill in this priority queue using just one line of code.\r\n\r\n  ics::ArrayPriorityQueue<Entry> sorted(m,entry_gt);\r\n\r\nor\r\n\r\n  ics::ArrayPriorityQueue<Entry,entry_gt> sorted(m);\r\n\r\nAlthough each is a mouthful, both do the job of constructing the Priority\r\nQueue named sorted with the appropriate \"gt\" function, filling it with the\r\nentries from the Map named m.\r\n\r\nThen, instead of iterating over the Map, we iterate over the Priority Queue\r\n(still producing Entry/pairs), which prints the entries (key/value pairs) in a\r\nsorted order. We will see below different ways to print Maps in sorted order.\r\n\r\nIn fact, we can write everything a just a for loop, whichi implicitly declares\r\nand uses the priority queue that was named \"sorted\" above.\r\n\r\n  for (const Entry& kv :  ics::ArrayPriorityQueue<Entry,entry_gt>(m) )\r\n    std::cout << kv.first << \"->\" << kv.second << std::endl;\r\n\r\n-----\r\n\r\nLet's next examine a few ways to put/update an association/mapping in the Map\r\ndescribed above. Suppose we have a std::string key k1 and want a std::string v1\r\nto be a value in the Set that k1 maps to. There are two cases to consider:\r\n\r\n  (1) k1 is a key in the Map (maps to a Set) so we should add v1 to that Set\r\n\r\n  (2) k1 is not a key in the Map (maps to NO Set), so we should put in an\r\n      association/mapping from k to a new Set that contains only v1\r\n\r\nThis code, or some variant of it, appears in most programs whose most basic\r\ndata type is a Map (most of those in Programming Assignment #1).\r\n\r\nHere is some code that directly implements this algorithm.\r\n\r\n  if (m.has_key(k1))\t\t//k1 a key in m with associated set?\r\n    m[k1].insert(v1);\t\t//Yes: add v1 to it associated set\r\n  else{                         //No: \r\n    Value mapped_values;\t//  Create empty set (Value is set of string)\r\n    mapped_values.insert(v1);\t//  add v1 to that empty set\r\n    m[k1] = mapped_values;\t//  associate k1 with this new set, storing v1\r\n  }\r\n\r\n----------\r\nInterlude\r\n\r\n  We could also \"reverse\" the last two lines in the else as\r\n    m[k1] = mapped_values;\t//  associate k1 with an empty set\r\n    m[k1].insert(v1);\t        //  add v1 to the empty set\r\n\r\n  We could even write them as a single line, based on what value = evaluates to\r\n    (m[k1] = mapped_values).insert(v1);\r\n\r\n  Or even reduce all 3 lines to a single line\r\n    (m[k1] = Value()).insert(v1);\r\n\r\n  Why won't the following work?\r\n    m[k1] = Value().insert(v1);  //Not equivalent to the code above\r\n----------\r\n\r\nNotice in this code that we must \"search\" the Map for a key twice: once for the\r\ncall to has_key(), and once for [], depending which if part is executed. \r\n\r\nWe can simplify this code a bit, by using an special constructor.\r\n\r\n  if (m.has_key(k1))\t\t//k1 a key in m with associated set?\r\n    m[k1].insert(v1);\t\t//Yes: add v1 to it associated set\r\n  else{                         //No:\r\n    Value mapped_values({v1});\t//  Create set containing one value: v1\r\n    m[k1] = mapped_values;\t//  associate k1 with this new set storing v\r\n  }\r\n\r\nBut given what [] does for a key not in the Map (putting the key in the Map\r\nassociated with a value from type T's default constructor), the following\r\nsimpler (almost trivial) code always \"searches\" the Map once, either inserting\r\ninto the Set it finds already associated with that key, or inserting into an\r\nempty Set it creates with the default constructor when it finds the key is not\r\nin the Map.\r\n\r\n  m[k1].insert(v1)\r\n\r\nUnderstand what you want Maps to do and write the simplest code possible (simple\r\noften means efficient too, but that depends on implementations). This one line\r\nis equivalent to the if statements above.\r\n\r\n-----\r\n\r\nMutation in PriorityQueues, Sets, and Maps:\r\n\r\nDO NOT ATTEMPT TO MUTATE any VALUES in a PriorityQueue or Set, or any KEYS in a\r\nMap. It is perfectly OK and frequently useful (as shown above) to mutate the\r\nVALUEs associated with KEYs in a Map.\r\n\r\nSome data structures (e.g., binary search tree and hash table) implement these\r\ndata types by storing values/keys in locations  that are based on their state.\r\nChanging the state of such a value/key will change the location it SHOULD BE\r\nSTORED IN, causing the value/key to be stored in the wrong place and/or be lost\r\n(unfindable). These issues are not present in Array implementations, so we will\r\nrevisit them later in the quarter. But since we don't know what implementations\r\nwe might be using, we should not do these kinds of mutations ever.\r\n\r\nSo, for example, if you wanted to change value in a Set, you should first\r\nremove it, then mutate it, then insert it back into the Set.\r\n\r\n  ics::ArraySet<std::string> s;\r\n  std::string element = ...;\r\n\r\n  s.remove(element);\r\n  element.mutator();\r\n  s.insert(element);\r\n\r\nLikewise, if you wanted to change a KEY in a Map, you should first remove it,\r\nthen mutate it, then put it back into the Set associated with its old value.\r\n\r\n  ics::ArrayMap<std::string,ics::ArraySet<std::string>> m;\r\n  std::string a_key = ...;\r\n\r\n  ArraySet<std::string> a_value = m.erase(a_key);  //store current value of key\r\n  a_key.mutator();\r\n  m[a_key] = a_value;\r\n\r\nWe will discuss this issue further, and in greater detail, when we learn about\r\nbinary search trees. In fact, the same problem occurs when using hashing, so we\r\nwill discuss this issues more than once later in this quarter.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nI have written but will not have time to discuss in depth a cross reference\r\nprogram. Download the project cross_reference from the web: see the Lectures or\r\nWeekly Schedule link for today; see if you can quickly create an Eclipse\r\nproject for this program, which uses courselib. this program uses these data\r\ntypes (templated classes in the ITL: Stack, PriorityQueue, and Map) to solve\r\nthe following problem. If you understand this code, you are fully ready to\r\nsolve Programming Assignment #1, but not until.\r\n\r\n  Read a file that contains lines of words separated by spaces. Produce a cross\r\n  reference map containing each word (as a key) and the lines in the file that\r\n  it appears on (as a value associated with a key: a Stack) such that even if a\r\n  word appears multiple times on a line, it appears only once in the Stack.\r\n  (Prove that the values from the bottom to top of the stack must get bigger).\r\n  Words using different case are considered to be different: \"Run\" != \"run\".\r\n  Then, print the map alphabetically by the words; finally, print the map from\r\n  most frequently to least frequently occuring words (e.g., sortd by Stack\r\n  size), such that all the words occurring with the same frequency are printed\r\n  in alphabetical order.\r\n\r\nHere is a sample (trivial) input file (notice punctuation was stripped):\r\n\r\nSee Dick\r\nSee Jane\r\nSee Spot\r\nSee Spot run\r\nRun Spot run\r\n\r\nAnd here are the results in the console of running the program.\r\n\r\nEnter file name to analyze[text.txt]: \r\n\r\nXRef alphabetically\r\n  Dick --> stack[1]:top\r\n  Jane --> stack[2]:top\r\n  Run --> stack[5]:top\r\n  See --> stack[1,2,3,4]:top\r\n  Spot --> stack[3,4,5]:top\r\n  run --> stack[4,5]:top\r\n\r\nXRef by frequency\r\n  See --> stack[1,2,3,4]:top\r\n  Spot --> stack[3,4,5]:top\r\n  run --> stack[4,5]:top\r\n  Dick --> stack[1]:top\r\n  Jane --> stack[2]:top\r\n  Run --> stack[5]:top\r\n\r\nNotice that Dick, Jane, and Run all appear once, so in the final print (by\r\nfrequency) they appear in alphabetical order.\r\n\r\nHere is the program. I'll just briefly explain\r\n\r\n1) The typedefs allow us to use simple names in the rest of the code.\r\n\r\n2) Notice how I used the following functions from ics46goody (in the courselib):\r\nsplit in read_xref and safe_open in main. You will find these functions useful\r\nin all parts of Programming Assigment #1.\r\n\r\n3) Note that the declaration\r\n\r\n     XRefPQ sorted(xref,has_higher_priority);\r\n\r\n   declares an XRefPQ filled with entries found by iterating over xref,\r\n   prioritized by the has_higher_priority parameter (discussed below in 4). It\r\n   is a shorthand for the equivalent code\r\n\r\n     XRefPQ sorted(has_higher_priority);\r\n     sorted.enqueue_all(xref);\r\n\r\n   or even the more verbose\r\n\r\n     XRefPQ sorted(has_higher_priority);\r\n     for (const XRefEntry& elem : xref)\r\n       sorted.enqueue(elem);\r\n\r\n4) In print_xref, read\r\n\r\n      bool (*has_higher_priority)(const XRefEntry& i,const XRefEntry& j))\r\n\r\n   as a pointer to a function that determines whether i has a higher priority\r\n   than j (meaning i would be dequeued/iterated-over before j. Generally, this\r\n   function has two const XRefEntry reference parameters and returns a bool.\r\n   Semantically, it returns whether i > j (i has a greater priority than j),\r\n   which is used to prioritize values in the priority queue.  We need to pass\r\n   it an argument that is the name of such a function, or a lambda (which is\r\n   what appears in calls in main). One  example is  \r\n\r\n      [](const XRefEntry& i,const XRefEntry& j)\r\n      {return (i.first == j.first ? \r\n                 i.second.size() < j.second.size() : i.first < j.first);}\r\n\r\n   It says (see XrefEntry below) if the strings are equal, i > j if its Stack\r\n   size is bigger, otherwise i > j if this string comes early in a dictionary.\r\n\r\n   Note that the priority queue local variable in print_xref is instantiated to\r\n   be of type ics::ArrayPriorityQueue<XRefEntry>, whose template does not\r\n   specify a gt function. We specify the gt function by the has_higher_priority\r\n   function. Recall that it is ILLEGAL TO INSTANTIATE a template using such a\r\n   lambds parameter: ics::ArrayPriorityQueue<XRefEntry,has_higher_priority> is\r\n   ILLEGAL.\r\n\r\n5) Re: 3) Learn the idiom for using a PriorityQueue to sort the pairs produced\r\n   by a Map in order to print the Map in a sorted order (based on both its\r\n   keys and values).\r\n\r\n------------------------------------------------------------------------------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include \"ics46goody.hpp\"\r\n#include \"array_stack.hpp\"\r\n#include \"array_priority_queue.hpp\"\r\n#include \"array_map.hpp\"\r\n\r\n\r\n//Useful typedefs: meaningful names connected to specific implementations\r\n//  that are used in this program; some of these can be changed to use\r\n//  different implementations (e.g., not Array) when those become available,\r\n//  to improve the performance of the program; we must change #includes too.\r\n//Note this program uses ArrayStack, ArrayPriorityQueue, and ArrayMap\r\ntypedef ics::ArrayStack<int>                  LineStack;\r\ntypedef ics::pair<std::string,LineStack>      XRefEntry;\r\ntypedef ics::ArrayPriorityQueue<XRefEntry>    XRefPQ;    //Must supply gt at construction\r\ntypedef ics::ArrayMap<std::string,LineStack>  XRef;\r\n\r\n\r\n//Read an open file of words separated by spaces and return a cross\r\n//  reference (Map) of each word associated with the lines on which it\r\n//  appears; if a word appears multiple times on a line, just record the\r\n//  line number once (this requirement makes stacks the best data type\r\n//  to record line numbers).\r\nXRef read_xref(std::ifstream& file) {\r\n  XRef xref;\r\n\r\n  std::string line;\r\n  int line_number = 0;\r\n  while (getline(file,line)) {\r\n    line_number++;\r\n    std::vector<std::string> words = ics::split(line,\" \");\r\n\r\n    for (const std::string& word : words)\r\n      if (!xref.has_key(word) || xref[word].peek() != line_number)\r\n        xref[word].push(line_number);\r\n  }\r\n\r\n  file.close();\r\n  return xref;\r\n}\r\n\r\n\r\n//Print message and all the entries in a cross reference in the order specified\r\n//  by *has_higher_priority: i is printed before j, if has_higher_priority(i,j)\r\n//  returns true.\r\nvoid print_xref(std::string message,\r\n                const XRef& xref,\r\n                bool (*has_higher_priority)(const XRefEntry& i,const XRefEntry& j)) {\r\n  std::cout << \"\\n\" << message << std::endl;\r\n  for (const XRefEntry& kv : XRefPQ(xref,has_higher_priority))\r\n    std::cout << \"  \" << kv.first << \" --> \" << kv.second << std::endl;\r\n}\r\n\r\n\r\n////An improved print_xref, printing line numbers ascending, separated by commas.\r\n////Print message and all the entries in a cross reference in the order specified\r\n////  by *has_higher_priority: i is printed before j, if has_higher_priority(i,j)\r\n////  returns true.\r\n//void print_xref(std::string message, XRef& xref,\r\n//                bool (*has_higher_priority)(const XRefEntry& i,const XRefEntry& j)) {\r\n//  std::cout << \"\\n\" << message << std::endl;\r\n//  XRefPQ sorted(xref,has_higher_priority);\r\n//  for (const XRefEntry& kv : sorted) {\r\n//    std::cout << \"  \" << kv.first << \" --> \";\r\n//    LineStack lines;\r\n//    for (const auto& v : kv.second)\r\n//      lines.push(v);\r\n//    int count = 0;\r\n//    for (int line : lines)\r\n//      std::cout << (count++ == 0 ? \"  \" : \", \") << line;\r\n//    std::cout << std::endl;\r\n//  }\r\n//}\r\n\r\n\r\n//Prompt the user for a file, create a cross reference of its contents, and print\r\n//  the entries in the cross reference two ways: sorted alphabetically (increasing)\r\n//  by words and sorted by frequency of word use (decreasing); see the two lambdas\r\n//  used to specify the order in which to print the entries.\r\nint main() {\r\n  std::ifstream text_file;\r\n  ics::safe_open(text_file,\"Enter file name to analyze\",\"text.txt\");\r\n\r\n  XRef xref = read_xref(text_file);\r\n\r\n  print_xref(\"XRef alphabetically\",xref,\r\n             [](const XRefEntry& i,const XRefEntry& j){return (i.first == j.first ? i.second.size() < j.second.size() : i.first < j.first);});\r\n  print_xref(\"XRef by frequency\",xref,\r\n             [](const XRefEntry& i,const XRefEntry& j){return (i.second.size() == j.second.size() ? i.first < j.first : i.second.size() > j.second.size());});\r\n\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\nFor the input above, and the commented out print_xref, it prints\r\n\r\nXRef alphabetically\r\n  Dick -->   1\r\n  Jane -->   2\r\n  Run -->   5\r\n  See -->   1, 2, 3, 4\r\n  Spot -->   3, 4, 5\r\n  run -->   4, 5\r\n\r\nXRef by frequency\r\n  See -->   1, 2, 3, 4\r\n  Spot -->   3, 4, 5\r\n  run -->   4, 5\r\n  Dick -->   1\r\n  Jane -->   2\r\n  Run -->   5\r\n\r\nIt is still a bit sloppy, because the numbers do not start in an aligned\r\ncolumn; that could be fixed by finding iterating throug the map and finding\r\nthe longest word that is a key and then printing each word in that amount of\r\nspace.\r\n\r\nCan you change this program to convert all strings to lower case? For this\r\nfile it would produce the following (with the original print_xref).\r\n\r\nXRef alphabetically\r\n  dick --> stack[1]:top\r\n  jane --> stack[2]:top\r\n  run --> stack[4,5]:top\r\n  see --> stack[1,2,3,4]:top\r\n  spot --> stack[3,4,5]:top\r\n\r\nXRef by frequency\r\n  see --> stack[1,2,3,4]:top\r\n  spot --> stack[3,4,5]:top\r\n  run --> stack[4,5]:top\r\n  dick --> stack[1]:top\r\n  jane --> stack[2]:top\r\n", "encoding": "ascii"}