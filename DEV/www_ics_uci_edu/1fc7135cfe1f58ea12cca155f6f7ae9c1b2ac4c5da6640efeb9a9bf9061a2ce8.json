{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/usefulfunctions/usefulfunctions.txt", "content": "\t\t\tUseful Functions/Methods\r\n\r\n\r\nThis turns out to be an abbreviated lecture in which we will cover some odds\r\nand ends about functions (and methods, which are just functions called a\r\nspecial way), ending a new way (lambda) to define new/simple functions.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nmin and max\r\n\r\nI mentioned when I wrote the min function that the builtins class defines the\r\nmin and max functions to operate on any numeric types, and they can have any\r\nnumber of parameters. So, we can call min(a,b,c,d) to compute the minimum of\r\nthese for values. When we learn about tuples (right after lists) we will learn\r\nthat these functions are defined similiarly, as follows (notice the different\r\noperators in the if statement):\r\n\r\ndef min(*args):\t     \t \t      def max(*args):\r\n    answer = args[0]\t\t          answer = args[0]\r\n    for x in args[1:]:\t\t\t  for x in args[1:]:\r\n        if x < answer:\t\t\t      if x > answer:\r\n            answer = x\t\t\t          answer = x\r\n    return answer    \t\t\t  return answer\r\n\r\ntype\r\n\r\nCalling type(object) returns a reference to the type of the object (we can\r\nspecify the object as a literal, variable, or more complicated expression.\r\nOf what use is knowing the type of something? One simple use is to check whether\r\nthe type of the argument bound to a parameter is correct. For example, in the\r\nfactorial function we might check the type and value of the parameter, to\r\nensure is it a positive integer by the following assertions.\r\n\r\ndef factorial(n)\r\n    assert type(n) is int, 'factorial: n is wrong type\"' + str(type(n))\r\n    assert n >= 0, 'factorial: n('+str(n)+') is negative\r\n    ....\r\n\r\nRecall that the \"is\" operator means the same object as (a stronger version of\r\n==). So we are checking whether the type(n) is the same object as int. Recall\r\nthat the names of the types are objects, just as values of specific types are\r\nobject. With the type function we can compute the type of an an object.\r\n\r\nWe can combine these into one assertion\r\n\r\n    assert type(n) is int and n>=0, 'factorial: n('+str(n)+') is illegal\r\n\r\nWhen we print type(...) it prints as follows (although typically we don't print\r\nthese results: we check them with \"is\"):\r\n\r\nprint(type('a'))  \t     <class 'str'>\r\nprint(type(1))\t\t     <class 'int'>\r\nprint(type(1.))\t\t     <class 'float'>\r\nprint(type(True))\t     <class 'bool'>\r\n\r\n\r\neval and exec\r\n\r\nWe features eval and exec in the previouis lecture. Both have arguments that\r\nare strings that should represent a valid expression/statement respectively.\r\nCalling eval returns the result of the expression, calling exec executes the\r\nstatement. Simple examples are\r\n\r\nexec('x = 1')\r\nprint(eval('x'))\r\n\r\nwhich prints 1. These functions are powerful when the strings are external to\r\nthe program: when we prompt the user for this information or read the\r\ninformation froma file.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nString Formatting and the .format method\r\n\r\nThere is a format method that we can use simply as follows:\r\n\r\n'For {scores} students: average = {percent}%'.format(scores=10,percent=83)\r\n\r\nwhich evaluates to the following string (which we can bind to a name or print)\r\n\r\n'For 10 students: average = 83%'\r\n\r\nSo primarily, the format method creates a new string from an old one, by\r\nreplacing the names in {} with the string representations for the values named\r\nas parameters in the () following the method name: format.\r\n\r\nIt is easy to exxperiment in the Python interpreter with this method. For\r\nexample, what if the name in the {} does not appear as a parameter in the (),\r\neither we omit it or misspell it.\r\n\r\n'Trying {foo}'.format(fo=2)\r\n\r\nPython raises the KeyError exception, saying it cannot find foo. But,\r\n\r\n'Trying {foo}'.format(foo=2,more=3)\r\n\r\nworks without any errors (producing 'Trying 2') so having missing parameters is\r\nan error, but having extra ones in the format method call is not.\r\n\r\nThe real power of the format method comes with other information that we can\r\nput inside {}. First we will show some examples, and then the complete form of\r\nall possibilities. If we write a : after the name in the {}, the information\r\nthat comes after it, in the {}, specifies information about how to turn the\r\nvalue into the replacment string. First lets look at some information for\r\nreplacing integers.\r\n\r\n'A{a: >5d}Z'.format(a=100) is 'A  100Z'\r\n   After the : space (for fill)\r\n               >     (for align, to right)\r\n               5     (for width)\r\n\t       d     (for type, decimal integer)\r\n\r\nBecause the width is 5 and the number is 3 digits, is puts 2 spaces (the fill)\r\nbefore the number aligning it to the right, to get a width of 5. Instead we\r\ncould write\r\n\r\n'A{a: <5d}Z'.format(a=100) is 'A100  Z'\r\n   After the : space (for fill)\r\n               <     (for align, to left)\r\n               5     (for width)\r\n\t       d     (for type, decimal integer)\r\n\r\nHere the alignment is to the left. We can change the alignment back to right,\r\nand change the fill to a X\r\n\r\n'A{a:X>5d}Z'.format(a=100) is 'AXX100Z'\r\n   After the : 0     (for fill)\r\n               >     (for align, to right)\r\n               5     (for width)\r\n\t       d     (for type, decimal integer)\r\n\r\nNow instead of two spaces in front of the right aligned number, it uses a fill\r\nof X and puts two Xs before the number.\r\n\r\nNote that we can omit the fill (the default is space) and the align (default is\r\nright for numbers), and the width (the default is the number of characters it\r\ntakes) and simplify the above to\r\n\r\n'A{a:d}Z'.format(a=100) is 'A100Z'\r\n\r\nIn fact, we can default everything, which for an int has the following effect.\r\n\r\n'A{a}Z'.format(a=100) is 'A100Z'\r\n\r\nFor printing big numbers if we can omit the width (it will take as much space\r\nas it needs) and instead put a comma after where the width specification would\r\ngo (right before the d).\r\n\r\n'A{a:,d}Z'.format(a=1000000000) is 'A1,000,000,000Z'\r\n\r\nor write this just as\r\n\r\n'A{a:,}Z'.format(a=1000000000) is 'A1,000,000,000Z'\r\n\r\nSo, we can specify what we need and default the rest. Sometime adding the\r\ninformation explicitly, instead of defaulting, makes for easier reading,\r\nsometimes not. Examine the EBNF below and experiment with formatting integer\r\nand strings.\r\n\r\nNow lets look at information for replacing floats. Most is the same, but after\r\nthe width we can specify the precision: how many decimal digits to print.\r\nRemember that printing a decimal point takes up one space in the width.\r\n\r\n'A{a: >8.2f}Z'.format(a=100.12345) is 'A  100.12Z'\r\n   After the : space (for fill)\r\n               >     (for align, to right)\r\n               8     (for width)\r\n               2     (for precision)\r\n               f     (for type, float)\r\n\r\nNote that the float takes up a width of 6 charaters total: 100 (3 characters)\r\n. (1 character), 12 (2 characters) so two chacaters in the width are filled in\r\nwith a space.\r\n\r\nNote that we can omit the fill (the default is space) and the align (default is\r\nright for numbers) and simplify the above to.\r\n\r\n'A{a:8.2f}Z'.format(a=100.12345) is 'A  100.12Z'\r\n\r\nIf we omit the width, as with integers it uses the smallest width with no fill.\r\n\r\n 'A{a:.2f}Z'.format(a=100.12345) is 'A100.12Z'\r\n\r\nFormating is useful for separating the form of the resulting string from all\r\nthe values that get substituted into it. When we print float values, we often\r\nwant to control the number of digits after the decimal point. You will need to\r\nuse format to nicely print the float values in the tennis program. Finally,\r\njust like all function calls with named parameters, their arguments can be\r\narbirary expressions.\r\n\r\nscore_sum      = 7543\r\nstudent_count  =   87\r\n'Average = {avg:5.2f}'.format(avg=score_sum/student_count*100)\r\n  is 'Average = 86.70'\r\n\r\nHere is the full EBNF for using format, from Python documentation. Notice the\r\nmost common replacement_field looks like\r\n\r\n  {field_name:format_spec}\r\n\r\nand format_spec has many options (many of which we discussed above), with each\r\nhaving a reasonable default value if omitted.\r\n\r\nEBNF for the .format method:\r\n\r\nreplacement_field ::=  \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\"\r\nfield_name        ::=  arg_name (\".\" attribute_name | \"[\" element_index \"]\")*\r\narg_name          ::=  [identifier | integer]\r\nattribute_name    ::=  identifier\r\nelement_index     ::=  integer | index_string\r\nindex_string      ::=  <any source character except \"]\"> +\r\nconversion        ::=  \"r\" | \"s\" | \"a\"\r\nformat_spec       ::=  <described in the next section>\r\n\r\nformat_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type]\r\nfill        ::=  <a character other than '{' or '}'>\r\nalign       ::=  \"<\" | \">\" | \"=\" | \"^\"\r\nsign        ::=  \"+\" | \"-\" | \" \"\r\nwidth       ::=  integer\r\nprecision   ::=  integer\r\ntype        ::=  \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\"\r\n\r\nfill\t    : one character to use as fill\r\nalign\t    : < (left), > (right), = (after sign), ^ (center)\r\nsign\t    : + (all signed), - (negative signed), space (space for +)\r\n#\t    : Alternative form (different for different types)\r\n0\t    : equivalent to fill 0, alignment =\r\nwidth\t    : width of field for value\r\n,\t    : use comma separators in big numbers\r\n.precision  : digits displayed after decimal point\r\ntype\t    : d (...integer), f/e (...fixed/exponent) floating point\r\n\r\n------------------------------------------------------------------------------\r\n\r\nlambda\r\n\r\nThere are times when it is useful to write a tiny function and not even name\r\nit. For example, suppose we want to prompt for numbers that are at least 10.\r\nWe can write the function\r\n\r\ndef at_least_ten(x):\r\n    return x >= 10\r\n\r\nand then pass this function as an argument when we call prompt.for_int.\r\n\r\nx = prompt.for_int('Enter x', is_legal=at_least_ten)\r\n\r\nNow the prompt.for_int function will keep prompting until the user enters a\r\nvalue 10 or bigger.\r\n\r\nSo, given our ability to write our own functions, we can now write functions\r\nthat work with all the prompt methods, to \"tell them\" which values to allow.\r\nThe functions that prompt.for_int expects to use must have one int parameter\r\nand return a bool value, as does the function at_leat_ten we wrote above.\r\n\r\nIf functions we write for this purpose are really useful, we might put them in\r\na library (like the predicate.py module). But the above function doesn't seem\r\nso useful. We will now learn a simpler way to write and use such simple\r\nfunctions. Lambda  is a Greek letter, used in work done by mathematicians in the\r\n1930, having to do with the logical foundations of mathematics, but which became\r\nvery important when computers were invented.\r\n\r\nInstead of the call above, we can rewrite it as\r\n\r\nx = prompt.for_int('Enter x', is_legal=(lambda x : x >= 10)\r\n\r\nSo, we don't have to write a function at all; we can use a lambda to specify\r\na function. We will see more uses of lambda periodically throughout the 30s\r\nseries. For now we'll just say that we can write a lambda where-ever we might\r\nwrite the name of a function. Lambdas look like\r\n\r\n  lambda parameters: expression-using-parameters\r\n\r\nwhich I often write (as I did for conditional expressions)\r\n\r\n  (lambda parameters: expression-using-parameters)\r\n\r\nto show its beginning and end easily. Note that these are no return statements\r\nin lambdas, only an expression. There is an implicit return inside each lambda,\r\nso we we cannot write complicated statements (i.e., control structures) inside\r\nlambdas. So, they are useful for only simple functions. In fact, writing\r\n\r\nf = (lambda parameters: expression-using-parameters)\r\n\r\nis equivalent to writing\r\n\r\ndef f(parameters):\r\n    return expression-using-parameters\r\n\r\nBut in the case of calling prompt.for_int, we do not even have to name the\r\nlambda, we just pass it along to the is_legal.\r\n", "encoding": "ascii"}