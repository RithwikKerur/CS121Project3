{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/recursion.txt", "content": "\t\t\t\tRecursion\r\n\r\n\r\nIn this lecture we will discuss the concept of recursion and examine recursive\r\nfunctions that operate on integers, strings, and lists -learning some common\r\nidioms for each. As with other topics discussed this quarter that you have\r\nalready seen, I want to ensure that you have a deeper understanding of\r\nrecursion.\r\n\r\nThe concept of recursively defined (sometimes called inductively defined) data\r\ntypes and recursion is fundamental in many areas of computer science, and this\r\nconcept should be discussed from many angles in many of your ICS classes; you\r\nshould become comfortable with seeing and applying recursion. In addition, some\r\nprogramming languages (Lisp, ML, and Haskell are the foremost examples) use\r\nrecursion (and also decision: if) as their primary control structures: any\r\niterative code can be written recursively (and recursion is even more powerful\r\nthan iteration, as we glimpsed in the EBNF lecture). Even languages that are\r\nnot primarily recursive all support recursion (and have since the late 1960s),\r\nbecause sometimes using recursion is the best way to write code to solve a\r\nproblem: best often means simplest, but sometimes it can mean most efficient\r\ntoo (efficient in time to write and/or efficient in time to run).\r\n\r\nPython (and C/C++/Java) are not primarily recursive languages. Each has strong\r\nfeatures for iterating through data (Python has the most powerful tools for such\r\niteration, including generator functions - which can also be recursive). But,\r\nit is important that we learn how to write recursive code in Python too. Next\r\nweek, we will recursively define the linear linked list and binary search tree\r\ndata structures and see how to manipulate them, both iteratively (for some\r\nfunctions) and recursively (for all functions). In ICS-46 we will revisit these\r\ndata structures (and more) many times using C++, and again see how we can\r\nmanipulate them both iteratively and recursively.\r\n\r\nDouglas Hofstadter's Pulitzer-prize winning book, \"Godel, Escher, Bach\" is an\r\ninvestigation of cognition, and commonly uses recursion and self-reference to\r\nillustrate the concepts it is discussing. It is a fascinating book and because\r\nit is old, can be purchased quite cheaply as a used book.\r\nhttp://www.amazon.com/G%C3%B6del-Escher-Bach-Eternal-Golden/dp/0465026567\r\n(at least read some small reviews of this book here). I recommend it highly.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nRecursion vs Iteration\r\n\r\nRecursion is a programming technique in which a call to a function often results\r\nin another call to that same function. In direct recursion, a call to a function\r\nappears in that function's body; in indirect/mutual recursion, the pattern is\r\nsome function calls some other function ... which ultimately calls the first\r\nfunction. In an example where f calls g and g calls f, we say f and g are\r\nmutually recursive with f calling f indirectly via g, and g calling g\r\nindirectly via f.\r\n\r\nFor some data structures (not many built-into Python) and problems, it is\r\nsimpler to write recursive code than its iterative equivalent. In modern\r\nprogramming languages, recursive functions may run a bit slower (maybe 5%) than\r\nequivalent iterative functions, but this is not always the case (and sometimes\r\nthere is no natural/simple iterative solution to a problem); in a typical\r\napplication, this time difference is insignificant (most of the time could be\r\nspent elsewhere in the code anyway). When recursion is natural, it requires\r\nless programmer time to write the code.\r\n\r\nWe will begin by studying the form of general recursive functions; then apply\r\nthis form to functions operating on int values, and then apply this form to\r\nfunctions operating on strings and lists. In all these cases, we will discuss\r\nhow values of these types are recursively defined and discuss the natual\r\n\"sizes\" of the problem solved.\r\n\r\nTo start, suppose that we have the problem of collecting $1,000.00 for charity,\r\nwith the assumption that when asked, everyone is willing to chip in the\r\nsmallest amount of money: a penny.\r\n\r\nIterative solution : visit 100,000 people, and ask each for a penny\r\n\r\nRecursive solution:  if you are asked for a penny, give a penny to this person\r\n                     otherwise\r\n                        visit 10 people and ask them each to collect 1/10 the\r\n                          amount that you are asked to raise;\r\n                        collect the money they give you into one bag;\r\n                        give this bag to the person who asked you for the money\r\n\r\nIn the iterative version each subproblem is the same; raising a penny. In the\r\nrecursive solution, subproblems get smaller and smaller until they reach the\r\nproblem of collecting a penny (they cannot get any smaller: this problem has the\r\nsmallest size because there is no smaller currency).\r\n\r\nThe general form of a directly recursive function is\r\n\r\ndef Solve(Problem):\r\n  if (Problem is minimal/not decomposable into a smaller problem: a base case)\r\n    Solve Problem directly and return solution; i.e., without recursion\r\n  else:\r\n    (1) Decompose Problem into one or more SIMILAR, STRICTLY SMALLER\r\n        subproblems: SP1, SP2, ... , SPn\r\n\r\n    (2) Recursively call Solve (this function) on each SMALLER SUBPROBLEM\r\n        (since they are all SIMILAR): Solve(SP1), Solve(SP2),..., Solve(SPN)\r\n\r\n    (3) Combine the returned solutions to these smaller subproblems into a\r\n        solution that solves the original, larger Problem (the one this\r\n        original function call must solve)\r\n  \r\n    (4) Return the solution to the original Problem\r\n\r\nFormulate your base cases correctly. DO NOT use try/except to compensate for\r\nomitted or incorrectly written base cases.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSimple Recursion in Python:\r\n\r\nWe will start by examining a recursive definition for the factorial function\r\n(e.g., 5! reads as \"five factorial\") and then a recursive function that\r\nimplements it. The definition is recursive because we define how to compute a\r\nbig factorial in terms of how to compute a smaller factorial. Note that the\r\ndomain of the factorial function is the non-negative integers (also called the\r\nnatural numbers), so 0 is the smallest number on which we can compute factorial.\r\n\r\n   0! = 1         the smallest value we can compute ! of\r\n   N! = N*(N-1)!  for all N>0; recursive: we define ! in terms of a smaller !\r\n\r\nBy this definition (and just substitution of equals for equals) we see that\r\n\r\n  5! = 5*4! = 5*4*3! = 5*4*3*2! = 5*4*3*2*1! = 5*4*3*2*1*0! = 5*4*3*2*1*1\r\n\r\nWe have eliminated all occurrences of !, so we can use just * to compute it:\r\n5! = 5*4*3*2*1*1 = 120.\r\n\r\nThe first definition below is a transliteration of the general code above,\r\ndecomposing it into just one similar (factorial) but simpler (n-1) subproblem.\r\n\r\ndef factorial (n):\r\n  if n == 0:\r\n    return 1\r\n  else:\r\n    sp1        = n-1                    # Decompose problem n into 1 subproblem\r\n    solved_sp1 = factorial(sp1)         # Recursive call to Solve subproblem\r\n    solved_n   = n*solved_sp1           # Solve problem n with solved subproblem\r\n    return solved_n                     # Return solution\r\n\r\nThe next definition is a simplification of how this function should really be\r\nwritten in Python, without all the intermediate names/steps, which are not\r\nneeded and don't really add any clarity.\r\n\r\ndef factorial (n):\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n        return n*factorial(n-1)\r\n\r\nThis definition looks clean and closely mirrors the recursive mathematical\r\ndescription of  factorial. In fact, because of the simplicity of this\r\nparticular recursive function, we can write an even simpler solution using a\r\nconditional expression; but I prefer the solution above, because it is more\r\nrepresentative of other recursive solutions (to more complicated problems).\r\n\r\ndef factorial (n):\r\n    return (1 if n == 0 else n*factorial(n-1))\r\n\r\nWe can contrast the recursive code with the iterative code that implements the\r\nfactorial function\r\n\r\nfrom goody import irange\r\ndef factorial (n):\r\n    answer = 1;\r\n    for i in irange(2,n)\r\n        answer *= i\r\n    return answer\r\n\r\nNote that the iterative function defines two local names (answer and i) and\r\nbinds 1 to answer and rebinds it to a new value during each execution of the\r\nfor loop's body. Likewise, i is rebound to a sequence of values produced when\r\nthe function iterates over the irange(2,n). The recursive function defines no\r\nlocal names and doesn't rebind any names (although each recursive call binds an\r\nargument to the parameter in the new recursive function call).\r\n\r\nRebinding the values of names make it hard for us to think about the meaning of\r\ncode (they make it tougher to prove that the code is correct too), and makes it\r\nhard for multi-core processors to coordinate in solving a problem. \"Functional\r\nprogramming languages\" (those that allow binding of a name to computed value,\r\nbut no rebinding to that names) are more amenable to be automatically\r\nparallelizable (can run more quickly on multi-core computers). You'll see more\r\nabout this in later classes at UCI (e.g., Concepts of Programming Languages).\r\n\r\nWe can mimic factorial's recursive definition for a function that raises a\r\nnumber to an integer power. Note that the domain of n for this power function\r\nagain requires n to be a natural number (a non-negative integer).\r\n\r\n  A**0 = 1             (yes, this is even true when A=0)\r\n  A**N = A * A**(N-1)  for all N>0\r\n\r\nSo A**4 = A * A**3 = A*A * A**2 = A*A*A * A**1 = A*A*A*A * A**0 = A*A*A*A*1\r\n\r\nWe can likewise translate this definition into a simple recursive Python\r\nfunction\r\n\r\ndef power(a,n):\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n        return a*power(a,n-1)\r\n\r\nBy this definition (and just substitution of equals for equals) we see that\r\ncalling power(a,n) requires n multiplications.\r\n\r\n   power(a,3) = a*power(a,2) = a*a*power(a,1) = a*a*a*power(a,0) = a*a*a*1\r\n\r\nOf course we could write this code iteratively as follows, which also requires\r\nn (the same number of) multiplications\r\n\r\ndef power(a,n):\r\n    answer = 1\r\n    for i in irange(1,n):\r\n        answer *= a\r\n    return answer\r\n\r\nBut there is a another way to compute power(a,n) recursively, shown below. This\r\nlonger function requires between Log2 n and 2*Log2 n multiplications. Here Log2\r\nmeans the log function using a base of 2. Note Log2 1000 is about 10 (2**10 =\r\n1,024), and Log2 1,000,000 is about 20, and Log2 1,000,000,000 is about 30): so,\r\nto compute power(a,1000) requires between 10 and 20 multiplications (not the\r\n1,000 multiplcations required by the earlier definitions of power); to compute\r\na to the billionth power would require at most 60 multiplcations.\r\n\r\nThe key fact we use to reduce the number of multiplications in this function is\r\nthat if we need to compute a**100, and we have computed temp = a**50, all we\r\nneed to compute a**100 is one more multiplication: temp*temp, because (a**50)**2\r\n= a**100.\r\n\r\ndef power(a,n):\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n       if n%2 == 1:               # n is odd  (if n remainder 2 == 1)\r\n           return a*power(a,n-1)  \r\n       else:                      # n is even (if n remainder 2 == 0)\r\n           temp = power(a,n//2)   #   n is divided by 2 perfectly: no remainder\r\n           return temp*temp\r\n\r\nHere we use a local variable temp, but we bind temp only ONCE (we never rebind\r\nit) and then use its value, which is fine for functional programming. We could\r\nget rid of the local name temp completely by defining the local function\r\ndef square(n): n*n inside power and then calling it in the else clause: return\r\nsquare( power(a,n//2) ).\r\n\r\ndef power(a,n):\r\n    def square(n):\r\n        return n*n\r\n\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n       if n%2 == 1:\r\n           return a*power(a,n-1)\r\n       else:\r\n           return square( power(a,n//2) )\r\n\r\n\r\nFor one example\r\n    power(a,16) computes power(a,8) and returns its result with 1 more\r\n    multiplication; power(a,8) computes power(a,4) and returns its result with\r\n    1 more multiplication; power(a,4) computes power(a,2) and returns its\r\n    result with 1 more multiplication; power(a,2) computes power(a,1) and\r\n    returns its result with 1 more multiplication; power(a,1) computes\r\n    a*power(a,0), which requires 1 multiplication: computing power(a,0)\r\n    requires 0 multiplications (it just retuns the value 1).\r\n\r\n    In all, power(a,16) requires just 5 multiplications, not 16. Note that this\r\n    function is efficient, but it is NOT guaranteed to always use the MINIMUM\r\n    number of multiplications. Power(a,15) uses 6  multiplication, but by\r\n    computing x3 = x*x*x then x3*(square(square(x3))) requires only 5: see the\r\n    topic named \"addition-chain exponentiation\" if you are interested in what is\r\n    known about the minimimal number of multiplications required for\r\n    exponentiation. No simple algorithms solves this problem in the minmum\r\n    number of multiplications. But, the algorithm above does an excellent job.\r\n\r\nWe will prove that this function computes the correct answer later in this\r\nlecture. Truth be told, we can write a fast power function like this\r\niteratively too, but it looks much more complicated and is much more\r\ncomplicated to understand and analyze its behavior and prove that it is correct.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHand Simulation\r\n\r\nNext, we will learn how to hand-simulate a recursive functions using a \"tower of\r\ncall frames\" in which each resident in an apartment executes the same code\r\n(acting as the function definition) to compute a factorial: he/she is called by\r\nthe resident above and calls the resident underneath, when a recursive call is\r\nneeded (calling back the resident above when their answer is computed).\r\n\r\nWhile it is useful to be able to hand-simulate a recursive call, to better\r\nunderstand recursion, hand-simulation is not a good way to understand or debug\r\nrecursive functions (the 3 proof rules discussed below are a better way). I\r\nwill do this hand simulation on the document camera in class, using the\r\nfollowing form for computing factorial(5).\r\n\r\n(call frames are defined/used more technically in ICS-51, and in CS 141/142)\r\n\r\n\r\n       Factorial Towers\r\n       +---------------------------+\r\n       |   n int    return value   |\r\n       | +------+  +------------+  |\r\n       | |      |  |            |  |\r\n       | +------+  +------------+  |\r\n-------+---------------------------+--------\r\n       |   n int    return value   |\r\n       | +------+  +------------+  |\r\n       | |      |  |            |  |\r\n       | +------+  +------------+  |\r\n       +---------------------------+\r\n       |   n int    return value   |\r\n       | +------+  +------------+  |\r\n       | |      |  |            |  |\r\n       | +------+  +------------+  |\r\n       +---------------------------+\r\n       |   n int    return value   |\r\n       | +------+  +------------+  |\r\n       | |      |  |            |  |\r\n       | +------+  +------------+  |\r\n       +---------------------------+\r\n       |   n int    return value   |\r\n       | +------+  +------------+  |\r\n       | |      |  |            |  |\r\n       | +------+  +------------+  |\r\n       +---------------------------+\r\n       |   n int    return value   |\r\n       | +------+  +------------+  |\r\n       | |      |  |            |  |\r\n       | +------+  +------------+  |\r\n       +---------------------------+\r\n     \r\n                 ....\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProof Rules for Recursive Functions\r\n\r\nNow, we will learn how to VERIFY that recursive functions are correct by three\r\nproof rules. Even more important than proving that EXISTING functions are\r\ncorrect (to better understand them), we will use these same three proof rules\r\nto guide us when we SYNTHESIZE new recursive functions.\r\n\r\nNote that in direct recursion, we say that the function \"recurs\", not that it\r\n\"recurses\". Recurses describes what happens when you hit your thumb with a\r\nhammer the second time. I was taught that programmers who use the words\r\n\"recurse\" or \"recurses\" are not well-spoken.\r\n\r\nThe three proof rules should be simple to apply in most cases. These rules\r\nmirror rules for proofs by induction in mathematics. Recursion (thinking about\r\nsmaller and smaller problems) and induction (thinking about bigger and bigger\r\nproblems) are two sides of the same coin.\r\n\r\n(1) Prove that the base case (smallest) problem is processed correctly: the \r\n    function RECOGNIZES the base case and then RETURNS THE CORRECT RESULT\r\n    without a recursive call.\r\n\r\n    This proof should be easy, because base cases are small and simple to\r\n    recognize; once a base case is known, its solution (for that one value) is\r\n    easy to state.\r\n\r\n(2) Prove that each recursive call is on a STRICTLY SMALLER-SIZED PROBLEM: the\r\n    problem gets closer to the base case.\r\n\r\n    This proof should be easy because we can locate each recursive call by\r\n    inspecting the function's body. Also, there are \"standard\" ways to recur:\r\n    for ints, decrease by 1 or a factor of 10 (i.e., x//10 -using // (known as\r\n    Floor or Truncating division- has one fewer digit that x); Strings, tuples,\r\n    and lists recur on slices (e.g., x[1:] has fewer characters or values).\r\n\r\n(3) ASSUMING ALL RECURSIVE CALLS SOLVE THEIR SMALLER SUBPROBLEMS CORRECTLY,\r\n    prove that the code combines these solved subproblems correctly, to solve\r\n    the original Problem (the original parameter of the original function call).\r\n\r\n    This proof should be easy, because we get to ASSUME something very important\r\n    and  powerful: all subproblems are solved correctly.\r\n\r\nHere is a proof, using these 3 rules, that the factorial function is correct:\r\n\r\n1) The base case is 0; and according to the recursive mathematical definition,\r\n0! = 1. This function recognizes an argument/parameter of 0 in the if statement\r\nand returns the correct value 1 as the result.\r\n\r\n2) If n is a non-negative number that is not 0 (not the base case), then this\r\nfunction makes one recursive call: n-1 is a smaller-sized problem, closer to 0\r\n(the base case) than n is. It is closer by 1: the distance between n-1 and 0 is\r\n1 less than the distance between n and 0.\r\n\r\n3) ASSUMING factorial(n-1) COMPUTES (n-1)! CORRECTLY, this function returns\r\nn*factorial(n-1), which is n*(n-1)! by our assumption, which according to the\r\nmathematical definition is the correct answer for n!, the parameter to the\r\nfunction call.\r\n\r\nNotice that the focus of the proof is on ONE call of the function (not like the\r\nhand simulation method above, which looked at all the recursive calls). That is,\r\nwe look at what happens in two situations: the argument/parameter is a base\r\ncase (rule 1 above); the argument/parameter is not the base case and the\r\nfunctions recurs (rule 2-3 above). For the recursive case, we don't worry about\r\nmore recursive calls, because we get to ASSUME that any further recursive calls\r\n(on smaller problems, which might be the base case or at least closer to the\r\nbase cases) compute the correct answer WITHOUT HAVING TO THINK about how that\r\nhappens during any of the recursive calls. When proving recursive functions\r\ncorrect, DO NOT think about what happens when the function is called recursively\r\nlater, just assume in produces the correct answer.\r\n\r\nProof that fast-power function is correct (the code is duplicated from above):\r\n\r\ndef power(a,n):\r\n    def square(n): n*n\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n       if n%2 == 1:\r\n           return a*power(a,n-1)\r\n       else:\r\n           return square( power(a,n//2) )\r\n\r\n1) The base case is 0; and according to the recursive mathematical definition,\r\na**0 = 1. This function recognizes an argument of 0 if the if statement and\r\nreturns the correct value 1 for it.\r\n\r\n2) If n is a non-negative number that is not 0 (not the base case), then if\r\nn is odd, n-1 is a smaller-sized problem: closer to 0 (the base case) than n\r\nis; if n is even (it must be >= 2), n//2 is also a smaller-sized problem:\r\ncloser to 0 (the base case) than n is (2//2 is 1, 4//2 is 2, 6//2 is 3, etc).\r\nFor large n, n//2 is much closer to the base case than n-1, which is what gives\r\nthis method its speed.\r\n\r\n3) ASSUMING power(a,n-1) COMPUTES a**(n-1) CORRECTLY AND power(a,n//2) COMPUTES\r\na**(n//2) CORRECTLY. We know that any n must be either odd or even: if n is odd,\r\nthis function returns a*power(n-1), which is a*a**(n-1), so it returns (by\r\nsimplifying) a**n, which is the correct answer for the parameters to this\r\nfunction; likewise, if n is even, this function returns the value\r\nsquare( power(a,n//2) ), which is square(a**(n//2)), which returns (by\r\nsimplifying) a**n, which is the correct answer for the parameters to this\r\nfunction. For all even numbers n, n//2 is half that value, with no truncation:\r\nfor example, for n the even number 10, square (a**(10//2)) = square (a**5) =\r\n(a**5)**2 = a**10.\r\n\r\nAgain, the focus of the proof is on ONE CALL of the function: the parts concern\r\nonly the base case and the recursive case (which itself is now two cases,\r\ndepending on whether or not n is odd or even): and for the recursive cases, we\r\ndon't worry about what happens in other recursive calls, because we get to\r\nassume that any recursive calls (on smaller problems, closer to the base cases)\r\ncompute the correct answer; we DO NOT have to think about what happens during\r\nthe later recursion.\r\n\r\n\r\nThe Three Proof Rules are Necessary:\r\n\r\nWhat happens if we write factorial incorrectly? Will the proof rules fail. Yes,\r\nfor any flawed definitions one will fail. Here are three examples (one failure\r\nfor each proof rule).\r\n\r\ndef factorial (n):\r\n    if n == 0:\r\n        return 0\t\t\t# 0! returns 0, not 1\r\n    else:\r\n        return n*factorial(n-1)\r\n\r\nThis factorial function violates the first proof rule. It returns 0 for the\r\nbase case; since everything is multiplied by the base case, ultimately this\r\nfunction always returns 0. Bar bet: you name the year and the baseball team,\r\nand I will tell you the product of all the final scores (last inning) for all\r\nthe games they played that year. How do I do it and why don't I make this kind\r\nof bet on basketball teams?\r\n\r\ndef factorial (n):\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n        return factorial(n+1)//(n+1)    # n+1 not closer to base case: 0\r\n\r\nThis factorial function violates the second proof rule. It recurs on n+1, which\r\nis a bigger-sized problem: farther away from -not closer to- the base case.\r\nAlthough mathematically (n+1)!//(n+1) = (n+1)*n!//(n+1) = n! this function will\r\ncontinue calling factorial with ever-larger arguments: a runaway (or infinite)\r\nrecursion. Actually, each recursive call takes up some space (to store its\r\nargument, see the hand simulation, which requires binding an argument for each\r\nrecursive call), so eventually memory will be exhausted and Python will raise\r\nan exception. \r\n\r\nIn fact, there is a recursion limit in Python (we can set it to anything we\r\nwant), such that if a recursive function does more than that number of \r\nrecursive calls,Python raises the RecursionError exception, with the associated\r\nstring \"maximum recursion depth exceeded\". We can examine/set the recursion\r\nlimit by importing the sys module and the calling the sys.getrecursionlimit() or\r\nsys.setrecursionlimit(some number) functions.\r\n\r\ndef factorial (n):\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n        return n+factorial(n-1)         # Notice the plus: n+(n-1)! is not n!\r\n\r\nThis factorial function violates the third proof rule. Even if we assume that\r\nfactorial(n-1) computes the correct answer, this function returns n added (not\r\nmultiplied) by that value, so it does not return the correct answer. In fact,\r\nit returns one more than the sum of all the integer from 1 to n (because for 0\r\nit returns 1) not the product of these numbers.\r\n\r\nIn summary, each of these functions violates a proof rule and therefore doesn't\r\nalways return the correct value. The first function always returns the wrong\r\nvalue; the second function returns the correct value, but only for the the base\r\ncase; it never returns a value for any other argument; the third function\r\nreturns the correct value, but only for the the base case.\r\n\r\n----------\r\nInterlude: Proving the Proof Rules Prove a Recursive Function is Correct\r\n\r\nWe can actually prove that these proof rules are correct! Here is the proof.\r\nThis is not simple to understand -unless you have thought a lot about\r\nrecursion- but it is short so I will write the proof here and let you think\r\nabout it (and reread it a dozen times, maybe later in the quarter :). The proof\r\nform (a proof by contradiction) should be familiar to ICS 6B/6D students.\r\n\r\nAssume that we have in fact proven that these three proof rules are correct for\r\nsome recursive funtion f. And assume that we assert that the function is not\r\ncorrect. We will show that these two assertions lead to a contradiction.\r\n\r\n0) If f is not correct, then there must be some problems that it does not\r\ncorrectly solve. And, if there are any problems that f does not solve correctly,\r\nthere must be a SMALLEST problem that it does not solve correctly: call this\r\nsmallest problem p.\r\n\r\n1) Because of proof rule (1) we know that p cannot be the base case, because we\r\nhave proven f recognizes and solves the base case correctly.\r\n\r\n2) So, f must solve p by calling itself recursively.\r\n\r\n3) Since f solves p by calling itself recursively, the recursive call(s) is/are\r\non problem(s) SMALLER THAN p: we know this by proof rule (2) which states that f\r\nalways recurs on a STRICTLY SMALLER problem size.\r\n\r\n4) We know that f correctly solves this/these smaller problem(s), because p, BY\r\nDEFINITION, is the SMALLEST PROBLEM THAT f SOLVES INCORRECTLY. So it must solve\r\nthe recursive call(s) on the smaller problem(s) correctly.\r\n\r\n5) We also know by proof (3) that assuming f solves all problems smaller than p\r\n(which it does, because p is the SMALLEST PROBLEM F DOES NOT SOLVE CORRECTLY),\r\nthen f will use these solutions of smaller problems to solve the bigger problem\r\np correctly. So, f must solve p correctly, contradicting our assumption.\r\n\r\nTherefore, we have a contradiction. If we have proven a function correct by the\r\nthree proof rules, it is impossible to find a smallest problem that f\r\nincorrectly solves; so, f must solve all problems correctly.\r\n\r\nWell, that is how the proof goes. If we assume that we have proven the 3 proof\r\nrules and that the function is incorrect, we are lead to a contradiction. So,\r\neither we haven't proven the 3 proof rules (we made some mistake in our proof)\r\nor the function is not incorrect (yes, a double negative, so it is correct).\r\n----------\r\n\r\n------------------------------------------------------------------------------\r\n\r\nMathematics Recursively \r\n(we will skip this section; you might be interested in reading it)\r\n\r\nWe can construct all the mathematical and relational operators on natural\r\nnumbers (integers >= 0) given just three functions and if/recursion. We can\r\nrecursively define the natural numbers as:\r\n\r\n   0 is the smallest natural number\r\n   for any natural number n, s(n) (the successor of n: n+1) is a natural number\r\n\r\nNow we define three simple functions z(ero), p(redecessor), and s(uccessor).\r\n\r\ndef z(n):\t\t# z(n) returns whether or not n is 0\r\n    return n == 0\r\n\r\ndef s(n):\t\t# s(n) returns the successor to n: n+1\r\n    return n+1\r\n\r\ndef p(n):\t\t# p(n) returns the predecessor of n, if one exists!\r\n    if not z(n):\t# 0 has no predecessor\r\n        return n-1\r\n    else:\r\n        raise ValueError('p: cannot compute predecessor of 0')\r\n\r\nNote we should be able to prove/argue/understand the following:\r\n\r\nz(s(n)) is always False\r\np(s(n)) is always n\r\ns(p(n)) is n if n != 0 (otherwise calling p(n) first raises an exception)\r\n\r\nGiven these functions, we can define functions for all arithmetic (+ - * // **)\r\nand relational ( == <... and all the other relational) operators. For example\r\n\r\ndef sum(a,b):  \t    \t     \t     \t# a+b\r\n    if z(a):\t\t\t\t# a == 0\r\n        return b\t\t\t#   return b: 0 + b = b\r\n    else:      \t\t\t\t# a != 0\r\n        returns sum( p(a), s(b) )\t#   return (a-1)+(b+1) = a+b\r\n\r\nProof of correctness\r\n\r\n1) The base case is a==0; and according to our knowledge of of mathematics,\r\nsum(0,b) is 0+b which is b. This function returns b when the argument a == 0.\r\n\r\n2) If z(a) is not True (a is not 0), then p(a) as the first agument in the\r\nrecursive call to sum is closer to the base case of 0. Becaue a is not 0, there\r\nis a predecessor of (a number one smaller than) a.\r\n\r\n3) Assuming that sum(p(a),s(b)) computes its sum correctly, we have\r\nsum(p(a),s(b)) = sum(p(a),s(b)) = (a-1)+(b+1) = a + b, so returning this result\r\ncorrectly returns the sum of a and b.\r\n\r\nAnother way to define this function is\r\n\r\ndef sum(a,b):\r\n    if z(a):\t\t\t\t# a == 0\r\n        return b\t\t\t#   return b: 0 + b = b\r\n    else:      \t\t\t\t# a != 0\r\n        returns s( sum( p(a), b) )\t#   return (a-1)+(b) + 1 = a+b\r\n\r\nWe can also use the 3 proof rule to prove this function correctly computes the\r\nsum of any two non-negative integers. Here it applies s(..smaller sum...)\r\ninstead of decreasing one argument while incresasing the other.\r\n\r\nGiven either definition of the sum function, we can similarly define the mult\r\nfunction, multiplying by repeated addition.\r\n\r\ndef mult(a,b):\r\n    if z(a):\t\t\t\t# a = 0\r\n        return 0\t\t\t#   return 0: 0*b = 0\r\n    else:      \t\t\t\t# a != 0\r\n        return sum(b, mult(p(a),b))     #   return b+((a-1)*b) = b+a*b-b = a*b\r\n\r\nSwitching from arithmetic to relational operators....\r\n\r\ndef equal(a,b):\r\n    if z(a) or z(b):\t\t# a = 0 or b = 0 (either == 0)\r\n        return z(a) and z(b)\t#   return True(if both ==0), False (if one !=0)\r\n    else:      \t\t\t# a != 0 and b != 0 (neither ==0); can recur\r\n        return equal(p(a),p(b))\t#   return a-1==b-1 which is the same as a==b\r\n\r\ndef less_than(a,b):\r\n    if z(a) or z(b):\t\t    # a = 0 or b = 0 (either == 0)\r\n        return z(a) and not z(b)    #   return True only when a==0 and b!=0\r\n    else:      \t\t \t    # a != 0 and b != 0 (neither ==0) can recur\r\n        return less_then(p(a),p(b)) #   return a-1 < b-1, same as a < b\r\n\r\nWe also might find it useful to do a hand simulation of these functions, with\r\nthe two parameters a and b stored in each \"apartment\" and passed as arguments.\r\n \r\nThe right way to illustrate all this mathematics is to write a class Natural,\r\nwith these methods, and then overload/define __add__ etc. for all the operators.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSynthesizing recursive string methods\r\n\r\nWe can define strings recursively:\r\n  '' is the smallest string (empty string; string whose len == 0)\r\n  a character concatenated to the front of any string is a (bigger) string\r\n\r\nLet's use these proof rules to write a reciple for synthesizing (and therefore\r\nproving correct as we are writing them) a few recursive functions that process\r\nstrings. Here is our approach:\r\n\r\n(1) Find the base (non-decomposable) case(s) and solve them\r\n    Write code that detects the base case and returns the correct answer for it,\r\n      without using recursion\r\n\r\n(2) Assume that we can decompose all non base-case problems and then solve\r\n      these smaller subproblems via recursion\r\n    Choose (requires some ingenuity) the decomposition; it should be \"natural\"\r\n\r\n(3) Write code that combines these solved subproblems (often there is just one)\r\n       to solve the problem specified by the parameter\r\n\r\nWe can use these rules to synthesize a method that reverses a string. We start\r\nwith\r\n\r\ndef reverse(s):\r\n\r\n(1) Please take time to think about the base case: the smallest string. Most\r\nstudents will think that a single-character string is the smallest, when in\r\nfact a zero-character string (the empty string) is smallest. It has been my\r\nexperience that more students screw-up on the base case than the recursive case.\r\nOnce we know the smallest string is the empty string, we need to detect it and\r\nreturn the correct result without recursion: the reverse of an empty string is\r\nan empty string.\r\n\r\ndef reverse(s):\r\n    if s == '':\t\t# or len(s) == 0\r\n        return ''       # obvious reversal of empty string\r\n    else:\r\n        Recur to solve a smaller problem\r\n        Use the solution of the smaller problem to solve the original problem: s\r\n\r\nWe can guess the form of the recursion as reverse(s[1:]) noting that the slice\r\ns[1:] computes a string with all characters but the one at index 0: all the\r\ncharacters after the first. We are guaranteed to be slicing only non-empty\r\nstrings (those whose answer is not computed by the base case), so slicing will\r\nalways be a smaller string: smaller by one character. We get to assume that the\r\nrecursive call correctly returns the reverse of the string that contains all\r\ncharacters but the first.\r\n\r\ndef reverse(s):\r\n    if s == '':\t\t# or len(s) == 0\r\n        return ''\r\n    else:\r\n        Use the solution of reverse(s[1:]) to solve the original problem: s\r\n\r\nNow, think concretely, using an example. if we called reverse('abcd') we get to\r\nassume that the recursive call works: so reverse(s[1:]) is reverse('bcd') which\r\nwe get to assume returns 'dcb'). How do we use the solution of this subproblem\r\nto solve the original problem, which we know must return 'dcba'? We need to\r\nconcatenate 'a' (the first character, at s[0], not included in the recursive\r\ncall) to the end of the reverse of all the other characters: 'dcb' + 'a', which\r\nevaluates to  'dbca', the reverse of all the characters in the parameter string.\r\nGenerally we write this function as\r\n\r\ndef reverse(s):\r\n    if s == '':\t\t# or len(s) == 0\r\n        return ''\r\n    else\r\n        return reverse(s[1:]) + s[0]\r\n\r\nWe know the result has the first letter of s at the end of the reversal of all\r\nits other characters.\r\n\r\nWe have now written this method by ensuring the three proof rules are satisfied\r\nso we dont' have to prove them, but note that \r\n\r\n(1) the reverse of the smallest string (empty) is computed/returned correctly\r\n\r\n(2) the recursive call is on a string argument smaller than s\r\n    (all the characters from index 1 to the end, skipping the character at\r\n    index 0, and therefore a string with one fewer characters)\r\n\r\n(3) ASSUMING THE RECURSIVE CALL RETURNS THE CORRECT ANSWER FOR THE SMALLER\r\n    STRING, then by concatenating the first character after the end of the\r\n    solution to the smaller problem, we have correctly reversed the entire\r\n    string (solving the problem for the original parameter).\r\n\r\nIn fact, we can use a conditional expression to rewrite this code as a single\r\nline as well.\r\n\r\ndef reverse(s):\r\n    return ('' if s == '' else reverse(s[1:]) + s[0])\r\n\r\nHere is a similar recursive function for reversing the values in a list.\r\n\r\ndef reverse(l):\r\n    if l == []:\t\t\t\t# or len(l) == 0\r\n        return [];\r\n    else\r\n        return reverse(l[1:]) + [l[0]]  # [l[0]] for right operand of + (a list)\r\n\r\nNow we will write a recursive function that returns the string equivalent of an\r\nint using the same approach: satisfying the three proof rules. We know that\r\nPython's str function, automatically imported from the builtins module) will\r\ncall int.__str__ which returns the string representation of an int. We can\r\nactually now write this function recursively ourselves, and at the same time\r\nprove it is correct. \r\n\r\nTo start, we assume that the integer is non-negative (it simplifies the\r\nrecursive code and we will add code to remove this assumption later). Unlike\r\nthe factorial and power functions, here the size of the integer will be the\r\nnumber of digits it contains: the smallest non-negative integers (0-9) contain\r\n1 digit, so that is the smallest size problem. So, we start with the header and\r\nbase case.\r\n\r\ndef to_str(n):\r\n    if 0 <= n <= 9:\t\t\t\t# 1 digit (no 0 digit numbers)\r\n        return '0123456789'[n]\t\t\t#   0<=n<=9, so no index error\r\n    else:\r\n        Recur to solve smaller problem(s)       # n has at least two digits\r\n        Use the solution of the smaller problem(s) to solve the original\r\n          problem: n\r\n\r\nWe can guess the form of the recursion as to_str(n//10) and to_str(n%10)\r\nbecause n//10 is all but the last digit in n, and n%10 is the last digit. If\r\nn has at least d digits (where d>=2), then both n//10 and n%10 will have fewer\r\ndigits: n//10 has d-1 digits and n%10 has 1 digit. \r\n\r\nWe get to assume that the recursive call correctly returns the string\r\nrepresentation of these numbers.\r\n\r\ndef to_str(n):\r\n    if 0 <= n <= 9:\t\t\t\t# 1 digit (no 0 digit numbers)\r\n        return '0123456789'[n]\t\t\t# 0<=n<=9, so no index error\r\n    else:\r\n        Use the solution of to_str(n//10) and to_str(n%10) to solve to_str(n)\r\n\r\nNow, think about a concrete example. if we called to_str(135) we get to assume\r\nthat the recursive calls work: so to_str(n//10) is to_str(13) which we get to\r\nassume it returns '13'; and to_str(n%10) is to_str(5) which we get to assume\r\nreturns '5'. How do we use the solution of these subproblems to solve the\r\noriginal problem? We need to concatenate them togther: '13'+'5' = '135'.\r\nGenerally we write this function as\r\n\r\ndef to_str(n):\r\n    if 0 <= n <= 9:\t\t\t\t# 1 digit (no 0 digit numbers)\r\n        return '0123456789'[n]\t\t\t# 0<=n<=9, so no index error\r\n    else:\r\n        return to_str(n//10) + to_str(n%10)\r\n\r\nWe have now written this method by ensuring the three proof rules are\r\nsatisfied. Note that \r\n\r\n(1) the to_str of the smallest ints (1 digit) are computed/returned correctly\r\n\r\n(2) the two recursive calls are on int arguments that are smaller than n by at\r\n    least one digit (in fact the second call is always exactly 1 digit).\r\n\r\n(3) ASSUMING THE RECURSIVE CALLS WORK CORRECTLY FOR THE SMALLER ints, then\r\n    by concatenating the recursive calls on these two numbers together, we have\r\n    correctly found the string representation of n (solving the original\r\n    problem)\r\n\r\nWe make this function work for negative numbers by redefining to_str with\r\nits original code in a locally defined function, changing the body of this\r\nfunction by either appending nothing or a '-' in front of the answer, depending\r\non n.\r\n\r\ndef to_str(n):\r\n    def to_str_digits(n):                       # n >= 0 (see call with abs)\r\n        if 0 <= n <= 9:\t\t\t\t#   1 digit (no 0 digit numbers)\r\n            return '0123456789'[n]\t\t#     0<=n<=9, so no index error\r\n        else:\r\n            return to_str_digits(n//10) + to_str_digits(n%10)\r\n\r\n    return ('' if n >= 0 else '-') + to_str_digits(abs(n))\r\n    # or\r\n    #return (to_str_digits(n) if n >= 0 else '-'+to_str_digits(-n))\r\n\r\nIn fact, the following function uses the same technique (but generalizes it by\r\nconverting to an arbitrary base) to compute the string representation of a\r\nnumber in any base from binary up to hexadecimal: to_str(11,2) returns '1011';\r\nto_str(11,16) returns 'B'.\r\n\r\ndef to_str(n,base=10):                          # only bases 2 - 16 allowed\r\n    if 0 <= n <= base-1:\r\n        return '0123456789ABCDEF'[n]            # 0<=n<=15, so no index error\r\n    else:\r\n        return to_str(n//base,base) + to_str(n%base,base)\r\n\r\nFinally let's write a recursive method that has two parameters on which we will\r\nrecur. This example is similar to the equal method applied to two integers\r\ndefined in the Mathematics Recursively section above.\r\n\r\nSuppose we want to write a same_length function that tests whether the length\r\nof its two string parameters are equal, without ever explicitly computing the\r\nlength of each. With two recursive parameters we have 4 possible cases:\r\n\r\n                               Parameter 2\r\n                          Empty      Not empty\r\n                        +----------+----------+\r\n            Empty       | Equal    | Not equal|\r\nParameter 1             +----------+----------+\r\n            Not Empty   | Not Equal|   recur  |\r\n                        +----------+----------+\r\n\r\nIn three of the four (anything in which one or both parameters are empty), we\r\nimmediately can compute the answer without reecursion. If both parameters are\r\nempty then the strings have the same length; if one parameter is empty and one\r\nisn't, then the strings have different lengths. Only if both are not empty do\r\nwe need to recur to compute the correct answer.\r\n\r\nHere are four ways to write the base cases.\r\n\r\n1)  if s1 == '' and s2 == '':\r\n        return True\r\n    if s1 == '' and s2 != '':\r\n        return False\r\n    if s1 != '' and s2 == '':\r\n        return False;\r\n\r\n\r\n2)  if s1 == '':\r\n        return s2 == ''\r\n    if s2 == ''\r\n        return False\t\t\t      # if got here, s1!='' and s2==''\r\n\r\n\r\n3)  if s1 == '' or s2 == '':                  # if either is empty, ...\r\n        return s1 == '' and s2 == ''          # returns True if both empty\r\n\r\n\r\n4)  if s1 == '' or s2 == '':                  # if either is empty, ...\r\n        return s1 == s2                       # returns True if the same (empty)\r\n\r\nI like 3 the best; 4 is smallest but a bit harder to understand.\r\n\r\nSo we can start this function as\r\n\r\ndef same_length(s1,s2)    \r\n    if s1 == '' or s2 == '':\r\n        return s1 == '' and s2 == ''\r\n    else:\r\n        Recur to solve a smaller problem        # s1/s2 each are not empty\r\n        Use the solution of the smaller problem to solve the original problem\r\n\r\nNow, if Python executes the else: clause then it has two non-empty strings, for\r\neach of which we can compute a substring (all the characters after the first).\r\nIf the substrings have the same length, then the original strings have the same\r\nlength (each substring is a length one smaller); if the substrings don't have\r\nthe same length then the original strings don't have the same length. So,\r\nsolving this problem for the substrings is exactly the same as solving it for\r\nthe original strings. So we can write the recursive call as\r\n\r\ndef same_length(s1,s2):    \r\n    if s1 == '' or s2 == '':\r\n        return s1 == '' and s2 == ''\r\n    else:\r\n        return same_length(s1[1:],s2[1:])\r\n\r\nNote that if we compared the lengths of a huge string and a tiny one, we would\r\nfind that they are different in an amount of time proportional to the tiny\r\nstring. Generally, it recurs once for each character in the smallest  string.\r\nThis is an example of \"tail-recursion\", which we will study more in the next\r\nlecture on functional programming.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nRecursive list processing\r\n\r\nNow, here are some some simple recursive list processing functions. As with\r\nstrings, we can slice a list to get a smaller list, with the slice l[1:]\r\nespecially common and useful.\r\n\r\nWe can define lists recursively:\r\n  [] is a list\r\n  a value concatenated to the front of a list is a (bigger) list\r\n\r\nIf there were not len function for lists, we could easily define it recursively:\r\n\r\ndef len(l):\r\n    if l == []:\r\n        return 0\r\n    else:\r\n        return 1 + len(l[1:])\r\n\r\nCould you start from scratch and define this as illustrated above?\r\n\r\nLikewise for a sum function\r\n\r\ndef sum(l):\r\n    if l == []:\r\n        return 0\r\n    else:\r\n        return l[0] + sum(l[1:])\r\n\r\nBelow, the all_pred function returns True if and only if predicate p always\r\nreturns True (never returns False), when called on every value in the list.\r\n\r\ndef all_pred(l,p): # where p is some predicate whose domain includes l's values\r\n    if l == []:\r\n        return True\r\n    else:\r\n        return p(l[0]) and all_pred(l[1:],p)\r\n\r\nNote that because and is a short-circuit operator, it recurs only as far as the\r\nfirst False value, at which point it does not (need to) call all_pred(l[1:],p)\r\nrecursively. When we study efficiency, we will discover that the way Python\r\nrepresents lists (as growable arrays) make recursion very inefficient compared\r\nto iteration, but when we study linked list and trees (briefly this quarter,\r\nextensively in ICS-46) we will see that for those implementations, recursion is \r\nas fast as iteration (and the code can be much simplre to write).\r\n\r\nFinally, you might wonder why the base case, all_pred([],p) returns True. What\r\nshould the function return for an empty list? Well, imagine we are one call\r\nabove the empty list: a list with one value. What should all_pred([a],p)\r\nreturn. Well, it should return p(a) (True if p(a) is) True for this one-element\r\nlist; False if it is False). What does the recursive part of this function\r\nreturn:\r\n   p(a) and all_pred([],p).\r\nSo we need to solve the equation by determine what all_pred([],p) should be.\r\nWhen does\r\n\r\np(a)    ==    p(a) and all_pred([],p)\r\n\r\nTo solve this equation, and determine the value of all_pred([],p), we find that\r\nall_pred([],p) must be True: if it were False, p(a) and all_pred([],p) would be\r\nthe same as p(a) and False, which would always be False, not the required\r\nanswer of p(a). But p(a) and True has the same truth value as p(a).\r\n\r\nBased on this same logic, here are what based cases must be, categorized by\r\nthe operator before the recursive call.\r\n\r\nbase case = True  ...     for and recursive-call (as we saw in all)\r\nbase case = False ...     for or  recursive-call\r\nbase case = 0     ...     for +   recursive-call\r\nbase case = 1     ...     for *   recursive-call (as we saw in ! and **)\r\nbase case = -infinity ... for max(...,recursive_call)\r\nbase case = +infinity ... for min(...,recursive_call)\r\n\r\nGenerally, recursive-call(base case) must be the identity for the operator used.\r\n\r\nFinally, we can use recursion to sum all the values yielded by an iterator\r\nas follows. The only way to test if an iterator for being a base case (having\r\nno values left in it) is to try to call next on it to see if a value is\r\nproduced or if StopIteration is raised. In the code below, a base case is\r\ndetected by a call to next in a try block, raising the StopIteration exception;\r\nthe except block handles this base case by returning the correct value: 0.\r\n\r\ndef sum(iterator):\r\n    try:\r\n        x = next(iterator)\r\n        return x + sum(iterator)\r\n    except StopIteration:\r\n        return 0\r\n\r\nHere we assume the argument to sum is an iterator (not an iterable: we don't\r\ncall iter on the argument). So we can use this function as is to compute\r\nsum(iter(range(100))) or sum(primes(100)): the first calls iter explicitly to\r\nconvert the iterable range(100) into an iterator on the range; the second has\r\nthe argument primes(100) whose returned result (by calling this generator\r\nfunction), is an iterator. But calling sum(range(100) for this function would\r\nnot be correct.\r\n\r\nGiven that calling iter on something that already is an iterator returns that\r\nsame iterator (in Python classes, and in code that we wrote for __iter__ in \r\neach _iter class we wrote), we could write this code as \r\n\r\ndef sum(iter_x):           # it_x is iter...able or an iter...ator\r\n    i = iter(iter_x)       # returns just itter_x if it is already an iterator\r\n    try:\r\n        x = next(i)\r\n        return x + sum(i)\r\n    except StopIteration:\r\n        return 0\r\n\r\nNow the calls sum(iter(range(100))), sum(primes(100)), and even sum(range(100))\r\nall work correctly.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n1. Define a recursive function named is_odd using the functions z, p, and s\r\ndescribed in the lecture, which computes whether or not its argument is an odd\r\nvalue.\r\n\r\n2. Define a recursive function named remove, which takes string and a\r\n1-character string, and returns a string with the specified character removed:\r\nremove('afghanistanbananastand','a') returns 'fghnistnbnnstnd'.\r\n\r\n3. Define a recursive function named replace, which takes string and two\r\n1-character strings, and returns a string with the first specified character\r\nreplaced byh the second: remove('potpourri','o','O') returns 'pOtpOurri'.\r\n\r\n4. Define a recursive function named contains, which takes a list and a value as\r\narguments, and returns whether or not the value appears in the list.\r\n\r\n5. Define a recursive function named is_sorted, which takes a list as an\r\nargument, and returns whether or not the list of values is non-decreasing (each\r\nis >= to the value preceding it).\r\n\r\n6. Define the function equals(s1,s2), which computes whether two strings are ==\r\nwithout ever comparing more than 1-character strings.\r\n\r\n7. Write less_than(s1,s2) which computes whether s1 < s2 (where both are\r\nstrings) without ever comparing more than 1-character strings. The result\r\nshould be the same as using < (the standard Python comparision).\r\n\r\n8. Write a function named min_stamps that takes an amount as an argument and\r\nreturns the minimum number of stamps that you need to make that amount. Assume\r\ninside the function you would define denominations as a list with all the stamp\r\namounts: e.g., denominations = [1, 2, 5, 12, 16, 24]. With these denominations\r\nmin_stamps(19) returns 3 (denominations 1, 2, 16 or 2, 5, 12).\r\n\r\n", "encoding": "ascii"}