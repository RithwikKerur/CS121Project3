{"url": "https://www.ics.uci.edu/~thornton/ics142/LabManual/Assignment2/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course2.css\" type=\"text/css\" />\r\n\r\n<title>ICS 142 Winter 2004, Assignment #2</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 142 Winter 2004 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../LabManual\">Lab Manual</a> |\r\n<a href=\"news:ics.142\">ics.142 newsgroup</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 142 Winter 2004<br />\r\n   Assignment #2</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, February 6, 11:59pm</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>In the previous assignment, you were asked to implement a scanner for a hypothetical imperative-style programming language called Monkie2004.  After making some simplifications to the language (to keep this assignment from being too large), I would now like you to build a parser for Monkie2004.  Since the language has been changed, and since I would imagine that not everyone completed the scanner entirely and correctly, I will provide a compiled version of my scanner, which has been updated to reflect the changes made to the language since the first assignment, and which also includes some error-handling for situations like identifiers with pairs of adjacent underscores or integer literals that are too large.</p>\r\n\r\n<p>Remember that the primary job of the parser is twofold: verifying that the input program is syntactically correct and, in the case of a correct program, beginning to discern the meaning of the input program by discovering a parse tree for it.  It should be noted that a parser need not actually build and store a parse tree in memory; it just needs to discover the existence of one, then use that discovery to continue analyzing the input program.  In future assignments, we'll connect parsers to modules that perform further analysis on the input program, such as type checking, code generation, and optimization.</p>\r\n\r\n<p>For this assignment, I'm requiring you to build a hand-coded <i>recursive descent parser</i> in Java, following the pattern that we discussed in lecture.  I'll also require you to do some theoretical work that is necessary in order for you to build your parser correctly.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What is a recursive descent parser?</p>\r\n\r\n<p>A recursive descent parser is a parser that is constructed from a set of mutually recursive functions, each of which corresponds to one nonterminal symbol in a grammar.  For example, consider the following simple grammar G:</p>\r\n\r\n<ul class=\"nomarker\">\r\n  <li><i>S</i> &rarr; <b>a</b> <i>A</i> | <b>b</b> <i>B</i></li>\r\n  <li><i>A</i> &rarr; <b>b c</b> | <b>c</b> <i>B</i></li>\r\n  <li><i>B</i> &rarr; <b>c d</b> | <b>d</b> <i>A</i></li>\r\n</ul>\r\n\r\n<p>The heart of a recursive descent parser for the language of G would be three functions, one for each nonterminal.  Using only the next token of input, these functions decide which rule to expand by, then consume tokens and make calls to other functions as needed.  For the grammar above, the functions would be implemented according to the following pattern:</p>\r\n\r\n<table>\r\n  <tr>\r\n    <td><pre>\r\nparse_S():\r\n    if (next token is 'a')\r\n        // S -> aA\r\n        consumeToken('a')\r\n        parse_A()\r\n    else if (next token is 'b')\r\n        // S -> bB\r\n        consumeToken('b')\r\n        parse_B()\r\n    else\r\n        ERROR!\r\n    </pre></td>\r\n    <td><pre>\r\nparse_A():\r\n    if (next token is 'b')\r\n        // A -> bc\r\n        consumeToken('b')\r\n        consumeToken('c')\r\n    else if (next token is 'c')\r\n        // A -> cB\r\n        consumeToken('c')\r\n        parse_B()\r\n    else\r\n        ERROR!\r\n    </pre></td>\r\n    <td><pre>\r\nparse_B():\r\n    if (next token is 'c')\r\n        // B -> cd\r\n        consumeToken('c')\r\n        consumeToken('d')\r\n    else if (next token is 'd')\r\n        // B -> dA\r\n        consumeToken('d')\r\n        parse_A()\r\n    else\r\n        ERROR!\r\n    </pre></td>\r\n</table>\r\n\r\n<p>The presumption here is that the consumeToken( ) operation does two things:</p>\r\n\r\n<ol>\r\n  <li>Check whether the next token of the input is the desired token.  If not, signal an error.</li>\r\n  <li>Move to the next token of the input.</li>\r\n</ol>\r\n\r\n<p>Calling parse_S( ) and having it run to completion without signaling an error indicates the existence of a valid parse tree for the input program.  By including additional code within this framework, the parser can be upgraded to build a parse tree, an abstracted version of a parse tree called an <i>abstract syntax tree</i>, and/or a variety of other forms of output.  (A typical compiler will build one or more intermediate representations of the program during parsing, then pass them on to subsequent stages of the compiler.)</p>\r\n\r\n<p>Notice that this framework does not use backtracking.  Every time it needs to expand some nonterminal, it chooses one of the right-hand sides of that nonterminal's rules; the penalty for choosing a rule that does not correspond to the input is an error, which presumably stops the parser from proceeding.  Grammars that can be parsed using this technique are called <i>LL(1) grammars</i> or <i>predictive grammars</i>.  (The term LL(1) arises from the fact that such grammars can be parsed by doing a <b>L</b>eft-to-right scan of the input and building a <b>L</b>eftmost derivation, using at most <b>1</b> token of lookahead.)  Naturally, not all grammars can be parsed this way.  Here's one example:</p>\r\n\r\n<ul class=\"nomarker\">\r\n  <li><i>S</i> &rarr; <b>a</b> <i>A</i></li>\r\n  <li><i>A</i> &rarr; <i>A</i> <b>b</b> | <b>c</b></li>\r\n</ul>\r\n\r\n<p>This grammar is not LL(1), and thus cannot be parsed using a recursive descent parser, since it has <i>left recursion</i> in it.  Specifically, the rule <i>A</i> &rarr; <i>A</i> <b>b</b> can cause a recursive descent parser to go into infinite recursion, as the corresponding parse_A( ) routine might call parse_A( ) without consuming any input, then call parse_A( ) again without consuming input, and so on.  (Left recursion comes in two flavors: <i>immediate left recursion</i>, shown above, and <i>indirect left recursion</i>.  Techniques for eliminating both forms of left recursion were discussed in class and are discussed in the textbook.)</p>\r\n\r\n<p>Another problem that prevents a grammar from being LL(1) is demonstrated in this grammar:</p>\r\n\r\n<ul class=\"nomarker\">\r\n  <li><i>S</i> &rarr; <b>a</b> <b>b</b> <i>A</i> | <b>a</b> <b>c</b> <i>B</i></li>\r\n  <li><i>A</i> &rarr; <b>g</b> <i>A</i> | <b>g</b></li>\r\n  <li><i>B</i> &rarr; <b>f</b> <i>B</i> | <b>f</b></li>\r\n</ul>\r\n\r\n<p>The right-hand sides of the two rules for S both begin with an <b>a</b>, meaning that it will be impossible to choose one of the rules by looking at only the next token of input.  The solution to this problem is <i>left factoring</i>, which we discussed in lecture and is discussed in some detail in the textbook.</p>\r\n\r\n<p>Left recursion elimination and left factoring are not necessarily enough to make a grammar have the LL(1) property; some languages cannot be expressed with LL(1) grammars.  Fortunately, most programming language constructs can be expressed using LL(1) grammars, making them useful in parsers for programming languages.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The updated Monkie2004 language for this assignment</p>\r\n\r\n<p>Monkie2004 is a simple imperative-style language.  A Monkie2004 program is a sequence of global variable declarations, procedures, and functions.  The distinction between procedures and functions is the same as the distinction between a void method in Java and one that returns a value.  Each procedure and function consists of a signature (a name, a parameter list, and -- in the case of a function -- a return type), then a block statement, which is one or more statement surrounded by a matched pair of brackets (i.e. <b>'['</b> and <b>']'</b>).  There are a few kinds of statements in Monkie2004: local variable declarations, assignments, procedure calls, <b>if</b> statements, <b>while</b> loops, and block statements.</p>\r\n\r\n<p>A few of the keywords that were present in the scanner are no longer considered a part of the language: <b>and</b>, <b>call</b>, <b>implies</b>, <b>not</b>, <b>or</b>, <b>xor</b>.  Two new keywords, <b>true</b> and <b>false</b>, have been added.  The <b>&lt;=</b> and <b>&gt;=</b> operators have been removed, while an integer negation operator <b>~</b> (analogous to Java's unary minus) has been added.  Integer literals may no longer contain negative signs; instead, the integer negation operator should be used to specify negation, so the integer -3 is represented in Monkie2004 as <b>~3</b>.</p>\r\n\r\n<p>It should be noted that Monkie2004 is case-sensitive.  Keywords must appear in all lowercase, and the identifiers <b>result</b> and <b>Result</b> are considered different.</p>\r\n\r\n<p>What follows is an unambiguous, but not LL(1), grammar for Monkie2004.  Nonterminal symbols are indicated by capitalized, italicized words, such as <i>Program</i> or <i>BlockStatement</i>.  Terminal symbols are indicated by boldface words or symbols, such as <b>while</b> or <b>(</b>.  The start symbol for the grammar is <i>Program</i>.</p>\r\n\r\n<ul class=\"nomarker\">\r\n  <li><i>Program</i> &rarr; <i>DefinitionList</i></li>\r\n  <li><i>DefinitionList</i> &rarr; &epsilon; | <i>Definition</i> <i>DefinitionList</i></li>\r\n  <li><i>Definition</i> &rarr; <i>VariableDeclaration</i> | <i>Procedure</i> | <i>Function</i></li>\r\n  <li><i>VariableDeclaration</i> &rarr; <b>var</b> <i>TypeDeclaration</i> <b>;</b></li>\r\n  <li><i>TypeDeclaration</i> &rarr; <b>identifier</b> <b>:</b> <b>identifier</b></li>\r\n  <li><i>Procedure</i> &rarr; <b>procedure</b> <b>identifier</b> <b>(</b> <i>ParameterList</i> <b>)</b> <i>BlockStatement</i></li>\r\n  <li><i>Function</i> &rarr; <b>function</b> <b>identifier</b> <b>(</b> <i>ParameterList</i> <b>)</b> <b>:</b> <b>identifier</b> <i>BlockStatement</i></li>\r\n  <li><i>ParameterList</i> &rarr; &epsilon; | <i>NonEmptyParameterList</i></li>\r\n  <li><i>NonEmptyParameterList</i> &rarr; <i>Parameter</i> | <i>Parameter</i> <b>,</b> <i>NonEmptyParameterList</i></li>\r\n  <li><i>Parameter</i> &rarr; <i>TypeDeclaration</i> | <b>ref</b> <i>TypeDeclaration</i></li>\r\n  <li><i>BlockStatement</i> &rarr; <b>[</b> <i>StatementList</i> <b>]</b></li>\r\n  <li><i>StatementList</i> &rarr; &epsilon; | <i>Statement</i> <i>StatementList</i></li>\r\n  <li><i>Statement</i> &rarr; <i>VariableDeclaration</i> | <i>Call</i> | <i>Assignment</i> | <i>IfStatement</i> | <i>WhileLoop</i> | <i>BlockStatement</i></li>\r\n  <li><i>Call</i> &rarr; <b>identifier</b> <b>(</b> <i>ExpressionList</i> <b>)</b> <b>;</b></li>\r\n  <li><i>Assignment</i> &rarr; <b>identifier</b> <b>&lt;-</b> <i>Expression</i> <b>;</b></li>\r\n  <li><i>IfStatement</i> &rarr; <b>if</b> <i>Expression</i> <b>then</b> <i>BlockStatement</i> | <b>if</b> <i>Expression</i> <b>then</b> <i>BlockStatement</i> <b>else</b> <i>BlockStatement</i></li>\r\n  <li><i>WhileLoop</i> &rarr; <b>while</b> <i>Expression</i> <b>do</b> <i>BlockStatement</i></li>\r\n  <li><i>ExpressionList</i> &rarr; &epsilon; | <i>NonEmptyExpressionList</i></li>\r\n  <li><i>NonEmptyExpressionList</i> &rarr; <i>Expression</i> | <i>Expression</i> <b>,</b> <i>NonEmptyExpressionList</i></li>\r\n  <li><i>Expression</i> &rarr; <i>Expr2</i> <b>==</b> <i>Expr2</i> | <i>Expr2</i> <b>/=</b> <i>Expr2</i> | <i>Expr2</i> <b>&lt;</b> <i>Expr2</i> | <i>Expr2</i> <b>&gt;</b> <i>Expr2</i> | <i>Expr2</i></li>\r\n  <li><i>Expr2</i> &rarr; <i>Expr2</i> <b>+</b> <i>Expr3</i> | <i>Expr2</i> <b>-</b> <i>Expr3</i> | <i>Expr2</i> <b>&</b> <i>Expr3</i> | <i>Expr3</i></li>\r\n  <li><i>Expr3</i> &rarr; <i>Expr3</i> <b>*</b> <i>Expr4</i> | <i>Expr3</i> <b>/</b> <i>Expr4</i> | <i>Expr4</i></li>\r\n  <li><i>Expr4</i> &rarr; <b>~</b> <i>Expr4</i> | <b>(</b> <i>Expression</i> <b>)</b> | <b>identifier</b> | <b>identifier</b> <b>(</b> <i>ExpressionList</i> <b>)</b> | <b>integer_literal</b> | <b>string_literal</b> | <b>true</b> | <b>false</b></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Part 1: Correcting the provided Monkie2004 grammar (25 points)</p>\r\n\r\n<p>The first step in building a recursive descent parser for Monkie2004 is to rewrite the grammar so that it is LL(1).  The provided grammar has multiple instances of two kinds of problems in it: immediate left recursion and the need for left factoring.  Using the techniques we discussed in lecture (and also in the textbook), rewrite the grammar so that it is an LL(1) grammar that recognizes the same language.  You may write the grammar using Microsoft Word and submit it as a <b>.doc</b> file, or you may write it in any other tool you wish and convert it to PDF format instead.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Part 2: Computing FIRST, FOLLOW, and FIRST<sup>+</sup> sets for your grammar (25 points)</p>\r\n\r\n<p>The next step in building a recursive descent parser is to compute its FIRST, FOLLOW, and FIRST<sup>+</sup> sets for your rewritten Monkie2004 grammar.  You may use the algorithm given in the textbook, though I suggest using a less structured approach, since these can be determined effectively by eyeballing the grammar.</p>\r\n\r\n<p>Remember that FIRST, FOLLOW, and FIRST<sup>+</sup> sets are defined as follows:</p>\r\n\r\n<ul>\r\n  <li>FIRST sets are defined for all nonterminal and terminal symbols in the grammar, including &epsilon;.\r\n    <ul>\r\n      <li>FIRST(&epsilon;) = { &epsilon; }.</li>\r\n      <li>For all terminal symbols <i>t</i>, FIRST(<i>t</i>) = { <i>t</i> }.</li>\r\n      <li>For all nonterminal symbols <i>N</i>, FIRST(<i>N</i>) is the set of all the possible first terminal symbols in any legal expansion of <i>N</i>.  If <i>N</i> may expand to &epsilon;, FIRST(<i>N</i>) also contains &epsilon;.</li>\r\n    </ul>\r\n  </li>\r\n  <li>FOLLOW sets are defined for all nonterminal symbols in the grammar.  The FOLLOW set of a nonterminal A is the set of all terminal symbols that may appear after a legal expansion of A in any sentence in the language.</li>\r\n  <li>FIRST<sup>+</sup> sets are defined for all nonterminal and terminal symbols in the grammar, except &epsilon;.  If &epsilon; is in FIRST(&alpha;), FIRST<sup>+</sup>(&alpha;) = FIRST(&alpha;) - { &epsilon; } &cup; FOLLOW(&alpha;), otherwise FIRST<sup>+</sup>(&alpha;) = FIRST(&alpha;).</li>\r\n</ul>\r\n\r\n<p>As an example, consider one of the grammars given earlier in the write-up:</p>\r\n\r\n<ul class=\"nomarker\">\r\n  <li><i>S</i> &rarr; <b>a</b> <i>A</i></li>\r\n  <li><i>A</i> &rarr; <i>A</i> <b>b</b> | <b>c</b></li>\r\n</ul>\r\n\r\n<ul>\r\n  <li>FIRST(&epsilon;) = { &epsilon; }</li>\r\n  <li>FIRST(a) = { a }</li>\r\n  <li>FIRST(b) = { b }</li>\r\n  <li>FIRST(c) = { c }</li>\r\n  <li>FIRST(S) = { a }, since any legal expansion of S must begin with an <b>a</b>.</li>\r\n  <li>FIRST(A) = { c }, since any legal expansion of A must begin with a <b>c</b>, either as a result of the rule <i>A</i> &rarr; <b>c</b>, or as a result of repeated applications of the rule <i>A</i> &rarr; <i>A</i> <b>b</b> followed by an application of <i>A</i> &rarr; <b>c</b>, as in the derivation <i>A</i> &rArr; <i>A</i> <b>b</b> &rArr; <i>A</i> <b>b</b> <b>b</b> &rArr; <b>c</b> <b>b</b> <b>b</b>.</li>\r\n  <li>Since S is the start symbol of the grammar and does not occur in the right-hand side of any rule, the only legal expansion of S is an entire program.  Thus, FOLLOW(S) = { eof }.</li>\r\n  <li>An A may occur in a derivation in one of two ways:\r\n    <ul>\r\n      <li>As a result of beginning a derivation like this: <i>S</i> &rArr; <b>a</b> <i>A</i> &rArr; ...</li>\r\n      <li>As a result of expanding an A using the rule <i>A</i> &rarr; <i>A</i> <b>b</b>.</li>\r\n    </ul>\r\n    In the former case, the expansion of A must be followed by eof.  In the latter, it must be followed by a <b>b</b>.  Thus, FOLLOW(A) = { eof, b }.\r\n  </li>\r\n  <li>Since &epsilon; does not appear in any of the FIRST sets, the FIRST<sup>+</sup> sets in this example are the same as the FIRST sets.</li>\r\n</ul>\r\n\r\n<p>As with your rewritten grammar, you may write your FIRST, FOLLOW, and FIRST<sup>+</sup> sets using Microsoft Word, or using any other tool so long as you convert it to PDF format before submitting it.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Part 3: Building your recursive descent parser (50 points)</p>\r\n\r\n<p>Now that you've rewritten the Monkie2004 grammar to be LL(1) and computed FIRST, FOLLOW, and FIRST<sup>+</sup> sets, you have all the information you need to implement your recursive descent parser, using the pattern described in your textbook and discussed in lecture.</p>\r\n\r\n<p>Your parser should print, as output, an indication of what procedures, functions, and statements it recognized.  For example, given the following input program:</p>\r\n\r\n<pre>\r\nvar globalInteger: integer;\r\n\r\nprocedure program()\r\n[\r\n    var x: integer;\r\n    x <- 10;\r\n\r\n    while x > 0 do\r\n    [\r\n        x <- x - 1;\r\n        \r\n        if x == 0 then\r\n        [\r\n            print(\"done\");\r\n        ]\r\n    ]\r\n]\r\n</pre>\r\n\r\n<p>...your parser should produce output in the following form:</p>\r\n\r\n<pre>\r\nvariable declaration\r\nprocedure\r\n[\r\n    variable declaration\r\n    assignment\r\n    while loop\r\n    [\r\n        assignment\r\n        if statement\r\n        [\r\n            procedure call\r\n        ]\r\n    ]\r\n]\r\n</pre>\r\n\r\n<p>Your parser is not required to (and should not) build a parse tree or any intermediate representation of the program; output should be generated on the fly as statements are recognized.  Output should use indentation to convey membership of statements in block statements, as shown in the example output above.</p>\r\n\r\n<p>As in the previous assignment, you are required to provide a driver program in a class called <b>Driver</b> in a file called <b>Driver.java</b>, so that we can compile and run your program with the following sequence of commands:</p>\r\n\r\n<pre>\r\n    javac *.java\r\n    java Driver inputfile.m\r\n</pre>\r\n\r\n<p>...where <b>inputfile.m</b> is the name of a Monkie2004 program.  I've provided such a Driver program in the starting point, which you may modify if you wish, though it must still behave in a way that allows us to run your program using the commands specified above.</p>\r\n\r\n<p>Unlike in the previous assignment, we will attempt to run your program using Monkie2004 programs that have errors in them.  In the case of an erroneous input program, your parser may print an error message and quit as soon as the first error is discovered.  It is not necessary to provide an error message that indicates the nature of the problem (though you may, if you'd like).  You are required, however, to print the line and column of the token that caused the problem.  I suggest throwing a ParserError (a class I've provided), catching it in your driver class, and doing this:</p>\r\n\r\n<pre>\r\n    System.out.println(e.getMessage());\r\n</pre>\r\n\r\n<p>To get you started, I'm providing a starting point, consisting of compiled versions of my Scanner, Token, and ScannerError classes, along with a skeleton for your parser in <b>Parser.java</b> (including some helper methods, such as consumeToken( ), that you will find useful), a ParserError class that you will likely find useful for reporting errors, and the complete source code for your Driver class.  Here's a link to the starting point:</p>\r\n\r\n<ul>\r\n  <li><a href=\"Parser.zip\">Parser.zip</a></li>\r\n</ul>\r\n\r\n<p>A little documentation for the compiled classes that I've provided will be necessary, so here goes...</p>\r\n\r\n<ul>\r\n  <li>The Scanner class is much like the one generated by your JFlex script in Assignment #1.  It has two constructors -- one that takes an InputStream and another that takes a Reader -- meaning that you can create a Scanner in the same two ways as you did in the last assigment:\r\n    <ul>\r\n      <li>Scanner s = new Scanner(System.in);</li>\r\n      <li>Scanner s = new Scanner(new FileReader(<i>filename</i>));</li>\r\n    </ul>\r\n    The scanning method in the Scanner class has the following signature:\r\n    <ul>\r\n      <li>public Token getNextToken() throws java.io.IOException</li>\r\n    </ul>\r\n    In addition to possibly throwing an IOException, getNextToken() throws a ScannerError (an unchecked exception) whenever it encounters a lexical error, such as an identifier with a consecutive pair of underscores or a string literal with an end-of-line in it.</li>\r\n  </li>\r\n  <li>The ScannerError class is an unchecked exception that is thrown by getNextToken().  I suggest catching this exception and doing the following with it (since it carries an error message with it):\r\n    <ul>\r\n      <li>System.out.println(e.getMessage());  // assuming e is a ScannerError</li>\r\n    </ul>\r\n    By the way, the skeleton that I've given you already contains code that reads the next token from the scanner and catches and reports ScannerErrors, so you likely won't have to write any code to deal with these yourself.\r\n  </li>\r\n  <li>The Token class is similar to the one that you should have built in the previous assignment.  It consists of 32 public static integer constants, one for each token type:\r\n      <blockquote><b>IDENTIFIER, INTEGER_LITERAL, STRING_LITERAL, DO, ELSE, FALSE, FUNCTION, IF, PROCEDURE, REF, THEN, TRUE, VAR, WHILE, LEFT_PAREN, RIGHT_PAREN, LEFT_BRACKET, RIGHT_BRACKET, ADDITION_OP, SUBTRACTION_OP, MULTIPLICATION_OP, DIVISION_OP, INTEGER_NEGATION_OP, LESS_THAN_OP, GREATER_THAN_OP, EQUAL_OP, NOT_EQUAL_OP, ASSIGNMENT_OP, CONCATENATION_OP, SEMICOLON, COLON, COMMA</b></blockquote>\r\n    The following methods can be called on a Token object:\r\n    <ul>\r\n      <li>public int getTokenType(): returns the token type, which is one of those 32 constant values.</li>\r\n      <li>public int getLine(): returns the line number where the first character of this token occurred in the input program.</li>\r\n      <li>public int getColumn(): returns the column number where the first character of this token occurred in the input program.</li>\r\n      <li>public String getStringAttribute(): returns the string attribute associated with this token, if any.  String attributes are associated with IDENTIFIER and STRING_LITERAL tokens, containing the name of the identifier and the value of the string literal, respectively.  All other tokens have a string attribute of \"\".</li>\r\n      <li>public int getIntegerAttribute(): returns the integer attribute associated with this token, if any.  Integer attributes are associated with INTEGER_LITERAL tokens, containing the value of the integer literal.  All other tokens have an integer attribute of 0.</li>\r\n    </ul>\r\n    One additional static method in Token might be of interest, though you probably won't find use for it:\r\n    <ul>\r\n      <li>public static String getTokenTypeString(int tokenType): given one of the 32 constant values for token types, returns a string that describes the token.  For example, Token.getTokenTypeString(Token.ELSE) returns \"ELSE\".</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>You must submit your two Microsoft Word or PDF documents -- one containing your grammar and another containing your FIRST, FOLLOW, and FIRST<sup>+</sup> sets.  Additionally, you are to submit all of the <b>.java</b> files that comprise your program, including those that have been provided.  You should not submit the <b>.class</b> files provided to you, nor should you submit any compiled versions of your own code or other files generated by your development environment.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingAssignments.html\">this link</a> for a discussion of how to submit your assignment.  Remember that we do not accept paper submissions of your assignments, nor do we accept them via email <i>under any circumstances</i>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Limitations</p>\r\n\r\n<p>In case it isn't obvious from the rest of the write-up, I expect you to hand-code your parser.  Use of automated tools to build your parser is strictly forbidden, and will result in an automatic score of 0 on this assignment.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Originally written by Alex Thornton, Winter 2004.</li>\r\n</ul>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}