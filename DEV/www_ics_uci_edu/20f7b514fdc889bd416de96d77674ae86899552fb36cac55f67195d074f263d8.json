{"url": "https://www.ics.uci.edu/~kay/courses/h22/hw/hw6.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Tuesday, February 18, 2003 11:20 AM\">\n<TITLE>Sixth Homework</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"D7C5897D\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 2, CS2, assignment, performance measurement\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"An assignment involving measuring and analyzing the performance of alternative search algorithms for ICS H22, an honors second-quarter course in computer science in Information and Computer Science, UC Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2000, 2003 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"Sixth_Homework_files/Sidebar_123.gif\" WIDTH=575 HEIGHT=77>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4> &#160; <A NAME=\"_14_30\"></A></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>This assignment is due on Monday, February\n24.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  Take the </FONT><FONT FACE=\"Courier New\">Button2</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nclass we went over last Thursday (adapted from <A HREF=\"http://www.mindview.net/Books\">Bruce Eckel&#39;s Thinking in Java, third edition</A>)\nand change it as follows:</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Make the text field display a counter that\nstarts at zero.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Make one button say &quot;Increment&quot;;\nwhen you click it, the counter is increased by one.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Make the other button say &quot;Decrement&quot;;\nwhen you click it, the counter is decreased by one.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Add another button called &quot;Reset&quot;\nthat sets the counter to zero.</FONT></LI>\n</UL>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>See </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.ics.uci.edu/~kay/courses/h22/hw/Button2.java\">http://www.ics.uci.edu/~kay/courses/h22/hw/Button2.java</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nfor the version of the <A NAME=\"_14_573\"></A></FONT><FONT FACE=\"Courier New\">Button2</FONT><FONT FACE=\"AGaramond\" SIZE=4>\ncode we used in class.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>For some extra credit, which you absolutely\nmay not attempt until you finish the rest of this assignment (come on now,\nGUIs are fun, but no dessert until you eat your vegetables!), take a look\nat Eckel&#39;s text (try the &quot;Catalog of Swing Components&quot; section\nof Chapter 14, Creating Windows &amp; Applets) to get an idea of some of\nthe other components you can create.  Then add some bells and whistles to\nyour counter:  Some simple possibilities are counting by twos (or a user-specified\nincrement, possibly specified by a slider), highlighting particular values\n(e.g., values evenly divisible by 10), or allowing the user to specify starting\nor reset values.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Design and implement a class DVD,\nwhich has the following 14 fields:  title, studio, pending release date,\nstatus (e.g., out or released, discontinued, pending), sound, versions,\nprice, rating, year, genre, aspect ratio, UPC (universal product code),\nrelease date, and ID number.  The file </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.ics.uci.edu/~kay/courses/h22/hw/DVD.txt\">http://www.ics.uci.edu/~kay/courses/h22/hw/DVD.txt</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>\ncontains data for about 25,000 DVDs (the original source of this file is\n</FONT><FONT FACE=\"Courier New\"><A HREF=\"http://hometheaterinfo.com/dvdlist.htm\">http://hometheaterinfo.com/dvdlist.htm</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>).\n Note that the first line contains the field names.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.1)</B>  Your DVD class should have conventional\ngetter and setter methods for each field.  </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.2)</B>  You should also have a constructor\nthat takes a single string (a line of information about the DVD, in the\nformat of the input file listed above) and extracts from it the field values,\ncreating a new DVD object appropriately.  The data file contains a single\nline for each DVD; you can read that line into a string and then call this\nconstructor. Parsing these strings requires a little bit of attention:</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>In each string, the 14 fields of DVD information\nare separated from one another by commas.  Some fields have null values;\nthey are represented in the input by two commas with nothing in between\n(or by a comma at the end of the string).</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Most of the fields are strings, surrounded\nby double-quote marks (and where a double-quoted string <I>contains</I>\na double-quote mark, two double-quote marks appear in a row).  When you\nstore these string values, of course you should not store the surrounding\ndouble-quote marks (and any internal double-quote marks should not be doubled\nin the stored version as they were in the input).</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>The price field appears with a dollar sign\nand no quotation marks.  Store it as an integer number of cents.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>The pending release date field is null if\nthe status isn&#39;t pending; this field and the other release date field,\nwhen they aren&#39;t null, contain a date and time (in the format 2/14/03\n12:00, not enclosed in quotation marks).  You may store each date/time value\nas a single string.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>The ID number field is either null or an integer;\nstore this field as an integer with null values as zero.</FONT></LI>\n</UL>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.3)</B>  You should also have a toString\nmethod that produces from a DVD object a string in the same form as the\noriginal data.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.4)</B>  Write a simple driver program\nthat reads lines from the input file, creates DVD objects, and writes lines\nback to a new text file.  You should eventually test your program on the\nentire input file, but of course you can use just a small portion of it\nas you&#39;re working.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)</B>  For the next part of this assignment,\nyou will design and implement a &quot;bag&quot; of objects.  A bag (or multiset)\nis a collection of objects, each with a string as its key, in which the\norder isn&#39;t important (like a set) but the number of times each item\noccurs <I>is</I> important (unlike a set).  You might use a bag, for example,\nin an automated building entry system where you look up each entrant and\nkeep a count of how many times that person has passed through the door;\nyou might also use one to support a web site that counts votes for a favorite\nsong or book.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Your bag will implement the interface described\nbelow.  You will write two classes that implement the Bag interface, one\nclass using a binary search tree and the other using a hash table.  For\nthe hash table class, you will experiment with different hash functions\nand compare their results.  You will also write one or more simple driver\nprograms to read in the data specified below and insert it into your various\nBags.  </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>For the hash table version, you will implement\nfive alternative hash functions.  Then you will hash each set of data using\neach of the five hash functions, producing statistics on the effectiveness\nof each combination.  [You may choose to parameterize your choice of hash\nfunction (and of data file), combining all your tests into one single run\nof the program.  You may also recompile the class and run the test separately\nwith each hash function and each data set.]  Finally you will write a brief\nsummary of your findings, describing which functions worked best and worst\nfor which data.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.1:  the Bag interface)</B>  A bag has\nthe operations described below; the behavior of the classes that implement\nthis interface is also described.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Constructor--Creates an empty Bag.  If an\nargument is specified, the binary search tree version ignores it but the\nhash table version uses that argument as the table size.  (For a little\nextra credit, make your hash table constructor use as the table size a prime\nnumber greater than or equal to the argument.)<A NAME=\"_14_5866\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>isEmpty</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Return\ntrue if the Bag contains no elements.  (Implement this so that it works\nin constant time.)<A NAME=\"_14_5978\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>makeEmpty</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Remove\nall the items stored in the Bag.<A NAME=\"_14_6034\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>insert</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Take\na string (the key) and an object as arguments and insert the object into\nthe Bag (according to the key).<A NAME=\"_14_6157\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>find</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Take\na string (the key) as an argument and return a reference to the object with\nthat key if it&#39;s present in the Bag (or null if it&#39;s not present).<A NAME=\"_14_6316\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>delete</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Take\na string (the key) as an argument and remove from the Bag one object with\nthat key (if it&#39;s present).  (E.g., if you insert objects with keys\nA, B, A, C, and B, and then delete A, the table will contain A, C, and two\nBs.)<A NAME=\"_14_6556\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>totalElements</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Return\nthe total number of elements currently stored in the Bag.  (E.g., if you\ninsert A, B, A, C, and B, <A NAME=\"_14_6682\"></A></FONT><FONT FACE=\"Courier\"><TT>totalElements</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nshould return 5.)  Implement this so that it works in constant time.<A NAME=\"_14_6771\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>uniqueElements</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Return\nthe number of unique elements currently stored in the Bag.  (E.g., if you\ninsert A, B, A, C, and B, <A NAME=\"_14_6899\"></A></FONT><FONT FACE=\"Courier\"><TT>uniqueElements</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nshould return 3.)  Implement this so that it works in constant time.<A NAME=\"_14_6989\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>printStats</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>--Print\nstatistics that show how evenly elements are distributed in the Bag.  This\nfunction will produce different results for each implementation.  \n<BR>\n--The binary search tree version should print out some indication of whether,\nor how well, the tree is balanced.  \n<BR>\n--The hash table version should print one line for each index (i.e., each\nbin) in the hash table; on that line should be the index, the total number\nof items in that bin, the number of unique items in that bin, and an asterisk\nfor each unique item in that bin.  For example, suppose we have a HashTable\nof size 3 in which the following items are inserted:  <A NAME=\"_14_7624\"></A></FONT><FONT FACE=\"Courier\"><TT>A\nB a c 3 9 D E D 4 9 5 7 5</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.  Suppose\nfurther that all upper-case letters hash to bin 0, all lower-case letters\nhash to bin 1, and all digits hash to bin 2.  The output of <A NAME=\"_14_7802\"></A></FONT><FONT FACE=\"Courier\"><TT>printStats</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nfor this table might look like this:<A NAME=\"_14_7855\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>0.  5  4 ****\n<BR>\n1.  2  2 **\n<BR>\n2.  7  5 *****</TT></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.2:  binary search tree details)</B>\n Your binary search tree should be a simple (unbalanced) binary search tree.\n You may use as a guide the Scheme code at </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.ics.uci.edu/~kay/courses/h22/hw/bst.scm\">http://www.ics.uci.edu/~kay/courses/h22/hw/bst.scm</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nas well as any code in Goodrich&#39;s text.  Note that even though the order\nof the items isn&#39;t important to the Bag class, you will need to compare\nstrings internally to construct your binary search tree.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.3: hash table details)</B>  Your hash\ntable should resolve collisions by linear chaining, as described in class\nand in Goodrich&#39;s text.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.4: hash functions)</B>  The <A NAME=\"_14_8496\"></A></FONT><FONT FACE=\"Courier\"><TT>Insert</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand <A NAME=\"_14_8513\"></A></FONT><FONT FACE=\"Courier\"><TT>Find</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\noperations must (of course) use a function that computes a hash code from\nthe key field of the data.  This hash function is critical to the performance\nof your hash table, since you&#39;ll lose the performance advantages of\nhashing if your data are not distributed evenly (i.e., randomly) throughout\nthe table.  You should code each of the hash functions listed below.  (Where\na function speaks of a character&#39;s ASCII code, you may use any numeric\nvalue that&#39;s unique for every character.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* the sum of the ASCII codes of each character\nof the key, mod the table size</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* the product of the ASCII codes of each character\nof the key, mod the table size</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* the product of the ASCII codes of the first,\nfifth, ninth, thirteenth, seventeenth, and twenty-third characters of the\nkey, mod the table size</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* the hash function given on page 346 of the\nGoodrich text</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* at least one other hash function of your\nown design (which may be a variation of one of the functions described above)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.5: experimental runs and input data)</B>\n Write simple driver programs to read the two data sets below, insert them\ninto a bag, and observe and analyze their performance:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* The DVD objects described in part <B>(b)</B>\nabove.  Use the DVD&#39;s title as the key.  There are about 40 titles that\naren&#39;t unique.  Your bag should count those as multiple occurrences\nof the same DVD object.  (For some extra credit, you can create from each\ntitle a &quot;main title&quot; field.  You&#39;ll notice that in the DVD\nlist, multiple versions of the same work are distinguished by adding to\nthe title some extra information like &quot;(Animated)&quot; or &quot;(Live\nAction).&quot;  You can create a &quot;main title&quot; by finding the first\ncharacter of the title that isn&#39;t a letter, upper or lower case, a digit,\na space, or an apostrophe; everything from the start of the string up to\nthat point could be the main title.  If you use this main title as the key,\nyou will produce more duplicate keys for your bag to count.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* Any list of at least 2000 English words.\n There is a file of many words available at </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.ics.uci.edu/~kay/courses/h22/hw/wordlist.txt\">http://www.ics.uci.edu/~kay/courses/h22/hw/wordlist.txt</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Ask yourself this question and check with\nsomeone if you don&#39;t know the answer:  What is the problem with these\ntwo input files when you&#39;re testing the performance of your BST-based\nBag?  (Hint:  To make your life easier, we have provided these two files:\n </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.ics.uci.edu/~kay/courses/h22/hw/DVD-random.txt\">http://www.ics.uci.edu/~kay/courses/h22/hw/DVD-random.txt</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.ics.uci.edu/~kay/courses/h22/hw/wordlist-random.txt\">http://www.ics.uci.edu/~kay/courses/h22/hw/wordlist-random.txt</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.6: extra credit)</B>  For a little extra\ncredit, try one or both of these:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* Run your tests and experiments on a third\nset of test data that you download from the Web, including the results in\nyour written analysis.  Your data should contain at least 5000 items.  Be\nsure to supply the URL where you found the data.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>* So far, we have been concerned with how\neffective our hash functions are--that is, how evenly they distribute the\ndata throughout the table.  For this part, you will concentrate on the efficiency\nof the function itself--that is, how long it takes to compute the hash value\nfrom the key.  You will measure how long each of your hash functions takes\nto hash 10,000 data items, including a description of your results in your\nwritten analysis.  You should write a separate driver for this task that\njust reads the data and calls the hash function, because you don&#39;t want\nto skew the results by including the time it takes to insert the data into\nthe table.  Produce timing results for each of the different hash functions\non each of the different sets of test data, to see if there are any efficiency\ndifferences that depend on the characteristics of the data.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(d)</B>  Write an interpreter for the programming\nlanguage Facile 2.0, which is like the original version of Facile except\nfor these two enhancements:</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Long variable names.  Everywhere a single-letter\nvariable could occur in an original Facile program, Facile 2.0 accepts a\nstring of one or more alphabetic characters (A-Z).  You&#39;ll need to build\na symbol table (as either a binary search tree or a hash table, similar\nto your Bag implementations from part <B>(c)</B>; you may use your implementations\nor a class from the Java library) to store each variable and its value and\nto retrieve the value when an already-defined variable appears in the code.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"AGaramond\" SIZE=4>Statement labels:  Perhaps the most painful\npart of programming in original Facile is having to count statements to\nget the statement numbers correct in goto, gosub, and if statements.  In\nFacile 2.0, the programmer may include statement label lines.  Each statement\nlabel is a variable name (as above) followed by a colon, as shown below.\n (Note that if the first word on a line isn&#39;t a statement keyword known\nto Facile (like LET or GOSUB), it&#39;s a label.)  When your program finds\na label, it adds the label to the symbol table with the value of the statement/line\nnumber where the label occurred.  When a label occurs in a goto, gosub,\nor if statement, the interpreter looks up the label in the symbol table\nand substitutes its value.  An example appears below.<A NAME=\"_14_13596\"></A></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>LET N 5</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>LET F 1</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>GOSUB FACT</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>PRINT F</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>END</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>FACT:</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>IF N &gt; 1 THEN KEEPGOING</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>RETURN</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>KEEPGOING:</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>MULT F N</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>SUB N 1</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>GOSUB FACT</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>RETURN</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=4><TT>.</TT></FONT></LI>\n</UL>\n<BR>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e)</B>  This part is extra credit, and\nit is not due with the rest of the assignment.  It will be due in a couple\nof weeks, but we wanted to give you the chance to start thinking about it\nnow.  Either individually or in pairs, add a graphical user interface to\none of the programs you&#39;ve written this quarter:  The restaurant database\nprogram, the restaurant ordering program, the bank accounts, or the Facile\ninterpreter.  Think about the design before you start coding, and develop\nincrementally:  That is, add a little bit at a time so that if you don&#39;t\nhave time to implement that one last feature, at least you&#39;ll have the\nprevious features working and ready to turn in.<A NAME=\"_14_14404\"></A></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>What to turn in:</B>  </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Turn in your Java files via Checkmate for\nparts <B>(a)</B> through <B>(d)</B>.  Also turn in a prose document with\npart <B>(c)</B> that gives your analysis of the hash functions you tested.</FONT></P>\n<P>\n<FONT FACE=\"Helvetica\" SIZE=1>GUI counter problem written by David G. Kay,\nWinter 2003 to build on code from Bruce Eckel&#39;s <I>Thinking in Java,\nThird Edition. \n<BR>\n</I>DVD class problem written by David G. Kay, Winter 2003.\n<BR>\nHash table implementation assignment written by David G. Kay, Winter 1997\nand modified by David G. Kay, Spring 1997 and Fall 1998. Bags and binary\nsearch trees included by David G. Kay, Winter 1999 with residual revisions\nby David G. Kay, Spring 1999 and Winter 2003.\n<BR>\nFacile enhancements written by David G. Kay, Winter 2003, to build on the\nFacile lab assignment by Alex Thornton.</FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}