{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/review.txt", "content": " \tPython Review (everything you should have learned in ICS-31/32)\r\n\r\nWhen reading the following material, I suggest that you have Eclipse open,\r\nincluding a project with an empty module; then copy/paste some of the code\r\nbelow into it, to see what it does. Explore the code by experimenting with\r\n(changing) it and predicting what results from the changes. I always have an\r\nEclipse folder/module named \"experiment\" open for this purpose. I believe\r\nthis approach is superior to me typing/executing code during lecture.\r\n\r\nThis lecture note is long (it is really three lectures), but the information is\r\ncritical for getting started. I hope that this is mostly a review for ICS-31/32\r\nstudents, but there are likely to be many things that come up as new (or as new\r\nperspectives and connections to the material that you already know). Pay close\r\nattention to the terminology used here, as I will use it (I hope consistently)\r\nthroughout the entire quarter. If you do not know any of these technical terms,\r\ntry looking them up online, or post a message in the \"Lecture Material\" Piazza\r\nQ&A Folder: if you didn't understand a term, probably other students didn't as\r\nwell. Here are 3 quotes relevant to this lecture:\r\n\r\n  1) The first step towards wisdom is calling things by their right names.\r\n\r\n  2) He/She who is ashamed of asking is ashamed of learning.\r\n\r\n  3) The voyage of discovery is not in seeking new landscapes but in having new\r\n     eyes. - M. Proust\r\n\r\n------------------------------------------------------------------------------\r\n\r\nPython in Four Sentences:\r\n\r\n1. Names (in namespaces) are bound to objects.\r\n\r\n2. Everything that Python computes with is an object.\r\n   (examples are instance/data, function, module, and class objects)\r\n\r\n3. Every object has its own namespace.\r\n   (a dictionary that binds its internal names to other objects)\r\n\r\n4. Python has rules about how things work.\r\n\r\nIn some sense these four sentences tell you very little about Python, but in\r\nanother sense they are a tiny framework in which to interpret every idea -small\r\nand big- in Python and how Python works.\r\n\r\nEvery name appears in the namespace of some object (when we define names in a\r\nmodule, for example, these names appear in the module object's namespace); and\r\nevery name is itself bound to some object (names are bound when defined on the\r\nleft of the = symbol; they can be rebound to another object by using them on\r\nthe left of the = symbol again; names are also bound in import statements,\r\nfunction definitions, and class definitions: these names/bindings are discussed\r\nin ICS-33 throughout the quarter).\r\n\r\nObjects are the fundamental unit with which Python computes. For example...\r\n\r\n  1) We can compute with int objects (instance objects from the int class) by\r\n     using operators; for the int object bound to x by x = 1 we can rebind it to\r\n     another int object, one bigger, by writing x = x + 1. We will learn later\r\n     that Python translates x+1 into the method call x.__add__(1) and then into\r\n     int.__add__(x,1) -assuming, as it does here, x stores a reference to an\r\n     int object: int is a reference to a class object.\r\n\r\n  2) We can compute with function objects by calling them; for the function\r\n     object bound to print, we can write print(x); we will learn later in these\r\n     notes that we can also pass functions as arguments to functions and\r\n     return functions as results from functions. Python allows us to do many\r\n     interesting things with functions, beyond just calling them.\r\n   \r\n  3) We can compute with module objects by importing them (and/or the objects\r\n     bound to the names in their namespaces).\r\n     import random\t\t\tor     from random import randint\r\n     x = random.randint(1,6)\t\t       x = randint(1,6)\r\n\r\n     The name random (in the current           The name randint (in the current\r\n     module) is bound to the random module     module) is bound to the function\r\n     object, which defines a randint\t       object that the name randint (in\r\n     function in its namespace, which is       the random module's namespace)\r\n     called.\t      \t \t\t       is bound to, which is called.\r\n\r\n  4) We can compute with class objects by constructing instance objects and\r\n     using the instances to call class methods. For example, we can write\r\n     timer = Stopwatch()\r\n     timer.start()\r\n\r\nPython follows rules that determine how names are bound (e.g., how arguments are\r\nbound to parameters), how operators compute, how control structures execute the\r\ncode blocks they control, etc. This course is designed to demystify how Python\r\nexecutes scripts and how you can better use its features to write scripts. We\r\nknow a programming language in most part by knowing its rules.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nBinding (and Drawing Names and their associated Objects)\r\n\r\nThe process of making a name refer to a value: e.g., x = 1 binds the name x to\r\nthe value 1 (which is an object/instance of the int class); later we can bind\r\nx to another value (possibly from another class) in another assignment: e.g.,\r\nx = 'abc'. We speak about \"the binding (noun) of a name\" to mean the value\r\n(such values are always objects) that the name is currently associated with\r\n(or the object the name refers to).\r\n\r\nIn Python, every data instance, module, function, and class is an object that\r\nhas a dictionary that stores its namespace: all its internal bindings. We will\r\nlearn much more about namespaces (and how to manipulate them) later in the\r\nquarter, when we study classes in more detail.\r\n\r\nTypically we illustrate the binding of a name to an object (below, x = 1) as\r\nfollows. We write the name over a rectangle, in which the tail of an arrow is\r\nINSIDE, specifying the current reference stored for that name: the arrow's head\r\nrefers to a rounded-edge rectangle object labeled by its type (here the class\r\nit is constructed from) and its value (inside).\r\n\r\n  x          int\r\n+---+\t    (---)\r\n| --+------>| 1 |\r\n+---+\t    (---)\r\n\r\nTechnically, if we we write x = 1 inside the module m, Python has already\r\ncreated an object for module m (we show all objects as rounded-edge rectangles)\r\nand it puts x, its box, and its binding in the namespace of module m: here, the\r\nname x is defined inside module m and bound to object 1. That is, we would more\r\nformally write the result of x = 1 in module m as\r\n\r\n             module\r\n          (---------)\r\n  m       |    x    |      int\r\n+---+     |  +---+  |     (---)\r\n| --+---->|  | --+--+---->| 1 |\r\n+---+     |  +---+  |     (---)\r\n          (---------)\r\n\r\nBut often we revert to the previous simpler diagram, when we don't care in what\r\nmodule x is defined, focusing solely on x and the object it refers to.\r\n\r\nNote that the del command in Python (e.g., del name) removes a name from the\r\ncurrent namespace/dictionary of the object in which name is bound. So, writing\r\ndel x inside module m would remove x and its box from m's namspace/dictionary.\r\nIf there was no name x in this module, Python raises an NameError exception. \r\n\r\nFinally, the \"is\" operator in Python determines whether two references refer to\r\nthe same object (it is called the (object)identity operator); the == operator\r\ndetermines whether two references refer to objects that store the same internal\r\nstate. If a is b is True then a == b must be True (because both a and b refer\r\nto the same object if a is b is True, and every object has the same state as\r\nitself.\r\n\r\nIf we write\r\n\r\n  x = ['a','b']\r\n  y = ['a','b']\r\n  \r\nthen x is y is False and x == y is True: the names x and y are bound to/refer\r\nto two different list objects (each use of [] creates a new list), but these\r\ntwo objects store the same state ('a' at index 0; 'b' at index 1).\r\n\r\n                list\r\n            (-----------)\r\n  x         |   0   1   |        str\r\n+---+\t    | +---+---+ |       (---)\r\n| --+------>| | | | --+-+-----> |'b'|\r\n+---+\t    | +-+-+---+ |\t(---)\r\n\t    (---+-------)\r\n                |\r\n\t\tv\r\n\t       str\t\t\r\n\t      (---)\r\n\t      |'a'|\r\n\t      (---)\r\n\r\n                list\r\n            (-----------)\r\n  y         |   0   1   |        str\r\n+---+\t    | +---+---+ |       (---)\r\n| --+------>| | | | --+-+-----> |'b'|\r\n+---+\t    | +-+-+---+ |\t(---)\r\n\t    (---+-------)\r\n                |\r\n\t\tv\r\n\t       str\t\t\r\n\t      (---)\r\n\t      |'a'|\r\n\t      (---)\r\n\r\n\r\nTechnically, the 0 and 1 indexes of the list should share the same string\r\nobjects ('a' and 'b'). This a subtle point that is special to int and str\r\nobjects. I won't care whether you share or duplicate such objects. It is\r\nintersting to use is to tell what is actually happening:\r\n\r\nprint(x[0] is y[0], x[1] is y[1], x[0] == y[0], x[1] == y[1])\r\n\r\nLikewise, if we write\r\n\r\n  x = ['a','b']\r\n  y = x\r\n\r\nthen we create one list object, and bind it to both x and y (assignment y = x\r\njust copies into name y the reference in name x, making y and x refer to the\r\nsame object). Here, x is y is True (and x == y is therefore True): the names x\r\nand y refer to the same list object. We would diagram it as\r\n  x\r\n+---+           list\r\n| --+------>(-----------)\r\n+---+       |   0   1   |        str\r\n            | +---+---+ |       (---)\r\n  y         | | | | --+-+-----> |'b'|\r\n+---+\t    | +-+-+---+ |\t(---)\r\n| --+------>(---+-------)\r\n+---+           |\r\n\t\tv\r\n\t       str\t\t\r\n\t      (---)\r\n\t      |'a'|\r\n\t      (---)\r\n\r\nSo, pictures can help us understand the differences between these two code\r\nfragments. You should be able to draw a simple picture of these names and\r\nobjects (both the list and int objects) to illustrate the difference between\r\nthe \"is\" and == operators.\r\n\r\nThe == operator, especially in simple programs, is used much more frequntly\r\nthan the the \"is\" operator.\r\n\r\nWhat happens in each example (what picture results) if we execute y[0] = 'c'?\r\nWhat would be printed by print(x[0]) in each after such an assignment.\r\n\r\nFinally, if we are in module m1 and we write \r\n\r\nimport m2\r\n\r\nthen we can create/delete names in m2's namespace by writing\r\n\r\nm2.x = 3  # create a name x in the namespace of module m2 (present? use that\r\n          # name); bind it to int 3\r\n\r\ndel m2.x  # delete name x in the namespace of module m2; absent? raise exception\r\n\r\n------------------------------------------------------------------------------\r\n\r\nStatements vs Expressions\r\n\r\nThe basic unit of speech in English is a sentence: sentences are built from\r\nnoun and verb phrases. In Python the basic unit of code is a statement:\r\nstatements are built from expressions (like a boolean expression in an if\r\nstatement) and other statements (like block statements inside an if statement).\r\n\r\nStatements are executed to cause an effect (e.g., binding/rebinding a name or\r\nproducing output). Expressions are evaluated to compute a result (e.g.,\r\ncomputing some formula, numeric, string, boolean, list, etc.). For example, the\r\nstatement x = 1, when executed, causes a binding of the name x to an object\r\nrepresenting the integer 1. The expression x+1, when evaluated, computes the\r\nobject representing the integer 2. Typically we write expressions inside\r\nstatements: two examples are x = x+1 and print(x+1): both \"do something\" with\r\nthe computed value x+1 (the first rebinds x to it; the second prints it). The\r\ndistinction between statements and expressions is important in most programming\r\nlanguages.  Learn the technical meaning of these terms and be able to recognize\r\nstatements and expressions in statements.\r\n\r\nThe print function is a bit strange. We call if for an effect (putting\r\ncharacters in the Console window) but like every function, also returns a\r\nvalue: when print is called successfully (doesn't raise any exceptions) it\r\nreturns the value None. We typically don't do anything with this value. So,\r\nwe can write the code line\r\n\r\nprint(x)\r\n\r\nwhich calls the print function (printing something in the Console window) and\r\ndoing nothing with the None value print returns.\r\n\r\nControl structures (even simple sequential ones, like blocks) are considered\r\nto be statements in Python. Python has rules describing how to execute\r\nstatements. Control structures might contain both statements and expressions.\r\nThe following is a conditional statement using if/else\r\n\r\n  if x == None:\r\n      y = 0\r\n  else:\r\n      y = 1\r\n\r\nThis if statement contains the expression x == None and the statements y = 0 and\r\ny = 1. Technically, x, None, 0 and 1 are \"trivial\" expressions (which trivially\r\ncompute the object to which x is currently bound, and the object values None,\r\n0, and 1 which are literals: preconstructed objects \"named\" by None, 0, and 1).\r\n\r\nThe following statement includes a conditional expression that binds a value to\r\ny: the conditional expression includes the expressions 0 (yes, an object by\r\nitself, or just a name refering to an object, is a simple expression),\r\nx == None, and 1.\r\n\r\n  y = (0 if x == None else 1)\r\n\r\nWe will discuss conditional statements vs. conditional expressions in more\r\ndetail later in this lecture note.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nNone:\r\n\r\nNone is a value (object/instance) of NoneType; it is the only value of that\r\ntype. Sometimes we use None as a default value for a parameter's argument;\r\nsometimes we use it as a return value of a function: in fact, a Python function\r\nthat terminates without executing a return statement automatically returns the\r\nvalue None. If None shows up as an unexpected result printed in your code or\r\nmore likely in a  raised exception, look for some function whose return value\r\nyou FORGOT to specify explicitly (or whose return statement somehow didn't get\r\nexecuted before Python executes the last statement in a function).\r\n\r\n------------------------------------------------------------------------------\r\n\r\npass:\r\n\r\npass is the simplest statement in Python; semantically, it means \"do nothing\".\r\nSometimes when we write statements, we aren't sure exactly which ones to write,\r\nso we might use pass as a placeholder until we write the actual statement we\r\nneed. Often, in tiny examples, we use pass as the meaning of a function.\r\n\r\n  def f(x) : pass     or     def f(x) :\r\n      \t     \t      \t         pass\r\n\r\nIf you are ever tempted to write the first if statement below, don't; instead\r\nwrite the second one, which is simpler: but, they produce equivalent results.\r\n\r\n  if a in s:\t\t\t# DON'T write this code\r\n      pass\r\n  else:\r\n      print(a,'is not in',s)\r\n\r\n\r\n  if a not in s:\t\t# Write this code instead; it is equivalent\r\n      print(a,'is not in',s)    # and simpler; strive to use Python simply\r\n\r\n------------------------------------------------------------------------------\r\n\r\nImporting: 5 Forms\r\n\r\nThere are five import forms; you should know what each does, and start to think\r\nabout which is appropriate to use in any given situation. Note that in EBNF (a\r\nnotation used to describe programming languages, which we will discuss soon)\r\n[...] means option and {...}  means repeat 0 or more times, although this\r\nsecond form is sometimes written (...)* when describing the syntax of Python.\r\n\r\nFundamentally, import statements bind names to objects (one or both of which\r\ncome from the imported module).\r\n\r\n\"import module-name\" form: one or more modules, optionally renaming each\r\n  1. import module-name{,module-name}\r\n  2. import module-name [as alt-name] {,module-name [as alt-name]}\r\n\r\n\"from module-name import\" form: one or mor attributes, optionally renaming each\r\n  3. from module-name import attr-name{,attr-name}\r\n  4. from module-name import attr-name [as alt-name] {,attr-name [as alt-name]}\r\n  5. from module-name import *\r\n\r\nAbove, alt-name is an alternative name to be bound to the imported object;\r\nattr-name is an attribute name already defined in the namespace of the module\r\nfrom which attr-name is imported.\r\n\r\nThe \"import module-name\" forms import the names of modules (not their attribute\r\nnames). (1) bind each module-name to the object representing that imported\r\nmodule-name. (2) bind each alt-name to the object representing its preceding\r\nimported module-name. Using a module name, we can refer to its attributes using\r\nperiods, such as by module-name.attribute-name\r\n\r\nThe \"from module-name import\" forms don't import a module-name, but instead\r\nimport some/all attribute names defined/bound inside module-name. (3) bind each\r\nattr-name to the object bound to that attr-name in module-name. (4) bind each\r\nalt-name to the object bound to the preceding attr-name in module-name. (5)\r\nbind each name that is bound in module-name to the same object it is bound to\r\nin module-name.\r\n\r\nImport (like an assignment, and a def, and a class definition) creates a name\r\n(if that name is not already in the namespace) and binds it to an object: the\r\n\"import module-name\" form binds names to module objects; the \"from module-name\r\nimport\" form binds names to objects (instances, functions, modules, classes,\r\netc.) defined inside modules (so now two modules contain names -maybe the same,\r\nmaybe different, depending on which of form 3 or 4 is use- bound to the same\r\nobjects).\r\n\r\nThe key idea as to which kind of import to use is to make it easy to refer to a\r\nname but not pollute the name space of the module doing the importing with too\r\nmany names (which might conflict with other names in that module).\r\n\r\nIf a lot of different names in the imported module are to be used, or we want\r\nto make it clear when an attribute name in another module is used, use the\r\n\"import module-name\" form (1) and then qualify the names when used: for example\r\n\r\n  import random\r\n  # use:  random.choice(...)  and  random.randint(...)\r\n\r\nIf the imported module-name is too large for using repeatedly, use an\r\nabbreviaton by importing using an alt-name (2) : for example\r\n\r\n  import high_precision_math as hp_math\r\n  # use:  hp_math.sqrt(...)\r\n\r\nIf only one name (or a few names) are to be used from a module, use the\r\nform (3):\r\n\r\n  from random import choice, randint\r\n  # use: choice(...)  and  randint(...)\r\n\r\nAgain, use alt-name to simplify either form, if the name is too large and\r\nunwieldy to use. Such names are often very long to be clear, but awkward to use\r\nmany times at that length. Generally we should apply the Goldilocks principle:\r\nname lengths shouldn't be too short (devoid of meaning) or too long (awkward to\r\nread/type) but their length should be \"just right\". Better to make them too\r\nlong, because there are ways (such as alt-name) to abbreviate them.\r\n\r\nWe almost never write the * form of importing. It imports all the names defined\r\nin module-name, and \"pollutes\" our namespace by defining all sorts of names we\r\nmay or may not use (and even worse, which might conflict and redefine names that\r\nwe have already defined). Better to explicitly import the names needed/used.\r\nEclipse marks with a warning any names that are imported but unused.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDirectly iterating over values in a list vs.\r\n  Using a range to iterate over indexes of values in a list\r\n\r\nWe know that we can iterate (with a for loop) over ranges: e.g., if alist is a\r\nlist, we can write\r\n\r\nalist = [5, 2, 3, 1, 4, 0]\r\nfor i in range(len(alist)):          # same as for i in range(0,len(alist)):\r\n    print(alist[i])\r\n\r\nHere i takes on the values 0, 1, ... , len(alist)-1 but not len(alist), which\r\nis 6. The code above prints all six values in alist: alist[0], alist[1], ....\r\nalist[5].\r\n\r\nOften we want to iterate over all the values in a list (alist) but don't need to\r\nknow/use their indexes at all: e.g., to print all the values in a list we can\r\nuse the loop\r\n\r\nfor v in alist:\r\n    print(v)\r\n\r\nwhich is much better (simpler/clearer/more efficient) than the loop\r\n\r\nfor i in range(len(alist)):\r\n    print(alist[i])\r\n\r\nalthough both produce the same result. Generally, choose to write the simplest\r\nloop possible (the one with the fewest details) for all your code. Sometimes you\r\nmight write a loop correctly, but then realize that you can also write a\r\nsimpler loop correctly: change your code to the simpler loop. Sometimes (when\r\ndoing more complicated index processing) we must iterate over indexes. Always\r\ntry to use the simplest tool needed to get the job done.\r\n\r\nIn many cases where using range is appropriate, we want to go from the low to\r\nhigh value INCLUSIVELY. I have written function named irange (for Inclusive\r\nRANGE) that we can import from the goody module and use like range.\r\n\r\nfrom goody import irange\r\nfor i in irange(1,10):\r\n    print(i)\r\n\r\nprints the values 1 through 10 inclusive; range(1,10) would print only 1\r\nthrough 9. One goal for ICS-33 is to show you how to write alternatives to\r\nbuilt-in Python features; we will study how irange is written later in the\r\nquarter, but you can import and use it now (and examine its definition in the\r\ngoody module).\r\n\r\nI have also written frange in goody, which allows iteration over\r\nfloating point (not int) values.\r\n\r\nfrom goody import frange\r\nfor x in frange(0., 1., .5):\r\n    print(x)\r\n\r\nprints (iterating from 0 to 1 in steps of .5\r\n\r\n0.0\r\n0.5\r\n1.0\r\n\r\nThere are some interesting numerical issues to think about when we use floating\r\npoint number:\r\n\r\nfrom goody import frange\r\nfor x in frange(0., 1., .2):\r\n    print(x)\r\n\r\nwhich prints\r\n\r\n0.0\r\n0.2\r\n0.4\r\n0.6000000000000001\r\n0.8\r\n1.0\r\n\r\nPython tries to print floating point values simply, but sometimes it cannot\r\nexactly represent a value, so it prints a value that is a tiny bit lower or\r\nhigher. Don't be confused by such numbers.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nArguments and Parameters (and Binding): Terminology (much more details later)\r\n\r\nWhenever we DEFINE a function (and define methods in classes), we specify the\r\nnames of its PARAMETERS in its header (in parentheses, separated by commas).\r\nWhenever we CALL a function we specify the values of its ARGUMENTS (also in\r\nparentheses, separated by commas). The definition below\r\n\r\ndef f(x,y):\r\n    return x**y\r\n\r\ndefines a function of two parameters: x and y. When we define a function we\r\n(re)bind the function's name to the function's object. This is similar to what\r\nhappens when we write x = 1 (which (re)binds a name to a data object: an\r\ninstance of the int class; if we later write x = 2 we rebind x to a different\r\nobject).\r\n\r\nCalling  f(5,2*6) calls this function with two arguments: the arguments 5 and\r\n2*6 are evaluated (producing objects) and the values/objects computed from\r\nthese arguments (5 and 12) are bound to their matching parameters in the\r\nfunction header (and then the body of the function is executed). Therefore, \r\nfunction calls happen in three steps: \r\n  (1) evaluate the arguments\r\n  (2) bind the argument values (objects) to the parameter names\r\n  (3) execute the body of the function, using the values bound to the parameter\r\n      names; so parameters are names inside the name-space of the function,\r\n      along with any local variables the function defines.\r\n\r\nWe will discuss the details of argument/parameter binding in much more detail\r\nlater in these lecture notes, but in a simple example like this one, parameter/\r\nargument binding occurs sequential, binding the first evaluated argument to the\r\nfirst parameter, the second evaluated argument to the second parameter (etc.).\r\nIt is like writing: x = 5 and then y = 2*6 which binds the parameter x to the\r\nobject 5 and then the paramter y to the object 12.\r\n\r\nSometimes we can use the parameter of a function as an argument to another\r\nfunction call inside its body. If we define\r\n\r\ndef factorial_sum(a,b):\r\n    return factorial(a) + factorial(b)\r\n\r\nHere the parameters a and b of factorial_sum function are used as arguments in\r\nthe two calls in its body to the factorial function.\r\n\r\nParameters are always names. Arguments are expressions that evaluate to objects.\r\nVery simple expressions include literals (such as 1 and 'abc') and any names\r\nbound to values (such as a and b in the calls to factorial above).\r\n\r\nIt is important that you understand the distinction between the technical term\r\nPARAMETER and ARGUMENT, and that calling a function first BINDS that argument\r\nvalues to to their associated parameter names in the functon's  HEADER (we will\r\ndiscuss the exact rules later in this lecture note) and then EXECUTES the BODY\r\nof the function. Be familar with these related technical terms.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunction calls ... always include ()\r\n  how we can pass a function as an argument to another function\r\n\r\nAny time a reference to an object is followed by (...) it means to perform a\r\nfunction call on that object. Some objects will raise an exception if they do\r\nnot support function calls: writing 3() or 'abc'() will both raise exceptions.\r\nCalling 'abc'() raises the TypeError exception, with the description: 'str'\r\nobject is not callable.\r\n\r\nWhile this rule is simple to understand for the functions that you have been\r\nwriting and calling, there are some much more interesting ramifications of this\r\nsimple rule. Run the following code to define these three functions.\r\n\r\ndef double(x):\r\n    return 2*x\r\n\r\ndef triple(x):\r\n    return 3*x\r\n\r\ndef times10(x):\r\n    return 10*x\r\n\r\nNote that each def defines the name of a function and binds that name to the\r\nfunction object that follows it.\r\n\r\nIf we then wrote\r\n\r\nf = double\r\n\r\nthen f would become a defined name that is bound to the same (function) object\r\nthat the name double is bound to (like like writing y = x if x were bound to an\r\ninteger). The expression \"f is double\" would evaluate to True, because these\r\ntwo names are bound to the same function object.\r\n\r\nNote that there are no () in the code above, so there is no function CALL here:\r\nwe are just binding names to objects (that happen to be function objects). If\r\nwe instead wrote f = double(3), then Python would bind f to the int value 6.\r\n\r\nGiven the assignment f = double above, \r\n\r\nprint( f(5) )\r\n\r\nPython would print 10, just as it would if we wrote\r\n\r\n print( double(5) )\r\n\r\nbecause f and double refer to the same function object, and it makes no\r\ndifference whether we call that function object using the name f or double. The\r\nfunction call does not occur until we use (). Of course the () in print(...)\r\nmeans that the print function is also called: print's argument is the result\r\nreturned by calling f(5). So the two sets of () in th print( f(5) ) means that\r\nPython calls two functions while executing print.\r\n\r\nHere is a more intersting example, but using exactly the same idea.\r\n\r\nfor f in [double, triple, times10]:\r\n    print( f(5) )\r\n\r\nHere f is a variable that iterates over (is bound to) all the values in a list\r\n(we could also have used a tuple to store these three functions): each value in\r\nthe list is a reference to a function object (the objects referred to by the\r\nnames double, triple, and times10). This code in the loop's body prints the\r\nvalues computed by calling each of these function objects with the argument 5.\r\nNote that these functions are NOT called when creating the list (no parentheses\r\nthere!): the list is just built to contain references to these three function\r\nobjects: again, when their names are not followed by () there is no function\r\ncall. This code prints 10, 15, and 50.\r\n\r\nSee the \"Creating;/Using a List of Functions\" link on the Weekly Schedule to see\r\na picture of how this code works.\r\n\r\nUsing the same logic, we could also write a dictionary whose keys are strings\r\nand whose values are function objects, and then use a string as a key needed to\r\nretrieve and call its associated function object.\r\n\r\nfs = {'x2' : double, 'x3' : triple, 'x10' : times10}\r\nprint( fs['x3'](5) )\r\n\r\nHere fs is a dictionary that stores keys that are strings and associates each\r\nwith a function object: there are no calls to functions when building the\r\ndictionary for fs in the first statement - no (); we then can retrieve the\r\nfunction associated with any key (here the key 'x3') and then call the resulting\r\nfunction object (here fs['x3']) with the argument 5. Of course in the second\r\nstatement we use the () to call the function selected from the dictionary.\r\n\r\nWe can also pass (uncalled) functions as arguments to other functions.\r\n\r\n# p is a predicate: a 1-argument function returning a bool (True or False)\r\n# alist is a list of values on which p can be/is called\r\n# count_true returns the number ov values in alist for which p returns True\r\ndef count_true(p, alist): \r\n    count = 0\r\n    for x in alist:\r\n        if p(x):\r\n            count += 1\r\n\r\n    return count\r\n\r\nif we wrote the following (predicate is a module in the ICS-33 course library)\r\n\r\nfrom predicate import is_prime\r\n\r\n(which imports the is_prime function from the predicates module: a PREDICATE is\r\na function of one argument that returns a boolean value) then calling\r\n\r\n  count_true(is_prime, [2,3,4,5,6,7,8,9,10])\r\n\r\nreturns 4: only the numbers 2, 3, 5, and 7, are prime. \r\n\r\nNote that the parameter p is bound to the function object that is_prime is\r\nbound to (is_prime is not called when it is specified as an argument), and p\r\nis called many times inside the count_true function: one for each value in the\r\nlist. We call count_true a \"functional\" because it is passed a function as an\r\nargument.\r\n\r\nIn summary\r\n\r\ndef f(x):\r\n    return 2*x\r\n\r\nis really just a special syntax for creating a name f and binding it to a new\r\nfunction object (not using an = sign, which we normally using for defining\r\nnames).\r\n\r\nNote the difference between the following, which both print 6. Both g and f\r\nrefer to the same function object (by the \"is\" operator, f is g is True). The\r\ncall g(3) is calling the same function object as the call f(3).\r\n\r\nx = f(3)\r\nprint(x)\r\n\r\nand \r\n\r\ng = f\r\nprint(g(3))\r\n\r\nA large part of this course deals with understanding functions better, including\r\nbut not restricted to function calls: the main thing -but not the only thing-\r\none does with functions; the other main things are passing functions as\r\narguments to other functions (as in count_true) and returning functions from\r\nother functions (discussed soon).\r\n\r\nSo, functions are objects just like integers are objects. Both can have one or\r\nmore names bound to them. In fact, is some branches of mathematics 3 is\r\nconsidered just the name of a parameterless function: we can call 3() to get\r\nits value (although don't try this in Python). \r\n\r\n------------------------------------------------------------------------------\r\n\r\nScope: Global and Local Names (generalized in the next section)\r\n\r\nThe topic of SCOPE concerns the visibility of variable names: when a name is\r\nwritten in Python code, to what definition of that name does it refer. In this\r\nsection, we discuss whether naming a variable in a simple context refers to a\r\nname defined in the global scopre or local scope; in the next, we generalize\r\nthis principle in a powerful way, allowing for the creation of functions that\r\nreturn other functions.\r\n\r\nNames defined in a module are global definitions; names defined in a function\r\n(including its parameters, and later names defined in a class) are local\r\ndefinitions. In a module, we can refer to global names, but not any local names\r\ninside the functions/class that are define there. In functions we can refer\r\nboth to their local names or to global names. Of particular interest is what\r\nhappens when a name is defined bothglobally and locally.\r\n\r\nHere are Python's rules (not all the rules yet, but the ones we focus on\r\nnow, and correct/expand later), which we will discuss and illustrate below.\r\n\r\n  1) A name used (to lookup or bind) in a module is global\r\n\r\n  2) A name used (to lookup or bind) in a function is global if \r\n      a) that name is explicitly declared global (e.g., global x) PRIOR to its\r\n           use in the function, OR\r\n      b) that name is only looked-up (and never bound) in the function\r\n\r\n  3) A name used (to lookup or bind) in a function is local, otherwise\r\n       (e.g., bound in a function AND not declared global before its use)\r\n       \r\nAs a result of these rules, all uses of a name in a given function must be the\r\nsame: all uses are global or all uses are local.\r\n\r\nLet's start by looking at Example 1: \r\n\r\nx = 1\r\nprint(x)\r\n\r\nwhich prints 1. Here the module defines a global name x (by rule 1) and binds\r\nit to the object 1 and prints the value bound to that global name.\r\n\r\nNow let's look at Example 2: \r\n\r\nx = 1\r\ndef f():\r\n    print(x)\r\n\r\nf()\r\nprint(x)\r\n\r\nwhich prints 1 and then 1. Here the module defines a global name x (by rule 1)\r\nand binds it to the object 1; then it defines a global name f (by rule 1) and\r\nbinds it to a function object: note the function uses the name x, which is\r\nglobal (by rule 2b). When we call f(), it prints the value bound to the global\r\nname x. Then, returning to the module, it prints the value bound to the global\r\nname x (again, by rule 1).\r\n\r\nIn this example, all the uses (there is just one) of x inside the function is\r\nglobal.\r\n\r\nNow let's look at Example 3: \r\n\r\nx = 1\r\ndef f():\r\n    x = 2\r\n    print(x)\r\n\r\nf()\r\nprint(x)\r\n\r\nwhich prints 2 and then 1. Here the module defines a global name x (by rule 1)\r\nand binds it to the object 1; then it defines a global name f (by rule 1) and\r\nbinds it to a function object: note the function uses the name x twice, which\r\nis local (by rule 3: it is bound in the function and is not declared global in\r\nthe functioni). When we call f(), it binds the local name x to 2 and then\r\nprints the value bound to the local name x. Then, returning to the module, it\r\nprints the value bound to the global name x (by rule 1), which is still 1.\r\n\r\nWhat is the primary difference between this example and the preceding one? Here,\r\nboth uses of the name x in this function are local (not global).\r\n\r\nNow let's look at Example 4: \r\n\r\nx = 1\r\ndef f():\r\n    y = 2\r\n    print(x,y)\r\n\r\nf()\r\nprint(x)\r\n\r\nwhich prints 1 2 and then 1. Here the module defines a global name x (by rule 1)\r\nand binds it to the object 1; then it defines a global name f (by rule 1) and\r\nbinds it to a function object: note the function uses the names x and y; x is\r\nglobal (by rule 2b) and y is local (by rule 3). When we call f(), it binds the\r\nlocal name y to 2 and then prints the values bound to the global name x and the\r\nlocal name y. Then, returning to the module, it prints the value bound to the\r\nglobal name x (by rule 1).\r\n\r\nNote that if we replaced print(x) at the end of the module with print(x,y)\r\nPython would raise a NameError exception because there is no global name y;\r\ny is a local name defined only in the function f.\r\n\r\nSomething interesting happens by the rules above, if we try to get function f\r\nto not only print the original value of the global name x, but also try to\r\nrebind that global name to 2. Let's see why this fails to be the effect of the\r\ncode below (later we will see how to accomplish this task). In fact, it fails in\r\nan interesting way.\r\n\r\nNow let's look at Example 5: \r\n\r\nx = 1\t\t\t# wrong code to print a global and then change it\r\ndef f():\t\t# wrong code to print a global and then change it\r\n    y = 2\t\t# wrong code to print a global and then change it\r\n    print(x,y)\t\t# wrong code to print a global and then change it\r\n    x = 2\t\t# wrong code to print a global and then change it\r\n      \t\t\t# wrong coed to print a global and then change it\r\nf()   \t\t\t# wrong code to print a global and then change it\r\nprint(x)\t\t# wrong code to print a global and then change it\r\n\r\nHere, the module defines a global name x (by rule 1) and binds it to the object\r\n1; then it defines a global name f (by rule 1) and binds it to a function\r\nobject: note the function uses the names x and y; x is local (by rule 3; it is\r\nbound in the function and not declared global) and y is local (also by rule 3,\r\nditto). When we call f(), it binds the local name y to 2 and then tries to\r\nprint the values bound to the local names x and y; but here there is no binding\r\n(yet) for x -even though Python knows that x must be local- so Python raises the\r\nUnboundLocalError exception: local variable 'x' referenced before assignment.\r\n\r\nSo, it does NOT look-up x as a global in the print and then define x as a local!\r\nThe name x is either always global or always local in a function.\r\n\r\n---------------\r\nIf we put the x = 2 before the print, it doesn't raise an exception, but doesn't\r\nrebind the global name x either.\r\n\r\nNow let's look at Example 6: \r\n\r\nx = 1\t\t\t# wrong code\r\ndef f():\t\t# wrong code\r\n    y = 2\t\t# wrong code\r\n    x = 2\t\t# wrong code\r\n    print(x,y)\t\t# wrong code\r\n    \t\t\t# wrong code\r\nf()   \t\t\t# wrong code\r\nprint(x)\t\t# wrong code\r\n\r\nPython would print 2 2 and then 1. Here, the module defines a global name x\r\n(by rule 1) and binds it to the object 1; then it defines a global name f (by\r\nrule 1) and binds it to a function object: note the function uses the names x\r\nand y; x is local (by rule 3; it is bound in the function and not declared\r\nglobal) and y is local (also by rule 3, ditto). When we call f(), it binds the\r\nlocal name y to 2 and binds the local name x to 2. Then it print the values\r\nbound to the local names x and y. Then, returning to the module, it prints the\r\nvalue bound to the global name x (which has remained bound to 1).\r\n---------------\r\n\r\nWe can change the value in the global name x by using a \"global\" declaration\r\nbefore x is used inside f. This declaration means that x should always be\r\ntreated as a global name inside this function (whether it is examined or\r\nbound to an object, or both) by rule 2.\r\n\r\nNow let's look at Example 7: \r\n\r\nx = 1\r\ndef f():\r\n    global x\r\n    y = 2\r\n    print(x,y)\r\n    x = 2\r\n\r\nf()\r\nprint(x)\r\n\r\nPython would print 1 2 and then print 2 (thus changing the global name x).\r\n\r\nHere, the module defines a global name x (by rule 1) and binds it to the object\r\n1; then it defines a global name f (by rule 1) and binds it to a function\r\nobject: note the function uses the names x and y; x is global (by rule 2a; it is\r\ndeclared global) and y is local (by rule 3, it is bound in the function but not\r\ndeclared global). When we call f(), it binds the local name y to 2 and then\r\nprints the values bound to the global name x and the local name y. Then it\r\nrebinds the global name x to 2. Finally, returning to the module, it prints the\r\nvalue bound to the global name x (which has now been rebound to 2).\r\n\r\nSo, if a function must (re)bind a global name, the functioin must explicitly\r\ndeclare that name global.\r\n\r\nNote that we we wrote \"global x\" after print(x,y) in f, this x would be\r\nconsidered a local name (rule 2a does not apply), so Python would instead raise\r\na SyntaxError: name 'x' is used prior to global declaration.\r\n\r\nTo repeat, when Python creates an function object, it first scans the whole\r\nfunction to determine whether a name refers to a global name or a local\r\nname, looking for global declarations and bindings to make this determination,\r\nusing the rules stated above. The rule for 2a hinges on the word PRIOR. So if\r\nis declared global subsequent to its first use, it is considered to be in error.\r\n\r\nIn summary, we can always lookup (find the value of, evaluate) a global name\r\ninside a function to find its value without doing anything special, but if we\r\nwant to (re)bind the global name to a new value inside the function, we must\r\ndeclare the name global somewhere in the function (before its first use). If we\r\nforget to declare the name global and (re)bind the name, Python will instead\r\ndefine it as a local name (rule 3) and all occurrences of that name in the\r\nfunction will use it as a local name (so it better be defined first).\r\n\r\nWhat do you think the following code will do? Notice that is similar to the code\r\nabove, but it does not define a global name x before defining f. Can you explain\r\nwhy (in terms of the rules) it does what it does?\r\n\r\nNow let's look at Example 8: \r\n\r\ndef f():\r\n    global x\r\n    x = 2\r\n    y = 2\r\n    print(x,y)\r\nf()\r\nprint(x)\r\n\r\nAlso can you explain what would happen if the print statement print(x,y) were\r\nmoved between the statements y = 2 and x = 2, ore moved before both?\r\n\r\nBottom Line: You should understand how Python decides whether names in a\r\nfunction are global or local. TYPICALLY, no global names should be used: all\r\ninformation that a function uses should be passed into the function and bound to\r\nits parameters. BUT if a function must (re)bind a global name either\r\n\r\n  (1) the name should be declared global (so it can be examined/changed), or \r\n\r\n  (2) the function should be called like global-name = f(...) so that the\r\n      global name is not declared/changed as a global inside the function, but \r\n      is instead changed as a result of an assignment statement made after\r\n      calling the function. We can even use this mechanism for rebinding\r\n      multiple global names: gn1, gn2, ..., gnN = f(...) where f returns an\r\n      N-tuple or N-list (see the Parallel/Tuple/List Assignment -aka sequence\r\n      unpacking- section below).\r\n\r\nProblem 1: Explain why we cannot write a general function in Python that\r\nexchanges the references in its argument names. That is, we cannot write\r\ndef f(x,y):\r\n  ...\r\nsuch that\r\na = 1\r\nb = 2\r\nf(a,b)\r\nprint(a,b) # prints 2 and 1\r\n\r\nSuch a function canno be written in Java, but can be written in C++.\r\n\r\nProblem 2: Write a SPECIFIC function in Python that exchanges the references\r\nONLY FOR THE NAMES a AND b. That is,\r\n\r\ndef f():\r\n  ...\r\nsuch that\r\na = 1\r\nb = 2\r\nf()\r\nprint(a,b) # prints 2, and 1\r\n\r\nProblem 3: Write a GENERAL function in Python that we can CALL IN A SPECIAL WAY\r\nto exchanges the references of its two argument names. Hint: read the paragraph\r\nabove.\r\n\r\ndef f(x,y):\r\n  ...\r\na = 1\r\nb = 2\r\n# some Python statement, calling f(a,b) such that\r\nprint(a,b) # prints 2, and 1\r\n\r\nThese local/global rules are generalized in the next section to include 4\r\ndifferent locations/scopes: LEGB\r\n  1) functions (Local scope)\r\n  2) enclosing functions (Enclosing scope)\r\n  3) modules (Global scope)\r\n  4) the special builtins module (Builtins scope)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nGeneralizing Scope: Local, Enclosing, Global, and Builtins\r\n(applicaton: a function call that return a reference to a function object)\r\n\r\nLook at the following functions, which all define a local function (and define\r\nlocal variables too), and then return the value of that local function. This\r\nfeature in Python (and the feature of passing function objects as arguments to\r\nparameters; see the count_true function defined earlier) are very powerful and\r\nuseful. In this section, we will generalize the scope rules discused above and\r\nlearn how these new rules apply when functions defined in functions are called).\r\n\r\ndef bigger_than(age):\r\n    def test_it(x):\r\n        return x > age\r\n\r\n    return test_it\r\n\r\ndef running_average1():\r\n    data = []              # Mutated, but not rebound, in include\r\n\r\n    def include_it(x):\r\n        data.append(x)     #   mutate data's list\r\n        return sum(data)/len(data)\r\n\r\n    return include_it\r\n\r\ndef running_average2():\r\n    sum   = 0              # Mutated, but not rebound, in include\r\n    count = 0              # Mutated, but not rebound, in include\r\n\r\n    def include_it(x):\r\n        nonlocal sum,count\r\n        sum += x           #   rebind sum\r\n        count+= 1          #   rebind count\r\n        return sum/count\r\n\r\n    return include_it\r\n\r\n\r\nNote that the body of these functions, and the bodies of their inner functions\r\n(test_it and include_it) can also use global names (as discused in the last\r\nsection); but none of these do, which follows good practice for defining any\r\nfunctions.\r\n\r\nWe will now write the complete rules Python uses to look up and bind names.\r\nThes rules generalizes what we learned in the previous section: we will now\r\ndefine any name in a function as either local, nonlocal/encloseing, global, or\r\nLEGB; then we will learn how such names are looked-up and bound. Here are the\r\nrules from the previous sections, restated and extended using these new terms.\r\nWe separate rules into how names are classified and how they are\r\nlooked-up/bound.\r\n\r\n  1) A name used in a module is global\r\n\r\n  2) A name used in a function is global if that name is explicitly declared\r\n      global (e.g., global x) PRIOR to its use in the function\r\n\r\n  3) A name used in a function is nonlocal/enclosing if that name is explicitly\r\n      declared nonlocal (e.g., nonlocal x) prior to its use in that function\r\n\r\n  4) A name used in a function is local\r\n       a) that name is a parameter in that function, or\r\n       b) that name is bound anywhere in that function (and is neither declared\r\n          global nor nonlocal)\r\n\r\n  5) Otherwise, a name is LEGB (if it is none of the above)\r\n     NOTE: an LEGB name can NEVER be bound in a function (if it is bound, it\r\n       must be declared global, or nonlocal, or will be local by 4a or 4b). \r\n     So LEGB names are ONLY LOOKED-UP.\r\n\r\nIf we import a module name (call it M), then we can lookup/rebind any global\r\nname defined in that module (call it n) by writing M.n: e.g., print(M.n) or\r\nM.n = ...\r\n\r\nHere are the corresponding rules for looking-up/binding all these names.\r\n\r\n  A+B) When a name is global,\r\n       1) Python LOOKS UP that name, in order, \r\n             a) in the Global scope; and if not found\r\n             b) in the Builtins scope (in the builtins module); and if not found\r\n             c) raises NameError\r\n       2) Python BINDS that name in the Global scope\r\n     \r\n  C) When a name is nonlocal/enclosing, Python looks for the name in the scope\r\n     of the function enclosing it (if there is one); if it doesn't find it\r\n     there, it looks in the scope of the function enclosing the enclosing\r\n     function (if there is one). This process continues outward until it finds\r\n     the name and then uses the name in that scope. If it cannot find the name\r\n     and reaches the global scope, Python raises a SyntaxError exception: no\r\n     binding for nonlocal ... found\r\n\r\n  D) When a name is local, Python looks-up/binds that name in the local scope.\r\n\r\n  E) When a name is LEGB, Python looks for the name, in order,\r\n       1) in the        Local scope of the function; and if not found \r\n       2) in any of the Enclosing scopes (see rules in C); and if not found\r\n       3) in the        Global scope; and if not found\r\n       4) in the        Builtins scope(in the builtins module); and if not found\r\n       5) raises NameError\r\n\r\nFor example, the code\r\n\r\nx = 1\r\ndef f(y):\r\n    print(x,y)\r\n\r\nf(2)\r\nprint(x)\r\n\r\nprints 1 2 and then 1. Here the module defines a global name x (by rule 1)\r\nand binds it to the object 1; then it defines a global name f (by rule 1) and\r\nbinds it to a function object: note the function uses the names print, x and y\r\n(yes, now we even look at where the name print comes from); print is LEGB (by\r\nrule 5), x is LEGB (by rule 5) and y is local (by rule 4a). After the function\r\ndefinition the name f is global (by rule 1) and the the name print is LEGB (by\r\nrule 5) and the name x is global (by rule 1).\r\n\r\nWhen we call f(2),\r\n\r\nPython looks up the global name f and finds it in the global scope where it is\r\ndeclared and calls that function, first binding its local name y to the object\r\n2; then it executes the body of the function. It looks up the object associated\r\nwith the LEGB name print (which it finds not in the local scope, not in an\r\nenclosing scope -there is none-, not in the global scope, but finally in the\r\nbuiltins scope): the print function is defined in the builtins module. It then\r\ncalls the print function after looking up the binding of the LEGB name x (which\r\nit finds not in the local scope, not in an enclosing scope -there is none-, but\r\nfinally in the global scope, with a binding 1) and the local name y (it finds\r\nits binding 2, in the local scope). After printing 1 2 the function terminates.\r\n\r\nNow, Python looks up the object associated with the global name print (which it\r\nfinds not in the global scope, but in the builtins scope). It then looks up the\r\nglobal name x (which it finds in the global scope, with a binding of 1) and\r\ncalls the print function, printing the value 1. The module then terminates.\r\n\r\n******\r\nThis is an incredibly detailed explanation of what happens, but it is an\r\naccurate description. We will do many more examples in class, but it is up to\r\nyou to study these and be able to know/describe/hand-simulate exactly what\r\nhappens.\r\n******\r\n\r\n-----Back to understand a function defined in a function\r\n\r\nNow let's return to the three concrete examples of a function defined inside a\r\nfunction. None of these functions use global or builtin names, so all names are\r\ndefined locally or nonlocally (in an enclosing scope, found by the LEGB rule).\r\n\r\nThe first is function is\r\n\r\ndef bigger_than(age):\r\n    def test_it(x):\r\n        return x > age\r\n\r\n    return test_it\r\n\r\nNote that inside the function bigger_than, age is a local name (this name is\r\nused only inside test_it). Inside the function test_it, x is a local name and\r\nage is an LEGB name (by rule 5); this is the only place age is used.\r\n\r\nLets look at the following sequence of statements\r\n\r\nold = bigger_than(60)\r\nprint(old(65))\r\n\r\nPython executes the first statement by calling bigger_than and then binding the\r\nobject that it returns to the variable name old. When calling bigger_than, \r\nPython first binds the argument 60 to the parameter age, and then executes its\r\nbody, whose two statements\r\n\r\n  (1) define test_it to refer to a NEW function object (new each time\r\n      bigger_than is called). That function object, being enclosed in\r\n      bigger_than, stores a CLOSURE consisting of all the local variables and\r\n      their bindings in bigger_than: here just age bound to 60. A function\r\n      stores a closure only if it is defined inside an enclosing function, so\r\n      global functions store no closures. We can think of a closure as just a\r\n      dictionary storing variable names and their current bindings.\r\n\r\n  (2) return a reference to the function object bound to the local variable\r\n      test_it. In the statement above, the global name old is bound to this\r\n      returned function object.\r\n\r\nWhen old(65) is called, Python first binds the argument 65 to the parameter x,\r\nand then executes old's body. It is just one return statement, which compares\r\nthe local name x to the LEGB name age; it looks-up the value for age inside the\r\nclosure of old's function object (where age is bound to 60). Since 65>60\r\nevaluates to True, old(65) returns True, which is printed. (*of course, the\r\nbinding of the parameter x inside this function call is 65).\r\n\r\nSee a link to the picture of a Function returning a function in the lectures\r\nand/or weekly schedule on the course website.\r\n\r\nIf we wrote the following\r\n\r\nold     = bigger_than(60)\r\nancient = bigger_than(90)\r\nprint (old(10), old(70), old(90), ancient(70), ancient(95))\r\n\r\nPython prints: False True True False True\r\n\r\nEach assignment statement binds its name (old and ancient) to a different\r\nfunction object that is created/returned by different calls to the bigger_than\r\nfunction. Each of these function objects has its own closure: age is bound to\r\n60 in old's function object's closure; age   s bound to 90 in ancients's\r\nfunction object's closure. So the LEGB name age in each different function will\r\nget its value from a different closure, so the functions can return different\r\nresults.\r\n\r\nIn fact, we even could have avoided the local variable old and written\r\n\r\nprint ( bigger_than(60)(70) )\r\n\r\nWe know that bigger_than(60) calls bigger_than with the argument 60, which\r\nreturns a result that is a reference to its inner function test_it in whose\r\nclosure age is bound to 60; so by writing (70) after that, we are just calling\r\ntht returned function object (the one bigger_than(60) returned). When calling\r\nthis returned function object using the argument 70, it returns True.\r\n\r\nIn the function \r\n\r\ndef running_average1():\r\n    data = []              # Mutated, but not rebound, in include\r\n\r\n    def include_it(x):\r\n        data.append(x)     #   mutate data's list\r\n        return sum(data)/len(data)\r\n\r\n    return include_it\r\n\r\nthe include_it function refers to data, which is an LEGB name, multiple times.\r\nNote that it is an LEGB name in include_it, because it is not bound in that\r\nfunction. So, each time running_average1 is called, it creates and returns a\r\nnew function object bound to include_it, whose closure will contain the name\r\ndata bound to an empty list. Each time we call it, it will mutate data by\r\nappending another value to it, and returning the average of all the values it\r\nhas been called with (now in the list). For example\r\n\r\nmileage_per_tank = running_average1()\r\nprint(mileage_per_tank(300))\r\nprint(mileage_per_tank(200))\r\nprint(mileage_per_tank(400))\r\n\r\nprints  300 (300/1), 250((300+200)/2), and 300 ((300+200+400)/3)\r\n\r\nSo, using functions returning functions, a function can remember information\r\nfrom its previous calls! It stores such information in the closure for its\r\nenclosing function (why the name \"closure\" is meaningful).\r\n\r\nFinally, in the function\r\n\r\ndef running_average2():\r\n    sum   = 0              # Mutated, but not rebound, in include\r\n    count = 0              # Mutated, but not rebound, in include\r\n\r\n    def include_it(x):\r\n        nonlocal sum,count\r\n        sum += x           #   rebind sum\r\n        count+= 1          #   rebind count\r\n        return sum/count\r\n\r\n    return include\r\n\r\nthe include_it function refers to sum and count, which because they are BOUND\r\ninside include_it (using +=) would normally be local names. But as local names\r\nthey would not be initialized and cause an error. Instead, we want the\r\ninclude_it function to use the sum/count initialized in running_average2, so\r\nwe explicitly declare them nonlocal, so their values will be LOOKED-UP and\r\nREBOUND in the closure for the running_averqage2 function call in which the\r\ninclude_it function was created.\r\n\r\nSo, each time running_average2 is called, it creates and returns a new function\r\nobject bound to include_it, whose closure will contain the names sum and count\r\nbound to 0. Each time we call it, it will rebind sum and count by incrementing\r\nthem, and returning the average of all the values it has been called with.\r\nThi function has the same behavior as running_average1 by storing just two\r\nintegers, without having to remember a list of values. But doing so requires\r\nnonlocal variables.\r\n\r\nThe bottom line here is that there are complicated rules that govern the scope\r\nof variable names. But they are often used in stardard ways, to get powerful \r\nbehavior from simple Python code.\r\n\r\nProblem: Predict what the following prints. Drawing a diagram might help.\r\n\r\ndef f():\r\n    prev = None\r\n    \r\n    def g1(x):\r\n        nonlocal prev\r\n        temp = prev\r\n        prev = x+5\r\n        return temp\r\n    def g2(x):\r\n        nonlocal prev\r\n        temp = prev\r\n        prev = 5*x\r\n        return temp\r\n    return g1,g2\r\n\r\nf1,f2 = f()\r\nf3,f4 = f()\r\nprint(f1(1))\r\nprint(f2(2))   \r\nprint(f3(5))\r\nprint(f4(6))\r\n\r\nProblem: What would the difference be if we defined a global vaiable prev = 100\r\nand change the nonlocal declaration in g2 to be a global declaration?\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunctions vs Methods: The Fundamental Equation of Object-Oriented Programming\r\n\r\nFunctions are typically called f(...) while methods are called on objects like\r\no.m(...). Think of x ='candide' followed by calling print(x.replace('d','p'))\r\n\r\nIn reality, a method call is just a special syntax to write a function\r\ncall. The special \"argument\" o (normally arguments are written inside the\r\nparentheses) prefixes the method name. Functions and methods are related by\r\nwhat I call \"The Fundamental Equation of Object-Oriented Programming.\"\r\n\r\n  o.m(...)     =     type(o).m(o,...)\r\n\r\nOn the right side\r\n  1) type(o) returns a reference to the class object o was constructed from.\r\n  2) .m means call the function m declared inside that class: look for\r\n       def m(self,...): .... in the class\r\n  3) pass o as the first argument to m: recall, that when defining methods in\r\n       classes we write def m(self, ....); where does the argument matching the\r\n       self parameter come from? It comes from the object o in calls like\r\n       o.m(...)\r\n\r\nSo, calling 'candide'.replace('d','p') is exactly the same as calling\r\nstr.replace('candide','d','p'), because type('candide') returns a reference to\r\nthe str class, which defines many string methods, including the replace method.\r\n\r\nHow well do you understand self (or your-self, for that matter:)? This equation\r\nis the key. I believe a deep understanding of this equation is the key to\r\nclarifying many aspects of object-oriented programming in Python (whose objects\r\nare constructed from classes). Just my two cents. But we will often return to\r\nthis equation throughout this course. I've never seen any books that talk about\r\nthis equation explicitly. We will revisit FEOOP when we spend a week discussing\r\nhow to write more sophisticated classes than the ones you wrote in ICS-32.\r\n\r\nOh, by the way, I must say that this equation is true, but not completely true.\r\nAs we will later see: (a) if m is in the object o's namespaces, it will be\r\ncalled directly (bypassing looking in o's class/type), and (b) when we learn\r\nabout class inheritance, the inheritance hierarchy of a class provides other\r\nclasses in which to look for m if it is not declared directly in o's class/type.\r\nSo, as in courtroom testimony, we need to distinguish the truth, the whole\r\ntruth, and nothing but the truth.\r\n\r\nBut this equation is so simple, clear (once you understand it), and useful\r\nfor tons of examples, it is worth memorizing, even if it is not completely\r\naccurate (yet).\r\n\r\n------------------------------------------------------------------------------ \r\n\r\nlambda:\r\n\r\nLambdas are used in expressions where we need a very simple function. A lambda\r\nrepresents a special function object. Instead of defining a full function (with\r\na def and a name for it), we can just use a lambda: after the word lambda comes\r\nits parameters separated by commas, then a colon followed by a single EXPRESSION\r\nthat computes the value of a lambda (no \"return\" is needed, and the function\r\ncannot include control structures/statments, not even a sequence of statements).\r\n\r\nSo, writing ...(lambda x,y : x+y)... in some context\r\n\r\nIs just like first defining\r\n\r\ndef f(x,y):\r\n    return x+y\r\n\r\nand then writing ...f... in the same context. That is calling\r\nprint( (lambda x,y : x+y)(2,3) ) is the same as calling print( f(2,3) ).\r\n\r\nA lambda produces an UNNAMED function object. For example, we can also write the\r\nfollowing code, whose first line binds to the name f the unnamed lambda/function\r\nobject, and whose second line calls the unnamed lambda object via the name.\r\n\r\ng = lambda x,y : x+y  # lambdas have one expression after : without a return\r\nprint( g(1,3) )\r\n\r\nand Python will print 4. I often put lambdas in parentheses, to more clearly\r\ndenote the start and end of the lambda, for example writing\r\n\r\ng =  (lambda x,y : x+y)\r\n\r\nUsing this form, we can write code code above without defining g, writing just\r\n\r\nprint( (lambda x,y : x+y)(1,3) )\r\n\r\nIn my prompt module (MY PREFERRED WAY OF DOING PYTHON USER-INPUT), there is a\r\nfunction called for_int that has a parameter that specifies a boolean function\r\n(a function taking on argument and returning a boolean value: we will repeated\r\nuse the word predicate for this kind of function) that the int value must\r\nsatisfy, to be returned by the prompt (otherwise the for_int function prompts\r\nthe user again, for a legal value).\r\n\r\nThat is, we pass a function object (without calling it) to prompt.for_int,\r\nwhich CALLS that function on the value the user enters to the prompt, to verify\r\nthat the function returns True for that value.\r\n\r\nSo the following code fragment is guaranteed to store a value between 0 to 5\r\ninclusive in the variable x. If the user enters a value like 7, an error will\r\nbe printed and the user reprompted for the information.\r\n\r\nimport prompt\r\nx = prompt.for_int('Enter a value in [0,5]', is_legal = (lambda x : 0<=x<=5))\r\nprint(x)\r\n\r\nExecute this code in Python.\r\n\r\nIn a later part of this lecture note, we will see how to use lambdas to\r\nsimplify sorting lists (or simplify iterating through any data structures\r\naccording to an ordering function).\r\n\r\nAgain, I often put lambdas in parentheses for clarity: see the prompt.for_int\r\nexample above. But there are certain places where lambdas are required to be in\r\nparentheses: assume def g(a,b): ... and the lambda below will receive a 2-tuple\r\nas an argument and return the reversed 2-tuple. Calling\r\ng( 1, (lambda x : x[1],x[0]) ) requires the lambda to be in parentheses, because\r\nwithout the parentheses it would read as g( 1, lambda x : x[1],x[0] ). In this\r\nfunction call, Python would think that x[0] was a third argument (not part of\r\nthe lambda) to function g, which would raise an exception when called, because\r\ng defined only two parameters. Of course, we could also use different\r\nparentheses in the call and write g( 1, lambda x : (x[1],x[0]) ). We also wrote\r\nthis call above as g( 1, (lambda x : x[1],x[0]) ). In both cases the\r\nparentheses remove the ambiguity.\r\n\r\nIn a previous section (functions returning functions) we wrote the code\r\n\r\ndef bigger_than(age):\r\n    def test_it(x) :\r\n        return x > age\r\n    return test\r\n\r\nWe defined the test_it function just so we could return a reference to it. Now,\r\nbecause the test_it function is so simple, and the only place we refer to it by\r\nname is in the return statement, we can simplify this code by returning a\r\nlambda instead of defining/returning a named function:\r\n\r\ndef bigger_than(age) :\r\n    return (lambda x : x > age)\r\n\r\nSo, in each version of the bigger_than function, it returns a reference to a\r\nfunction object.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nParallel/Tuple/List Assignment (aka sequence unpacking)\r\n\r\nNote that we can write code like the following: here both x,y and 1,2 are\r\nimplicit tuples; and we can unpack them as follows\r\n\r\nx,y = 1,2\r\n\r\nIn fact, you can replace the left hand side of the equal sign by either (x,y) or\r\n[x,y] and replace the right hand side of the equal sign by either (1,2) or [1,2]\r\nand x gets assigned 1 and y get assigned 2: even (x,y) = [1,2] works correctly.\r\n\r\nIn most programming languages (including Java and C++), to exchange the values\r\nof two variables x and y we write three assignments (can you prove that writing\r\njust x = y followed by y = x fails to exchange these values?):\r\n\r\ntemp = x\r\nx    = y\r\ny    = temp\r\n\r\nProblem: why would x = y followed by y = x not do the swapping?\r\n\r\nIn Python we can write this code using one tuple assignment\r\n\r\nx,y = y,x\r\n\r\nTo do any parallel assignment, Python\r\n  (a) first computes all the values of the expressions/objects on the right\r\n        (1 and 2 from the top)\r\n  (b) second binds each name on the left (x then y) to these computed\r\n        values/objects (binds x to 2, then bind y to 1)\r\n\r\nThis is similar to how Python calls functions: first evaluating all the\r\narguments and then binding them to all the parameters.\r\n\r\nThis is also called \"sequence unpacking assignment\": both tuples and list are\r\nconsidered kinds of sequences (where order is important) in Python. Note that\r\nx,y = 1,2,3 and x,y,z = 1,2 would both raise ValueError exceptions, because\r\nthere are different numbers of names and values to bind to them. We will\r\nfrequently use simple forms of parallel/unpacking assignment when looping\r\nthrough items in dictionaries (illustated below; used extensively later in this\r\nlecture note), but even more complicated forms are possible: for example.\r\n\r\nl,m,(n,o) = (1, 2, [3,4])\r\nprint(l,m,n,o)\r\n\r\nprints: 1 2 3 4\r\n\r\nHere, each name is bound to one int value. Python also allows writing\r\n\r\na,*b,c = [1,2,3,4,5]\r\nprint(a,b,c)\r\n\r\nwhich prints as: 1 [2, 3, 4] 5\r\n\r\nHere, * can preface any name; the name is bound to a sequence of any number of\r\nvalues, so as to correctly bind a and c. That is, *b would need to bind to a\r\nsequence of all but the first and last value. We could not write\r\n\r\n*a,*b,c = [1,2,3,4,5]\r\n\r\nbecause there is no unique way to bind a, b, and c: for example a=1, b=[2,3,4],\r\nand c=5 works; but so does a=[1,2],b=[3,4],c=5. \r\n\r\nIn fact, we can write complicated parallel assignments with multiple *s like\r\n\r\nl,(*m,n),*o  = (1, ['a','b','c'], 2, 3,4)\r\nprint(l,m,n,o)\r\n\r\nso long as there is a unique way to decide what the * variables bind to.\r\n\r\nThe above statement prints as: 1 ['a', 'b'] c [2, 3, 4]\r\n\r\nGenerally sequence unpacking assignment is useful if we have a complex\r\ntuple/list structure and we want to bind names to its components, to refer to\r\nthese components more easily by these names: each name binds to part of the\r\ncomplicated structure.\r\n\r\nAs another example, if we define a function that returns a tuple\r\n\r\ndef reverse(a,b) :\r\n    return (b,a)    # we could also write just return b,a\r\n\r\nwe can also write x,y = reverse(x,y) to also exchange these values.\r\n\r\nFinally, one of the most common ways to use unpacking assignment is in for\r\nloops: for example, we can write the following for loop to print the sum of\r\neach triple in the list\r\n\r\nfor i,j,k in [(1,2,3), (4,5,6), (7,8,9)]:\r\n    print (i+j+k)\r\n\r\nthis is much simpler and clearer than using one name for the entire tuple, and\r\nthen indexing that one name.\r\n\r\nfor t in [(1,2,3), (4,5,6), (7,8,9)]:\r\n    print (t[0] + t[1] + t[2])\r\n\r\nThe loop above assigns i, j, and k the three values in each 3-tuple in the list\r\nthat the for loop is iterating over. We will see more about such assignments\r\nwhen  iterating though items in dictionaries. A preview is\r\n\r\nfor k,v in d.items():  #d is any dictionary\r\n    print(k,'->',v)    #  print its key and value pairs (abbreviated k,v)\r\n\r\nwhich prints each key and its associated value for each item (each key/value\r\nassociation) that we are iterating through in a dictionary.\r\n\r\nd = {'a':1, 'b':2, 'c':3, 'd':4}\r\nfor k,v in d.items():\r\n    print(k,'->',v)\r\n\r\nprints\r\n\r\nd -> 4\r\na -> 1\r\nc -> 3\r\nb -> 2\r\n\r\nalthough the keys/values may print in any order\r\n\r\nThis is simpler than the following loop, which iterates over the tuples\r\nproduced when iterating over d.items().\r\n\r\nfor t in d.items():         #d is any dictionary\r\n    print(t[0],'->',t[1])   #  print its key (t[0])and value (t[1]) pairs\r\n\r\nWhen you write for loops that loop over complicated data (as in dictionary\r\nitems), use multiple variables to name the indvidual parts of the data.\r\nMultiple names for the parts often make the loop body's code easier to write\r\nand understand. Students often fail to follow this advice and eventually get\r\ndocked points for writing code that is more complicated than needed.\r\n\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------ \r\n\r\nEnd of 1st Lecture on this material\r\n\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------ \r\n\r\nIterable\r\n\r\nWhen we specify that an argument of a function must be iterable, it might be one\r\nof the standard data structures in Python: str, list, tuple, set, dict. All\r\nthese data structures are iterable: we can iterate over the values they contain\r\nby using a simple for loop.\r\n\r\nBut we will learn other Python features (classes and generators) that are also\r\niterable. The difference is, that for standard Python data structures we can\r\ncall the \"len\" function on them and index them  [...]; but for general iterable\r\narguments we CANNOT call \"len\" nor index them: we can only iterate over their\r\nvalues with a for loop: getting the first value, the second value, etc. (never\r\nknowing when there won't be a next value). Later in the quarter we will learn\r\nhow to call iter and next explicitly on iterables; for loops implicitly call\r\nthese two functions on iterables.\r\n\r\nAlso, we can always use a comprehension (dicussed later in this lecture) to\r\ntransform any iterable into a list or tuple of its values, doing so takes up\r\nextra time and space, and should be avoided unless necessary. But learning how\r\nto convert an iterable into a list or tuple is instructive.\r\n\r\n------------------------------------------------------------------------------ \r\n\r\nsort (a list method)/sorted (a function): and their \"key\"/\"reverse\" parameters\r\n\r\nFirst, we will examine the following similar definitions of sort/sorted. Then we\r\nwill learn the differences between these similar and related features below.\r\n\r\n(1) sort is a method defined on arguments that are LIST objects; it returns\r\n      None but MUTATES its list argument to be in some specified order:\r\n      e.g., alist.sort() or alist.sort(reverse=True); note that calling\r\n      print(alist.sort()) sorts (mutates)  alist and prints None (sort's\r\n      returned value).\r\n\r\n(2) sorted is a function defined on arguments that are any ITERABLE object; it\r\n      returns a LIST of its argument's values, in some specified order. The\r\n      argument itself is NOT MUTATED: e.g., sorted(adict) or\r\n      sorted(adict,reverse=True). Neither changes adict to be sorted, because\r\n      dictionaries are never sorted; both produce a LIST of sorted keys in\r\n      adict. We can also call sorted with an argument that is a str, list,\r\n      tuple, set, ... anything that is iterable in Python.\r\n\r\nSo, the sort method can be applied only to lists, but the sorted function can\r\nbe applied to any iterable (str, list, tuple, set, dict, etc.) \r\n\r\nFor example, if votes is the list of 2-tuples (candidates, votes) below, we can\r\nexecute the following code.\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker', 20), ('Dog', 15)]\r\nvotes.sort()\r\nfor c,v in votes:                         # note parallel/unpacking assignment\r\n    print('Candidate', c, 'received', v, 'votes')\r\nprint(votes)\r\n\r\nThe call votes.sort() uses the sort METHOD to sort the LIST (MUTATE it); then\r\nthe for loop iterates over this newly-ordered list and prints the information\r\nin the list in the order it now appears. When the entire votes list is printed\r\nafter the loop, we see the list has been MUTATED and is now sorted. It prints\r\n\r\nCandidate Able received 10 votes\r\nCandidate Baker received 20 votes\r\nCandidate Charlie received 20 votes\r\nCandidate Dog received 15 votes\r\n[('Able', 10), ('Baker', 20), ('Charlie', 20), ('Dog', 15)]\r\n\r\nWe will see why it sorts by name soon, and learn how to use the key argument to\r\nsort by anything else (say by votes).\r\nContrast this with the following code.\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nfor c,v in sorted(votes):                 # note parallel/unpacking assignment\r\n    print('Candidate', c, 'received', v, 'votes')\r\nprint(votes)\r\n\r\nHere we never sort/mutate the votes list. Instead we use the sorted FUNCTION,\r\nwhich takes an ITERABLE argument (a LIST is iterable) and returns a NEW LIST\r\nthat is sorted (leaving votes unchanged). Then we iterate over that returned\r\nlist to print its information (which is a sorted version of votes). But here,\r\nwhen we print the votes list at the end, we see that the votes list remained\r\nunchanged. It prints\r\n\r\nCandidate Able received 10 votes\r\nCandidate Baker received 20 votes\r\nCandidate Charlie received 20 votes\r\nCandidate Dog received 15 votes\r\n[('Charlie', 20), ('Able', 10), ('Baker', 20), ('Dog', 15)]\r\n\r\nThe sorted function can be thought of as first iterating over the parameter,\r\ncreating a temporary list; then sorting that temprorary list; and finally\r\nreturning the sorted temporary list: sorted mutates the list it creates\r\ninternally; it does not mutate the argument matching iterable.\r\n\r\nSo, we can think of the sorted function to be defined by\r\n\r\ndef sorted (iterable):\r\n  alist = list(iterable)  # create a list with all the iterable's values\r\n  alist.sort()\t\t  # sort that list using the sort method for lists\r\n  return alist\t\t  # return the sorted list\r\n\r\nQuestion: What would the following code do? If you understand the definitions\r\nabove, you won't be fooled and the answer won't suprise you. Hint: what does\r\nvotes.sort() return vs. sorted(votes)?\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nfor c,v in votes.sort():\r\n    print('Candidate', c, 'received', v, 'votes')\r\nprint(votes)\r\n\r\nIf we were going to print some list in a sorted form many times, it would be\r\nmore efficient to sort/mutate it once, and then use a regular for loop on that\r\nsorted list (either mutate the original or create a new, sorted list and use it\r\nmultiple time). But if we needed to keep the list in a certain order and care\r\nabout space efficiency and/or don't care as much about time efficiency, we\r\nwould not sort/mutate the list and instead call the sorted function whenever we\r\nneed to process the list in a sorted order.\r\n\r\nNote that if we store votes_dict as a dict data structure (a dictionary\r\nassociating candidates with the number of votes they received), and then tried\r\nto call the sort method on it, Python would raise an exception\r\n\r\nvotes_dict = {'Charlie': 20, 'Able': 10, 'Baker': 20, 'Dog': 15}\r\nvotes_dict.sort()\r\n\r\n  AttributeError: 'dict' object has no attribute 'sort'\r\n\r\nThe problem is: the sort method is defined only on LIST class objects, not\r\nDICT class objects.\r\n\r\nSo, Python cannot execute votes_dict.sort()! It makes no sense to sort a\r\ndictionary. In fact, we cannot sort strings (they are immutable); we cannot\r\nsort tuples (their order is immutable); we cannot sort sets (they have no order,\r\nwhich actually allows them to operate more efficiently; we'll learn why later\r\nin the quarter); we cannot sort dicts (like sets, they have no order, which\r\nallows them to operate more efficiently; ditto). \r\n\r\nBUT, WE CAN CALL THE SORTED FUNCTION ON ALL FOUR OF THESE DATA STRUCTURES, and\r\ngenerally on anything that is iterable: As we saw, Python executes the sorted\r\nfunction by creating a temporary list from all the values produced by the\r\niterable, then sorts that temporary list, and then returns the sorted list.\r\nHere is one example of how the sorted function processes votes_dict. Note that\r\nexecuting sorted(votes_dict) is the same as executing sorted(votes_dict.keys())\r\nwhich produces and iterates over a sorted list of the dict's keys.\r\n\r\nvotes_dict = {'Charlie' : 20, 'Able' :  10, 'Baker' : 20, 'Dog' : 15}\r\nfor c in sorted(votes_dict):       # same as: for c in sorted(votes_dict.keys())\r\n    print('Candidate', c, 'received', votes_dict[c], 'votes')\r\nprint(votes_dict)\r\n\r\nIt prints\r\n\r\nIt would show as\r\nCandidate Able received 10 votes\r\nCandidate Baker received 20 votes\r\nCandidate Charlie received 20 votes\r\nCandidate Dog received 15 votes\r\n{'Charlie': 20, 'Able': 10, 'Baker': 20, 'Dog': 15}\r\n\r\n-----Start alternative example\r\nNote: if we wrote\r\n\r\nvotes_dict = {'Charlie' : 20,  'Able' : 10,  'Baker' : 20,  'Dog' : 15}\r\nprint(sorted(votes_dict))\r\n\r\nPython prints a list, returned by sorted, of the dictionary's keys in sorted\r\norder:\r\n\r\n['Able', 'Baker', 'Charlie', 'Dog']\r\n-----Stop alternative example\r\n\r\nWell, this is one \"normal\" way to iterate over a sorted list built from a\r\ndictionary. We can also iterate over sorted \"items\" in a dictionary as follows\r\n(the difference is in the for loop and the print). We will examine more about\r\ndicts and the different ways to iterate over them later in this lecture. Recall\r\nthat each item in a dictionary is a 2-tuple consisting of one key and its\r\nassociated value.\r\n\r\nvotes_dict = {'Charlie' : 20,  'Able' : 10,  'Baker' : 20,  'Dog' : 15}\r\nfor c,v in sorted(votes_dict.items()):     # note parallel/unpacking assignment\r\n    print('Candidate', c, 'received', v, 'votes')\r\nprint(votes_dict)\r\n\r\nIt prints identically to the original example using dicts.\r\n\r\nNotice that this print doesn't access votes[c] to get the votes: that is the\r\nsecond item in each 2-tuple being iterated over using .items(). This is because\r\niterating over votes_dict.items() produces a sequence of 2-tuples, each\r\ncontaining one key and its associated value. The order that these 2-tuples\r\nappear in the list is unspecified, but using the sorted function ensures that\r\nthe keys appear in order.\r\n\r\n-----Start alternative example\r\nNote: if we wrote\r\n\r\nvotes_dict = {'Charlie' : 20,  'Able' : 10,  'Baker' : 20,  'Dog' : 15}\r\nprint(list(votes_dict.items()))\r\nprint(sorted(votes_dict.items()))\r\n\r\nPython first prints a list of the dictionary's items in an unspecified order,\r\nthen it prints a list of the same dictionary's items, in sorted order:\r\n\r\n[('Charlie', 20), ('Able', 10), ('Baker', 20), ('Dog', 15)]\r\n[('Able', 10), ('Baker', 20), ('Charlie', 20), ('Dog', 15)]\r\n\r\nboth list(...) and sorted(...) produce a list of the items in the dictionary,\r\nwith only sorted(....) producing a list that is guaranteed to be sorted.\r\n-----Stop alternative example\r\n\r\nHow to use a key parameter to sort arbitrarily:\r\n\r\nHow does sort/sorted work? How do they know how to compare the values they are\r\nsorting: where should come before which? There is a standard way to compare any\r\ndata structures, but we can also use the \"key\" and \"reverse\" parameters (which\r\nmust be used with their names, not positionally) to tell Python how to do the\r\nsorting. The reverse parameter is simpler, so let's look at it first; writing\r\nsorted(votes,reverse=True) sorts, but in the reverse order (writing\r\nreverse=False is like not specifying reverse at all). So, returning to votes as\r\na list,\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nprint(sorted(votes,reverse=True))\r\n\r\nprints the list of 2-tuples\r\n\r\n[('Dog', 15), ('Charlie', 20), ('Baker', 20), ('Able', 10)]\r\n\r\nWhat sort is doing is comparing each value in the list to the others using the\r\nstandard meaning of <. You should know how Python compares str values, int\r\nvalues, etc. But how does Python compare whether one tuple is less than another?\r\nOr whether one list is less than another? The algorithm in analagous to strings,\r\nso let's first re-examine comparing strings. The ordering, by the way, is called\r\n\"lexicographic ordering\", and also \"dictionary ordering\" (related to the order\r\nwords appear in dictionaries that are books, not Python dicts/dictionaries).\r\n\r\n---------------\r\nInterlude: Comparing Strings in Python:\r\n\r\nString comparison: x to y (high level: how does x compare to yl):\r\n\r\nFind the first/minimum index i such that the ith character in x and y are\r\ndifferent (e.g., x[i] != y[i]). If that character in x is less than that\r\ncharacter in y (by the standard ASCII table) then x is less than y; if that\r\ncharacter in x is greater than that character in y then x is greater than y;\r\nif there is no such different character, then how x compares to y is the same as\r\nhow  x's length compares to y's length (either less than, equal or greater\r\nthan).\r\n\r\nHere are three examples:\r\n\r\n  (1) How do we compare x = 'aunt' and y = 'anteater'? The first/minimum i such\r\n  that the characters are different is 1: x[1] is 'u' and y[1] is 'n'; 'u' is\r\n  greater than 'n', so x > y, so 'aunt' > 'anteater'.\r\n\r\n  (2) How do we compare x = 'ant' and y = 'anteater'? There is no first/minimum\r\n  i such that the characters are different; len(x) < len(y), so x < y, so\r\n  'ant' < 'anteater'. The word 'ant' appears in an English dictionary before\r\n  the word 'anteater' ('ant' is a prefix of 'anteater').\r\n\r\n  (3) How do we compare x = 'ant' and y = 'ant'? There is no first/minimum i\r\n  such that the characters are different; len(x) == len(y), so x == y, so\r\n  'ant' == 'ant'. I show this example, which is trivial, just to be complete.\r\n\r\nSee the Handouts(General) webpage showing the ASCII character set, because\r\nthere are some suprises. You should memorize that the digits and lower/upper\r\ncase letters compare in order, and all digts < all upper-case letters < all\r\nlower-case letters. So 'TINY' < 'huge' is True because the index 0 characters\r\ndifferent, and 'T' is < 'h' (all upper-case letters have smaller ASCII values\r\nthan any lower-case letters). Likewise, 'Aunt' < 'aunt' because 'A' < 'a'. Note\r\nthat we can always use the upper() method (as in x.upper() < y.upper()) or\r\nlower() method to perform a comparison that ignores the case of the letters in\r\na string: 'TINY'.lower() > 'huge'.lower() because 'tiny' > 'huge' because\r\n't' > 'h'.\r\n\r\nUse these rules to determine whether '5' < '15' by comparing the string '5' to\r\n'15'. What is your answer; what is the correct answer?\r\n---------------\r\n\r\nBack to comparing tuples (or lists). We basically do the same thing. We look at\r\nwhat is in index 0 in the tuples; if different, then the tuples compare in the\r\nsame way as the values in index 0 compare; if the values at this index are\r\nequal, we keep going until we find a difference, and compare the tuples the same\r\nway that the differences compare; if there are no differences, the tuples\r\ncompare the same way their lengths compare.\r\n\r\nSo ('UCI', 100) < ('UCSD', 50) is True because at index 0 of these tuples, the\r\nstring values are different; and 'UCI' < 'UCSD' (because at index 2 of these\r\nstrings, the character values are different, and 'I' < 'S').\r\n\r\nWhereas ('UCI', 100) < ('UCI', 200) is True because at index 0 of these tuples,\r\nthe string values are equal ('UCI' == 'UCI'), so we go to index 1, where we\r\nfind the first different values, and 100 < 200.\r\n\r\nFinally, ('UCI', 100) < ('UCI', 100, 'extra') is True because at index 0 these\r\ntuples the values are equal ('UCI' == 'UCI'); and at index 1 of these tuples\r\nthe values are equal (100 == 100), so there are no different values; but\r\nthe second tuple has a larger length, so it is greater than the first tuple.\r\n\r\nRecall the sorting code from above.\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nfor c,v in sorted(votes):\r\n    print('Candidate', c, 'received', v, 'votes')\r\nprint(votes)\r\n\r\nThe reason that the values come out in the order they do (alphabetical order)\r\nin the code above is because the names that are in the first index in each\r\n2-tuple are different and ensure the tuples are sorted alphabetically. Python\r\nnever gets to looking at the second value in each tuple, because the first\r\nvalues (the candidate names) are always different.\r\n\r\nNow, what if we don't want to sort by the natural tuple ordering. We can\r\nspecify a \"key\" function that computes a key value for every value in what is\r\nbeing sorted, and the COMPUTED KEY VALUES ARE USED FOR COMPARISON, not the\r\noriginal values themselves. These are the \"keys\" for comparison.\r\n\r\nSee the by_vote_count function below; it takes a 2-tuple argument and returns\r\nonly the second value in the tuple (recall indexes start at 0) for the key on\r\nwhich Python will compare. For the argument 2-tuple ('Baker' ,20) by_vote_count\r\nreturns 20.\r\n\r\ndef by_vote_count(t):\r\n    return t[1]            # remember t[0] is the first index, t[1] the second\r\n\r\nSo, when we sort with key=by_vote_count, we are telling the sorted function to\r\ndetermine the order of values by calling the by_vote_count function on each\r\nvalue: so in this call of sorted, we are comparing tuples based solely on their\r\nvote part, from index 1. So writing\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nfor c,v in sorted(votes, key=by_vote_count):\r\n    print('Candidate', c, 'received', v, 'votes')\r\n\r\nproduces \r\n\r\nCandidate Able received 10 votes\r\nCandidate Dog received 15 votes\r\nCandidate Charlie received 20 votes\r\nCandidate Baker received 20 votes\r\n\r\nFirst, notice that by writing \"key=by_vote_count\" Python didn't CALL the\r\nby_vote_count function (there are no parentheses) it just passed its associated\r\nfunction object to the key parameter in the sorted function. Inside the sorted\r\nfunction, by_vote_count's function object automatically is called where needed,\r\nto compare two 2-tuples, to determine in which order these values will appear in\r\nthe returned list.\r\n\r\nAlso, because Charlie and Baker both received the same number of votes, they\r\nboth appear at the bottom, but they might appear in either order; the order is\r\nunspecified (equal values can appear in any order); here Charlie appears first.\r\n\r\nFinally, notice that the tuples are printed in ascending order by votes;\r\ngenerally for elections we want the votes to be descending, so we can combine\r\nusing key and reverse (with reverse=True) in the call to the sorted function.\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nfor c,v in sorted(votes, key=by_vote_count, reverse=True):\r\n    print('Candidate', c, 'received', v, 'votes')\r\n\r\nwhich produces \r\n\r\nCandidate Charlie received 20 votes\r\nCandidate Baker received 20 votes\r\nCandidate Dog received 15 votes\r\nCandidate Able received 10 votes\r\n\r\nAgain, since the top two candidates both received the same number of votes, they\r\ncould appear in any order: the order is unspecified.\r\n\r\nNow, rather than define this simple by_vote_count function, we can use a lambda\r\ninstead, and write the following.\r\n\r\n...\r\nfor c,v in sorted(votes, key=(lambda t : t[1]), reverse=True):\r\n    ...\r\n\r\nSo, now we don't have to write/name that extra by_vote_count function. Of\r\ncourse, if we did write it, we could reuse it wherever we wanted, instead of\r\nrewriting the lambda (but the lambdas are pretty small). By writing the lambda,\r\nthe relevant code is all inside the call to sorted: we don't have to go look\r\nelsewhere for some function defintion. So, we now know how to use functions and\r\nlambdas in sorted.\r\n\r\nSuch a key function is used the same way when calling the sort method. If votes\r\nis the list shown at the beginning of this section (not the dictionary above),\r\nwe can call  votes.sort(key=(lambda t : t[1]), reverse=True) to sort this list,\r\nmutating it.\r\n\r\nAnother way to sort in reverse order (for integers) is to use the \"negation\"\r\ntrick illustrated below (and omit reverse=True).\r\n\r\n...\r\nfor c,v in sorted(votes, key=(lambda t : -t[1]) ):\r\n    ...\r\n\r\nHere we have negated the vote count part of the tuple, and removed reverse=True.\r\nSo it is sorting from smallest to largest, but the key function returns the\r\nnegative of the vote values (because that is what the lambda says to do). It is\r\ncomparing -20, -10, -20, and -15 to sort. So here the biggest vote count\r\ncorresponds to the smallest negative number (so the tuple with that number will\r\nappear first). The tuples appear in the order specified by the key functions:\r\n-20, -20, -15, -10 (smallest to largest). These negative values returned by the\r\nkey function are used only to determine the order insides sorted; they do not\r\nappear in the results.\r\n\r\nFinally, typically when multiple candidates are tied for votes, we want to print\r\ntheir names together (because they all have the same number of votes) but also\r\nin alphabetical order. We do this in Python by specifying a key function that\r\nreturns a tuple in which the vote count is checked first and sorted in\r\ndescending order; and only if the votes are equal will the names be checked and\r\nsorted in ascending order. Because we want the tuples in decreasing vote\r\ncounts but increasing names, we cannot just use reverse=True: it would reverse\r\nboth the vote AND name comparisons; we need to resort to the \"negation trick\"\r\nabove and write\r\n\r\nvotes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]\r\nfor c,v in sorted(votes, key=(lambda t : (-t[1],t[0])) ):\r\n    print('Candidate',c,'received',v,'votes')\r\n\r\nSo it compares the 2-tuple keys (-20, 'Charlie'), (-10, 'Able'), (-20, 'Baker'),\r\nand (-15, 'Dog') when ordering the actual 2-tuples, and by what we have learned\r\n\r\n(-20, 'Baker') < (-20, 'Charlie') < (-15, 'Dog') < (-10, 'Able')\r\n\r\nwhich produces \r\n\r\nCandidate Baker received 20 votes\r\nCandidate Charlie received 20 votes\r\nCandidate Dog received 15 votes\r\nCandidate Able received 10 votes\r\n\r\nSo with this key function, the previous order is GUARANTEED, even though Baker\r\nand Charlie both received the same number (20) of votes, 'Baker' < 'Charlie' so\r\nthat 2-tuple will appear first.\r\n\r\nFinally, note that the lambda in the key ensures Python compares ('Charlie', 20)\r\nand ('Dog', 15) as if they were (-20, 'Charlie') and (-15, 'Dog'), so the first\r\ntuple will be less (and appear earlier) in the sorted list (the one with the\r\nhighest votes has the lowest negative votes). And when Python compares\r\n('Charlie', 20) and ('Baker' ,20) as if they were (-20, 'Charlie') and\r\n(-20, 'Baker') so the second tuple will be less and the tuple it was produced\r\nfrom will appear earlier (equal votes and then 'Baker' < 'Charlie').\r\n\r\nSo think of sorting\r\n\r\n('Charlie', 20)   ('Able', 10)   ('Baker' ,20)   ('Dog', 15)\r\n       |                |               |              |  using the key function\r\n       |                |               |              |  it really compares\r\n       V                V               V              V  \r\n(-20, 'Charlie')  (-10, 'Able')  (-20, 'Baker')  (-15, 'Dog')\r\n\r\nwhich sorts to \r\n\r\n(-20,'Baker')     (-20,'Charlie')   (-15,'Dog')    (-10,'Able')\r\n       |                |               |              | actual values in list\r\n       |                |               |              | (without key function)\r\n       V                V               V              V\r\n('Baker',20)      ('Charlie', 20)   ('Dog',15)     ('Able', 10)\r\n\r\nso the order of the actual list returned by sorted is\r\n\r\n[('Baker', 20), ('Charlie', 20), ('Dog', 15),  ('Able', 10)]\r\n\r\nwhich is sorted by decreasing vote, with equal votes sorted alphabetically\r\nincreasing by name.\r\n\r\nOur ability to use this \"negation trick\" works in SOME cases, but unfortunately\r\nNOT IN ALL cases: we can sort arbitarily using this trick exactly when \"all non-\r\nnumerical data is sorted in the same way\" (all increasing or all decreasing). In\r\nsuch cases, we can negate any numerical data, if we need to sort it decreasing.\r\nSo, we can sort the above example because we are sorting only one non-numerical\r\ndatum. By the requirement, all non-numerical data (there is only one on this\r\nexample, the name) is sorted the same way (increasing).\r\n\r\nUsing the \"negation trick\" is therefore not generalizable to all sorting tasks:\r\nfor example, if we had a list of 2-tuples containing strings of candidates and\r\nstrings of the states they are running in\r\n\r\n  [('Charlie', 'CA'), ('Able', 'NY'), ('Baker' ,'CA'), ('Dog', 'IL')]\r\n\r\nthere is no way to use the \"negation trick\" to sort them primarily by\r\ndecreasing state, and secondarily by increasing name (when two candidates come\r\nfrom the same state). Here it is not the case that \"all non-numerical data is\r\nsorted the same way\": each string data is sorted differently. In this case the\r\nsorted list would be\r\n\r\n  [('Able', 'NY'), ('Dog', 'IL'), ('Charlie', 'CA'), ('Baker' ,'CA')]\r\n\r\neven though we wanted it to be (note the last two names, from the same state)\r\n\r\n  [('Able', 'NY'), ('Dog', 'IL'), ('Baker', 'CA'), ('Charlie' ,'CA')]\r\n\r\nWe cannot apply the \"negation trick\" to either of the strings: we cannot negate\r\nstrings at all. But we can produce a list in this specified order by calling\r\nsorted multiple times, as is illustrated below. \r\n\r\n---------------\r\nArbitrary sorting: multiple calls to sorted with \"stable\" sorting\r\n\r\nPython's sorted function (and sort method) are \"stable\". This property means\r\nthat \"equal\" values (decided naturally, or with the key function supplied) keep\r\ntheir same \"relative\" order (left-to-right positions) in the data being sorted.\r\n\r\nFor example, assume that db is a list of 2-tuples, each specifying a student:\r\nindex 0 is a student's name; index 1 is that student's grade.\r\n\r\n  db = [('Bob','A'),    ('Mary','C'), ('Pat','B'), ('Fred','B'), ('Gail','A'),\r\n        ('Irving','C'), ('Betty','B'), ('Rich','F')]\r\n\r\nIf we call\r\n\r\n  sorted(db, key = lambda x : x[1])   # sorted by index 1 only: their grade\r\n\r\nPython returns the following list, whose 2-tuples are sorted by grade. Because\r\nsorting is \"stable\", all 2-tuples with the same grade (equal values by the key\r\nfunction) keep their same relative order (left-to-right positions) in the list.\r\n\r\n  [('Bob','A'),  ('Gail','A'),   ('Pat','B'), ('Fred','B'), ('Betty','B'),\r\n   ('Mary','C'), ('Irving','C'), ('Rich','F')]\r\n\r\nNotice that...\r\n\r\n  (1) in the original list, the students with 'A' grades are 'Bob' and 'Gail',\r\n      with 'Bob' to the left of 'Gail'. In the returned list, 'Bob' is also to\r\n      the left of 'Gail'. \r\n\r\n  (2) in the original list, the students with 'B' grades are 'Pat', 'Fred', and\r\n      'Betty', with 'Pat' to the left of 'Fred' and 'Fred' to the left of\r\n      'Betty'. In the returned list, 'Pat' is to the left of 'Fred' and 'Fred'\r\n      is to the left of 'Betty'.\r\n\r\n  (3) in the original list, the students with 'C' grades are 'Mary' and\r\n      'Irving', with 'Mary' to the left of 'Irving'. In the returned list,\r\n      'Mary' is also to the left of 'Irving'. \r\n\r\n  (4) there is only one student with an 'F' grade.\r\n\r\nNow, suppose that we wanted to sort this list so that primarily the 2-tuples\r\nare sorted DECREASING by grade ('F's, then 'D's, then 'C's, then 'B's, then\r\n'A's); and for students who have equal grades, the 2-tuples are sorted\r\nINCREASING alphabetically by student name. We can accomplish this task by\r\ncalling sorted twice, by writing\r\n\r\n  sorted( sorted(db, key=(lambda x : x[0])), key=(lambda x : x[1]), reverse=True )\r\n\r\nThe inner call to sorted produces the list\r\n\r\n  [('Betty','B'), ('Bob','A'), ('Fred','B'), ('Gail','A'), ('Irving','C'),\r\n   ('Mary','C'),  ('Pat','B'), ('Rich','F')]\r\n\r\nwhich is sorted INCREASING by the student's name: all names are distinct\r\n(different), so stability is irrelevant here.\r\n\r\nThe outer call to sorted, using the \"sorted by name\" db list as an argument,\r\nproduces the list\r\n\r\n  [('Rich','F'), ('Irving','C'), ('Mary','C'), ('Betty','B'), ('Fred','B'),\r\n   ('Pat','B'),  ('Bob','A'),    ('Gail','A')]\r\n\r\nwhich is sorted DECREASING by the student's grade: for equal grades, the\r\nstability property ensures that all names are still sorted INCREASING by the\r\nstudent's name (because the argument is sorted that way). Here, the 'B' students\r\nare in the alphabetical order 'Betty', 'Fred', and 'Pat'. Note that we could\r\nsimplify this code to just\r\n\r\n  sorted( sorted(db), key=(lambda x : x[1]), reverse = True )\r\n\r\nbecause for the inner call to sorted, no key function is the same as the key\r\nfunction that specifies sorting the 2-tuples in the natural way (alphabetically\r\nby name). We could use a temporary variable and write this code as\r\n\r\n  temp = sorted(db)\r\n  sorted( temp, key = lambda x : x[1], reverse = True )\r\n\r\nThus, we can sort complex structures in any arbitrary way (some data increasing,\r\nsome data decreasing) by calling sorted multiple times on it. The LAST call will\r\ndictate the primary order in which it is sorted; each preceding/inner call\r\ndictates how the data is sorted if values specified by the outer orders are\r\nequal.\r\n\r\nExperiment with these various forms of sorting, using reverse, keys, the \r\nnegation trick, and multiple calls to sort.\r\n---------------\r\n\r\nFinally, to solve the original problem above (with candidates and their states:\r\nalso involving two strings sorted primarily DECREASING on state and INCREASING\r\non name)\r\n\r\n  db  = [('Charlie', 'CA'), ('Able', 'NY'), ('Baker' ,'CA'), ('Dog', 'IL')]\r\n\r\nwe would call \r\n\r\n  sorted( sorted(db), key=(lambda x : x[1]), reverse = True )\r\n\r\nBottom line on sorting:\r\n\r\n  To achieve our sorting goal, if we can call sorted once, using a complicated\r\n  key (possibly involving the \"negation trick\") and reverse, that is the\r\n  preferred approach: it is shortest/clearest in code and fastest in computer\r\n  time. But if we are unable to specify a single key function and reverse that\r\n  do the job, we can always call sorted multiple times, using multiple key\r\n  functions and multiple reverses, sometimes relying on the \"stability\"\r\n  property to achieve our sorting goal.\r\n\r\nWe now have a general tool bag for sorting all types of information. Sorting\r\nwill be heavily tested in Quiz #1, Programming Assignment #1, and In-Lab #1.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe print function\r\n\r\nNotice how the sep and end parameters in print help control how the printed\r\nvalues are separated and what is printed after the last one. Recall that print\r\ncan have any number of arguments (we will see how this is done in Python soon),\r\nand it prints the str(...) of each parameter. By default, sep=' ' (space) and\r\nend='\\n' (newline). So the following\r\n\r\nprint(1,2,3,4,sep='--',end='/')\r\nprint(5,6,7,8,sep='x',end='**')\r\n\r\nprints\r\n\r\n1--2--3--4/5x6x7x8**\r\n\r\nAlso recall that all functions must return a value. The print function returns\r\nthe value None: this function serves as a statement: it has an \"effect\" (of\r\ndisplaying information in the console window; we might say changing the state\r\nof the console) but returns no useful \"value\"; but all functions must return a\r\nvalue, so this one returns None. Recall that the sort method on lists mutated\r\na list (its primarly action) but also had to return a value, so returned None.\r\n\r\nSometimes we use sep='' to control spaces more finely. In this case we must put\r\nin all the spaces ourselves. If we want to separate only 2 and 3 by a space,\r\nwe write\r\n\r\nprint(1,2,' ',3,sep='')\r\n\r\nwhich prints\r\n\r\n12 3\r\n\r\nStill, other times we can concatenate values together into one string (which\r\nrequires us to explicitly use the str function on the things we want to print).\r\n\r\nx = 10\r\nprint('Your answer of '+str(x)+' is too high.'+'\\nThis is on the next line')\r\n\r\nNote the use of the \"escape\" sequence \\n to generate a new line. It doesn't\r\nprint a '\\' followed by an 'n'; Python interprets '\\n' to be the newline\r\ncharacter: the remaining output starts at the beginning of the next line.\r\n\r\nFinally, we can also use the very general-purpose .format function. This\r\nfunction is illustrated in Section 6.1.3 in the documentation of The Python\r\nStandard Library. The following two statements print equivalently: for a string\r\nwith many format substitutions, I prefer the form with a name (here x) in the\r\nbraces of the string and as a named parameter in the arguments to format.\r\n\r\nprint('Your answer of {} is too high\\nThis is on the next line'.format(10))\r\n\r\nprint('Your answer of {x} is too high\\nThis is on the next line'.format(x=10))\r\n\r\nIn Python 3.6 and beyond we can use f-strings (formatted strings; google PEP\r\n498) to solve this problem even more simply.\r\n\r\nprint(f'Your answer of {x} is too high\\nThis is on the next line')\r\n\r\nHere, any expression in {} is evaluated and turned into a string embedded\r\nin the f-string. We could write {x+1} or any other expression instead of just\r\nthe x in the {}.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nString/List/Tuple (SLT) slicing:\r\n\r\nSLTs represent sequences of indexable values, whose indexes start at index 0,\r\nand go up to -but do not include- the length of the SLT (which we can compute\r\nusing the len function).\r\n\r\n1) Indexing: We can index a SLT by writing SLT[i], where i is in the range 0\r\n  to len(SLT)-1 inclusive, or i is negative and i is in the range\r\n  -len(SLT) to -1 inclusive: if an index is not in these ranges, Python raises\r\n  an exception. Note SLT[0] is the value store in the first index, SLT[-1] is\r\n  the value stored in the last index, SLT[-2] is the value stored in the 2nd\r\n  to last index.\r\n\r\n2) Slicing: We can specify a slice by SLT[i:j] which includes SLT[i] followed\r\n   by SLT[i+1], ... SLT[j-1]. Slicing a string produces another string,\r\n   slicing a list produces another list, and slicing a tuple produces another\r\n   tuple). The resulting structures has j-i elements if indexes i through j are\r\n   in the SLT (or 0 if j-i is <= 0); for this formula, both indexes must be\r\n   non-negative or both positive; if they are different, convert the negative\r\n   to it non-negative (or the non-negative to its negative) equivalent.\r\n\r\n   If the slice contain no values it is empty (an  empty string, an empty list,\r\n    and empty tuple).\r\n  \r\n   If the first index come before index 0, then index 0 is used; if the second\r\n   index comes after the biggest index, then index len(SLT) is used. Finally,\r\n   if the first index is omitted it is 0; if the second index is omitted it is\r\n   len(SLT).\r\n\r\n   Here are some examples\r\n\r\ns = 'abcde'\r\nx = s[1:3]\r\nprint (x)     # prints 'bc' which is 3-1 = 2 values\r\nx = s[-4:-1]\r\nprint (x)     # prints 'bcd' same as s[1:4] which is 4-1 = 3 values\r\nx = s[1:-2]\r\nprint (x)     # prints 'bc' same as s[1:3] which is 3-1 = 2\r\nx = s[-4:-2]\r\nprint (x)     # prints 'bc' same as s[1:3] which is 3-1 = 2 values\r\nx = s[1:10]\r\nprint (x)     # prints 'bcde' which is len(x)-1 = 4 values\r\n\r\n   likewise\r\n\r\ns = ('a','b','c','d','e')\r\nx = s[1:3]\r\nprint (x)     # prints ('b','c') which is 3-1 = 2 values\r\nx = s[-4:-1]\r\nprint (x)     # prints ('b','c','d') which is -1-(-4) = 3 values\r\n\r\n   s[:i] is index 0 up to but not including i (can be positive or negative)\r\n   s[i:] is index i up to and including the last index; so s[-2:] is the last\r\n         two values.\r\n\r\n3) Slicing with a stride: We can specify a slice by SLT[i:j:k] which includes\r\n   SLT[i] followed by SLT[i+k], SLT[i+2k] ... SLT[j-1]. This follows the rules\r\n   for slicing too, and allows negative numbers for indexing.\r\n\r\ns = ('a','b','c','d','e')\r\nx = s[::2]\r\nprint (x)     # prints ('a','c','e')\r\nx = s[1::2]\r\nprint (x)     # prints ('b','d')\r\n\r\nx = s[3:1:-1]\r\nprint (x)     # prints ('d','c')\r\nx = s[-1:1:-1]\r\nprint (x)     # prints ('e','d','c')\r\n\r\n  When the stride is omitted, it is +1. If the stride is negative, if the first\r\n  index is omitted it is len(SLT); if the last index is omitted it is -1.\r\n  Compare these to the values if omitted above in part 2, which assumed a\r\n  positive stride.\r\n\r\nExperiment with various slices of strings (the easiest to write) to verify you\r\nunderstand what results they produce.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nConditional statement vs. Conditional expression\r\n\r\nPython has an if/else STATEMENT, which is a conditional statement. It also has a\r\nconditional EXPRESSION that uses the same keywords (if and else), which while\r\nnot as generally useful, sometimes is exactly the right tool to simplify a\r\nprogramming task.\r\n\r\nA conditional statement uses a boolean expression to decide which indented\r\nblock of statements to execute; a conditional expression uses a boolean\r\nexpression to decide which one of exactly two other expressions to evaluate:\r\nthe value of the evaluated expression is the value of the conditional\r\nexpression.\r\n\r\nThe form of a conditional expression is\r\n\r\n  resultT if test else resultF\r\n\r\nThis says, the expression evaluates to the value of resultT if test is True\r\nand the value of resultF if test is False; first it evaluates test, and then\r\nevaluates either resultT or resultF (but only one, not the other) as necessary.\r\nLike other short-circuit operators in Python (do you know which?) it evaluates\r\nonly the subexpressions it needs to determine the result.\r\n\r\nI often write conditional expresions inside parentheses for clarity (as I did\r\nfor lambdas; sometimes the parentheses are required, as with lambdas). See the\r\nexamples below.\r\n\r\nHere is a simple example. We start with a conditional statement, which always\r\nstores a value into min: either x or y depending on whether x <= y. Note that\r\nregardless of the test, min is bound to some value.\r\n\r\n  if x <= y:\r\n      min = x\r\n  else:\r\n      min = y\r\n\r\nWe can write this using a simpler conditional expression, capturing the fact\r\nthat we are always storing into min, and just deciding which value to store in\r\nit.\r\n\r\n  min = (x if x <= y else y)\r\n\r\nNot all conditional statements can be converted into conditional expressions;\r\ntypically only simple ones can: ones with a single statement in their indented\r\nblocks. But using conditional expressions in these cases simplifies the code\r\neven more. So attempt to use conditional expression, but use good judgement\r\nafter you see what the code looks like. Write the simplest looking code.\r\n\r\nHere is another example; it always prints x followed by some message\r\n\r\n  if x % 2 == 0:\r\n      print(x,'is even')\r\n  else:\r\n      print(x,'is odd')\r\n\r\nWe can rewrite it as as calling print with a conditional expression inside\r\ndeciding what string to print at the end.\r\n\r\n      print(x, ('is even' if x%2 == 0 else 'is odd'))\r\n\r\nWe can also write it as a one argument print using concatenation:\r\n\r\n      print(str(x) + ' is ' + ('even' if x%2 == 0 else 'odd'))\r\n\r\nNote that conditional expressions REQUIRE using BOTH THE if AND else KEYWORDS,\r\nalong with the test boolean expression and the two expressions needed in the\r\ncases where the test is True or the test is False. Some conditional statements\r\nuse just if (and no else nor elif).\r\n\r\nAs an example of f-strings, we can write this as\r\n\r\n      print(f\"{x} is {'even' if x%2 == 0 else 'odd'}\")\r\n\r\nbecause we can write a conditional EXPRESSION inside {}, because we can put\r\nany expression there. Note I had to write the outside string using \" to specify\r\n'even' and 'odd' as strings in the f-string.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe else: block-else option in for/while loops\r\n\r\nFor and while looping statements are described as follows. The else: block-else\r\nis optional, and not often used. But we will explore its meaning here.\r\n\r\nfor_statement   <= for index(es) in iterable:\r\n                       block-body\r\n                   [else:\r\n                       block-else]\r\n\r\nwhile_statement <= while <bool-expression>:\r\n                       block-body\r\n                   [else:\r\n                       block-else]\r\n\r\nHere are the semantics of else: block-else.\r\n\r\n   If the else: block-else option appears, and the loop terminated normally,\r\n   (not with a break statement) then execute block-else.\r\n\r\nHere is an example that makes good use of the else: block-else option. This\r\ncode prints the first/lowest value (looking at the values 0 to 100 inclusive)\r\nfor which the function special_property returns True (and then breaks out of\r\nthe loop); otherwise it prints that no value in this range had this property:\r\nso it prints exactly one of these two messages. Note you cannot run this code,\r\nbecause there is no special_property function: I'm using it for illustration\r\nonly.\r\n\r\nfor i in irange(100):\r\n    if special_property(i):\r\n        print(i,'is the first value with the special property')\r\n        break\r\nelse:\r\n    print('No value in the range had the special property')\r\n\r\nWithout the else: block-else option, the simplest code that I can write that has\r\nequivalent meaning is as follows.\r\n\r\nfound_one = False\r\nfor i in irange(100):\r\n    if special_property(i):\r\n        print(i,'is the first with the special property')\r\n        found_one = True\r\n        break\r\nif not found_one:\r\n    print('No value in the range had the special property')\r\n\r\nThis solution requires an extra name (found_one), an assignment to set and\r\nreset the name, and an if statement. Although I came up with the example above,\r\nI have not used the else: block-else option much in Python. Most programming\r\nlanguages that I have used don't have this special feature, so I'm still\r\nexploring its usefulness. Every so often I have found an elegant use of this\r\nconstruct. \r\n\r\nCan you predict what would happen if I removed the break statement in the\r\nbigger code above? Run the code to check your answer.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nArgument/Parameter Matching (leaves out **kargs, discussed later)\r\n\r\nRecall that when functions are called, Python first evaluates the arguments,\r\nthen matches/binds them with parameters, and finally executes the body of the\r\nfunction using the names of parameters (bound to the values of arguments).\r\n\r\nLet's explore the argument/parameter matching rules. First we classify\r\narguments and parameters, according to the options that they include. Remember\r\nthat arguments appear in function CALLS and parameters appear in function\r\nHEADERS (the first line in a function defintion).\r\n\r\nArguments\r\n  positional argument: an argument NOT preceded by the name= option\r\n  named      argument: an argument preceded by the name= option\r\n\r\nParameters\r\n  name-only parameter       :a parameter not followed by =default argument value\r\n  default-argument parameter:a parameter followed by =default argument value\r\n\r\nWhen Python calls a function, it must define every parameter name in the\r\nfunction's header (binding each to the argument value object matching that\r\nparameter's name, just like an assignment statement). In the rules below, we\r\nwill learn exactly how Python matches arguments to parameters according to\r\nthree criteria: positions, parameter names, and default arguments for parameter\r\nnames. We will also learn how to write functions that can receive an arbitrary\r\nnumber of arguments (so, for example, we can write our own print function).\r\n\r\nHere is a concise statement of Python's rules for matching arguments to\r\nparameters. The rules are applied in this order (e.g., once you reach M3 we\r\ncannot go back to M1).\r\n\r\nM1. Match positional argument values in the call sequentially to the\r\n    parameters named in the header's corresponding positions (both name-only\r\n    and default-argument parameters are OK to match). Stop when reaching any\r\n    named argument in the call, or the * parameter (if any) in the header.\r\n\r\nM2. If matching a * parameter in the header, match all remaining positional\r\n    argument values to it. Python creates a tuple that stores all these\r\n    arguments. The parameter name (typically args) is bound to this tuple.\r\n\r\nM3. Match named-argument values in the call to their like-named parameters\r\n    in the header (both name-only and default-argument parameters are OK).\r\n\r\nM4. Match any remaining default-argument parameters in the header (unmatched\r\n    by rules M1 and M3) with their specified default argument values.\r\n\r\nM5. Exceptions: If at any time (a) an argument cannot match a parameter\r\n    (e.g., a positional-argument follows a named-argument) or (b) a parameter\r\n    is matched multiple times by arguments; or if at the end of the process\r\n    (c) any parameter has not been matched or (d) if a named-argument does not\r\n    match the name of a parameter, raise an exception: SyntaxError for (a) and\r\n    TypeError for (b), (c), and (d). These exceptions report that the function\r\n    call does not correctly match its header by these rules.\r\n\r\n[When we examine a **kargs as a parameter, we will learn what Python does when\r\nthere are extra named arguments in a function call: names besides those of\r\nparameters: preview: it puts all remaing named arguments in a dictionary, with\r\ntheir name as the key and their value associated with that key). The parameter\r\nname (typically kargs or kwargs) is bound to this dictionary.]\r\n\r\nWhen this argument-parameter matching process if finished, Python defines,\r\n(in the function's namespace), a name for every parameter and binds each to\r\nthe unique argument it matched using the above rules. Passing parameters is\r\nsimilar to performing a series of assignment statements between parameter names\r\nand their matching argument values.\r\n\r\nIf a function call raises no exception, these rules ensure that each parameter\r\nin the function header matches the value of exactly one argument in the\r\nfunction call. After Python binds each parameter name to its argument, it\r\nexecutes the body of the function, which computes and returns the result of\r\ncalling the function.\r\n\r\nHere are some examples of functions that we can call to explore the rules for\r\nargument/parameter matching specified above. These functions just print their\r\nparameters, so we can see the arguments bound to them (or see which exception\r\nthey raise). Certainly you should try others to increase your understanding.\r\n\r\ndef f(a,b,c=10,d=None): print(a,b,c,d)\r\ndef g(a=10,b=20,c=30) : print(a,b,c)\r\ndef h(a,*b,c=10)      : print(a,b,c)\r\n\r\nCall              | Parameter/Argument Binding (matching rule)\r\n------------------+--------------------------------------------\r\nf(1,2,3,4)\t  | a=1, b=2, c=3, d=4(M1)\r\nf(1,2,3)\t  | a=1, b=2, c=3(M1); d=None(M4)\r\nf(1,2)\t\t  | a=1, b=2(M1); c=10, d=None(M4)\r\nf(1)\t\t  | a=1(M1); c=10, d=None(M4);\r\n                       TypeError(M5c: parameter b not matched)\r\nf(1,2,b=3) \t  | a=1, b=2(M1); b=3(M3); c=10, d=None(M4)\r\n                      TypeError(M5b: parameter b matched twice)\r\nf(d=1,b=2)\t  | d=1, b=2(M3); c=10(M4);\r\n                       TypeError(M5c: parameter a not matched)\r\nf(b=1,a=2)\t  | b=1, a=2(M3); c=10, d=None(M4)\r\nf(a=1,d=2,b=3)\t  | a=1, d=2, b=3(M3); c=10(M4)\r\nf(c=1,2,3)\t  | c=1(M3);\r\n                       SyntaxError(M5a:2 is positional argument)\r\n\r\ng()\t\t  | a=10, b=20, c=30(M4)\r\ng(b=1)\t\t  | b=1(M3); a=10, c=30(M4)\r\ng(a=1,2,c=3)\t  | a=1(M3);\r\n                       SyntaxError(M5a:2 is positional argument)\r\n\r\nh(1,2,3,4,5)\t  | a=1(M1); b=(2,3,4,5)(M2), c=10(M4)\r\nh(1,2,3,4,c=5)    | a=1(M1); b=(2,3,4)(M2), c=5(M3)\r\nh(a=1,2,3,4,c=5)  | a=1(M3);\r\n                       SyntaxError(M5a:2 is positional argument))\r\nh(1,2,3,4,c=5,a=1)| a=1(M1); b=(2,3,4)(M2); c=5(M3);\r\n                        TypeError(M5b:a matched twice)\r\n\r\nHere is a real but simple example of using *args, showing how the max function\r\nis implememented in Python; we dont' really need to write this function because\r\nit is in Python already, but here is how it is written in Python. We will cover\r\nraising exceptions later in this lecture note, so don't worry about that code.\r\n\r\ndef max(*args) :     \t   # Can refer to args inside; it is a tuple of values\r\n    if len(args) == 0:\r\n        raise TypeError('max: expected >=1 arguments, got 0')\r\n\r\n    answer = None\r\n    for i in args:\r\n        if answer == None or i > answer:\r\n            answer = i\r\n    return answer\r\n\r\nprint(max(3,-4, 2, 8)) # max with many arguments; prints 8\r\n\r\nIn fact, the real max function in Python can take either (a) any number of\r\narguments or (b) one iterable argument. It is a bit more subtle to write\r\ncorrectly to handle both parameter structures, but here is the code.\r\n\r\ndef max(*args) :     \t   # Can refer to args inside; it is a tuple of values\r\n    if len(args) == 0:\r\n        raise TypeError('max: expected >=1 arguments, got 0')\r\n\r\n    if len(args) == 1:     # Assume that if max has just one argument then\r\n        args = args[0]     #   it's iterable, so take the max over its values\r\n\r\n    answer = None\r\n    for i in args:\r\n        if answer == None or i > answer:\r\n            answer = i\r\n    return answer\r\n\r\nl = (3,-4, 2, 8)\r\nprint(max(l))          # max with one iterable argument; prints 8\r\n\r\nFinally, because of this approach computing max(3) raises an exception, because\r\nPython expects a single argument to be iterable. It might be reasonable in this\r\ncase to return 3, but that is not the semantics (meaning) of the max function\r\nbuilt into Python.\r\n\r\nHere is another real example of using *args, where I show how the print function\r\nis written in Python. The myprint calls a very simple version of print, just\r\nonce at the end, to print only one string that it builds from args along with\r\nsep and end; it prints the same thing the normal print would print with the same\r\narguments. Notice the use of the conditional if in the first line, to\r\ninitialize s to either '' or the string value of the first argument.\r\n\r\ndef myprint(*args, sep=' ', end='\\n'):\r\n    s = (str(args[0]) if len(args) >= 1 else '') # handle 1st (if there) special\r\n    for a in args[1:]:\t \t      \t     \t # all others come after sep\r\n        s += sep + str(a)\r\n    s += end\t\t\t\t\t # end at the end\r\n    print(s,end='')\t\t\t\t # print the entire string s\r\n\r\nmyprint('a',1,'x')\t\t   # prints a line\r\nmyprint('a',1,'x',sep='*',end='E') # prints a line but stays at end\r\nmyprint('a',1,'x')\t\t   # continues at end of previous line\r\n\r\nTogether when executed, these print\r\n\r\na 1 x\r\na*1*xEa 1 x\r\n\r\nThis is what would be printed if the print (not myprint) function was called.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nConstructors operating on Iterable values to Construct Data\r\n\r\nList, Tuples, Sets:\r\n\r\nPython's \"for\" loops allow us to iterate through all the components of any\r\niterable data. We can even iterate through strings: iterating over their\r\nindividual characters. Later in the quarter, we will study iterator protocols\r\nin detail, both the special iter/__iter__ and next/__next__ methods in classes,\r\nand generators (which are very very similar to functions, with a small but\r\npowerful twist). Both will improve our understanding of iterators and also\r\nallow us to write our own iterable data types (classes) easily. \r\n\r\nCertainly we know about using \"for\" loops and iterable data (as illustrated by\r\nlots of code above). What I want to illustrate here is how easy it is to\r\ncreate lists, tuples, and sets from anything that is iterable by using the\r\nlist, tuple, and set constructors (we'll deal with dict constructors later in\r\nthis section). For example, in each of the following the constructor for the\r\nlist/tuple/set objects iterates over the string argument to get the 1-char\r\nstrings that become the values in the list/tuple/set object.\r\n\r\nl = list ('radar') then l is ['r', 'a', 'd', 'a', 'r']\r\nt = tuple('radar') then t is ('r', 'a', 'd', 'a', 'r')\r\ns = set  ('radar') then s is {'a', 'r', 'd'} or {'d', 'r', 'a'} or ...\r\n\r\nNote that lists/tuples are ORDERED, so whatever the iteration order of their\r\niterator argument is, the values in the list/tuple will be the same order.\r\nContrast this with sets, which have (no duplicates and) no special order. So,\r\nset('radar') can print its three different values in any order.\r\n\r\nLikewise, since tuples/sets are iterable, we can also compute a list from a\r\nlist, a list from a a tuple, or a list from a set. Using l, t, and s from above.\r\n\r\nlist(t) which is ['r', 'a', 'd', 'a', 'r']\r\nlist(s) which is ['r', 'd', 'a']  assuming s iterates in the order 'r', 'd', 'a'\r\nlist(l) which is ['r', 'a', 'd', 'a', 'r']\r\n\r\nThe last of these iterates over the list to create a new list with the same\r\nvalues: note that l is list(l) is False, but l == list(l) is True: there are\r\ntwo different lists, but they store the same contents (see the next section on\r\n\"is\" vs \"==\" for more details).\r\n\r\nLikewise we could create a tuple from a list/set, or a set from a list/tuple.\r\nAll the constructors handle iterable data, producing a result of the specified\r\ntype by iterating over their argument. \r\n\r\nNote that students sometimes try to use a list constructor to create a list with\r\none value. They write list(1), by Python responds with \"TypeError: 'int' object\r\nis not iterable\" because the list constructor is expecting an iterable argument.\r\nThe correct way to specify this list with one value is [1]. Likewise for tuples,\r\nsets, and dictionaries.\r\n\r\nProgram #1 will give you lots of experience with these data types and when and\r\nhow to use them. The take-away now is it is trivial to convert from one of these\r\ndata types to another, because the constructors for their classes all allow\r\niterable values as their arguments, and all these data types (and strings as\r\nwell) are iterable (can be iterated over).\r\n\r\n\r\nDictionary Constructors:\r\n\r\nBefore leaving this topic, we need to look at how dictionaries fit into the \r\nnotion of iterable. There is not just ONE way to iterate through dictionaries,\r\nbut there are actually THREE ways to iterate through dictionaries: by keys, by\r\nvalues, and by items (each item a 2-tuple with a key folowed by its associated\r\nvalue).  Each of these is summoned by a method name for dict, and the methods\r\nare named the same: keys, values, and items.\r\n\r\nSo if we write the following to bind d to a dict (we will discuss this \"magic\"\r\nconstructor soon)\r\n\r\nd = dict(a=1,b=2,c=3,d=4,e=5) # the same as d = {'a':1,'b':2,'c':3,'d':4,'e':5}\r\n\r\nThen we can create lists of three aspects of the dict:\r\n\r\nlist(d.keys  ()) is like ['c', 'b', 'a', 'e', 'd']\r\nlist(d.values()) is like [3, 2, 1, 5, 4]\r\nlist(d.items ()) is like [('c', 3), ('b', 2), ('a', 1), ('e', 5), ('d', 4)]\r\n\r\nI said \"is like\" because sets and dicts are NOT ORDERED: in the first case we\r\nget a list of the keys; in the second a list of the values; in the third a list\r\nof item tuples, where each tuple contains one key and its associated value. But\r\nin all three cases, the list's values can appear in ANY ORDER.\r\n\r\nNote that the keys in a dict are always unique, but there might be duplicates\r\namong the values: try the code above with d = dict(a=1,b=2,c=1). Items are\r\nunique because they contain keys (which are unique).\r\n\r\nAlso note that if we iterate over a dict without specifying how, it is\r\nequivalent to specifyihg d.keys(). That is\r\n\r\nlist(d) is the same as list(d.keys()) which is like ['a', 'c', 'b', 'e', 'd']\r\n\r\nOne way to construct a dict is to give it an iterable, where each value\r\nis either a 2-tuple or 2-list: a key followed by its associated value. So, we\r\ncould have written any of the following to initialize d:\r\n\r\nd = dict( [['a', 1], ['b', 2], ['c', 3], ['d', 4], ['e', 5]] ) #list of  2-list\r\nd = dict( [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)] ) #list of  2-tuple\r\nd = dict( (['a', 1], ['b', 2], ['c', 3], ['d', 4], ['e', 5]) ) #tuple of 2-list\r\nd = dict( (('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)) ) #tuple of 2-tuple\r\n\r\nor, even (a tuple that has a mixture of 2-tuples and 2-lists in it)\r\n\r\nd = dict( (('a', 1), ['b', 2], ('c', 3), ['d', 4], ('e', 5)) )\r\n\r\nor even (a set of 2-tuples; we cannot have a set of 2-list (see hashable below)\r\n\r\nd = dict( {('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)} )\r\n\r\nThe bottom line is that a positional dict argument must be iterable, and each\r\nvalue in the iterable must have 2 values (e.g., a 2-list or 2-tuple) that\r\nrepresent a key followed by its associated value.\r\n\r\nWe can also combine the two forms writing \r\nd = dict( {('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)}, f=6, g=7)\r\n\r\nFinally, if we wanted to construct a dict using the keys/values in another\r\ndict, here are two easy ways to do it\r\n\r\nd_copy = dict(d)\r\n\r\nor\r\n\r\nd_copy = dict(d.items())\r\n\r\nIn both cases the dict constructor creates a new dictionary by iterating through\r\nthe (key,value) 2-tuples.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSharing/Copying:  is vs. ==\r\n  (one more time: see Binding (and Drawing Names and their associated Objects)\r\n\r\nIt is important to understand the fundamental difference between two names\r\nsharing an object (bound to the same object) and two names referring/bound to\r\n\"copies of the same object\". Note that if we mutate a shared object, both names\r\n\"see\" the change: both are bound to the same object which has mutated. But if\r\nthey refer to different copies of an object, only one name \"sees\" the change.\r\n\r\nNote the difference between the Python operators is and ==. Both return boolean\r\nvalues. The first asks whether two references/binding are to the same object\r\n(the is operator is called the (object)identity operator); the second asks only\r\nwhether the two objects store the same values. See the different results\r\nproduced for the example below. Also note that if x is y is True, then x == y\r\nmust be True too: an object ALWAY stores the same values as itself. But if\r\nx == y is True, x is y may or may not be True.\r\n\r\nFor example, compare execution of the following scripts: the only difference\r\nis the second statement in each: y = x vs. y = list(x)\r\n\r\nx = ['a']\r\ny = x\t\t# Critical: y and x share the same reference\r\nprint('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)\r\nx [0] = 'z'\t# Mutate x (could also append something to it)\r\nprint('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)\r\n\r\nThis prints\r\nx: ['a'] y: ['a'] x is y: True x == y: True\r\nx: ['z'] y: ['z'] x is y: True x == y: True\r\n\r\nx = ['a']\r\ny = list(x)\t# Critical: y refers to a new list with the same contents as x\r\nprint('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)\r\nx [0] = 'z'\t# Mutate x (could also append something to it: x+)\r\nprint('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)\r\n\r\nThis prints\r\nx: ['a'] y: ['a'] x is y: False x == y: True\r\nx: ['z'] y: ['a'] x is y: False x == y: False\r\n\r\nYou might have learned about the id function: it returns a unique integer for\r\nany object. It is often implemented to return the first address in memory at\r\nwhich an object is stored, but there is no requirement that it returns this int.\r\nChecking \"a is b\" is equivalent to checking \"id(a) == id(b)\" but the first way\r\nto do this check (with the is operator) is preferred (and is faster).\r\n\r\nFinally there is a copy module in Python that defines a copy function: it\r\ncopies some iterable without us having to specify the specific constructor\r\n(like list, set, tuple, or dict).\r\n\r\nSo we can import it as: from copy import copy\r\n\r\nAssuming x is a list, we can replace y = list(x) by y = copy(x).\r\nLikewise, if x is a dict we can replace y = dict(x) by y = copy(x).\r\n\r\nWe could also just: import copy (the module) and then write y = copy.copy(x)\r\nbut it is clearer in this case to write \"from copy import copy\". Here is a\r\nsimple implementation of copy:\r\n\r\ndef copy(x):\r\n    return type(x)(x)\r\n\r\nwhich finds the type of x, then calls it as a constructor to construct a new\r\nobject of that type, intialized by x: iterating over all the values in x, as\r\nwe say in examples list list('abc') producing ['a', 'b', 'c'].\r\n\r\n----------\r\n\r\nNote that copying in all the ways that we have discussed is SHALLOW. That means\r\nthe \"copy\" is a new object, but that object stores all the references from the\r\n\"object being copied\". For example, if we write\r\n\r\n  x = [1, [2]]\r\n  y = list(x) # or y = copy(x) or y = x[:]\r\n\r\nthen we would draw the following picture for these assignments.\r\n\r\n                list              list\r\n            (-----------)      (-------)        \r\n  x         |   0   1   |      |   0   |        int\r\n+---+\t    | +---+---+ |      | +---+ |       (---)\r\n| --+------>| | | | --+-+----->| | --+-+-----> | 2 |\r\n+---+\t    | +-+-+---+ |      | +---+ |       (---)\r\n\t    (---+-------)      (-------)\r\n                |                  ^\r\n\t\tv\t           |\r\n\t       int\t\t   |\r\n\t      (---)\t\t   |\r\n\t      | 1 |<--------+\t   |\r\n\t      (---)\t    |\t   |\r\n\t      \t\t    |\t   |\r\n                list\t    |\t   |\r\n            (-----------)   |\t   |\r\n  y         |   0   1   |   |\t   |\r\n+---+\t    | +---+---+ |   |\t   |\r\n| --+------>| | | | --+-+---+------+\r\n+---+\t    | +-+-+---+ |   |\r\n\t    (---+-------)   |\r\n                |           |\r\n                +-----------+\r\n\r\nHere, x and y refer to DIFFERENT lists: but all the references in x's list are\r\nidentical to the references in y's list. Using the 'is\" operator we can state\r\nthat (1) x[0] is y[0] == True, and (2) x[1] is y[1] == True.\r\n\r\nThis means if we now write x[1][0] = 'a', then print(y[1][0]) prints 'a' too,\r\nbecause x[1] and y[1] refer to the same list.\r\n\r\nWe will discuss how to do DEEP copying when we discuss recursion later in the\r\ncourse; it is implemented in the copy module by the function named deepcopy,\r\nwhich does a deep copy of an object, by constucting an object of that type and\r\npopulating it with deep copies of all the objects in the original object.\r\n\r\nBut, if we wrote\r\n  from copy import deepcopy\r\n  x = [1, [2]]\r\n  y = deepcopy(x)\r\n\r\nthen we would draw the following picture for these assignments.\r\n\r\n                list              list\r\n            (-----------)      (-------)        \r\n  x         |   0   1   |      |   0   |       int\r\n+---+\t    | +---+---+ |      | +---+ |       (---)\r\n| --+------>| | | | --+-+----->| | --+-+-----> | 2 |\r\n+---+\t    | +-+-+---+ |      | +---+ |       (---)\r\n\t    (---+-------)      (-------)         ^\r\n                |                                |\r\n\t\tv                                |\r\n\t       int                               |\r\n\t      (---)\t\t\t\t |\r\n\t      | 1 |<--------+                    |\r\n\t      (---)\t    |                    |\r\n\t      \t\t    |                    |\r\n                list\t    |      list          |\r\n            (-----------)   |   (-------)        |\r\n  y         |   0   1   |   |   |   0   |        |\r\n+---+\t    | +---+---+ |   |   | +---+ |        |\r\n| --+------>| | | | --+-+---+-->| | --+-+--------+\r\n+---+\t    | +-+-+---+ |   |   | +---+ |\r\n\t    (---+-------)   |   (-------)\r\n                |           |   \r\n                +-----------+\r\n\r\nIn a deep copy, all the mutable objects referred to are copied, but the\r\nimmutable ones referred to are not copied.\r\n\r\nFor more information on mutable, see the next section.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHashable vs. Mutable and how to Change Things:\r\n\r\nPython uses the term Hashable, which has the same meaning as Immutable. So\r\nhashable and mutable are OPPOSITES: You might see this message relating to\r\nerrors when using sets with UNHASHABLE values or dicts with UNHASHABLE keys:\r\nsince hashable means immutable, then un-hashable means un-immutable which\r\nsimplifies (the two negatives cancel) to mutable. So unhashable means the same\r\nas mutable. So\r\n\r\nhashable    means the same as immutable\r\nunhashalble means the same as mutable\r\n\r\nHere is a quick breakdown of standard Python types\r\n\r\nHashable/immutable: numeric values, strings, tuples containing\r\n                      hashable/immutable data, frozenset\r\nmutable/unhashable: list, sets, dict\r\n\r\nThe major difference between tuples and lists in Python is the former is\r\n(mostly) hashable/immutable and the later is not. I say mostly because if a\r\ntuple contains mutable data, you can mutate the mutable data part. So\r\n\r\n  x = (1, 2, [3, 4])\r\n  x[2][0] = 'a'\r\n  print(x)\r\n\r\nprints \r\n\r\n  (1, 2, ['a', 4])\r\n\r\nSo you have mutated the tuple because you mutated the list stored in index 2\r\nof the tuple. On the other hand, you cannot append to a tuple, nor store a new\r\nvalue in one of its indexes (x[0] = 10 is not allowed).\r\n\r\nSo technically, a tuple storing hashable/immutable values is hashable/immutable,\r\nbut a tuple storing unhashable/mutable values is unhashable/mutable. So if some\r\nother datatype (e.g., values in a set, or keys in a dictionary) needs to be\r\nhashable/immutable, use a tuple (storing hashable/immutable values) to\r\nrepresent its value, not a list. Thus we cannot say, \"Any value whose type is a\r\ntuple is hashable/immutable.\" Instead we must say, \"A value whose type is a\r\ntuple is hashability/immutability when the tuple stores only hashable/immutable\r\nvalues.\"\r\n\r\nA frozenset can do everything that a set can do, but doesn't allow any mutator\r\nmethods to be called (so we cannot add a value to or delete a value from a\r\nfrozenset). Thus, we can use a frozen set as a value in a set or a key in a\r\ndictionary.\r\n\r\nThe constructor for a frozenset is frozenset(...) not {}. Note that once you've\r\nconstructed a frozen set you cannot change it (because it is immutable). If you\r\nhave a set s and need an equivalent frozenset, just write frozenset(s).\r\n\r\nThe function hash takes an argument that is hashable (otherwise it raises\r\nTypeError, with a message about a value from an unhashable type) and returns\r\nan int.\r\n\r\nWe will study hashing towards the end of the quarter: it is a technique for\r\nallowing very efficient operations on sets and dicts. ICS-46 (Data Structures)\r\nstudies hash tables in much more depth, in which you will implement the\r\nequivalent of Python sets and dicts by using hash tables.\r\n\r\n------\r\nInterlude: unique objects\r\n\r\nSmall integer objects are unique in Python. If we assign x = 1 and y = 1, then\r\nx is y evaluates to True (but you should use == and != for comparing integers).\r\nLikewise, if we write x += 1 and y *= 2 then x is y evaluates to True. But if we\r\nwrite x = 10**100 and y = 10**100. then x is y is False (but x == y is True, as\r\nexpected).\r\n\r\nTo save space, Python allocates only one object for each small int. When a small\r\nint is computed, Python first looks to see if an object with that value already\r\nexists, and if it does, returns a reference to it; if it doesn't, it makes a new\r\nobject storing that values and returns a reference to it. This is a tradeoff\r\nthat minimizes the space (occupied by objects) but increases the time to do\r\ncomputations (by having to first look to see if an object for a value already\r\nexists).\r\n\r\nGenerally, because ints are immutable, there are no bad consequences in sharing\r\nobjects in this way: once a name is bound to an int object, that int object\r\nwill always represent the same value, because ints are immutable.\r\n\r\nAgain, constrast this with writing lists, which always allocate new objects. If\r\nwe write \r\n\r\nx = ['a']\r\ny = ['a']\r\n\r\nThen x is y evaluates to False. Because lists are mutable, this is the only\r\ncorrect way to implement lists.\r\n\r\nThe situation with strings (also immutable) is similar but more complicated.\r\nWhether \"is\" operating on two strings with the same characters is True depends\r\non things like the length of the strings and whether the string was computed or\r\nentered by the user in the console. If we write\r\n\r\nx = 'ab'\r\ny = 'a'+'b'\r\nz = input('Enter string') # and enter the string ab when prompted\r\n\r\nx is y evaluates to True, but x is z evaluates to False. As with integers, it is\r\nbest to compare strings with == and != and not use the \"is\" or \"is not\"\r\noperators on them.\r\n\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------ \r\n\r\nEnd of 2nd Lecture on this material\r\n\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------ \r\n\r\nComprehensions: list, tuple, set, dict\r\n\r\nList, Tuple, Set Comprehensions:\r\n\r\nComprehensions are compact ways to create complicated (but not too complicated)\r\nlists, tuples, sets, and dicts. That is, they compactly solve some problems but\r\ncannot solve all problems (for example, we cannot use them to mutate values in\r\nan existing data structure, just to create values in a new data structure). The\r\ngeneral form of a list comprehension is as follows, where f means any function\r\nusing var (or expression using var: we can also write just var there because a\r\nname by itself is a very simple expression) and p means any predicate (or bool\r\nexpresssion) using var.\r\n\r\n[f(var,...) for var in iterable if p(var,...)]\r\n\r\nMeaning: collect together into a list (list because of the outer []) all of\r\nf(var,...) values, for var taking on every value in iterable, but only collect\r\nan f(var,...) value if its corresponding p(var,...) is True.\r\n\r\nFor tuple or set comprehensions, we would use () and {} as the outermost\r\ngrouping symbol instead of []. We'll talk about dicts later in this section:\r\nthey use also use {} but also include a : inside (separating keys from values)\r\nto be distinguised from sets, which use {} without any such : inside.\r\n\r\nNote that the \"if p(var,...)\" part is optional, so we can also write the\r\nsimplest comprehensions as follows (in which case it has the same meaning as\r\np(var,...) always being True).\r\n\r\n[f(var,...) for var in iterable]\r\n\r\n   which has the same meaning as\r\n\r\n[f(var,...) for var in iterable if True]\r\n\r\nfor example\r\n\r\nx = [i**2 for i in irange(1,10) if i%2==0]\t# note: irange not range\r\nprint(x)\r\n\r\nprints the squares of all the integers from 1 to 10 inclusive, but only if the\r\ninteger is even (computed as leaving a remainder of 0 when divided by 2). Run \r\nit. Change it a bit to get is to do something else. Here is another example\r\n\r\nx = [2*c for c in 'some text' if c in 'bcdfghjklmnpqrstvwxz']\r\nprint(x)\r\n\r\nwhich prints a list with strings with doubled characters for all the consonants\r\n(no aeiouy -or spaces for that matter) in the string 'some text':\r\n['ss', 'mm', 'tt', 'xx', 'tt'].\r\n\r\nWe can translate any list comprehension into equivalent code that uses more\r\nfamiliar Python looping/if/list appending features.\r\n\r\nx = []\t       \t  \t   # start with an empty list\r\nfor var in iterable:\t   # iterate through iterable\r\n   if p(var):\t\t   # if var is acceptable?\r\n       x.append(f(var))\t   # add f(var) next in the list\r\n\r\nBut often using a comprehension (in the right places: where you want to\r\ncreate from scratch some list, tuple, set or dict) is simpler. Not all lists\r\nthat we build can be written as simple comprehensions, but the ones that can\r\nare often very simple to write, read, and understand when written as\r\ncomprehensions. They tend to be more efficient too.\r\n\r\nWhat comprehensions aren't good for is putting information into a data structure\r\nand then mutating/changing it during the execution of the comprehension; for\r\nthat job you need code more like the for loop above. So when deciding whether or\r\nnot to use a comprehension, ask youself if you can specify each value in the\r\ndata structure once, without changing it (as was done above, using\r\ncomprehensions). Or try to write the code as a comprehension first; if you\r\nfail, then try to write it using more complicated statements in Python.\r\n\r\nNote that we can add-to (mutate) lists, sets, and dicts, but not tuples. For\r\ntuples we would have to write this code with x = () at the top and\r\nx = x + (var,) in the middle: which builds an entirely new tuple by\r\nconcatenating the old one and a one-tuple (containing only x) and then binding\r\nx to the newly constructed tuple. For large tuples, this process is very slow.\r\nDon't worry about these details, but understand that unlike lists and sets,\r\ntuples have no mutator methods: so x.append(...)/x.add(...) is not allowed.\r\n\r\nHere is something interesting (using a set comprehension: notice {} around the\r\ncomprehension.\r\n\r\nx = {c for c in \"I've got plenty of nothing\"}\t# note ' in str delimited by \"\r\nprint(sorted(x))\r\n\r\nIt prints a set of characters (printing in a list, in sorted order, created by\r\nsorted(x)) in the string but because it is a set, each character occurs one\r\ntime). So even though a few c's have the same value, only one of each appears in\r\nthe set because of the semantics/meaning of sets. Note it prints as as the list\r\n\r\n[' ', \"'\", 'I', 'e', 'f', 'g', 'h', 'i', 'l', 'n', 'o', 'p', 't', 'v', 'y']\r\n\r\nbecause sorted takes the iterable set created and produces a sorted list as a\r\nresult.\r\n\r\nIf we used a list comprehension instead of a set comprehension, the result would\r\nbe much longer because, for example, the character 't' would occur 3 times in a\r\nlist (but occurs only once in a set).\r\n\r\nNote the following: binding values to for loop variables (both outside/inside\r\nof comprehensions) do not affect the same variable name outside the scope of\r\nthe for loop. Both\r\n\r\nx = 'ABC'     \t       \t\tx = 'ABC'\r\nfor x in range(1,5):\t\ty = [x for x in range(1,5)]\r\n   pass\t \t\t\tprint(x)\r\nprint(x)\r\n\r\nprint ABC after the loop/comprehension finishes. The x outside the loop (or\r\ncomprehension) is considered a different variable than the x inside the loop\r\n(or comprehension). The reason is similar to why\r\n\r\nx = 'ABC'\r\ndef f():\r\n  x = 1\r\nf()\r\nprint(x)\r\n\r\nalso prints ABC after the function call. A for loop (like a function) creates\r\nits own scope for the loop's index variable(s) - remember there can be more\r\nthan one. \r\n\r\nDict Comprehensions:\r\n\r\nThe form for dict comprehensions is similar, here k and v are functions (or\r\nexpressions) using var. Notice the {} on the outside and the : on the inside,\r\nseparating the key from the value. That is how Python knows the comprehension\r\nis a dict not a set.\r\n\r\n{k(var,...) : v(var,...) for var in iterable if p(var,...)}\r\n\r\nSo,\r\n\r\nx = {k : len(k) for k in ['one', 'two', 'three', 'four', 'five']}\r\nprint(x)\r\n\r\nprints a dictionary that stores keys that are these five words whose associated\r\nvalues are the lengths of these words. Because dicts aren't ordered, it could\r\nprint as {'four': 4, 'three': 5, 'one': 3, 'five': 4, 'two': 3}\r\n\r\nFinally, we can write a nested comprehension, although they are harder to\r\nunderstand than simple comprehensions.\r\n\r\nx = {c for word in ['i', 'love', 'new', 'york'] for c in word if c not in 'aeiou'}\r\nprint(x)\r\n\r\nIt says to collect c's, by looking in each word in the list, and looking at\r\neach character c in each word: so the c collected at the beginning is the c\r\nbeing iterated over in the second part of the comprehension (for c in word...).\r\n\r\nIt prints a set of each different letter that is not a vowel, in each word\r\nin the list. I could produce this same result by rewriting the outer part of the\r\ncomprehension as a loop, but leaving the inner one as a comprehension (union\r\nmerges two sets: does a bunch of adds).\r\n\r\nx = set()                    # empty set: cannot use {} which is an empty dict\r\nfor word in ['i', 'love', 'new', 'york']:\r\n    x = x.union( {c for c in word if c not in 'aeiou'} )\r\nprint(x)\r\n\r\nor write it with no comprehensions at all\r\n\r\nx = set()\r\nfor word in ['i', 'love', 'new', 'york']:\r\n    for c in word:\r\n        if c not in 'aeiou':\r\n            x.add(c)\r\nprint(x)\r\n\r\nSo which of these is the most comprehendable: the pure comprehension, the\r\nhybrid loop/comprehension, or the pure nested loops? What is important is that\r\nwe know how all three work, can write each correctly in any of these ways,\r\nand then we can decide afterwords which way we want the code to appear. As we\r\nprogram more, our preferences might change. I'd probably prefer the first one\r\n(because I've seen lots of double comprehensions), but the middle one is\r\nalso reasonable.\r\n\r\nWhat do you think the following nested (in a different way) comprehension\r\nproduces?\r\n\r\nx = {word : {c for c in word} for word in ['i', 'love', 'new', 'york']}\r\n\r\nCheck your answer by executing this code in Python and printing x.\r\n\r\nFinally, here is a version of myprint (written above in the section on the\r\nbinding of arguments and parameters) that uses a combination of the .join\r\nfunction and a comprehension to create the string to print simply.\r\n\r\nThe .join function (discussed more in depth below) joins all the string values\r\nin an iterable into a string using the prefix operator as a separator:\r\n'--'.join( ['My', 'dog', 'has', 'fleas'] )\r\nreturns the string 'My--Dog--has--fleas'\r\n\r\ndef myprint(*args,sep=' ',end='\\n'):\r\n    s = sep.join(str(x) for x in args)+end       # create string to print\r\n    print(s,end='')\t\t\t\t # print the string\r\n\r\nWARNING: Once students learn about comprehensions, sometimes they go a bit\r\noverboard as they learn about/use this feature. Here are some warning signs:\r\nWhen writing a comprehension, you should (1) use the result produced in a later\r\npart of the computation and (2) typically not mutate anything in the\r\ncomprehension. If the purpose of your computation is to mutate something,\r\ndon't use a comprehension. Over time you will develop good instincts for when\r\nto use comprehensions.\r\n\r\n\r\nTuple Comprehensions are special:\r\n\r\nThe result of a tuple comprehension is special. You might expect it to produce\r\na tuple, but what it does is produce a special \"generator\" object that we can\r\niterate over. We will discuss generators in detail later in the quarter, so for\r\nnow we will examine just some simple examples. Given the code\r\n\r\nx = (i for i in 'abc')  # tuple comprehension\r\nprint(x)\r\n\r\nYou might expect this to print as ('a', 'b', 'c') but it prints as\r\n<generator object <genexpr> at 0x02AAD710>\r\n\r\nThe result of a tuple comprehension is not a tuple: it is actually a generator.\r\nThe only thing that you need to know now about a generator is just that you can\r\niterate over it, but ONLY ONCE. So, given the code\r\n\r\nx = (i for i in 'abc')\r\nfor i in x:\r\n    print(i)\r\nfor i in x:\r\n    print(i)\r\n\r\nit prints\r\na\r\nb\r\nc\r\n\r\nYes, it prints a, b, c and just prints it once: after the first loop finishes,\r\nthe generator is exhausted so the second loop prints no more values. We will\r\nspend a whole lecture studying the details of generators later in the quarter.\r\n\r\nSpecifically, if x is defined as above, we cannot call len(x) or x[1]: it is\r\nnot a tuple, it is a generator. All we can do it iterate over x.\r\n\r\nRecall our discussion of changing any iterable into a list, tuple, or set by\r\niterating over it; we can iterate over a tuple comprehension. So if we wrote\r\nt  = tuple(x) or t = tuple( (i for i in 'abc') ), then print(t) would print\r\n('a', 'b', 'c'). In fact, we could even write t = tuple(i for i in 'abc')\r\nbecause (1) by default, comprehensions are tuple comprehensions; (2) in a\r\nfunction call with exactly one argument, we can omit the () specifying a tuple\r\ncomprehension (but with multiple arguments we must supply the parentheses).\r\n\r\nOf course, we could also write things like :\r\nl = list(i for i in 'abc')\r\ns = set (i for i in 'abc')\r\n\r\nbut these are equivalent to writing the standard comprehensions more simply\r\n(and efficiently) as:\r\nl = [i for i in 'abc']\r\ns = {i for i in 'abc'}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nNine Important/Useful Functions: split/join, any/all, sum/min/max, zip/enumerate\r\n\r\nThe split/join methods\r\n\r\nBoth split and join are methods in the str class: if s is some string, we call\r\nthem by writing s.split(...) or s.join(....)\r\n\r\nThe split method also takes one str argument as .... and the result it returns\r\nis a  list of of str. For example 'ab;c;ef;;jk'.split(';') returns the list of\r\nstr\r\n\r\n['ab', 'c', 'ef', '', 'jk']\r\n\r\nIt uses the argument str ';' to split up the string (the one prefixing the\r\n.split call), into slices that come before or after every ';'.\r\n\r\nNote that there is an empty string between 'ef' and 'j' because two adjacent\r\nsemi-colons appear between them in the string. If we wanted to filter out such\r\nempty strings, we can easily do so by embedding the call to split inside a\r\ncomprehension: writing [s for s in 'ab;c;ef;;jk'.split(';') if s != '']\r\nproduces the list ['ab', 'c', 'ef', 'jk'].\r\n\r\nBecause the prefix and regular arguments are both strings, students sometime\r\nreverse these two operands: what does ';'.split('ab;c;ef;;jk') produce and why?\r\n\r\nThe split method is very useful to call after reading lines of text from a file,\r\nto parse (split) these lines into their important constituent information.\r\nYou will use split in all 5 parts of Programming Assignment #1.\r\n\r\n-----\r\n\r\nThe join method also takes one iterable argument (it must produce str values) \r\nas ....; the result it returns is a str. For example\r\n';'.join(['ab', 'c', 'ef', '', 'jk']) returns the str\r\n\r\n'ab;c;ef;;jk'\r\n\r\nIt merges all the strings produced by iterating over its argument into one big\r\nstring, with all the strings produced by iterating over its argument\r\nconcatenated together and separated from each other by the ';' string.\r\n\r\nSo, split and join are opposites. Unfortunately, the splitting/joining string\r\n';' appears as the argument inside the () in split, but it appears as the prefix\r\nargument before the call in join. This inconsistency can be confusing.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe all/any functions (and their use with tuple comprehensions)\r\n\r\nThe \"all\" function takes one iterable argument (and returns a bool value): it\r\nreturns True if ALL the bool values produced by the iterable are True; it can\r\nstop examining values and return a False result when the first False is produced\r\n(ultimately, if no False is produced it returns True).\r\n\r\nThe \"any\" function takes one iterable argument (and returns a bool value): it\r\nreturns True if ANY the bool values produced by the iterable are True; it can\r\nstop examining values and return a True result when the first True is produced\r\n(ultimately, if no True is produced it returns False).\r\n\r\nThese functions can be used nicely with tuple comprehensions. For example, if\r\nwe have a list l of numbers, and we want to know whether all these numbers are\r\nprime, we can call\r\n\r\n  all( predicate.is_prime(x) for x in l )\r\n\r\nwhich is the same as calling\r\n\r\n  all( (predicate.is_prime(x) for x in l) )\r\n\r\nand similar (but more time/space-efficient) than calling\r\n\r\n  all( [predicate.is_prime(x) for x in l] )\r\n\r\nThe list comprehension computes the entire list of boolean values and then\r\n\"all\" iterates over this list. When \"all\" iterates over a tuple comprehension,\r\nthe tuple comprehension computes values one at a time and \"all\" checks each: if\r\none is False, the tuple comprehension returns False immediately and does not\r\nhave to compute any further values in the tuple comprehension.\r\n\r\n-----Efficiency Interlude\r\nThe tupel comprehension version can be much more efficient, if a False value is\r\nfollowed by a huge number of other values.\r\n\r\nFor example, calling\r\n\r\nall( predicate.is_prime(x) for x in range(2,1000000) )\r\n\r\nimmediately returns False because it checks whetehr 2 is prime (True), 3 is\r\nprime (True), 4 isn't prime (False: so all finishes executing, returning False).\r\n\r\nBut calling\r\n\r\nall( [predicate.is_prime(x) for x in range(2,1000000)] )\r\n\r\ntakes a very long time to return False. It first determines whether all values\r\nfrom 2 to 1,000,000 are prime (putting all these boolean values in the list\r\ncomprehension), and then looks at the first (True), the second (True), the\r\nthird (False: so all finishes executing, returning False).\r\n\r\nThis illustrates the very important difference between tuple comprehension and\r\nother kinds of comprehensions.\r\n-----End: Efficiency Interlude\r\n\r\nLikewise for the \"any\" function, which produces True the first time it examines\r\na True value.\r\n\r\nHere is how we can write these functions, which search for a False or a True\r\nrespectively:\r\n\r\ndef all(iterable):\r\n    for v in iterable:\r\n        if v == False\r\n            return False  # something was False; return False immediately\r\n    return True           # nothing   was False; return True after loop\r\n\r\ndef any(iterable):\r\n    for v in iterable:\r\n        if v == True\r\n            return True   # something was True; return True immediately\r\n    return False          # nothing   was True; return False after loop\r\n\r\nRead these functions. What does each produce if the iterable produces no values?\r\nWhy is that reasonable?\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe sum/max/min functions (and their use with tuple comprehensions)\r\n\r\nThe simple versions of the sum function takes one iterable argument. The sum\r\nfunction requires that the iterable produce numeric values that can be added.\r\nIt returns the sum of all the values produced by the iterable; if the iterable\r\nargument produces no values, sum returns 0. Actually, we can supply a second\r\nargument to the sum function; in this case, that value will be returned in the\r\nspecial case when the iterable produces no values; if the iterable does produce\r\nany values, the sum will be the actual sum plus this argument. We can think of\r\nsum as defined by\r\n\r\ndef sum(values, init_sum=0):\r\n    result = init_sum\r\n    for v in values:\r\n        result += v\r\n    return result\r\n\r\nThe simple versions of the max and min functions also each take one iterable\r\nargument.\r\n\r\nThe min/max functions require that the iterable produce values that can be\r\ncompared with each other; so calling min([2,1,3]) returns 1; and calling\r\nmin(['b','a','c']) returns 'a';  but calling min([2,'a',3]) raises a TypeError\r\nexception because Python cannot compare an integer to a string. These functions\r\nreturn the minimum/maximum value produced by their iterable argument; if the\r\niterable produces no values (e.g., min([]), min and max each raise a ValueError\r\nexception, because there is no minimum/maximum value that it can compute/return.\r\n\r\nThere are two more interesting properties to learn about the min and max\r\nfunctions.\r\n\r\nFirst, we can also call min/max specifying any number of arguments or if one\r\nargument, it must be iterable: so calling min([1,2,3,4]) -using a tuple which it\r\niterable- produces the same result as calling min(1,2,3,4) -using 4 arguments.\r\n\r\nWe can also specify a named argument in min/max: a key function just like the\r\nkey function used in sort/sorted. The min/max functions return the\r\nsmallest/largest value in its argument(s), but if the key function is supplied,\r\nit compares two values by calling the key function on each, not by directly\r\ncomparing these two value.\r\n\r\nFor example, min('abcd','xyz') returns 'abcd', because 'abcd' < 'xyz'. But if\r\nwe instead wrote min('abcd','xyz',key = (lambda x : len(x)) ) it would return\r\n'xyz' because len('xyz') < len('abcd'): that is, it compares the key function\r\napplied to all values in the iterable to determine which value to return.\r\n\r\nNote that min('abcd','wxyz',key = (lambda x : len(x)) ) will return 'abcd'\r\nbecause it is the first value that has the smallest result when the key\r\nfunction is called: the key function returns 4 for both values. We can think of\r\nthe min function operating on an iterable to be written as follows (although we\r\nwill learn Python features later on that simplifies the actual definition of\r\nthis function)\r\n\r\ndef min(*args,key = (lambda x : x) ): # default key is the identity function\r\n    if len(args) == 0:\r\n        raise TypeError('min: expected >=1 arguments, got 0')\r\n    if len(args) == 1:     # Assume that if min has just one argument\r\n        args = args[0]     #   it's iterable, so take the max over its values\r\n\r\n    answer = None\r\n    for v in args:\r\n        key_of_v = key(v)\r\n        if answer == None or key_of_v < key_of_answer:\r\n            answer = v\r\n            key_of_answer = key_of_v\r\n\r\n    return answer\r\n\r\nCalling min( ('abc','def','gh','ij'),key = (lambda x : len(x)) ) returns 'gh'.\r\nNote that the default value for the key function is a lambda that returns the\r\nvalue it is passed: this is called the identity function/lambda. \r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe zip and enumerate functions\r\n\r\nZip:\r\n\r\nThere is a very interesting function called zip that takes an arbitrary number\r\nof iterable arguments and zips/interleaves them together (like a zipper does\r\nfor the teeth on each side). Let's start by looking at just the two argument\r\nversion of zip.\r\n\r\nWhat zip actually produces is a generator -the ability to get the results of\r\nzipping- not the result itself. See the discussion above about how tuple\r\ncomprehensions produce generators.\r\n\r\nSo to \"get the result itself\" we should use a for loop or constructor (as shown\r\nin most of the examples below) to iterate over the generator result of calling\r\nzip. The following code\r\n\r\nz = zip( 'abc', (1, 2, 3) )           # String and tuple are iterator arguments\r\nprint('z:', z, 'list of z:', list(z))\r\n\r\nprints\r\n\r\nz: <zip object at 0x02A4D990> list of z: [('a', 1), ('b', 2), ('c', 3)]\r\n\r\nHere, z refers to a zip generator object; the result of using z in the list\r\nconstructor is [('a', 1), ('b', 2), ('c', 3)] which zips/interleaves the values\r\nfrom the first iterable and the values from the second:\r\n[(first from first,first from second),(second from first,second from second),  \r\n (third from first,third from second)]\r\n\r\nWhat happens when the iterables are of different lengths? Try it.\r\n\r\nz = zip( 'abc', (1, 2) )  # String and tuple for iterables\r\nprint(list(z))\t\t  # prints [('a', 1), ('b', 2)]\r\n\r\nSo when one iterable runs out of values to produce, the process stops. Here is\r\na more complex example with three iterable parameters of all different sizes.\r\nCan you predict the result it prints: do so, and only then run the code.\r\n\r\nz = zip( 'abcde', (1, 2, 3), ['1st', '2nd', '3rd', '4th'] )\r\nprint(list(z))\r\n\r\nwhich prints\r\n\r\n[('a', 1, '1st'), ('b', 2, '2nd'), ('c', 3, '3rd')]\r\n\r\nOf course, this generalizes for any number of arguments, interleaving them all\r\n(from first to last) until any iterable runs out of values. So the number of\r\nvalues in the result is the minimum of the number of values of the argument \r\niterables.\r\n\r\nNote one very useful way to use zip: suppose we want to iterate over values in\r\ntwo iterables simultaneously, i1 and i2, operating on the first pair of values\r\nin each, the second pair of values in each, etc. We can use zip to do this by\r\nwriting:\r\n\r\nfor v1,v2 in zip(i1,i2):\r\n    process v1 and v2: the next pair of values in each\r\n\r\nSo\r\n\r\nfor v1,v2 in zip ( ('a','b','c'), (1,2,3) ):\r\n    print(v1,v2)\r\n\r\nprints\r\n\r\na 1\r\nb 2\r\nc 3\r\n\r\nUsing zip, we can write a small function that computes the equivalent of the\r\n< (less than) operator for strings in Python (see the discussion above about\r\nthe meaning of < for strings).\r\n\r\ndef less_than(s1 : str, s2 : str)-> bool:\r\n    for c1,c2 in zip(s1,s2):   # examine 1st, 2nd, ... characters of each string\r\n        if c1 != c2:           # if current characters are different\r\n            return c1 < c2     #   compute result by comparing characters\r\n\r\n    # if all character from the shorter are the same (as in 'a' and 'ab')\r\n    # return a result based on the length of the strings\r\n    return len(s1)<len(s2)\r\n\r\nThis precisely caputures in Python code our prose discussion of the meaning of\r\ncomparing strings.\r\n\r\nEnumerate:\r\n\r\nFinally, this is a convenient time to toss in another important function:\r\nenumerate. It also also produces a generator as a result, but has just one\r\niterable argument, and an optional 2nd argument that is a starting number. It\r\nproduces tuples whose first values are numbers (starting at the value of the\r\nsecond parameter; omit a 2nd parameter and unsurprisingly, the starting number\r\nis 0) and whose second values are the values in the iterable. So, if we write\r\n\r\ne = enumerate(['a','b','c','d'], 5)\r\nprint(list(e))\r\n\r\nit prints [(5, 'a'), (6, 'b'), (7, 'c'), (8, 'd')]\r\n\r\nGiven l = ['a','b','c','d','e'] we could write the following code\r\n\r\nfor i in range(len(l)):\r\n    print(i+1,l[i])\r\n\r\n(which prints 1 a, 2 b, 3 c, 4 d, and 5 e on separate lines) more simply by\r\nusing enumerate (notice the use of parallel/tuple assignment for i,x):\r\n\r\nfor i,x in enumerate(l,1):\r\n     print(i,x)\r\n\r\nAnother nice example illustrating enumerate is reading a file a line at a time,\r\nand processing the line number and the line contents.\r\n\r\nInstead of writing \r\n\r\nline_number = 1\r\nfor line in open(\"file-name\"):\r\n    .... process line_number and line\r\n    line_number += 1\r\n\r\nwe can write just\r\n\r\nfor line_number, line in enumerate(open(\"file-name\"),1):\r\n    .... process line_number and line\r\n\r\nYou might ask now, why do these things (tuple comprehension, zip, enumerate)\r\nproduce generators and not just tuples or lists? That is an excellent question.\r\nIt goes right along with the excellent question why does sorted(...) produce a\r\nlist and not a generator? We will discuss these issues later in the quarter.\r\nThe generator question mostly has to do with space efficiency when iterating\r\nover very  many values. The sorted question has to do with why there is no way\r\nto do this operation in a space efficient way.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n**kargs for dictionary of not-matched named arguments in function calls\r\n\r\nRecall the use of *args in a function parameter list. It combines into one\r\ntuple a sequence of positional arugments. We can also write the symbol **kargs\r\n(we can write ** and any word, but kargs or kwargs are the standard ones). If\r\nwe use it to specify this kind of parameter, it must occur as the last\r\nparameter. kargs stands for keyword arguments. Basically, if Python has any \r\nkeywords arguments that do not match keyword parameters (see the large\r\ndiscussion of argument/paramteter binding above, which includes *args but\r\ndoesn't include **kargs) they are all put in a dictionary that is stored in the\r\nlast parameter named kargs.\r\n\r\nSo, imagine we define the following function\r\n\r\ndef f(a,b,**kargs):\r\n  print(a,b,kargs)\r\n\r\nand call it by\r\n\r\nf(c=3,a=1,b=2,d=4)\r\n\r\nit prints: 1 2 {'c': 3, 'd': 4}\r\n\r\nWithout **kargs, using the rules specified before, Python would report a\r\nTypeError exception (by rule M5(d)), because there are no parameter named\r\nc or d. \r\n\r\nBy the new rules, Python finds two named arguments (c=3 and d=4) whose names\r\ndid not appear as parameter names in the function header of f (which specifies\r\nonly a and b, and of course the special **kargs), so while Python directly\r\nbinds a to 1 and b to 2 (the parameter names specified in the function header,\r\nmatched to similarly named arguments) it creates a dictionary with all the\r\nother named arguments: {'c': 3, 'd': 4} and binds kargs to that dict.\r\n\r\nThe same result would be printed for the call\r\n\r\nf(1,2,d=4,c=3)\r\n\r\nWe will use **kargs to understand a special use of of dict constructors (below).\r\nWe will also use **kargs (and learn something new in the process) when\r\ndiscussing how to (1) call methods in decorators and (2) call overridden\r\nmethods using inheritance much later in the quarter.\r\n\r\nNote that to write a perfectly general function that is called with any kinds\r\nof arguments we can write\r\n\r\ndef g(*args,**kargs):\r\n  print(args,kargs)\r\n\r\nNow, any legal call of g (one with any legal combination of positional and\r\nnamed arguments) will populate the *args and **kargs structures appropriately.\r\n\r\nCalling\r\n\r\ng(1,2,c=3,d=4)     prints (1, 2) {'c': 3, 'd': 4}\r\ng(a=1,b=2,c=3,d=4) prints () {'c': 3, 'b': 2, 'a': 1, 'd': 4}\r\n\r\nGenerally, when a parameter name is prefixed by * and ** in a function header,\r\nwe omit the prefix when we use the parameter name inside the function. But\r\nthere are times where use use the * and ** prefixes.\r\n\r\ndef h(a,b,c,d):\r\n    print(a,b,c,d)\r\n\r\ndef i(*args,**kargs):\r\n  h(*args,**kargs)\r\n\r\nThe arguments *args and **kargs in the call of h expand the args tuple to\r\nbe positional arguments and the **kargs dictionary to be named arguments\r\n\r\nCalling\r\n\r\ni(1,2,c=3,d=4)     prints 1 2 3 4: it calls h(1,2,c=3,d=4)\r\ni(a=1,b=2,c=3,d=4) prints 1 2 3 4: it calls h(c=3,b=2,a=1,d=4)\r\n\r\nSummarizing:\r\n\r\n1) Writing * and ** when specifying parameters makes those parameters names\r\n   bind to a tuple/dict respectively.\r\n\r\n2) Using the parameter names by themselves in the function is equivalent to \r\n    using the tuple/dict respectively.\r\n\r\n3) Using * and ** followed by the parameter name as ARGUMENTS IN FUNCTION\r\n   CALLS expands all the values in the tuple/dict respectively to represent\r\n   all the arguments.\r\n\r\nExperiment with *args/**kargs as parameters of functions and args/kargs and\r\n*args/**kargs as arguments to other function calls.\r\n\r\n-----Interlude\r\nWe have seen that to call sorted with a lambda we must write something like\r\n\r\n  sorted(iterable, key = (lambda ...))\r\n\r\nOne might ask, is the key paraemeter to sorted the second one? Could we write\r\n\r\n  sorted(iterable, (labmda ...))\r\n\r\nto accomplish the same call? The answer is \"no\" we cannot. If we want to use\r\na lambda, we must write a named argument as  key = (lambda ...). Similarly, we\r\nmust write reverse = ....\r\n\r\nHow do you think the header of the sorted function is written?\r\n\r\n------------------------------------------------------------------------------\r\n\r\nLists, Tuples, Sets, Dictionaries (frozenset and defaultdict)\r\n\r\nYou need to have pretty good grasp of these important data types, meaning how to\r\nconstruct them and the common methods/operations we can call on them. Really\r\nyou should get familiar with reading the online documentation for all these\r\ndata types (see the Python Library Reference link on the homepage for the\r\ncourse).\r\n\r\n4. 6: Sequence Types includes Lists (mutable) and Tuples (immutable)\r\n4. 9: Set Types includes set (mutable) and frozenset (immutable)\r\n4.10: Mapping Types includes dict and defaultdict (both mutable)\r\n\r\nHere is a very short/condensed summary of these operations. Experiment with\r\nthem in Eclipse.\r\n\r\n-----\r\n\r\n4.6: Sequence Types includes Lists (mutable) and Tuples (immutable)\r\nThese sequence operations (operators and functions) are defined in 4.6.1\r\n   x in s, x not in s, s + t, s * n, s[i], s[i:j], s[i:j:k], len(s), min(s), \r\n   max(s), s.index(x[, i[, j]]), s.count(x)\r\n\r\nMutable sequence allow the following operations, defined in 4.6.3\r\n  s[i] = x , s[i:j] = t, del s[i], s[i:j:k] = t, del s[i:j:k], s.append(x)\r\n  s.clear(), s.copy(), s.extend(t), s.insert(i, x), s.pop(), s.pop(i),\r\n  s.remove(x), s.reverse()\r\n\r\n  It also discusses list/tuple constructors and sort for list.\r\n\r\n  note that the append method is especially important for building up sequences\r\n  like lists. Also to return and remove a value from a sequence, we call\r\n    x = s.pop(i)\r\n  is equivalent to \r\n    x = s[i]\r\n    del s[i]\r\n  and calling s.pop() uses the value len(s)-1 (the last index in the sequence)\r\n\r\n-----\r\n\r\n4. 9: Set Types includes set (mutable) and frozenset (immutable)\r\nThese set (operators and functions) are defined in 4.6.1.9\r\n  len(s), x in s, x not in s, isdisjoint(other), issubset(other), set <= other, \r\n  set < other, issuperset(other), set >= other, set > other, union(other, ...),\r\n  intersection(other, ...), difference(other, ...), symmetric_difference(other),\r\n  copy; also the operators | (for union), & (for intersection), - (for\r\n  difference), and ^ (for symmetic difference)\r\n\r\nSets, which are mutable, allow the following operations\r\n  update(other, ...), intersection_update(other, ...),\r\n  difference_update(other, ...), symmetric_difference_update(other), add(elem),\r\n  remove(elem), discard(elem), pop(), clear(); also the operators |= (union\r\n  update), &= (intersection update), -= (difference update), ^= (symmetric\r\n  difference update)\r\n\r\n-----\r\n\r\n4.10: Mapping Types includes dict and defaultdict (both mutable)\r\nThese dict (operators and functions) are defined in 4.10\r\n  d[key] = value , del d[key], key in d, key not in d, iter(d), clear(), copy(),\r\n  fromkeys(seq[, value]), get(key[, default]), items(), keys(),\r\n  pop(key[, default]), popitem(), setdefault(key[, default]), update([other]),\r\n  values() \r\n\r\nImportant Notes on dicts:\r\n  d[k] returns the value associated with a key (raises exception if k not in d)\r\n\r\n  d.get(k,default) returns d[k] if k in d; returns default if k not in d\r\n    it is equivalent to the conditional expression (d[k] if k in d else default)\r\n\r\n  d.setdefault(k,default) returns d[k] if k in d; if k not in d it\r\n    (a) sets d[k] = default\r\n    (b) returns d[k]\r\n  writing d.setdefault(k,default) is equivalent to (but more efficient than)\r\n  writing\r\n      if k in d:\r\n          return d[k]\r\n      else\r\n          d[k] = default\r\n          return d[k]\r\n\r\nThere is a type called defaultdict (see 8.3.4) whose constructor generally\r\ntakes an argument that is a reference to any object that CAN BE CALLED WITH NO\r\nARGUMENTS. Very frequently we use a NAME OF A CLASS that when called will\r\nCONSTRUCT A NEW VALUE: if the argument is int, it will call int() producing the\r\nvalue 0; if the argument is list, it will call list() producing an empty list;\r\nif the argument is set, it will call set() producing an empty set; etc.\r\n\r\nWhenever a key is accessed for the first time (i.e., that key is accessed but\r\nnot already associated with a value in the dictionary) in a defaultdictionary,\r\nit will associate that key with the value created by calling the reference to\r\nthe object supplied to the constructor.\r\n\r\nHere is an example of program first written with a dict, and simplified later\r\nby using a defaultdict. \r\n\r\nletters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']\r\nfreq_dict = dict()             # could use = {}\r\nfor l in letters:\r\n    if l not in freq_dict:     # must check l in freq_dict before freq_dict[l]\r\n        freq_dict[l] = 1       # if not there, put with frequency of 1\r\n    else:\r\n        freq_dict[l] += 1      # otherwise there, increment frequency\r\nprint(freq_dict)\r\n\r\nThis would print the following dict: {'b': 1, 'x': 3, 'f': 1, 'a': 2}\r\n\r\nAs each letter in the loop is processed, it is associated with 1 (if not already\r\nin the dict) or it is in the dict, and its associated value is incremented by 1.\r\n\r\nWe could solve this a bit more easily with a defaultdict.\r\n\r\nfrom collections import defaultdict # in same module as namedtuple\r\nletters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']\r\nfreq_dict = defaultdict(int)   # int not int(); but int() returns 0 when called\r\nfor l in letters:\r\n    freq_dict[l] += 1\t       # in dict, exception raised if l not in d, but\r\nprint(freq_dict)               #   defaultdict calls int() putting 0 there first\r\n\r\nAs each letter in the loop is processed, its associated key is looked up:\r\nif the key is absent, it it placed in the dict assocatiated with int()/0; then\r\nthen the associated value (possibly the one just put in the dict) is\r\nincremented by 1.\r\n\r\nThe dict code below is equivalent to how the defaultdict code above works.\r\n\r\nletters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']\r\nfreq_dict = dict()\t       # could use = {}\r\nfor l in letters:\r\n    if l not in freq_dict:     # must check l in freq_dict before freq_dict[l]\r\n        freq_dict[l] = int()   # int() constructor returns 0; could write 0 here\r\n    freq_dict[l] += 1\t       # l is guaranteed in freq_dict, either because\r\nprint(freq_dict)\t       #   it was there originally, or just put there\r\n\r\nAnother way to do the same thing (but also a bit longer and less efficient)\r\nuses the setdefault method (listed above)\r\n\r\nletters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']\r\nfreq_dict = dict()\t       # note dict only\r\nfor l in letters:\r\n    freq_dict[l] = freq_dict.setdefault(l,0) + 1\r\nprint(freq_dict)\t   \t       \r\n\r\nHere we evaluate the right side of the = first; if l is already in the dict,\r\nits associated value is returned; if not, l is put in the map with an associated\r\nvalue of 0, then this assocated value is returned (and then incremented, and\r\nstored back into freq_dict[l] replacing the 0 just put there).\r\n\r\nYou should achieve a good understanding of why each of these four scripts work\r\nand why they all produce equivalent results.\r\n\r\nOften we use defaultdicts with list instead of int: just as int() produces the\r\nobject 0 associated with a new key, list() creates an empty list associated\r\nwith a new key (and later we add things to that list); likewise we can use\r\ndefaultdicts with set to get an empty set with a new key.\r\n\r\nSo, if we wrote x = defaultdict(list) and then immediately wrote\r\nx['bob'].append(1) then x['bob'] is associated with the list [1] (the empty\r\nlist, with 1 appended to it). If we then wrote x['bob'].append(2), then\r\nx['bob'] is associated with the list [1, 2]. So, we can always append to the\r\nvalue associated with a key, because it will use an empty list to start the\r\nprocess if there is nothing associated with a key.\r\n\r\nHow could we specify a defaultdict that initializes keys with the value 5?\r\nTranslation: in what simple way can we pass to defaultdict an arguement that is\r\na function of no parameters, which returns the value 5. The solution can lead \r\nto all sorts of interesting variants, say for a defaultdict whose unknown keys\r\nare automatically associated with a dict (or another defaultdict).\r\n\r\nNote that the ==/!= operators for dictionaries work correct between dicts and\r\ndefaultdicts. They are considered equal so long as they have the equal keys, and\r\neach key is associated with an equal value.\r\n\r\nJust as with comprehensions, what is important is that we know how things like\r\ndefaultdicts and dicts (with the setdefault method) work, so that we can\r\ncorrectly write code in any of these ways. We can decide afterwords which way\r\nwe want the code to appear. As we program more, our preferences might change.\r\nI have found defaultdicts are mostly what I to use to simplify my code, but\r\nevery so often I must use a regular dict.\r\n\r\nLater in the quarter we will use inheritance to show how to write the\r\ndefaultdict class simply, by extending the dict class.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nPrinting Dictionaries in Order: An example of using comprehensions and sorted\r\n\r\nIn this section we will combine our knowledge about the sorted function,\r\ncomprehensions, and iteratring over dictionaries to examine how we can print\r\n(or generally process) dictionaries in arbitrary orders.\r\n\r\nGenerally, all of our code will be of the form\r\n\r\n  for index(es) in sorted( iterable, key = (lambda x : ....) ):\r\n     print( index(es) )\r\n\r\nIn these examples, we will use the simple dictionary\r\n\r\n   d = {'x': 3, 'b': 1, 'a': 2, 'f': 1}\r\n\r\nIn each example, we will discuss the relationships among index(es), iterable,\r\nand the (lambda x : ....) in the function bound to the key parameter.\r\n\r\n1) In the first example, we will print the dictionary keys in increasing\r\nalphabetical order, and their associated values, by iterating over d.items().\r\n\r\nfor k,v in sorted( d.items(), key = (lambda item : item[0]) ):\r\n   print(k,'->',v)\r\n\r\nwhich prints as\r\n\r\na -> 2\r\nb -> 1\r\nf -> 1\r\nx -> 3\r\n\r\nHere, iterable is d.items(), which produces 2-tuples storing each key and its\r\nassociated value, for every item in the dictionary; the item in lambda item is\r\nalso a key/value 2-tuple (specifying here to sort by item[0], the key part in\r\nthe 2-tuple); finally, the list returned by sorted also contains key/value\r\n2-tuples, which are unpacked into k and v and printed.\r\n\r\nWe can solve this same problem by iterating over just the keys in d as well.\r\n\r\nfor k in sorted( d.keys(), key = (lambda k : k) ):\r\n   print(k,'->',d[k])\r\n\r\nHere, iterable is d.keys() which produces strings storing each key in the\r\ndictionary; the k in lambda k is also a key/str value (specifying here to\r\nsort by k, the key itself: I could have omitted this identity lambda); finally,\r\nthe list returned by sorted also contains key/str value, which are stored into\r\nk and printed along with d[k].\r\n\r\nThis code is equivalent to the following, since d.keys() is the same as just d,\r\nand lambda x : x is the default for the key parameter.\r\n\r\nfor k in sorted( d ):\r\n   print(k,'->',d[k])\r\n\r\n\r\n2) In the second example, we will print the dictionary keys and their associated\r\nvalues, in increasing order of the values, by iterating over d.items().\r\n\r\nfor k,v in sorted( d.items(), key = (lambda item : item[1]) ):\r\n   print(k,'->',v)\r\n\r\nwhich prints as\r\n\r\nb -> 1\r\nf -> 1\r\na -> 2\r\nx -> 3\r\n\r\nHere, iterable is d.items(), which produces 2-tuples storing each key and its\r\nassociated value, for every item in the dictionary; the item in lambda item is\r\nalso a key/value 2-tuple (specifying here to sort by item[1], the value part in\r\nthe 2-tuple); also, the list returned by sorted also contains key/value\r\n2-tuples, which are unpacked into k and v and printed. Finally, by this\r\nlambda either b or f might be printed first, because they have the same value\r\nassociated with them.\r\n\r\nWe can solve this same problem by iterating over just the keys in d as well.\r\n\r\nfor k in sorted( d.keys(), key = (lambda k : d[k]) ):\r\n   print(k,'->',d[k])\r\n\r\nHere, iterable is d.keys() which produces strings storing each key in the\r\ndictionary; the k in lambda k is also a key/str value (specifying here to sort\r\nby d[k], the value associated with the key); finally, the list returned by\r\nsorted also contains key/str values, which are stored into k and printed along\r\nwith d[k].\r\n\r\nThis code is equivalent to the following, since d.keys() is the same a d; the\r\nlambda is still needed here because it is not the identity lambda.\r\n\r\nfor k in sorted( d, key = (lambda k : d[k]) ):\r\n   print(k,'->',d[k])\r\n\r\nIn both cases, Python uses the LEGB rule: d is not a parameter to the lambda,\r\nbut it might be defined in the Enclosing or Global scope, so it can be used\r\nin the lambda.\r\n\r\n3) In the third example, we will compute a list that contains all the keys in a\r\ndictionary, sorted by their associated values (in decreasing order of the\r\nvalues), by iterating over d.keys() (really just d, to simplify the code)\r\n\r\nWe compute\r\n\r\nks = sorted(d, key = (lambda k : d[k]), reverse = True)\r\n\r\nks stores ['x', 'a', 'b', 'f'].\r\n\r\nWe could also compute this list less elegantly using d.items().; I say less\r\nelegantly, because we need a comprehension to \"throw away\" the value part of\r\neach item returned by sorted.\r\n\r\nks = [k for k,v in sorted(d.items(), key=(lambda item : item[1]), reverse=True)]\r\n\r\n\r\n4) Finally, in the fourth example, we will compute a list that contains all the\r\n2-tuples in the items of d, but the tuples are reversed (values before keys) and\r\nsorted in increasing alphabetical order by keys.\r\n\r\nWe compute this list of 2-tuple in the following two ways\r\n\r\nvks = [ (v,k) for k,v in sorted( d.items(), key = (lambda item : item[0]) ) ]\r\nvks = sorted( ((v,k) for k,v in d.items()), key = (lambda item : item[1]) )\r\n\r\nvks stores [(2, 'a'), (1, 'b'), (1, 'f'), (3, 'x')]\r\n\r\nThe top computation first creates a sorted version of d by keys, and then uses a\r\ncomprehension to create tuples that reverse the keys/values; the bottom\r\ncomputation first uses a comprehension to create a list of reversed keys/values,\r\nand then uses sorted to sort these reversed 2-tuples by the keys that are now\r\nin the second part of each tuple.\r\n\r\n\r\nUsing _ as a variable Name:\r\n\r\nIf you write \r\n\r\n  ks = [k for k,v in list_of-2-tuples...]\r\n\r\nEclipse will likely give you warning about \"variable v is not used\". Since\r\nthere must be variable to store the second tuple index, but that variable does\r\nnot get used, we can write it as just _ (a legal Python variable name)\r\n\r\n  ks = [k for k,_ in list_of-2-tuples...]\r\n\r\nIn this case, Eclipse does not indicate a warning. Naming a variable _ implies\r\nyou aren't going to to anything useful with it. Although, we can write\r\n\r\nfor _ in [1,2,3]:\r\n    print(_)\r\n\r\nand it will print 1, 2, and 3 (on their own lines). By using _ Eclipse\r\ndoesn't expect this name to be used.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nExceptions: example from prompt_for_int\r\n\r\nWe do two things with exceptions in Python: we raise them (with the raise\r\nstatement) and we handle them (with the try/except statement). Exceptions were\r\nnot in early programming languages, but were introduced big time in the Ada\r\nlanguage in the early 1980s, and have been parts of most new languages since\r\nthen.\r\n\r\nA function raises an exception if it cannot do the job it is being asked to\r\ndo. Rather than fail silently, possibly producing a bogus answer that gets used\r\nto compute a bogus result, it is better that the computation announces a problem\r\noccurred and if no way is known to recover from it (see handling exceptions\r\nbelow) the computation halts with an error message to the user.\r\n\r\nFor example, if your program has a list l and you write l[5] but l has nothing\r\nstored at index 5 (its length is smaller), Python raises the IndexError\r\nexception. If you haven't planned for this possibility, and told Python how to\r\nhandle the exception and continue the calculation, then the program just\r\nterminates and Python prints: \r\n\r\nIndexError: list index out of range\r\n\r\nWhy doesn't it print the index value 5 and the lenth of list l?. I don't know.\r\nThat certainly seems like important and useful information, and Python knows\r\nthose two values. I try to make my exception messages include any information\r\nuseful to the programmer.\r\n\r\nThere are lots of ways to handle exceptions. Here is a drastically simplified\r\nexample from my prompt class (this isn't the real code, but a simplification\r\nfor looking at a good use of exception handling). But it does a good job of\r\nintroducing the try/except control form which tries to execute a block of code\r\nand handles any exceptions it raises.\r\n\r\nIf we write a try/except and specify the name of no exception, it will handle\r\nany exception. The name Exception is the name of the most generic exception.\r\n\r\nWe can write a try/except statement with many excepts, each one specifying a \r\nspecific exception to handle, and what to do when that exception is raised. In\r\nfact, int('x') raises the ValueError exception, so I use ValueError in the\r\nexcept clause below to be specific, and not accidentally handle any other kind\r\nof exception.\r\n\r\ndef prompt_for_int(prompt_text):\r\n    while True:\r\n        try:\r\n            response = input(prompt_text+': ')    # response is used in except\r\n            answer = int(response)\r\n            return answer\r\n        except ValueError:\r\n            print('  You bozo, you entered \"',response,'\"',sep='')\r\n\t    print('  That is not a legal int')\r\n\r\nprint(prompt_for_int('Enter a positive number'))\r\n\r\nSo, this is an \"infinite\" while loop, but there is a return statement at the\r\nbottom of the try-block; if it gets executed, it returns from the function,\r\nthus terminating the loop. The loop body is a try/except; the body of the\r\ntry/except\r\n\r\n1) prompts the user to enter a string on the console (this cannot fail)\r\n\r\n2) calls int(response) on the user's input (which can raise the ValueError\r\n   exception, if the user types characters that cannot be interpreted as an\r\n   integer)\r\n\r\n3) if that exception is not raised, the return statement returns an int object\r\n   representing the integer the user typed as a string\r\n\r\nBut if the exception is raised, it is handled by the except clause, which\r\nprints some information. Now the try/except is finished, but it is in an\r\ninfinite loop, so it goes around the loop again, reprompting the user (over and\r\nover until the user enters a legal int).\r\n\r\nActually, the body of try could be simplified (with the same behavior) to just\r\n\r\n  response = input(prompt_text+': ')    # response is used in except\r\n  return int(response)\r\n\r\nIf an exception is raised while the return statement is evaluating the int\r\nfunction, it still gets handled in except. We CANNOT write it in one line\r\nbecause the name response is used in the except clause (in the first print).\r\nIf this WASN'T the case, we could write just\r\n\r\n  return int(input(prompt_text+': '))    # if response not used in except\r\n\r\nFor example, we might just say 'Illegal input' in the except, but in the example\r\nabove, it actually display the string (not a legal int) that the user typed.\r\n\r\nFinally, in Java we throw and catch exceptions (obvious opposites, instead of\r\nraise and handle) so I might sometimes use the wrong term. That is because I \r\nthink more generally about programming than \"in a language\", and translate what\r\nI'm thinking to the terminology of the language I am using, but sometime I get\r\nit wrong.\r\n\r\nNote that exception handling is very powerful, but should be avoided if a\r\nboolean test can easily determine whether a computation will fail. For example.\r\n\r\nl = [...]\r\nif (0 <= i < len(l))\r\n  print(l[i])\r\n\r\nis preferred to\r\n\r\ntry:\r\n  print(l[i])\r\nexcept IndexError:\r\n  pass\r\n\r\n------------------------------------------------------------------------------\r\n\r\nName Spaces (for objects): __dict__\r\n\r\nEvery object has a special variable named __dict__ that stores all its\r\nnamespace bindings in a dictionary. During this quarter we will systematically\r\nstudy class names that start and end with two underscores. Writing x.a = 1\r\nis similar to writing x.__dict__['a'] = 1; both associate a name with a value\r\nin the object. We will explore the uses of this kind of knowledge in much more\r\ndepth later in the quarter.\r\n\r\nHere is a brief illustration of the point above. Note that there is a small\r\nPython script that illustrates the point. This is often the case.\r\n\r\nclass C:\r\n    def __init__(self): pass\r\n\r\no = C()\r\no.a = 1\r\nprint(o.a)           # prints 1\r\n\r\no.__dict__['a'] = 2\r\nprint(o.a)           # prints 2\r\n\r\no.__dict__['b'] = 3\r\nprint(o.a,o.b)       # prints 2 3\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTrivial Things.\r\n\r\nAn empty dict is created by {} and empty set by set() (we can't use {} for an\r\nempty set because Python would think it is a dict). Any non-empty dicts can\r\nbe distinguished from a non-empy set because a non-empty dict will always have\r\nthe : character inside {} separating keys from values. Suppose you want to\r\ncreate a set containing the value 1: which works (and why)? {1} or set(1).\r\n\r\nA one value tuple must be written like (1,) with that \"funny\" comma (we can't\r\nwrite just (1) because that is just the value 1, not a tuple storing just 1).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nQuestions:\r\n\r\n1. Describe, in term of binding, what happens if the first statement in a\r\nmodule is x = 0, in terms of the module object and its namespace.\r\n\r\n2. Assume that we have executed the statement x = 1. Describe, in terms of\r\nbinding, what is the semantics of the statement x += 1.\r\n\r\n3. What is printed in print(f(0)) if we define f as follows?\r\n\r\n  def f(x):\r\n      pass\r\n\r\n4. Using the kind of pictures dicussed in the Binding section above, illustrate\r\nthe meaning of a module named m that contains the following statements:\r\n\r\n  x = 1\r\n  y = 2\r\n  z = y\r\n\r\nAnd a module named script that contains the following statements:\r\n\r\n  import m\r\n  a = m.x\r\n  m.y = 10\r\n  from m import y\r\n  from m import z as b\r\n  z = y\r\n  del m.z\r\n  c = 10\r\n\r\nThe result will be two large rounded-rectangles (objects for modules m and \r\nscript) which contain labeled boxes that refer to other rounded-rectangles\r\n(objects for int values), some of which are shared (referred to by multiple\r\nnames)\r\n\r\n5. Predict what the following script will produce and explain why.\r\n\r\nprint(print(5))\r\nprint=1\r\nprint(print)\r\n\r\n6a. Write a simple function named count that returns the number of times a value\r\nis in a list; write the a simple function named indexes that returns a list of\r\nindexes in a list that a value returns. Use the appropriate kind of for loop.\r\nFor example, count(5, [5,3,4,5,1,2,5]) returns 3; indexes(5, [5,3,4,5,1,2,5])\r\nreturns [0,3,6].\r\n\r\n7. Suppose that we define the functions double, triple, and times10 (as done\r\nabove). Write the function call, such that call('double',5) returns the result\r\ndouble(5); call('triple',5) returns the result triple(5); call('magnitude',5)\r\nreturns the result magnitude(5). Hint: use eval.\r\n\r\n8. Write a function named between that is defined with two parameters. It\r\nreturns a reference to a function that has one parameter, which returns whether\r\nor not its one parameter is between (inclusive) the two arguments supplied when\r\nbetween is called. For example\r\n\r\ncollege_age = between(18,22)\r\nprint( college_age(20) )\r\n\r\nprint True because 18 <= 20 <= 22.\r\n\r\n9. Assume s = 'Fortunate'. Explain how Python evalues s.replace('t','c'). Sure,\r\nthe result it produces is 'Forcunace', but exactly how does Python know which\r\nfunction to call and how to call that function with these arguments. Hint: Use\r\nthe Fundamenal Equation of Object-Oriented Programming.\r\n\r\n9.5 This is tricky: it requires a good understanding of exec, eval, and what\r\ncharacters really appear in strings when you type them on the console.\r\n(1) prompt the user to enter a string that defines a function (using \\n where\r\nnew lines would be in the function); (2) use exec to define the function;\r\n(3) prompt the user to enter a call to the function and print what it evaluates\r\nto. The interaction might look like:\r\n\r\nEnter function definition as string: def f(n):\\n    return 2*n\r\nEnter function call as string      : f(3)\r\n6\r\n\r\nHint: when you enter \\n in a string, what characters are entered? Use the\r\nreplace function to \"fix\" them to exec will work.\r\n\r\n10. Assume that you have a list of tuples, where each tuple is a name and\r\nbirthday: e.g., ('alex', (9, 4, 1988)) and ('mark', (11, 29, 1990)). The\r\nbirthday 3-tuple, consists of a month, followed by day, followed by year. Write\r\na for-loop using sorted and a lambda to print out the tuples in the list in\r\norder of their bithdays (just months and days) so the 'alex' tuple prints\r\nbefore the 'mark' tuple because September 4th comes before November 29th; all\r\npeople who have the same birthday should be printed in alphabetical order.\r\nHint write a lambda that uses a key that is a person's month value, followed by\r\na day value, followed by a name value.\r\n\r\n11. What does the following script print?\r\n\r\nprint('a','b','c',sep='.-x-.')\r\nprint('d','e','f',sep='')\r\nprint('g','j','i',sep=':',end='..')\r\nprint('j','k','l',sep='--',end='?')\r\nprint('m',end='\\n\\n')\r\nprint('n')\r\n\r\n12. Assume s is a string. What is the value of s[-1:0:-1]? Assume l is a list.\r\nWrite the simplest loop that prints all values in a list except the first and\r\nlast (if the list has2 or fewer values, it should print nothing).\r\n\r\n13. Write a single Python statement using a conditional expression that is\r\nequivalent to the following two statementso\r\n\r\nt= 0\r\nif x < 0:\r\n    t = -1\r\n\r\n14. What can we say about\r\n  len of set(d.keys())   compared to len of d.keys?\r\n  len of set(d.values()) compared to len of d.values()?\r\n  len of set(d.items())  compared to len of d.items()?\r\n\r\n15. Assume we import the copy function from the copy module. What is the\r\ndifference between the result produced by list((1,2,3)) and copy((1,2,3))?\r\n\r\n15.5 Using the kind of pictures dicussed in the Binding section above,\r\nillustrate the meaning of the following and determine what is printed.\r\n\r\n  x = [ [0], [1]]\r\n  y = list(x)\r\n  x[0][0] = 'a'\r\n  print(x,y)\r\n\r\n16a. Assume we have a list of students (ls) and a list of their gpas (lg).\r\nCreate a dictionary whose first key is the first student in ls and whose\r\nassociated value is the first gpa in the lg; whose second key is the second\r\nstudent in ls and whose associated value is the second gpa in the lg; etc.\r\nSo if ls = ['bob','carol','ted','alice'] and lg = [3.0, 3.2, 2,8, 3.6] the\r\nresulting dict might print as {'carol': 3.2, 'ted': 2, 'alice': 8, 'bob': 3.0}.\r\nHint: use the dict constructor and the zip function.\r\n\r\n16b. Assume that we have a list of runners in the order they finished the race.\r\nFor example ['bob','carol','ted','alice']. Create a dictionary whose keys are\r\nthe students and whose values are the place in which they finished. For this\r\nexample the resulting dict might print as \r\n{'carol': 2, 'ted': 3, 'alice': 4, 'bob': 1}. Hint: use a comprehension and\r\nenumerate.\r\n\r\n16c. Assume that we have a list of values l and a function f, and we want to\r\ndefine a function that computes the value x in l whose f(x) is the smallest.\r\nFor example, if l = [-2, -1, 0, 1, 2] and def f(x) : return abs(x+1), then\r\ncalling min_v(l,f) would return -1. Hint: try to write the min_v function in one\r\nline: a returns statement calling min, on a special comprehension, and indexing.\r\n\r\n17. The following script uses many topics that are covered in the lecture.\r\n\r\nWrite a script that reads a multiline file of words separated by spaces\r\n(no punctuation) and builds a dictionary whose keys are the words and whose\r\nvalues are lists of the line numbers that the words are on (with no duplicate\r\nline numbers in each list). Print all the words (in sorted order, one per line)\r\nwith the list of their line numbers afterwards. For example, the 3 line file\r\n\r\nto be or\r\nnot to be\r\nthat is the question\r\n\r\nwould print as\r\n\r\nbe [1, 2]\r\nis [3]\r\nnot [2]\r\nor [1]\r\nquestion [3]\r\nthat [3]\r\nthe [3]\r\nto [1, 2]\r\n\r\nMy solution was 8 lines long (including one import). It used a defaultdict,\r\nthree loops, three function calls (open, enumerate, and sorted), and four\r\nmethod calls (rstrip, split, append).\r\n", "encoding": "ascii"}