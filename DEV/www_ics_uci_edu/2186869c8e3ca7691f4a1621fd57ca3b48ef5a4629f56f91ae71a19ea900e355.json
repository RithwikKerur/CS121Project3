{"url": "https://www.ics.uci.edu/~thornton/ics142/LabManual/Assignment6/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course2.css\" type=\"text/css\" />\r\n\r\n<title>ICS 142 Winter 2004, Assignment #6</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 142 Winter 2004 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../LabManual\">Lab Manual</a> |\r\n<a href=\"news:ics.142\">ics.142 newsgroup</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 142 Winter 2004<br />\r\n   Assignment #6</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, March 19, 11:59pm</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>Ultimately, the job of a compiler is to take a program in some source language and generate an equivalent program in some target language.  Generally, that target language is an executable program for some platform, meaning that assembly code must be generated at some stage.  Many of the abstractions provided by high-level programming languages -- procedures, scopes, arrays, structures, and support for a variety of built-in data types (including automatic conversions between them), to name a few -- do not exist at the assembly level.  So the overall job of the back end of a compiler is to map higher-level abstractions into lower-level ones, choosing an assembly-level implementation for high-level language constructs.  Naturally, some implementations of language constructs are better than others.  But some are better in some situations and worse in others.  Context plays a large role in selecting a good implementation.  The complexities of generating good intermediate code are complicated by attempting to analyze this context on the fly.  It makes good software engineering sense, then, to generate intermediate code that makes a \"best guess\" at a good implementation, then allow an <i>optimizer</i> to find better implementations whenever possible, based on more complex analysis of context.</p>\r\n\r\n<p>The job of an optimizer is to take an intermediate code program and rewrite it to be a better program with the equivalent effect.  (\"Better,\" of course, can mean many things: faster, less memory usage, or less power consumption, for example.)  Optimizers can employ many forms of analysis to improve a program, which are typically arranged into <i>passes</i>, where each pass uses one technique to attempt to improve the code.  The net effect of all the passes, some of which may be repeated more than once, should be a significant improvement of the original program.</p>\r\n\r\n<p>In this assignment, we'll explore a few issues that arise in the optimization of a substantial subset of the intermediate language ILOC that was discussed in lecture (and is discussed in the textbook).  You'll write a program that takes a fragment of ILOC code, performs one or more optimization passes on it, and outputs the optimized fragment.  The entire structure of the program will be provided, including a scanner/parser for ILOC, representations for ILOC instructions, and a module to pretty-print the output.  Your job will only be to write three optimization modules.  (The framework is extensible, so you're welcome to implement additional optimization modules if you'd like, though I won't be offering any extra credit for them.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The subset of ILOC for this assignment</p>\r\n\r\n<p>In this assignment, a substantial subset of ILOC (as presented in lecture and the textbook) is to be supported and optimized.  The following ILOC instructions are to be supported in this assignment:</p>\r\n\r\n<table class=\"normal\">\r\n  <tr class=\"top\">\r\n    <td>Opcode</td>\r\n    <td>Source Operands</td>\r\n    <td>Target Operands</td>\r\n    <td>Description</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">add</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Adds the value in reg1 and reg2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">addI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Adds the value in reg1 to the constant integer int2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">sub</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Subtracts the value in reg2 from reg1, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">subI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Subtracts the constant integer int2 from reg1, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">rsubI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Subtracts the value in reg1 from the constant integer int2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">mult</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Multiplies the values in reg1 and reg2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">multI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Multiplies the value in reg1 by the integer constant int2, storing the result in reg3.</td>\r\n  </tr>  \r\n  <tr>\r\n    <td class=\"special\">div</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Divides the value in reg1 by the value in reg2, storing the result in reg3.  If reg2's value is zero, it is assumed that a processor exception is raised.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">divI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Divides the value in reg1 by the integer constant int2, storing the result in reg3.  If int2 is zero, it is assumed that a processor exception is raised.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">rdivI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Divides the value of the integer constant int2 by the value in reg1, storing the result in reg3.  If the value in reg1 is zero, it is assumed that a processor exception is raised.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">lshift</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Left-shifts the value in reg1 by reg2 bits, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">lshiftI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Left-shifts the value in reg1 by the number of bits specified by the integer constant int2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">rshift</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Right-shifts the value in reg1 by reg2 bits, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">rshiftI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Right-shifts the value in reg1 by the number of bits specified by the integer constant int2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">and</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>AND's together the (presumably boolean) values stored in reg1 and reg2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">andI</td>\r\n    <td>reg1, bool2</td>\r\n    <td>reg3</td>\r\n    <td>AND's together the (presumably boolean) value stored in reg1 with the boolean constant bool2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">or</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>OR's together the (presumably boolean) values stored in reg1 and reg2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">orI</td>\r\n    <td>reg1, bool2</td>\r\n    <td>reg3</td>\r\n    <td>OR's together the (presumably boolean) value stored in reg1 with the boolean constant bool2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">xor</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>XOR's together the (presumably boolean) values stored in reg1 and reg2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">xorI</td>\r\n    <td>reg1, bool2</td>\r\n    <td>reg3</td>\r\n    <td>XOR's together the (presumably boolean) value stored in reg1 with the boolean constant bool2, storing the result in reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">not</td>\r\n    <td>reg1</td>\r\n    <td>reg2</td>\r\n    <td>NOT's the (presumably boolean) value stored in reg1, storing the result in reg2.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">load</td>\r\n    <td>reg1</td>\r\n    <td>reg2</td>\r\n    <td>Loads the value stored in the memory address stored in reg1 into the register reg2.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">loadI</td>\r\n    <td>const1</td>\r\n    <td>reg1</td>\r\n    <td>Places the value of the constant const1 into reg1.  const1 may be either an integer or a boolean constant.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">loadAI</td>\r\n    <td>reg1, int2</td>\r\n    <td>reg3</td>\r\n    <td>Loads the value stored in the memory address calculated by adding the integer constant int2 to the value stored in reg1.  The loaded value is placed into reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">loadAO</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Loads the value stored in the memory address calculated by adding the values stored in reg1 and reg2.  The loaded value is placed into reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">store</td>\r\n    <td>reg1</td>\r\n    <td>reg2</td>\r\n    <td>Stores the value in reg1 into the memory address indicated in reg2.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">storeAI</td>\r\n    <td>reg1</td>\r\n    <td>reg2, int3</td>\r\n    <td>Stores the value in reg1 into the memory address calculated by adding the integer constant int3 to the value in reg2.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">storeAO</td>\r\n    <td>reg1</td>\r\n    <td>reg2, reg3</td>\r\n    <td>Stores the value in reg1 into the memory address calculated by adding the values in reg2 and reg3.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">i2i</td>\r\n    <td>reg1</td>\r\n    <td>reg2</td>\r\n    <td>Copies the value stored in reg1 into reg2.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">cmp_LT<br />cmp_LE<br />cmp_EQ<br />\r\n                        cmp_NE<br />cmp_GE<br />cmp_GT</td>\r\n    <td>reg1, reg2</td>\r\n    <td>reg3</td>\r\n    <td>Compares the values stored in reg1 and reg2, storing the boolean result of the comparison into reg3.  Each of these instructions uses a different form of comparison: cmp_LT uses &lt;, cmp_LE uses &lt;=, and so on.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">cbr</td>\r\n    <td>reg1</td>\r\n    <td>Label1, Label2</td>\r\n    <td>If the (presumably boolean) value stored in reg1 is true, jump to Label1, otherwise jump to Label2.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">jumpI</td>\r\n    <td>none</td>\r\n    <td>Label1</td>\r\n    <td>Jump to Label1.</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"special\">nop</td>\r\n    <td>none</td>\r\n    <td>none</td>\r\n    <td>Has no effect, but is sometimes necessary as a placeholder.  Optimizations should not remove these; they are placed automatically when needed.</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>ILOC code is to be written into an input file, subject to the following restrictions:</p>\r\n\r\n<ul>\r\n  <li>All instructions are to be terminated by semicolons.  This is not the notation used in the textbook or in lecture, but it simplified my parser implementation.</li>\r\n  <li>The names of all registers must begin with a lowercase <b>r</b> and be followed by a non-negative integer.  Example register names are <b>r3</b> and <b>r999</b>.</li>\r\n  <li>The names of all labels must begin with an uppercase <b>L</b> and be followed by a non-negative integer.  Example label names are <b>L3</b> and <b>L999</b>.</li>\r\n  <li>An instruction may have either zero or one labels associated with it.  No instruction may have two or more labels.</li>\r\n  <li>All jumps must be to existent labels.</li>\r\n  <li>The numbers and types of all operands must be correct.  An attempt to read an instruction from an input file with the wrong number or types of operands -- or an attempt to create such an instruction programmatically in your optimizer -- will result in an exception being thrown by my code, which will crash your program.</li>\r\n</ul>\r\n\r\n<p>Here is an example input file.  It should be pointed out that, for the sake of readability, I've spaced the input in the file somewhat, though whitespace is not considered relevant, except when it is necessary to separate tokens.</p>\r\n\r\n<pre>\r\n     loadI  50      => r1;\r\n     loadI  100     => r2;\r\n     cmp_LT r1, r2  => r3;\r\n     cbr    r3      -> L1, L2;\r\nL1:  add    r4, r5  => r6;\r\n     jumpI          -> L3;\r\nL2:  add    r7, r8  => r6;\r\n     jumpI          -> L3;\r\nL3:  cmp_LT r6, r7  => r8;\r\n     cbr    r8      -> L4, L1;\r\nL4:  cmp_GT r6, r7  => r8;\r\n     cbr    r8      -> L5, L6;\r\nL5:  loadI  true    => r9;\r\n     jumpI          -> L7;\r\nL6:  loadI  false   => r9;\r\n     jumpI          -> L7;\r\nL7:  nop;\r\n</pre>\r\n\r\n<p>The <b>cbr</b> and <b>jumpI</b> instructions use the symbol -&gt; to separate source operands from target operands.  The <b>nop</b> instruction has no operands.  All other instructions use the symbol =&gt; to separate source operands from target operands.</p>\r\n\r\n<p>Comments may be placed into input files; anything following two slashes (i.e. <b>//</b>) until the end of the line is considered to be a comment, much like in Java.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Basic blocks and control-flow graphs</p>\r\n\r\n<p>Many optimization techniques involve some form of compile-time simulation of the run-time behavior of the program.  In the presence of control-flow structures, such as if-then-else statements and while loops (which introduce conditional branches into the intermediate code), this simulation becomes increasingly more difficult to do precisely.  To simplify matters, we divide the intermediate code program into straight-line chunks of code that must always be executed in sequence from beginning to end.  Each such chunk is called a <i>basic block</i>.</p>\r\n\r\n<p>Here's a brief example ILOC program:</p>\r\n\r\n<pre>\r\n     loadI  1       => r1;\r\n     loadI  10      => r2;\r\n     loadI  0       => r3;\r\n     cmp_GT r1, r2  => r4;\r\n     cbr    r4      -> L2, L1;\r\nL1:  add    r3, r1  => r3;\r\n     addI   r1, 1   => r1;\r\n     cmp_LE r1, r2  => r4;\r\n     cbr    r4      -> L1, L2;\r\nL2:  store  r3      => r0;\r\n</pre>\r\n\r\n<p>This program uses a loop to calculate the sum of the integers 1..10 and store it in a memory address stored in the register r0.  There are three basic blocks in this program:</p>\r\n\r\n<ul>\r\n  <li>The first five instructions must always run in sequence from beginning to end.  They constitute the first basic block, which we'll call <i>block 0</i>.</li>\r\n  <li>The next four instructions must always run in sequence from beginning to end.  They constitute the second basic block, which we'll call <i>block 1</i>.</li>\r\n  <li>The last instruction is on its own, only running when it is finally jumped to.  It, by itself, constitutes the third basic block, which we'll call <i>block 2</i>.</li>\r\n</ul>\r\n\r\n<p>From this example, we see that any jump instruction (<b>cbr</b> or <b>jumpI</b>) always constitutes the end of a basic block.  A label must always constitute the beginning, since it is possible to jump to labels.</p>\r\n\r\n<p>The longer the basic blocks in a program, the better.  Basic blocks indicate sequences of code that are likely to pipeline well.  It is also significantly easier to perform optimizations on a single basic block than to try to perform them on more than one block (due to the complexities introduced by control-flow).</p>\r\n\r\n<p>Basic blocks are said to be connected together as a <i>control-flow graph</i>.  In this context, we'll often refer to the blocks as <i>nodes</i>.  In our example, the following edges exist between nodes in the control-flow graph:</p>\r\n\r\n<ul>\r\n  <li>There is an edge from node 0 to node 2, since it's possible for the last instruction in node 0 to jump to L2, which is the first instruction in node 2.</li>\r\n  <li>There is an edge from node 0 to node 1, since it's possible for the last instruction in node 0 to jump to L1, which is the first instruction in node 1.</li>\r\n  <li>For similar reasons, there are edges from node 1 to node 2, and also from node 1 to node 1.</li>\r\n  <li>Node 2 has no outgoing edges, since it is the end of our code fragment.</li>\r\n</ul>\r\n\r\n<p>Viewing basic blocks as a graph like this is handy, since it allows a variety of well-known graph algorithms to be useful for performing optimization.  We'll use one such algorithm in Part 3.</p>\r\n\r\n<p>Good news: I've provided the portion of your program that reads the input file, finds the basic blocks, and builds the control-flow graph.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Guiding assumptions about the profitability of optimizations</p>\r\n\r\n<p>Different architectures have radically different performance characteristics.  For this reason, optimizers for different architectures will need to make different decisions.  After all, the point of optimization is not to make the code prettier; it's to make the code perform better.  A compiler writer must pay careful attention to the optimizations she chooses to perform, to ensure that they really constitute an improvement in the program as it will execute on the target architecture.</p>\r\n\r\n<p>For your optimizer, use the following assumptions about the performance of the underlying architecture to guide your choices.  This list may or may not compare favorably with a list for an actual architecture; I've made these decisions to make the problem a more interesting one to solve.</p>\r\n\r\n<ul>\r\n  <li>The immediate form of arithmetic, shifting, and logical instructions should be preferred over the regular form.  For example, <b>addI</b> should be preferred over <b>add</b>, <b>rshiftI</b> should be preferred over <b>rshift</b>, and <b>xorI</b> should be preferred over <b>xor</b>.</li>\r\n  <li>A single add or subtract operation should be preferred over a single multiplication or division.  A single left- or right-shift should be preferred over a single addition, subtraction, multiplication, or division.  (This only applies in the case that all operations in question are non-immediate or all operations are immediate.  A <b>multI</b> is considered better than an <b>add</b>, though an <b>addI</b> is considered better than a <b>multI</b>.)</li>\r\n  <li>The <b>not</b> instruction should be preferred over any other boolean operator.</li>\r\n  <li>A register-to-register copy, <b>i2i</b>, should be preferred over any instruction that performs a computation.</li>\r\n  <li>A <b>loadI</b> operation, which loads an immediate value into a register, should be preferred over any instruction that performs a computation.  In other words, any time you can do the work of one or more instructions at compile time and replace it with a <b>loadI</b> operation, this will be considered profitable.</li>\r\n  <li>A <b>loadI</b> operation should also be preferred over a register-to-register copy (<b>i2i</b>) operation.</li>\r\n  <li>The \"address+immediate\" forms of load and store (<b>loadAI</b> and <b>storeAI</b>) should be preferred over the \"address+offset\" forms (<b>loadAO</b> and <b>storeAO</b>).</li>\r\n  <li>An immediate jump (<b>jumpI</b>) should be preferred over a conditional branch (<b>cbr</b>).  The motivation for this is the desire to keep a pipeline full.  A conditional branch operation always runs the risk of causing the pipeline to be flushed (though, realistically, branch prediction can reduce the risk), while an immediate jump does not.</li>\r\n</ul>\r\n\r\n<p>Of course, it should be noted here that it is only possible to replace one instruction with another in the case that their effect is the same.  For example, given this brief sequence of instructions:</p>\r\n\r\n<pre>\r\n     loadI  100     => r1;\r\n     load   r2      => r3;\r\n     addI   r1, 50  => r4;\r\n     addI   r3, 50  => r5;\r\n</pre>\r\n\r\n<p>...since r1 is known to have the constant value 100, we can replace the first <b>addI</b> instruction with a <b>loadI</b>.  The second <b>addI</b>, however, cannot be replaced, since its run-time value is based on a value in a memory location whose value is unknown to us at compile-time.  So, a correctly-rewritten sequence might look like this:</p>\r\n\r\n<pre>\r\n     loadI  100     => r1;\r\n     load   r2      => r3;\r\n     loadI  150     => r4;    // this is considered better than addI\r\n     addI   r3, 50  => r5;    // this cannot be replaced, since we can't know r3's value at compile-time\r\n</pre>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Part 1: Local algebraic simplification (30 points)</p>\r\n\r\n<p>Apply the following algebraic transformations on the code within each basic block.  Handle each basic block separately.  (The term \"local\", when used to describe an optimization technique, indicates an optimization that works only separately within each basic block.  For this transformation, it actually makes little difference, since we can make substitutions without understanding any context.)</p>\r\n\r\n<ul>\r\n  <li>Addition or subtraction of a constant 0 should be replaced with a register-to-register copy.\r\n    <ul>\r\n      <li>e.g. addI r1, 0 => r2; should be replaced with i2i r1 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Subtraction of a register from itself should be replaced with an immediate load of 0.\r\n    <ul>\r\n      <li>e.g. sub r1, r1 => r2; should be replaced with loadI 0 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Multiplication by the constant 0 should be replaced with an immediate load of 0.\r\n    <ul>\r\n      <li>e.g. multI r1, 0 => r2; should be replaced with loadI 0 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Multiplication or division by the constant 1 should be replaced with a register-to-register copy.\r\n    <ul>\r\n      <li>e.g. multI r1, 1 => r2; should be replaced with i2i r1 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Reverse-immediate division of the constant 0 by a register should be replaced with an immediate load of 0.\r\n    <ul>\r\n      <li>e.g. rdivI r1, 0 => r2; should be replaced with loadI 0 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Multiplication or division by immediate powers of 2 should be replaced by the appropriate left- or right-shift operation.\r\n    <ul>\r\n      <li>e.g. multI r1, 64 => r2; should be replaced with lshiftI r1, 6 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Division of a register by itself should be replaced with an immediate load of 1.\r\n    <ul>\r\n      <li>e.g. div r1, r1 => r2; should be replaced with loadI 1 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Left- or right-shift by the constant 0 should be replaced with a register-to-register copy.\r\n    <ul>\r\n      <li>e.g. lshiftI r1, 0 => r2; should be replaced with i2i r1 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>Immediate AND (andI), OR (orI), XOR (xorI) by the constants true or false should be replaced with the appropriate boolean identity.\r\n    <ul>\r\n      <li>e.g. andI r1, false => r2; should be replaced with loadI false => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>AND, OR of a register by itself should be replaced with a register-to-register copy.\r\n    <ul>\r\n      <li>e.g. and r1, r1 => r2; should be replaced with i2i r1 => r2;</li>\r\n    </ul>\r\n  </li>\r\n  <li>XOR of a register by itself should be replaced with an immediate load of false.\r\n    <ul>\r\n      <li>e.g. xor r1, r1 => r2; should be replaced with loadI false => r2;</li>\r\n    </ul>\r\n  </li>\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Part 2: Local constant propagation and folding (50 points)</p>\r\n\r\n<p>Whenever it can be proven that a register must have a known constant value, that fact can then be used to simplify instructions that use the value of the register.  For example, consider the following pair of instructions:</p>\r\n\r\n<pre>\r\n     loadI   40      => r1;\r\n     addI    r1, 40  => r2;\r\n</pre>\r\n\r\n<p>Since it's clear that the value of r1 must be 40 after the first instruction executes, the second instruction is really the addition of 40 and 40.  (Replacing a register with a known constant value is called <i>constant propagation</i>.)  Since both operands are known to be constants, we might as well perform the addition at compile-time and replace the addI instruction with an immediate load.  (Combining constants together at compile-time is known as <i>constant folding</i>.)  The combination of constant propagation and constant folding yields this pair of instructions in lieu of the original two:</p>\r\n\r\n<pre>\r\n     loadI   40      => r1;\r\n     loadI   80      => r2;\r\n</pre>\r\n\r\n<p>This optimization has two benefits.  First, it replaces an add instruction with an immediate load, which, according to our guidelines from earlier in the write-up, is considered to be an improvement.  Second, and perhaps more importantly, r2 now has a known constant value, which enables us to propagate that value to future instructions.</p>\r\n\r\n<p>Proving whether a register has a constant value can be tricky in the general case, though if we limit ourselves to one basic block at a time, a much simpler algorithm can be used:</p>\r\n\r\n<pre>\r\n    when we start processing a basic block, consider all registers to be non-constants\r\n\r\n    for each instruction i in the block, in top-to-bottom order\r\n    {\r\n        if one or more of the operands in the instruction are known to be constants\r\n            propagate the constant values...\r\n            ...fold constants...\r\n            ...and replace the instruction if possible\r\n\r\n        regardless of whether we made a change to the instruction...\r\n            if the instruction now stores a constant value into a register\r\n                add that (register, constant value) pair to our collection of registers and known constant values\r\n            else if the instruction now stores a non-constant value into a register\r\n                remove that register from our collection of registers and known constant values\r\n    }\r\n</pre>\r\n\r\n<p>This algorithm boils down to a simulation of the basic block's execution at compile-time.  We make the most conservative assumption to start with, that none of the registers are known to be constants.  Anytime a register is assigned a constant value (such as with a <b>loadI</b> instruction), we add it (and the value) to a collection of registers with known constant values.  Anytime a register is assigned a non-constant value (such as with a <b>load</b> instruction), we remove it from the collection of registers with known constant values.  This collection, as it turns out, is really a <i>map</i> (in the data structure sense of the word), which might efficiently be implemented using a hash table (e.g. HashMap in the Java library).</p>\r\n\r\n<p>Not surprisingly, the algorithm for maintaining the collection of known constant values becomes a great deal more complicated when it can be run over many basic blocks.  This technique is known as <i>global constant propagation and folding</i>.  (The term \"global,\" when applied to an optimization technique, does not mean a program-wide optimization.  It means an optimization made on all the basic blocks in one procedure, considered together.)  We won't be covering global optimizations in this course, though there's plenty of reading material on the subject in Chapters 9 and 10 of the textbook, if you're interested.</p>\r\n\r\n<p>I'll leave it as an exercise for each of you to figure out which instructions can be replaced and how they ought to be replaced, based on the set of guiding assumptions from earlier in the write-up.  Don't forget to update your set of registers with known constant values whenever it changes!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Part 3: Unreachable block elimination (20 points)</p>\r\n\r\n<p>Either as a result of a poorly-written input file, or more likely as the result of one of the optimizations in the previous parts, one or more entire basic blocks in the control-flow graph may become unreachable.  If this is the case, we should eliminate unreachable nodes from the control-flow graph of our ILOC program entirely, since they serve no purpose.</p>\r\n\r\n<p>The analysis required is a relatively straightforward depth-first graph traversal algorithm with marking:</p>\r\n\r\n<pre>\r\n    consider all nodes in the CFG to be unmarked\r\n    let currentNode = node 0 (the start node)\r\n    loop\r\n    {\r\n        mark currentNode\r\n        if there exists an unvisited successor n of currentNode\r\n            currentNode = n\r\n        else\r\n            backtrack\r\n    }\r\n</pre>\r\n\r\n<p>I've illustrated the algorithm using a pseudo-loop, but I actually implemented it as a recursive algorithm with backtracking.  Since the CFGNode class I provided does not have a marking feature in it, I suggest implementing the marks by storing them in a separate one-dimensional boolean array.</p>\r\n\r\n<p>Once you've finished the traversal phase, iterate through the nodes and remove the ones that were never marked.  Nodes can be removed by calling the removeNode( ) method on the ControlFlowGraph.  <i>Beware that the start node, node 0, is always considered reachable and, hence, may not be removed!</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">A step-by-step example</p>\r\n\r\n<p>Suppose we began with the following ILOC input file, running all three optimizer passes (local algebraic simplification, local constant propagation and folding, and unreachable block elimination) in sequence.</p>\r\n\r\n<pre>\r\n     loadI   1       => r1;\r\n     multI   r1, 64  => r2;\r\n     addI    r2, 50  => r3;\r\n     cmp_LT  r2, r3  => r4;\r\n     cbr     r4      -> L3, L1;\r\nL1:  loadI   1       => r5;\r\n     loadI   10      => r6;\r\n     loadI   0       => r7;\r\n     cmp_GT  r5, r6  => r8;\r\n     cbr     r8      -> L4, L2;\r\nL2:  add     r7, r5  => r7;\r\n     addI    r5, 1   => r5;\r\n     cmp_LE  r5, r6  => r8;\r\n     cbr     r8      -> L2, L4;\r\nL3:  loadI   1024    => r7;\r\nL4:  addI    r7, 100 => r9;\r\n     store   r9      => r0;\r\n</pre>\r\n\r\n<p class=\"subtitle\">Results of local algebraic simplification</p>\r\n\r\n<pre>\r\n     loadI   1       => r1;\r\n     lshiftI r1, 6   => r2;   // multiplication by power of 2 simplified\r\n     addI    r2, 50  => r3;\r\n     cmp_LT  r2, r3  => r4;\r\n     cbr     r4      -> L3, L1;\r\nL1:  loadI   1       => r5;\r\n     loadI   10      => r6;\r\n     loadI   0       => r7;\r\n     cmp_GT  r5, r6  => r8;\r\n     cbr     r8      -> L4, L2;\r\nL2:  add     r7, r5  => r7;\r\n     addI    r5, 1   => r5;\r\n     cmp_LE  r5, r6  => r8;\r\n     cbr     r8      -> L2, L4;\r\nL3:  loadI   1024    => r7;\r\nL4:  addI    r7, 100 => r9;\r\n     store   r9      => r0;\r\n</pre>\r\n\r\n<p class=\"subtitle\">Results of local constant propagation and folding</p>\r\n\r\n<pre>\r\n     loadI   1       => r1;\r\n     loadI   64      => r2;\r\n     loadI   114     => r3;\r\n     loadI   true    => r4;\r\n     jumpI           -> L3;\r\nL1:  loadI   1       => r5;\r\n     loadI   10      => r6;\r\n     loadI   0       => r7;\r\n     loadI   false   => r8;\r\n     jumpI           -> L2;\r\nL2:  add     r7, r5  => r7;\r\n     addI    r5, 1   => r5;\r\n     cmp_LE  r5, r6  => r8;\r\n     cbr     r8      -> L2, L4;\r\nL3:  loadI   1024    => r7;\r\nL4:  addI    r7, 100 => r9;\r\n     store   r9      => r0;\r\n</pre>\r\n\r\n<p>Several instructions were replaced by <b>loadI</b> instructions in this pass, since several times registers were used whose values were known constants.  Also, two of the three conditional branches were replaced by immediate jumps, since the result of the comparisons that preceded them became constants.</p>\r\n\r\n<p>A couple of things should be pointed out here:</p>\r\n\r\n<ul>\r\n  <li>First of all, the last instruction before the label L2 is an immediate jump to L2.  This is not a problem that will be solved in any of our optimizations, though in a real compiler, you would obviously want to solve it.  (One way to solve it is to use a <i>peephole optimizer</i>, which walks through the intermediate code after all other optimizations and looks for short, bizarre instruction sequences like this one, or instructions such as <b>i2i r1 => r1;</b>.)</li>\r\n  <li>Because of the immediate jump to L3 in the fifth instruction, none of the code between the labels L1 and L3 is reachable.  The third pass will eliminate all of this code.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Results of unreachable block elimination</p>\r\n\r\n<pre>\r\n     loadI   1       => r1;\r\n     loadI   64      => r2;\r\n     loadI   114     => r3;\r\n     loadI   true    => r4;\r\n     jumpI           -> L3;\r\nL3:  loadI   1024    => r7;\r\nL4:  addI    r7, 100 => r9;\r\n     store   r9      => r0;\r\n</pre>\r\n\r\n<p>The code between L1 and L3 was removed.  <i>This is the code that I would expect a working version of your program to output for this example.</i></p>\r\n\r\n<p>Again, it should be pointed out that this code is not perfect by any stretch.  But it is a marked improvement over what we started with.  Additional passes that performed other kinds of analyses would be capable of making additional improvements.  For example, these two instructions:</p>\r\n\r\n<pre>\r\nL3:  loadI   1024    => r7;\r\nL4:  addI    r7, 100 => r9;\r\n</pre>\r\n\r\n<p>...would ideally be subject to constant propagation, changing them to this instead:</p>\r\n\r\n<pre>\r\nL3:  loadI   1024    => r7;\r\nL4:  loadI   1124    => r9;\r\n</pre>\r\n\r\n<p>The presence of the label L4 separates these two instructions into different basic blocks.  Our constant propagation algorithm works only within a basic block, rendering it incapable of making this change.  Furthermore, the values of registers r1, r2, r3, r4, and r7 are never used in this fragment.  This being the case, an ideal optimizer would detect the fact that they are no longer \"live\" and remove the corresponding loadI instructions entirely.  A peephole optimizer might then remove the jump to L3.  No longer serving a purpose, both labels could be removed, leaving us with only this code as a rewrite of the <i>entire original code fragment</i>:</p>\r\n\r\n<pre>\r\n     loadI   1124    => r9;\r\n     store   r9      => r0;\r\n</pre>\r\n\r\n<p>When properly designed and implemented, optimization is a beautiful thing!</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Starting point</p>\r\n\r\n<p>The entire framework of the program is being provided to you as a Zip archive.  Most of the code is available only in its compiled form, as .class files.  The .java files that will be relevant to your work have been provided.</p>\r\n\r\n<ul>\r\n  <li><a href=\"StartingPoint.zip\">Zip archive</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>Place all of the .java files that comprise your program into a Zip archive.  Also, include a file called README.txt in your archive, which briefly explains what portion of the program you believe you have working, what aspects of it are only partially working, and what aspects do not work at all.  You do not need to include the provided .class files from the Starting Point.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingAssignments.html\">this link</a> for a discussion of how to submit your assignment.  Remember that we do not accept paper submissions of your assignments, nor do we accept them via email <i>under any circumstances</i>.</p>\r\n\r\n<p>In order to keep the grading process relatively simple, we require that you keep your program designed in such a way as it can be compiled and executed with the following set of commands:</p>\r\n\r\n<pre>\r\n    javac *.java\r\n    java Driver example.iloc 1 2 ...\r\n</pre>\r\n\r\n<p>...where there may be any list of at least one valid optimizer pass number (which may include duplicates).  We will test your optimization passes both in isolation and in concert.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Originally written by Alex Thornton, Winter 2004.</li>\r\n</ul>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}