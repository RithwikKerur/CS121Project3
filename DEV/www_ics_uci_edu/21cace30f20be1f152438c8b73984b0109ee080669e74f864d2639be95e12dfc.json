{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/DuckTyping/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Duck Typing and Interfaces</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Duck Typing and Interfaces</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>We've noticed before that Python is happy to allow us to store any kind of value in any variable we'd like.</p>\r\n\r\n<blockquote><pre>\r\nx = 3\r\ny = 'Boo'\r\nz = [1, 2, 3]\r\n</pre></blockquote>\r\n\r\n<p>We've also seen that we can potentially change the type of a variable any time we'd like by simply assigning a value of a different type into it.</p>\r\n\r\n<blockquote><pre>\r\nx = (1, 2)      <i># x is now a tuple</i>\r\ny = 9.5         <i># y is now a float</i>\r\nz = 'Alex'      <i># z is now a str</i>\r\n</pre></blockquote>\r\n\r\n<p>Or, thought differently, variables themselves don't have types at all in Python; only the values of those variables have types.  If we use a variable after assigning it a value, what we're allowed to do with it &mdash; the operators we can use, the functions into which we can pass it as an argument, and so on &mdash; is determined by the type of its value at the time we use it.</p>\r\n\r\n<blockquote><pre>\r\nw = 'Alex'\r\nprint(len(w))   <i># prints <b>4</b></i>\r\nq = 57\r\nprint(len(q))   <i># raises an exception, because ints don't have a length</i>\r\n</pre></blockquote>\r\n\r\n<p>In the example above, we could ask for the length of <b>w</b>, because the value of <b>w</b> is a string and strings have a length.  On the other hand, we couldn't ask for the length of <b>q</b>, because <b>q</b>'s value is an integer and integers don't have a length.</p>\r\n\r\n<p>In general, Python uses a technique that is sometimes called <i>duck typing</i> when deciding what we can and can't do with the values stored in variables.  The term \"duck typing\" comes from an old saying that insinuates that \"if a bird walks like a duck and quacks like a duck, it's a duck,\" meaning that we can deduce what something is &mdash; or at least some aspect of what something is &mdash; based on what it can do.</p>\r\n\r\n<p>If you try to call a method on an object, it's legal so long as that object's class has such a method; it's illegal if it doesn't.</p>\r\n\r\n<blockquote><pre>\r\ns = 'Hello'\r\nprint(s.upper())   <i># no problem, because the str class has an <b>upper()</b> method</i>\r\n\r\nclass XYZ:\r\n    def upper(self):\r\n        return 'Argh!'\r\n\r\nx = XYZ()\r\nprint(x.upper())   <i># also legal, prints <b>Argh!</b></i>\r\n\r\ni = 19\r\nprint(i.upper())   <i># not legal, because ints have no <b>upper()</b> method</i>\r\n</pre></blockquote>\r\n\r\n<p>What's more, based on the type of the object, the \"right thing\" will happen automatically.  Asking a string for its length will tell you how many characters it contains, asking a list for its length will tell you how many elements are stored in it, and so on.  Adding two integers together with the <b>+</b> operator gives their sum; adding two lists together with the <b>+</b> operator gives you their concatenation.  Sometimes, the same method or the same operator will behave in wildly different ways depending on the type of objects it's called on, but the behavior will always be the \"right\" behavior for that type, without you having to do anything special to ensure that.</p>\r\n\r\n<p class=\"subtitle\">How duck typing affects the way we write functions</p>\r\n\r\n<p>Armed with the knowledge that Python behaves this way, we can write functions and methods that are more flexible than we could before.  Consider this nonsensical-looking Python function:</p>\r\n\r\n<blockquote><pre>\r\ndef foo(x, y):\r\n    return x.bar(y) * 2\r\n</pre></blockquote>\r\n\r\n<p>I've left the types out of the function's signature, because it's not as clear what they are until we stop to think about it.  What must be true about the types of <b>x</b> and <b>y</b> in order to successfully evaluate a call to <b>foo(x, y)</b>?</p>\r\n\r\n<ul>\r\n  <li><b>x</b> must be an object of some class that has a method called <b>bar</b> that takes one parameter (in addition to <b>self</b>).  There might be many classes like this, and it may not always be the case that all their <b>bar</b> methods even do the same thing; the presence of the method is one part of what makes this legal.</li>\r\n  <li><b>y</b> must have a type that is compatible as an argument to <b>bar</b>.  Depending on <b>x</b>'s type &mdash; and depending on what its <b>bar</b> method does &mdash; this constraint will be different.  Any combination that works is potentially legal.</li>\r\n  <li>The type of value returned from the <b>bar</b> method must be something that can be multiplied by 2.  At first blush, that sounds like it must be a number, but if you think harder, you'll remember that you can also multiply other kinds of things (e.g., lists, strings) by numbers, too.  (If that sounds weird to you, try evaluating <b>[1, 2, 3] * 2</b> in a Python interpreter and see what you get back.)</li>\r\n</ul>\r\n\r\n<p>If all of these things are true, the call to <b>foo(x, y)</b> will succeed, and the type of value returned from <b>foo</b> will be whatever type of value you get when you multiply <b>bar</b>'s result by 2; this, again, may be different depending on the types of <b>x</b> and <b>y</b>.</p>\r\n\r\n<p>We don't normally use duck typing in situations as nonsensical-looking as this one, but this shows us the mechanics of how Python works.  It is legal to call a method on an object and pass it parameters if and only if the object's class has such a method that can accept those parameters.  \"If it walks like a duck and quacks like a duck, it's a duck.\"</p>\r\n\r\n<p>Why this is advantageous is because we can write multiple classes and intentionally give them the same <i>interface</i> (i.e., they each have one or more methods in common, whose signatures and meanings are the same in all of the classes, but whose behaviors are different in each class), then use objects of these classes interchangeably.  Python will automatically call the appropriate version of the method in the appropriate case, just as in our example above of calling <b>upper()</b> on objects of two different classes.</p>\r\n\r\n<p class=\"subtitle\">Using duck typing to our advantage</p>\r\n\r\n<p>Suppose we wanted to write a function <b>makelist</b>, which is intended to do the same thing that Python's built-in <b>list</b> function does.  First, let's make sure we understand what it does: It takes the argument you pass to it, iterates that argument, and then builds and returns a list containing all the elements that were iterated.  It's quite flexible.  For example, you can pass it data structures of various types.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>list([1, 2, 3])</b>          <i># you can pass it a list</i>\r\n[1, 2, 3]\r\n&gt;&gt;&gt; <b>list((1, 2, 3))</b>          <i># you can also pass it a tuple</i>\r\n[1, 2, 3]\r\n&gt;&gt;&gt; <b>list({'a', 'b', 'c'})</b>    <i># or even a set</i>\r\n['b', 'a', 'c']              <i># (remember that sets are not ordered)</i>\r\n</pre></blockquote>\r\n\r\n<p>But that's not all!  You can also pass it the results of functions that return sequences of results, like <b>range</b>.  (Technically, functions like these are said to return <i>generators</i>, a topic you'll see in more depth in ICS 33.)</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>list(range(5))</b>\r\n[0, 1, 2, 3, 4]\r\n</pre></blockquote>\r\n\r\n<p>Seeing all of this, you might conclude that <b>makelist</b> would be a difficult function to write, since it needs to take such a wide variety of types of input.  But there's a saving grace: lists, tuples, sets, and generators &mdash; as well as lots of other kinds of objects I didn't demonstrate above &mdash; share an interface, namely the ability to be iterated.  So any of them could, for example, be used in a <b>for</b> loop and the right thing would happen automatically.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>for x in [1, 2, 3]:\r\n        print(x)</b>\r\n\r\n1\r\n2\r\n3\r\n&gt;&gt;&gt; <b>for x in (1, 2, 3):\r\n        print(x)</b>\r\n\r\n1\r\n2\r\n3\r\n&gt;&gt;&gt; <b>for x in range(5):\r\n        print(x)</b>\r\n\r\n0\r\n1\r\n2\r\n3\r\n4\r\n</pre></blockquote>\r\n\r\n<p>The reason this works is that iteration is always done using the same interface.  What makes an object <i>iterable</i> is that it has particular methods with particular names, and these are the methods used for iteration.  Not all kinds of objects have them, though, which is why you can't do this:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>for x in 3:\r\n        print(x)</b>\r\n\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#28&gt;\", line 1, in &lt;module&gt;\r\n    for x in 3:\r\nTypeError: 'int' object is not iterable\r\n</pre></blockquote>\r\n\r\n<p>Knowing all of this, we can rely on the same approach to write our <b>makelist</b> function.  If something is iterable, we can use it in a <b>for</b> loop, which leads to this design for our function:</p>\r\n\r\n<blockquote><pre>\r\ndef makelist(items):\r\n    the_list = []\r\n\r\n    for x in items:\r\n        the_list.append(x)\r\n\r\n    return the_list\r\n</pre></blockquote>\r\n\r\n<p>And if we try this function out, we'll see it hits the nail right on the head:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>makelist([1, 2, 3])</b>\r\n[1, 2, 3]\r\n&gt;&gt;&gt; <b>makelist((1, 2, 3))</b>\r\n[1, 2, 3]\r\n&gt;&gt;&gt; <b>makelist({'a', 'b', 'c'})</b>\r\n['b', 'a', 'c']\r\n&gt;&gt;&gt; <b>makelist(range(5))</b>\r\n[0, 1, 2, 3, 4]\r\n</pre></blockquote>\r\n\r\n<p>The key is that our function says <b>for x in items</b>, and how Python handles the iteration is by asking to iterate <b>items</b>.  Depending on the type of <b>items</b>, the iteration will be done in the appropriate way automatically, so our function can be blissfully unaware of what types of input it can handle; if it's iterable, our function will do the right thing with it, no matter what type it is.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The only remaining question is how to design a set of similar classes to take advantage of this.  The code example below consists of several classes that have an identical interface (i.e., they all contain a method with the same signature), along with a function that is capable of taking an object of any of those classes (it doesn't matter which one) and calling that method on it.</p>\r\n\r\n<ul>\r\n  <li><a href=\"duck_typing.py\">duck_typing.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}