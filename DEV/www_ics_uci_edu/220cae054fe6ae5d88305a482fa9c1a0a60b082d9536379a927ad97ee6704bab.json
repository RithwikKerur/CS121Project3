{"url": "https://www.ics.uci.edu/~thornton/inf102/LabManual/ErlangTutorial.html", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\n<link rel=\"stylesheet\" href=\"../course.css\" type=\"text/css\" />\n\n<title>Informatics 102 Spring 2012: Erlang Tutorial</title>\n</head>\n\n<body>\n\n<div class=\"navbar\">\n\n<p>\nInformatics 102 Spring 2012 |\n<a href=\"../index.html\">News</a> |\n<a href=\"../CourseReference.html\">Course Reference</a> |\n<a href=\"../Schedule.html\">Schedule</a> |\n<a href=\"../LabManual\">Lab Manual</a> |\n<a href=\"../CodeExamples\">Code Examples</a> |\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\n</p>\n\n<hr />\n\n</div>\n\n<div class=\"header\">\n\n<p>Informatics 102 Spring 2012<br />\n   Erlang Tutorial</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Background</p>\n\n<p>Erlang is a functional programming language that has direct, built-in support for <i>concurrency</i> &mdash; the ability to perform more than one task simultaneously on a machine &mdash; and <i>distribution</i> &mdash; the ability to perform cooperating tasks on multiple machines.  In an era of networked, multicore computers, concurrency and distribution are becoming increasingly important.  While Erlang doesn't do anything so special that it can't be done in other languages, it clearly demonstrates the difference between a language that allows you to build infrastructure that supports concurrency and distribution (like Java) and one that has this infrastrucfture built in.</p>\n\n<p>Some of Erlang's features and syntax will be familiar from your past experience with other programming languages that you may have seen in prerequisite coursework, such as Scheme, Haskell, and Prolog.  I'll point these similarities out as they arise in this tutorial.  Though some aspects of Erlang will be familiar, where it becomes especially mind-opening is when it diverges from these similarities.</p>\n\n<p></p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Using Erlang in the ICS labs</p>\n\n<p>A reasonably-recent (good enough for us) version of Erlang is installed on the Windows workstations in the ICS labs for your use.  You can execute the Erlang interpreter from any command prompt by executing the command <b>erl</b>, though you may first need to execute these commands each time you start a new command prompt window:</p>\n\n<pre>\nset PATH=%PATH%;\"C:\\Program Files\\erl5.9.0\\bin\"\nset ERLANG_HOME=\"C:\\Program Files\\erl5.9.0\"\n</pre>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Installing Erlang on your own machine</p>\n\n<p>Erlang is open source, so downloading and installing it is free.  It is distributed as a package called <b>Erlang/OTP</b>.  (OTP is a library for building concurrent, fault tolerant applications.  We won't be covering OTP in this course.)  The latest version is Erlang/OTP R15B01.</p>\n\n<p>Erlang/OTP is actually distributed as a source code bundle, which you can compile on many operating systems, given a C compiler and the right ancillary tools.  Downloading and compiling source code can be cumbersome, though, so there are prebuilt installations available if you know where to look; where to look depends on what operating system you want to install Erlang/OTP on.</p>\n\n<p class=\"subtitle\">Installing Erlang/OTP on Windows</p>\n\n<p>An installer for the latest version of Erlang/OTP is available on the <a href=\"http://www.erlang.org/download.html\">download page</a> at <a href=\"http://www.erlang.org/\">erlang.org</a>.  The download page lists the most recent several versions along the right-hand side; be sure you choose the latest (R15B01).  To download the Windows installer, click the <i>download</i> link titled <i>R15B01 Windows binary</i>.</p>\n\n<p>After downloading the installer, execute it, then follow these steps.</p>\n\n<ul>\n  <li>The first screen is titled \"Choose Components.\"  Accept the defaults by clicking <b>Next</b>.</li>\n  <li>The next screen asks where you'd like to install Erlang.  The default is <b>C:\\Program Files\\erl5.9.1</b>, but I suggest something shorter (that, importantly, contains no spaces); install to <b>C:\\erl5.9.1</b> instead.  Either way, make a note of where you chose to install Erlang; you'll need it later.  The rest of these instructions assume you installed to <b>C:\\erl5.9.1</b>.</li>\n  <li>The next screen asks whether and where you'd like Erlang on your start menu.  Do whatever you prefer here, then click <b>Install</b>.</li>\n</ul>\n\n<p>Once the installer is complete, you're not quite finished.  Next on the agenda, you'll need to alter some Windows settings that will allow you to run the Erlang interpreter from the command line.</p>\n\n<p>Right-click on the <b>My Computer</b> icon on your desktop (or right-click it in Windows Explorer, if you can't find it on your desktop) and select <b>Properties</b>.  Select the <b>Advanced</b> tab.  Click the <b>Environment Variables...</b> button.  Under \"System variables,\" find the <b>PATH</b> variable and add this to the <i>end</i> of it:</p>\n\n<pre>\n;C:\\erl5.9.1\\bin\n</pre>\n\n<p>Then, also under \"System variables,\" click the <b>New</b> button and create a new variable named <b>ERLANG_HOME</b> with this value:</p>\n\n<pre>\nC:\\erl5.9.1\n</pre>\n\n<p>You can now execute the Erlang interpreter from any command prompt by typing the command <b>erl</b>.  If, after executing the <b>erl</b> command, you receive the following prompt, your installation was successful:</p>\n\n<pre>\n    Eshell V5.9.1 (abort with ^G)\n    1&gt;\n</pre>\n\n<p class=\"subtitle\">Installing Erlang/OTP on Other Operating Systems</p>\n\n<p>A consulting company called Erlang Solutions maintains a set of documentation and downloadable files for installing Erlang R15B01 on other operating systems (and also Windows, but the \"official\" release for Windows is just as simple).  Head to <a href=\"http://www.erlang-solutions.com/section/132/download-erlang-otp\">this link</a>.</p>\n\n<p>Others maintain scrips that you can run to download the source code, compile it, and install it.  For example, <a href=\"https://gist.github.com/2577850\">this</a> GitHub \"gist\" is a script that installs Erlang R15B01 on Ubuntu Linux.  It takes a while to run, but I've tested this on an Ubuntu Server 11.10 virtual machine to good effect.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">The Erlang interpreter</p>\n\n<p>Whether you're using it in the ICS labs or you've installed it on your own machine, the Erlang interpreter can be executed from a command prompt or terminal window using the command <b>erl</b>, upon which you'll see something like this:</p>\n\n<pre>\n    Eshell V5.9.1  (abort with ^G)\n    1&gt; \n</pre>\n\n<p>An Erlang interpreter, which is also called an Erlang <i>shell</i>, is a lot like the interpreters for other functional languages like Scheme or Haskell; it is centrally a <i>read-evaluate-print loop</i> (or REPL), in which it reads an expression from the keyboard, evaluates that expression, then prints its value.  The <b>1&gt;</b> that you see when you first start the interpreter is a prompt asking you to enter an expression.  So, for example, we could type a mathematical expression, then get a response, like this:</p>\n\n<pre>\n    1&gt; <b>2 + 4.</b>\n    6\n    2&gt;\n</pre>\n\n<p>Note that each expression you type into the interpreter must be terminated with a period (.) character, so this is an expression that adds the integers 2 and 4.  After evaluating the expression and printing its result (6), the interpreter asks for another expression; the prompt changes to <b>2&gt;</b> as this will be the second expression we've entered since starting the interpreter.</p>\n\n<p>When you want to stop the interpreter, there are at least a couple of ways to do it.  One is to call the function <b>q</b>, like this:</p>\n\n<pre>\n    2&gt; <b>q().</b>\n</pre>\n\n<p>Another (which at least works on Windows) is to press Ctrl+C, which terminates the interpreter immediately.  You can also restart the interpreter by typing Ctrl+G, then Enter; this is equivalent to stopping the interpreter and starting it again.  The prompts will begin from <b>1&gt;</b> again.  Also, notably, the values of variables will all be cleared, which is important since variables can only be assigned once within a particular scope; more about this later in the tutorial.</p>\n\n<p>As I proceed through the examples in this tutorial, I'll do a couple of things to aid readability:</p>\n\n<ul>\n  <li>Things you should type will be in <b>boldface</b>, while things that the interpreter prints out will be in normal text.</li>\n  <li>I'll restart the command numbers whenever I'm starting a new example.  You might want to do the same (using the Ctrl+G \"abort\" trick described above), to prevent variable names from one example from conflicting with variable names from another.</li>\n</ul>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Numbers and mathematical operators</p>\n\n<p>Erlang offers support for two kinds of numbers.</p>\n\n<ul>\n  <li><i>Integers</i>, which can be written like their counterparts in many languages (including Java).\n    <ul>\n      <li>Example integer values are <b>34</b> and <b>709</b>.  Unlike Java, but like Scheme, integers can be arbitrarily large, meaning that <b>7621348123950871235376234786012935871235</b> is a perfectly legal integer value in Erlang.</li>\n      <li>There is also a syntax for integers in bases other than 10.  For example, <b>2#100101</b> is 100101<sub><small>2</small></sub> or 37.  <b>16#fe34</b> is fe34<sub><small>16</small></sub> or 65076.  This can be handy for dealing with binary, octal, and hexadecimal values, though any base from 2 through 36 is supported.</li>\n    </ul>\n  </li>\n  <li><i>Floating-point numbers</i>, which are equivalent to <b>double</b> values in Java.  They are written using the same syntax as Java.\n    <ul>\n      <li>Example double values are <b>2.54</b> and <b>2.74878e11</b>.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>As in most programming languages, Erlang supports basic mathematical operators: addition, subtraction, multiplication, division, and remainder (modulus).  Below are some examples:</p>\n\n<pre>\n    1&gt; <b>2 + 4.</b>\n    6\n    2&gt; <b>6 - 8.</b>\n    -2\n    3&gt; <b>7 * 5.</b>\n    35\n    4&gt; <b>7 div 2.</b>\n    3\n    5&gt; <b>7 / 2.</b>\n    3.5\n    6&gt; <b>5 rem 4.</b>\n    1\n    7&gt; <b>6 rem 4.</b>\n    2\n    8&gt; <b>7 rem 4.</b>\n    3\n    9&gt; <b>8 rem 4.</b>\n    0\n    10&gt; <b>2 + 3 * 5.</b>\n    17\n    11&gt; <b>(2 + 3) * 5.</b>\n    25\n</pre>\n\n<p>We can see a few things from these examples:</p>\n\n<ul>\n  <li>There are two kinds of division, indicated by different operators.  (There are two kinds of division in Java, too, but they're both written with the same operator and are differentiated by context.)\n    <ul>\n      <li>Integer division, which is specified by the <b>div</b> operator, with the result of <i>i div j</i> being <i>floor</i>(<i>i</i> / <i>j</i>).\n      <li>Floating-point division, which is specified by the <b>/</b> operator.  Note that the <b>/</b> operator indicates floating-point division even when its two arguments are integers, so <b>7 / 2</b> is <b>3.5</b>.</li>\n    </ul>\n  </li>\n  <li>The <b>rem</b> operator indicates a <i>remainder</i> or <i>modulus</i>, analogous to Java's <b>%</b> operator.  (The <b>%</b> symbol has meaning in Erlang, too; it is used for commenting, which will be familiar if you've ever seen Prolog.  Erlang's syntax is influenced in several places by the syntax of Prolog.)</li>\n  <li>A fairly standard set of precedence rules govern mathematical expressions.  For example, we see in the second-to-last expression above that multiplication has a higher precedence than addition; we see in the last expression that parentheses can be used to override precedence.</li>\n</ul>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Variables</p>\n\n<p>Erlang supports <i>variables</i>.  As in Prolog, variables are distinguished by names that start with an uppercase letter.  Example variable names are <b>A</b>, <b>Alex</b>, and <b>U2</b>.</p>\n\n<p>Being a functional language, Erlang places a restriction on variables: they can't vary!  Once they've been assigned a value, they can never be reassigned while they are in scope.  In the interpreter, this is a harsh rule; once you've assigned a variable, you can never use it again.  However, this rule isn't as restrictive as it sounds because of scoping rules that are like those in other languages; variables declared within a function, for example, are only bound while that function is executing, and do not conflict with variables in other functions that have the same name.</p>\n\n<p>Assigning a value to a variable can be done using the <b>=</b> operator.  In its simplest form, the <b>=</b> operator is just like its counterpart in Java: the expression on the right-hand side is evaluated, its value is assigned into the variable on the left-hand side, and its result is that value.  For example:</p>\n\n<pre>\n    1&gt; <b>X = 3.</b>\n    3\n    2&gt; <b>X + 2.</b>\n    5\n    3&gt; <b>Y = X + 9.</b>\n    12\n    4&gt; <b>Y div X</b>\n    4\n</pre>\n\n<p>There's more to <b>=</b> than this, but first we need to learn a few other things.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Dynamic typing</p>\n\n<p>Notice that when we assign a value to a variable, we aren't required to declare the variable first, and we aren't required to declare its type.  This is because Erlang, like Scheme, is <i>dynamically typed</i>, which means that types are determined entirely at run-time, and that type errors are all run-time errors.  For example, consider this situation:</p>\n\n<pre>\n    1&gt; <b>X = 2.5.</b>\n    2.5\n    2&gt; <b>X div 2.</b>\n    ** exception error: bad argument in an arithmetic expression\n         in operator  div/2\n            called as 2.5 div 2\n</pre>\n\n<p>The <b>div</b> operator only works when its two operands are integer values.  In this case, X has a floating-point value, so our attempt to use <b>div</b> fails with an error message.</p>\n\n<p>Had the expression <b>X div 2</b> been in a function that we'd called, and had X been an argument to that function, we would have received a run-time error in that function when it executed.  There is no up-front type checking done in Erlang; dynamic typing means that type checking is done on an as-needed basis at run-time.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Atoms</p>\n\n<p><i>Atoms</i> are global, automatically-generated, named constants, which are distinguished by names that start with a lowercase letter; that lowercase letter can be followed by upper- and lowercase letters, underscores, and <b>@</b> symbols.  Simply using the atom <b>alex</b> means that you've declared a new atom called <b>alex</b>.</p>\n\n<p>Atoms can also have names that don't conform to the rules above if surrounded by single-quotes.  For example, <b>'EXIT'</b>, and <b>'I am happy today'</b> are both atoms.  <b>'alex'</b> is an atom, which is equivalent to the atom <b>alex</b>.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Tuples</p>\n\n<p>In Java, when we want to collect a fixed-size group of values together, we write a class and declare these values as fields.  For example, we might write a Point class, representing a point on the x/y plane, like this one:</p>\n\n<pre>\n    public class Point\n    {\n        private double x;\n        private double y;\n        \n        // constructors, getters, setters, etc.\n    }\n</pre>\n\n<p>Erlang offers a mechanism for collecting a fixed-size group of values together, as well; it's called a <i>tuple</i>.  Tuples are simpler to use than their counterparts in Java &mdash; though, to be fair, they don't do as much.</p>\n\n<p>Tuples are written as a sequence of expressions, separated by commas, and surrounded by curly braces.  For example:</p>\n\n<pre>\n    1&gt; <b>P = {point, 10, 20}.</b>\n    {point, 10, 20}\n    2&gt; <b>P.</b>\n    {point, 10, 20}\n</pre>\n\n<p>Here, we see that it's possible to assign a tuple into a variable, then get that tuple back when we evaluate the variable.  Notice, too, that the first value in our tuple is the atom <b>point</b>; it's very common in Erlang for the first value of a tuple to be an atom that specifies what \"kind\" of value it represents.  We can then use that atom as a way to decide what to do, in a similar way to Java's use of polymorphism to determine which version of a method to call based on the type of the object it's being called on.</p>\n\n<p>Of course, we need a way to get the individual elements of a tuple.  One way is to ask for them based on their index.  The <b>element</b> function can do this job.  Continuing the previous example:</p>\n\n<pre>\n    3&gt; <b>element(1, P).</b>\n    point\n    4&gt; <b>element(2, P).</b>\n    10\n    5&gt; <b>element(3, P).</b>\n    20\n</pre>\n\n<p>But this is ultimately unsatisfying, because it requires us to do so much work to unpackage the values in a tuple, one at a time, just like calling accessor methods in Java.  It would be nice if we could unpackage them in one fell swoop.</p>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Pattern matching</p>\n\n<p>The <b>=</b> operator in Erlang is actually not an assignment operator, as in Java.  It's actually something else: a <i>pattern matching</i> operator.  Its job is to take the value of the expression on the right, then match it to the pattern on the left, where the pattern on the left generally contains variables.  Its job is to answer this question: <i>Does the value on the right look like the pattern on the left and, if so, is there some set of values I can give to the variables on the left to make the two sides have the same value?</i>  If so, the variables on the left are given their new values.</p>\n\n<p>When we use <b>=</b> as we do in Java, the pattern match is trivial: to make the thing on the left have the same value as the thing on the right, give the thing on the left the value of the thing on the right.  That's what makes this example work:</p>\n\n<pre>\n    1&gt; <b>X = 3.</b>\n    3\n    2&gt; <b>X.</b>\n    3\n</pre>\n\n<p>But we can express more complicated patterns on the left.  For example, we can write a tuple on the left, which can be used to unpackage a tuple's elements all at once.</p>\n\n<pre>\n    1&gt; <b>P = {point, 10, 20}.</b>\n    {point, 10, 20}\n    2&gt; <b>{point, X, Y} = P.</b>\n    {point, 10, 20}\n    3&gt; <b>X.</b>\n    10\n    4&gt; <b>Y.</b>\n    20\n</pre>\n\n<p>Here, the interpreter is saying \"Is there some set of values I can give to X and Y that make the thing on the left look like the value of P?\"  P's value is the tuple <b>{point, 10, 20}</b>.  The interpreter correctly deduces the right set of values: if X were 10 and Y were 20, both sides of the <b>=</b> operator would be the value <b>{point, 10, 20}</b>.  So, the matching succeeds, and X and Y take their new values.</p>\n\n<p>(The algorithm used to do this matching is called <i>unification</i>.  If you've ever worked with Prolog before, you'll recognize this algorithm as one that is used in Prolog to match variables with values as rules are searched and applied.  It's not especially useful to know the details of how unification works; most of the time, your intuition will lead you to the right expectations.)</p>\n\n<p>As we discussed earlier in the tutorial, variables in Erlang cannot take on a new value once they've been given a value.  This rule affects pattern matching in the sense that it requires variables that already have values to retain those values; pattern matching will succeed only if the values of bound variables &mdash; those that already have values &mdash; do not need to change in order for matching to succeed.  Consider the following example:</p>\n\n<pre>\n    1&gt; <b>A = {person, \"Alex\", \"Thornton\"}.</b>\n    {person, \"Alex\", \"Thornton\"}\n    2&gt; <b>{person, FirstName, LastName} = A.</b>\n    {person, \"Alex\", \"Thornton\"}\n    3&gt; <b>FirstName.</b>\n    \"Alex\"\n    4&gt; <b>LastName.</b>\n    \"Thornton\"\n    5&gt; <b>{person, FirstName, LastName2} = A.</b>\n    {person, \"Alex\", \"Thornton\"}\n    6&gt; <b>LastName2.</b>\n    \"Thornton\"\n    7&gt; <b>{person, LastName, LastName2} = A.</b>\n    ** exception error: no match of right hand side value {person,\"Alex\",\"Thornton\"}\n</pre>\n\n<p>(Side note: Notice that Erlang supports strings, much like those in many other programming languages.  More about them later.)</p>\n\n<p>The pattern match in expression 2 succeeded, because neither FirstName nor LastName already had a value, so they could be given the values \"Alex\" and \"Thornton,\" respectively.  The pattern match in expression 5 succeeded, even though FirstName already had a value, since it had the same value as the second element of A: \"Alex.\"  The pattern match in expression 7, on the other hand, failed, since LastName already had the value \"Thornton,\" which did not match the value in the second element of A.</p>\n\n<p>Sometimes you want to match only some values but others you don't care about.  In this case, you can use <i>anonymous variables</i>, which have names that begin with an underscore (or are just an underscore by themselves).  For example:</p>\n\n<pre>\n    1&gt; <b>Person = {person, \"Alex\", \"Thornton\"}.</b>\n    {person, \"Alex\", \"Thornton\"}\n    2&gt; <b>{person, FirstName, _} = Person.</b>\n    {person, \"Alex\", \"Thornton\"}\n    3&gt; <b>FirstName.</b>\n    \"Alex\"\n</pre>\n\n<p>Anonymous variables are never bound to a value.  Using an anonymous variable in a pattern matching expression is a way of saying \"I don't care what the value of this part of the pattern is.\"  In the example above, only the second element is actually pulled out of the tuple; the third element is irrelevant.</p>\n\n<p>Pattern matching is supported in some other languages &mdash; Haskell is an example you may have seen before &mdash; and is a feature that generally leads to shorter, clearer code than you can write without it.  Erlang supports pattern matching in several places, as we'll see, in addition to just expressions that use the <b>=</b> operator; it works the same way in every place that it occurs.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Lists</p>\n\n<p><i>Lists</i> are sequences of elements.  They are implemented in Erlang in the same way as they are in other functional languages like Scheme and Haskell: fundamentally, lists are implemented as a <i>head</i> (the first element) and a <i>tail</i> (the list containing everything except the first element).</p>\n\n<p>Syntactically, lists appear like their counterparts in Haskell, with elements separated by commas and surrounded by brackets.  For example, <b>[1, 2, 3]</b> and <b>[a, b, c, d, e, f, g, h, i, j]</b> are lists.  Unlike in Haskell (but as in Scheme), Erlang permits lists to have any combination of kinds of elements, so <b>[1, a, 2, b, 3, c]</b> is also a valid list.</p>\n\n<p>One way to break a list into pieces is to use the built-in functions <b>hd</b> and <b>tl</b>, which return the head and the tail of a list, respectively.  Examples:</p>\n\n<pre>\n    1&gt; <b>X = [1, 2, 3, 4, 5].</b>\n    [1, 2, 3, 4, 5]\n    2&gt; <b>hd(X).</b>\n    1\n    3&gt; <b>tl(X).</b>\n    [2, 3, 4, 5]\n    4&gt; <b>tl(tl(X)).</b>\n    [3, 4, 5]\n    5&gt; <b>hd(tl(tl(X))).</b>\n    3\n</pre>\n\n<p>Pattern matching provides us with a better approach, however, so <b>hd</b> and <b>tl</b> are rarely used in practice.  The syntax <b>[H | T]</b> (which you might recognize from Prolog) is used to describe a list whose head is H and whose tail is T.  (This is analogous to the syntax <b>(x:xs)</b> that appears in Haskell.)  Depending on where you put it, this syntax can be used to create a new list or to split up an existing list.  Examples:</p>\n\n<pre>\n    1&gt; <b>L = [1, 2, 3, 4].</b>\n    [1, 2, 3, 4]\n    2&gt; <b>[H | T] = L.</b>\n    [1, 2, 3, 4]\n    3&gt; <b>H.</b>\n    1\n    4&gt; <b>T.</b>\n    [2, 3, 4]\n    5&gt; <b>[H1, H2, H3 | TT] = L.</b>\n    [1, 2, 3, 4]\n    6&gt; <b>H1.</b>\n    1\n    7&gt; <b>H2.</b>\n    2\n    8&gt; <b>H3.</b>\n    3\n    9&gt; <b>TT.</b>\n    [4]\n    10&gt; <b>L2 = [H2 | TT].</b>\n    [2, 4]\n    11&gt; <b>L2.</b>\n    [2, 4]\n</pre>\n\n<p>In expression 2, we used pattern matching to split the list L into a head and a tail, storing the head in H and the tail in T; the reason that expression 2 splits the list is because the <b>[H | T]</b> syntax appears on the left hand side of the <b>=</b> operator, which means that Erlang will find a value for H and T that make <b>[H | T]</b> look like the list L.  Expression 5 is a variant of this syntax, in which we store the first three elements of the list H1, H2, and H3, then the remaining elements in TT.  Expression 10 builds a new list, since it appears on the right side of the <b>=</b> operator.</p>\n\n<p>There are other ways to manipulate lists.  For example, there is a concatenation operator, <b>++</b>, which can be used to concatenate two lists together.</p>\n\n<pre>\n    1&gt; <b>[1, 2, 3] ++ [4, 5, 6].</b>\n    [1, 2, 3, 4, 5, 6]\n</pre>\n\n<p>It should be noted that list concatenation is more expensive than building a list using the <b>[H | T]</b> notation, so it should be avoided if possible.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Strings</p>\n\n<p>Erlang supports <i>strings</i>.  Strings are actually not a special, separate data type; they're implemented as a list of integers, where each integer is a character code for some character.  For example, the string <b>\"Alex\"</b> is equivalent to the list <b>[65, 108, 101, 120]</b>, since the character code for 'A' is 65, the character code for 'l' is 108, and so on.</p>\n\n<p>This leads us to an interesting question: if strings are lists of integers, how does the interpreter know whether to print a string value like <b>\"Alex\"</b> or a list of integers like <b>[65, 108, 101, 120]</b>.  If you're accustomed to Java, the answer will surprise you: Erlang decides based on the contents of the list.  If the list contains only character codes for printable characters, the list is printed as a string; otherwise, it's printed as a list.  Examples:</p>\n\n<pre>\n    1&gt; <b>[1, 2, 3, 4].</b>\n    [1, 2, 3, 4]\n    2&gt; <b>[65, 108, 101, 120].</b>\n    \"Alex\"\n    3&gt; <b>\"Alex\".</b>\n    \"Alex\"\n</pre>\n\n<p>It's not necessary to know what character code corresponds to a particular character; if you need it, you can ask for it using the syntax <b>$x</b>, which evaluates to the character code for the character <b>x</b>.  Examples:</p>\n\n<pre>\n    1&gt; <b>$A.</b>\n    65\n    2&gt; <b>[$A, $b, $c].</b>\n    \"Abc\"\n</pre>\n\n<p>Since strings are implemented as lists, all of the things we can do with lists can be done with strings, as well, including built-in list-processing functions like <b>map</b>, <b>filter</b>, and so on.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Modules and functions</p>\n\n<p>A language implementation with only a REPL and interactive commands is only of limited use; at some point, we'd like to be able to write code, save it into a file, then load it up when we need it.  Erlang allows us to do this by writing <i>modules</i>.</p>\n\n<p>Modules are collections of <i>functions</i>.  Functions serve the same purpose that they do in Scheme or Haskell; they describe how to calculate a result given a sequence of arguments.</p>\n\n<p>An example module follows:</p>\n\n<pre>\n    -module(mymath).\n    -export([fib/1]).\n    \n    fib(0) -&gt; 0;\n    fib(1) -&gt; 1;\n    fib(N) -&gt; fib(N - 1) + fib(N - 2).\n</pre>\n\n<p>This code should be written in a file named <b>mymath.erl</b> (i.e., the name of the file should match the name of the module, with the extension <b>.erl</b> added).</p>\n\n<p>In order to use this module, we first need to compile it.  There are two ways to compile it:</p>\n\n<ul>\n  <li>From an operating system command prompt or terminal window, type the command <b>erlc mymath.erl</b>.</li>\n  <li>From the Erlang interpreter, type the command <b>c(mymath).</b>.</li>\n</ul>\n\n<p>Either way, a compiled version of the file, named <b>mymath.beam</b>, will be generated.  Erlang is similar to Java, in the sense that the compiler translates Erlang source code to a virtual machine language, which is then executed by the interpreter.  <b>.erl</b> files are analogous to <b>.java</b> files, while <b>.beam</b> files are analogous to <b>.class</b> files.</p>\n\n<p>Once compiled, it is possible to call any of the module's <i>exported</i> functions &mdash; those that appear in the export list denoted by the <b>-export</b> directive &mdash; from the interpreter prompt (or from other modules).  Modules are permitted to export as many functions as they'd like; in this case, we've just exported one of them.  The name of a function is the name of the module combined with the name of the function, separated by a colon.  So, for example, the name of the function exported by this module is <b>mymath:fib</b>.  Example:</p>\n\n<pre>\n    1&gt; <b>c(mymath).</b>\n    {ok, mymath}\n    2&gt; <b>mymath:fib(10).</b>\n    55\n    3&gt; <b>mymath:fib(20).</b>\n    6765\n</pre>\n\n<p>Note that the call to the <b>c</b> function is only necessary if the module has not already been compiled.</p>\n\n<p>There are a few other things worth noting here:</p>\n\n<ul>\n  <li>The <b>fib</b> function takes one argument, but nowhere is the type of that argument defined.  Remember that Erlang is dynamically typed, which means that the compiler does no type checking; type checking is done when the function is called, based on what the function does.</li>\n  <li>When necessary, the name of the function includes its <i>arity</i> (i.e., the number of arguments it accepts).  For example, in the <b>-export</b> directive, the function is listed as <b>fib/1</b>, which means \"a function called fib that takes one argument.\"  This is important, because it's possible to overload a function with different numbers of arguments.  Note that since you cannot specify the types of arguments, you cannot overload a function on the basis of its argument types; you can overload only on the number of arguments it accepts.</li>\n  <li>The <b>fib</b> function is made up of three <i>function clauses</i>.  Each clause consists of a <i>head</i> (a signature) and a <i>body</i> (how to calculate a result).  The clauses are separated by semicolons and the last one is terminated with a period.</li>\n  <li>Pattern matching is used to choose which clause should execute in any given situation, which is often used as a replacement for some kind of \"if\" or \"case\" expression.  The actual parameters are pattern-matched against the clauses in the order specified; the first match is the one that is executed.  So, if <b>fib</b> is passed 0, it returns 0; if it is passed 1, it returns 1; if it is passed some other value <b>N</b>, it returns the sum of calling <b>fib</b> on <b>N</b>-1 and <b>N</b>-2.  Order is important here; had we placed the last clause first, there would be no base case and the recursion will continue unabated (until the run-time stack overflows), since any value would match <b>N</b>.</li>\n</ul>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Funs</p>\n\n<p><i>Funs</i> are anonymous functions.  Funs are data, as is typical of functions in functional languages like Scheme and Haskell.  (Note that, unlike Scheme and Haskell, functions are not data.)  This means that funs can be passed as arguments, returned as results, stored in tuples and lists, and so on.</p>\n\n<p>Syntactically, a fun is written in this form: <b>fun(<i>arguments</i>) -&gt; <i>body</i> end</b>; it is an expression whose result is the fun itself.  Here is an example of creating and calling a fun:</p>\n\n<pre>\n    1&gt; <b>Square = fun(N) -&gt; N * N end.</b>\n    #Fun<erl_eval.6.13229925>\n    2&gt; <b>Square(3).</b>\n    9\n</pre>\n\n<p>More interestingly, though, funs can be used with <i>higher-order functions</i>, as they can in other functional languages like Scheme and Haskell.  A predefined module called <b>lists</b> contains a variety of higher-order functions that may be familiar to you, like <b>map</b>, <b>filter</b>, <b>foldl</b>, and <b>zip</b>.  These functions accept funs as their \"function\" arguments.  Examples:</p>\n\n<pre>\n    1&gt; <b>Square = fun(N) -&gt; N * N end.</b>\n    #Fun<erl_eval.6.13229925>\n    2&gt; <b>lists:map(Square, [1, 2, 3, 4]).</b>\n    [1, 4, 9, 16]\n    3&gt; <b>IsPositive = fun(N) -&gt; N &gt; 0 end.</b>\n    #Fun<erl_eval.6.13229925>\n    4&gt; <b>lists:filter(IsPositive, [1, -1, 2, -2, 3, -3]).</b>\n    [1, 2, 3]\n</pre>\n\n<p>Note that you can't pass a function as an argument; only funs can be passed this way.  However, there is a shorthand mechanism for wrapping a function as a fun:</p>\n\n<pre>\n    1&gt; <b>lists:map(fun mymath:fib/1, [1, 2, 3, 4, 5, 6]).</b>\n    [1, 1, 2, 3, 5, 8]\n</pre>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Equals vs. identical</p>\n\n<p>There are two ways in Erlang to compare values for equality.</p>\n\n<ul>\n  <li>The <b>=:=</b> and <b>=/=</b> operators mean \"identical\" and \"not identical,\" respectively.  They can be used to compare any two values to see if they are identical to one another (e.g., two numbers that are the same type and have the same value, two lists that have the same sequence of values).</li>\n  <li>The <b>==</b> and <b>/=</b> operators mean \"equal\" and \"not equal,\" respectively.  They behave just like the <b>=:=</b> and <b>=/=</b> operators, except where numbers are concerned.  For numbers, <b>==</b> and <b>/=</b> enable comparisons between integer and floating-point values.  (This means that there is a performance benefit in using <b>=:=</b> and <b>=/=</b>, as no type checking and type coercion is done.)</li>\n</ul>\n\n<p>Some examples of these follow:</p>\n\n<pre>\n    1&gt; <b>[1, 2, 3] =:= [2, 3, 4].</b>\n    false\n    2&gt; <b>[1, 2, 3] =:= [1, 2, 3].</b>\n    true\n    3&gt; <b>3 =:= 3.</b>\n    true\n    4&gt; <b>3.0 =:= 3.</b>\n    false\n    5&gt; <b>3.0 == 3.</b>\n    true\n</pre>\n\n<p>(Side note: Notice that Erlang has boolean constants <b>true</b> and <b>false</b>.)</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Recursion and the importance of tail recursion</p>\n\n<p>Being a functional language, Erlang does not offer loops, for the simple reason that it doesn't offer the mutable variables that are necessary to support them.  This doesn't mean that repetition is impossible; it just means that recursion is the only practical way to do it.  (If you've written code in Scheme or Haskell before, this will come as no surprise.)</p>\n\n<p>The potential downside of recursion is the need for the run-time stack to grow the deeper you want to recurse, as an activation record is stored on the stack for each recursive call.  This can be a serious problem for functions that are intended to process very long lists; it can be an insurmountable problem for the kinds of functions we'll write later, which are effectively like infinite loops.</p>\n\n<p>Perhaps surprisingly, it is possible to write functions that recurse infinitely without running out of stack space, though it does require some care.  It requires the use of a special form of recursion called <i>tail recursion</i>.</p>\n\n<p>A <i>tail recursive call</i> (or, more broadly, a <i>tail call</i>) is a function call that is the last act that a function will perform; whatever that function call returns, its caller will also return, with no further calculations done.</p>\n\n<p>Tail calls allow an important optimization.  A normal function call requires a new activation record to be pushed on to the run-time stack, carrying a variety of information, including the parameters, local variables, and return address.  Tail calls can be handled differently; when a function <i>f</i> makes a tail call to a function <i>g</i>, the new activation record for <i>g</i> replaces the activation record for <i>f</i>, since <i>f</i> will have no more work to do after <i>g</i> returns.  Recursion using only tail calls (i.e., tail recursion) can run infinitely, since the stack space used does not grow as the recursion deepens.</p>\n\n<p>Tail calls are also faster than non-tail calls, which makes tail recursion an important approach in practice, even when you expect recursion to be relatively shallow.</p>\n\n<p>It should be noted that not all programming languages optimize tail calls.  Java is a notable example of a language that does not, though this may someday change.  But for a language that performs this optimization, it's worth paying attention to.  Some things in Erlang absolutely require it; for example, we'll soon be writing potentially long-running servers as single, infinitely-recursive functions, which would soon run out of stack space if they aren't tail recursive.</p>\n\n<p>The following module demonstrates two versions of a factorial function: one that uses tail recursion and one that does not.</p>\n\n<pre>\n    -module(factest).\n    -export([fac/1, factail/1]).\n\n    \n    % A non-tail-recursive version\n    fac(0) -> 1;\n    fac(N) -> N * fac(N - 1).\n\n        \n    % A tail-recursive version\n    factail(N) -> factail(N, 1).\n    \n    factail(0, Product) -> Product;\n    factail(N, Product) -> factail(N - 1, N * Product).\n</pre>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Concurrency</p>\n\n<p>Thus far, there is probably little about Erlang that you haven't seen before in at least one programming language, even if you haven't seen very many of them.  Where Erlang really shines, and where it delves into territory that will be less familiar and more mind-opening, is its built-in support for <i>concurrency</i>, which allows you to easily write programs that are capable of doing more than one thing at a time.  This is important for at least a couple of reasons:</p>\n\n<ul>\n  <li>If you intend to run your program on a machine with multiple processors &mdash; a scenario that has, and will continue to, become increasingly common &mdash; it becomes necessary to write your program so that it can do more than one thing at a time.</li>\n  <li>Even if you don't have a lot of cores, concurrency provides a nice way to break up a complex program into a set of separate, simpler tasks.</li>\n</ul>\n\n<p>Lots of programming languages support concurrency in one way or another.  Erlang is very particular in how it supports it.  An Erlang program is a set of concurrently-running <i>processes</i>.  Processes are entirely isolated from one another, sharing no memory at all; they communicate with one another, when necessary, by sending messages to one another.  Processes communicate the same way if they are all running on one machine or if they are running on many machines spread across the Internet; Erlang hides virtually all of the details about how the processes communicate, which makes building <i>distributed systems</i> not much harder than building concurrent ones that run on a single machine.  Erlang also provides other important mechanisms, such as the ability for one process to know that another one has died, which is the backbone of <i>fault-tolerance</i>, the ability for a system to systematically and swiftly react to what would otherwise be catastrophic problems.</p>\n\n<p>Note that Erlang's flavor of concurrency is very different from the one available in Java.  Java programs are a set of running <i>threads</i>.  Each thread has its own run-time stack, but all threads share the same heap; in other words, all objects are shared.  This makes it necessary to carefully coordinate access to these objects, understanding which objects are actually being shared and which happen to be isolated (implicitly, since only one thread happens to touch them); access to those that are shared must be carefully <i>synchronized</i>, so, for example, they won't become corrupted if modified simultaneously by multiple threads.  This kind of synchronization turns out to be difficult to get right, which is one of the reasons why Erlang's model of concurrency is so attractive; it promises a simplicity that's often impossible to achieve in Java.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Spawning a new process</p>\n\n<p>When we want to run a function concurrently with other functions, we <i>spawn</i> a new process to execute that function.  The new process runs until the function completes &mdash; either normally or due to an error &mdash; at which time it dies.</p>\n\n<p>Spawning a new process can be done by calling the <b>spawn</b> function.  There are a few variants of the <b>spawn</b> function, but the simplest one takes a fun as an argument and executes that fun in a new process.  Here's an example:</p>\n\n<pre>\n    1&gt; <b>WaitAndPrint = fun() ->\n                          timer:sleep(5000),\n                          io:format(\"Hello!~n\")\n                      end.</b>\n    2&gt; <b>spawn(WaitAndPrint).</b>\n    &lt;0.33.0&gt;\n</pre>\n\n<p>After calling <b>spawn</b>, you'll notice that you immediately get the next prompt from the interpreter, which is ready and able to accept additional expressions from you.  Meanwhile, in the background, the WaitAndPrint fun is executing.  Notice a couple of things about the WaitAndPrint fun:</p>\n\n<ul>\n  <li>It consists of two expressions, separated by commas.  This is legal in Erlang and is useful for situations like this, where functions have side effects, but also for taking complex expressions and breaking them into separate ones with results stored in local variables.</li>\n  <li>The <b>timer:sleep</b> function pauses the process that calls it for the given number of milliseconds; the process won't be able to do anything for that length of time.  Our call here will pause the calling process for five seconds.   Note that no other processes will be affected; they'll still be able to continue processing expressions as normal.</li>\n  <li><b>io:format</b> is analogous to <b>System.out.format</b> in Java; it prints formatted output to the console.  The <b>~n</b> placeholder means \"newline character.\"</li>\n</ul>\n\n<p>So even though we're sleeping for five seconds, the interpreter will still accept expressions as input.  Why?  Because the interpreter process is separate from the one we spawned; they're running concurrently.</p>\n\n<p>After five seconds, no matter what we're doing in the interpreter, we'll see the text <b>Hello!</b> pop up in the interpreter window.  Granted, seeing text pop up in the interpreter, colliding with other text you're typing, isn't especially convenient.  But if processes are doing other kinds of things, like writing files, communicating across networks, or drawing graphics in isolated windows, this kind of concurrency becomes very handy indeed.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Pids, mailboxes and message passing</p>\n\n<p>Concurrent processes are of relatively limited use if they are isolated from one another and have no means of interacting.  While there is wisdom in trying to limit the amount of interaction when possible, some interaction is necessary, just as it's usually necessary, when you hire people to work for you, that they communicate with each other (and with you) at least some of the time.</p>\n\n<p>Though Erlang processes are isolated from one another, in the sense that they share no memory, they are capable of sending messages to one another.  This section details the mechanisms that are needed for message passing.</p>\n\n<p class=\"subtitle\">Pids</p>\n\n<p>In the example above, notice that the call to <b>spawn</b> returned the value <b>&lt;0.33.0&gt;</b>.  Every process has a unique <i>process identifier</i>, or <i>pid</i>, associated with it.  The pid associated with the process we created in the example above was <b>&lt;0.33.0&gt;</b>.  (You may notice a slightly different return value when you run this code, as you won't always get the same pid back when you create a process, but the value will have a similar structure.)</p>\n\n<p>The syntax <b>&lt;0.33.0&gt;</b> is the printable representation of a pid in the Erlang shell, but it does not literally build a pid in Erlang.  There is a built-in function called <b>pid</b> that does; for example, <b>pid(0, 33, 0)</b> would return the pid <b>&lt;0.33.0&gt;</b>.)  However, it will most often be more convenient to store pids in variables, pass them as parameters, etc.  For example:</p>\n\n<pre>\n    1&gt; <b>WaitAndPrint = fun() ->\n                          timer:sleep(5000),\n                          io:format(\"Hello!~n\")\n                      end.</b>\n    2&gt; <b>Pid = spawn(WaitAndPrint).</b>\n    &lt;0.33.0&gt;\n    3&gt; <b>Pid.</b>\n    &lt;0.33.0&gt;\n</pre>\n\n<p class=\"subtitle\">Mailboxes</p>\n\n<p>Every process has its own <i>mailbox</i>, which collects messages sent to that process.  As messages are received by a process, they are removed from the mailbox.  In order to make use of mailboxes, we'll need to learn two things: how to send messages and how to receive them.</p>\n\n<p class=\"subtitle\">Sending a message to a process</p>\n\n<p>The simplest way to send a message to a process is to use its pid.  The <b>!</b> operator is used to send a message to a process.  It is a binary operator, with the pid of the receiving process on the left-hand side and the message on the right-hand side.  Messages are not special; a message can be any Erlang term (i.e., any Erlang data structure, such as a number, an atom, a list, a tuple, a fun, etc.).</p>\n\n<p>Continuing the previous example:</p>\n\n<pre>\n    4&gt; <b>Pid ! 35.</b>\n    35\n</pre>\n\n<p>This expression sends the message <b>35</b> to the process we created previously.</p>\n\n<p>One important thing to understand about sending messages is that it will never appear to fail, so long as we place a pid on the left-hand side of the <b>!</b>.  If the pid is not associated with any currently-running process, the message will quietly be lost.  There will also be no notification provided when the other process receives the message.  We say that this kind of message passing is <i>fire and forget</i>, meaning that we send messages with little regard to whether they'll get to where they need to go.  (That said, we can build our own mechanisms for checking whether messages were received, such as expecting receivers to send us responses.  But no such mechanism is automatically provided.)</p>\n\n<p class=\"subtitle\">Receiving a message from a process' mailbox</p>\n\n<p>A process receives one message from its mailbox using the <b>receive</b> expression.  The general structure of a <b>receive</b> expression is:</p>\n\n<pre>\n    <b>receive</b>\n        Pattern1 -&gt;\n            Expressions1;\n        Pattern2 -&gt;\n            Expressions2;\n        ...\n        PatternN -&gt;\n            ExpressionsN\n    <b>end</b>\n</pre>\n\n<p>When a <b>receive</b> expression is evaluated, the first message in the process' mailbox is removed and matched against the patterns in the order they're listed, using the same kind of pattern matching that's done on function arguments and by the <b>=</b> operator.  The expressions corresponding to the first pattern that matches the message are evaluated, with the result of the <b>receive</b> expression being the result of the last corresponding expression.</p>\n\n<p>If there are no patterns that match the first message, the second message is tried, then the third, and so on, until a message matches a pattern.  If no messages match any patterns (or if there are no messages in the mailbox at all), the <b>receive</b> expression <i>blocks</i> the process until a matching message arrives.  By \"blocks,\" I mean that the process will not be able to do any additional work until a message arrives that matches one or more of the patterns in the <b>receive</b> expression.</p>\n\n<p>Example:</p>\n\n<pre>\n    1&gt; <b>Pid = spawn(fun() ->\n                       receive\n                           hello ->\n                               io:format(\"Hello!~n\");\n                           goodbye ->\n                               io:format(\"Goodbye!~n\");\n                           _Other ->\n                               io:format(\"Unknown message~n\")\n                       end\n                   end).</b>\n    &lt;0.53.0&gt;\n    2&gt; <b>Pid ! goodbye.</b>\n    Goodbye!\n    goodbye\n</pre>\n\n<p>Expression 1 spawns a new process, executing a function that expects one of three kinds of messages: the atom <b>hello</b>, the atom <b>goodbye</b>, or anything else (note the underscore at the beginning of the variable name, which is a way of saying \"I don't care what this value is\").  Expression 2 sends the <b>goodbye</b> message.  Notice that the spawned process prints <b>Goodbye!</b> to the output in response.</p>\n\n<p class=\"subtitle\">Receive with timeout</p>\n\n<p>A variant of the <b>receive</b> expression supports a timeout, so that a process won't be blocked indefinitely if no messages arrive.  This variant looks like this:</p>\n\n<pre>\n    <b>receive</b>\n        Pattern1 -&gt;\n            Expressions1;\n        Pattern2 -&gt;\n            Expressions2;\n        ...\n        PatternN -&gt;\n            ExpressionsN\n    <b>after</b> TimeInMilliseconds -&gt;\n        TimeoutExpressions\n    <b>end</b>\n</pre>\n\n<p>The only difference between this variant and the previous one is that it will evaluate the TimeoutExpressions if no message arrives before the given timeout, with the result of the <b>receive</b> expression being the result of the last of the TimeoutExpressions.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Process registration</p>\n\n<p>Pids can be inconvenient to deal with, since it is often necessary to pass them to many processes and store them.  For this reason, Erlang offers the ability to <i>register</i> a process.  Registering a process is to associate it with an atom that functions as its name.  Once a process is registered, its registered name is available globally to all other processes; other processes can send messages to it using its registered name instead of its pid.  Example:</p>\n\n<pre>\n    1&gt; <b>register(handler, spawn(fun connection_handler:handle_connection/0)).</b>\n    true\n    2&gt; <b>handler ! 35.</b>\n    35\n    3&gt; <b>unregister(handler).</b>\n    true\n</pre>\n\n<p>Expression 1 spawns a new process and registers it with the name <b>handler</b>.  Expression 2 sends the message <b>35</b> to that process.  Finally, Expression 3 unregisters <b>handler</b>, making that name available to other processes; only one process can be registered with a particular name at any given time.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">That's it?  Where can I learn more?</p>\n\n<p>This concludes the Erlang tutorial.  Note that we haven't covered the entire Erlang language, nor have we covered every detail of the features that we've discussed.  If you'd like to learn more, there are a few places you can go.</p>\n\n<ul>\n  <li>Of course, we'll cover several detailed <a href=\"CodeExamples\">code examples</a> in lecture, which will be posted here on the course web site afterward.</li>\n  <li>If you're interested in reference material, there is a fair amount of documentation available at <a href=\"http://erlang.org/doc/\">erlang.org's documentation page</a> and also at <a href=\"http://erldocs.com/\">erldocs.com</a>.</li>\n  <li>If you're interested in a much more thorough book on the subject, there is a wonderful, free online book titled <a href=\"http://learnyousomeerlang.com/\">Learn You Some Erlang for Great Good</a>, which, despite its peculiar title, is an excellent book.</li>\n</ul>\n\n</div>\n\n<div class=\"history\">\n\n<hr />\n\n<ul class=\"nomarker\">\n  <li>A few tweaks and fixes by Alex Thornton, Spring 2012.</li>\n  <li>Some additions, clarifications, and link updates added by Alex Thornton, Winter 2010.</li>\n  <li>Originally written by Alex Thornton, Winter 2009.</li>\n</ul>\n\n</div>\n\n</body>\n</html>\n", "encoding": "ascii"}