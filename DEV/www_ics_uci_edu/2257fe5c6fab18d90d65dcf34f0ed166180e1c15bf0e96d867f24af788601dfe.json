{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/PyGameSpots/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: The Spots Game</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: The Spots Game</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>In the previous code example, we explored how to use PyGame to draw animations one frame at a time.  Each frame of our animation was drawn during one iteration of a game loop; each time through the game loop, we made whichever adjustments were necessary to make the next frame look different.  This was a very good start, but as we start to work on problems that are more complex, it becomes more important to think more about how we're choosing to solve them.</p>\r\n\r\n<p>One problem that we ignored in the previous example, but that we should consider how to solve, is how to handle resizing a PyGame window, so that the game can be played at a larger or smaller size.  For example, we might like everything to be drawn proportional to the size of the window, so that doubling the window's width and height would cause each frame to be drawn at double the width and height, as well.  Scaling our image proportionally requires thinking about coordinates differently.</p>\r\n\r\n<p>Additionally, we were happy in the previous example to cram everything into a single game loop, written within a single function, but it's clear that this is not an approach that will scale well, from a design perspective.  Eventually, we'll have so much input-handling, drawing, and world-altering code mixed together in each loop iteration, it will become difficult for us to understand it or to make changes to it.  For this reason, we need to take that complexity and break it up.  Broadly, we can divide a game like this into two components:</p>\r\n\r\n<ul>\r\n  <li>A <i>model</i>, which is tasked with keeping track of the game's mechanics.  In other words, the model understands how the game is played &mdash; its rules, its objects, and so on &mdash; but is not concerned with how it looks or how the user interacts with it.</li>\r\n  <li>A <i>view</i>, whose focus is how the game looks and how the user interacts with it, but that remains ignorant of the game's mechanics.</li>\r\n</ul>\r\n\r\n<p>Every problem we face in writing games like these can be characterized as either a model problem or a view problem; if it seems like both, that's probably because it's two problems, one a model problem and one a view problem.  We'll want to be fastidious about keeping these separate from each other, so best to use Python's mechanism for doing so: We'll write them in separate modules.</p>\r\n\r\n<p class=\"subtitle\">The Spots game</p>\r\n\r\n<p>In lecture, we built a game that I called the <i>Spots game</i>.  When launched, it displays an empty window (i.e., a background color with nothing else drawn).  Clicking the mouse in that window somewhere causes a <i>spot</i> (an ellipse) to be drawn, and it also begins moving in a randomly-chosen direction.  Clicking within an existing spot causes that spot to disppear, rather than creating a new one; if two spots overlap and the click occurs within both, the topmost spot (the one added most recently and, thus, drawn above the others) is removed.</p>\r\n\r\n<p class=\"subtitle\">Designing the model</p>\r\n\r\n<p>In designing our model, our focus should be on trying to build tools that can assist us, rather than doing boring, repetitive work on our own.  For this reason, we settled on the idea of writing a Spot class; an object of this class represents one spot.  This allows us to have spots that can be empowered to answer useful questions and do things, rather than just be dumb holders of data.  For example, our Spot class could have operations like these:</p>\r\n\r\n<ul>\r\n  <li>What is your center point?</li>\r\n  <li>What is your radius?</li>\r\n  <li>Here is another point: is it inside of you?</li>\r\n  <li>Move yourself, given your current speed and direction.</li>\r\n</ul>\r\n\r\n<p>Finally, we could encapsulate the notion of the overall state of the Spots game in another kind of object, called a SpotsState.  The state of the Spots game is represented by a list of spots, which grows and shrinks as spots are added and removed.  Rather than just have SpotsState be a dumb container that stores a list of Spot objects, we'll empower it further, by including a method that handles the adding and removing of spots that occurs when the mouse is clicked.</p>\r\n\r\n<p class=\"subtitle\">Designing the view</p>\r\n\r\n<p>Given our model classes, Spot and SpotsState, our view can be focused entirely on what our game looks like and how the user interacts with it.  It draws the spots (appropriately sized), as well as handling user input like resizing the window or clicking the mouse inside of it.  As long as our view contains a SpotsState object, it will be able to ask that object to do most of the heavy lifting whenever the user takes action.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Coordinates, revisited</p>\r\n\r\n<p>We've seen before that PyGame uses a Cartesian-like coordinate system, in which each pixel (i.e., each dot that you can draw) is represented by a unique (<i>x</i>, <i>y</i>) coordinate.  In a PyGame window whose surface is 500 pixels wide by 400 pixels tall, the coordinates look like this:</p>\r\n\r\n<table border=\"0\" align=\"center\">\r\n  <tr>\r\n    <td align=\"right\">(0, 0)</td>\r\n    <td></td>\r\n    <td>(499, 0)</td>\r\n  </tr>\r\n  <tr height=\"100\">\r\n    <td></td>\r\n    <td><img src=\"canvas.png\" alt=\"\" /></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td align=\"right\">(0, 399)</td>\r\n    <td></td>\r\n    <td>(499, 399)</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>However, if we doubled the width and height of the surface (to 1,000 pixels wide and 800 pixels tall), we would find that the coordinate system would change to this instead:</p>\r\n\r\n<table border=\"0\" align=\"center\">\r\n  <tr>\r\n    <td align=\"right\">(0, 0)</td>\r\n    <td></td>\r\n    <td>(999, 0)</td>\r\n  </tr>\r\n  <tr height=\"100\">\r\n    <td></td>\r\n    <td><img src=\"canvasbig.png\" alt=\"\" /></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td align=\"right\">(0, 799)</td>\r\n    <td></td>\r\n    <td>(999, 799)</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>Note, however, that if we draw the next frame of animation the same way we drew the previous one, the lines and shapes we drew previously will retain their original coordinates, so their size and position relative to the top-left will not change.  If we want them to correspondingly double their size, we'll need to redraw them with new coordinates instead.</p>\r\n\r\n<p class=\"subtitle\">Alternative coordinate systems</p>\r\n\r\n<p>While PyGame doesn't offer much relief &mdash; its coordinate system is what it is, based on counting pixels &mdash; we can do a little bit of extra work and fix the problem ourselves.  Just because PyGame expects us to draw our shapes using pixel coordinates (i.e., all distances are measured in terms of pixels) doesn't mean that we have to conceptualize our shapes that way throughout our program.  We just need the pixel coordinates at the moment we plan to actually draw the shapes; prior to that, we can use any coordinate system we'd like, then do a conversion just before we draw.</p>\r\n\r\n<p>In lecture, we explored an alternative I called <i>fractional coordinates</i>, which used floating-point numbers to specify coordinates as a fraction of the distance from the left to the right (horizontally, in the <i>x</i> direction) and from the top to the bottom (vertically, in the <i>y</i> direction).  These coordinates were independent of the size of the surface, allowing us to think of, say, a rectangle that fills up a particular <i>proportion</i> of the surface instead of a particular number of pixels.</p>\r\n\r\n<p>The fractional coordinate system, as we defined it, looked like this instead:</p>\r\n\r\n<table border=\"0\" align=\"center\">\r\n  <tr>\r\n    <td align=\"right\">(0.0, 0.0)</td>\r\n    <td></td>\r\n    <td>(1.0, 0.0)</td>\r\n  </tr>\r\n  <tr height=\"100\">\r\n    <td></td>\r\n    <td><img src=\"canvas.png\" alt=\"\" /></td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <td align=\"right\">(0.0, 1.0)</td>\r\n    <td></td>\r\n    <td>(1.0, 1.0)</td>\r\n  </tr>\r\n</table>\r\n\r\n<p class=\"subtitle\">Applying an alternative coordinate system</p>\r\n\r\n<p>To make use of an alternative coordinate system, though, we'd need to reconcile it with the coordinate system required by PyGame when it comes time to draw shapes.  Here's what can be done:</p>\r\n\r\n<ul>\r\n  <li>Know the fractional coordinates of the shapes you want to draw.</li>\r\n  <li>In each iteration of your game loop, when it comes time to draw everything, first determine the size of the surface you're drawing on.  Then, you can use this information to convert the fractional coordinates to pixel coordinates.  You can do this by multiplying the fractional <i>x</i>-coordinate by the width of the surface (in pixels) and multiplying the fractional <i>y</i>-coordinate by the height.\r\n    <ul>\r\n      <li>So, for example, if we wanted to draw one ring bounded by the box (0.4, 0.3) - (0.6, 0.7) in fractional coordinates on a surface of width 600 and height 700, we would do this:\r\n        <ul>\r\n          <li>Convert the top-left fractional coordinate to a pixel coordinate.  (0.4, 0.3) &rArr; (0.4 * 600, 0.3 * 700) &rArr; (240, 210).</li>\r\n          <li>Convert the bottom-right fractional coordinate to a pixel coordinate similarly.  (0.6, 0.7) &rArr; (0.6 * 600, 0.7 * 700) &rArr; (360, 490).</li>\r\n        </ul>\r\n      </li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>Note that our model would want to rely on fractional coordinates throughout, because pixels are essentially meaningless <i>except</i> when it comes time to draw a frame of our animation.  Fractional coordinates are the ones that have immutable meaning &mdash; (0.5, 0.5) is always the center in fractional coordinates, whereas the pixel coordinate of the center changes every time the window's size changes.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Handling additional kinds of events using PyGame</p>\r\n\r\n<p>PyGame's input arrives in our program in the form of <i>events</i>, which are generated behind the scenes whenever the user does things like press keys on the keyboard, click their mouse button, and so on.  Those events are given to us when we call the <b>pygame.event.get()</b> function, which returns all of the events that have occurred since the last time it was called.  By calling it once per iteration of our game loop, we get the effect of events appearing to be handled more or less as they happen.</p>\r\n\r\n<p>This example handles two new kinds of events that we've not yet seen.  Events in PyGame carry attributes that describe the event in more detail.  They all have a <b>type</b> attribute that specifies what kind of event they are; depending on what kind of event we have, though, we can expect to find other attributes available, as well.</p>\r\n\r\n<ul>\r\n  <li><b>pygame.VIDEORESIZE</b>, which occurs every time the size of the PyGame display window is changed.  In events with this type, the attribute <b>pygame.size</b> will be a two-element tuple containing the width and height in pixels, respectively, of the window are it's been resized.</li>\r\n  <li><b>pygame.MOUSEBUTTONDOWN</b>, which occurs every time the primary mouse button goes down while the mouse cursor is within the PyGame display window.  (Note that PyGame distinguishes between the button going down and the button going up; what triggers these events is the change in state between the button being depressed and not.)  In events with this type, the attribute <b>pygame.pos</b> will be a two-element tuple containing the (<i>x</i>, <i>y</i>) coordinate &mdash; measured in pixels, relative to the location of the window &mdash; where the mouse was pointing at the time the button went down.</li>\r\n</ul>\r\n\r\n<p>There are several more kinds of events that PyGame can handle, as well, which you will find described in the documentation for the <b>pygame.event</b> library here.</p>\r\n\r\n<ul>\r\n  <li><a href=\"http://www.pygame.org/docs/ref/event.html\"><b>pygame.event</b> documentation</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>A completed, lightly-commented version of the Spots game from lecture is avialable below.</p>\r\n\r\n<ul>\r\n  <li><a href=\"spots_game.py\">spots_game.py</a></li>\r\n  <li><a href=\"spots.py\">spots.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}