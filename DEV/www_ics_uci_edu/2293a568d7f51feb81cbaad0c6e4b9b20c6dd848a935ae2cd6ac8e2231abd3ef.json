{"url": "https://www.ics.uci.edu/~pattis/ICS-33/assignments/program1/program.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 1</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 1</h1>\r\n<h1>\r\nIteration and Major Data Types:<br>\r\nList, Tuple, Set, and Dict (and Open for files) \r\n</h1>\r\n<p>\r\n<h2>ICS-33: Intermediate Programming\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to use\r\n  combinations of Python's most important data types to model and\r\n  compactly write code that solves a wide variety of different programming \r\n  problems.\r\nThe kind of abstract thinking that goes into modeling solutions to these\r\n  programming problems with these data types (and iteration over them) is\r\n  critical to your development as computer scientists.\r\n<p>\r\nThere are five parts to this assignment.\r\n<!--- (and and extra credit part at the end). --->\r\nIn each you will be asked to write a module that contains a few functions\r\n  and a script at the bottom, which ties these functions together to solve\r\n  the problem.\r\n<p>\r\nYou should download the \r\n  <a href=\"program1.zip\">program1</a> project folder and use it to create an\r\n  Eclipse project.\r\nThe project folder contains files for all the modules in which to write your\r\n  functions and scripts; it also contains all the data files that you need to\r\n  test/debug your modules; finally, it contains all the batch self-check files\r\n  I will use when grading your programs.\r\nIn your modules, you may import additional standard/courselib modules and you\r\n  may write additional helper functions.\r\n<p>\r\nI recommend that you work on this assignment in pairs, and I recommend that you\r\n  work with someone in your lab section (so that you have 4 hours each week of\r\n  scheduled time together).\r\nThese are just recommendations.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<p>\r\n<b>Only one student should submit all parts of the the assignment</b>, but both\r\n  students' UCInetID and name should appear in a comment at the <b>top</b> of\r\n  <b>each submitted .py file</b>.\r\nA special grading program reads this information.\r\nThe format is a comment starting with <b>Submitter</b> and <b>Partner</b> (when\r\n  working with a partner), followed by a <b>colon</b>, followed by the student's <b>UCInetID</b> (in all lower-case), followed by the student's <b>name in\r\n  parentheses</b> (last name, comma, first name -capitalized appropriately).\r\nIf you omit this information, or do not follow this exact form, it will require\r\n  extra work for us to grade your program, so we will deduct points.\r\n<p>\r\nFor example if Romeo Montague (whose UCInetID is romeo1) submitted a program\r\n  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)\r\n  the comment at the top of each .py file would appear as:\r\n<pre><b># Submitter: romeo1(Montague, Romeo)\r\n# Partner  : jcapulet(Capulet, Juliet)\r\n# We certify that we worked cooperatively on this programming\r\n#   assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  <b>before</b> starting this assignment.\r\nPlease turn in each program <b>as you finish it</b>, so that I can more\r\n  accurately assess the progress of the class as a whole during this assignment.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nThe code you write should be as elegant and compact as possible, using \r\n  appropriate Python idioms.\r\nYou should familiarize yourselves with the <b>safe_open</b> function in the\r\n  <b>goody</b> module and all the functions in the <b>prompt</b> module, both\r\n  of which you should have installed in your <b>courselib</b> folder as part\r\n  of the Eclipse/Python installation.\r\nRecall how to use the <b>sep</b> and <b>end</b> parameters in the <b>print</b>\r\n  function.\r\n<p>\r\nReread the section on <b>Time Management</b> from Programming Assignment 0\r\n  before starting this assignment.\r\n<p>\r\n<b>IMPORTANT 1</b>:\r\nBefore starting this assignment, download the\r\n  <a href=\"xref.zip\">xref</a> project folder which contains a small Python\r\n  script <b>xref.py</b> that produces a cross-reference of all the words\r\n  (converted to lower case) in a file (where words appear with spaces between\r\n  them: see <b>xrefin.txt</b> for an example): the words are listed in\r\n  alphabetic order followed by a set (i.e., no duplicates) of the line numbers\r\n  it appears on (listed in increasing numeric order).\r\nBefore solving the problems in this programming assignment, ensure you\r\n  understand all the details of how this program works: look at features and\r\n  functions like <b>safe_open</b>, <b>defaultdict</b> (and how it is used),\r\n  <b>enumerate</b>, <b>rstrip</b> and <b>lower</b>, <b>split</b> and\r\n  <b>join</b>, <b>sorted</b>, <b>for</b> loops with two (unpacked) indexes, the\r\n  two comprehensions (in the call to <b>max</b> and <b>join</b>), and\r\n  <b>format</b>.\r\nThese are the building blocks for many parts of this assignment; explore\r\n  and experiment with this code to understand how all the parts work together\r\n  to achieve the desired result.\r\nRun this code on more complicated data files.\r\n<p>\r\n<b>IMPORTANT 2</b>:\r\nThis assignment has 5 parts: pairs should work on each part together, not split\r\n  them up and do them separately.\r\nParts 1-3 are going to be worth 12 points each; parts 4-5 are to be worth 7\r\n  points each.\r\nThis skewing of points towards the simpler parts means students finishing the\r\n  first 3 parts correctly will yield a 72% average; those finishing the first 4 \r\n  parts correctly will have an 86% average; but to get an A on this  assignment\r\n  requires solving all parts correctly.\r\nI strongly recommend finishing the first part by the weekend, and then\r\n  finishing another part every few days.\r\n<p>\r\nIn the past, many students waited until the last few days and then tried to\r\n  write all their solutions: that is a recipe for learning little and getting a\r\n  poor grade (or worse, cheating and getting caught; remember that I'm going to\r\n  be running MOSS on all the parts of this assignment, checking for very similar\r\n  solutions).\r\nSo, now I am grading only 2 parts submitted the day before the due date or\r\n  later (and only 1 part submitted on the due date).\r\nYou can submit as many parts as you want earlier than the day before the due\r\n  date.\r\nThat is if you submit all 5 parts on the day before the due date, I will grade\r\n  only 2 parts; if you submit all parts on the due date I will grade only 1\r\n  part.\r\nIf you submit all 5 parts two days before the due date, I will grade all parts\r\n  and you will get two extra credit points.\r\nIn the worst case, to have me grade all parts, you must submit 3 parts two days\r\n  before the due date, 1 part a day before the due date, and 1 part on the due\r\n  date.\r\nSo, start early on this assignment and submit your work well before the due\r\n  date.\r\n<p>\r\n<b>IMPORTANT 3</b>:\r\nI will <b>mostly</b> grade all these programs automatically, using the batch\r\n  self-check files provided in the download.\r\nUse the <b>driver</b> program (explored in Programming Assignment #0) to run\r\n  the batch-self check files in this assignment; debug any errors that they\r\n  produce.\r\nBut the TAs (with some automated tools) will also look at/run the code in some\r\n  of your scripts: so the scripts need to follow exactly what is shown in the\r\n  <b>Sample Interactions</b> part for each problem.\r\nI suggest testing your code first to match the scripts; when those results are\r\n  correct, test it using the batch self-check files.\r\nFinally, if a submitted Python module contains even one syntax error or bad\r\n  import, it will <b>fail all</b> its batch self-checks; ensure that you\r\n  <b>submit modules with no syntax or bad import errors</b> (Python sometimes\r\n  adds strange imports at the top of your file; ensure that all your imports\r\n  are used and are reasonable).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 Influencers\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Influencers</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user for the name of a\r\n    file representing a graph;\r\n  reads the file (storing the graph in a dictionary);\r\n  prints the graph/dictionary in a special form;\r\n  computes an approximation to the minimmum <b>influencers</b>\r\n    (a special <b>set</b> of node names in the graph);\r\n  repeatedly prompts the user for a <b>set</b> of node names in the graph\r\n    (rejecting sets that specify any node name not in the graph);\r\n  computes and prints all the nodes that are \"influenced\" (see below) by the\r\n    node names in the set.\r\n<p>\r\nWe can use a graph to describe friendships or professional relationships, \r\n  as Facebook and LinkedIn do.\r\nEach node in a friendshiop graph is the name of a person, and that person has\r\n  edges (arrows) leading from his/her node to the nodes of all his/her friends.\r\nIn this model, friendship is symmetric (goes both ways):\r\n  if <b>a</b> is <b>b</b>'s friend (there is an arrow from <b>a</b> to\r\n  <b>b</b>), then <b>b</b> is <b>a</b>'s friend (there is an arrow from\r\n  <b>b</b> to <b>a</b>).\r\nFor simplicity, we will represent these two arrows by one double arrow: a\r\n  single line with arrowheads at both ends.\r\nSuch a graph, with all double-arrow edges, is called <b>undirected</b>.\r\nThe undirected graph below shows all the friendships among the names\r\n  <b>a-k</b>: note tha there <b>k</b> is edgeless, meaning he/she has no\r\n   friends.\r\n<p>\r\n<image src=\"images/influencegraph.jpg\">\r\n<p>\r\nSo, for example, in the above graph <b>c</b> has 4 friends:\r\n   <b>a</b>, <b>b</b>, <b>d</b>, and <b>g</b>.\r\nLikewise <b>g</b> has 3 friends: <b>c</b>, <b>h</b>, and <b>j</b>.\r\nOf course, because <b>c</b> has <b>g</b> as a friend, <b>g</b> has <b>c</b> as\r\n  a friend: see the double arrow.\r\nNote that <b>h</b> has just 1 friend: <b>g</b>.\r\nFinally <b>k</b> has 0 (no) friends.\r\n<p>\r\nAssume that people in a friendship graph can influence their friends:\r\n  specifically, assume in this example that if <b>half or more</b> of a person's\r\n  friends like a song, then that person will decide (be influenced) to like the\r\n  song too.\r\nFor example, <b>c</b> has 4 friends, so if 2 or more of <b>c</b>'s friends like\r\n  a song, then <b>c</b> will be influenced to like it too; it doesn't matter\r\n  which of <b>c</b>'s friends like the song, so long as 2 or more of his/her\r\n  friends like it.\r\n<p>\r\n<blockquote>\r\nHow does this rule apply if a person has an <b>odd</b> number of friends?\r\nFor example, <b>g</b> has 3 friends, so half for <b>g</b>'s friend would be\r\n  3/2 = 1.5 friends; in this case, we round upward to an integer and require 2\r\n  or more of <b>g</b>'s 3 friends to like the song in order to influence\r\n  <b>g</b> to like it.\r\n<p>\r\nIn fact Python's <b>math.ceil</b> (ceiling) function computes and returns the\r\n  smallest integer &gt;= to its argument: so, calling <b>math.ceil(1.5)</b>\r\n  returns <b>2</b>, and calling <b>math.ceil(2)</b> also returns <b>2</b>.\r\nTherefore, <b>math.ceil(#friends/2)</b>, whether <b>#friends</b> is even or odd,\r\n  correctly computes the minimum number of friends (an <b>int</b>) needed to\r\n  influence that person.\r\nRemember <b>ceil</b>: you will use it in your code; it is already imported into\r\n  the module you will download, into which you will write your code.\r\n</blockquote>\r\n<p>\r\nLet's see how a few people's influence can spread through this friendship graph.\r\nTo start, let's suppose that that person <b>b</b> and <b>e</b> like a song.\r\nHere is how they can influence their friends, illustrated and explained below.\r\n<p>\r\n<image src=\"images/influence1.jpg\">\r\n<image src=\"images/influence2.jpg\">\r\n<image src=\"images/influence3.jpg\">\r\n<image src=\"images/influence4.jpg\">\r\n<image src=\"images/influence5.jpg\">\r\n<p>\r\nComputing which friends are influenced by <b>b</b> and <b>e</b>:\r\n<ol>\r\n<li>At the start, only <b>b</b> and <b>e</b> like a song; if a person likes a\r\n    song, we will write a <b>*</b> after their name in the graphs above, so\r\n    the node names <b>b*</b> and <b>e*</b> appear in the first graph.\r\n<li><b>a</b> now likes the song, because 1 of <b>a</b>'s 2 friends (&gt;= half)\r\n     like the song: <b>b</b>.\r\n<li><b>c</b> now likes the song, because 2 of <b>c</b>'s 4 friends (&gt;= half)\r\n     like the  song: <b>a</b> and <b>b</b>.\r\n<li><b>d</b> now likes the song, because 2 of <b>d</b>'s 3 friends (&gt;= half)\r\n     like the song: <b>c</b> and <b>e</b>.\r\n<li><b>f</b> now likes the song, because 1 of <b>f</b>'s 1 friends (&gt;= half)\r\n     like the song: <b>d</b>.\r\n</ol>\r\nAs this point, no other people are influenced by enough of their friends to like\r\n  the song; specifically, <b>g</b> needs 2 of his/her 3 friends to to inluence\r\n  him/her to like the song, but only 1  of his/her friend likes it.\r\nSo <b>b</b> and <b>e</b> were not influential enough to make everyone in the\r\n  graph like a song, but they did influence <b>a</b>, <b>c</b>, <b>d</b>,\r\n  and <b>f</b>.\r\n<p>\r\nIn fact, no pair of people wields enough influence for everyone in this graph\r\n  to like a song (note that no one can influence <b>k</b> to like it).\r\nBut if <b>d</b>, <b>g</b>, and <b>k</b> like a song, they can influence\r\n  everyone else to like it too (check that this statement is true, to ensure\r\n  that you understand the influencing process).\r\nThis is the minimum number of people needed to influence everyone in this\r\n  friendship graph.\r\nIn this problem, we will learn how to represent friendship graphs in Python and\r\n  implement an algorithm that computes a small set of nodes that can influence\r\n  all the others.\r\nIf we wanted to create a viral marketing campaign to promote say a new song (or\r\n  any belief), we would concentrate our efforts on this set, because they could\r\n  convince everyone else in their social network.\r\n\r\n<h3>Input and Output:</h3>\r\n\r\nWe will store this graph in a dictionary: each person's/node's name will be a\r\n  key (<b>str</b>) whose  associated <b>value</b> is a <b>set</b> of <b>str</b>\r\n  of the people/node names of his/her friends.\r\n<p>\r\nRead a file where each line is either one node name (a person with no\r\n  identifiable friends) or a pair of node names (representing an undirected\r\n  friendship edge) in the graph.\r\nNote that node names may be any number of characters (not just the single\r\n  characters used in this example), separated by one semicolon character.\r\nBuild a dictionary whose keys are <b>str</b> node names, and whose associated\r\n  values are <b>set</b>s of <b>str</b> node names that are friends.\r\nWe annotate this dictionary as <b>{str:{str}}</b>.\r\n<p>\r\nFor example, the input file <b>graph1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other order, and still\r\n  produce the same dictionary).\r\nBy convention, we will put all friendless names at the end of the file.\r\n<b><pre>  a;b\r\n  a;c\r\n  b;c\r\n  c;d\r\n  d;e\r\n  d;f\r\n  c;g\r\n  g;h\r\n  g;j\r\n  i;j\r\n  k</pre></b>\r\nwhich represent the original friendship graph we examined above.\r\n<p>\r\n<image src=\"images/influencegraph.jpg\">\r\n<p>\r\nPrint the graph, one node name per line followed by the set of all his/her\r\n  friend's node names (alphabetically).\r\nThis graph above would print as\r\n<b><pre>  Graph: node -> [all its friend nodes]\r\n    a -> ['b', 'c']\r\n    b -> ['a', 'c']\r\n    c -> ['a', 'b', 'd', 'g']\r\n    d -> ['c', 'e', 'f']\r\n    e -> ['d']\r\n    f -> ['d']\r\n    g -> ['c', 'h', 'j']\r\n    h -> ['g']\r\n    i -> ['j']\r\n    j -> ['g', 'i']\r\n    k -> []</pre></b>\r\n<p>\r\nNote that the node names must be <b>sorted</b> alphabetically; and, the\r\n  <b>set</b> of associated node names must appear in a <b>list</b> whose values\r\n  are <b>sorted</b> alphabetically: we use a <b>list</b>, because it makes no\r\n  sense to talk about sorted <b>sets</b>.\r\nNote that because node <b>k</b> appears in the input file on a line by itself,\r\n  it has no friends.\r\n<b>Remember that friendship is symmetric!</b> So the line <b>a;b</b> means\r\n  <b>b</b> is <b>a</b>'s friend and <b>a</b> is <b>b</b>'s friend; this\r\n  means the node name <b>b</b> appears in node <b>a</b>'s associated set and the\r\n  node name <b>a</b> appears in node <b>b</b>'s associated set.\r\n<p>\r\nThere are multiple data files for this program: <b>graph1.txt</b> (shown\r\n  above), <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on\r\n  the first file; when you are done, test it on the remaining files.\r\nDraw the graph represented by each file to ensure that your code correctly\r\n  prints it and computes the set of influencer nodes (which you can do by\r\n  eyeballing the graphs: they are small).\r\n<p>\r\nHere is a description of the Influencer algorithm for computing a small set of \r\n nodes that can influence every node in the graph.\r\nIt is guaranteed to produce a small set of nodes with the desired property, but\r\n  it will not necessarily compute the <b>smallest</b> such set in all cases\r\n  (that is a much harder problem).\r\nYou must implement this Influencer algorithm, as it is described below.\r\n<p>\r\nIt is fairly straightforward to specify the Influencer algorithm, which is\r\n  straightforward to implement in Python.\r\nBut, first you must understand these English instructions, and only then can\r\n  you carefully translate them into Python code.\r\nYou should hand-simulate this algorithm using the data above, and verify that\r\n  it produces the results that you expect, before coding it in Python.\r\n<ol>\r\n<li>Make a dictionary (I'll call it <b>infl_dict</b> here) whose keys are all\r\n       the node names in the graph and whose associated values are 3-lists.\r\n    Initially, each 3-list stores\r\n      <ul>\r\n      <li>at index 0: the number of friends of the node minus the number of\r\n            friends needed to influence the node (this second value is the\r\n            <b>ceil</b> of half the number of its friends);\r\n          but, if a node contains no friends, the value stored at index 0\r\n            should be <b>-1</b>.\r\n      <li>at index 1: the number of friends of the node\r\n      <li>at index 2: the node name itself (duplicating the key)\r\n      </ul>\r\n    Index 0 for a node specifies its number of friends that can be removed\r\n      while still allowing the node to be influenced by its remaining friends.\r\n    For example Index 0 for <b>g</b> is computed as\r\n      <b>3-ceil(3/2)</b> = <b>1</b> meaning that node <b>c</b> can have 1 of\r\n      its friends removed and still be influenced by its (2) remaining friends.\r\n    <p>\r\n    If Index 0 stores a negative value, it cannot be influenced by its friends,\r\n      so it must be part of the returned set of influencers: see  the last pair\r\n      of lines below.\r\n<p>\r\n<li>Repeat the following process until termination:\r\n<ol type=\"a\" start=\"a\">\r\n  <li>Create a list of the 3-tuple values currently stored as 3-list values in\r\n        <b>infl_dict</b>, but only if their index 0 values are non-negative;\r\n        these are candidates for removal from the <b>infl_dict</b>, since they\r\n        can still be influenced by their friends.\r\n  <li>Terminate the Influencer algorithm if there are no values in this list;\r\n        otherwise ...\r\n  <li>Find the smallest 3-tuple in this list: use the <b>min</b> function\r\n        (not via sorting).\r\n      Because 3-tuples are unique, the minimum 3-tuple is unique.\r\n  <li>Remove the specified node name (see index 2) from <b>infl_dict</b>.\r\n  <li>For every friend of this node in the graph that is also still in\r\n         <b>infl_dict</b>, decreeasing its index 0 and index 1 values\r\n         by 1 in its associated 3-list.\r\n</ol>\r\n</ol>\r\n<p>\r\n\r\nUpon terminating, the keys remaining in <b>infl_dict</b> represent a small\r\n  (but not necessarily the smallest) set of influencers for the entire\r\n  friendship graph.\r\nNote that although <b>infl_dict</b> changes, the original dictionary storing\r\n  the friendship graph remains unchanged.\r\n<p>  \r\nRead these instructions carefully, a few times.\r\nHand simulate these instructions to ensure that you understand the Influencer\r\n  algorithm; use the data above, which is automatically traced in the example\r\n  below.\r\nDo not attempt to write any Python code to solve this problem until you\r\n  understand this algorithm and can apply it to the data specified above.\r\nEventually you will write your Python code to produce such a trace\r\n   conditionally.\r\n<p>\r\nHere is a trace (see the 2nd parameter to the <b>find_influencers</b> function\r\n  described below, which activiates the trace) for the friendship graph\r\n  specified above.\r\nThe order of values in the dictionaries and lists are arbitrary; I have written\r\n  these data structures on multiple lines for formating purposes..\r\n<b><pre>  \r\n  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [1, 3, 'd'],\r\n                           'e': [0, 1, 'e'], 'f': [0, 1, 'f'], 'g': [1, 3, 'g'], 'h': [0, 1, 'h'],\r\n                           'j': [1, 2, 'j'], 'i': [0, 1, 'i'], 'k': [-1, 0, 'k']}\r\n  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (1, 3, 'd'), (0, 1, 'e'),\r\n                           (0, 1, 'f'), (1, 3, 'g'), (0, 1, 'h'), (1, 2, 'j'), (0, 1, 'i')]\r\n  (0, 1, 'e') is the smallest candidate\r\n  Removing e as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [0, 2, 'd'],\r\n                           'f': [0, 1, 'f'], 'g': [1, 3, 'g'], 'h': [0, 1, 'h'], 'j': [1, 2, 'j'],\r\n                         'i': [0, 1, 'i'], 'k': [-1, 0, 'k']}\r\n  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (0, 2, 'd'), (0, 1, 'f'),\r\n                           (1, 3, 'g'), (0, 1, 'h'), (1, 2, 'j'), (0, 1, 'i')]\r\n  (0, 1, 'f') is the smallest candidate\r\n  Removing f as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],\r\n                           'g': [1, 3, 'g'], 'h': [0, 1, 'h'], 'j': [1, 2, 'j'], 'i': [0, 1, 'i'],\r\n                           'k': [-1, 0, 'k']}\r\n  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (1, 3, 'g'), (0, 1, 'h'),\r\n                           (1, 2, 'j'), (0, 1, 'i')]\r\n  (0, 1, 'h') is the smallest candidate\r\n  Removing h as key from influencer dictionary; decreasing friend's values there\r\n\r\n influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],\r\n                          'g': [0, 2, 'g'], 'j': [1, 2, 'j'], 'i': [0, 1, 'i'], 'k': [-1, 0, 'k']}\r\n removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (0, 2, 'g'), (1, 2, 'j'),\r\n                           (0, 1, 'i')]\r\n  (0, 1, 'i') is the smallest candidate\r\n  Removing i as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],\r\n                           'g': [0, 2, 'g'], 'j': [0, 1, 'j'], 'k': [-1, 0, 'k']}\r\n  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (0, 2, 'g'), (0, 1, 'j')]\r\n  (0, 1, 'j') is the smallest candidate\r\n  Removing j as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],\r\n                           'g': [-1, 1, 'g'], 'k': [-1, 0, 'k']}\r\n  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c')]\r\n  (1, 2, 'a') is the smallest candidate\r\n  Removing a as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'b': [0, 1, 'b'], 'c': [1, 3, 'c'], 'd': [-1, 1, 'd'], 'g': [-1, 1, 'g'],\r\n                           'k': [-1, 0, 'k']}\r\n  removal candidates    = [(0, 1, 'b'), (1, 3, 'c')]\r\n  (0, 1, 'b') is the smallest candidate\r\n  Removing b as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'c': [0, 2, 'c'], 'd': [-1, 1, 'd'], 'g': [-1, 1, 'g'], 'k': [-1, 0, 'k']}\r\n  removal candidates    = [(0, 2, 'c')]\r\n  (0, 2, 'c') is the smallest candidate\r\n  Removing c as key from influencer dictionary; decreasing friend's values there\r\n\r\n  influencer dictionary = {'d': [-2, 0, 'd'], 'g': [-2, 0, 'g'], 'k': [-1, 0, 'k']}\r\n  removal candidates    = []</pre></b>\r\n<p>\r\nWhen the algorithm terminates, the small influencer set is\r\n  <b>{'d', 'g', 'k'}</b>: the node names remaining in the <b>infl_dict</b> whose\r\n  associated 3-list stores a negative number at index 0.\r\n<p>\r\nNow, repeatedly prompt the user for a set of node names in the graph (until the\r\n  user enters <b>quit</b>) and compute and print all the nodes these influence\r\n  (as well as the percentage of nodes in the graph influenced): the default\r\n  value for the prompt should be all the nodes computed above, which when\r\n  entered should influence 100% of the nodes in the friendship graph (if they\r\n  were computed correctly).\r\nReject any set that contains a node name that is not a key in the graph.\r\n<p>\r\nCall the function <b>all_influenced</b> to compute this value:\r\n  it uses the friendship graph and the set of node names the user enters to\r\n  compute all the influenced nodes in the friendship graph as follows.\r\n<ol>\r\n<li>Create a dictionary associating every node in the graph with a <b>bool</b>\r\n      value telling whether it is currently influenced: initiallyl <b>True</b>\r\n      if and  only if it is in the set supplied to the influencers parameter;\r\n      also compute the number of keys in this dictionary whose associated value\r\n      is <b>True</b> (which initially is the length of the set).\r\n<p>\r\n<li>Repeat the following process until termination:\r\n<ol type=\"a\" start=\"a\">\r\n<li>For every item in the dictionary produced in Step 1, if it is not\r\n      yet influenced (its associated <b>bool</b> is <b>False</b>) check to see\r\n      whether it has enough friends (who are already influenced) to influence\r\n      it as well; if so, change its associated dictionary value to <b>True</b>.\r\n    <p>\r\n    You will need to treat friendless nodes specially: they are never influenced\r\n      because they have no friends.\r\n<p>\r\n<li>If the number of currently influenced nodes has not changed (from the\r\n      previous time this value was computed), terminate by returning a set of\r\n      all the dictionary keys whose associated value is <b>True</b>: all the\r\n      influenced nodes.\r\n</ol>\r\n</ol>\r\n\r\nAn example interaction (processing the graph above) might be\r\n<b><pre>  Specify the influencers set (or just quit)[{'d', 'g', 'k'}]: <i>{'b','d'}</i>\r\n  Nodes Influenced (54.54545454545455% of graph)= {'c', 'b', 'a', 'f', 'e', 'd'}\r\n\r\n  Specify the influencers set (or just quit)[{'d', 'g', 'k'}]: <i>{'a','x'}</i>\r\n    Entry Error: '{'a','x'}';  \r\n    Please enter a legal String\r\n\r\n  Specify theinfluencers set (or just quit)[{'d', 'g', 'k'}]: \r\n  Nodes Influenced (100.0% of graph)= {'h', 'c', 'b', 'a', 'i', 'f', 'j', 'e', 'd', 'g', 'k'}\r\n\r\n  Specify some influencers set (or just quit)[{'d', 'g', 'k'}]: <i>quit</i></pre></b>\r\n\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_graph</b> has an open (file) parameter; it returns the dictionary\r\n     representing the undirected friendship graph\r\n     (body is 11 lines).\r\n<p>\r\n<li><b>graph_as_str</b> has a dictionary parameter (representing the friendship\r\n      graph); it returns a multi-line string (each line is ended by\r\n      <b>'\\n'</b>), which when printed shows the contents of the graph in the\r\n      appropriate textual form\r\n     (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>find_influencers</b> has a dictionary parameter (representing the graph),\r\n         as well as a tracing parameter whose default value is <b>False</b>.\r\n       This function uses the Influencer algorithm described above to\r\n         compute/return a small set of nodes that can influence everyone in the\r\n         friendship graph; if tracing is <b>True</b> it creates a trace in the\r\n         form of the example trace shown above\r\n    (body is 13 lines, but only 11 lines without tracing code).\r\n<p>\r\n<li><b>all_influenced</b> has a dictionary parameter (representing the graph)\r\n         and a set of initially infuenced nodes.\r\n       This function uses the algorithm described above to compute/return the\r\n         set of nodes that can be influenced by this set\r\n    (body is 10 lines).\r\n<p>\r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the\r\n    file storing friendship graph; reads this file and creates the required\r\n    dictionary; labels and prints the dictionary (using <b>graph_as_str</b>);\r\n    prompts the user about whether to trace this algorithm, then computes\r\n    (using <b>find_influencers</b>) and prints the set of influencer nodes;\r\n    repeatedly prompts the user to enter a set of nodes (rejecting any set that\r\n    contains a node not in the graph) or the word <b>quit</b>; calls\r\n    <b>all_influenced</b> using the entered set, and prints the required\r\n    information (body is 11 lines).\r\n</ul>\r\n\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one (sets will match if they have the same\r\n  contents, independent of their order).\r\nYou should also check that it works for other graphs.\r\n\r\n<b><pre>  Specify the file name storing a friendship graph: <i>graph.txt</i>: \r\n  Graph: node -> [all its friend nodes]\r\n    a -> ['b', 'c']\r\n    b -> ['a', 'c']\r\n    c -> ['a', 'b', 'd', 'g']\r\n    d -> ['c', 'e', 'f']\r\n    e -> ['d']\r\n    f -> ['d']\r\n    g -> ['c', 'h', 'j']\r\n    h -> ['g']\r\n    i -> ['j']\r\n    j -> ['g', 'i']\r\n    k -> []\r\n\r\n  Trace this Algorithm[True]: <i>False</i>\r\n  Influencers set is {'g', 'k', 'd'}\r\n\r\n  Specify the influencers set (or just quit)[{'g', 'k', 'd'}]: \r\n  Nodes Influenced (100.0% of graph)= {'i', 'g', 'f', 'k', 'c', 'j', 'h', 'a', 'b', 'd', 'e'}\r\n\r\n  Specify the influencers set (or just quit)[{'g', 'k', 'd'}]: <i>quit</i><pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n-->\r\n\r\n<!-- Problem 1, Reachability -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #1: Reachability</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user for the name of a\r\n    file representing a graph;\r\n  reads the file (storing the graph in a dictionary);\r\n  prints the graph/dictionary in a special form;\r\n  repeatedly prompts the user for a starting node name (rejecting those that\r\n    are not keys in the graph);\r\n  computes and prints all the node names that are reachable from it by\r\n    following zero or more edges in the graph (e.g., a node is reachable from\r\n    itself).\r\n\r\n<h3>Input and Output:</h3>\r\nRead a file of pairs of node names (representing edges) in a directed\r\n  graph, building a dictionary whose key is a <b>str</b> source node name and\r\n  whose associated value is a <b>set</b> of <b>str</b> destination node names\r\n  that are each reachable directly from the source node name key.\r\nWe annotate this dictionary as <b>{str:{str}}</b>.\r\n<p>\r\nIn the file, two nodes names appear on each line: first the source node name,\r\n  then the destination node name, with these node names (which may be entire\r\n  words, not just single characters) separated by one semicolon character.\r\nFor example, the input file <b>graph1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other order, and still\r\n  produce the same dictionary).\r\n<b><pre>  c;f\r\n  b;d\r\n  a;c\r\n  c;e\r\n  d;g\r\n  a;b\r\n  e;d\r\n  f;g\r\n  f;d</pre></b>\r\nwhich represent the graph\r\n<p>\r\n<image src=\"images/graph.gif\">\r\n<p>\r\nPrint the graph, one source node name per line followed by the set of all the\r\n  destination node names that the source can immediately reach.\r\nThe graph above would print as\r\n<b><pre>  Graph: a node -> [showing all its destination nodes]\r\n    a -> ['b', 'c']\r\n    b -> ['d']\r\n    c -> ['e', 'f']\r\n    d -> ['g']\r\n    e -> ['d']\r\n    f -> ['d', 'g']</pre></b>\r\n<p>\r\nNote that the source node names must be <b>sorted</b> alphabetically; the\r\n  <b>set</b> of desintation node names associated with each source must appear\r\n  in a <b>list</b> whose values are also <b>sorted</b> alphabetically: it makes\r\n  no sense to talk about sorted <b>sets</b>.\r\nNote that because node <b>g</b> is not a source node (it is only a\r\n  destination node), it does not appear first on any line (and appears only\r\n  in the <b>sets</b> for source nodes <b>d</b> and <b>f</b>).\r\n<p>\r\nThere are multiple data files for this program: <b>graph1.txt</b> (shown\r\n  above), <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on\r\n  the first file; when you are done, test it on the remaining files.\r\nDraw the graph represented by each file to ensure that your code correctly\r\n  prints it and computes the node names reachable from any source node (which\r\n  you can do by eyeballing the graphs: they are small).\r\n<p>\r\nRepeatedly prompt the user for a starting node name in the graph (until the user\r\n  enters <b>quit</b>) and compute and print all the node names that are\r\n  reachable from it by following edges in the graph.\r\nReject any node name that is not a key in the graph.\r\nAn example interaction (processing the graph above) might be\r\n<b><pre>  Enter the starting node (or enter quit): <i>e</i>\r\n  From node e its reachable nodes: {'g', 'e', 'd'}\r\n\r\n  Enter the starting node (or enter quit): <i>x</i>\r\n    Entry Error: 'x';  Illegal: not a source node\r\n    Please enter a legal String\r\n\r\n  Enter the starting node (or enter quit): <i>a</i>\r\n  From node a its reachable nodes: {'g', 'f', 'e', 'd', 'c', 'b', 'a'}\r\n\r\n  Enter the starting node (or enter quit): <i>quit</i></pre></b>\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_graph</b> has an open (file) parameter; it returns the dictionary\r\n     representing the graph\r\n     (body is 5 lines).\r\n<p>\r\n<li><b>graph_as_str</b> has a dictionary parameter (representing the graph); it\r\n    returns a multi-line string (each line is ended by <b>'\\n'</b>), which when\r\n    printed shows the contents of the graph in the appropriate textual form\r\n    (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>reachable</b> has a dictionary parameter (representing the graph), a\r\n    <b>str</b> start node in the graph (technically a key in the dictionary),\r\n    and a <b>bool</b> controling tracing (whose default value is <b>False</b>);\r\n    it returns a <b>set</b> of all the nodes reachable from it by following\r\n    edges in the graph. Hint: I used the <b>get</b> dictionary function, which \r\n    allows a second argument that specifies what to do if the first argument\r\n    (key) is not in the dictionary, because this function should not mutate\r\n    the dictionary\r\n    (body is 9 lines).\r\n<p>\r\n<li>Write a script at the bottom of this module\r\n   (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the\r\n   file storing the graph and start node (rejecting any string that is not a\r\n   source node in the graph) or the word <b>quit</b>; calls these functions\r\n   with the entered information to solve the problem, and print the appropriate information: the graph\r\n   and the set containing all the node labels\r\n   (body is 9 lines).\r\n</ul>\r\nHere is the basic algorithm for computing reachability; it is simple to explain\r\n  and not (very) complicated to implement.\r\nBut, you have to understand these instructions and carefully translate them into\r\n  Python.\r\nYou should hand-simulate this algorithm using the graph above, and verify that\r\n  it produces the results you expect, before coding the algorithm in Python.\r\nYou might be tempted to use recursion, but please don't: unless recursion is\r\n  done very carefully, <b>reachable</b> will run forever on graphs that contain\r\n  cycles: one of the input files is a graph that contains cycles.\r\n<ol>\r\n<li>To compute all the reachable nodes in a graph, create a <b>set</b>\r\n   (initially empty) of reached nodes and a <b>list</b> (initially containing\r\n   the  parameter start node) of nodes that we are going to explore (to find\r\n   nodes they can reach).\r\n<p>\r\n<li>While the <b>exploring list</b> still has nodes, remove the first one\r\n    (recall the <b>pop</b> method for <b>lists</b>) and put it into the\r\n    <b>reached set</b>; for all its associated destination nodes that are not\r\n    already in the <b>reached set</b>, put them in the <b>exploring list</b>.\r\n<p>\r\n<li>When the <b>exploring list</b> becomes empty (can you argue that this always\r\n    will happen -there is no infinite looping), return the <b>reached set</b>.\r\n</ol>\r\n<p>\r\n\r\nRead these instructions carefully, a few times.\r\nHand simulate these instructions to ensure that you understand the reachability\r\n  algorithm; use the data above, which is automatically traced in the example\r\n  below.\r\nDo not attempt to write any Python code to solve this problem until you\r\n  understand this algorithm and can apply it to the data specified above.\r\nEventually you will write your Python code to produce such a trace\r\n  conditionally.\r\n<p>\r\nHere is a trace (see the 3rd parameter to the <b>reachable</b> function\r\n  described below, which activiates the trace) for graph specified above\r\n  starting at the node <b>a</b>.\r\nThe order of values in the sets are arbitrary; I have written these data\r\n  structures on multiple lines for formating purposes.\r\n\r\n<b><pre>  reached set    = set()\r\n  exploring list = ['a']\r\n  removing node a from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from a but not already in reached, exploring = ['c', 'b'] \r\n\r\n  reached set    = {'a'}\r\n  exploring list = ['c', 'b']\r\n  removing node c from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from c but not already in reached, exploring = ['b', 'f', 'e'] \r\n\r\n  reached set    = {'a', 'c'}\r\n  exploring list = ['b', 'f', 'e']\r\n  removing node b from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from b but not already in reached, exploring = ['f', 'e', 'd'] \r\n\r\n  reached set    = {'a', 'c', 'b'}\r\n  exploring list = ['f', 'e', 'd']\r\n  removing node f from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from f but not already in reached, exploring = ['e', 'd', 'g', 'd'] \r\n\r\n  reached set    = {'a', 'c', 'f', 'b'}\r\n  exploring list = ['e', 'd', 'g', 'd']\r\n  removing node e from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from e but not already in reached, exploring = ['d', 'g', 'd', 'd'] \r\n\r\n  reached set    = {'f', 'b', 'a', 'c', 'e'}\r\n  exploring list = ['d', 'g', 'd', 'd']\r\n  removing node d from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from d but not already in reached, exploring = ['g', 'd', 'd', 'g'] \r\n\r\n  reached set    = {'f', 'b', 'a', 'c', 'e', 'd'}\r\n  exploring list = ['g', 'd', 'd', 'g']\r\n  removing node g from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from g but not already in reached, exploring = ['d', 'd', 'g'] \r\n\r\n  reached set    = {'f', 'b', 'a', 'g', 'c', 'e', 'd'}\r\n  exploring list = ['d', 'd', 'g']\r\n  removing node d from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from d but not already in reached, exploring = ['d', 'g'] \r\n\r\n  reached set    = {'f', 'b', 'a', 'g', 'c', 'e', 'd'}\r\n  exploring list = ['d', 'g']\r\n  removing node d from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from d but not already in reached, exploring = ['g'] \r\n\r\n  reached set    = {'f', 'b', 'a', 'g', 'c', 'e', 'd'}\r\n  exploring list = ['g']\r\n  removing node g from the exploring list; adding it to reached list\r\n  after adding all nodes reachable directly from g but not already in reached, exploring = []</b></pre>\r\n\r\n\r\n\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one (sets will match if they have the same\r\n  contents, independent of their order).\r\nYou should also check that it works for other starting nodes, and\r\n  a variety of starting nodes in the other graphs.\r\n\r\n<b><pre>  Enter the file name describing this graph: <i>graph1.txt</i>\r\n\r\n  Graph: a node -> [showing all its destination nodes]\r\n    a -> ['b', 'c']\r\n    b -> ['d']\r\n    c -> ['e', 'f']\r\n    d -> ['g']\r\n    e -> ['d']\r\n    f -> ['d', 'g']\r\n\r\n  Enter the starting node (or enter quit): <i>e</i>\r\n  Enter whether to trace this algorithm[True]: False\r\n  From node e its reachable nodes: {'g', 'e', 'd'}\r\n\r\n  Enter the starting node (or enter quit): <i>x</i>\r\n    Entry Error: 'x';  Illegal: not a source node\r\n    Please enter a legal String\r\n\r\n  Enter the starting node (or enter quit): <i>a</i>\r\n  Enter whether to trace this algorithm[True]: False\r\n  From node a its reachable nodes: {'g', 'f', 'e', 'd', 'c', 'b', 'a'}\r\n\r\n  Enter the starting node (or enter quit): <i>quit</i></b></pre>\r\nNote that if the user specified <b>True</b> for tracing the algorithm, the\r\n  program would also print the kinds of information shown above in the example\r\n  of tracing.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<!-- Problem #2 Stable Marriage\r\n\r\n<a name=\"problem6\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2: Stable Marriage</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user for the names of\r\n  two files: a file representing the marriage preferences of a sequence of men,\r\n  and a file representing the marriage preferences of a sequence of women; \r\n  reads these files (storing this information in special data structures: \r\n  dictionaries storing preference as lists); prints the dictionary/preferences\r\n  of the men and women in a special form; runs the <b>Gale/Shapley</b>\r\n  algorithm for finding a  <b>stable</b> marriage (tracing its progress, if\r\n  required); prints the stable marriage as a set of man/woman tuples.\r\nPlease excuse my use of  heteronormative terms.\r\nThe problem is easier to state and understand when it uses two disjoint sets,\r\n  men and women, whose members match only others outside their sets.\r\n\r\n<p>\r\nSuppose that N men and N women want to match in a heterosexual marriage.\r\nEach produces a list of his/her preferences, ranking all members of the opposite\r\n  gender in highest to lowest order of acceptability as a partner.\r\nThe Gale/Shapley algorithm (described in detail below) matches men and women in\r\n  <b>stable</b> marriages.\r\nMarriages are stable when we cannot find a man and woman, who prefer each other\r\n  to their match.\r\nThis scenario can be used to find stable matches in other contexts.\r\nFor example, this algorithm is used when medical school graduates match with\r\n  hospitals for their residencies: the students and institutions rank each\r\n  other and then the algorithm is run, processing these rankings.\r\nIn this case, the residents propose (act as the men in the description above)\r\n  and the hospitals accept/reject the proposals (act as the women).\r\n<p>\r\nThe fundamental data structure used throughout this process (as both arguments\r\n  to functions and the results returned by functions) is characterized by\r\n  <b>{str:[str,[str]]}</b>, which describes a dictionary whose keys are\r\n  associated with <b>2-lists</b>.\r\nThe dictionary keys are the names of men/women (<b>str</b>).\r\nEach man/woman is associated with a <b>2-list</b>, whose first index is the\r\n  current match of that person (<b>str</b>), and whose second index is a list\r\n  ranking other possible matches (<b>list</b> of <b>str</b>), from highest to\r\n  lowest preference.\r\n<p>\r\nFor example, the following dictionary represents information about three men\r\n  participating in marriages (<b>m1</b>, <b>m2</b>, <b>m3</b>):\r\n\r\n<b><pre>  {'m1': [None, ['w3', 'w2', 'w1']],\r\n   'm2': [None, ['w3', 'w1', 'w2']],\r\n   'm3': [None, ['w2', 'w1', 'w3']]}</pre></b>\r\nHere, <b>m1</b> is currently matched with no one (<b>None</b>) and\r\n  ranks the women, in order of preference, as follows <b>w3</b> (hightes\r\n  ranking) followed by  <b>w2</b> followed by <b>w1</b> (lowest ranking).\r\nThe other lines in this dictionary are interpreted similarly.\r\nIn this example (and the ones below) I have printed each key/value pair\r\n  (alphabetically by key) on\r\n  its own line; of course, if we print a dictionary in Python, it can print\r\n  its key/value pairs in any order.\r\n<p>\r\nThe following dictionary represents information about three women\r\n  participating in marriages (<b>w1</b>, <b>w2</b>, and <b>w3</b>):\r\n<b><pre>  {'w1': [None, ['m1', 'm2', 'm3']],\r\n   'w2': [None, ['m2', 'm1', 'm3']],\r\n   'w3': [None, ['m3', 'm2', 'm1']]}</pre></b>\r\nHere, <b>w2</b> is currently matched with no one (<b>None</b>) and\r\n  ranks the men, in order of preference, as follows <b>m2</b> (highest ranking)\r\n followed by <b>m1</b> followed by <b>m3</b> (lowest ranking).\r\n<p>\r\nAfter running the Gale/Shapley algorithm (with men proposing to women, and\r\n  women accepting or rejecting their proposals: more on these details later),\r\n  these dictionaries are mutated to\r\n<b><pre>  {'m1': ['w2', ['w3', 'w2', 'w1']],\r\n   'm2': ['w3', ['w3', 'w1', 'w2']],\r\n   'm3': ['w1', ['w2', 'w1', 'w3']]}\r\n\r\n  {'w1': ['m3', ['m1', 'm2', 'm3']],\r\n   'w2': ['m1', ['m2', 'm1', 'm3']],\r\n   'w3': ['m2', ['m3', 'm2', 'm1']]}</pre></b>\r\nNote the following <b>invariant</b>: if a man is matched to a woman in the man's\r\n  dictionary, then that same woman must be matched to that man in the woman's\r\n  dictionary.\r\nVerify that this is true above.\r\n<p>\r\nAre these marriages stable?\r\nFirst, let's look just at <b>m1</b>, who is matched to <b>w2</b>.\r\nBy his preferences, he would rather marry <b>w3</b>, but she prefers\r\n  <b>m2</b> (her match) to <b>m1</b>.\r\nNow, let's look just at <b>w1</b>, who is matched to <b>m3</b>.\r\nBy her preferences, she would rather marry <b>m1</b>, but he prefers\r\n  <b>w2</b> (his match) to <b>w1</b>; also <b>w1</b> would prefer to marry\r\n  <b>m2</b>, but he also prefers <b>w3</b> (his match) to <b>w1</b>.\r\nIf you check all the other men and women (do it) you will find that you can\r\n  find no pair who would both rather marry each other, rather than their\r\n  current matches, so these marriages are considered stable.\r\n\r\n<h3>Input and Output:</h3>\r\nRead files of men and women and their rankings of all members of the opposite\r\n  gender (highest to lowest preference), separated by semicolons, building a\r\n  dictionary like the ones above (where each match is initially the special\r\n  value <b>None</b>).\r\nAs described above, we annotate the structure of this dictionary as\r\n  <b>{str:[str,[str]]}</b>.\r\n<p>\r\nIn the file, the person's name appears first, followed by the names of all\r\n  members of the opposite gender in highest to lowest preference, separated by\r\n  one semicolon character.\r\nFor example, the input file <b>men0.txt</b> contains the following\r\n  lines: these line could appear in this order, or any other, but the\r\n  each man's preferences must appear in decleasing order of preference.\r\n<b><pre>  m1;w3;w2;w1\r\n  m2;w3;w1;w2\r\n  m3;w2;w1;w3</pre></b>\r\nThe first line means, <b>m1</b> ranks the members of the opposite gender in\r\n  the order of preference from <b>w3</b>, <b>w2</b>, and <b>w1</b> in\r\n  decreasing order of preference\r\nEach line is guaranteed to start with a unique name, which is guaranteed to be\r\n  followed by all the names of all members of the opposite gender, each\r\n  appearing once; and all names are separated by semicolons.\r\n<p>\r\nWhen you print such information, print each person on a separate line, followed\r\n  by his/her match and preferences.\r\nFor example, the file above would print as:\r\n<b><pre>  m1 -> [None, ['w3', 'w2', 'w1']]\r\n  m2 -> [None, ['w3', 'w1', 'w2']]\r\n  m3 -> [None, ['w2', 'w1', 'w3']]</pre></b>\r\n<p>\r\nNote that the names on the lines must be <b>sorted</b> in alphabetical order;\r\n  the <b>list</b> of preferences must appear in the same order they appeared in\r\n  the file.\r\nThere are multiple pairs of data files for this program, all named like\r\n  <b>men0.txt</b> and <b>women0.txt</b>; Test/debug your program on the first\r\n  file; when you are done, test it on the remaining files.\r\n<p>\r\n\r\nHere is a description of the <b>Gale/Shapley Algorithm</b> for computing a\r\n  stable marriage.\r\nYou must implement this algorithm, as it is described below.\r\nThere might be other stable marriages, but this algorithm will always compute\r\n  the same one.\r\nThis algorithm is not symmetric: here men get to propose to women and women get\r\n  to accept/reject men.\r\nIf we ran the algorithm the other way (with women proposing to men, and men\r\n  accepting or rejecting women, we would also get a stable marriage, but the\r\n  matches might be different.\r\n<p>\r\nIt is fairly straightforward to specify the Gale/Shapley algorithm, which is\r\n   straightforward to implement in Python.\r\nBut, first you must understand these English instructions, and only then can\r\n  you carefully translate them into Python code.\r\nYou should hand-simulate this algorithm using the data above, and verify that\r\n  it produces the results that you expect, before coding the algorithm in\r\n  Python.\r\n<ol>\r\n<li>Make a copy of only the men's data structure: create a new dictionary that\r\n      copies all data, including copying the lists, from the original\r\n      dictionary.\r\n    We make a copy because the algorithm below mutates the men's data\r\n      structure, but we don't want its matching argument to change.\r\n    In the steps below, mutate the copy, not the parameter.\r\n<p>\r\n<li>Make an <b>unmatched</b> set that contains the names of all unmatched men.\r\n    Initially, all men are unmatched, so this set will contain all the men in\r\n    the men's dictionary.\r\n<p>\r\n<li>Repeat the following process until there are no more unmatched men.\r\n<ol type=\"a\" start=\"a\">\r\n  <li>Remove (see the <b>pop</b> operation on sets) any man from the set of\r\n        unmatched men.\r\n<p>\r\n  <li>Determine the woman that is highest on his preference list and remove that\r\n        woman from his preference list (see the <b>pop</b> operation on lists).\r\n      This man will try to propose to that woman.\r\n  <ul>\r\n     <li>If that woman is unmatched: match this man and that woman.\r\n     <li>If that woman is matched, but pefers this man to her current match: \r\n           unmatch that woman and her current match and add the man that she\r\n           previously matched (he is now unmatched) to the set of unmatched men.\r\n         Then, match this man and that woman.\r\n     <li>If that woman is matched, and pefers her current match to this man,\r\n           just add this man (still unmatched) back to the set of unmatched men.\r\n   </ul>\r\n</ol>\r\n</ol>\r\n\r\nRead these instructions carefully, a few times.\r\nDo not attempt to write any Python code to solve this problem until you\r\n  understand this algorithm and can apply it to the data specified below.\r\nHand simulate these instructions to ensure that you understand the algorithm;\r\n  use the data above, which is automatically traced in the example below.\r\nEventually you will write your Python code to produce such a trace\r\n  conditionally.\r\n<p>\r\nHere is a trace (see the 3rd parameter to the <b>make_match</b> function below)\r\n  for the men and women data structures specified above.\r\n<b><pre>  Women Preferences (unchanging)\r\n    w1 -> [None, ['m1', 'm2', 'm3']]\r\n    w2 -> [None, ['m2', 'm1', 'm3']]\r\n    w3 -> [None, ['m3', 'm2', 'm1']]\r\n\r\n  Men Preferences (current)\r\n    m1 -> [None, ['w3', 'w2', 'w1']]\r\n    m2 -> [None, ['w3', 'w1', 'w2']]\r\n    m3 -> [None, ['w2', 'w1', 'w3']]\r\n \r\n  unmatched men = {'m2', 'm3', 'm1'} \r\n\r\n  m2 proposes to w3 who is not matched, ergo accepts the proposal\r\n\r\n  Men Preferences (current)\r\n    m1 -> [None, ['w3', 'w2', 'w1']]\r\n    m2 -> ['w3', ['w1', 'w2']]\r\n    m3 -> [None, ['w2', 'w1', 'w3']]\r\n \r\n  unmatched men = {'m3', 'm1'} \r\n\r\n  m3 proposes to w2 who is not matched, ergo accepts the proposal\r\n\r\n  Men Preferences (current)\r\n    m1 -> [None, ['w3', 'w2', 'w1']]\r\n    m2 -> ['w3', ['w1', 'w2']]\r\n    m3 -> ['w2', ['w1', 'w3']]\r\n \r\n  unmatched men = {'m1'} \r\n\r\n  m1 proposes to w3 who is matched, ergo she rejects the proposal (liking her current match better)\r\n\r\n  Men Preferences (current)\r\n    m1 -> [None, ['w2', 'w1']]\r\n    m2 -> ['w3', ['w1', 'w2']]\r\n    m3 -> ['w2', ['w1', 'w3']]\r\n \r\n  unmatched men = {'m1'} \r\n\r\n  m1 proposes to w2 who is matched, ergo she accepts the proposal (liking her new match better)\r\n\r\n  Men Preferences (current)\r\n    m1 -> ['w2', ['w1']]\r\n    m2 -> ['w3', ['w1', 'w2']]\r\n    m3 -> [None, ['w1', 'w3']]\r\n   \r\n  unmatched men = {'m3'} \r\n\r\n  m3 proposes to w1 who is not matched, ergo accepts the proposal\r\n\r\n  algorithm concluded: the final matches = {('m1', 'w2'), ('m3', 'w1'), ('m2', 'w3')}</pre></b>\r\n\r\nThe resulting matches form stable marriages (the ones discussed above, when we\r\n  discussed the meaning of stability).\r\nWhen this algorithm stops, the local copy of the men's data structure has\r\n  become\r\n<b><pre>  m1 -> ['w2', ['w1']]\r\n  m2 -> ['w3', ['w1', 'w2']]\r\n  m3 -> ['w1', ['w3']]</pre></b>\r\n<p>\r\nNote that each man's preference list shows only the women he did not propose to.\r\nFinally, if we used the same algorithm but let the women propose to the men,\r\n  who accept of reject the proposals, we would get the following matches.\r\n<b><pre>algorithm concluded: the final matches = {('w2', 'm2'), ('w1', 'm1'), ('w3', 'm3')}</pre></b>\r\n<p>\r\nThese matches are all different, but the marriages are all still stable.\r\nSo, who proposes to whom can determine the results of the algorithm: we can run\r\n  the program, swapping the men's/women's files, to see if it produces an\r\n  alternative stable matching.\r\n<p>\r\n\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_match_preferences</b> has an open (file) parameter; it returns the\r\n       dictionary representing each man (or women, depending on which file is\r\n       read) and his/her match (initially <b>None</b>) and preferences\r\n       (body is 6 lines).\r\n<p>\r\n<li><b>dict_as_str</b> has a men or women dictionary, key <b>function</b>\r\n      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as\r\n       parameters; it returns a multi-line string (each line is ended by\r\n       <b>'\\n'</b>), which when printed shows the contents of the\r\n       dictionary in the appropriate textual form.\r\n    The key function determines the ordering and the <b>bool</b> determines\r\n      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters\r\n      used for <b>sort</b>/<b>sorted</b> in Python.\r\n    This function is used to print both the men's/women's dictionaries, in the\r\n      form dicussed above in the <b>Input/Output</b> section.\r\n    <p>\r\n    <b>Important:</b> The key function (and its use when iterating over the\r\n      dictionary in <b>dict_as_str</b>) must assume that its argument is a\r\n      <b>key</b> in the dictionary, not an <b>item</b>;\r\n      otherwise the batch self-check test will fail even if your code works.\r\n     (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>who_prefer</b> has a list (of <b>str</b>) of preferences and two values\r\n       (<b>str</b>) that are in the list; it returns the value with the higher\r\n       preference: e.g., <b>who_prefer(['w3','w1','w2'], 'w2', 'w3')</b> returns\r\n       <b>w3</b> -the one present earlier in the list.\r\n    Hint: I used this function in <b>make_match</b> defined below\r\n    (body is 1 line).\r\n<p>\r\n<li><b>extract_matches</b> has a men dictionary as a parameter; it returns a\r\n       set of 2-tuples: each has a match with the man in index 0 and the woman\r\n       in index 1.\r\n    Hint: I used this function in <b>make_match</b> defined below\r\n       (body is 1 line).\r\n<p>\r\n<li><b>make_match</b> has a men and women dictionary as parameters, as well\r\n         as a tracing parameter whose default value is <b>False</b>; it returns\r\n         a set of 2-tuples: each has a match with the man in index 0 and the\r\n         woman in index 1.\r\n       This function uses the Gale/Shapley algorithm described above to\r\n         find the match; if tracing is <b>True</b> it creates a trace in the\r\n         form the example trace shown above\r\n       (body is 25 lines, but only 18 lines without tracing code).\r\n<p>\r\n<!--- don't include this\r\n<li><b>stable</b> has a men and women dictionary as parameters; it returns\r\n       whether (<b>bool</b>) the match is stable (defined above).\r\n       Hint: for all possible man/woman combinations, if you can find\r\n          one where the man prefers the woman to his match, and the woman\r\n          prefers the man to her match, the match is not stable; if you cannot\r\n          find an man/woman satisfying this criteria, the match is stable\r\n          (body is 6 lines).\r\n<p>\r\n<!--- include this\r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the\r\n    files storing the men and women preferences; reads these files and creates\r\n    the required dictionaries; labels and prints both\r\n    dictionaries (using <b>dict_as_str</b>); prompts the user about whether to\r\n    trace the matching, then computes (using <b>make_match</b>) and prints the\r\n    stable matches.\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<pre><b>  Select the file name encoding all mens preferences: <i>men0.txt</i>\r\n  Select the file name encoding all womens preferences: <i>women0.txt</i>\r\n\r\n  Men Preferences\r\n    m1 -> [None, ['w3', 'w2', 'w1']]\r\n    m2 -> [None, ['w3', 'w1', 'w2']]\r\n    m3 -> [None, ['w2', 'w1', 'w3']]\r\n\r\n  Women Preferences\r\n    w1 -> [None, ['m1', 'm2', 'm3']]\r\n    w2 -> [None, ['m2', 'm1', 'm3']]\r\n    w3 -> [None, ['m3', 'm2', 'm1']]\r\n\r\n  Select whether to trace the algorithm[True]: <i>False</i>\r\n\r\n  the final matches = {('m1', 'w2'), ('m3', 'w1'), ('m2', 'w3')}</b></pre>\r\n<p>\r\nNote that if the user specified <b>True</b> for tracing the algorithm, the\r\n  program would also print all the information shown above in the example of\r\n  tracing the Gale/Shapley algorithm.\r\nFinally, you can also try processing the <b>men1.txt/women1.txt</b> and\r\n  <b>men2.txt/women2.txt</b> pairs of files.\r\nYou can print these data files and hand-simulate the Gale/Shapely algorithsm\r\n  on them to compute their stable matches.\r\nYou can also feed the women file in as the men file, and the men file in as\r\n  the women file, to see the match that results from letting women propose and\r\n  men accept or reject: it can produce different matching pairs, but the\r\n  matching pairs it produces will be stable.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem #2 Instant Runoff --->\r\n\r\n<a name=\"problem6\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #2: Instant Runoff Voting</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user to enter the name\r\n  of a file representing the preferences of a sequence of voters;\r\n  reads the file (storing its information in a dictionary);\r\n  prints the voter preferences/dictionary in a special form;\r\n  repeatedly displays the vote count for ballots (sorted both by candidate name\r\n  and by vote count), eliminating from the election the candidate(s) receiving\r\n  the fewest votes, until one candidate (the winner) remains or no candidates\r\n  remain (a tie among the candidates on the final ballot).\r\n<p>\r\nThis form of election is known as <b>instant runoff voting</b>.\r\nEvery voter submits preferences that rank all the candidates in the election,\r\n  from highest preference candidate (most favorite) to lowest preference\r\n  candidate (least favorite): we will use a <b>list</b> for this purpose</b>,\r\n  where \"earlier in the <b>list</b>\" means \"higher preference\".\r\nAll the candidates appear on the first ballot, so each voter votes for his\r\n  highest preference candidate.\r\nThen the candidate(s) with the fewest number of votes are removed from the\r\n  election: if more than one candidate receives the least number of votes, all\r\n  with that number are removed from the election.\r\n<p>\r\nDuring the second ballot, votes are allowed only for the\r\n  <b>remaining candidates</b>: there is at least 1 fewer candidate.\r\nIf a  voter's highest preference candidate has been removed from the election,\r\n  then his/her second ranked candidate should receive the vote; likewise, if\r\n  his/her second ranked candidate has been removed from the election, then\r\n  his/her third ranked candidate should receive the vote .... this process\r\n  continues until a voter voters for his/her highest preference candidate who\r\n  is still in the election.\r\n<p>\r\nThe number of votes cast in each ballot should always be the same as the number\r\n  of voters: each voter votes for his/her most preferred candidate <b>who is\r\n  still in the election</b>.\r\nThis ballot process continues until either 1 candidate remains, or 0 candidates\r\n  remain (meaning that all the remaining candidates tallied the same number\r\n  of votes, and all were removed, so the election is a tie among them).\r\n<p>\r\nRead these instructions carefully, a few times.\r\nDo some hand simulations to ensure you understand the algorithm.\r\nDo not attempt to write any Python code to solve this problem until you\r\n  understand this algorithm and can apply it to the data specified below.\r\nYou can discuss the algorithm with the class staff and each other; but, you\r\n  cannot discuss your code with other students.\r\n\r\n<h3>Input and Output:</h3>\r\nRead a file of voters and their ranking of the candidates (highest to lowest\r\n  preference), separated by semicolons, building a dictionary whose key is each\r\n  voter and whose associated value is a <b>list</b> of candidates ranked by\r\n  that voter (they appear in the file in order, from highest to lowest\r\n  preference).\r\nWe annotate this dictionary as <b>{str:[str]}</b>.\r\n<p>\r\nIn the file, the voter's name appears first, followed by the names of all the\r\n  candidates in the election in highest to lowest preference (names may be\r\n  entire words, not just single characters) separated by one semicolon\r\n  character.\r\nFor example, the input file <b>votepref1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other):\r\n<b><pre>  A;X;Y;Z\r\n  B;Y;Z;X\r\n  C;Y;Z;X\r\n  D;Z;X;Y\r\n  E;Z;X;Y</pre></b>\r\nThe first line means, voter <b>A</b> ranks candidate <b>X</b> first,\r\n  candidate <b>Y</b> second, and candidate <b>Z</b> third.\r\nThe second line means, voter <b>B</b> ranks candidate <b>Y</b> first,\r\n  candidate <b>Z</b> second, and candidate <b>X</b> third.\r\nEach line will have a unique voter and a permutation of all the \r\n  candidates in the election.\r\n<p>\r\nPrint each voter on a separate line, followed by his/her preferences.\r\nThat is, each line contains the voter and his/her complete ranking of the\r\n  candidates.\r\nFor example, the file above would print as:\r\n<b><pre>  Preferences: voter -> [candidates in order]\r\n     A -> ['X', 'Y', 'Z']\r\n     B -> ['Y', 'Z', 'X']\r\n     C -> ['Y', 'Z', 'X']\r\n     D -> ['Z', 'X', 'Y']\r\n     E -> ['Z', 'X', 'Y']</pre></b>\r\n<p>\r\nNote that the voter names must be <b>sorted</b> in alphabetical order;\r\n  the <b>list</b> of preferences must appear in the same order they appeared in\r\n  the file.\r\nThere are multiple data files for this program: <b>votepref1.txt</b>, \r\n  <b>votepref2.txt</b>, <b>votepref3.txt</b> and <b>votepref4.txt</b>;\r\n  test/debug your program on the first file; when you are done, test it on the\r\n  remaining files.\r\n<p>\r\n<b>Algorithm:</b>\r\nStart with a <b>set</b> of all the candidates.\r\nEvaluate the ballot to determine how many votes each candidate received.\r\nPrint this vote count two ways: sorted by name in alphabetical order and\r\n   sorted by votes in numerical order (in decreasing order).\r\nRemove the candidate(s) receiving the fewest votes, and repeat this process\r\n  until only one or no candidates remain.\r\nFinally, print the outcome of the election: a single candidate winner or a tie.\r\nAn example interaction (processing the preferences above) might be\r\n<b><pre>  Vote count on ballot #1: candidates (sorted alphabetically) using only candidates in set {'X', 'Y', 'Z'}\r\n    X -> 1\r\n    Y -> 2\r\n    Z -> 2\r\n\r\n  Vote count on ballot #1: candidates (sorted numerically) using only candidates in set {'Y', 'X', 'Z'}\r\n    Y -> 2\r\n    Z -> 2\r\n    X -> 1\r\n\r\n  Vote count on ballot #2: candidates (sorted alphabetically) using only candidates in set{'Y', 'Z'}\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Vote count on ballot #2: candidates (sorted numerically) using only candidates in set {'Y', 'Z'}\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Election winner is {'Y'}</pre></b>\r\nThe first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, \r\n  and <b>Z</b>.\r\nFor this ballot, the votes were counted and printed; candidate <b>X</b>\r\n  received the fewest number of votes so he/she is eliminated from the next\r\n  ballot.\r\nThe second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.\r\nFor this ballot: <b>A</b> votes for <b>Y</b>, who is his/her second highest\r\n  preference because <b>X</b>, his first highest preference, was removed from\r\n  the election; <b>B</b> through <b>E</b> vote for their highest preference\r\n  candidate, who all remain in the election.\r\nThese votes are counted and printed; candidate <b>Z</b> received the fewest\r\n  number of votes so is eliminated from the next ballot.\r\nThere is only one candidate remaining so <b>Y</b> is declared the winner.\r\nAn alternative outcome prints\r\n<b>Tie among final candidates: cannot choose one unique winner</b>.\r\n\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_voter_preferences</b> has an open (file) parameter; it returns the\r\n       dictionary representing each voter and his/her preferences\r\n      (body is 5 lines).\r\n<p>\r\n<li><b>dict_as_str</b> has a dictionary, key <b>function</b>\r\n      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as\r\n       parameters; it returns a multi-line string (each line is ended by\r\n       <b>'\\n'</b>), which when, which when printed shows the contents of the\r\n       dictionary in the appropriate textual form.\r\n    The key function determines the ordering and the <b>bool</b> determines\r\n      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters\r\n      used for <b>sort</b>/<b>sorted</b> in Python.\r\n    This function is used to print both the voter preference dictionary and\r\n      the vote count dictionary for each ballot.\r\n    <p>\r\n    <b>Important:</b> The key function (and its use when iterating over the\r\n      dictionary in <b>dict_as_str</b>) must assume that its argument is a\r\n      <b>key</b> in the dictionary, not an <b>item</b>;\r\n      otherwise the batch self-check test will fail even if your code works.\r\n     (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>evaluate_ballot</b> has a dictionary of voter preferences\r\n         (see <b>read_voter_preferences</b>) and a <b>set</b> of the remaining\r\n         candidates as parameters; it returns a dictionary whose keys are these\r\n         candidates and whose values are the number of votes they received on\r\n         this ballot, based on the description of the\r\n         <b>instant runnoff voting</b> algorithm.\r\n       Remember to count only one vote per voter, for his/her highest ranked\r\n         candidate who is still in the election; hint: I used a <b>break</b>\r\n         statement in one loop\r\n       (body is 7 lines).\r\n<p>\r\n<li><b>remaining_candidates</b> has a dictionary as a parameter whose keys are\r\n          candidates and whose values are the number of votes they received\r\n          (see <b>evaluate_ballot</b>); it returns a set containing all those\r\n          candidates remaining in the election (the one(s) receiving the\r\n          fewest number of votes are absent).\r\n       Note that if all the candidates receive the same number of votes, then\r\n         this function returns an empty <b>set</b>.\r\n       (body is 2 lines).\r\n<p>\r\n<li><b>run_election</b>  has an open (file) parameter; it returns a <b>set</b>\r\n        that is empty (signifying no winner for this election) or contains one\r\n        value (the winner of the election).\r\n      In the process of computing its result to return, it calls the functions\r\n        above and prints all the required information: see the\r\n        <b>Sample Interaction</b> below\r\n      (body is 13 lines).\r\n<p>\r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user for the\r\n    file describing the voter preferences and calls <b>run_election</b> to\r\n    do this task.\r\n</ul>\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<pre><b>  Enter the file name describing all the voter preferences: <i>votepref1.txt</i>\r\n\r\n  Preferences: voter -> [candidates in order]\r\n    A -> ['X', 'Y', 'Z']\r\n    B -> ['Y', 'Z', 'X']\r\n    C -> ['Y', 'Z', 'X']\r\n    D -> ['Z', 'X', 'Y']\r\n    E -> ['Z', 'X', 'Y']\r\n  \r\n  Vote count on ballot #1: candidates (sorted alphabetically) using only candidates in set {'Z', 'Y', 'X'}\r\n    X -> 1\r\n    Y -> 2\r\n    Z -> 2\r\n\r\n  Vote count on ballot #1: candidates (sorted numerically) using only candidates in set {'Y', 'X', 'Z'}\r\n    Y -> 2\r\n    Z -> 2\r\n    X -> 1\r\n\r\n  Vote count on ballot #2: candidates (sorted alphabetically) using only candidates in set {'Y', 'Z'}\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Vote count on ballot #2: candidates (sorted numerically) using only candidates in set {'Y', 'Z'}\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Election winner is {'Y'}</b></pre>\r\n<p>\r\nYou can also try processing the <b>votepref2.txt</b> file (which leads to\r\n  printing <b>Tie among final candidates: cannot choose one unique winner</b>),\r\n <b>votepref3.txt</b>, and <b>votepref4.txt</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 3 -->\r\n\r\n<a name=\"problem3\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #3: Finite Automata</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user for the name of a\r\n   file representing a finite automaton: indicating its <b>states</b> and\r\n       input-&gt;state <b>transitions</b>;\r\n   reads the information in the file (storing the finite automaton in a\r\n     dictionary);\r\n   prints the finite-automaton/dictionary in a special form;\r\n   prompts the user for the name of a file storing the start-state\r\n      and inputs to process (each line in the file contains this combination);\r\n   repeatedly processes these lines, computing the results of the finite\r\n      automaton on each input, and then prints the results.\r\nNote that a finite automaton is really a <b>program</b>; in this problem we are\r\n  reading a program from a file and then executing it (running the finite\r\n  automaton) on various inputs.\r\nSo, we are really writing a compiler/interpreter for a small programming\r\n  language.\r\n<p>\r\nA <b>finite  automaton</b> (FA) is an machine that is sometimes called a\r\n  Deterministic Finite Automaton (DFA; see the next problem for an NDFA: a\r\n  non-deterministic finite automaton).\r\nAn FA is described by its <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what\r\n  <b>state</b> in the FA that input leads to.\r\nWe can illustrate an FA as a graph with state labels in circles and edge labels\r\n  for transitions (see below).\r\n<p>\r\n\r\n<h3>Input and Output:</h3>\r\nRead a file that describes a FA: each line contains a state and an\r\n  arbitrary number of input-&gt;state <b>transitions</b>.\r\nBuild a dictionary such that each key is a <b>str</b> state and whose associated\r\n  value is another dictionary specifying all the transitions from that state:\r\n  this second dictionary has keys that are <b>str</b> inputs and associated\r\n  values are <b>str</b> states.\r\nThe first token on each line is the <b>str</b> state and the remaining tokens\r\n  (always coming in pairs) are <b>str</b> inputs and their resulting states.\r\nAll tokens (which can comprise any number of characters) are separated by one\r\n  semicolon character.\r\nWe annotate this dictionary as <b>{str:{str:str}}</b>.\r\n<p>\r\n\r\nFor example, the input file <b>faparity.txt</b> contains the following lines\r\n  (which could appear in this order, or any other and still specify the same\r\n  FA):\r\n<b><pre>  even;0;even;1;odd\r\n  odd;0;odd;1;even</pre></b>\r\nHere is a picture of the <b>parity</b> FA.\r\nIt graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)\r\n  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)\r\n  that always lead back to one of these two states.\r\n<p>\r\n\r\n<img src=\"images/parity.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>even</b> (meaning it has seen an even number of <b>1</b>\r\n  inputs so far) is a key in the main dictionary.\r\nIts value is a dictionary with two key/value pairs <b>0</b>-><b>even</b>\r\n  and <b>1</b>-><b>odd</b>.\r\nIt means that in the <b>even</b> state, if the input is a <b>0</b> the\r\n  FA stays in the <b>even</b> state; if the input is a <b>1</b> the\r\n  FA goes to the <b>odd</b> state.\r\nAnd similarly (the next line) means that for the <b>odd</b> state, if the input\r\n  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a\r\n  <b>1</b> the FA goes back to the <b>even</b> state.\r\nSo, seeing an input of <b>0</b> keeps the FA in the same state;\r\n  seeing an input of <b>1</b> flips the FA into the other state.\r\n<p>\r\n\r\nPrint the finite automaton, one state (and its transitions) per line;\r\n  the states are printed alphabetically and the transition dictionary\r\n  for each state is printed as a <b>list</b> of input/state items (tuples)\r\n  such that these are printed alphabetically by the inputs.\r\n<p>\r\nFor example, the file above would print as:\r\n<b><pre>  The Description of the file entered for this Finite Automaton\r\n    even transitions: [('0', 'even'), ('1', 'odd')]\r\n    odd transitions: [('0', 'odd'), ('1', 'even')]</pre></b>\r\n<p>\r\nNote that there are multiple data files for this program: <b>faparity.txt</b>\r\n  and <b>fadivisibleby3.txt</b>; test/debug your program on \r\n  the first file; when you are done, test it on the last file.\r\nDraw the FA represented by each for to ensure that your code correctly\r\n  prints and computes with it.\r\n<b>Important:</b> This task is <b>not</b> to write a Python code that simulates\r\n  the Parity FA; it is to write code that simulates <b>any</b> FA, whose\r\n  description it reads from a file.\r\n<p>\r\nNext, repeatedly read and process lines from a second input file, computing the\r\n  results of the finite automaton running on the specified start-state with its\r\n  inputs; then print out the results in a special form.\r\nEach line in the file contains a start-state followed by a sequence of inputs\r\n  (all separated by semicolons).\r\nThe start-state will be a state in the FA (it is a key in the outer dictionary)\r\n  the inputs may specify legal or illegal transitions (may or may not be keys\r\n  in some inner dictonary).\r\n<p>\r\nFor example, the input file <b>fainputparity.txt</b> contains the following\r\n  three lines:\r\n<b><pre>  even;1;0;1;1;0;1\r\n  even;1;0;1;1;0;x\r\n  odd;1;0;1;1;0;1</pre></b>\r\nThe first line means, the start-state is <b>even</b> and the\r\n  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\nThe result of processing each line is to print the start-state, and then each\r\n  input and the new state it transitions to, and finally print the stop-state.\r\nFor the <b>parity</b> FA and the first line in this file, it should print\r\n<b><pre>Start state = even\r\n  Input = 1; new state = odd\r\n  Input = 0; new state = odd\r\n  Input = 1; new state = even\r\n  Input = 1; new state = odd\r\n  Input = 0; new state = odd\r\n  Input = 1; new state = even\r\nStop state = even</pre></b>\r\n<p>\r\nNote that the second line contains an input <b>x</b> which is not a legal input\r\n  allowed in any state; any such input should stop the simulation for that line\r\n  only, continuing to start a new simulation for all following lines (as\r\n  illustrated in the <b>Sample Interaction</b>).\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_fa</b> has an open (file) parameter; it returns the dictionary\r\n     representing the finite automaton; <b>hint</b>: I used splicing and the\r\n     <b>zip</b> function to build the inner dictionaries.\r\n     (body is 6 lines).\r\n<p>\r\n<li><b>fa_as_str</b> has a dictionary parameter (representing the FA); it\r\n    returns a multi-line string (each line is ended by <b>'\\n'</b>), which when\r\n    printed shows the contents of the FA in the appropriate textual form:\r\n    sorted alphabetically by state, with a state's transitions sorted by their\r\n    input value (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>process</b> has a dictionary parameter (representing the FA),\r\n    a <b>str</b> parameter (representing the start-state), and a <b>list</b>\r\n    parameter (representing a <b>list</b> of <b>str</b> inputs); it returns a\r\n    <b>list</b> that contains the start-state followed by <b>tuples</b> that\r\n    show the input and resulting state after each transition.\r\n    For the example shown above, <b>process</b> returns the following\r\n    <b>list</b>.\r\n<b><pre>['even', ('1', 'odd'), ('0', 'odd'), ('1', 'even'), ('1', 'odd'), ('0', 'odd'), ('1', 'even')]</pre></b>\r\n    Finally, if an input is illegal (is not the key in some transition for the\r\n    current state), say\r\n    <b>'x'</b>, for the parity FA, then <b>process</b> should terminate with\r\n    the last <b>tuple</b> in the <b>list</b> indicating a problem:\r\n     <b>('x', None)</b>\r\n   (body  is 9 lines).\r\n<p>\r\n<li><b>interpret</b> has a <b>list</b> parameter (the <b>list</b> result\r\n    produced by  <b>process</b>); it returns a multi-line string (each line is\r\n    ended by <b>'\\n'</b>), which when printed illustrates the results of\r\n    processing an FA on an input in the appropriate textual form.\r\n    See how it prints the example <b>list</b> argument shown above in the\r\n      output further above.\r\n    Also see the <b>Sample Interaction</b> below to see how it prints\r\n    <i>input errors</i>: see the middle example\r\n   (body is 9 lines).\r\n<p>\r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the\r\n    file describing the FA, prints it, prompts the user to enter the file\r\n    containing lines of start-states and input, simulates the FA on each line,\r\n    printing the results in the appropriate textual form\r\n    (body is 7 lines).\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<b><pre>  Enter the file name describing this Finite Automaton: <i>faparity.txt</i>\r\n\r\n  The Description of the file entered for this Finite Automaton \r\n    even transitions: [('0', 'even'), ('1', 'odd')]\r\n    odd transitions: [('0', 'odd'), ('1', 'even')]\r\n\r\n  Enter the file name describing a sequence of start-states and all their inputs: <i>fainputparity.txt</i>\r\n\r\n  Start tracing this FA in its start-state\r\n  Start state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n  Stop state = even\r\n  \r\n  Start tracing this FA in its start-state\r\n  Start state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = x; illegal input: simulation terminated\r\n  Stop state = None\r\n\r\n  Start tracing this FA in its start-state\r\n  Start state = odd\r\n    Input = 1; new state = even\r\n    Input = 0; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 0; new state = even\r\n    Input = 1; new state = odd\r\n  Stop state = odd</b></pre>\r\n<p>\r\nYou can also try the <b>fadivisibleby3.txt</b> finite automaton file, which\r\n  determines whether an integer (sequence of digits) is divisible by <b>3</b>:\r\n   it is divisible if the  finite automaton stops in state <b>rem0</b>.\r\nIt's input file <b>fainputdivisibleby3.txt</b> tries the number\r\n  <b>12,435,711</b>, which is divisible by <b>3</b> and number <b>823</b>,\r\n  which is not divisible by <b>3</b>: dividing <b>823</b> by <b>3</b> leaves a\r\n  remainder of <b>1</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 4 -->\r\n\r\n<a name=\"problem4\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #4: Non-Deterministic FA</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that solve, for a Non-Deterministic\r\n   Finite Automaton, the same problem that was solved for a Deterministic Finite\r\n   Automaton in Problem #3 (above).\r\nRead about the differences between these two automata (below).\r\nHint: Adapt your code for the FA problem to solve the more general NDFA problem.\r\n<p>\r\nA non-deterministic finite automaton (NDFA) is machine described by its\r\n  <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and a\r\n  <b>set</b> of <b>states</b> (more than one is allowed) that input can lead\r\n  to: <b>sets</b> with <b>more than one states</b> is what makes it\r\n  non-deterministic.\r\nWe can illustrate a NDFA as a graph with state labels in circles and edge\r\n  labels for transitions (see below).\r\nThe critical difference between an FA and an NDFA is that an NDFA can have\r\n  multiple edges with the same label going to different states (we'll see how\r\n  to represent and simulate such transitions below).\r\n<p>\r\n\r\n<h3>Input and Output:</h3>\r\nRead a file that describes a NDFA: each line contains a state and an\r\n  arbitrary number of input-&gt;state <b>transitions</b>.\r\nBuild a dictionary such that each key is a <b>str</b> state and whose associated\r\n   value is another dictionary specifying all the transitions from that state:\r\n   this second dictionary has keys that are <b>str</b> inputs and associated\r\n   values that are <b>sets</b> of <b>str</b> states: all the states a particular\r\n   input can lead to.\r\nThe first token on each line is the <b>str</b> state and the remaining tokens\r\n  (always coming in pairs) are <b>str</b> inputs and states.\r\nAll tokens (which can comprise any number of characters) are separated by one\r\n  semicolon character.\r\nWe annotate this dictionary as <b>{str:{str:{str}}}</b>.\r\n<p>\r\n\r\nFor example, the input file <b>ndfaendin01.txt</b> contains the following lines\r\n  (which could appear in this order, or any other and still specify the same\r\n  NDFA):\r\n<b><pre>  start;0;start;1;start;0;near\r\n  near;1;end\r\n  end</pre></b>\r\nHere is a picture of the <b>endin01</b> NDFA.\r\nIt graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,\r\n  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>\r\n  and <b>1</b>).\r\n<p>\r\n\r\n<img src=\"images/endin01.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>start</b> is a key in the main dictionary.\r\nIt's value is a dictionary with two key/value pairs: <b>0</b> mapping to the\r\n  <b>set</b> containing <b>start</b> and <b>near</b>, and <b>1</b> mapping to\r\n  the <b>set</b> containing just <b>start</b>.\r\nIt means that in the <b>start</b> state, if the input is a <b>0</b> the\r\n  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>\r\n  state; if the input is a <b>1</b> the NDFA must stay in the <b>start</b>\r\n  state.\r\nAnd similarly the next line means that in the <b>near</b> state, if the\r\n  input is a <b>1</b> the NDFA must go into the <b>end</b> state.\r\nThe last line means that the <b>end</b> state has no transitions out of it.\r\n<p>\r\n\r\nPrint the NDFA, one state (and its transitions) per line;\r\n  the states are printed alphabetically and the transition dictionary\r\n  for each state is printed as a <b>list</b> of input/set of state items\r\n  (2-tuples) such that these are printed alphabetically by the inputs,\r\n  and the set of states for each input is printed as an alphabetically sorted\r\n  list (e.g., <b>near</b> comes before <b>start</b>).\r\nNote that the state <b>end</b> is a key in the main dictionary, whose\r\n  associated transitions are an empty dictionary.\r\n<p>\r\n\r\nFor example, the file above would produce:\r\n<b><pre>  The Description of the file entered for this Non-Deterministic Finite Automaton \r\n    end transitions: []\r\n    near transitions: [('1', ['end'])]\r\n    start transitions: [('0', ['near', 'start']), ('1', ['start'])]</pre></b>\r\n<p>\r\nNote that there are multiple data files for this program: <b>ndfaendin01.txt</b>\r\n  and <b>ndfatrain.txt</b> and <b>ndfare.txt</b>;; test/debug your program on \r\n  the first file; when you are done, test it on the last file.\r\nDraw the FA represented by each for to ensure that your code correctly\r\n  prints and computes with it.\r\n<p>\r\nNext, repeatedly read and process lines from a second input file, computing the\r\n  results of the non-determinisitc finite automaton on the specified\r\n  start-state with its inputs ; then print out the results in a special form.\r\nEach line in the file contains a start-state followed by a sequence of inputs\r\n  (all separated by semicolons).\r\nThe start-state will be a state in the FA (it is a key in the outer dictionary)\r\n  the inputs may specify legal or illegal transitions (may or may not be keys\r\n  in some inner dictionary).\r\n<p>\r\nFor example, the input file <b>ndfainputendin01.txt</b> contains the following\r\n  two lines:\r\n<b><pre>  start;1;0;1;1;0;1\r\n  start;1;0;1;1;0;0</pre></b>\r\nFor example, the first line means, the start-state is <b>start</b> and the\r\n  inputs <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\nThe result of processing each line is to print the start-state, and then each\r\n  input and the new states (plural) it could transition to (the <b>could</b>\r\n  is what makes it non-deterministic), and finally print the stop-states.\r\nFor the <b>ndfaendin01</b> NDFA and the first line in this file, it should print\r\n<b><pre>  Start state = start\r\n    Input = 1; new possible states = ['start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n    Input = 1; new possible states = ['end', 'start']\r\n    Input = 1; new possible states = ['start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n    Input = 1; new possible states = ['end', 'start']\r\n  Stop state(s) = ['end', 'start']</pre></b>\r\n<p>\r\nNote that the <b>set</b> of states it might be in are printed as an alphabetized\r\n  <b>list</b>.\r\nAlso note especially that in the <b>start</b> state, if the input is a <b>0</b>,\r\n  then the NDFA can either remain in the <b>start</b> state or go into the\r\n  <b>near</b> state.\r\nFor this program, we keep track of all states that the NDFA <b>can</b> be in,\r\n  using a <b>set</b> of <b>new possible states</b>.\r\nFor the next input, <b>1</b>, we can be either in the <b>start</b> state\r\n  (from the <b>start</b> state; an input of <b>1</b> allows us to stay in the\r\n  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state; an\r\n  input of <b>1</b> allows us to transition to the <b>end</b> state).\r\nThus, we keep track of the <b>set</b> of states the NDFA can be in, and the\r\n  new <b>set</b> of states the NDFA can be in after processing the next input.\r\nIn this example, because <b>'end'</b> is included in the stop-states, this\r\n  input does end in <b>01</b>.\r\n<p>\r\nFor any state that does not have a transition specifying the current input,\r\n  ignore that input for that state.\r\nFor example, if <b>near</b> is one of the possible states and <b>0</b> is the\r\n  input, ignore the <b>0</b> for the <b>near</b> state.\r\n<p>\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_ndfa</b> has an open (file) parameter; it returns the dictionary\r\n     representing the non-deterministic finite automaton; <b>hint</b>: I used\r\n     splicing and the <b>zip</b> function to build the inner dinctionaries, and\r\n     I called the <b>setdefault</b> function for the inner <b>dict</b>:\r\n     alternatively I could have built it as <b>defaultdict</b>s from the\r\n     standard  <b>collections</b> module\r\n     (body is 9 lines).\r\n<p>\r\n<li><b>ndfa_as_str</b> has a dictionary parameter (representing the FA); it\r\n    returns a multi-line string (each line is ended by <b>'\\n'</b>), which when\r\n    printed shows the contents of the NDFA in the appropriate textual form:\r\n    sorted alphabetically by state, with a state's transitions sorted by their\r\n    input values, and sorted by states if an input results in multiple states\r\n    (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>process</b> has a dictionary parameter (representing the NDFA),\r\n    a <b>str</b> parameter (representing the start-state), and a <b>list</b>\r\n    parameter (representing a <b>list</b> of <b>str</b> inputs); it returns a\r\n    <b>list</b> that contains the start-state followed by <b>tuples</b> that\r\n    show the input and resulting <b>set</b> of  states after each transition.\r\n    For the example shown above, <b>process</b> returns the following\r\n    <b>list</b>.\r\n<p>\r\n<b><pre>  ['start', ('1', {'start'}), ('0', {'near', 'start'}), ('1', {'end', 'start'}), ('1', {'start'}),\r\n    ('0', {'near', 'start'}), ('1', {'end', 'start'})]</pre></b>\r\n    Finally, remember that if an input is illegal for the current state (is not\r\n      the key  in some transition for the current state), just ignore it.\r\n    But if the input leads to no possible states (the empty set of states)\r\n      terminate processing there\r\n    (body is 12 lines).\r\n<p>\r\n<li><b>interpret</b> has a <b>list</b> parameter (the <b>list</b> result \r\n    produced by <b>process</b>);  it returns a multi-line string (each line is\r\n    ended by <b>'\\n'</b>), which when printed illustrates the results of\r\n    processing an NDFA on an input in the appropriate textual form.\r\n    Note that in this output the <b>sets</b> computed in <b>process</b> appear\r\n      as <b>lists</b> sorted alphabetically by state.\r\n    See how it prints the example <b>list</b> argument shown above in the\r\n       <b>Sample Interaction</b> below\r\n    (body is 5 lines).\r\n<p>    \r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the\r\n    file describing the NDFA, prints it, prompts the user to enter the file\r\n    containing lines of start-states and input, and simulates the NDFA on each \r\n    line, printing  the results in the appropriate textual form\r\n    (body is 7 lines).\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one.\r\n<b><pre>  Enter the file name describing this Non-Deterministic Finite Automaton: <i>ndfaendin01.txt</i>\r\n\r\n  The Description of the file entered for this Non-Deterministic Finite Automaton\r\n    end transitions: []\r\n    near transitions: [('1', ['end'])]\r\n    start transitions: [('0', ['near', 'start']), ('1', ['start'])]\r\n\r\n  Enter the file name describing a sequence of start-states and all their inputs: <i>ndfainputendin01.txt</i>\r\n\r\n  Start tracing this NDFA in its start-state\r\n  Start state = start\r\n    Input = 1; new possible states = ['start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n    Input = 1; new possible states = ['end', 'start']\r\n    Input = 1; new possible states = ['start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n    Input = 1; new possible states = ['end', 'start']\r\n  Stop state(s) = ['end', 'start']\r\n  \r\n  Start tracing this NDFA in its start-state\r\n  Start state = start\r\n    Input = 1; new possible states = ['start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n    Input = 1; new possible states = ['end', 'start']\r\n    Input = 1; new possible states = ['start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n    Input = 0; new possible states = ['near', 'start']\r\n  Stop state(s) = ['near', 'start']</pre></b>\r\n<p>\r\nIn Week #2 of this course we will cover EBNF and regular expressions, which\r\n  relate to the files below.\r\nYou can run these files on your code to ensure they produce the correct results.\r\n<p>\r\nThe <b>ndfatrain.txt</b> file is a non-deterministic finite automaton\r\n  that determines whether or not a train (a sequence of characters representing\r\n  different kinds of cars) is a legal train according to Chapter Exercise #7\r\n  in the ENBF lecture.\r\nIts input file is <b>ndfainputtrain.txt</b>, which starts with a legal train\r\n  (one that ends with the state <b>done</b> as one possible state) followed by\r\n  an illegal train (one that does not end with the state <b>done</b> as one\r\n  possible state).\r\n<p>\r\nThe <b>ndfare.txt</b> file is a non-deterministic finite automaton translation\r\n  of the regular expression <b>((a*|b)cd)+</b>. \r\nIts input file is <b>ndfainputre.txt</b>, which starts with a match (one that\r\n  ends with the state <b>last</b> as one possible state) followed by a non-match\r\n   (one that does not end with the state <b>last</b> as one possible state).\r\n</td>\r\n</tbody>\r\n</table>\r\n  \r\n\r\n\r\n<!-- Problem #5 Google\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #5: Google Queries</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user to enter the\r\n  name of a file of text that contains a sequence of Google queries;\r\n  reads the file (storing it in two special <b>prefix</b> and <b>query</b>\r\n    dictionaries);\r\n  repeatedly: prints the dictionaries in a special form; prompts the user to\r\n    enter a query prefix, displays the top three queries with that prefix;\r\n  prompts the user to enter a new full query, and then updates the dictionaries\r\n    as if this new full query had appeared at the end of the file initially\r\n    read.\r\n<p>\r\n<h3>Background:</h3>\r\nWhen we type a word (or a few words) into Google's query box, it shows some of\r\n  the most frequently entered queries starting with those word(s).\r\nFor example, when I recently typed the word <b>uci</b> into Google, it showed\r\n  the following as the 3 most frequent queries starting with <b>uci</b>:\r\n<ul>\r\n<li><b>uci law</b>\r\n<li><b>uci medical center</b>\r\n<li><b>uci women's soccer</b>\r\n</ul>\r\nI could have clicked on one of these queries to select it, or continued typing\r\n  more words to specify my own (different) query.\r\n<p>\r\nHere we say <b>uci</b> is a <b>prefix</b>, which is the beginning of some\r\n  <b>full query</b>, like <b>uci medical center</b>.\r\n<p>\r\nGoogle represents a <b>full query</b> as a <b>tuple</b> of <b>str</b> (words).\r\nFor example, <b>('uci', 'medical', 'center')</b> is a <b>full query</b>.\r\nGoogle also represents a <b>prefix</b> as a <b>tuple</b> of <b>str</b> (words).\r\nFor example, <b>('uci',)</b> is a one-word <b>prefix</b> and\r\n  <b>('uci', 'medical')</b> is a two-word <b>prefix</b> of this\r\n  <b>full query</b>.\r\n<p>\r\nFrom any <b>full query</b> we can compute a <b>set</b> of all its\r\n  <b>prefix</b>es.\r\nFor example, the <b>full query</b> <b>('uci', 'medical', 'center')</b> would\r\n  compute the <b>prefix set</b>\r\n  <b>{('uci',), ('uci', 'medical'), ('uci', 'medical', 'center')}</b>.\r\nThe <b>prefix set</b> includes a <b>tuple</b> of the first word, \r\n  a <b>tuple</b> of the first two words, ...\r\n  and finally a <b>tuple</b> of all the words in the <b>full query</b>.\r\n<p>\r\nGoogle stores information (in dictionaries) that allows it to predict the most\r\n  likely <b>full query</b> from any <b>prefix</b> the user enters in the\r\n  Google search box (as discussed in the example above).\r\nThe prediction is based on (1) knowing all the <b>full queries</b> for a\r\n  <b>prefix</b> and (2) knowing how many times each <b>full query</b> was\r\n  used.\r\nUsing this information, Google can show the user the most frequently\r\n  entered <b>full queries</b> for the <b>prefix</b> he/she typed.\r\n<p>\r\nGoogle stores two dictionaries to accomplish this task.\r\nRecall that dictionary keys and <b>set</b> values must be immutable types:\r\n  <b>tuple</b>s are immutable (as are strings and integers) but not\r\n  <b>list</b>s.\r\n<ol>\r\n<li>Google stores a <b>prefix</b> dictionary whose <b>key</b> is a\r\n  <b>prefix</b> (a <b>tuple</b>) and whose <b>associated value</b> is a\r\n  <b>set</b> of all the <b>full queries</b> that have been entered for that\r\n  <b>prefix</b>.\r\n<p>\r\n<li>Google stores a <b>query</b> dictionary whose <b>key</b> is a\r\n  <b>full query</b> (again a <b>tuple</b>) and whose <b>associated value</b>\r\n  is an <b>int</b>: the number of times (the frequency) that that \r\n  <b>full query</b> was used.\r\n</ol>\r\n<b>IMPORTANT:</b>\r\nUse a <b>defaultdict</b> to store both of these dictionaries.\r\n<p>\r\nIn this program you will build these dictionaries and then use them it to\r\n  predict a <b>full query</b> from a <b>prefix</b> entered by the user, and\r\n  update the dictionaries for any new query.\r\n<p>\r\n<h3>Input and Output:</h3>\r\nAfter prompting the user for the file of full queries, read the file, building\r\n  the <b>prefix</b> and <b>query</b> dictionaries (we are dropping the word\r\n  <b>full</b> now).\r\n<p>\r\nFor a simple example, the file <b>googleq0.txt</b> contains the following\r\n  lines (in it, for simplicity and conciseness, we abbreviated\r\n  b = basketball, c = center, l = law, m = medical, s = soccer,  u = uci, and\r\n  w = women's).\r\n<b><pre>  u m c\r\n  u l\r\n  u w s\r\n  u l\r\n  u w s\r\n  u w b\r\n  u w b\r\n  u w b</pre></b>\r\n<p>\r\nThe program will first read this file and build the appropriate <b>prefix</b>\r\n  and <b>query</b> dictionaries; then it will print each dictionary.\r\nThe <b>prefix</b> dictionary should be sorted by keys, from the shortest to\r\n  longest prefix, with equal-length prefixes sorted in standard lexical order;\r\n  of course the associated sets may print their values in any order.\r\nThe <b>query</b> dictionary should be sorted by associated values (integers),\r\n  from largest to smallest integer, with equal integers sorted by their keys in\r\n  standard lexical order.\r\n<p>\r\nFor example, the file above would produce the following output:\r\n<b><pre>  Prefix dictionary:\r\n    ('u',) -> {('u', 'm', 'c'), ('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's')}\r\n    ('u', 'l') -> {('u', 'l')}\r\n    ('u', 'm') -> {('u', 'm', 'c')}\r\n    ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}\r\n    ('u', 'm', 'c') -> {('u', 'm', 'c')}\r\n    ('u', 'w', 'b') -> {('u', 'w', 'b')}\r\n    ('u', 'w', 's') -> {('u', 'w', 's')}\r\n\r\n  Query dictionary:\r\n    ('u', 'w', 'b') -> 3\r\n    ('u', 'l') -> 2\r\n    ('u', 'w', 's') -> 2\r\n    ('u', 'm', 'c') -> 1</pre></b>\r\n<p>\r\nIn the <b>prefix</b> dictionary <b>('u',)</b> appears before <b>('u', 'l')</b>\r\n  because it has fewer words; and <b>('u', 'l')</b> appears before\r\n  <b>('u', 'w')</b> because in standard lexical order, when 2-tuples have equal\r\n  first values, they are ordered by their second values, and <b>'l'</b> comes\r\n  before <b>'w'</b>.\r\n<p>\r\nIn the <b>query</b> dictionary <b>('u', 'w', 'b')</b> appears before\r\n  <b>('u', 'l')</b> because the first tuple's associated value (<b>3</b>) is\r\n  bigger than the second tuple's (<b>2</b>); and <b>('u', 'l')</b> appears\r\n  before <b>('u', 'w', 's')</b> because when tuples are associated with equal\r\n  values (<b>2</b>), they are ordered lexically, and <b>('u', 'l', ...)</b>\r\n  comes before  <b>('u', 'w', ...)</b> (see the reasoning above).\r\n<p>\r\nNow, repeatedly prompt the user for any query prefix and print the top three\r\n  full queries for the entered prefix: print them in order from most to least\r\n  frequent full query (with ties printed using the standard lexical ordering;\r\n  the same ordering used when printing the Query dictionary above).\r\nUsing the dictionaries above the iteraction would be.\r\n<p>\r\n<pre><b>  Specify the prefix sequence (or just quit): u\r\n    Up to 3 (best) matching full queries = [('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')]</b></pre>\r\nFinally, prompt the user to enter the full query, and update the dictionaries\r\n  and reprint them.\r\n<pre><b>  Specify the full query sequence (or just enter quit): u w s\r\n\r\n  Prefix dictionary:\r\n    ('u',) -> {('u', 'm', 'c'), ('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')}\r\n    ('u', 'l') -> {('u', 'l')}\r\n    ('u', 'm') -> {('u', 'm', 'c')}\r\n    ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}\r\n    ('u', 'm', 'c') -> {('u', 'm', 'c')}\r\n    ('u', 'w', 'b') -> {('u', 'w', 'b')}\r\n    ('u', 'w', 's') -> {('u', 'w', 's')}\r\n\r\n  Query dictionary:\r\n    ('u', 'w', 'b') -> 3\r\n    ('u', 'w', 's') -> 3\r\n    ('u', 'l') -> 2\r\n    ('u', 'm', 'c') -> 1</b></pre>\r\nHere, the prefix dictionary stays the same (the full query already was entered\r\n  once; we could have entered a new full query, which would augment the prefix\r\n  dictionary), and the full query <b>('u', 'w', 's')</b> has its query-count\r\n  increased from <b>2</b> to <b>3</b>.\r\n<p>\r\n\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>all_prefixes</b> has a <b>tuple</b> of <b>str</b>\r\n         (words) parameter; it returns a <b>set</b> of <b>tuple</b> of\r\n          <b>str</b>: all the <b>prefixes</b> of the <b>full query</b> argument.\r\n       For example, <b>all_prefixes(('a', 'b', 'c'))</b> returns\r\n         <b>{('a',), ('a', 'b'), ('a', 'b', 'c')}</b>.\r\n       <b>Hints:</b> comprehension and slicing\r\n       (body is 1 line).\r\n<p>\r\n<li><b>add_query</b> has a prefix dictionary, query dictionary, and new full\r\n         query (<b>tuple</b> of <b>str</b>) as parameters; it returns\r\n         <b>None</b> but updates these two dictionaries based on the new full\r\n         query.\r\n       It adds the new full query's prefixes to the prefix dictionary (each\r\n          associated with the new full query) and increments the integer value\r\n          associated with that full query in the query dictionary (or, if the\r\n          full query is not in the dictionary, associates that full query with\r\n          1) (body is 3 lines).\r\n<p>\r\n<li><b>read_queries</b> has an open (file) parameter; it returns a 2-tuple\r\n     containing the prefix and query dictionaries (in that order) built by\r\n     reading and processing each full query in this file.\r\n    (body is 5 lines).\r\n<p>\r\n<li><b>dict_as_str</b> has a dictionary, key <b>function</b>\r\n      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as\r\n       parameters; it returns a multi-line string (each line is ended by\r\n       <b>'\\n'</b>), which when printed shows the contents of the dictionary in\r\n       the appropriate textual form.\r\n    The key function determines the ordering and the <b>bool</b> determines\r\n      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters\r\n      used for the <b>sort</b>/<b>sorted</b> functions in Python.\r\n    This function is used to print both the prefix and query dictionaries.\r\n    <p>\r\n    <b>Important:</b> The key function (and its use when iterating over the\r\n      dictionary in <b>dict_as_str</b>) must assume that its argument is a\r\n      <b>key</b> in the dictionary, not an <b>item</b>;\r\n      otherwise the batch self-check test will fail even if your code works.\r\n     (body is 4 lines; can you do it in 1?).\r\n<p>\r\n<li><b>top_n</b> has a prefix (<b>tuple</b> of <b>str</b>), <b>int</b>, prefix\r\n        dictionary, and query dictionary as parameters; it returns a <b>list</b>\r\n        of full queries (<b>tuple</b> of <b>str</b>) whose length is the\r\n        integer parameter, containing the most frequent full queries with that\r\n         prefix; if the number of full queries with that prefix is less than\r\n         that integer parameter, return all the full queries.\r\n    If no full queries have this prefix, return the empty list.\r\n    Notes: The dictionaries should not be changed.\r\n           If multiple full queries occur the same number of times, prefer\r\n      the full queries that come earlier in the standard lexical ordering: e.g.,\r\n      the same order they are printed in the query dictionary.\r\n      (body is 3 lines; can you do it in 1?).\r\n<p>     \r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the\r\n    file storing the queries and builds the prefix and query dictionaries from\r\n    this file; then repeated: print these dictionaries; prompt the user to enter\r\n    a prefix; display the top three full queries with that prefix; prompt the\r\n    user to enter a full query; and finally update the prefix and query\r\n    dictionaries with that full query\r\n   (13 lines).\r\n</ul>\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match the form of this one (the order of values in the sets\r\n  may vary).\r\n<pre><b>Specify the file name storing the full query: <i>googleq0.txt</i>\r\n\r\nPrefix dictionary:\r\n  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}\r\n  ('u', 'l') -> {('u', 'l')}\r\n  ('u', 'm') -> {('u', 'm', 'c')}\r\n  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}\r\n  ('u', 'm', 'c') -> {('u', 'm', 'c')}\r\n  ('u', 'w', 'b') -> {('u', 'w', 'b')}\r\n  ('u', 'w', 's') -> {('u', 'w', 's')}\r\n\r\nQuery dictionary:\r\n  ('u', 'w', 'b') -> 3\r\n  ('u', 'l') -> 2\r\n  ('u', 'w', 's') -> 2\r\n  ('u', 'm', 'c') -> 1\r\n\r\nSpecify the prefix sequence (or just enter quit): <i>u</i>\r\n  Up to 3 (best) matching full queries = [('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')]\r\n\r\nSpecify the full query sequence (or just enter quit): <i>u w s</i>\r\n\r\nPrefix dictionary:\r\n  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}\r\n  ('u', 'l') -> {('u', 'l')}\r\n  ('u', 'm') -> {('u', 'm', 'c')}\r\n  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}\r\n  ('u', 'm', 'c') -> {('u', 'm', 'c')}\r\n  ('u', 'w', 'b') -> {('u', 'w', 'b')}\r\n  ('u', 'w', 's') -> {('u', 'w', 's')}\r\n\r\nQuery dictionary:\r\n  ('u', 'w', 'b') -> 3\r\n  ('u', 'w', 's') -> 3\r\n  ('u', 'l') -> 2\r\n  ('u', 'm', 'c') -> 1\r\n\r\nSpecify the prefix sequence (or just enter quit): <i>u w</i>\r\n  Up to 3 (best) matching full queries = [('u', 'w', 'b'), ('u', 'w', 's')]\r\n\r\nSpecify the full query sequence (or just enter quit): <i>a b c</i>\r\n\r\nPrefix dictionary:\r\n  ('a',) -> {('a', 'b', 'c')}\r\n  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}\r\n  ('a', 'b') -> {('a', 'b', 'c')}\r\n  ('u', 'l') -> {('u', 'l')}\r\n  ('u', 'm') -> {('u', 'm', 'c')}\r\n  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}\r\n  ('a', 'b', 'c') -> {('a', 'b', 'c')}\r\n  ('u', 'm', 'c') -> {('u', 'm', 'c')}\r\n  ('u', 'w', 'b') -> {('u', 'w', 'b')}\r\n  ('u', 'w', 's') -> {('u', 'w', 's')}\r\n\r\nQuery dictionary:\r\n  ('u', 'w', 'b') -> 3\r\n  ('u', 'w', 's') -> 3\r\n  ('u', 'l') -> 2\r\n  ('a', 'b', 'c') -> 1\r\n  ('u', 'm', 'c') -> 1\r\n\r\nSpecify the prefix sequence (or just enter quit): <i>quit</i></b></pre>\r\n<p>\r\nYou can also try processing the <b>googleq1.txt</b> and <b>googleq2.txt</b>\r\n  files\r\n</td>\r\n</tbody>\r\n</table>\r\n-->\r\n\r\n\r\n<!-- Problem #5 Word Generator\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #5: Word Generator</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user to enter the\r\n    <b>order statistic</b> (a positive number) and the name of a file of text;\r\n  reads the file of text (storing it in a special <b>corpus</b> dictionary);\r\n  prints the dictionary in a special form;\r\n  prompts the user to enter the <b>order statistic</b> number of words, and the\r\n    number of words to generate, then print a <b>list</b> of that many words\r\n    randomly generated from the corpus.\r\n</ul>\r\nYour program will \"learn\" the word pattern of an author (based on some\r\n  \"order statistic\" and reading a large sample of the author's writing) and\r\n  then generate random text following the author's word patterns.\r\n<p>\r\n<h3>Input and Output:</h3>\r\nAfter prompting for the <b>order statistic</b>, read a file of words, building a\r\n  corpus dictionary storing data annotated as <b>{(str):[str]}</b>.\r\nHere the dictionary's keys are <b>tuple</b>s of <b>n</b> words (where <b>n</b>\r\n  is the <b>order statistic</b>) and each key's assocaited value is a\r\n  <b>list</b> of all the words in the text that somewhere follow these words:\r\n  e.g., if <b>n</b> were <b>2</b>, the dictionary would contain a key for every\r\n  pair of words appearing next to each other in the text, and each would have\r\n  an associated value that is a <b>list</b> of all the words following these two\r\n  (no matter where the pair occurs, with NO DUPLICATES allowed in the values\r\n  <b>list</b>).\r\n<p>\r\nAn easy way to read the words one at a time is to use the result returned by\r\n  the helper function <b>word_at_a_time</b> (which I have supplied at the top of\r\n   <b>wordgenerator.py</b>). \r\nWhen passed an <b>open</b> file to read from, this function returns an object\r\n  on which we can (a) call <b>next</b> and/or (b) iterate over, using a <b>for</b> loop.\r\nFor example, if a file named <b>f.txt</b> contained\r\n<b><pre>  a b c\r\n  d e</pre></b>\r\nthen executing the code\r\n<b><pre>  i = word_at_a_time(open('f.txt'))\r\n  print(next(i), next(i))  # print next (really first) two values in the file\r\n  for c in i:              # iterate over all remaining values in the file\r\n      print(c)             #   and print them</pre></b>\r\nwould print\r\n<b><pre>  a b\r\n  c\r\n  d\r\n  e</pre></b>\r\n<p>\r\nWe will learn when we examine iterators in depth that the <b>for</b> loop\r\n  implicitly calls <b>next</b> on the object (here <b>i</b>) that it is\r\n  iterating over.\r\nFor now, use this approach to read some number of words (based on the\r\n  <b>order statistic</b>), followed by reading all the other words.\r\n<p>\r\nWe can build the dictionary by \"prereading\" <b>n</b> words (by calling\r\n  <b>next</b> explicitly) into a <b>list</b> (assume that this is always\r\n  possible;\r\n  how might it not be?); then repeatedly read the next word and put it in as a\r\n  value associated with the <b>list</b> of pre-read words; then, drop the\r\n  \"oldest\" word at the beginning of the <b>list</b>, and add this next word\r\n  as the \"youngest\" at the end of the <b>list</b> (always keeping the list\r\n  length at <b>n</b>); repeating this process until all the words have been\r\n  read.\r\nRemember to convert this <b>list</b> of words to a <b>tuple</b> of words,\r\n  before using it as a key in the dictionary.\r\n<p>\r\nFor a simple example, the file <b>wginput1.txt</b> contains the following\r\n  lines (it could have all this information on one line or more lines):\r\n<b><pre>  a b c b a d c b a d\r\n  c a a b a a d</pre></b>\r\n  \r\n<p>\r\nPrint all the associations in the corpus dictionary, one per line in standard\r\n  lexical order; after printing all associations, print the length of the\r\n  smallest and largest <b>list</b> that is a value in the dictionary.\r\nEach line contains an <b>n</b> word <b>tuple</b>, followed by the <b>list</b>\r\n   of unique words (no duplicates) that follow them anywhere in the text.\r\nIn standard lexical order, the keys appear in order relative to the first word \r\n  in the <b>tuple</b>; for all first words that are the same, they appear in\r\n  order relative to the second word in the <b>tuple</b>; for all first and\r\n  second words that are the same, they appear in order relative to the thrid\r\n  word in the <b>tuple</b>; etc. (see the example below).\r\n<p>\r\nFor example, the file above would produce:\r\n<b><pre>  Corpus\r\n    ('a', 'a') can be followed by any of ['b', 'd']\r\n    ('a', 'b') can be followed by any of ['c', 'a']\r\n    ('a', 'd') can be followed by any of ['c']\r\n    ('b', 'a') can be followed by any of ['d', 'a']\r\n    ('b', 'c') can be followed by any of ['b']\r\n    ('c', 'a') can be followed by any of ['a']\r\n    ('c', 'b') can be followed by any of ['a']\r\n    ('d', 'c') can be followed by any of ['b', 'a']\r\n  max/min list lengths = 2/1</pre></b>\r\n<p>\r\nFor example, <b>('a','d')</b> appears three times in the text above, twice\r\n  followed by <b>'c'</b> and once followed by nothing (at the end of the file);\r\n  <b>('a','b')</b> appears twice in the file above, first followed by\r\n  <b>'c'</b> and second followed by <b>'a'</b>.\r\n<p>\r\n\r\nPrompt the user for the words to start with (there are <b>order statistic</b>\r\n  number of them) and the number of random words after that to generate.\r\nProduce such a <b>list</b> of words and print it. \r\n<p>\r\nA random 10 word <b>list</b>, after the words <b>a</b> and <b>d</b> might\r\n  print as\r\n<pre><b>    Random text = ['a', 'd', 'c', 'a', 'a', 'd', 'c', 'a', 'a', 'd', 'c', 'b']</b></pre>\r\nIn the result we start with <b>a d</b> (2 words specified by the user), we\r\n  know only <b>c</b> can come next; then using <b>d c</b> we know that\r\n  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...\r\n<p>\r\n\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>read_corpus</b> has an <b>order statistic</b> (<b>int</b>) parameter and\r\n     and open (file) parameter; it returns the dictionary representing the\r\n     corpus of words in a file\r\n    (body is 8 lines).\r\n<p>\r\n<li><b>corpus_as_str</b> has a dictionary parameter (representing the corpus);\r\n     it returns a multi-line string (each line is ended by <b>'\\n'</b>), which\r\n     when printed shows the contents of the corpus followed by the max/min\r\n     <b>list</b> lengths in the appropriate textual form\r\n     (body is 7 lines; can you do it in 4?).\r\n<p>\r\n<li><b>produce_text</b> has a dictionary parameter (representing the corpus),\r\n    a <b>list</b> parameter (representing the starting words), and an <b>int</b>\r\n    parameter (representing the number of additional words to generate);\r\n    it returns a <b>list</b> that contains the the starting words followed by\r\n    the generated words.\r\n    <p>\r\n    <b>Hints</b>: Let <b>n</b> be the <b>order statistic</b> of the dictionary.\r\n    Construct two <b>lists</b> (<b>[str]</b>), each initially storing these same\r\n      <b>n</b> starting words.\r\n    The first will always contain only the most recent <b>n</b> words (to be\r\n      coverted to a <b>tuple</b> and used as a key in the dictionary); the \r\n      second will  grow to contain all the generated words.\r\n    Generate a random next word from the dictionary by using the <b>choice</b>\r\n      function in the <b>random</b> module: e.g., <b>choice(['a','b','c'])</b>\r\n      will return a random value in the <b>list</b>, either <b>'a'</b>,\r\n      <b>'b'</b>, or <b>'c'</b>); add it to both <b>lists</b>; then, drop the\r\n      first word from the first <b>list</b>, so it remains a <b>list</b> of\r\n      length <b>n</b>; repeat until you have generated the required number of\r\n      words.\r\n    <p>\r\n    <b>Warning</b>: you might have to stop prematurely if you generate the last\r\n      <b>n</b> words in the text, and if these words occur nowhere else.\r\n    That is because in this case, there is no random word to generate following\r\n      them; in this case append a <b>None</b> to the end of the list of words\r\n      and  immediately return that list.\r\n    <p>\r\n    A slightly more elegant solution in Python uses only one list, copying the\r\n      last <b>order statistic</b> values of it into a tuple when needed for a\r\n      key to the dictionary.\r\n    Ensure that you do not mutate any of the parameters\r\n      (body is 8 lines).\r\n<p>     \r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user for (a) the\r\n    <b>order statistic</b> (rejecting non-positive values), (b) the file storing\r\n    the text, (c) <b>order statistic</b> words from the text, and (d) the\r\n    number of random words to generate (reject any negative values); it\r\n    calls these functions to solve the problem, and print the appropriate\r\n    information\r\n   (7 lines).\r\n</ul>\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match the form of this one (the actual random text my vary).\r\n<pre><b>  Select an order statistic: <i>2</i>\r\n  Select the file name to read: <i>wginput1.txt</i>\r\n  Corpus\r\n    ('a', 'a') can be followed by any of ['b', 'd']\r\n    ('a', 'b') can be followed by any of ['c', 'a']\r\n    ('a', 'd') can be followed by any of ['c']\r\n    ('b', 'a') can be followed by any of ['d', 'a']\r\n    ('b', 'c') can be followed by any of ['b']\r\n    ('c', 'a') can be followed by any of ['a']\r\n    ('c', 'b') can be followed by any of ['a']\r\n    ('d', 'c') can be followed by any of ['b', 'a']\r\n  max/min list lengths = 2/1\r\n  \r\n  Select 2 words for start of list\r\n  Select word 1: <i>a</i>\r\n  Select word 2: <i>d</i>\r\n  Choose # of words for appending to list: <i>10</i>\r\n  Random text = ['a', 'd', 'c', 'a', 'a', 'd', 'c', 'a', 'a', 'd', 'c', 'b']</b></pre>\r\n<p>\r\nYou can also try reading a much larger file included in this project\r\n  folder <b>wghuck.txt</b>, Mark Twain's, \"The Adventures of Huckleberry Finn\".\r\nI tried it with an order statistic of 3.\r\nThe corpus has over 90,000 entries; the biggest key triple had an\r\nassociated value with 46 unique words in it.\r\nThe key was <b>('out', 'of', 'the')</b> and its associated value was the list\r\n<pre><b>  ['window', 'face', 'woods', 'fourth', 'front', 'jacket', 'hole', 'canoe', 'middle',\r\n   \"ferryboat's\", 'cottonwood', \"captain's\", 'river', 'fog', 'range', 'presbyterian', 'tree',\r\n   'nest', 'wagon-troughs', 'reach', 'store', 'way', 'wigwam', 'ark', 'room', 'corner', 'grave',\r\n   'nonesuch', 'trouble', 'kitchen', 'old', 'first', 'hardest', 'nigger-patch', 'sugar-bowl',\r\n   'window-hole', 'brass', 'spoon', 'house', 'tooleries', 'bag', 'office', 'post-office', 'cabin',\r\n   'path', 'chains']</b></pre>\r\n<p>\r\nWith the appropriate modification, we can use this same program to\r\n  read/generate music or DNA sequences or any other data made from an\r\n  sequence of symbols.\r\n</td>\r\n</tbody>\r\n</table>\r\n -->\r\n\r\n<!-- Problem #5 Word Generator -->\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem #5: Synonym Finder</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\nWrite the required functions and script that prompts the user to enter the\r\n  the names of any number of text files; reads these text files (creating one\r\n  special <b>semantic</b> dictionary); optionally prints the dictionary in a\r\n  special form; prompts the user to enter the name of a file containing a\r\n  series of synonym problems (given a word, which of a series of words is its\r\n  best synonym); then uses the <b>semantic</b> dictionary to try to solve each\r\n  synonym problem, printing the results of each problem in a special form, and\r\n  finally printing the percentage of problems that it solved correctly.\r\n<p>\r\nThe program will read the text file(s) to <b>learn</b> which words are similar\r\n  to which others: each word in the <b>semantic</b> dictionary is associated\r\n  with a <b>context</b> dictionary storing the words that appear in the same\r\n  sentences (and how often they appear in the same sentences).\r\nThe program will use a <b>metric</b> function to determine how similar any two\r\n  words are by comparing their <b>context</b> dictionaries.\r\nBy this process, the program can determine whether two words are likely to be\r\n  synonyms.\r\n<p>\r\n<h3>Input and Output:</h3>\r\nAfter repeatedly prompting for the text file names (ensuring each one can be\r\n  read: try to <b>open</b> it), read each file, a sentence at a time, building\r\n  a <b>semantic</b> dictionary of the form <b>{str:{str:int}}</b>.\r\nThe outer keys of this dictionary are all the words in the text files; each\r\n  word is associated with an inner <b>context</b> dictionary whose keys are all\r\n  the words that appear in sentences with the outer word; each inner key is\r\n  associated with the number of times it appears in sentences with the outer\r\n  key.\r\nAll words in the sentences should be converted to lower-case letters and all\r\n  punctuation should be removed; certain common function words should also be\r\n  removed as \"noise words\".\r\n<p>\r\nAn easy way to read the files, one sentence at a time, is to iterate over the\r\n  result returned by calling the helper function <b>sentence_at_a_time</b>\r\n (which I have supplied at the top of <b>synonym.py</b>). \r\nWhen passed an <b>open</b> file to read from and a <b>set</b> of words to\r\n  ignore, this function returns an object that we can iterate over -one\r\n  sentence at a time- using a <b>for</b> loop.\r\nFor example, if a file named <b>trivial.txt</b> contained the text\r\n<b><pre>  I went to the gym this\r\n  morning. Later in the\r\n  morning I rested; I was tired!</pre></b>\r\nthen executing the code\r\n<b><pre>  for s in sentence_at_a_time(open('f.txt'), {'in','the','to'}):\r\n      print(s)</pre></b>\r\nwould print\r\n<b><pre>  ['i', 'went', 'gym', 'this', 'morning']\r\n  ['later', 'morning', 'i', 'rested']\r\n  ['i', 'was', 'tired']</pre></b>\r\n<p>\r\nNote that <b>sentence_at_a_time</b> will correctly return full sentences\r\n  (each as a <b>list</b> of words), whether they appear on one or multiple\r\n  lines.\r\nFor now, just assume that this function works correctly (you can certainly\r\n  experiment with it on small text files); later in the quarter we will\r\n  be able to understand its body: when we learn about regular expressions\r\n  (in week 2) and implementing iterators with generator functions (in week 4).\r\n<p>\r\nPrint all the associations in the semantic dictionary, one per line in standard\r\n  lexical order (with the inner dictionaries also printed in standard lexical\r\n  order); after printing all associations, print the length of the smallest and\r\n  largest inner dictionaries, using the following form.\r\n<p>\r\nFor example, the file <b>trivial.txt</b> shown above (also using the file\r\n  <b>ignore_trivial.txt</b>, which contains the words <b>in</b>, <b>the</b>,\r\n  and <b>to</b>) would print as:\r\n<b><pre>  Semantic Dictionary\r\n    context for gym = i@1, morning@1, this@1, went@1\r\n    context for i = gym@1, later@1, morning@2, rested@1, this@1, tired@1, was@1, went@1\r\n    context for later = i@1, morning@1, rested@1\r\n    context for morning = gym@1, i@2, later@1, rested@1, this@1, went@1\r\n    context for rested = i@1, later@1, morning@1\r\n    context for this = gym@1, i@1, morning@1, went@1\r\n    context for tired = i@1, was@1\r\n    context for was = i@1, tired@1\r\n    context for went = gym@1, i@1, morning@1, this@1\r\n    min/max context lengths = 2/8</pre></b>\r\n<p>\r\nMost of the words in these sentences are unique, but the words <b>i</b>\r\n  and <b>morning</b> appeared in two sentences, so they have the largest\r\n  inner dictionaries: <b>morning</b> appears in <b>2</b> sentences with\r\n  <b>i</b>, so <b>i</b> also appears in <b>2</b> sentences with <b>morning</b>.\r\nAlso note that the context for any word will not contain that same word.\r\n<p>\r\nRead a file that contains a series of synonym problems (one per line) with each\r\n  line in the following form:\r\n<ul>\r\n<li>A word\r\n<li>Any number of other words separated by spaces: the choices for its possible synonyms\r\n<li>The correct choice of the synonym\r\n</ul>\r\n<p>\r\nFor example, one line in this kind of input file might look like\r\n<b><pre>  draw walk eat paint paint</pre></b>\r\nindicating the problem is to find the synonym of <b>draw</b> from the choices\r\n  <b>walk</b>, <b>eat</b>, and <b>paint</b>, where the correct answer is\r\n  <b>paint</b>.\r\n<p>\r\nFor each line in the file of synonym problems, it will print that (a) it found\r\n  the correct synonym; (b) it failed to find the correct synonym, because it\r\n  chose incorrectly; or (c) it failed to find the correct synonym because the\r\n  <b>metric</b> function raised an exception on one of the possible synonyms.\r\nIn these cases it will display a message like one of the following (note that\r\n  here the strings appear in quotes; Hint: the <b>repr</b> function):\r\n<b><pre>\r\n  Correct: 'picture' is most like 'painting' from ['painting', 'chair']\r\n  Incorrect: 'duty' is most like 'task', not 'example' from ['task', 'example']\r\n  Metric failure: could not choose synonym for 'earnest' from ['serious', 'amusing']</pre></b>\r\n\r\n\r\n<h3>Functions and Script:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts for these function bodies not as requirements, but\r\n  to indicate the lengths of well-written Pythonic code.\r\n<ul>\r\n<li><b>build_semantic_dictionary</b> has a <b>list</b> of <b>open</b> files\r\n      parameter (the training file(s)), and an <b>open</b> file parameter\r\n     (words to ignore file); it returns a <b>semantic</b> dictionary\r\n     (<b>{str:{str:int}}</b>), in which each unignored word is associated with\r\n     a <b>context</b> dictionary whose keys are all the unignored words that\r\n     appear in the same sentences with it, and whose associated value is the\r\n     number of times each key appears in the same sentences as the word: in the\r\n     sentence <b>I really really like you.</b>, the <b>context</b> dictionary\r\n     for each word in this sentence will count  <b>really</b> twice.\r\n     Hints: Process each training file by reading it (using\r\n        <b>sentence_at_a_time</b>, which is passed a <b>set</b> of all\r\n        the words to be ignored: remember to <b>rstrip</b> them when reading\r\n        the file); process each word in a sentence by incrementing the count in\r\n         its <b>context</b> dictionary of every other word in the sentence.\r\n     Recall that a word that is a key in the <b>semantic</b> dictionary should\r\n       not be a key in its own <b>context</b> dictionary\r\n    (body is 9 lines containing four nested loops).\r\n<p>\r\n<li><b>dict_as_str</b> has a dictionary parameter (representing the\r\n     <b>semantic</b> dictionary); it returns a multi-line string (each line is\r\n     ended by <b>'\\n'</b>), which when printed shows the contents of the \r\n     <b>semantic</b> dictionary followed by the max/min <b>context</b>\r\n     dictionary lengths in the appropriate textual form shown above\r\n     (body is 5 lines).\r\n<p>\r\n<li><b>cosine_metric</b> has two <b>context</b> dictionaries as parameters; it\r\n  returns a <b>float</b> indicating how close are the context dictionaries\r\n  (a higher number is better).\r\n  Here is the formula for computing the <b>cosine_metric</b>\r\n  <p>\r\n  <img src=\"images/cosine_metric.jpg\"></img>\r\n  <p>\r\n  The formula will always have a value between <b>0</b> and <b>1</b>.\r\n  Note that if either <b>context</b> dictionary is empty, the denominator will\r\n    be <b>0</b> and Python will raise a <b>ZeroDivisionError</b> exception\r\n  <p>\r\n  For example, if <b>cd<sub>1</sub> = {'a':1, 'b':2, 'c':3}</b> and \r\n  <b>cd<sub>2</sub> = {'a':5, 'c':7, 'd':8}</b> then we would calculate the\r\n  <b>cosine_metric</b> as.\r\n  <p>\r\n  <img src=\"images/cosine_metric_calculation.jpg\"></img>\r\n  <p>\r\n  Hint: recall the <b>get</b> function on dictionaries can supply a default\r\n    value to return if the key is not in the dictionary.\r\n  <p>\r\n<p>\r\n<li><b>most similar</b> has a <b>str</b> parameter (the target word, to find the\r\n  synonym of), a <b>list</b> of <b>str</b> parameter (the synonym candidates), a\r\n  <b>semantic</b> dictionary parameter (of the <b>context</b> dictionaries for\r\n  words), and a metric function parameter (of which <b>cosine_metric</b> is one\r\n  example); it returns the synonym candidate whose metric is largest when\r\n  compared with the target word.\r\nThis function can raise an exception if any word has no associated\r\n  <b>context</b> dictionary in the <b>semantic</b> dictionary.\r\n<p>\r\n<li><b>similarity_test</b> has an open file parameter (the file of synonym\r\n  problems), a <b>semantic</b> dictionary parameter, and a metric function\r\n  parameter; it returns a descriptive <b>str</b> showing the results of all its\r\n  attempts to solve synonym problems (whose last line is the percentage of\r\n  problems it solved correctly).\r\nSee the three types of results illustrated in the section above\r\n  (body is 16 lines).\r\n<p>     \r\n<li>Write a script at the bottom of this module\r\n    (in <b>if __name__ == '__main__':</b>) that prompts the user for (a) the\r\n    names of the training files (the default answer should be <b>no-more</b>;\r\n    and unopenable files should be rejected) then builds the <b>semantic</b>\r\n    dictionary from these files (passing the opened <b>ignore_words.txt</b>\r\n    file as the second argument), (b) whether to print the <b>semantic</b>\r\n    dictionary, (c) the name of the synonym problem file (rejecting any\r\n    unopenable file - here use <b>goody.safe_open</b>) then attempts to solve\r\n    all these problems and prints all the results.\r\n</ul>\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match the form of this one (the actual random text my vary).\r\n<pre><b>  Enter name of text file for training (no-more to start processing)[no-more]: <i>bible.txt</i>\r\n  Enter name of text file for training (no-more to start processing)[no-more]: archie_comics.txt\r\n    file named archie_comics.txt rejected: cannot be opened\r\n  Enter name of text file for training (no-more to start processing)[no-more]: <i>war_and_peace.txt</i>\r\n  Enter name of text file for training (no-more to start processing)[no-more]: \r\n\r\n  Print Semantic dictionary?[False]: \r\n\r\n  Enter name of problem file[synonym-problems.txt]: <i>simple_problems.txt</i>\r\n    Correct: 'earnest' is most like 'serious' from ['serious', 'amusing']\r\n    Incorrect: 'picture' is most like 'painting', not 'table' from ['house', 'painting', 'table', 'chair']\r\n    Incorrect: 'vexed' is most like 'annoyed', not 'amused' from ['amused', 'annoyed']\r\n    Correct: 'watch' is most like 'see' from ['hear', 'see', 'smell']\r\n    Metric failure: could not choose synonym for 'thief' from ['banker', 'robber', 'postman']\r\n 40.0% correct</pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<!-- Extra Credit\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Extra Credit</b></td>\r\n<td width =\"80%\">\r\nWrite up all three answers in the file <b>extracredit.txt</b> and drop them off\r\n  on checkmate.\r\n<ol>\r\n<li>Specify a fa that is equivalent to the ndfa that finds inputs that end\r\n      in <b>01</b>.\r\n    It must identify some state that is stopped in only for input ending in 01\r\n    (the <b>end</b> state in the ndfa).\r\n<li>What is interesting about the results of the election using the\r\n      <b>votepref3.txt</b> input file?\r\n    How could we add another voter, such that his/her preferences allow X to\r\n      win on the first ballot?\r\n<li>In the word generator program we used a <b>dict</b> value that was a\r\n      <b>list</b> of words that was to contain no duplicates?\r\n    Why can't we just use a <b>set</b> (what would break in our code)?\r\n    If we wanted to use a set how could we modify the code to work correctly\r\n      (what is the smallest and/or fastest modification)?\r\n</td>\r\n</tbody>\r\n</table>\r\n--->\r\n</html>\r\n", "encoding": "ascii"}