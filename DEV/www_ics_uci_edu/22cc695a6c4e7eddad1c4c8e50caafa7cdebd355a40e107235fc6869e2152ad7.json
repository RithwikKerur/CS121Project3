{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/inheritanceiii.txt", "content": "\t\t\t\tInheritance III\r\n\r\nIn this lecture we will look at a few useful examples of inheritance,\r\nclassifying them into two categories: normal and mix-in inheritance. In normal\r\ninheritance, a large base class (typically with lots of data and method\r\nattributes) is specialized to perform a bit differently: it typically involves\r\na small derived class (defining few data and method attributes)\r\nsingle-inheriting from a large base class. Mix-in inheritance typically\r\ninvolves a derived class multiply-inheriting -to add many small special\r\nbehaviors to it- from a variety of small base classes.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nInheritance Summary:\r\n\r\n1) A derived class should be \"like\" its base class: all the base class methods\r\nshould be meaningful for it: either inherited by the derived class -like reset\r\nand value_of in Counter/Modular_Counter- or overridden by it -like __str__ and\r\ninc; the derived class can also define new methods that are meaningful only for\r\nthe derived class -like get_modulus. The relationship between the derived class\r\nclass and its base class is an \"IS-A\" relationship: we say a Modular_Counter IS-\r\nA Counter (it is-a specialized kind of counter); a defaultdict IS-A special kind\r\nof dict. We characterize other relationships (non-inheritance) among classes as\r\nHAS-A relations: For example, a FA (Finite Automata) class HAS-A attribute that\r\nstores the states and transitions; we WOULDN'T derive the FA class from the\r\ndict class: a FA is not a special kind of dict, but it has-a dict to represent\r\nits information.\r\n\r\n2) Inheritance in Python works by augmenting the FEOOP look-up rule for\r\nattributes: after checking for an attribute in the namespace (__dict__) of an\r\nobject, it is sequentially checked for in the namespaces of each class in the\r\n__mro__ tuple attribute (stored in the class from which the object was\r\nconstructed).  The first value in __mro__ is that class itself; the other\r\nvalues include any base classes that it was derived from, all the way back up\r\nthe inheritance hierarchy to the object class at its root (that will alway be\r\nthe last class in the __mro__). It is contstrained by looking at derived\r\nclasses before their base classes, and when deriving involves multiple base\r\nclasses, looking at the classes in the order they are specified in the derived\r\nclass.\r\n\r\n3) To call a method in the base class from the same method (the method that\r\noverrides it) in a derived class, use BaseClassName.method (e.g., we call\r\nCounter.inc(...) in the inc method defined in the Modular_Counter class). This\r\noften happens in the __init__ method too (see below).\r\n\r\n4) Typically the __init__ in the derived class calls the __init__ method of\r\nits base class (see the form above), passing along some of its arguments. This\r\nmeans that the parameter structure for the derived class is often longer than\r\nthe parameter structure the base class(es) it was derived from. By calling\r\n__init__ in the base class, it will setup all the attributes it needs to work\r\ncorrectly, when its methods are called (via inheritance, or directly in\r\noverridden methods: see 3 above).\r\n\r\n5) A derived class should not directly access the data attributes in any of its\r\nbase classes; instead (if the attribute needs to be examined or mutated) the\r\nbase class should provide methods to access/mutate it. E.g., the Counter class\r\nprovides the get_value method to access its _value attribute, and the reset/inc\r\nmethods to mutate its _value attribute in constrained ways. So Counter controls\r\n_value and Modular_Counter controls _modulus (which can be examined by the\r\nget_modulus method, but not mutated/changed).\r\n\r\n------------------------------\r\n\r\nNormal Inheritance Examples\r\n\r\npdefaultdict derived from the base-class dict:\r\n\r\nThe dict class implements a standard Python dictionary. It is a large class that\r\ndefines many methods. It uses many attrributes to store its dict, but we don't\r\ncare about these (since we will not access by name attributes defined in a base\r\nclass). In this example we will use it as a base class, deriving from it (using\r\nsingle-inheritance) the defaultdict class. Actually defaultdict is already\r\ndefined in the collections module, so here we will define the pdefaultdict\r\n(pseudo-defaultdict) class in the pcollection (pseudo-collections) module.\r\n\r\nA defaultdict IS-A special kind of a dict, so it is a good candidate to define\r\nvia normal inheritance. All operators/methods working on dicts make sense\r\nworking on defaultdicts; most work correctly purely by inheritance, but we must\r\noverride the meaning of the __init__ method (adding another parameter to\r\nrepresent a function it can call with no arguments to create a value for keys\r\nthat are accessed but not present) and override the meanings of the __repr__\r\n and __missing__ methods (which is called by __getitem__ in a dict when a key\r\nis not present).\r\n\r\nA defaultdict has only three behavioral differences from a dict:\r\n\r\n(1) Its __init__ method can/should be initialized with a special reference to a\r\nclass/function that is called (with no arguments) to store/return the associated\r\nvalue for any missing key.\r\n\r\n(2) Its __repr__ method returns a string with 'defaultdict' followed, in\r\nparentheses, by the special reference to a class/function passed to __init__\r\nfollowed by the key:value items in the dictionary.\r\n\r\n(3) When a key that is missing from the defaultdict is referred to, the key is\r\nautomatically added to the defaultdict, associated with the value returned by\r\ncalling (with no arguments) the special reference to a class/function passed to\r\n__init__. Note that the method __missing__ is already called in such\r\ncircumstances (in a normal dict, calling __missing__ raises a KeyError\r\nexception), so we will override this method in the derived/defaultdict class to\r\ninstead perform these actions.\r\n\r\nHere is a complete definition of pdefaultdict derived from dict.\r\n\r\nclass pdefaultdict(dict):\r\n    def __init__(self,default_factory=None,initial_dict=[],**kargs):\r\n        dict.__init__(self,initial_dict,**kargs) # call to initialize base-class\r\n        self._default_factory = default_factory  # used in overridden methods\r\n        \r\n    def __repr__(self):\r\n        return 'pdefaultdict('+str(self._default_factory)+','+dict.__repr__(self)+')'\r\n\r\n    # When accessing d[key] the inherited method __getitem__ is\r\n    #   called; if it finds key is not in the dictionary, it calls\r\n    #   self.__missing__(key), returns the result of executing this\r\n    #   method, which uses default_factory, if present, to create a\r\n    #   value associated with d[key] and return that value\r\n    def __missing__(self,key):\r\n        if self._default_factory == None:\r\n            dict.__missing__(self,key)       # same as: raise KeyError(str(key))\r\n        result    = self._default_factory()  # Call default, with no arguments\r\n        self[key] = result\t\t     # Store it in the pdefaultdict\r\n        return result\t\t\t     # Return a reference to it\r\n\r\nx = pdefaultdict(list)\r\nx['a'].append('x')\r\nprint(x)\r\n\r\nprints\r\n\r\npdefaultdict(<class 'list'>,{'a': ['x']})\r\n\r\n\r\nNotes:\r\n\r\n  (1) The standard dict.__init__ method has default-value parameters (a) an\r\n  iterable of items to pre-load the dictionary and (b) any number of item\r\n  parameters of the form key=value (collected in **kargs and added to the\r\n  dictionary after the pre-loaded items).\r\n\r\n  IMPORTANT: We don't have to know how dict.__init__ processes such data. We\r\n  do need to be aware of what arguments it expects/processes, and supply\r\n  parameters for these arguments to pdefaultdict.__init__, so its can pass them\r\n  along to dict.__init__ for real processing (just like init_value in Counter).\r\n\r\n  The pdefaultdict.__init__ method also has an extra default_factory\r\n  parameter: it uses its second two parameters to call dict.__init__ and then\r\n  also stores default_factory as an attribute the newly constructed pdefauldict\r\n  object, where it is used in the overridden methods __repr__ and __missing___.\r\n\r\n  (2) The pdefaultdict.__repr__ method returns the appropriate string, including\r\n  the name 'pdefaultdict', the special reference to a class/function to call\r\n  for missing keys, and the current contents of the dictionary . Of special\r\n  interest is that fact that there is an explicit call to dict.__repr__(self)\r\n  in this method, which overrides __repr__, to show the dict part of the\r\n  pdefaultdict.\r\n\r\n  (3) The pdefaultdict.__missing__ method supplies the main difference \r\n  between dicts and defaultdicts, by overriding the dict.__missing__ method\r\n  (which in dict always raises KeyError): here, so long as self.default_factory\r\n  is not None (meaning an argument has been supplied to this parameter in its\r\n  __init__), it is called to produce an initial value to associate with the\r\n  missing key.\r\n\r\n  (4) Any other operator/method applied to a pdefaultdict object executes the\r\n  corresponding method inherited from dict: there are very many of these\r\n  inherited (and not overridden) methods.\r\n\r\n----------\r\n\r\nLists indexes starting at 1:\r\n\r\nThe list class implements a standard Python list. It is a large class that\r\ndefines many methods. In this example we will use it as a base class, deriving\r\nthe class list1, which represents a list that we index starting at 1. Notice\r\nthat it inherits from list (so all the list functions like .append and .sort\r\nwork for list1) and overrides __getitem__ to call list's __getitem__ with a\r\nvalue one smaller. There are a few weird cases where list1 doesn't quite\r\nperform as expected, but for most it does.\r\n\r\nfrom goody import irange\r\n\r\nclass list1(list):\r\n    # Handle positive and negative indexes correctly\r\n    def __getitem__(self,index):\r\n        assert index!=0, 'list1.__getitem__: 0 index in origin-1 indexed list1'\r\n        return list.__getitem__(self, index-1 if index > 0 else index)\r\n\r\n    def __setitem__(self,index,value):\r\n        assert index!=0, 'list1.__setitem__: 0 index in origin-1 indexed list1'\r\n        list.__setitem__(self, index-1 if index > 0 else index, value)\r\n\r\n    def __delitem__(self,index):\r\n        assert index!=0, 'list1.__deltitem__: 0 index in origin-1 indexed list1'\r\n        list.__delitem__(self, index-1 if index > 0 else index)\r\n    \r\n    ... other methods too\r\n\r\nx = list1([1,2,3,4,5])\r\nprint(len(x),bool(x))\r\nfor i in irange(1,len(x)):\r\n    print(i,x[i]) \r\n    x.append('x')\r\nprint(x)\r\nx.reverse()\r\nprint(x)\r\nprint(2 in x) \r\n\r\nthis prints\r\n\r\n5 True\r\n1 1\r\n2 2\r\n3 3\r\n4 4\r\n5 5\r\n[1, 2, 3, 4, 5, 'x', 'x', 'x', 'x', 'x']\r\n['x', 'x', 'x', 'x', 'x', 5, 4, 3, 2, 1]\r\nTrue \r\n\r\n----------\r\n\r\nOptionMenuValue derived from the base-class OptionMenu (in tkinter)\r\n\r\nThe OptionMenu class is defined in the tkinter module. Constructing an\r\nOptionMenu widget in a Frame presents the user with a labeled menu, allowing\r\nthe user to see, select, and reselect a desired option, and discover what the\r\nstring value of the current selected option is.\r\n\r\nThe constructor for OptionMenu has an aribitrary number of arguments (see 3).\r\n(1) A parent Frame in which the widget is displayed\r\n\r\n(2) A StringVar into which the text of the selection is put.\r\n    When initially displayed, an OptionMenu will show this StingVar's value.\r\n    Clicking it exposes all the other options, which can be selected, replacing\r\n    the value in the StringVar. So StringVar is like a mutable string: its\r\n    contents can be changed.\r\n\r\n(3) Any number of strings which comprise the options for this option menu.\r\n\r\nBelow is a trivial demo tkinter application that illustrates how an OptionMenu\r\nis use, which also uses tkinter's StringVar, Entry, and Button widgets. It\r\ndisplays an OptionMenu (in column 1) and a Button and Entry (top and bottom in\r\ncolumn 2). The user can select an option from the OptionMenu. The 'Show Chosen\r\nOption' button places the selection into the Entry.\r\n\r\nRun this program a few times, repeatedly selecting options and pressing the\r\n'Show Chosen Option' button. Whenever this button is pushed, Python executes the\r\noption_to_entry function (that is the command associated with the button,\r\nwrapped in a parameterless lambda), which erases the information currently in\r\nthe Entry e and then puts the text from the StringVar o_var into this Entry.\r\nNote that if no option is chosen yet, the original text in o_var is put in the\r\nEntry.\r\n\r\nWhen pressing the button calls the lambda, its body calls option_to_entry with\r\nthe global names o_var (for the option) and e (for the entry). Using a lambda\r\nlike this one is common for commands in tkinter.\r\n\r\n-----\r\ncommands for widgets (and the partial evaluation alternative)\r\n\r\nThe command parameter in this button (and other widgets) must refer to a\r\nparameterless function object. Here we use a parameterless lambda that calls the\r\noption_to_entry function with the appropriate arguments. Another way to\r\naccomplish this goal is by using partial evaluation, to reduce the number of\r\narguments in the option_to_entry to 0. After importing partial from functools\r\nand defining option_to_entry, we could add one line and rewrite b = button(...)\r\ncode.\r\n\r\nbs_command = partial(option_to_entry,o_var,e)\r\nb = Button(main,text='Show Chosen Option',command = bs_command)\r\n\r\n-----\r\n\r\nfrom tkinter import *\r\n\r\nroot = Tk()\r\nroot.title('Widget Tester')\r\nmain = Frame(root)\r\nmain.pack(side=TOP,anchor=W)\r\n\r\no_var = StringVar()\r\no_var.set('Choose Option')\r\nom = OptionMenu(main, o_var, 'option1','option2','option3')\r\nom.grid(row=1,column=1)\r\nom.config(width = 10)\r\n\r\ne = Entry(main) \r\ne.grid(row=2,column=2)\r\n\r\ndef option_to_entry(option,entry):\r\n    entry.delete(0,END)\r\n    entry.insert(0,option.get())    \r\n\r\nb = Button(main,text='Show Chosen Option',command=lambda : option_to_entry(o_var,e))\r\nb.grid(row=1,column=2)\r\n\r\nroot.mainloop()\r\n\r\nThis is 18 non-blank lines of code.\r\n\r\nNotice that to control the OptionMenu we are required to bind two names: one\r\nfor the OptionMenu itself (om) and one to store the value of the chosen option\r\n(o_var). We will now derive a simple variant of the OptionMenu class, named\r\nOptionMenuValue, which keeps track of its own selection's value. In addition,\r\nwe will implement it so that it returns 'None' (rather than the initial value\r\nof o_var, which is the title for the OptionMenu) if the user has made no\r\nselection yet. Finally, a reset method allows us to reset what appears on the\r\noption menu to the string displayed there initially.\r\n\r\nAs with pdefaultdict/dict or list1/list, an OptionMenuValue is a slight variant\r\nof an OptionMenu, so it is a good candidate to define via inheritance. All\r\noperators/methods working on OptionMenu make sense working on OptionMenuValue:\r\nmost (e.g. grid and config, called in the code) work purely by inheritance, but\r\nwe must change the parameters of the __init__ method and add get/reset methods\r\nin the OptionMenuValue class. Note that there are hundreds of methods that we\r\ncan call on most GUI widgets like OptionMenu (for placement, size, etc.) which\r\nare all inherited by OptionMenuValue; we don't have to think about them, nor do\r\nwe have to think about the data attributes defined in OptionMenu, since we do\r\nnot refer to them directly.\r\n\r\nObserve how the OptionMenuValue class stores and uses its own StringVar, how get\r\nworks, and how the option_to_entry function now manipulates the object\r\nconstructed from the OptionMenuValue class directly.\r\n\r\nfrom tkinter import *\r\n\r\n# OptionMenuValue: with title and option_tuple\r\n# get is a pull function to get the option selected\r\nclass OptionMenuValue(OptionMenu):\r\n    def __init__(self,parent,title,*option_tuple,**configs):\r\n        self.result = StringVar()     # create a new StringVar to use for option\r\n        self.result.set(title)        # set it to the title\r\n        self.original_title = title   # remember original title in attribute\r\n\r\n        # initialize base class (which does most of the work) with self.result,\r\n        #   passing along the other arguments passed to this __init__\r\n        OptionMenu.__init__(self,parent,self.result,*option_tuple,**configs)\r\n\r\n    def reset(self):\r\n        self.result.set(self.original_title)\r\n        \r\n    def get(self):\r\n        value = self.result.get()\r\n        return value if value != self.original_title else 'None'\r\n\r\n\r\nroot = Tk()\r\nroot.title('Widget Tester')\r\nmain = Frame(root)\r\nmain.pack(side=TOP,anchor=W)\r\n\r\nom = OptionMenuValue(main, 'Choose Option', 'option1','option2','option3')\r\nom.grid(row=1,column=1)\r\nom.config(width = 10)\r\n\r\ne = Entry(main) \r\ne.grid(row=2,column=2)\r\n\r\ndef option_to_entry(option,entry):\r\n    entry.delete(0,END)\r\n    entry.insert(0,option.get())\r\n    \r\nb= Button(main,text='Show Chosen Option',command=lambda : option_to_entry(om,e))\r\nb.grid(row=1,column=2)\r\n\r\nb = Button(main,text='Reset Option',command=om.reset)\r\nb.grid(row=1,column=3)\r\n\r\nroot.mainloop()\r\n\r\nNot counting the class definition, this is 18 lines of code, but two are\r\nrequired to add the new 'Reset Option' button, so the equivalent code has\r\nshrunk from 18 to 16 lines. This reduction isn't tremendous, but most of the\r\ncode included does bookkeeping operations. Mostly what we have accomplished is\r\nestablishing one object that keepts track of the StringVar functionality inside\r\nthe OptionMenuValue object itself. If we had 10 OptionMenu GUI objects in our\r\noriginal program, we would need 10 StringVar objects too: now we can use just 10\r\nOptionMenuValue objects (and not have to remember which OptionMenu object goes\r\nwith which StringVar object).\r\n\r\n----------\r\n\r\nOptionMenuToEntry derived from the base-class OptionMenuValue\r\n\r\nWe will now derive a simple variant of OptionMenuValue named OptionMenuToEntry,\r\nwhich links to an Entry (see __init__) and updates this Entry automatically\r\nwhen a new selection is made (indicating it is a new -not yet \"gotten with get\"-\r\nselection with a green background). When the 'Show Chosen Option' button is\r\npressed, it shows the option in the Entry (actually, it is already there), but\r\nwith a white background. Finally, for this class, reset also puts an empty\r\nstring with a white background into the Entry.\r\n\r\nAs with OptionMenu/OptionMenuValue, an OptionMenuToEntry is a slight variant of\r\nan OptionMenuValue, so it is a good candidate to define via inheritance. All\r\noperators/methods working on OptionMenuValue make sense working on\r\nOptionMenutoEntry: most (e.g. grid, config, get) work purely by inheritance,\r\nbut we must change the parameters of the __init__ method, add a put method, and\r\noverride the reset method to do something different.\r\n\r\nObserve how the OptionMenuToEntry stores and uses its own entry reference,\r\nhow reset calls the overridden OptionMenuValue.reset before blanking the Entry,\r\nhow put fills the Entry with a green background, and how the command for the\r\n'Show Chosen Entry' button now calls get/put to accomplish its task: we no\r\nlonger need the option_to_entry function.\r\n\r\nfrom tkinter import *\r\n\r\n# ... define OptionMenuValue class (see above)\r\n\r\n#OptionMenuToEntry: with title,linked_entry, and option_tuple\r\n#get is an inherited pull function; put is a push function, pushing\r\n#  the selected option into the linked_entry (replacing what is there)\r\n#  with a green backround; reset now resets this text too\r\n\r\nclass OptionMenuToEntry(OptionMenuValue):\r\n    def __init__(self,parent,title,linked_entry,*option_tuple,**configs):\r\n        self.entry = linked_entry\r\n        OptionMenuValue.__init__(self,parent,title,*option_tuple,command=self.put,**configs)\r\n  \r\n    def reset(self):\r\n        OptionMenuValue.reset(self)\r\n        self.put('','white')\r\n        \r\n    def put(self,option,bg='green'):\r\n        self.entry.delete(0,len(self.entry.get()))\r\n        self.entry.insert(0,option)\r\n        self.entry.config(bg=bg)\r\n\r\n\r\nroot = Tk()\r\nroot.title('Widget Tester')\r\nmain = Frame(root)\r\nmain.pack(side=TOP,anchor=W)\r\n\r\ne = Entry(main) \r\ne.grid(row=2,column=2)\r\n\r\nomte = OptionMenuToEntry(main, 'Choose Option', e, 'option1','option2','option3')\r\nomte.grid(row=1,column=1)\r\nomte.config(width = 10)\r\n\r\n\r\nb= Button(main,text='Show Chosen Option',command=lambda : omte.put(omte.get(),'white'))\r\nb.grid(row=1,column=2)\r\n\r\nb = Button(main,text='Reset Option',command=omte.reset)\r\nb.grid(row=1,column=3)\r\n\r\nroot.mainloop()\r\n\r\nNot counting the class definitions, this is 15 lines of code, shrunk from 16\r\nlines.\r\n\r\nSo, we have seen how we can start with a powerful class (MenuOption) and easily\r\nspecialize it, via inheritance (multiple times), to operate a bit differently\r\neach time. In this way it is easy to define widgets with exactly the behavior\r\nthat we need, built on widgets supplied in Tkinter. It is common to use\r\ninheritance when defining/refining advanced GUI widgets.\r\n\r\n----------\r\n\r\nPrivacyError derived from the base-class Exception \r\n\r\nWe have seen that Python defines many exceptions and we have used a variety of\r\nthem (either raising them or handling them in except clauses of try/except\r\nstatements). We can easily define our own exception classes using inheritance.\r\nIn the mix-in inheritance example below, we will refer to PrivacyException,\r\nwhich is defined as follows.\r\n\r\nclass PrivacyError(Exception):\r\n    pass # inherits everything (including __init__) and overrides nothing\r\n\r\nSo here, the whole purpose is to define a class name, which we can name when we\r\nraise an exception, and can name when we handle an exception in a try/except\r\nstatements. It inherits ALL it (no overridding, no new) methods, including\r\n__init__.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nMix-in Inheritance Examples\r\n\r\nNow we will switch to a discussion of mix-in inheritance. Typically a mix-in\r\nbase class is something small that other classes can be derived from, to\r\ninherit their behavior. For example, the Privacy class (itself derived from\r\nobject) ensures that certain attributes are never rebound: its __setattr__\r\nmethod raises PrivacyError (defined above) if the attribute is in the set of the\r\n'privates' attribute: if o is constructed from a class that is derived from\r\nPrivacy, then if we write o.attr = ..., and attr is one of the strings in\r\no.privates, then Python will raise PrivacyError in the inherited __setattr__\r\nmethod.\r\n\r\nThe reasoning behind how Privacy works (see the Test class that is derived from\r\nit) depends on our knowledge of how attributes are located: inside the object\r\nor inside the class the object was constructed from. Here is the actual code and\r\nan analysis of what is happening.\r\n\r\nclass PrivacyError(Exception):\r\n    pass # inherit __init__/constructor\r\n        \r\n\r\nclass Privacy:\r\n    def __setattr__(self,attr_name,new_value):\r\n        print('__setattr__:',attr_name,'to be set to',new_value,'; privates = ',self.privates) # for illustration\r\n        if attr_name in self.privates:\r\n            raise PrivacyError('Privacy: attempt to set private: '+\r\n                               attr_name+' to '+str(new_value))\r\n        else:\r\n            self.__dict__[attr_name] = new_value\r\n\r\nclass Test(Privacy): # mix-in a single base class: Privacy\r\n    privates = {'y'} # y attribute of Test objects cannot be rebound after __init__\r\n\r\n    def __init__(self,x,y):\r\n        self.privates = set() # allow setting x y attributes; privates now found in object\r\n        self.x = x  \r\n        self.y = y\r\n        del self.privates     # now use class attribute privates above for future privacy\r\n\r\n        \r\nt = Test(0,1)\r\nt.x = 'rebound'\r\nt.y = 'rebound'\r\n\r\nNote the print statement in Privacy.__setattr__. When we run this program it\r\nprints\r\n\r\n__setattr__: privates to be set to set() ; privates =  {'y'}\r\n__setattr__: x to be set to 0 ; privates =  set()\r\n__setattr__: y to be set to 1 ; privates =  set()\r\n__setattr__: x to be set to rebound ; privates =  {'y'}\r\n__setattr__: y to be set to rebound ; privates =  {'y'}\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\pattis\\Desktop\\python32\\ztest\\experiment.py\", line 35, in <module>\r\n    t.y = 'rebound'\r\n  File \"C:\\Users\\pattis\\Desktop\\python32\\ztest\\experiment.py\", line 10, in __setattr__\r\n    attr_name+' to '+str(new_value))\r\n__main__.PrivacyError: Privacy: attempt to set private: y to rebound\r\n\r\nHere is an explanation of all the actions (some are a bit subtle)\r\n\r\n(1) When Python defines the Test class it has two attributes: privates is a\r\nname in the class namespace bound to {'y'} and __init__ is bound to its defined\r\nmethod.\r\n\r\n(2) When Python executes t = Test(0,1), Test.__init__ is called.\r\n\r\n  (2a) When Python executes self.privates = {}, it calls the __setattr__ method\r\n  inherited from Privacy; at this point it looks up self.privates, doesn't find\r\n  'privates' in the object (yet; see the result of this statement) so it tries\r\n  to look up the attribute in the Test class, where its value is {'y'}; since\r\n  'privates' -which is being bound- is not in this set, __setattr__ binds the\r\n  'privates' attribute to {} IN THE OBJECT being constructed.\r\n\r\n  (2b) When Python executes self.x = x, it calls the __setattr__ method\r\n  inherited from Privacy; at this point it looks up self.privates, and finds\r\n  'privates' IN THE OBJECT (see 2a), where its value is {}; since 'x' is not in\r\n  this set, __setattr__ binds the 'x' attribute to 0 in the object being\r\n  constructed.\r\n\r\n  (2c) When Python executes self.y = y, the same series of events happen (as\r\n  in 2b), and  __setattr__ binds the 'y' attribute to 1 in the object being\r\n  constructed.\r\n\r\n  (2d) When Python executes del self.privates it removes the 'privates'\r\n  attribute from the self object. After __init__ finishes, the object created\r\n  will not have a 'privates' attribute, so in the future when Python looks up\r\n  self.privates in __setattr__, it will find the 'privates' attribute not in\r\n  the object but instead in the Test class (bound to {'y'}) from which the\r\n  object was constructed.\r\n\r\n(3) When Python executes t.x = 'rebound',  it calls the __setattr__ method\r\n  inherited from Privacy; at this point it looks up self.privates, and finds\r\n  'privates' in the Test class (bound to {'y'}); since 'x' is not in this set,\r\n  __setattr__ binds the 'x' attribute in t's object to 'rebound'.\r\n\r\n(3) When Python executes t.y = 'rebound',  it calls the __setattr__ method\r\n  inherited from Privacy; at this point it looks up self.privates, and finds\r\n  'privates' in the Test class (bound to {'y'}); since 'y' is in this set,\r\n  __setattr__ raises an exception.\r\n\r\nHere is a second, simpler definition and use (in Test) of Privacy, but with a\r\nbit of a difference in meaning. In the code below, any new attribute is allowed\r\nto be added to the namespace of an object (e.g., in the Test.__init__ or\r\nelsewhere) but once an attribute is in the namespace of an object, it cannot be\r\nrebound if it appears in the 'privates' attribute. Here are the changed classes.\r\n\r\nclass Privacy:\r\n    def __setattr__(self,attr_name,new_value):\r\n        print('__setattr__:',attr_name,self.privates) # for illustration\r\n        if attr_name in self.__dict__ and attr_name in self.privates:\r\n            raise PrivacyError('Privacy: attempt to set private: '+\r\n                               attr_name+' to '+str(new_value))\r\n        else:\r\n            # either defining a first time or not private\r\n            self.__dict__[attr_name] = new_value\r\n\r\n\r\nclass Test(Privacy):\r\n    privates = {'y',} # y attribute of Test objects cannot be rebound\r\n\r\n    def __init__(self,x,y):\r\n        self.x = x  \r\n        self.y = y\r\n\r\nThe same lines of code\r\n\r\nt = Test(0,1)\r\nt.x = 'rebound'\r\nt.y = 'rebound'\r\n\r\nnow produce very simlar results (the only difference is that printing\r\nself.privates is always {'y'}). But when __init__ sets attribute 'y' Privacy\r\nallows it, because 'y' is not currently bound to any value.\r\n\r\n__setattr__: x {'y'}\r\n__setattr__: y {'y'}\r\n__setattr__: x {'y'}\r\n__setattr__: y {'y'}\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\inheritance\\privacy.py\", line 25, in <module>\r\n    t.y = 'rebound'\r\n  File \"C:\\Users\\Pattis\\workspace\\inheritance\\privacy.py\", line 10, in __setattr__\r\n    attr_name+' to '+str(new_value))\r\n__main__.PrivacyError: Privacy: attempt to set private: y to rebound\r\n\r\n\r\n----------\r\n\r\nAs a second mix-in example we will define a class that implements an interesting\r\n__str__ method. Then, we will write the Test class shown above to mix-in both\r\nthis class and Privacy. But first, let's use our knowledge of inheritance to\r\nbetter understand what happens when __str__ is called on an object constructed\r\nfrom the Test class, which does not define a __str__ method. Assume as above,\r\nt = Test(0,1).\r\n\r\nNotice the Test class defined above defines no __repr__ or __str__ functions.\r\nWhen we call print(t), Python converts t to a str (the only things it can print)\r\nby calling t.__str__(). Now, the t object itself defines no __str__ attribute,\r\nso Python tries to look up this attribute in the Test class, but it also doesn't\r\ndefine a __repr__ or __str__ method. So Python next looks in the base class of\r\nTest, which is Privacy; but it also doesn't define a __repr__ or __str__ method.\r\nSo Python next looks in the base class of Privacy, which is object. Now the\r\nobject class does define only a __repr__ method (which __str__ calls too). It\r\nreturns a string like '<__main__.Test object at 0x027482F0>' showing just the\r\nname of the class of t and its location in memory (all objects come froma class\r\nand have a location in memory). So, that is how a class that doesn't define\r\n__repr__ or __str__ methods ultimately produces a string representing an object\r\nconstructed from the class: it calls the one inherited from the object class.\r\n\r\nThe mix-in class Str_All_Attributes defines only a __str__ method, as follows.\r\nIt returns a string saying what class the object is an instance of, and then\r\nlists (on separate lines) each attribute of the object, in alphabetical order,\r\nand its value.\r\n\r\nclass Str_All_Attributes:\r\n    def __str__(self):\r\n        from goody import type_as_str\r\n        answer = 'Instance of ' +type_as_str(self)+'\\n'\r\n        for a in sorted(self.__dict__):\r\n            answer += '  ' + a + ' -> ' + str(self.__dict__[a]) + '\\n'\r\n        return answer\r\n\r\nNow we can define Test as follows, using both mix-in classes\r\n\r\nclass Test(Privacy,Str_All_Attributes):\r\n\r\nWhen we define t = Test(0,1) and call print(t) Python looks up the __str__\r\nattribute using the search order discussed in the previous lecture (__mro__).\r\n\r\nPython tries to look up the attribute in the t object itself, but it doesn't\r\ndefine a __repr__ or __str__ method. Python next tries to look up this\r\nattribute in the Test class, but it also doesn't define a __repr__ or __str__\r\nmethod. So Python next looks in the first base class of Test, which is Privacy;\r\nbut it also doesn't define a __repr__ or __str__ method. So Python next looks\r\nin the second base class, which is Str_All_Attributes. Now this class does\r\ndefine a __str__ method. It prints the string as\r\n\r\nInstance of __main__.Test\r\n  x -> 0\r\n  y -> 1\r\n\r\nBy defining\r\n\r\nclass Test(Privacy,Str_All_Attributes):\r\n\r\nAny Test objects will check rebinding attempts via the __setattr__ method\r\ninherited from Privacy and will print via the __str__ method inherited from\r\nStr_All_Attributes.\r\n\r\nSo, it is very simple to derive a class from a variety of mix-in base classes,\r\nand have the derived class inherit all the behaviors of the mixin classes. But\r\nnote that if TWO MIX-IN BASE CLASSES define the SAME METHOD, if that method is\r\ncalled, it will be called only from the class that is the first one found in\r\nthe inheritance hierarchy. Therefore, one must be carefully when using mix-in\r\ninheritance with classes that define the same methods. Typically, the mix-in\r\nclasses used in multiple inheritance should not define the same methods.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n1) Define a class name Controlled_Keys_Dict that allows us to specify that some\r\nkeys are unchangable: they can be set to associate with a value, but only if\r\nthey are not already in the dictionary (if they are already in the dictionary\r\nthey cannot be changed). For d in this class, we can call d.control(...) to\r\nspecify which keys are controlled (its argument can be any iterable). Thus if\r\nwe call d.control(d.keys()) it would controll all the keys currently in that\r\ndictionary.\r\n\r\n2) Suppose we define\r\n\r\nt1 = Test(0,1)\r\nt2 = Test(0,1)\r\nt1.privacy = {'x'}\r\n\r\nCan we change t1.x? t1.y? t2.x? t2.y? Explain your reasoning.\r\n\r\n3) Write a version of Str_All_Attributes that includes not only the\r\nattributes of the object, but all its inherited attributes. See the\r\ninheritancetool2 module for some useful code.\r\n", "encoding": "ascii"}