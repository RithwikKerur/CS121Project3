{"url": "https://www.ics.uci.edu/~jacobson/ics23/LabManual/01-UnearthingThePast.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n    \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<meta name=\"Generator\" content=\"Microsoft Word 97/98\">\n<title>Unearthing the Past - Assignment 1</title>\n<link rel=\"stylesheet\" href=\"../course.css\" type=\"text/css\">\n</head>\n\n<body>\n\n<div class=\"title\">\n<center>\n<h2>Unearthing the Past</h2>\n<h4>Assignment 1</h4>\n</center>\n</div>\n\n<div class=section>\n<hr>\n<h3>About Ground Penetrating Radar</h3>\n</div>\n<p>Ground-penetrating radar (&#147;GPR&#148;) sends pulsed radio waves into the ground and receives them as they reflect back. As with radar or sonar, GPR waves are distorted when they encounter various materials&#151;water, stone, bone, wood, metals, etc.&#151;resulting in reflected waves that differ in shape and intensity depending upon what they &#147;hit.&#148; The reflected wave data is (computer) processed and recorded. When combined with the location of the readings, a two-dimensional map of the area can be composed, kind of like an aerial photograph of what&#146;s under the ground. GPR is used for several purposes, but is perhaps most noted for accessing an area&#146;s archeological significance much faster (and cheaper) than digging. (To learn more about GPR, check out, for example, the <a href=\"http://en.wikipedia.org/wiki/Ground_penetrating_radar\">Ground-penetrating radar entry in Wikipedia</a>).</p>\n\n<p>In the context of this program, each surveyed site has a title. The surveyed area is always a <i>grid</i>, a two-dimensional, rectangular array of equal-sized square <i>cells</i>.  For each cell that has been surveyed, we have its row number (starting at 0), column number (starting at 0), the intensity of the reading (from 1 to 600), and the time the reading was taken. Data for a cell in the gird area not (yet) surveyed is either not given, or appears as special values indicating the cell&#146;s intensity is not yet known and the time is not applicable.</p>\n\n<div class=section>\n<hr>\n<h3>About the assignment</h3>\n</div>\n\n<p> In this assignment, you complete a program to convert the GPR data from a text file (created by a download  from a GPR field unit) into memory structures so that (already written) graphics routines can use it to produce an on-screen false color-coded map of the area surveyed, along with a report of the collected data. You gain practice with two-dimensional arrays and linked-list-based priority queues, a review of several programming concepts and Java features covered in ICS 21 and ICS 22, and an opportunity to make heavy use of pre-existing classes for which you have no source code&#151;one of  the most valuable of real-world programming skills. (This program is less sophisticated than a typical real-world GPR program, as this assignment is not about writing a full-blown GPR app; it&#146;s about applying data structure and alogrithm concepts to an actual programming problem.)</p>\n\n<div class=section>\n<hr>\n<h3>Using the GPR Viewer program</h3>\n</div>\n\n<p>To view a GPR survey&#146;s map and report, the user runs the GPR Viewer program <font class = \"codeFaceSmall\">GPR</font>; this screen appears:\n\n<center><img src=\"01-UnearthBlank.jpg\"></center>\n\n<p>The user enters the name of a file in the <font class = \"codeFaceSmall\">GPR File Name:</font> text box and presses the <font class = \"codeFaceSmall\">View</font> button. If the file does not exist, an error message prints and the screen is otherwise left unchanged. If the file does exist, a color-coded map of the surveyed area appears in the map area above the file name and a text report containing survey information appears in the right-side window.</p>\n\n<p>The program maps each cell to a position in the map area, corresponding to the cell&#146;s row and column position in the grid. For instance, if the cell is at position (1,4) in the grid, it is displayed at position (1,4) on the map.  The cell's size is set so that the grid fills the map window in at least one dimension&#151;so if the survey area has few cells, each cell will be quite large. (Typically, each cell is relatively small compared to the survery area, so more precise readings of the area can be obtained.)  Each cell is displayed in a color determined by its intensity; an intensity of 0 indicates the cell has yet to be surveyed, so the program leaves its cell unfilled: </p>\n\n<center>\n<table summary=\"Intensity to Color Cell Mapping\" border=\"1\" cellspacing=\"2\" cellpadding=\"1\">\n<tr align=\"left\" valign=\"top\"><td><b>Intensity</b></td><td><b>Color</b></td></tr>\n<tr align=\"left\" valign=\"top\"><td>0</td><td>black</td></tr>\n<tr align=\"left\" valign=\"top\"><td>1-100</td><td>violet</td></tr>\n<tr align=\"left\" valign=\"top\"><td>101-200</td><td>blue</td></tr>\n<tr align=\"left\" valign=\"top\"><td>201-300</td><td>green</td></tr>\n<tr align=\"left\" valign=\"top\"><td>301-400</td><td>yellow</td></tr>\n<tr align=\"left\" valign=\"top\"><td>401-500</td><td>orange</td></tr>\n<tr align=\"left\" valign=\"top\"><td>501-600</td><td>red</td></tr>\n</table>\n</center>\n\n<p>The report first displays the site name, the number of rows and the number of columns. It then lists each cell&#146;s information, one cell per line. Note that the report has a line for <i>every</i> cell in the grid; if a grid was not surveyed, its intensity will be 0, and its time-stamp will be all zeroes. </p>\n\n<p>When  the report is first displayed, the cells are sorted by intensity (see below for details). The user can press any of the buttons <font class = \"codeFaceSmall\">Sort by Intensity</font>, <font class = \"codeFaceSmall\">Sort by Time</font>, <font class = \"codeFaceSmall\">Sort by Row</font> and <font class = \"codeFaceSmall\">Sort by Column</font> to place cell data in that so-named ordering. The sort orders are</p>\n\n<ul>\n<li><p><font class = \"codeFaceSmall\">Sort by Intensity</font>: in order of decreasing intensity and, within each intensity value, sorted in ascending row order and, for each row, in ascending column order; unsurveyed cells that appear in the file are at the bottom of the list (as they have intensity 0) </p></li>\n\n<li><p><font class = \"codeFaceSmall\">Sort by Time</font>: in order of decreasing time (that is, most recently surveyed items appear first) and, within each time, sorted in ascending row order and, for each row, in ascending column order; unsurveyed cells that appear in the file appear at the bottom of the list </p></li>\n\n<li><p><font class = \"codeFaceSmall\">Sort by Row</font>: in order of ascending row number and, within each row, in ascending column order </p></li>\n\n<li><p><font class = \"codeFaceSmall\">Sort by Column</font>: in order of ascending column number and, within each column, in ascending row order </p></li>\n</ul>\n\n<li><p>To view another survey, the user just enters a new file name (and presses <font class = \"codefacesmall\">View</font>). To exit, the user clicks on the window&#146;s close box.</p></li>\n\n\n<div class=section>\n<hr>\n<h3>Technical issues and requirements</h3>\n</div>\n\n<h4>The ICS 23 Eclipse workspace</h4>\n\n\n<p>As previously discussed, we use Eclipse as our programming environment. Eclipse keeps each program in a <i>project</i>; projects are kept in a <i>workspace</i>, which also keeps track of all of your environment settings (including compile and runtime options). \n\n<p>Eclipse provides a large set of options and,  unfortunately, the default settings aren&#146;t entirely appropriate for us in this course. So, to keep things straightforward, you&#146;ll all use the same workspace, one already set up with the appropriate settings for this course (and the same settings that will be used when grading your work).  This workspace, as a ZIP file, is available at</p>\n\n<ul>\n  <li><a href=\"http://www.ics.uci.edu/~jacobson/ics23/LabManual/LabFiles/23Workspace.zip\">ICS 23 Eclipse workspace</a></li>\n</ul>\n\nA good place to put your workspace when working in the ICS labs is on your H: drive, so that it will be available to you regardless of which machine you're logged into, as well as being permanently stored (remember, files stored to the C: drive can be erased).  For example, you might put your workspace into a folder named <font class = \"codefacesmall\">H:\\23Workspace</font>.  You might also want to store it on a USB memory stick or other portable media, thus having a backup in case you lose the original.</p>\n\n<p>(Note to Mac users who intend to use Eclipse on their own machines: the zip archive may appear empty, because it contains only a folder called <font class = \"codefacesmall\">.metadata</font>.  Files and folders whose names begin with a \".\" character are hidden in Mac OS X by default.  Go ahead and unzip the archive as discussed above; all will be well.)</p>\n\n<h4>The UnearthingThePast project file</h4>\n\n<p>All of the code that makes up this program is to be included in the UnearthingThePast project file; we&#146;ve already included the project in the workspace you download. To complete the assignment, you add your code, that is, appropriate Java source files, to the <i>source</i> folder inside the project.\n\n<h4>Provided code and code you write</h4>\n\n<p>We&#146;ve provided the code, as class files, that handles the graphic display of the map and report. You&#146;ll find these files in the project&#146;s <font class = \"codefacesmall\">lib</font> folder.\n\n<p>You are to supply the code that reads the information from the GPR data file and prepares the grid; the grid contains the same information as the file, but in a form appropriate for use by the graphics routines the control the grid map. You also write the code that takes information from the grid and &#147;massages&#148; it into the GPR report; that report, as a (very long) string, is then &#147;picked up&#148; by the graphics routines when appropriate and displayed in the report window.</p>\n\n<p>To help you write your code (and write it according to specification), we provide in the project, in the <i>source</i> folder, four Java source files. One has a class with the main() method, to get things going; the other three are interfaces to help ensure your code meets the required specifications. All these files are to be left unchanged. More specifically, the files are</p>\n\n<ul>\n<li><p><font class = \"codeFaceSmall\">GPR.java</font>: the main progam; it also gives a brief description of the program</p></li>\n\n<li><p><font class = \"codeFaceSmall\">CellInfoInterface.java</font>: an interface that describes and enforces some requirements for the cell class, which contains the information about one cell of the grid; you write the cell class </p></li>\n\n<li><p><font class = \"codeFaceSmall\">GPRGridInterface.java</font>: an interface that describes and enforces some requirements for the grid class; you write the grid class </p></li>\n\n<li><p><font class = \"codeFaceSmall\">SurveyReportInterface.java</font>: an interface that describes and enforces some requirements for the report; you write the report class </p></li>\n</ul>\n\nEach of the Java files is well-commented, and contains information you need to properly implement the cell, grid and report classes, such as the format of the GPR data file. <i>Do pay attention to them!</i>\n\n\n<h4>Additional requirements</h4>\n\n<ul>\n<li><p>The exact format of the report is up to you, but it must (1) contain all the data that is in the GPR data file (2) be formatted so the site name, and number of rows and columns, appear at the top of the report, followed by cell information, with each cell&#146;s information on one (and its own) line, and (3) be formatted so it is easy to read and locate specfic information (e.g., a user should be able to find the information about a particular cell quickly). You will lose points if your report is hard to read or understand.</p></li>\n\n<li><p>Your program has to run within Eclipse's default memory allocations; in particular, this means you cannot increase the size of the heap or runtime stack. This restriction is to simulate the real-world situation where you are doing this work in the middle of nowhere. (This is a very real-world constraint: As-needed air drops in the middle of the Egyptian desert to deliver RAM to beef up your computer&#151;it just doesn&#146;t happen!) If your program runs out of memory while processing the provided test files (see below), your implementation needs improvement.</p></li>\n\n<li><p>To sort the cells into a given order for the report, you must use a priority queue based on a singly-linked list. The PQ add operation is to be O(1); the delete operation is to be O(n). (Recall the O-value of a function is an upper bound&#151;so you can make these operations faster than indicated, but no slower). You can write your own linked-list class, or adapt a linked-list class from a text, a web site that allows such adaptation of its code, or class notes from this or another course. If you adapt your list code from another source, <i>be sure to cite your source in comments in your code</i>&#151;not doing so is considered plagarism! (Note you cannot use the Java LinkedList class, as it is based on a doubly-linked list.)</p> \n\n<li><p>You must write your own priority queue class (which, of course, uses linked list class objects as appropriate).<p></li>\n </ul>\n\n<p>The use of the priority queue as defined here provides what is essentially a sorting of the data via selection sort; the data is sorted in one of the four ways given above, depending upon which ordering the user chooses. There are several reasonable approaches for computing the priority; here are some hints and ideas:\n\n<ul>\n<li><p>One can compute each of the four priorities and store those priorities as part of the information that is placed into the queue at the time a cell&#146;s information is inserted.  Each cell is inserted only once, so this way each priority is only computed once. </p>\n\n<p>An alternative approach is to determine the node&#146;s priority during the delete operation; whenever a node is examined, the needed priority is computed from the node&#146;s stored information. Since nodes may be queried several times in the course of deleting items to add to the report, this approach coud be quite a bit slower than the one discussed in the paragraph above, but it takes much less storage space&#151;and storage space could be a somethig of concern if a data file has a large number (millions) of squares.</p></li>\n\n<li><p>Removing items repeatedly from a priority queue produces items in decreasing order. If one wants to have the items in increasing order (and not violate the rules of priority queue deletion), &#147;invert&#148; the priority; for example, if the original priority is a number, multiply it by -1, or subtract it from a number larger than any legal value, to produce a new priority; that new priority will deliver the items in the reverse order.</p></li>\n\n<li><p>A nice trick for computing a priority (a sort key) that is composed of multiple fields is to concatentate them into one long number or string, ordered from the first field to use to the last. For example, for the By Intensity ordering,  one can make the priority be </p>\n\n<pre>\n// computed once : these do not change\nshiftFactorForRow = 10 ^ (floor(log(numberOfColumns) + 1));\nshiftFactorforIntensity = 10 ^ (floor(log(numberOfRows) + 1)) * shiftFactorforRow;\n\n//computed for each node's priority\npriority =  intensity * shiftFactorforIntensity + (numberOfRows - row) * shiftFactorForRow + (numberOfColumns - col) \n</pre>\n\n<p>Note the &#147;-1&#148; trick will not work with this approach.</p></li>\n</ul>\n\n<p>One way to reorder a report&#146s information is to re-read the file or GPR in-memory structure that contains the data,, and placing it (back) into the priority queue. But reading data off of disk is orders of magnitude slower than reading things from memory, so it would be better not to re-read the file each time the report is reodered. And re-reading data from the GPR memory structure also takes time (though not as much as reading from disk)&#151but it is time you don't actually need to spend if you use this little trick: When you delete a node from the priority queue, don't actually delete it; instead, mark the node as deleted from the priority queue but leave it in the underlying list. If the user selects a diferent ordering for the same information, just go through the linked list (that is used to store priority queue data) and unmark the deleted items. Now all the original data is back into the queue without having to read it again from the file.</p>\n\n<p>The project file contains some test files to help you debug your program; they (and only they) end in the <font class = \"codeFaceSmall\">txt</font> extension. For example, here is what the file <font class = \"codeFaceSmall\">SimpleTest.txt</font> produces:</p>\n\n<center><img src=\"01-UnearthTest.jpg\"></center>\n\n<p>The grid patterns these files produce should look like what their names imply. The files ending in BIG can take several minutes to process, so, obviously, use them once you have your program working on the smaller files.</p>\n\n<p>You will note the report generated from these files is very poorly formatted; we did this purposely, to give you an idea of what <i>not</i> to do for your report. Your report showing the data from the test files should be much nicer, as described above. (Hint: Java has a String.format() static method that takes a pattern and a string and produces an output string that conforms to the format. This is a very powerful method that can format the output almost any way you could possibly want. You can find some details about format() in most any introductory Java book and in tutorials on the Web; complete documetation is available on the <font class = \"codeFaceSmall\"><a href=\"http://download.oracle.com/javase/7/docs/api/\">Java Platform, Standard Edition 7 API Specification</a></font> web page; check out the String and Formatter classes.)</p>\n\n\n<div class=section>\n<hr>\n<h3>Making a Speedy Program</h3>\n</div>\n\n<p>Obviously, the users of the this GPR program do not want to wait more than necessary to see a map and report; once the View button his clicked, the results need to display as quickly as feasible.</p>\n\n<p>The main determiner of the speed of this program is how long the data files, especially the  big files, take to process, and that depends mainly upon the priority queue implementation and the Java string classes we use. (You can improve the speed of the program a bit using other means, <i>but do not focus on \"micro-efficiencies\"</i>&#151; if the speed increase is minimal (for example, a few milliseconds faster for a report that takes minutes to generate) and the resulting code would be harder to understand or maintain, do not implement that change; it is just not worth it! However, if you can make the priority queue faster by making a small, <i>easy-to-understand</i> variation, go ahead and do so. For example, there is a way (using a technique we discussed in class) to construct the list so that you never have to check for a null list when adding a node; that saves some constant time for each insertion that, across many insertions, could have up to a noticeable increase in speed.) You&#146;ll learn about other, faster, implementations of priority queues later in the course. But, even with this exercise&#146;s priority queue structure, the program can be made several times faster by using the right Java string class:</p>\n\n<p>It turns out that main activity that slows down the program is constructing the report, which requires concatenating many, many pieces of information into one very long string, as the graphics routine that prints the report can only handle a single string as its input. If you use the standard String class, these concatenations takes a very long time. Strings are immutable; that is, they cannot change once assigned a value. So each time there is a concatenation, a new target string is allocated to hold the result, and the (large) concatenated string is copied into that new String object, a very time-consuming task.</p>\n\n<p>However, Java also provides a StringBuffer class that produces objects that hold strings that can be modified: at any point in time, a StringBuffer object contains some particular sequence of characters, but the length and content of the sequence can be changed.\n\n<p>The principal operations on a StringBuffer are the append and insert methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string buffer. The append method always adds these characters at the end of the buffer; the insert method adds the characters at a specified point.</p>\n\n<blockquote>For example, if <font class = \"codefacesmall\">z</font> refers to a string buffer  object whose current contents are \"<font class = \"codefacesmall\">start</font>\", then the method call <font class = \"codefacesmall\">z.append(\"le\")</font> would cause the string buffer to contain \"<font class = \"codefacesmall\">startle</font>\", whereas <font class = \"codefacesmall\">z.insert(4, \"le\")</font> would alter the string buffer to contain \"<font class = \"codefacesmall\">starlet</font>\". [Java StringBuffer API documentation, //download.oracle.com/javase/7/docs/api/]\n</blockquote>\n\n<p>Thus, append works like concatenation for Strings, except that the current string is extended instead of a new String being allocated; this is much, much faster.</p>\n\n<p>If you nicely format each piece of the report as you append it to the report string [e.g., <font class = \"codefacesmall\">z.append(String.format(<i>pattern</i>,<i>string to add</i>))</font>], your report will be nicely formatted when it appears on the GPR screen.</p>\n\n<p>Potentially even better is StringBuilder:</p>\n\n<blockquote>...This class is designed for use as a drop-in replacement for StringBuffer in places where the string buffer was being used by a single thread (as is generally the case). Where possible, it is recommended that this class be used in preference to StringBuffer as it will be faster under most implementations.[Java StringBuilder API documentation, //download.oracle.com/javase/7/docs/api/]</blockquote>\n\n<p>The constructors, append() and insert() for StringBuilder work the same way as the equivalent StringBuffer methods.</p>\n\n<p>The GPR program only uses one explicit thread&#151; so try StringBuilder and see how well it works. The graphic routines sometimes call their own threads, which might interfere with StringBuilder; if so, revert back to StringBuffer. <i>In no event, though, should you use String objects to build the report</i>: Use StringBuilder if you can, StringBuffer if you must.</p>\n\n<p>Documetation for String, StringBuffer and StringBuilder is on the <font class = \"codeFaceSmall\"><a href=\"http://download.oracle.com/javase/7/docs/api/\">Java Platform, Standard Edition 7 API Specification</a></font> web page.</p>\n\n<div class=section>\n<hr>\n<h3>Deliverables</h3>\n</div>\n\n<p>Zip up your <i>project</i> folder into the file <font class = \"codeFaceSmall\">UnearthingThePast.zip</font>, and turn it in via Checkmate. <i>Do not turn in the entire workspace</i>&#151;it&#146;s quite large, and we already have a workspace set up for running and grading your program.\n\n<div class=history>\n<hr>\nWritten by Norman Jacobson, August 2006. <br>\n&nbsp;&nbsp;Some portions based on a few sections of the Spring 2006 version of the ICS 23 assignment \n<br>&nbsp;&nbsp;<i>Dark at the End of the Tunnel</i> by Alex Thornton as revised by Norman Jacobson.\n<br>Revised to discuss additional test files by Norman Jacobson, October 2006.\n<br>Added section to discuss StringBuilder and StringBuffer and made minor edits to fix typographical errors, \n<br>&nbsp;&nbsp;by Norman Jacobson, January 2007.\n<br>Minor edits for clarity and to emphasize that String is not to be used to build the report, by Norman Jacobson, December 2008.\n<br>Made clear that PQ has to be O(1) insert & O(n) delete; added hints for determining priorities; indicated the data\n<br>&nbsp;&nbsp;file has data for all squares of the grid, by Norman Jacobson April 2009.\n<br>Added intro material to provide Eclipse workspace for all assignments, to reflect use of Eclipse workspace and project \n<br>&nbsp;&nbsp;and to add a couple of hints and further explanations, by Norman Jacobson March 2010.\n<br>Added discussion of how to avoid re-reading the data when re-ordering a report, and\n<br>&nbsp;&nbsp;added restriction that only default memory allocations can be used, by\n<br>&nbsp;&nbsp;Norman Jacobson, April 2010.\n<br>Corrected \"multiple key hint\" formula, made minor edits and updated documentation links, by Norman Jacobson, March and April 2011\n<br>Updated documentation links, by Norman Jacobson, March 2012\n</div>\n\n</body>\n</html>\n", "encoding": "ascii"}