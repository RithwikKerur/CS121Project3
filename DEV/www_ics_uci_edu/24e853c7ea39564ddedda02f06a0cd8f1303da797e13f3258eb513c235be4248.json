{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/SetsAndDictionaries/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Python Background Notes: Sets and Dictionaries</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Python Background Notes: Sets and Dictionaries</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Why tuples and lists aren't enough</p>\r\n\r\n<p>Thus far, we've seen two different data structures that are built into Python: tuples and lists.  At a quick glance, they seem to be essentially the same thing, because they each store a collection of elements where the order of those elements is considered relevant.  The key difference, though, lies in how flexible their structure is:</p>\r\n\r\n<ul>\r\n  <li>Tuples are intended to be used in situations where you know their structure at the time you write the program.  For example, you might want to store information about a point in three-dimensional space as its three coordinates: <i>x</i>, <i>y</i>, and <i>z</i>.  A tuple would be a handy way to do that.</li>\r\n  <li>Lists are intended to be used in situations where you need the structure to be more flexible, and to adapt as the program runs.  You might use this to store the information you load from a file when you don't know ahead of time how large the file will be, or a collection of all of the users currently logged into your application, or what have you; the key is that we're talking about a collection that can (and usually does) change while the program runs.</li>\r\n</ul>\r\n\r\n<p>Why tuples and lists are useful for different things has mostly to do with a difference in their mutability.  Tuples are set in stone once you create them; they are what they are.  Lists can be mutated during their lifetime.</p>\r\n\r\n<p>So, ultimately, there's value in having both tuples and lists available to us, because they each fit a different kind of problem.  But they aren't enough, because not all problems require storing an ordered sequence of elements.  For differently-shaped problems, you'd need different structures.  Fortunately, Python provides some additional choices, fitting additional commonly-occurring problems very nicely.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Sets</p>\r\n\r\n<p>You've likely been introduced to the mathematical concept of <i>sets</i> at some point.  In mathematics, a set is a collection of zero or more unique values.  What's important about a set is what's in it and what's not in it; there is no meaningful notion of ordering involved.  For example, the set <b>{1, 2, 3}</b> is considered to be equivalent to the set <b>{3, 1, 2}</b>, because they both contain the same collection of values.</p>\r\n\r\n<p>As it turns out, sets aren't just a mathematical curiosity.  Sometimes, you'll want your program to manage a collection of objects with the same characteristics:</p>\r\n\r\n<ul>\r\n  <li>What you're most interested in knowing is whether or not an object is in the collection.</li>\r\n  <li>You don't want to allow duplication of objects within the collection.  If, for example, it's a collection of integers, you don't want the same integer to appear twice.</li>\r\n</ul>\r\n\r\n<p>When you have a problem that has those characteristics, a set provides a nice way to solve it.  Obviously, not all problems have those characteristics, but some certainly do.  If, for example, you were implementing a program with a graphical user interface, which contained a collection of buttons that could each be toggled on or off, and you wanted to know which buttons had been toggled on, you might store them in a set.  Why?  Because this scenario fits those two characteristics:</p>\r\n\r\n<ul>\r\n  <li>You're most interested in knowing whether or not one of the buttons has been toggled on.</li>\r\n  <li>The same button can't be toggled on more than once.  It either is or it isn't.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">How to create and use sets</p>\r\n\r\n<p>Sets are actually pretty simple to create and use in Python, though there is a bit of additional syntax we'll need to learn.  We've seen previously that lists are denoted, literally, by being surrounded by the bracket characters <b>'['</b> and <b>']'</b>, with their elements separated inside by commas.  Sets are written similarly, except they're surrounded instead by the curly-brace characters <b>'{'</b> and <b>'}'</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>s = {'a', 'c', 'e'}</b>\r\n&gt;&gt;&gt; <b>type(s)</b>\r\n&lt;class 'set'&gt;\r\n&gt;&gt;&gt; <b>s</b>\r\n{'e', 'a', 'c'}\r\n</pre></blockquote>\r\n\r\n<p>One thing to note, right away, is that <b>s</b> was displayed to us differently from the way we wrote it.  When we wrote it, we listed the strings alphabetically; when it was displayed to us, it was displayed in a different order.  There are a couple of things to know about sets:</p>\r\n\r\n<ul>\r\n  <li>Because the order of elements within sets is considered irrelevant, Python feels no obligation to maintain any information about what order we used when we originally created them.</li>\r\n  <li>The order that's used is actually <i>implementation-dependent</i>, which is a fancy way of saying that you simply don't know what it will be; the rules of ordering elements in a set can change from one implementation of Python to another &mdash; or even from one <i>version</i> of the same implementation to another.</li>\r\n</ul>\r\n\r\n<p>Just because sets aren't stored in any kind of order doesn't make them useless; it just means that you can't count on anything having to do with that ordering.  But you can nonetheless ask the key questions you'd like to ask.  For example, checking whether an element is in a set can be done using the <b>in</b> operator.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>'e' in s</b>\r\nTrue\r\n&gt;&gt;&gt; <b>'f' in s</b>\r\nFalse\r\n</pre></blockquote>\r\n\r\n<p>(It should be noted that you can use this same <b>in</b> operator on lists, as well, though you might expect it to run a fair bit faster on a large set than on a large list.  In future coursework, we'll talk in more detail about why that is.)</p>\r\n\r\n<p>Sets can also be combined with other sets in the ways you've seen in mathematics before: There is a notion of <i>union</i>, <i>intersection</i>, <i>set difference</i>, and <i>symmetric difference</i>.  The only tricky part is recognizing the operators.</p>\r\n\r\n<ul>\r\n  <li>Union is denoted by <b>|</b>, which is actually a syntax in some programming languages for the Boolean operator <b>or</b>.  This makes some sense, actually: The union of the sets <b>s1</b> and <b>s2</b> contains elements that are either in <b>s1</b> or <b>s2</b> (or both).</li>\r\n  <li>Intersection is denoted by <b>&</b>, a syntax that also sometimes means Boolean <b>and</b>.  The intersection of the sets <b>s1</b> and <b>s2</b> contains elements that are in both <b>s1</b> and <b>s2</b>.</li>\r\n  <li>Set difference is denoted by <b>-</b>, which is somewhat akin to the difference between two numbers.</li>\r\n  <li>Symmetric difference is denoted by <b>^</b>, a syntax that sometimes means the Boolean notion of <i>exclusive or</i> (i.e., one or the other, but not both).  The symmetric differnce of the sets <b>s1</b> and <b>s2</b> contains elements that are in one set or the other, but do not appear in both.</li>\r\n</ul>\r\n\r\n<p>Putting all of these together leads to the following examples.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>s1 = {1, 3, 5, 7, 9, 11}</b>\r\n&gt;&gt;&gt; <b>s2 = {2, 5, 8, 11, 14}</b>\r\n&gt;&gt;&gt; <b>s1 | s2</b>\r\n{1, 2, 3, 5, 7, 8, 9, 11, 14}\r\n&gt;&gt;&gt; <b>s1 & s2</b>\r\n{11, 5}\r\n&gt;&gt;&gt; <b>s1 - s2</b>\r\n{1, 3, 9, 7}\r\n&gt;&gt;&gt; <b>s1 ^ s2</b>\r\n{1, 2, 3, 7, 8, 9, 14}\r\n</pre></blockquote>\r\n\r\n<p>(Note, again, that the order in which you see the elements in each resulting set may vary if you run these same expressions in the Python shell.  There are essentially no guarantees about the visible ordering of elements in a set.)</p>\r\n\r\n<p>Whether or not other operations that you've seen on lists are supported on sets is mainly a matter of whether they're sensible when used on a set.  Indexing, for example, is not supported.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>s = {1, 2, 3}</b>\r\n&gt;&gt;&gt; <b>s[0]</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;\r\n    s[0]\r\nTypeError: 'set' object does not support indexing\r\n</pre></blockquote>\r\n\r\n<p>This is a sensible restriction, because indexing this way implies that there's a definitive order (i.e., one of them is definitively the first one in the set).</p>\r\n\r\n<p>On the other hand, you can iterate over a set using a <b>for</b> loop.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>for x in s:\r\n        print(x)</b>\r\n\r\n1\r\n2\r\n3\r\n</pre></blockquote>\r\n\r\n<p>Though it should be noted that you won't be guaranteed that the iteration will happen in any particular order.  Note, too, that this means anything else that uses iteration will work as you would expect, with the same caveat about ordering.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>list(s)</b>\r\n[1, 2, 3]\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Dictionaries</p>\r\n\r\n<p>Sets can be handy, but they are somewhat limited in their usefulness.  However, we can extend the idea of a set a little bit and end up with something that has even broader usefulness.</p>\r\n\r\n<p>In a <i>dictionary</i>, we store a collection of unique <i>keys</i>, each one associated with a <i>value</i>.  The uniqueness of the keys in a dictionary means that the collection of keys, conceptually, forms a set.  (This also means that the keys are not ordered, similar to how they aren't ordered in a set.)  But the important distiction is that you can know something <i>about</i> each key besides just the key; by being able to associate a value with a key, you have a tool that you can use in different circumstances for which a set would be a poor fit.</p>\r\n\r\n<p class=\"subtitle\">How to create and use dictionaries</p>\r\n\r\n<p>Creating a dictionary is generally done using the built-in function <b>dict()</b> and passing it no arguments.  (Alternatively, the syntax <b>{ }</b> is technically legal, though a little bit confusing, because you have to remember that the result is an empty dictionary, rather than an empty set.  Clearer is usually better than shorter.)</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>d = dict()</b>\r\n&gt;&gt;&gt; <b>type(d)</b>\r\n&lt;class 'dict'&gt;\r\n&gt;&gt;&gt; <b>d</b>\r\n{}\r\n</pre></blockquote>\r\n\r\n<p>Dictionaries are mutable, the way that lists are; the expectation is that you should be able to use them to manipulate a collection of data that changes while your program runs.  Mutating them is a matter of changing the value that is associated with some key, which you can do using an operation that looks very similar to indexing a list.  The difference is that the index you pass it isn't a numeric index, necessarily; it's the key whose value you want to update.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>d['b'] = 3</b>\r\n&gt;&gt;&gt; <b>d['b']</b>\r\n3\r\n&gt;&gt;&gt; <b>d['b'] += 1</b>\r\n&gt;&gt;&gt; <b>d['b']</b>\r\n4\r\n</pre></blockquote>\r\n\r\n<p>There is wide latitude in which is allowed as a key in a dictionary; more or less anything that is immutable will do.  (The reason why immutability of keys is such a big deal is that you don't want changes outside of the dictionary to suddenly have an impact of the set of keys within that dictionary.)</p>\r\n\r\n<p>You can have as many different keys in the dictionary as you want, but each key can only appear once; any subsequent attempt to set its value replaces the value that's already there.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>d['b'] = 9</b>\r\n&gt;&gt;&gt; <b>d['q'] = -5</b>\r\n&gt;&gt;&gt; <b>d</b>\r\n{'b': 9, 'q': 5}\r\n</pre></blockquote>\r\n\r\n<p>You can see, also, that a dictionary's representation is similar to the representation of a set, except that each key is followed by a colon and a value.  Like sets, the order of the keys is considered irrelevant, and there's no guarantees about what order you'll see them in.  Note, too, that this is also legal syntax for writing dictionary literals.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>d2 = {'a': 1, 'b': 2, 'c': 3}</b>\r\n&gt;&gt;&gt; <b>d2</b>\r\n{'a': 1, 'b': 2, 'c': 3}\r\n</pre></blockquote>\r\n\r\n<p>Keys can be removed from dictionaries similar to how you remove values from other collections: by using the <b>del</b> operator.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>del d2['b']</b>\r\n&gt;&gt;&gt; <b>d2</b>\r\n{'a': 1, 'c': 3}\r\n</pre></blockquote>\r\n\r\n<p>You can check for the presence of a key similar to the way you check for the presence of an element in a set, by using the <b>in</b> operator.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>'c' in d2</b>\r\nTrue\r\n&gt;&gt;&gt; <b>'b' in d2</b>\r\nFalse\r\n</pre></blockquote>\r\n\r\n<p>Dictionaries can also be iterated, though you do need to be aware of what you get when you do so.  When you iterate a dictionary, all you get back are the keys.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>for x in d2:\r\n        print(x)</b>\r\n\r\na\r\nc\r\n</pre></blockquote>\r\n\r\n<p>However, you can also ask a dictionary for all of its keys, all of its values, or all of its items.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>for x in d2.keys():\r\n        print(x)</b>\r\n\r\na\r\nc\r\n&gt;&gt;&gt; <b>for x in d2.values():\r\n        print(x)</b>\r\n\r\n1\r\n3\r\n&gt;&gt;&gt; <b>for x in d2.items():\r\n        print(x)</b>\r\n('a', 1)\r\n('c', 3)\r\n</pre></blockquote>\r\n\r\n<p>Notice that the latter of these, the <b>items()</b> method, returns <i>both</i> each key and its associated value.  The natural way to return two values is a tuple, so that's what Python returns.</p>\r\n\r\n<p class=\"subtitle\">Example: Calculating the occurrences of characters in a string</p>\r\n\r\n<p>Suppose that we wanted to write a function that takes a string as a parameter and can tell you how many time each different, unique character occurs in that string.  So, for example, if you called this function with the argument <b>'BOO BEAR'</b>, then you'd expect to see something that told you the following:</p>\r\n\r\n<ul>\r\n  <li>The character <b>B</b> appears twice</li>\r\n  <li>The character <b>O</b> appears twice</li>\r\n  <li>The character <B>E</b> appears once</li>\r\n  <li>The character <b>A</b> appears once</li>\r\n  <li>The character <b>R</b> appears once</li>\r\n</ul>\r\n\r\n<p>You might call this kind of information a <i>mapping</i>, similar to a mathematical function.  The order of the characters in our answer is irrelevant &mdash; except maybe from a standpoint of how we might display it, but that's a user interface problem, rather than a problem that this function should solve.  All we want to know is what characters occur and, for each of those, how many times they occur.</p>\r\n\r\n<p>Dictionaries are a perfect way to communicate this kind of information.  The keys would be the characters; the values would be the number of times each character appears.  We would only bother to store information for the characters that appeared at all; if a character doesn't appear, it will not be part of our output.</p>\r\n\r\n<p>The following is one way you could write that function.</p>\r\n\r\n<blockquote><pre>\r\ndef count_chars(s: str) -&gt; dict:\r\n    # Start with an empty dictionary\r\n    counts = dict()\r\n\r\n    # Iterate through the characters of the string.  For characters that\r\n    # we've seen before, increment the count we already have.  For\r\n    # newly-seen characters, add them to the dictionary with a count of 1.\r\n    for c in s:\r\n        if c in counts:\r\n            counts[c] += 1\r\n        else:\r\n            counts[c] = 1\r\n\r\n    return counts\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}