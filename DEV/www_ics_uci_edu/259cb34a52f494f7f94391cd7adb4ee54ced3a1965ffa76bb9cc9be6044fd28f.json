{"url": "https://www.ics.uci.edu/~ejw/versioning/arch/0111.html", "content": "<!-- received=\"Tue Aug 27 00:28:30 1996 PDT\" -->\n<!-- sent=\"Tue, 27 Aug 1996 00:28:28 -0700\" -->\n<!-- name=\"Yaron Goland\" -->\n<!-- email=\"yarong@microsoft.com\" -->\n<!-- subject=\"Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)\" -->\n<!-- id=\"ae428a5409021004bb29@[18.52.0.181]\" -->\n<!-- inreplyto=\"\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)</title>\n<h1>Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)</h1>\n<b>Yaron Goland</b> (<a href=\"mailto:yarong@microsoft.com\"><i>yarong@microsoft.com</i></a>)<br>\n<i>Tue, 27 Aug 1996 00:28:28 -0700</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#111\">[ date ]</a><a href=\"thread.html#111\">[ thread ]</a><a href=\"subject.html#111\">[ subject ]</a><a href=\"author.html#111\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Previous message:</b> <a href=\"0110.html\">Yaron Goland: \"MS Versioning Requirements Spec\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\nMicrosoft Feature Support List (V 0.1, ALPHA, 8/26/96)\nby Yaron Y. Goland (<a href=\"mailto:yarong@microsoft.com\">yarong@microsoft.com</a>)\nThe following is the list of features which I have found that Microsoft \nrequires in order to express the full functionality of its products across \nHTTP. The \"I have found\" caveat means that the list will change as I \ncontinue my investigations.  In addition this is an ALPHA version of the \ndocument and is only being released at the behest of Jim Whitehead so that \n'something' would get into the HTTP v1.2 working group. Please excuse any \ncontradictions or omissions, over the coming days I will be working with \nJim to clean up any problems and sync this document with his own work.\nThis list is a result of the HTTP Versioning and File Control Project, \nwhich currently consists of just me. However I am also the program manager \nfor WinInet which is the API that will provide support for HTTP \nversioning.\nWhile I have proposed solutions to the needs expressed in this document \nthese solutions are in a rough form and serve only to clarify the purpose \nof the particular feature. I am open to a complete rewrite of the \nimplementation so long as it maintains the same underlying feature set.\nFinally, this document does not represent all of the features I would like \nto add, only the features that I am aware Microsoft requires.\n1. File Control Features\nBy its very nature versioning requires strong file support features. \nWithout them the overhead for even basic versioning tasks quickly grows out \nof control.\n1.1 Attributes\nThe list of attributes one would want to associate with a file or directory \nis endless. Rather than trying to specify them all I would recommend that \nthe link facility, as described below, be used. A link would be available \nto an attribute entity whose format will be decided later. I do have a list \nof attributes, such as if a URL can be multiply checked out or not, but \ngiving it here would just clutter this paragraph.\n1.2 Copy\nCurrently Copy can only be implemented through a combination of GET and \nPUT/POST. In cases were the file is being moved from one computer to \nanother this is quite appropriate. It is unlikely that servers will be \nwilling to take upon themselves the difficulties inherent in accepting a \nrequest from one source and then performing an action on another source due \nto that request. This opens the door to all sorts of abuses. However in the \ncase were URLs are being moved around on the same server a COPY verb would \nprove extremely useful. Given the need for this command and given the heavy \ncosts inherent in the current GET-&gt;PUT/POST method I believe it is \nappropriate to implement a COPY verb. Note that the COPY verb should not be \nrestricted to only copying within one site and instead should specify which \nURL to copy from and which URL to copy to. The previous comments to the \ncontrary, a site should have the freedom to accept requests to copy to \nforeign sites.\nWhile I am fairly agnostic on the issue of a MCopy I think that sticky \nheaders makes it a bit useless.\n1.3 Directories\nThis is not a request for a command but rather a discussion of the \nimplications of directories. Directory URLs are unique entities and should \nbe allowable as arguments to all commands included in this document. Thus a \nmove or copy should work on the directory URL by moving the URL and all of \nits subordinate URLs to a new location with proper URL name translation. A \nGET on a directory URL should return a HTML file containing the directory \ninformation. I would recommend we standardize on the SiteMap format which \nprovides for a HTML file containing hierarchical information. A tag should \nalso be available to indicate if an action to be performed on recursively \non a directory. Finally some sort of wildcard support is required. This is \nnot necessarily restricted to just directory URLs and would be useful as a \nback door to M* verbs.\n1.4 Delete\nDelete functionality already exists in HTTP. It is included for \ncompleteness.\n1.5 [Full | Partial] Write [Lock | Unlock]\nA lock is defined here as the ability to prevent anyone from doing anything \nto a particular URL if it is locked. The owner of the lock however may do \nanything to the URL they want, including deleting it. If the URL is deleted \nthe lock still exists. Meaning no one can create that URL or perform any \ncommands on that URL until the lock is released. With this in mind we need \nthe ability to do write locks on multiple files. We also need a way to \nexplicitly override locks.\nThis is a major feature issue for Microsoft. The ability to Lock a file \nboth partially and completely is desperately needed. Furthermore support \nfor multiple simultaneous file locks is equally needed. We need to begin by \nasserting that PUT HTTP requests are atomic. This may seem obvious but \nshould nevertheless be stated. Thus the locking problem is reduced to the \nissue of locking a file over multiple requests. Dependency on time outs is \ndangerous as a request may be submitted after the lock has timed out, the \nresulting ugliness is self evident. Thus a token based lock system seems to \nbe the best solution. A set of URLs would be submitted as a lock request. \nIf the lock is successful the system will respond with an opaque set of \noctets. These octets are a token that refers to the lock. All further \nrequests on those URLs must include the lock token. If they do not then \nthey are treated as normal requests, with success or failure based upon \nnormal behavior given the existence of a lock. If the lock is removed, by \nexpiration or because of override, the request with the lock token will \nfail with an appropriate error indication. Facilities should also exist to \nadd or remove URLs from a particular lock token. Locks should be indefinite \nbut a non-activity time out should apply. This time out should be generous \nand should not be used as a means of removing a lock from an application \nthat is abusing the lock facility.\nLocks should be removed through one of three means: the lock owner asking \nto remove the lock, an activity time out, or another user overriding the \nlock. It is up to the system to determine who can override a lock however \nour needs in this area will be explained in the security section below.\nFinally, I generally do not like adding verbs. As such I would use PEP to \nput lock and unlock onto a PUT with no body. I would also use byte ranges \nto support partial locks on files. In addition one should be able to use \nthe PUT tags to request a lock during another request. So for example a \nlock request tag could be added to a GET. The GET will only succeed if the \nlock can be executed. A lock token will then be added to the header of the \nresponse or an error message returned.\n1.6 Get\nAgain, completeness.\n1.7 Link\nLinks are needed for a variety of reasons including associating the \npre-processed and processed versions of files and establishing shadow \ndirectories. The variety of values one would want to associate with a link \nare numerous and argue that links should be made into first class objects. \nA tag would be added to the HTML header of a file indicating the URLs of \nany associated links. The link URL should be equal to the URL of the \nrequested entity with appropriate tags appended to the end. The client \nwould then request the links using a normal GET. The bodies of the replies \nwould contain whatever information was relevant to the link.\nIn order to ease administration it is also possible that each linked file \nwill have a URL associated with it that will list all the links attached to \nthis file.\nA PUT with appropriate tags should be used to associate a link body with \none or more URLs. Note that there is no restriction on the number of files \na link URL may be attached to.\nOnce a link is made into a URL all sorts of powerful mechanisms become \npossible.\n1.8 Move\nWhile arguments can be made for a move verb I would suggest a copy followed \nby a delete.\n1.9 Partial [Read | Write]\nPartial read support is already provided through byte ranges. Partial write \nsupport is problematic because servers that do not support partial writes \nwould drop the byte range header and execute a write over file. I would \nsuggest implementing partial write through a PEP extension as a means of \nsolving this problem.\n1.10 Put\nThe only question here is should there exist a tag which tells the server \nthat if the file already exists it should not be overwritten and an error \nshould be returned. The same functionality can be achieved through a head \nrequest.\n1.11 Rename\nThis can be handled through copy as specified above. Our only requirement \nis that renames be possible without having to move the file from the server \nto the client and back again.\n2. Versioning Control Features\n2.1 Comments\nWhy an action has occurred is just as important as the action itself. Thus \na comment facility is necessary. I would suggest either comment tags, one \nfor strings and another for URLs, or the Link facility be used. Given the \nfrequency that comments are used it may be appropriate to implement the \ncomment tags and then define a method by which the tags are turned into \nlinks. The idea is that we do not want to have every action take two parts, \nthe action and then the addition of a link in order to add a comment.\n2.2 Currently Checked Out Files\nA tag should be added to modify a GET request to indicate that check out \ninformation is request for the specified URL. If the URL is a directory \nthen information will be provided on all the entries in that directory. The \nsuggested recursive tag should also apply. This could easily be implemented \nas a predefined link type.\n2.3 Destroy\nA deleted object is removed from normal view in histories or directories \nbut will be visible in a link associated with a directory which specified \ndeleted but not destroyed items. As such a tag should be added to the \ndelete command specifying if the delete is meant as a delete or a destroy.\n2.4 History\nA history for a document or directory is necessary to show the user what \nversions have existed and what their comments are. This can be implemented \nthrough the attributes link. Specific formats for the history file can be \ndecided later. Though said formats must address the difference between \nlinear and branched histories.\n2.5 Merge\nSometime a Check In will result in a conflict between a currently existing \nURL and the Checked In URL. If the server has facilities to detect such \nconflicts then the server may request that the client resolve the \nconflicts. At this point the server should send a PUT with a merge tag to \nthe client. The body of the PUT will either contain the entity to merge \nwith or the URL of the entity to be merged with. The reason for the pointer \nis that not all clients will be able to merge all types of files and may \nreturn an error message so indicating. By allowing just the URL to be sent \nthe server is able to save bandwidth in case the client can not support the \nmerge.\n2.6 [Multi | Single] Check [In | Out]\nThe only real difference between check in/out and lock/unlock is that \nmultiple users may have that ability to check out a single resource while \nonly a single user may have a lock. There is also the issue of an entity \nbody but not all check ins even use an entity body. In fact a check in \nwithout an entity body is just an UnCheckOut. The security, override, and \nimplementation format for lock also apply here.\nAnother issue is the meaning of checking in a directory. In this case the \nbody of the message should be a multi-part mime file with HTTP headers \nindicating the URLs of each entry. Entries which are not included are \nassumed to be unchanged.\n2.7 Search\nThe ability to search a site is crucial. Facilities for grep, wild card \nsearch, and searches on check in/out status are needed. It is tempting to \nimplement these functions using URL munges as they are now done, with the \nrecognition of directory structure this would be very powerful. I have no \nparticular views on the subject.\n2.8 Version\nA facility to specify the version identifier is needed. This identifier \nshould be expressed by appending it to the end of the URL for the entity. \nThe appended format should be defined so that it is always possible to \nidentify and remove the appended entity.\nThis however opens the question of what sort of versioning identifiers \nshould be used. Integer? Decimal? Alphabetic? Opaque Token? All of the \nabove? Currently we only require integer however all of the above is \nprobably the best solution. When a URL is checked in the server's \nconfirmation reply should include the URL assigned to the entity. The reply \nshould be in the appended format. If information regarding the relationship \nof URLs is needed then a history file should be requested. The format of \nthe history file will clearly indicate the relationship of the URLs.\nWhen a Check In/Out or Lock/UnLock request is made on a URL that is not in \nappended format the request should apply to all versions of that URL.\n3. Access Control Features\nSecurity is a murky territory I am sure we would all rather avoid but the \nreality is that security is absolutely vital to versioning. If a robust \nsecurity solution is not provided for then proprietary ones will be \nintroduced and all of our work will be for not.\nThe security model that would best meet our needs is a combination of group \nand individual based security attributes. Each entity, either group or \nindividual, can be assigned security rights which apply to one or more URLs \nwith the option to apply the rights recursively. The actual rights would be \na listing of the verbs and tags in this document. A user would only be able \nto use a tag or verb if they have the right to. This combination of rights, \nboth to users and groups, to URLs both singly, in groups, and recursively \nthrough the URL hierarchy will meet our needs nicely.\nIn addition facilities to modify these rights are needed. I am not \nreligious on how they are implemented, only that they exist. I will assume \nthe existence of SSL or similar protocol to secure the transmission line. \nThe authorization header is more than sufficient to uniquely identify a \nuser.\n4. Comments on the WWW Versioning Support Draft Proposal v 0.1\n4.1 Flags\nFlags are not necessary here as values are set via links which point to \narbitrary entity bodies, probably HTML files, whose format can be decided \nlater. I provide a facility for finding out who has what files checked out \nthrough links and while I have not specified it, a similar facility could \nbe provided for finding out who has which locks.\n4.2 Lock\nNo time out value is really necessary to meet Microsoft's needs. We \ncompletely rely on the over ride facility. I only put the time out value \ninto the document for completeness sake. As long as a \"NEVER\" value is \navailable for the time out you will hear no complaints from me.\n4.3 Unlock\nI will count on the security set up to clear up cases of who may and may \nnot unlock a URL. Obviously the person who locked it may unlock it but we \nalso rely upon 'authorized' users to be able to unlock a file. In some \ncases that means users with the same security level and in others those \nwith special security levels. This definition is enforced by the server and \nthe authorization control section provides a definition more than powerful \nenough to handle all cases relevant to Microsoft.\n4.4 Use\nWe do not need such a facility currently but it is still a neat idea. I can \nsee circumstances were we would want it. Though my general dislike of \nadding verbs does make me a bit wary.\n4.5 Configurations\nWe provide this functionality through a number of other means. Specifically \nusing SiteMaps for directory listings. However this is still an interesting \nfeature and I will look at it further.\n4.6 Derivations File\nAKA a history file which is provided for.\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Previous message:</b> <a href=\"0110.html\">Yaron Goland: \"MS Versioning Requirements Spec\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n", "encoding": "ascii"}