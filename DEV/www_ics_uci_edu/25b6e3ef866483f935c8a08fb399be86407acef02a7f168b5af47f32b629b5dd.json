{"url": "https://www.ics.uci.edu/~kay/courses/141/bst.txt", "content": "\n;;; Binary Search Tree (BST)\n;\n; This code implements a simple BST of integers.\n;\n; Our binary tree will be represented as follows:\n; either an empty list or a list with three elements:  \n; the value, the left subtree, and the right subtree.\n; So, the tree\n;                      5\n;                    /   \\\n;                  4       6\n; would be (5 (4 () ()) (6 () ())).\n;\n; Note that only the six routines below (two constructors,\n; one predicate, and three field-selectors) depend on the\n; tree being implemented as described above.  All the rest\n; of the routines are written in terms of these six, so if\n; we chose to change the representation, we could do it by\n; changing only these six routines.\n;\n; Remember as you read that these routines are written in \n; the functional style---they RETURN something (in many\n; cases a binary search tree) rather than changing any \n; existing values in place.\n\n(define bst-create-empty   ; constructor---create an empty BST\n  (lambda ()\n    '()))\n\n(define bst-create         ; constructor\n  (lambda (value left-subtree right-subtree)\n    (list value left-subtree right-subtree)))\n\n(define bst-isempty? (lambda (BST) (null? BST)))\n\n; Field selector routines.  These make the rest of the code\n; a lot clearer since we can say bst-left-subtree instead of\n; (first (rest BST)) )\n(define bst-value (lambda (BST) (first BST)))\n(define bst-left-subtree (lambda (BST) (first (rest BST))))\n(define bst-right-subtree (lambda (BST) (first (rest (rest BST)))))\n\n(define bst-add    ; return tree with value added\n  (lambda (BST value)\n    (cond\n      ((bst-isempty? BST)           ; if empty, create a new node\n       (bst-create value (bst-create-empty) (bst-create-empty))) \n      ((< value (bst-value BST))    ; add node to left subtree \n       (bst-create (bst-value BST)  ; (functionally, by building new tree)\n                   (bst-add (bst-left-subtree BST) value)\n                   (bst-right-subtree BST)))\n      ((> value (bst-value BST))    ; add node to right subtree\n       (bst-create (bst-value BST)\n                   (bst-left-subtree BST)\n                   (bst-add (bst-right-subtree BST) value)))\n      (else BST))))                 ; it's already there; don't do anything\n\n(define bst-delete   ; return tree with value deleted\n  (lambda (BST value)\n    (cond\n      ((bst-isempty? BST) (bst-create-empty))\n      ((= value (bst-value BST)) (bst-delete-root BST))\n      ((< value (bst-value BST))\n       (bst-create (bst-value BST)\n                   (bst-delete (bst-left-subtree BST) value)\n                   (bst-right-subtree BST)))\n      (else ; (> value (bst-value BST)) -- commented out for efficiency\n        (bst-create (bst-value BST)\n                    (bst-left-subtree BST)\n                    (bst-delete (bst-right-subtree BST) value))))))\n\n(define bst-delete-root   ; return tree with root deleted\n  (lambda (BST)\n    (cond\n      ; If the root has no children, result is empty tree\n      ((bst-isleaf? BST) (bst-create-empty))\n      ; If the root has one child (right or left), \n      ; result is that child (and descendants)\n      ((bst-isempty? (bst-left-subtree BST)) (bst-right-subtree BST))\n      ((bst-isempty? (bst-right-subtree BST)) (bst-left-subtree BST))\n      ; If the root has two children, \n      ; replace value with leftmost child of right subtree\n      (else (let* ((replacement-value\n                     (bst-value (bst-leftmost-child (bst-right-subtree BST))))\n                   (new-right-subtree\n                     (bst-delete (bst-right-subtree BST) replacement-value)))\n              (bst-create replacement-value \n                          (bst-left-subtree BST) \n                          new-right-subtree))))))\n\n(define bst-isleaf?\n  (lambda (BST)\n    (and (bst-isempty? (bst-left-subtree BST))\n         (bst-isempty? (bst-right-subtree BST)))))\n\n(define bst-leftmost-child\n  (lambda (BST)\n    (cond\n      ((bst-isempty? BST) (bst-create-empty))\n      ((bst-isempty? (bst-left-subtree BST)) BST)\n      (else (bst-leftmost-child (bst-left-subtree BST))))))\n\n(define bst-member?   ; find a value in the tree\n  (lambda (BST value)\n    (cond\n      ((bst-isempty? BST) #f)\n      ((= value (bst-value BST)) #t)\n      ((< value (bst-value BST)) (bst-member? (bst-left-subtree BST) value))\n      (else (bst-member? (bst-right-subtree BST) value))))))\n\n(define bst-traverse-inorder   ; return an inorder list of values\n  (lambda (BST)                ; We return a standard list so we can cross \n    (cond                      ; the abstraction barrier safely.  The calling\n      ((bst-isempty? BST) '()) ; program can then process the list as it likes.\n      (else (append\n              (bst-traverse-inorder (bst-left-subtree BST))\n              (list (bst-value BST)) ; each argument to append must be a list\n              (bst-traverse-inorder (bst-right-subtree BST)))))))\n\n(define bst-size  ; number of items in the tree\n  (lambda (BST)\n    (cond\n      ((bst-isempty? BST) 0)\n      (else (+ 1\n               (bst-size (bst-left-subtree BST))\n               (bst-size (bst-right-subtree BST)))))))\n\n(define bst-height\n  (lambda (BST)\n    (cond\n      ((bst-isempty? BST) -1) ; by definition empty tree's height is -1\n      (else (+ 1 (max (bst-height (bst-left-subtree BST))\n                      (bst-height (bst-right-subtree BST))))))))\n\n(define bst-balanced?         ; check for perfect balance\n  (lambda (BST)\n    (cond\n      ((bst-isempty? BST) #t)\n      (else (and (= (bst-height (bst-left-subtree BST)) \n                           (bst-balanced? (bst-left-subtree BST))\n                 (bst-balanced? (bst-right-subtree BST)))))))\n  \n(define bst-shortest-path-to-leaf\n  (lambda (BST)\n    (cond\n      ((bst-isempty? BST) -1)\n      (else (+ 1 (min (bst-shortest-path-to-leaf (bst-left-subtree BST))\n                      (bst-shortest-path-to-leaf (bst-right-subtree BST))))))))\n  \n(define bst-relatively-balanced?\n  (lambda (BST)\n    (>= 1 (abs (- (bst-height BST) (bst-shortest-path-to-leaf BST))))))\n  \n; Notes\n;\n; The names of all the binary-search-tree functions above \n; start with \"bst-\".  This is just a matter of convention;\n; it's not required.  In fact, it's possible to build\n; object-oriented code in Scheme, where the operations \n; would be associated with each object so we wouldn't need\n; either the \"bst-\" prefix or the BST parameter.\n", "encoding": "ascii"}