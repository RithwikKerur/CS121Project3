{"url": "https://www.ics.uci.edu/~magda/Courses/ics156/Man_TCPDUMP.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\r\n<!-- saved from url=(0049)http://www.ics.uci.edu/~lchen/ics156/tcpdump.html -->\r\n<HTML><HEAD><TITLE>Manpage of TCPDUMP</TITLE>\r\n<META content=\"text/html; charset=windows-1252\" http-equiv=Content-Type>\r\n<META content=\"MSHTML 5.00.2920.0\" name=GENERATOR></HEAD>\r\n<BODY>Content-type: text/html \r\n<H1>TCPDUMP</H1>Section: Maintenance Commands (8)<BR>Updated: 30 June 1997<BR><A \r\nhref=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#index\">Index</A> <A \r\nhref=\"http://localhost/cgi-bin/man/man2html\">Return to Main Contents</A>\r\n<HR>\r\n <A name=lbAB>&nbsp;</A> \r\n<H2>NAME</H2>tcpdump - dump traffic on a network <A name=lbAC>&nbsp;</A> \r\n<H2>SYNOPSIS</H2><B>tcpdump</B> [ <B>-adeflnNOpqStvx</B> ] [ <B>-c</B> \r\n<I>count</I> ] [ <B>-F</B> <I>file</I> ] \r\n<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ <B>-i</B> \r\n<I>interface</I> ] [ <B>-r</B> <I>file</I> ] [ <B>-s</B> <I>snaplen</I> ] \r\n<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ <B>-T</B> <I>type</I> \r\n] [ <B>-w</B> <I>file</I> ] [ <I>expression</I> ] <BR><A name=lbAD>&nbsp;</A> \r\n<H2>DESCRIPTION</H2>\r\n<P><I>Tcpdump</I> prints out the headers of packets on a network interface that \r\nmatch the boolean <I>expression</I>. \r\n<P><B>Under SunOS with nit or bpf:</B> To run <I>tcpdump</I> you must have read \r\naccess to <I>/dev/nit</I> or <I>/dev/bpf*</I>. <B>Under Solaris with dlpi:</B> \r\nYou must have read access to the network pseudo device, e.g. <I>/dev/le</I>. \r\n<B>Under HP-UX with dlpi:</B> You must be root or it must be installed setuid to \r\nroot. <B>Under IRIX with snoop:</B> You must be root or it must be installed \r\nsetuid to root. <B>Under Linux:</B> You must be root or it must be installed \r\nsetuid to root. <B>Under Ultrix and Digital UNIX:</B> Once the super-user has \r\nenabled promiscuous-mode operation using <I><A \r\nhref=\"http://localhost/cgi-bin/man/man2html?8+pfconfig\">pfconfig</A></I>(8), any \r\nuser may run <B>tcpdump</B>. <B>Under BSD:</B> You must have read access to \r\n<I>/dev/bpf*</I>. <A name=lbAE>&nbsp;</A> \r\n<H2>OPTIONS</H2>\r\n<DL compact>\r\n  <DT><B>-a</B> \r\n  <DD>Attempt to convert network and broadcast addresses to names. \r\n  <DT><B>-c</B> \r\n  <DD>Exit after receiving <I>count</I> packets. \r\n  <DT><B>-d</B> \r\n  <DD>Dump the compiled packet-matching code in a human readable form to \r\n  standard output and stop. \r\n  <DT><B>-dd</B> \r\n  <DD>Dump packet-matching code as a <B>C</B> program fragment. \r\n  <DT><B>-ddd</B> \r\n  <DD>Dump packet-matching code as decimal numbers (preceded with a count). \r\n  <DT><B>-e</B> \r\n  <DD>Print the link-level header on each dump line. \r\n  <DT><B>-f</B> \r\n  <DD>Print `foreign' internet addresses numerically rather than symbolically \r\n  (this option is intended to get around serious brain damage in Sun's yp server \r\n  --- usually it hangs forever translating non-local internet numbers). \r\n  <DT><B>-F</B> \r\n  <DD>Use <I>file</I> as input for the filter expression. An additional \r\n  expression given on the command line is ignored. \r\n  <DT><B>-i</B> \r\n  <DD>Listen on <I>interface</I>. If unspecified, <I>tcpdump</I> searches the \r\n  system interface list for the lowest numbered, configured up interface \r\n  (excluding loopback). Ties are broken by choosing the earliest match. \r\n  <DT><B>-l</B> \r\n  <DD>Make stdout line buffered. Useful if you want to see the data while \r\n  capturing it. E.g., <BR>``tcpdump&nbsp;&nbsp;-l&nbsp;&nbsp;|&nbsp;&nbsp;tee \r\n  dat'' or ``tcpdump&nbsp;&nbsp;-l &nbsp;&nbsp;&gt; \r\n  dat&nbsp;&nbsp;&amp;&nbsp;&nbsp;tail&nbsp;&nbsp;-f&nbsp;&nbsp;dat''. \r\n  <DT><B>-n</B> \r\n  <DD>Don't convert addresses (i.e., host addresses, port numbers, etc.) to \r\n  names. \r\n  <DT><B>-N</B> \r\n  <DD>Don't print domain name qualification of host names. E.g., if you give \r\n  this flag then <I>tcpdump</I> will print ``nic'' instead of ``nic.ddn.mil''. \r\n  <DT><B>-O</B> \r\n  <DD>Do not run the packet-matching code optimizer. This is useful only if you \r\n  suspect a bug in the optimizer. \r\n  <DT><B>-p</B> \r\n  <DD><I>Don't</I> put the interface into promiscuous mode. Note that the \r\n  interface might be in promiscuous mode for some other reason; hence, `-p' \r\n  cannot be used as an abbreviation for `ether host {local-hw-addr} or ether \r\n  broadcast'. \r\n  <DT><B>-q</B> \r\n  <DD>Quick (quiet?) output. Print less protocol information so output lines are \r\n  shorter. \r\n  <DT><B>-r</B> \r\n  <DD>Read packets from <I>file</I> (which was created with the -w option). \r\n  Standard input is used if <I>file</I> is ``-''. \r\n  <DT><B>-s</B> \r\n  <DD>Snarf <I>snaplen</I> bytes of data from each packet rather than the \r\n  default of 68 (with SunOS's NIT, the minimum is actually 96). 68 bytes is \r\n  adequate for IP, ICMP, TCP and UDP but may truncate protocol information from \r\n  name server and NFS packets (see below). Packets truncated because of a \r\n  limited snapshot are indicated in the output with ``[|<I>proto</I>]'', where \r\n  <I>proto</I> is the name of the protocol level at which the truncation has \r\n  occurred. Note that taking larger snapshots both increases the amount of time \r\n  it takes to process packets and, effectively, decreases the amount of packet \r\n  buffering. This may cause packets to be lost. You should limit <I>snaplen</I> \r\n  to the smallest number that will capture the protocol information you're \r\n  interested in. \r\n  <DT><B>-T</B> \r\n  <DD>Force packets selected by \"<I>expression</I>\" to be interpreted the \r\n  specified <I>type</I>. Currently known types are <B>rpc</B> (Remote Procedure \r\n  Call), <B>rtp</B> (Real-Time Applications protocol), <B>rtcp</B> (Real-Time \r\n  Applications control protocol), <B>vat</B> (Visual Audio Tool), <B>wb</B> \r\n  (distributed White Board), and <B>snmp</B> (Simple Network Management \r\n  Protocol). \r\n  <DT><B>-S</B> \r\n  <DD>Print absolute, rather than relative, TCP sequence numbers. \r\n  <DT><B>-t</B> \r\n  <DD><I>Don't</I> print a timestamp on each dump line. \r\n  <DT><B>-tt</B> \r\n  <DD>Print an unformatted timestamp on each dump line. \r\n  <DT><B>-v</B> \r\n  <DD>(Slightly more) verbose output. For example, the time to live and type of \r\n  service information in an IP packet is printed. \r\n  <DT><B>-vv</B> \r\n  <DD>Even more verbose output. For example, additional fields are printed from \r\n  NFS reply packets. \r\n  <DT><B>-w</B> \r\n  <DD>Write the raw packets to <I>file</I> rather than parsing and printing them \r\n  out. They can later be printed with the -r option. Standard output is used if \r\n  <I>file</I> is ``-''. \r\n  <DT><B>-x</B> \r\n  <DD>Print each packet (minus its link level header) in hex. The smaller of the \r\n  entire packet or <I>snaplen</I> bytes will be printed. \r\n  <DT><I>expression</I>\r\n  <DD>\r\n  <DL compact>\r\n    <DT>\r\n    <DD>selects which packets will be dumped. If no <I>expression</I> is given, \r\n    all packets on the net will be dumped. Otherwise, only packets for which \r\n    <I>expression</I> is `true' will be dumped. \r\n    <P>The <I>expression</I> consists of one or more <I>primitives.</I> \r\n    Primitives usually consist of an <I>id</I> (name or number) preceded by one \r\n    or more qualifiers. There are three different kinds of qualifier: \r\n    <DL compact>\r\n      <DT><I>type</I>\r\n      <DD>qualifiers say what kind of thing the id name or number refers to. \r\n      Possible types are <B>host</B>, <B>net</B> and <B>port</B>. E.g., `host \r\n      foo', `net 128.3', `port 20'. If there is no type qualifier, <B>host</B> \r\n      is assumed. \r\n      <DT><I>dir</I>\r\n      <DD>qualifiers specify a particular transfer direction to and/or from \r\n      <I>id.</I> Possible directions are <B>src</B>, <B>dst</B>, <B>src or \r\n      dst</B> and <B>src and</B> <B>dst</B>. E.g., `src foo', `dst net 128.3', \r\n      `src or dst port ftp-data'. If there is no dir qualifier, <B>src or \r\n      dst</B> is assumed. For `null' link layers (i.e. point to point protocols \r\n      such as slip) the <B>inbound</B> and <B>outbound</B> qualifiers can be \r\n      used to specify a desired direction. \r\n      <DT><I>proto</I>\r\n      <DD>qualifiers restrict the match to a particular protocol. Possible \r\n      protos are: <B>ether</B>, <B>fddi</B>, <B>ip</B>, <B>arp</B>, <B>rarp</B>, \r\n      <B>decnet</B>, <B>lat</B>, <B>sca</B>, <B>moprc</B>, <B>mopdl</B>, \r\n      <B>tcp</B> and <B>udp</B>. E.g., `ether src foo', `arp net 128.3', `tcp \r\n      port 21'. If there is no proto qualifier, all protocols consistent with \r\n      the type are assumed. E.g., `src foo' means `(ip or arp or rarp) src foo' \r\n      (except the latter is not legal syntax), `net bar' means `(ip or arp or \r\n      rarp) net bar' and `port 53' means `(tcp or udp) port 53'. </DD></DL>\r\n    <P>[`fddi' is actually an alias for `ether'; the parser treats them \r\n    identically as meaning ``the data link level used on the specified network \r\n    interface.'' FDDI headers contain Ethernet-like source and destination \r\n    addresses, and often contain Ethernet-like packet types, so you can filter \r\n    on these FDDI fields just as with the analogous Ethernet fields. FDDI \r\n    headers also contain other fields, but you cannot name them explicitly in a \r\n    filter expression.] \r\n    <P>In addition to the above, there are some special `primitive' keywords \r\n    that don't follow the pattern: <B>gateway</B>, <B>broadcast</B>, \r\n    <B>less</B>, <B>greater</B> and arithmetic expressions. All of these are \r\n    described below. \r\n    <P>More complex filter expressions are built up by using the words \r\n    <B>and</B>, <B>or</B> and <B>not</B> to combine primitives. E.g., `host foo \r\n    and not port ftp and not port ftp-data'. To save typing, identical qualifier \r\n    lists can be omitted. E.g., `tcp dst port ftp or ftp-data or domain' is \r\n    exactly the same as `tcp dst port ftp or tcp dst port ftp-data or tcp dst \r\n    port domain'. \r\n    <P>Allowable primitives are: \r\n    <DL compact>\r\n      <DT><B>dst host </B><I>host</I>\r\n      <DD>True if the IP destination field of the packet is <I>host</I>, which \r\n      may be either an address or a name. \r\n      <DT><B>src host </B><I>host</I>\r\n      <DD>True if the IP source field of the packet is <I>host</I>. \r\n      <DT><B>host </B><I>host</I>\r\n      <DD>True if either the IP source or destination of the packet is \r\n      <I>host</I>. Any of the above host expressions can be prepended with the \r\n      keywords, <B>ip</B>, <B>arp</B>, or <B>rarp</B> as in: <PRE><B>ip host </B><I>host</I>\r\n</PRE>which is equivalent to: <PRE><B>ether proto </B><I>\\ip</I><B> and host </B><I>host</I>\r\n</PRE>If <I>host</I> is a name with multiple IP addresses, each address \r\n      will be checked for a match. \r\n      <DT><B>ether dst </B><I>ehost</I>\r\n      <DD>True if the ethernet destination address is <I>ehost</I>. <I>Ehost</I> \r\n      may be either a name from /etc/ethers or a number (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?3N+ethers\">ethers</A></I>(3N) \r\n      for numeric format). \r\n      <DT><B>ether src </B><I>ehost</I>\r\n      <DD>True if the ethernet source address is <I>ehost</I>. \r\n      <DT><B>ether host </B><I>ehost</I>\r\n      <DD>True if either the ethernet source or destination address is \r\n      <I>ehost</I>. \r\n      <DT><B>gateway</B> <I>host</I>\r\n      <DD>True if the packet used <I>host</I> as a gateway. I.e., the ethernet \r\n      source or destination address was <I>host</I> but neither the IP source \r\n      nor the IP destination was <I>host</I>. <I>Host</I> must be a name and \r\n      must be found in both /etc/hosts and /etc/ethers. (An equivalent \r\n      expression is <PRE><B>ether host </B><I>ehost </I><B>and not host </B><I>host</I>\r\n</PRE>which can be used with either names or numbers for <I>host / \r\n      ehost</I>.) \r\n      <DT><B>dst net </B><I>net</I>\r\n      <DD>True if the IP destination address of the packet has a network number \r\n      of <I>net</I>. <I>Net</I> may be either a name from /etc/networks or a \r\n      network number (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4+networks\">networks</A>(4)</I> \r\n      for details). \r\n      <DT><B>src net </B><I>net</I>\r\n      <DD>True if the IP source address of the packet has a network number of \r\n      <I>net</I>. \r\n      <DT><B>net </B><I>net</I>\r\n      <DD>True if either the IP source or destination address of the packet has \r\n      a network number of <I>net</I>. \r\n      <DT><B>net </B><I>net</I> <B>mask </B><I>mask</I>\r\n      <DD>True if the IP address matches <I>net</I> with the specific netmask. \r\n      May be qualified with <B>src</B> or <B>dst</B>. \r\n      <DT><B>net </B><I>net</I>/<I>len</I>\r\n      <DD>True if the IP address matches <I>net</I> a netmask <I>len</I> bits \r\n      wide. May be qualified with <B>src</B> or <B>dst</B>. \r\n      <DT><B>dst port </B><I>port</I>\r\n      <DD>True if the packet is ip/tcp or ip/udp and has a destination port \r\n      value of <I>port</I>. The <I>port</I> can be a number or a name used in \r\n      /etc/services (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4P+tcp\">tcp</A></I>(4P) and \r\n      <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4P+udp\">udp</A></I>(4P)). If a \r\n      name is used, both the port number and protocol are checked. If a number \r\n      or ambiguous name is used, only the port number is checked (e.g., <B>dst \r\n      port 513</B> will print both tcp/login traffic and udp/who traffic, and \r\n      <B>port domain</B> will print both tcp/domain and udp/domain traffic). \r\n      <DT><B>src port </B><I>port</I>\r\n      <DD>True if the packet has a source port value of <I>port</I>. \r\n      <DT><B>port </B><I>port</I>\r\n      <DD>True if either the source or destination port of the packet is \r\n      <I>port</I>. Any of the above port expressions can be prepended with the \r\n      keywords, <B>tcp</B> or <B>udp</B>, as in: <PRE><B>tcp src port </B><I>port</I>\r\n</PRE>which matches only tcp packets whose source port is <I>port</I>. \r\n      <DT><B>less </B><I>length</I>\r\n      <DD>True if the packet has a length less than or equal to <I>length</I>. \r\n      This is equivalent to: <PRE><B>len &lt;= </B><I>length</I>.\r\n</PRE>\r\n      <DT><B>greater </B><I>length</I>\r\n      <DD>True if the packet has a length greater than or equal to \r\n      <I>length</I>. This is equivalent to: <PRE><B>len &gt;= </B><I>length</I>.\r\n</PRE>\r\n      <DT><B>ip proto </B><I>protocol</I>\r\n      <DD>True if the packet is an ip packet (see <I><A \r\n      href=\"http://localhost/cgi-bin/man/man2html?4P+ip\">ip</A></I>(4P)) of \r\n      protocol type <I>protocol</I>. <I>Protocol</I> can be a number or one of \r\n      the names <I>icmp</I>, <I>igrp</I>, <I>udp</I>, <I>nd</I>, or <I>tcp</I>. \r\n      Note that the identifiers <I>tcp</I>, <I>udp</I>, and <I>icmp</I> are also \r\n      keywords and must be escaped via backslash (\\), which is \\\\ in the \r\n      C-shell. \r\n      <DT><B>ether broadcast</B>\r\n      <DD>True if the packet is an ethernet broadcast packet. The <I>ether</I> \r\n      keyword is optional. \r\n      <DT><B>ip broadcast</B>\r\n      <DD>True if the packet is an IP broadcast packet. It checks for both the \r\n      all-zeroes and all-ones broadcast conventions, and looks up the local \r\n      subnet mask. \r\n      <DT><B>ether multicast</B>\r\n      <DD>True if the packet is an ethernet multicast packet. The <I>ether</I> \r\n      keyword is optional. This is shorthand for `<B>ether[0] &amp; 1 != 0</B>'. \r\n\r\n      <DT><B>ip multicast</B>\r\n      <DD>True if the packet is an IP multicast packet. \r\n      <DT><B>ether proto </B><I>protocol</I>\r\n      <DD>True if the packet is of ether type <I>protocol</I>. <I>Protocol</I> \r\n      can be a number or a name like <I>ip</I>, <I>arp</I>, or <I>rarp</I>. Note \r\n      these identifiers are also keywords and must be escaped via backslash (\\). \r\n      [In the case of FDDI (e.g., `<B>fddi protocol arp</B>'), the protocol \r\n      identification comes from the 802.2 Logical Link Control (LLC) header, \r\n      which is usually layered on top of the FDDI header. <I>Tcpdump</I> \r\n      assumes, when filtering on the protocol identifier, that all FDDI packets \r\n      include an LLC header, and that the LLC header is in so-called SNAP \r\n      format.] \r\n      <DT><B>decnet src </B><I>host</I>\r\n      <DD>True if the DECNET source address is <I>host</I>, which may be an \r\n      address of the form ``10.123'', or a DECNET host name. [DECNET host name \r\n      support is only available on Ultrix systems that are configured to run \r\n      DECNET.] \r\n      <DT><B>decnet dst </B><I>host</I>\r\n      <DD>True if the DECNET destination address is <I>host</I>. \r\n      <DT><B>decnet host </B><I>host</I>\r\n      <DD>True if either the DECNET source or destination address is \r\n      <I>host</I>. \r\n      <DT><B>ip</B>, <B>arp</B>, <B>rarp</B>, <B>decnet</B>\r\n      <DD>Abbreviations for: <PRE><B>ether proto </B><I>p</I>\r\n</PRE>where <I>p</I> is one of the above protocols. \r\n      <DT><B>lat</B>, <B>moprc</B>, <B>mopdl</B>\r\n      <DD>Abbreviations for: <PRE><B>ether proto </B><I>p</I>\r\n</PRE>where <I>p</I> is one of the above protocols. Note that \r\n      <I>tcpdump</I> does not currently know how to parse these protocols. \r\n      <DT><B>tcp</B>, <B>udp</B>, <B>icmp</B>\r\n      <DD>Abbreviations for: <PRE><B>ip proto </B><I>p</I>\r\n</PRE>where <I>p</I> is one of the above protocols. \r\n      <DT><I>expr relop expr</I>\r\n      <DD>True if the relation holds, where <I>relop</I> is one of &gt;, &lt;, \r\n      &gt;=, &lt;=, =, !=, and <I>expr</I> is an arithmetic expression composed \r\n      of integer constants (expressed in standard C syntax), the normal binary \r\n      operators [+, -, *, /, &amp;, |], a length operator, and special packet \r\n      data accessors. To access data inside the packet, use the following \r\n      syntax: <PRE><I>proto</I><B> [ </B><I>expr</I><B> : </B><I>size</I><B> ]</B>\r\n</PRE><I>Proto</I> is one of <B>ether, fddi, ip, arp, rarp, tcp, udp, \r\n      </B>or <B>icmp</B>, and indicates the protocol layer for the index \r\n      operation. The byte offset, relative to the indicated protocol layer, is \r\n      given by <I>expr</I>. <I>Size</I> is optional and indicates the number of \r\n      bytes in the field of interest; it can be either one, two, or four, and \r\n      defaults to one. The length operator, indicated by the keyword <B>len</B>, \r\n      gives the length of the packet. \r\n      <P>For example, `<B>ether[0] &amp; 1 != 0</B>' catches all multicast \r\n      traffic. The expression `<B>ip[0] &amp; 0xf != 5</B>' catches all IP \r\n      packets with options. The expression `<B>ip[6:2] &amp; 0x1fff = 0</B>' \r\n      catches only unfragmented datagrams and frag zero of fragmented datagrams. \r\n      This check is implicitly applied to the <B>tcp</B> and <B>udp</B> index \r\n      operations. For instance, <B>tcp[0]</B> always means the first byte of the \r\n      TCP <I>header</I>, and never means the first byte of an intervening \r\n      fragment. </P></DD></DL>\r\n    <P>Primitives may be combined using: \r\n    <DL compact>\r\n      <DT>\r\n      <DD>A parenthesized group of primitives and operators (parentheses are \r\n      special to the Shell and must be escaped). \r\n      <DT>\r\n      <DD>Negation (`<B>!</B>' or `<B>not</B>'). \r\n      <DT>\r\n      <DD>Concatenation (`<B>&amp;&amp;</B>' or `<B>and</B>'). \r\n      <DT>\r\n      <DD>Alternation (`<B>||</B>' or `<B>or</B>'). </DD></DL>\r\n    <P>Negation has highest precedence. Alternation and concatenation have equal \r\n    precedence and associate left to right. Note that explicit <B>and</B> \r\n    tokens, not juxtaposition, are now required for concatenation. \r\n    <P>If an identifier is given without a keyword, the most recent keyword is \r\n    assumed. For example, <PRE><B>not host vs and ace</B>\r\n</PRE>is short for <PRE><B>not host vs and host ace</B>\r\n</PRE>which should not be confused with <PRE><B>not ( host vs or ace )</B>\r\n</PRE>\r\n    <P>Expression arguments can be passed to tcpdump as either a single argument \r\n    or as multiple arguments, whichever is more convenient. Generally, if the \r\n    expression contains Shell metacharacters, it is easier to pass it as a \r\n    single, quoted argument. Multiple arguments are concatenated with spaces \r\n    before being parsed. </P></DD></DL></DD></DL><A name=lbAF>&nbsp;</A> \r\n<H2>EXAMPLES</H2>\r\n<P>To print all packets arriving at or departing from <I>sundown</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump host sundown</B>\r\n</PRE></DD></DL>\r\n<P>To print traffic between <I>helios</I> and either <I>hot</I> or <I>ace</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump host helios and \\( hot or ace \\)</B>\r\n</PRE></DD></DL>\r\n<P>To print all IP packets between <I>ace</I> and any host except <I>helios</I>: \r\n\r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump ip host ace and not helios</B>\r\n</PRE></DD></DL>\r\n<P>To print all traffic between local hosts and hosts at Berkeley: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump net ucb-ether</B>\r\n</PRE></DD></DL>\r\n<P>To print all ftp traffic through internet gateway <I>snup</I>: (note that the \r\nexpression is quoted to prevent the shell from (mis-)interpreting the \r\nparentheses): \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'gateway snup and (port ftp or ftp-data)'</B>\r\n</PRE></DD></DL>\r\n<P>To print traffic neither sourced from nor destined for local hosts (if you \r\ngateway to one other net, this stuff should never make it onto your local net). \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump ip and not net </B><I>localnet</I>\r\n</PRE></DD></DL>\r\n<P>To print the start and end packets (the SYN and FIN packets) of each TCP \r\nconversation that involves a non-local host. \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'tcp[13] &amp; 3 != 0 and not src and dst net </B><I>localnet</I>'\r\n</PRE></DD></DL>\r\n<P>To print IP packets longer than 576 bytes sent through gateway <I>snup</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'gateway snup and ip[2:2] &gt; 576'</B>\r\n</PRE></DD></DL>\r\n<P>To print IP broadcast or multicast packets that were <I>not</I> sent via \r\nethernet broadcast or multicast: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'ether[0] &amp; 1 = 0 and ip[16] &gt;= 224'</B>\r\n</PRE></DD></DL>\r\n<P>To print all ICMP packets that are not echo requests/replies (i.e., not ping \r\npackets): \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>tcpdump 'icmp[0] != 8 and icmp[0] != 0\"</B>\r\n</PRE></DD></DL><A name=lbAG>&nbsp;</A> \r\n<H2>OUTPUT FORMAT</H2>\r\n<P>The output of <I>tcpdump</I> is protocol dependent. The following gives a \r\nbrief description and examples of most of the formats. \r\n<P><B></B>Link Level Headers \r\n<P>If the '-e' option is given, the link level header is printed out. On \r\nethernets, the source and destination addresses, protocol, and packet length are \r\nprinted. \r\n<P>On FDDI networks, the '-e' option causes <I>tcpdump</I> to print the `frame \r\ncontrol' field, the source and destination addresses, and the packet length. \r\n(The `frame control' field governs the interpretation of the rest of the packet. \r\nNormal packets (such as those containing IP datagrams) are `async' packets, with \r\na priority value between 0 and 7; for example, `<B>async4</B>'. Such packets are \r\nassumed to contain an 802.2 Logical Link Control (LLC) packet; the LLC header is \r\nprinted if it is <I>not</I> an ISO datagram or a so-called SNAP packet. \r\n<P><I>(N.B.: The following description assumes familiarity with the SLIP \r\ncompression algorithm described in RFC-1144.)</I> \r\n<P>On SLIP links, a direction indicator (``I'' for inbound, ``O'' for outbound), \r\npacket type, and compression information are printed out. The packet type is \r\nprinted first. The three types are <I>ip</I>, <I>utcp</I>, and <I>ctcp</I>. No \r\nfurther link information is printed for <I>ip</I> packets. For TCP packets, the \r\nconnection identifier is printed following the type. If the packet is \r\ncompressed, its encoded header is printed out. The special cases are printed out \r\nas <B>*S+</B><I>n</I> and <B>*SA+</B><I>n</I>, where <I>n</I> is the amount by \r\nwhich the sequence number (or sequence number and ack) has changed. If it is not \r\na special case, zero or more changes are printed. A change is indicated by U \r\n(urgent pointer), W (window), A (ack), S (sequence number), and I (packet ID), \r\nfollowed by a delta (+n or -n), or a new value (=n). Finally, the amount of data \r\nin the packet and compressed header length are printed. \r\n<P>For example, the following line shows an outbound compressed TCP packet, with \r\nan implicit connection identifier; the ack has changed by 6, the sequence number \r\nby 49, and the packet ID by 6; there are 3 bytes of data and 6 bytes of \r\ncompressed header: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><B>O ctcp * A+6 S+49 I+6 3 (6)</B>\r\n</PRE></DD></DL>\r\n<P><B></B>ARP/RARP Packets \r\n<P>Arp/rarp output shows the type of request and its arguments. The format is \r\nintended to be self explanatory. Here is a short sample taken from the start of \r\nan `rlogin' from host <I>rtsg</I> to host <I>csam</I>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>arp who-has csam tell rtsg\r\narp reply csam is-at CSAM</TT>\r\n\r\n</PRE></DD></DL>The first line says that rtsg sent an arp packet asking for the \r\nethernet address of internet host csam. Csam replies with its ethernet address \r\n(in this example, ethernet addresses are in caps and internet addresses in lower \r\ncase). \r\n<P>This would look less redundant if we had done <B>tcpdump -n</B>: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>arp who-has 128.3.254.6 tell 128.3.254.68\r\narp reply 128.3.254.6 is-at 02:07:01:00:01:c4</TT>\r\n</PRE></DD></DL>\r\n<P>If we had done <B>tcpdump -e</B>, the fact that the first packet is broadcast \r\nand the second is point-to-point would be visible: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>RTSG Broadcast 0806  64: arp who-has csam tell rtsg\r\nCSAM RTSG 0806  64: arp reply csam is-at CSAM</TT>\r\n\r\n</PRE></DD></DL>For the first packet this says the ethernet source address is \r\nRTSG, the destination is the ethernet broadcast address, the type field \r\ncontained hex 0806 (type ETHER_ARP) and the total length was 64 bytes. \r\n<P><B></B>TCP Packets \r\n<P><I>(N.B.:The following description assumes familiarity with the TCP protocol \r\ndescribed in RFC-793. If you are not familiar with the protocol, neither this \r\ndescription nor tcpdump will be of much use to you.)</I> \r\n<P>The general format of a tcp protocol line is: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src &gt; dst: flags data-seqno ack window urgent options</I>\r\n\r\n</PRE></DD></DL><I>Src</I> and <I>dst</I> are the source and destination IP \r\naddresses and ports. <I>Flags</I> are some combination of S (SYN), F (FIN), P \r\n(PUSH) or R (RST) or a single `.' (no flags). <I>Data-seqno</I> describes the \r\nportion of sequence space covered by the data in this packet (see example \r\nbelow). <I>Ack</I> is sequence number of the next data expected the other \r\ndirection on this connection. <I>Window</I> is the number of bytes of receive \r\nbuffer space available the other direction on this connection. <I>Urg</I> \r\nindicates there is `urgent' data in the packet. <I>Options</I> are tcp options \r\nenclosed in angle brackets (e.g., &lt;mss 1024&gt;). \r\n<P><I>Src, dst</I> and <I>flags</I> are always present. The other fields depend \r\non the contents of the packet's tcp protocol header and are output only if \r\nappropriate. \r\n<P>Here is the opening portion of an rlogin from host <I>rtsg</I> to host \r\n<I>csam</I>. \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;\r\ncsam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;\r\nrtsg.1023 &gt; csam.login: . ack 1 win 4096\r\nrtsg.1023 &gt; csam.login: P 1:<A href=\"http://localhost/cgi-bin/man/man2html?1+2\">2</A>(1) ack 1 win 4096\r\ncsam.login &gt; rtsg.1023: . ack 2 win 4096\r\nrtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096\r\ncsam.login &gt; rtsg.1023: P 1:<A href=\"http://localhost/cgi-bin/man/man2html?1+2\">2</A>(1) ack 21 win 4077\r\ncsam.login &gt; rtsg.1023: P 2:<A href=\"http://localhost/cgi-bin/man/man2html?1+3\">3</A>(1) ack 21 win 4077 urg 1\r\ncsam.login &gt; rtsg.1023: P 3:<A href=\"http://localhost/cgi-bin/man/man2html?1+4\">4</A>(1) ack 21 win 4077 urg 1</TT></FONT>\r\n\r\n</PRE></DD></DL>The first line says that tcp port 1023 on rtsg sent a packet to \r\nport <I>login</I> on csam. The <B>S</B> indicates that the <I>SYN</I> flag was \r\nset. The packet sequence number was 768512 and it contained no data. (The \r\nnotation is `first:last(nbytes)' which means `sequence numbers <I>first</I> up \r\nto but not including <I>last</I> which is <I>nbytes</I> bytes of user data'.) \r\nThere was no piggy-backed ack, the available receive window was 4096 bytes and \r\nthere was a max-segment-size option requesting an mss of 1024 bytes. \r\n<P>Csam replies with a similar packet except it includes a piggy-backed ack for \r\nrtsg's SYN. Rtsg then acks csam's SYN. The `.' means no flags were set. The \r\npacket contained no data so there is no data sequence number. Note that the ack \r\nsequence number is a small integer (1). The first time <B>tcpdump</B> sees a tcp \r\n`conversation', it prints the sequence number from the packet. On subsequent \r\npackets of the conversation, the difference between the current packet's \r\nsequence number and this initial sequence number is printed. This means that \r\nsequence numbers after the first can be interpreted as relative byte positions \r\nin the conversation's data stream (with the first data byte each direction being \r\n`1'). `-S' will override this feature, causing the original sequence numbers to \r\nbe output. \r\n<P>On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20 in the \r\nrtsg -&gt; csam side of the conversation). The PUSH flag is set in the packet. \r\nOn the 7th line, csam says it's received data sent by rtsg up to but not \r\nincluding byte 21. Most of this data is apparently sitting in the socket buffer \r\nsince csam's receive window has gotten 19 bytes smaller. Csam also sends one \r\nbyte of data to rtsg in this packet. On the 8th and 9th lines, csam sends two \r\nbytes of urgent, pushed data to rtsg. \r\n<P>If the snapshot was small enough that <B>tcpdump</B> didn't capture the full \r\nTCP header, it interprets as much of the header as it can and then reports \r\n``[|<I>tcp</I>]'' to indicate the remainder could not be interpreted. If the \r\nheader contains a bogus option (one with a length that's either too small or \r\nbeyond the end of the header), tcpdump reports it as ``[<I>bad opt</I>]'' and \r\ndoes not interpret any further options (since it's impossible to tell where they \r\nstart). If the header length indicates options are present but the IP datagram \r\nlength is not long enough for the options to actually be there, tcpdump reports \r\nit as ``[<I>bad hdr length</I>]''. \r\n<P><B></B><B>UDP Packets</B> \r\n<P>UDP format is illustrated by this rwho packet: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>actinide.who &gt; broadcast.who: udp 84</TT>\r\n\r\n</PRE></DD></DL>This says that port <I>who</I> on host <I>actinide</I> sent a \r\nudp datagram to port <I>who</I> on host <I>broadcast</I>, the Internet broadcast \r\naddress. The packet contained 84 bytes of user data. \r\n<P>Some UDP services are recognized (from the source or destination port number) \r\nand the higher level protocol information printed. In particular, Domain Name \r\nservice requests (RFC-1034/1035) and Sun RPC calls (RFC-1050) to NFS. \r\n<P><B></B>UDP Name Server Requests \r\n<P><I>(N.B.:The following description assumes familiarity with the Domain \r\nService protocol described in RFC-1035. If you are not familiar with the \r\nprotocol, the following description will appear to be written in greek.)</I> \r\n<P>Name server requests are formatted as \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src &gt; dst: id op? flags qtype qclass name (len)</I>\r\n\r\n<TT>h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</TT>\r\n\r\n</PRE></DD></DL>Host <I>h2opolo</I> asked the domain server on <I>helios</I> for \r\nan address record (qtype=A) associated with the name <I>ucbvax.berkeley.edu.</I> \r\nThe query id was `3'. The `+' indicates the <I>recursion desired</I> flag was \r\nset. The query length was 37 bytes, not including the UDP and IP protocol \r\nheaders. The query operation was the normal one, <I>Query</I>, so the op field \r\nwas omitted. If the op had been anything else, it would have been printed \r\nbetween the `3' and the `+'. Similarly, the qclass was the normal one, \r\n<I>C_IN</I>, and omitted. Any other qclass would have been printed immediately \r\nafter the `A'. \r\n<P>A few anomalies are checked and may result in extra fields enclosed in square \r\nbrackets: If a query contains an answer, name server or authority section, \r\n<I>ancount</I>, <I>nscount</I>, or <I>arcount</I> are printed as `[<I>n</I>a]', \r\n`[<I>n</I>n]' or `[<I>n</I>au]' where <I>n</I> is the appropriate count. If any \r\nof the response bits are set (AA, RA or rcode) or any of the `must be zero' bits \r\nare set in bytes two and three, `[b2&amp;3=<I>x</I>]' is printed, where <I>x</I> \r\nis the hex value of header bytes two and three. \r\n<P><B></B>UDP Name Server Responses \r\n<P>Name server responses are formatted as \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src &gt; dst:  id op rcode flags a/n/au type class data (len)</I>\r\n\r\n<TT>helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)\r\nhelios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</TT>\r\n\r\n</PRE></DD></DL>In the first example, <I>helios</I> responds to query id 3 from \r\n<I>h2opolo</I> with 3 answer records, 3 name server records and 7 authority \r\nrecords. The first answer record is type A (address) and its data is internet \r\naddress 128.32.137.3. The total size of the response was 273 bytes, excluding \r\nUDP and IP headers. The op (Query) and response code (NoError) were omitted, as \r\nwas the class (C_IN) of the A record. \r\n<P>In the second example, <I>helios</I> responds to query 2 with a response code \r\nof non-existent domain (NXDomain) with no answers, one name server and no \r\nauthority records. The `*' indicates that the <I>authoritative answer</I> bit \r\nwas set. Since there were no answers, no type, class or data were printed. \r\n<P>Other flag characters that might appear are `-' (recursion available, RA, \r\n<I>not</I> set) and `|' (truncated message, TC, set). If the `question' section \r\ndoesn't contain exactly one entry, `[<I>n</I>q]' is printed. \r\n<P>Note that name server requests and responses tend to be large and the default \r\n<I>snaplen</I> of 68 bytes may not capture enough of the packet to print. Use \r\nthe <B>-s</B> flag to increase the snaplen if you need to seriously investigate \r\nname server traffic. `<B>-s 128</B>' has worked well for me. \r\n<P>\r\n<P><B></B>NFS Requests and Replies \r\n<P>Sun NFS (Network File System) requests and replies are printed as: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>src.xid &gt; dst.nfs: len op args</I>\r\n<I>src.nfs &gt; dst.xid: reply stat len op results</I>\r\n\r\n<TT>\r\nsushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165\r\nwrl.nfs &gt; sushi.6709: reply ok 40 readlink \"../var\"\r\nsushi.201b &gt; wrl.nfs:\r\n        144 lookup fh 9,74/4096.6878 \"xcolors\"\r\nwrl.nfs &gt; sushi.201b:\r\n        reply ok 128 lookup fh 9,74/4134.3150\r\n</TT>\r\n\r\n</PRE></DD></DL>In the first line, host <I>sushi</I> sends a transaction with id \r\n<I>6709</I> to <I>wrl</I> (note that the number following the src host is a \r\ntransaction id, <I>not</I> the source port). The request was 112 bytes, \r\nexcluding the UDP and IP headers. The operation was a <I>readlink</I> (read \r\nsymbolic link) on file handle (<I>fh</I>) 21,24/10.731657119. (If one is lucky, \r\nas in this case, the file handle can be interpreted as a major,minor device \r\nnumber pair, followed by the inode number and generation number.) <I>Wrl</I> \r\nreplies `ok' with the contents of the link. \r\n<P>In the third line, <I>sushi</I> asks <I>wrl</I> to lookup the name \r\n`<I>xcolors</I>' in directory file 9,74/4096.6878. Note that the data printed \r\ndepends on the operation type. The format is intended to be self explanatory if \r\nread in conjunction with an NFS protocol spec. \r\n<P>If the -v (verbose) flag is given, additional information is printed. For \r\nexample: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<TT>\r\nsushi.1372a &gt; wrl.nfs:\r\n        148 read fh 21,11/12.195 8192 bytes @ 24576\r\nwrl.nfs &gt; sushi.1372a:\r\n        reply ok 1472 read REG 100664 ids 417/0 sz 29388\r\n</TT>\r\n\r\n</PRE></DD></DL>(-v also prints the IP header TTL, ID, and fragmentation fields, \r\nwhich have been omitted from this example.) In the first line, <I>sushi</I> asks \r\n<I>wrl</I> to read 8192 bytes from file 21,11/12.195, at byte offset 24576. \r\n<I>Wrl</I> replies `ok'; the packet shown on the second line is the first \r\nfragment of the reply, and hence is only 1472 bytes long (the other bytes will \r\nfollow in subsequent fragments, but these fragments do not have NFS or even UDP \r\nheaders and so might not be printed, depending on the filter expression used). \r\nBecause the -v flag is given, some of the file attributes (which are returned in \r\naddition to the file data) are printed: the file type (``REG'', for regular \r\nfile), the file mode (in octal), the uid and gid, and the file size. \r\n<P>If the -v flag is given more than once, even more details are printed. \r\n<P>Note that NFS requests are very large and much of the detail won't be printed \r\nunless <I>snaplen</I> is increased. Try using `<B>-s 192</B>' to watch NFS \r\ntraffic. \r\n<P>NFS reply packets do not explicitly identify the RPC operation. Instead, \r\n<I>tcpdump</I> keeps track of ``recent'' requests, and matches them to the \r\nreplies using the transaction ID. If a reply does not closely follow the \r\ncorresponding request, it might not be parsable. \r\n<P><B></B>KIP Appletalk (DDP in UDP) \r\n<P>Appletalk DDP packets encapsulated in UDP datagrams are de-encapsulated and \r\ndumped as DDP packets (i.e., all the UDP header information is discarded). The \r\nfile <I>/etc/atalk.names</I> is used to translate appletalk net and node numbers \r\nto names. Lines in this file have the form \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>number  name</I>\r\n\r\n<TT>1.254           ether\r\n16.1            icsd-net\r\n1.254.110       ace</TT>\r\n\r\n</PRE></DD></DL>The first two lines give the names of appletalk networks. The \r\nthird line gives the name of a particular host (a host is distinguished from a \r\nnet by the 3rd octet in the number - a net number <I>must</I> have two octets \r\nand a host number <I>must</I> have three octets.) The number and name should be \r\nseparated by whitespace (blanks or tabs). The <I>/etc/atalk.names</I> file may \r\ncontain blank lines or comment lines (lines starting with a `#'). \r\n<P>Appletalk addresses are printed in the form \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<I>net.host.port</I>\r\n\r\n<TT>144.1.209.2 &gt; icsd-net.112.220\r\noffice.2 &gt; icsd-net.112.220\r\njssmag.149.235 &gt; icsd-net.2</TT>\r\n\r\n</PRE></DD></DL>(If the <I>/etc/atalk.names</I> doesn't exist or doesn't contain \r\nan entry for some appletalk host/net number, addresses are printed in numeric \r\nform.) In the first example, NBP (DDP port 2) on net 144.1 node 209 is sending \r\nto whatever is listening on port 220 of net icsd node 112. The second line is \r\nthe same except the full name of the source node is known (`office'). The third \r\nline is a send from port 235 on net jssmag node 149 to broadcast on the icsd-net \r\nNBP port (note that the broadcast address (255) is indicated by a net name with \r\nno host number - for this reason it's a good idea to keep node names and net \r\nnames distinct in /etc/atalk.names). \r\n<P>NBP (name binding protocol) and ATP (Appletalk transaction protocol) packets \r\nhave their contents interpreted. Other protocols just dump the protocol name (or \r\nnumber if no name is registered for the protocol) and packet size. \r\n<P><B>NBP packets</B> are formatted like the following examples: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: \"=:LaserWriter@*\"\r\njssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: \"RM1140:LaserWriter@*\" 250\r\ntechpit.2 &gt; icsd-net.112.220: nbp-reply 190: \"techpit:LaserWriter@*\" 186</TT></FONT>\r\n\r\n</PRE></DD></DL>The first line is a name lookup request for laserwriters sent by \r\nnet icsd host 112 and broadcast on net jssmag. The nbp id for the lookup is 190. \r\nThe second line shows a reply for this request (note that it has the same id) \r\nfrom host jssmag.209 saying that it has a laserwriter resource named \"RM1140\" \r\nregistered on port 250. The third line is another reply to the same request \r\nsaying host techpit has laserwriter \"techpit\" registered on port 186. \r\n<P><B>ATP packet</B> formatting is demonstrated by the following example: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000\r\njssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000\r\nhelios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000\r\njssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001\r\njssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002</TT></FONT>\r\n\r\n</PRE></DD></DL>Jssmag.209 initiates transaction id 12266 with host helios by \r\nrequesting up to 8 packets (the `&lt;0-7&gt;'). The hex number at the end of the \r\nline is the value of the `userdata' field in the request. \r\n<P>Helios responds with 8 512-byte packets. The `:digit' following the \r\ntransaction id gives the packet sequence number in the transaction and the \r\nnumber in parens is the amount of data in the packet, excluding the atp header. \r\nThe `*' on packet 7 indicates that the EOM bit was set. \r\n<P>Jssmag.209 then requests that packets 3 &amp; 5 be retransmitted. Helios \r\nresends them then jssmag.209 releases the transaction. Finally, jssmag.209 \r\ninitiates the next request. The `*' on the request indicates that XO (`exactly \r\nonce') was <I>not</I> set. \r\n<P>\r\n<P><B></B>IP Fragmentation \r\n<P>Fragmented Internet datagrams are printed as \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<B>(frag </B><I>id</I><B>:</B><I>size</I><B>@</B><I>offset</I><B>+)</B>\r\n<B>(frag </B><I>id</I><B>:</B><I>size</I><B>@</B><I>offset</I><B>)</B>\r\n\r\n</PRE></DD></DL>(The first form indicates there are more fragments. The second \r\nindicates this is the last fragment.) \r\n<P><I>Id</I> is the fragment id. <I>Size</I> is the fragment size (in bytes) \r\nexcluding the IP header. <I>Offset</I> is this fragment's offset (in bytes) in \r\nthe original datagram. \r\n<P>The fragment information is output for each fragment. The first fragment \r\ncontains the higher level protocol header and the frag info is printed after the \r\nprotocol info. Fragments after the first contain no higher level protocol header \r\nand the frag info is printed after the source and destination addresses. For \r\nexample, here is part of an ftp from arizona.edu to lbl-rtsg.arpa over a CSNET \r\nconnection that doesn't appear to handle 576 byte datagrams: \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE>\r\n<FONT size=-2><TT>arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)\r\narizona &gt; rtsg: (frag 595a:204@328)\r\nrtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560</TT></FONT>\r\n\r\n</PRE></DD></DL>There are a couple of things to note here: First, addresses in \r\nthe 2nd line don't include port numbers. This is because the TCP protocol \r\ninformation is all in the first fragment and we have no idea what the port or \r\nsequence numbers are when we print the later fragments. Second, the tcp sequence \r\ninformation in the first line is printed as if there were 308 bytes of user data \r\nwhen, in fact, there are 512 bytes (308 in the first frag and 204 in the \r\nsecond). If you are looking for holes in the sequence space or trying to match \r\nup acks with packets, this can fool you. \r\n<P>A packet with the IP <I>don't fragment</I> flag is marked with a trailing \r\n<B>(DF)</B>. \r\n<P><B></B>Timestamps \r\n<P>By default, all output lines are preceded by a timestamp. The timestamp is \r\nthe current clock time in the form \r\n<DL compact>\r\n  <DT>\r\n  <DD><PRE><I>hh:mm:ss.frac</I>\r\n</PRE></DD></DL>and is as accurate as the kernel's clock. The timestamp reflects \r\nthe time the kernel first saw the packet. No attempt is made to account for the \r\ntime lag between when the ethernet interface removed the packet from the wire \r\nand when the kernel serviced the `new packet' interrupt. <A name=lbAH>&nbsp;</A> \r\n\r\n<H2>SEE ALSO</H2><A \r\nhref=\"http://localhost/cgi-bin/man/man2html?1C+traffic\">traffic</A>(1C), <A \r\nhref=\"http://localhost/cgi-bin/man/man2html?4P+nit\">nit</A>(4P), <A \r\nhref=\"http://localhost/cgi-bin/man/man2html?4+bpf\">bpf</A>(4), <A \r\nhref=\"http://localhost/cgi-bin/man/man2html?3+pcap\">pcap</A>(3) <A \r\nname=lbAI>&nbsp;</A> \r\n<H2>AUTHORS</H2>Van Jacobson, Craig Leres and Steven McCanne, all of the \r\nLawrence Berkeley National Laboratory, University of California, Berkeley, CA. \r\n<P>The current version is available via anonymous ftp: \r\n<P>\r\n<DL compact>\r\n  <DT>\r\n  <DD><I><A \r\n  href=\"ftp://ftp.ee.lbl.gov/tcpdump.tar.Z\">ftp://ftp.ee.lbl.gov/tcpdump.tar.Z</A></I> \r\n  </DD></DL><A name=lbAJ>&nbsp;</A> \r\n<H2>BUGS</H2>Please send bug reports to <A \r\nhref=\"mailto:tcpdump@ee.lbl.gov\">tcpdump@ee.lbl.gov</A>. \r\n<P>NIT doesn't let you watch your own outbound traffic, BPF will. We recommend \r\nthat you use the latter. \r\n<P>Some attempt should be made to reassemble IP fragments or, at least to \r\ncompute the right length for the higher level protocol. \r\n<P>Name server inverse queries are not dumped correctly: The (empty) question \r\nsection is printed rather than real query in the answer section. Some believe \r\nthat inverse queries are themselves a bug and prefer to fix the program \r\ngenerating them rather than tcpdump. \r\n<P>Apple Ethertalk DDP packets could be dumped as easily as KIP DDP packets but \r\naren't. Even if we were inclined to do anything to promote the use of Ethertalk \r\n(we aren't), LBL doesn't allow Ethertalk on any of its networks so we'd would \r\nhave no way of testing this code. \r\n<P>A packet trace that crosses a daylight savings time change will give skewed \r\ntime stamps (the time change is ignored). \r\n<P>Filters expressions that manipulate FDDI headers assume that all FDDI packets \r\nare encapsulated Ethernet packets. This is true for IP, ARP, and DECNET Phase \r\nIV, but is not true for protocols such as ISO CLNS. Therefore, the filter may \r\ninadvertently accept certain packets that do not properly match the filter \r\nexpression. \r\n<P>\r\n<HR>\r\n<A name=index>&nbsp;</A>\r\n<H2>Index</H2>\r\n<DL>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAB\">NAME</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAC\">SYNOPSIS</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAD\">DESCRIPTION</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAE\">OPTIONS</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAF\">EXAMPLES</A>\r\n  <DD>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAG\">OUTPUT \r\n  FORMAT</A>\r\n  <DD>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAH\">SEE \r\n  ALSO</A>\r\n  <DD>\r\n  <DT><A \r\n  href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAI\">AUTHORS</A>\r\n  <DD>\r\n  <DT><A href=\"http://www.ics.uci.edu/~lchen/ics156/tcpdump.html#lbAJ\">BUGS</A>\r\n  <DD></DD></DL>\r\n<HR>\r\nThis document was created by <A \r\nhref=\"http://localhost/cgi-bin/man/man2html\">man2html</A>, using the manual \r\npages.<BR>Time: 19:17:16 GMT, August 09, 2000 </BODY></HTML>\r\n", "encoding": "ascii"}