{"url": "https://www.ics.uci.edu/~kay/courses/i41/hw/lab5.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\" />\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\" />\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Friday, October 28, 2005 9:47 AM\" />\n<TITLE>Lab Assignment 5</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"D235E05F\" />\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 1, CS1, assignment, Scheme\" />\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"An assignment for ICS H21, an honors first-quarter course in computer science in Information and Computer Science, UC Irvine, using How to Design Programs by Matthias Felleisen et al.\" />\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2001 by David G. Kay.  All rights reserved.\" />\n<link href=\"/~kay/courses/i41/code.css\" rel=\"stylesheet\" type=\"text/css\" />\n<style type=\"text/css\">\n<!--\n.style1 {font-size: 10pt}\n.style2 {\n\tfont-size: 10pt;\n\tfont-family: \"Courier New\", Courier, monospace;\n}\n.style4 {\n\tfont-family: \"Courier New\", Courier, monospace;\n\tfont-weight: bold;\n\tfont-size: 10pt;\n}\n-->\n</style>\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<P><FONT size=\"2\" FACE=\"Goudy Old Style\">INFORMATICS 41 &bull; DAVID G. KAY &bull; UC IRVINE &bull; FALL 2011</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\" SIZE=6><B>Lab Assignment 5</B></FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">This assignment is due at the end of lab on\nFriday, October 28.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Choose a partner for this assignment, someone\nyou haven&#39;t worked with already. If you're thinking about doing more software development after this course, try to find a partner with similar interests.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a) </B>In class we described how to change our restaurant\nstructure so that instead of just one best dish and its price, each restaurant\nhas a menu of dishes.  So a (new) </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nis now</FONT></P>\n<P class=\"style1\"><FONT FACE=\"Courier New\">(make-rrant\nname cuisine phone menu)</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">where name is a string, cuisine is a string,\nphone is a string, and menu is a list of dish structures (see below).  We\ndefined the new structure more or less like this:</FONT></P>\n<P class=\"style1\"><FONT FACE=\"Courier New\">(define-struct\nrrant (name cuisine phone menu))</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">The menu was a list of dishes&mdash;that is,\nthe </FONT><code>rrant</code></span><FONT FACE=\"Goudy Old Style\">\nstructure contains a list as one of its fields.  Each dish on the list has a name and a price.  So a </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">dish</FONT></span><FONT FACE=\"Goudy Old Style\">\nis</FONT></P>\n<P class=\"style1\"><FONT FACE=\"Courier New\">(make-dish\nname price)</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">where name is a string and price is a number,\ndefined with</FONT></P>\n<P class=\"style1\">\n  <FONT FACE=\"Courier New\">(define-struct dish (name price))</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.1)</B> To the restaurant definition below,\nadd a third dish:  Paht Woon Sen at $7.95.<A NAME=\"_14_2366\"></A>\n<BR />\n</FONT><span class=\"style2\">(define R1 (make-rrant &quot;Thai\nTouch&quot; &quot;Thai&quot; &quot;949-640-0123&quot; <BR />\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (make-dish &quot;Mee Krob&quot; 8.50) <BR />\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-dish &quot;Larb Gai&quot; 10.25))))</span></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Write a Scheme expression that defines R2 as\na (new) </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nstructure for the French restaurant Pascal whose phone number is 940-752-0107;\nthey serve escargots for $12.95, poached salmon for $18.50, rack of lamb\nfor $24.00 and marjolaine cake for $8.50.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.2)  </B>Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant-first-dish-name</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nas its argument and returns the name of the first dish on the restaurant&#39;s\nmenu.  Remember to write the test cases and examples before you write the\nfunction.  You should include code to check whether the menu has zero dishes\nand return empty if so.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">You may find yourself needing to extract the\nmenu from the argument twice; use </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">local</FONT></span><FONT FACE=\"Goudy Old Style\">\nto avoid that.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.3)</B>  Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">dish-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a dish structure and a number and returns true if (and only if)\nthe price of the dish is less than the specified number.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.4)</B>  Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">menu-all-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a menu (i.e., a list of dish structures) and a number and returns\ntrue if (and only if) all the dishes on the menu have a price less than\nthe specified number. You may write your code to return true if the menu\ndoesn&#39;t have any dishes; don&#39;t produce an error message.  Of course\nyou should use </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">dish-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nin your definition.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.5) </B> Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant-all-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nand a number and returns true if all the dishes the restaurant serves cost\nless than the specified number.  Of course you should use </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">menu-all-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nin your definition.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.6)</B>  Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">menu-prices</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a menu and returns a list of numbers where each number is the\nprice of a dish on the menu.  That is, your function will collect all the\nprices of the dishes into a list and return that list. (This is an alternative approach to what we did in class.)</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.7)</B>  Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">menu-average</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a menu and returns the average price of the dishes on that menu.\n Think about how you compute an average, what quantities you need, and how\nto get them.  The predefined function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">length</FONT></span><FONT FACE=\"Goudy Old Style\">\nwill be helpful; it will also be helpful to write a function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">sum</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat returns the sum of a list of numbers.  Note also that you&#39;ll need\nto check for an empty menu and return zero in that case, so you don&#39;t\ndivide by zero.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.8)</B>  Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nand a number and returns true if the average price of the restaurant&#39;s\nmenu is less than the specified number.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.9) </B> Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant-keep-cheap</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nand a number and returns (a newly constructed copy of) that restaurant with\nall the menu items that aren&#39;t cheap removed.  The right way to go about\nthis is to follow the pattern of the functions above:  Start by writing\na function to operate on a menu, and then call that function from your </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant-keep-cheap</FONT></span><FONT FACE=\"Goudy Old Style\">\nfunction.  The actual removal task follows the pattern of some of the functions\nwe&#39;ve already seen.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\"><B>(a.10)</B>  Write the function </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">cheap-rrants</FONT></span><FONT FACE=\"Goudy Old Style\">\nthat takes a list of </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Goudy Old Style\">\nstructures and a number and returns a list containing only the cheap restaurants&mdash;the\nones whose average menu price is less than the number.  Use </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant-cheap?</FONT></span><FONT FACE=\"Goudy Old Style\">\nin your definition, of course. </FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Collect all of these definitions and submit\nthem via Checkmate.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(b)</B> In class, we did an &quot;inorder traversal&quot; of a BST; we called it <code>BST-&gt;list</code>.  We also did the insertion of an item into a BST; we called it <code>BST-insert</code>.  And we wrote a function to take a list of items and insert each item into a BST; we called it <code>list-&gt;BST</code>.  You should know how to recognize these functions and how to write them.</font></P>\n<p><font face=\"Goudy Old Style\"><strong>(b.1) </strong>At the end of class, we reimplemented (rebuilt) our BST to keep track of duplicate items by storing a count of how many times each item occurred. We redefined the <code>node</code> structure and we defined an insertion function to increase the count each time we find a duplicate item.  But we didn't finish rewriting <code>BST-&gt;list</code> to produce, for example, three 19s on the sorted list if there were three 19s in the input.  The skeleton is at the bottom of Thursday afternoon's class transcript (available in the course Email archive); complete that definition (including enough <code>check-expect</code> tests to demonstrate that your definition is correct). </font></p>\n<p><FONT FACE=\"Goudy Old Style\"><strong>(b.2) </strong>In class we did not write a function to search for an item in a binary tree.  So we'll give you a chance to do it now.  Write the function <font face=\"Courier New, Courier, monospace\">BST-member?</font> as described below.  Write it to process BSTs as we defined them in class (with counts or without, your choice).</FONT></P>\n<pre><font size=\"2\" face=\"Courier New, Courier, monospace\">;; BST-member?: number  BST  -&gt;  boolean\n;; Return true if number appears in BST and false otherwise\n(check-expect (BST-member? 17 empty) false)\n(check-expect (BST-member? 17 (list-&gt;BST (list 17))) true)\n(check-expect (BST-member? 17 (list-&gt;BST (list 34 43 28 16 17 24 134 34))) true)\n(check-expect (BST-member? 17 (list-&gt;BST (list 34 3 23 2 25 26 24))) false)</font></pre>\n<p><FONT FACE=\"Goudy Old Style\">Here are some hints if you'd like them: You have the contract, purpose statement, and examples above. Next, write the function header (define and lambda). Since a tree is either empty or not, have a cond to distinguish. Now, what do you return if the tree's empty? If it's not empty, what two things do you have to look at? What if they're equal, what do you return? If they're not equal, you're going to have to keep looking (recursively) in either the left subtree or the right subtree; how do you decide which?</FONT></P>\n<p><FONT FACE=\"Goudy Old Style\">Submit your definitions\n  via Checkmate. </FONT></P>\n<p>\n<FONT FACE=\"Goudy Old Style\"><B>(c)</B> This part is optional. If you don't get to it, that's fine. But if you think your interests might be in the area of software development or software engineering, then we highly recommend giving it a try.</FONT></P>\n<p><FONT FACE=\"Goudy Old Style\">Reimplement the collection class in the restaurants program to store\n  the restaurants in a binary search tree ordered by the restaurants&#39;\n  names.  This will involve changing all the definitions in the collection\n  part of the code, but none of the definitions elsewhere. [In fact, you'd do exatly the same thing whether the restaurant structures are old-style (with one dish and price) or new-style (with a menu of dishes).]</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Your data definition will be as follows:</FONT></P>\n<P><code>;; A treenode is either<br />\n  ;; 1. empty<br />\n  ;; 2. (make-treenode rootvalue left right), where rootvalue is a rrant and left<br />\n  ;; and right are treenodes, representing the left subtree and right subtree,<br />\n  ;; and (this is the BST property) where all of the restaurant names in the left<br />\n  ;; subtree are earlier alphabetically than the name of the rootvalue restaurant,<br />\n;; all names in the right subtree are greater, and both subtrees are BSTs.</code></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Here are some tips, hints, and simplifications:</FONT></P>\n<ul>\n  <li>\n    <FONT FACE=\"Goudy Old Style\">The BST code you wrote earlier and the code we did in class should\n    be a useful guide. </FONT></li>\n  <li>\n    <FONT FACE=\"Goudy Old Style\">To compare strings alphabetically, use </FONT><FONT FACE=\"Courier New\" SIZE=2>string=?</FONT><FONT FACE=\"Goudy Old Style\">,\n      </FONT><FONT FACE=\"Courier New\" SIZE=2>string&gt;?</FONT><FONT FACE=\"Goudy Old Style\">,\n        or </FONT><FONT FACE=\"Courier New\" SIZE=2>string&lt;?</FONT><FONT FACE=\"Goudy Old Style\">.\n        </FONT></li>\n  <li>\n    <FONT FACE=\"Goudy Old Style\">The </FONT><FONT FACE=\"Courier New\" SIZE=2>collection-&gt;list</FONT><FONT FACE=\"Goudy Old Style\">\n    function should do an inorder traversal of the tree, so it produces a sorted\n    list.  </FONT></li>\n  <li>\n    <FONT FACE=\"Goudy Old Style\">Assume that every restaurant in the collection\n      will have a unique name.  Under that assumption, there will be no duplications,\n    so that </FONT><FONT FACE=\"Courier New\" SIZE=2>collection-search</FONT><FONT FACE=\"Goudy Old Style\">\n    will always return a one-element collection or an empty collection.</FONT></li>\n  <li>\n    <FONT FACE=\"Goudy Old Style\">Deleting items from a BST is very tricky\n      if the item has two children, because you can&#39;t leave holes and you\n      need to maintain the BST property.  We&#39;ll learn the algorithm for this\n    some day, but for now, you can skip it:  </FONT><FONT FACE=\"Courier New\" SIZE=2>collection-remove</FONT><FONT FACE=\"Goudy Old Style\">\n  can just return the same collection unchanged.</FONT></li>\n</ul>\n<p><FONT FACE=\"Goudy Old Style\">What's the point of this exercise? The restaurant collection in our program is an interchangeable part. We can change how we build it internally (from a list to a BST) without affecting the rest of the program (i.e., without requiring the authors of those parts of the program to make any changes in their code). This interchangeability is a key aspect of any well-designed modern software system and it's a fundamental principle of object-oriented programming.</FONT></p>\n<P><FONT FACE=\"Goudy Old Style\"><B>(d)</B>  Remember that each partner must\n  complete a partner evaluation form via the Survey tool on <code>eee.uci.edu</code>.</FONT><BR />\n</P>\n<P>\n<FONT FACE=\"Helvetica\" SIZE=1>Based in part on ICS H21assignments by David\nG. Kay; modified by David G. Kay for the Informatics Core Course, Fall 2004, Fall 2005, Fall 2008, Fall 2009, Fall 2011.</FONT></P>\n<HR />\n<FONT FACE=\"Goudy Old Style\"><A HREF=\"http://www.ics.uci.edu/~kay/\">David G. Kay</A>, <a href=mailto:kay@uci.edu>kay@uci.edu</A> </FONT><span><br />\n<font size=\"2\" face=\"Goudy Old Style\">\n<!-- #BeginDate format:fcAm1a -->Saturday, October 22, 2011 10:35 AM<!-- #EndDate -->\n</font></span>\n</BODY>\n</HTML>\n", "encoding": "ascii"}