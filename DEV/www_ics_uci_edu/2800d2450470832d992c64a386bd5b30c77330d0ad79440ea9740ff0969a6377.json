{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/Quadtree.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Quadtree closest pair algorithm\n// Maintains a sequence of matrices where the outer one stores all distances,\n// and each successive one stores a minimum of four entries from the previous.\n// The parent of square (i,j) in one matrix (where i>j) is the square\n// (ceil(i/2),floor(j/2)) in a smaller matrix. Note the asymmetry between\n// i and j due to our matrices being triangular; we don't store entries for i<=j.\n//\n// Total space: 2/3 n^2 + O(n)\n// Time per insertion or single distance update: O(Dn)\n// Time per deletion or point update: O(n)\n// Time per closest pair: O(log n)\n\n#include \"Quadtree.h\"\n#include \"Error.h\"\n\n// Perform indexing into distance matrices\n// Taking account of symmetry to avoid storing each distance twice\n//\n// assumes first arg is greater than second; results undefined otherwise\n//\nstatic inline point HalfArray(point i, point j)\n{\n\treturn (i*(i-1))/2 + j;\n}\n\n// Pretend that a distance matrix is a set of half as many points\n// with distance = min of four adjacent distances\nclass QuadTreeDist : public PointSet {\n\tdouble * child_dist;\n public:\n \tQuadTreeDist(unsigned long np, double * cd) : PointSet(np) {\n \t\tchild_dist = cd;\n \t}\n\tdouble operator() (point i, point j);\n};\n\n// Find minimum value in a single quadtree square\n// Note we don't do gDistances++ since this is not a real distance computation\ndouble QuadTreeDist::operator() (point i, point j)\n{\n\tif (i < j) return (*this)(j,i);\n\tdouble d = child_dist[HalfArray(2*i-1,2*j)];\n\tdouble dd = child_dist[HalfArray(2*i,2*j)];\n\tif (dd < d) d = dd;\n\tdd = child_dist[HalfArray(2*i,2*j+1)];\n\tif (dd < d) d = dd;\n\tif (i > j+1) {\n\t\tdd = child_dist[HalfArray(2*i-1,2*j+1)];\n\t\tif (dd < d) d = dd;\n\t}\n\treturn d;\n}\n\n// Initialize quadtree\nQuadTreeCP::QuadTreeCP(long np, long mp, Distance & d)\n\t: ClosestPairs(np, mp, d), dist(d)\n{\n\tgInsertions += np;\n\tmaxpts = mp;\n\n\t// initialize distance matrix\n\t// to keep our code simple we make sure that, if recursing, mp is odd\n\tif (mp > 2 && (mp & 01) == 0) mp++;\n\tdistances = new double[(mp*(mp-1)/2)];\n\tif (distances == 0) error(\"QuadTreeCP: unable to create distance matrix\");\n\tactive = new int[mp];\n\tif (active == 0) error(\"QuadTreeCP: unable to create table of active points\");\n\tunsigned long i, j;\n\tfor (i = 0; i < np; i++) active[i] = 1;\n\tfor (i = np; i < mp; i++) active[i] = 0;\n\tfor (i = 1; i < np; i++) for (j = 0; j < i; j++)\n\t\tdistances[HalfArray(i,j)] = dist(i,j);\n\tfor (i = np; i < mp; i++) for (j = 0; j < i; j++)\n\t\tdistances[HalfArray(i,j)] = MAX_DISTANCE;\n\n\t// initialize parent\n\tif (mp <= 2) {\n\t\tparent_dist = 0;\n\t\tparent = 0;\n\t} else {\n\t\tunsigned long pp = (mp+1)/2;\n\t\tparent_dist = new QuadTreeDist(pp, distances);\n\t\tif (parent_dist == 0) error(\"QuadTreeCP: unable to create quadtree squares\");\n\t\tparent = new QuadTreeCP(pp, pp, *parent_dist);\n\t\tif (parent == 0) error(\"QuadTreeCP: unable to create parent\");\n\t\tgInsertions -= pp;\t// keep insertion count sane\n\t}\n}\n\n// Get rid of used quadtree\nQuadTreeCP::~QuadTreeCP() {\n\tdelete distances;\n\tdelete active;\n\tif (parent_dist != 0) delete parent_dist;\n\tif (parent != 0) delete parent;\n}\n\n// add a point by making it active and updating\nvoid QuadTreeCP::operator += (point p)\n{\n\tgInsertions++;\n\tactive[p] = 1;\n\tUpdatePoint(p);\n}\n\n// remove a point by making it inactive and updating\nvoid QuadTreeCP::operator -= (point p)\n{\n\tgDeletions++;\n\tactive[p] = 0;\n\tUpdatePoint(p);\n}\n\n// find closest pair by recursing through quadtree levels\ndouble QuadTreeCP::operator () (point & a, point & b)\n{\n\t// base case. only one distance in array; just return it.\n\tif (parent == 0) {\n\t\ta = 1;\n\t\tb = 0;\n\t\tgPairs++;\t\t// only do in base case so total count stays sane\n\t\treturn distances[0];\n\t}\n\t\n\t// recursive case. find min in parent then determine which of\n\t// four possibilities it is in our distance matrix.\n\tpoint i,j;\n\tdouble d = (*parent)(i,j);\n\tfor (int x = 0; x < 2; x++)\n\t\tfor (int y = 0; y < 2; y++)\n\t\t\tif (d == distances[HalfArray(2*i-x,2*j+y)]) {\n\t\t\t\ta = 2*i-x;\n\t\t\t\tb = 2*j+y;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\t\n\terror(\"QuadTreeCP: unable to find distance matching parent\");\n}\n\nvoid QuadTreeCP::UpdateRow(point i)\n{\n\tfor (point j = 0; j < i; j++)\n\t\tif (active[i] && active[j])\n\t\t\tdistances[HalfArray(i,j)] = dist(i,j);\n\t\t\telse distances[HalfArray(i,j)] = MAX_DISTANCE;\n\t\n\tif (parent != 0) parent->UpdateRow((i+1)/2);\n}\n\nvoid QuadTreeCP::UpdateCol(point j)\n{\n\tfor (point i = j+1; i < maxpts; i++)\n\t\tif (active[i] && active[j])\n\t\t\tdistances[HalfArray(i,j)] = dist(i,j);\n\t\t\telse distances[HalfArray(i,j)] = MAX_DISTANCE;\n\t\n\tif (parent != 0) parent->UpdateCol(j/2);\n}\n\nvoid QuadTreeCP::UpdatePoint(point p)\n{\n\tUpdateRow(p);\n\tUpdateCol(p);\n}\n\nvoid QuadTreeCP::UpdateDistance(point i, point j)\n{\n\tif (i < j) {\n\t\tUpdateDistance(j, i);\n\t\treturn;\n\t}\n\tif (active[i] && active[j])\n\t\tdistances[HalfArray(i,j)] = dist(i,j);\n\t\telse distances[HalfArray(i,j)] = MAX_DISTANCE;\n\n\tif (parent != 0) parent->UpdateDistance((i+1)/2, j/2);\n}\n", "encoding": "ascii"}