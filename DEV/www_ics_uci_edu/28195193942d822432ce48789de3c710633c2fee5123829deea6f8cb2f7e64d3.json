{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_11.html#SEC157", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Debugging Tools</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Debugging Tools\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Debugging Tools\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC155\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_10.html#SEC152\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_12.html#SEC168\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> E. Debugging Tools </H1>\n<!--docid::SEC155::-->\n<P>\n\nMany tools lie at your disposal for debugging Pintos.  This appendix\nintroduces you to a few of them.\n</P>\n<P>\n\n<A NAME=\"printf\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC156\"></A>\n<H2> E.1 <CODE>printf()</CODE> </H2>\n<!--docid::SEC156::-->\n<P>\n\nDon't underestimate the value of <CODE>printf()</CODE>.  The way\n<CODE>printf()</CODE> is implemented in Pintos, you can call it from\npractically anywhere in the kernel, whether it's in a kernel thread or\nan interrupt handler, almost regardless of what locks are held.\n</P>\n<P>\n\n<CODE>printf()</CODE> is useful for more than just examining data.\nIt can also help figure out when and where something goes wrong, even\nwhen the kernel crashes or panics without a useful error message.  The\nstrategy is to sprinkle calls to <CODE>printf()</CODE> with different strings\n(e.g. <CODE>&quot;&lt;1&gt;&quot;</CODE>, <CODE>&quot;&lt;2&gt;&quot;</CODE>, <small>...</small>) throughout the pieces of\ncode you suspect are failing.  If you don't even see <CODE>&lt;1&gt;</CODE> printed,\nthen something bad happened before that point, if you see <CODE>&lt;1&gt;</CODE>\nbut not <CODE>&lt;2&gt;</CODE>, then something bad happened between those two\npoints, and so on.  Based on what you learn, you can then insert more\n<CODE>printf()</CODE> calls in the new, smaller region of code you suspect.\nEventually you can narrow the problem down to a single statement.\nSee section <A HREF=\"pintos_11.html#SEC165\">E.6 Triple Faults</A>, for a related technique.\n</P>\n<P>\n\n<A NAME=\"ASSERT\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC157\"></A>\n<H2> E.2 <CODE>ASSERT</CODE> </H2>\n<!--docid::SEC157::-->\n<P>\n\nAssertions are useful because they can catch problems early, before\nthey'd otherwise be noticed.  Ideally, each function should begin with a\nset of assertions that check its arguments for validity.  (Initializers\nfor functions' local variables are evaluated before assertions are\nchecked, so be careful not to assume that an argument is valid in an\ninitializer.)  You can also sprinkle assertions throughout the body of\nfunctions in places where you suspect things are likely to go wrong.\nThey are especially useful for checking loop invariants.\n</P>\n<P>\n\nPintos provides the <CODE>ASSERT</CODE> macro, defined in <Q><TT>&lt;debug.h&gt;</TT></Q>,\nfor checking assertions.\n</P>\n<P>\n\n<A NAME=\"IDX185\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>ASSERT</B> <I>(expression)</I>\n<DD>Tests the value of <VAR>expression</VAR>.  If it evaluates to zero (false),\nthe kernel panics.  The panic message includes the expression that\nfailed, its file and line number, and a backtrace, which should help you\nto find the problem.  See section <A HREF=\"pintos_11.html#SEC159\">E.4 Backtraces</A>, for more information.\n</DL>\n<P>\n\n<A NAME=\"Function and Parameter Attributes\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC158\"></A>\n<H2> E.3 Function and Parameter Attributes </H2>\n<!--docid::SEC158::-->\n<P>\n\nThese macros defined in <Q><TT>&lt;debug.h&gt;</TT></Q> tell the compiler special\nattributes of a function or function parameter.  Their expansions are\nGCC-specific.\n</P>\n<P>\n\n<A NAME=\"IDX186\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>UNUSED</B>\n<DD>Appended to a function parameter to tell the compiler that the\nparameter might not be used within the function.  It suppresses the\nwarning that would otherwise appear.\n</DL>\n<P>\n\n<A NAME=\"IDX187\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>NO_RETURN</B>\n<DD>Appended to a function prototype to tell the compiler that the\nfunction never returns.  It allows the compiler to fine-tune its\nwarnings and its code generation.\n</DL>\n<P>\n\n<A NAME=\"IDX188\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>NO_INLINE</B>\n<DD>Appended to a function prototype to tell the compiler to never emit\nthe function in-line.  Occasionally useful to improve the quality of\nbacktraces (see below).\n</DL>\n<P>\n\n<A NAME=\"IDX189\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PRINTF_FORMAT</B> <I>(<VAR>format</VAR>, <VAR>first</VAR>)</I>\n<DD>Appended to a function prototype to tell the compiler that the function\ntakes a <CODE>printf()</CODE>-like format string as the argument numbered\n<VAR>format</VAR> (starting from 1) and that the corresponding value\narguments start at the argument numbered <VAR>first</VAR>.  This lets the\ncompiler tell you if you pass the wrong argument types.\n</DL>\n<P>\n\n<A NAME=\"Backtraces\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC159\"></A>\n<H2> E.4 Backtraces </H2>\n<!--docid::SEC159::-->\n<P>\n\nWhen the kernel panics, it prints a &quot;backtrace,&quot; that is, a summary\nof how your program got where it is, as a list of addresses inside the\nfunctions that were running at the time of the panic.  You can also\ninsert a call to <CODE>debug_backtrace()</CODE>, prototyped in\n<Q><TT>&lt;debug.h&gt;</TT></Q>, to print a backtrace at any point in your code.\n<CODE>debug_backtrace_all()</CODE>, also declared in <Q><TT>&lt;debug.h&gt;</TT></Q>, \nprints backtraces of all threads.\n</P>\n<P>\n\nThe addresses in a backtrace are listed as raw hexadecimal numbers,\nwhich are difficult to interpret.  We provide a tool called\n<CODE>backtrace</CODE> to translate these into function names and source\nfile line numbers.\nGive it the name of your <Q><TT>kernel.o</TT></Q> as the first argument and the\nhexadecimal numbers composing the backtrace (including the <Q><SAMP>0x</SAMP></Q>\nprefixes) as the remaining arguments.  It outputs the function name\nand source file line numbers that correspond to each address.  \n</P>\n<P>\n\nIf the translated form of a backtrace is garbled, or doesn't make\nsense (e.g. function A is listed above function B, but B doesn't\ncall A), then it's a good sign that you're corrupting a kernel\nthread's stack, because the backtrace is extracted from the stack.\nAlternatively, it could be that the <Q><TT>kernel.o</TT></Q> you passed to\n<CODE>backtrace</CODE> is not the same kernel that produced\nthe backtrace.\n</P>\n<P>\n\nSometimes backtraces can be confusing without any corruption.\nCompiler optimizations can cause surprising behavior.  When a function\nhas called another function as its final action (a <EM>tail call</EM>), the\ncalling function may not appear in a backtrace at all.  Similarly, when\nfunction A calls another function B that never returns, the compiler may\noptimize such that an unrelated function C appears in the backtrace\ninstead of A.  Function C is simply the function that happens to be in\nmemory just after A.  In the threads project, this is commonly seen in\nbacktraces for test failures; see <A HREF=\"pintos_3.html#The pass function fails\"><CODE>pass()</CODE> Fails</A>, for more information.\n</P>\n<P>\n\n<A NAME=\"Backtrace Example\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC160\"></A>\n<H3> E.4.1 Example </H3>\n<!--docid::SEC160::-->\n<P>\n\nHere's an example.  Suppose that Pintos printed out this following call\nstack, which is taken from an actual Pintos submission for the file\nsystem project:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>Call stack: 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319\n0xc010325a 0x804812c 0x8048a96 0x8048ac8.\n</pre></td></tr></table><P>\n\nYou would then invoke the <CODE>backtrace</CODE> utility like shown below,\ncutting and pasting the backtrace information into the command line.\nThis assumes that <Q><TT>kernel.o</TT></Q> is in the current directory.  You\nwould of course enter all of the following on a single shell command\nline, even though that would overflow our margins here:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>backtrace kernel.o 0xc0106eff 0xc01102fb 0xc010dc22 0xc010cf67 \n0xc0102319 0xc010325a 0x804812c 0x8048a96 0x8048ac8\n</pre></td></tr></table><P>\n\nThe backtrace output would then look something like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>0xc0106eff: debug_panic (lib/debug.c:86)\n0xc01102fb: file_seek (filesys/file.c:405)\n0xc010dc22: seek (userprog/syscall.c:744)\n0xc010cf67: syscall_handler (userprog/syscall.c:444)\n0xc0102319: intr_handler (threads/interrupt.c:334)\n0xc010325a: intr_entry (threads/intr-stubs.S:38)\n0x0804812c: (unknown)\n0x08048a96: (unknown)\n0x08048ac8: (unknown)\n</pre></td></tr></table><P>\n\n(You will probably not see exactly the same addresses if you run the\ncommand above on your own kernel binary, because the source code you\ncompiled and the compiler you used are probably different.)\n</P>\n<P>\n\nThe first line in the backtrace refers to <CODE>debug_panic()</CODE>, the\nfunction that implements kernel panics.  Because backtraces commonly\nresult from kernel panics, <CODE>debug_panic()</CODE> will often be the first\nfunction shown in a backtrace.\n</P>\n<P>\n\nThe second line shows <CODE>file_seek()</CODE> as the function that panicked,\nin this case as the result of an assertion failure.  In the source code\ntree used for this example, line 405 of <Q><TT>filesys/file.c</TT></Q> is the\nassertion\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>ASSERT (file_ofs &gt;= 0);\n</pre></td></tr></table><P>\n\n(This line was also cited in the assertion failure message.)\nThus, <CODE>file_seek()</CODE> panicked because it passed a negative file offset\nargument.\n</P>\n<P>\n\nThe third line indicates that <CODE>seek()</CODE> called <CODE>file_seek()</CODE>,\npresumably without validating the offset argument.  In this submission,\n<CODE>seek()</CODE> implements the <CODE>seek</CODE> system call.\n</P>\n<P>\n\nThe fourth line shows that <CODE>syscall_handler()</CODE>, the system call\nhandler, invoked <CODE>seek()</CODE>.\n</P>\n<P>\n\nThe fifth and sixth lines are the interrupt handler entry path.\n</P>\n<P>\n\nThe remaining lines are for addresses below <CODE>PHYS_BASE</CODE>.  This\nmeans that they refer to addresses in the user program, not in the\nkernel.  If you know what user program was running when the kernel\npanicked, you can re-run <CODE>backtrace</CODE> on the user program, like\nso: (typing the command on a single line, of course):\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>backtrace tests/filesys/extended/grow-too-big 0xc0106eff 0xc01102fb\n0xc010dc22 0xc010cf67 0xc0102319 0xc010325a 0x804812c 0x8048a96\n0x8048ac8\n</pre></td></tr></table><P>\n\nThe results look like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>0xc0106eff: (unknown)\n0xc01102fb: (unknown)\n0xc010dc22: (unknown)\n0xc010cf67: (unknown)\n0xc0102319: (unknown)\n0xc010325a: (unknown)\n0x0804812c: test_main (...xtended/grow-too-big.c:20)\n0x08048a96: main (tests/main.c:10)\n0x08048ac8: _start (lib/user/entry.c:9)\n</pre></td></tr></table><P>\n\nYou can even specify both the kernel and the user program names on\nthe command line, like so:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>backtrace kernel.o tests/filesys/extended/grow-too-big 0xc0106eff\n0xc01102fb 0xc010dc22 0xc010cf67 0xc0102319 0xc010325a 0x804812c\n0x8048a96 0x8048ac8\n</pre></td></tr></table><P>\n\nThe result is a combined backtrace:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>In kernel.o:\n0xc0106eff: debug_panic (lib/debug.c:86)\n0xc01102fb: file_seek (filesys/file.c:405)\n0xc010dc22: seek (userprog/syscall.c:744)\n0xc010cf67: syscall_handler (userprog/syscall.c:444)\n0xc0102319: intr_handler (threads/interrupt.c:334)\n0xc010325a: intr_entry (threads/intr-stubs.S:38)\nIn tests/filesys/extended/grow-too-big:\n0x0804812c: test_main (...xtended/grow-too-big.c:20)\n0x08048a96: main (tests/main.c:10)\n0x08048ac8: _start (lib/user/entry.c:9)\n</pre></td></tr></table><P>\n\nHere's an extra tip for anyone who read this far: <CODE>backtrace</CODE>\nis smart enough to strip the <CODE>Call stack:</CODE> header and <Q><SAMP>.</SAMP></Q>\ntrailer from the command line if you include them.  This can save you\na little bit of trouble in cutting and pasting.  Thus, the following\ncommand prints the same output as the first one we used:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>backtrace kernel.o Call stack: 0xc0106eff 0xc01102fb 0xc010dc22\n0xc010cf67 0xc0102319 0xc010325a 0x804812c 0x8048a96 0x8048ac8.\n</pre></td></tr></table><P>\n\n<A NAME=\"GDB\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC161\"></A>\n<H2> E.5 GDB </H2>\n<!--docid::SEC161::-->\n<P>\n\nYou can run Pintos under the supervision of the GDB debugger.\nFirst, start Pintos with the <Q><SAMP>--gdb</SAMP></Q> option, e.g.\n<CODE>pintos --gdb -- run mytest</CODE>.  Second, open a second terminal on\nthe same machine and\nuse <CODE>pintos-gdb</CODE> to invoke GDB on\n<Q><TT>kernel.o</TT></Q>:<A NAME=\"DOCF7\" HREF=\"pintos_fot.html#FOOT7\">(7)</A>\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>pintos-gdb kernel.o\n</pre></td></tr></table>and issue the following GDB command:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>target remote localhost:1234\n</pre></td></tr></table><P>\n\nNow GDB is connected to the simulator over a local\nnetwork connection.  You can now issue any normal GDB\ncommands.  If you issue the <Q><SAMP>c</SAMP></Q> command, the simulated BIOS will take\ncontrol, load Pintos, and then Pintos will run in the usual way.  You\ncan pause the process at any point with <KBD>Ctrl+C</KBD>.\n</P>\n<P>\n\n<A NAME=\"Using GDB\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC162\"></A>\n<H3> E.5.1 Using GDB </H3>\n<!--docid::SEC162::-->\n<P>\n\nYou can read the GDB manual by typing <CODE>info gdb</CODE> at a\nterminal command prompt.  Here's a few commonly useful GDB commands:\n</P>\n<P>\n\n<A NAME=\"IDX190\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>c</B>\n<DD>Continues execution until <KBD>Ctrl+C</KBD> or the next breakpoint.\n</DL>\n<P>\n\n<A NAME=\"IDX191\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>si</B>\n<DD>Execute one machine instruction\n</DL>\n<P>\n\n<A NAME=\"IDX192\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>b</B> <I>function</I>\n<DD><A NAME=\"IDX193\"></A>\n<DT><U>GDB Command:</U> <B>b</B> <I>file:line</I>\n<DD><A NAME=\"IDX194\"></A>\n<DT><U>GDB Command:</U> <B>b</B> <I>*address</I>\n<DD>Sets a breakpoint at <VAR>function</VAR>, at <VAR>line</VAR> within <VAR>file</VAR>, or\n<VAR>address</VAR>. <CODE>b</CODE> is short for <CODE>break</CODE> or <CODE>breakpoint</CODE>.\n(Use a <Q><SAMP>0x</SAMP></Q> prefix to specify an address in hex.)\n<P>\n\nUse <CODE>b pintos_init</CODE> to make GDB stop when Pintos starts running.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX195\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>p</B> <I>expression</I>\n<DD>Evaluates the given <VAR>expression</VAR> and prints its value.\nIf the expression contains a function call, that function will actually\nbe executed.\n</DL>\n<P>\n\n<A NAME=\"IDX196\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>info</B> <I>registers</I>\n<DD>Print the general purpose registers, eip, eflags, and the segment selectors. For \na much more thorough dump of the machine register state, see QEMU's own info \nregisters command.\n</DL>\n<P>\n\n<A NAME=\"IDX197\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>x/Nx</B> <I>addr</I>\n<DD>Display a hex dump of N words starting at virtual address addr. If N is omitted, it defaults to 1. addr can be any expression.\n</DL>\n<P>\n\n<A NAME=\"IDX198\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>x/Ni</B> <I>addr</I>\n<DD>Display the N assembly instructions starting at addr. Using $eip as addr will display the instructions at the current instruction pointer.\n</DL>\n<P>\n\n<A NAME=\"IDX199\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>l</B> <I>*address</I>\n<DD>Lists a few lines of code around <VAR>address</VAR>.\n(Use a <Q><SAMP>0x</SAMP></Q> prefix to specify an address in hex.)\n</DL>\n<P>\n\n<A NAME=\"IDX200\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>bt</B>\n<DD>Prints a stack backtrace similar to that output by the\n<CODE>backtrace</CODE> program described above.\n</DL>\n<P>\n\n<A NAME=\"IDX201\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>p/a</B> <I>address</I>\n<DD>Prints the name of the function or variable that occupies <VAR>address</VAR>.\n(Use a <Q><SAMP>0x</SAMP></Q> prefix to specify an address in hex.)\n</DL>\n<P>\n\n<A NAME=\"IDX202\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>diassemble</B> <I>function</I>\n<DD>Disassembles <VAR>function</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX203\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>thread</B> <I>n</I>\n<DD>GDB focuses on one thread (i.e., CPU) at a time. This command switches that focus to thread n, numbered from zero.\n</DL>\n<P>\n\n<A NAME=\"IDX204\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>info</B> <I>threads</I>\n<DD>List all threads (i.e., CPUs), including their state (active or halted) and what function they're in.\n</DL>\n<P>\n\n<A NAME=\"IDX205\"></A>\n</P>\n<DL>\n<DT><U>GDB Command:</U> <B>thread</B> <I>n</I>\n<DD>Switch to symbol file file. When GDB attaches to QEMU, it has no notion of the process \nboundaries within the virtual machine, so we have to tell it which symbols to use. \nBy default, we configure GDB to use the kernel symbol file, <Q><TT>build/kernel.o</TT></Q>. \nIf the machine is running user code, say <Q><TT>hello.c</TT></Q>, you can switch to the <Q><TT>hello</TT></Q>\nsymbol file using <CODE>symbol-file examples/hello.o</CODE>.\n</DL>\n<P>\n\nWe also provide a set of macros specialized for debugging Pintos,\nwritten by Godmar Back <A HREF=\"mailto:gback@cs.vt.edu\">gback@cs.vt.edu</A>.  You can type\n<CODE>help user-defined</CODE> for basic help with the macros.  Here is an\noverview of their functionality, based on Godmar's documentation:\n</P>\n<P>\n\n<A NAME=\"IDX206\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>debugpintos</B>\n<DD>Attach debugger to a waiting pintos process on the same machine.\nShorthand for <CODE>target remote localhost:1234</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX207\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>dumplist</B> <I>list type element</I>\n<DD>Prints the elements of <VAR>list</VAR>, which should be a <CODE>struct</CODE> list\nthat contains elements of the given <VAR>type</VAR> (without the word\n<CODE>struct</CODE>) in which <VAR>element</VAR> is the <CODE>struct list_elem</CODE> member\nthat links the elements.\n<P>\n\nExample: <CODE>dumplist all_list thread allelem</CODE> prints all elements of\n<CODE>struct thread</CODE> that are linked in <CODE>struct list all_list</CODE> using the\n<CODE>struct list_elem allelem</CODE> which is part of <CODE>struct thread</CODE>.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX208\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>btthread</B> <I>thread</I>\n<DD>Shows the backtrace of <VAR>thread</VAR>, which is a pointer to the\n<CODE>struct thread</CODE> of the thread whose backtrace it should show.  For the\ncurrent thread, this is identical to the <CODE>bt</CODE> (backtrace) command.\nIt also works for any thread suspended in <CODE>schedule()</CODE>,\nprovided you know where its kernel stack page is located.\n</DL>\n<P>\n\n<A NAME=\"IDX209\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>btthreadlist</B> <I>list element</I>\n<DD>Shows the backtraces of all threads in <VAR>list</VAR>, the <CODE>struct list</CODE> in\nwhich the threads are kept.  Specify <VAR>element</VAR> as the\n<CODE>struct list_elem</CODE> field used inside <CODE>struct thread</CODE> to link the threads\ntogether.\n<P>\n\nExample: <CODE>btthreadlist all_list allelem</CODE> shows the backtraces of\nall threads contained in <CODE>struct list all_list</CODE>, linked together by\n<CODE>allelem</CODE>.  This command is useful to determine where your threads\nare stuck when a deadlock occurs.  Please see the example scenario below.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX210\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>btthreadall</B>\n<DD>Short-hand for <CODE>btthreadlist all_list allelem</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX211\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>btpagefault</B>\n<DD>Print a backtrace of the current thread after a page fault exception.\nNormally, when a page fault exception occurs, GDB will stop\nwith a message that might say:<A NAME=\"DOCF8\" HREF=\"pintos_fot.html#FOOT8\">(8)</A>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>Program received signal 0, Signal 0.\n0xc0102320 in intr0e_stub ()\n</pre></td></tr></table><P>\n\nIn that case, the <CODE>bt</CODE> command might not give a useful\nbacktrace.  Use <CODE>btpagefault</CODE> instead.\n</P>\n<P>\n\nYou may also use <CODE>btpagefault</CODE> for page faults that occur in a user\nprocess.  In this case, you may wish to also load the user program's\nsymbol table using the <CODE>loadusersymbols</CODE> macro, as described above.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX212\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>hook-stop</B>\n<DD>GDB invokes this macro every time the simulation stops, which Bochs will\ndo for every processor exception, among other reasons.  If the\nsimulation stops due to a page fault, <CODE>hook-stop</CODE> will print a\nmessage that says and explains further whether the page fault occurred\nin the kernel or in user code.\n<P>\n\nIf the exception occurred from user code, <CODE>hook-stop</CODE> will say:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>pintos-debug: a page fault exception occurred in user mode\npintos-debug: hit 'c' to continue, or 's' to step to intr_handler\n</pre></td></tr></table><P>\n\nIn Project 2, a page fault in a user process leads to the termination of\nthe process.  You should expect those page faults to occur in the\nrobustness tests where we test that your kernel properly terminates\nprocesses that try to access invalid addresses.  To debug those, set a\nbreak point in <CODE>page_fault()</CODE> in <Q><TT>exception.c</TT></Q>, which you will\nneed to modify accordingly.\n</P>\n<P>\n\nIn Project 3, a page fault in a user process no longer automatically\nleads to the termination of a process.  Instead, it may require reading in\ndata for the page the process was trying to access, either\nbecause it was swapped out or because this is the first time it's\naccessed.  In either case, you will reach <CODE>page_fault()</CODE> and need to\ntake the appropriate action there.\n</P>\n<P>\n\nIf the page fault did not occur in user mode while executing a user\nprocess, then it occurred in kernel mode while executing kernel code.\nIn this case, <CODE>hook-stop</CODE> will print this message:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>pintos-debug: a page fault occurred in kernel mode\n</pre></td></tr></table>followed by the output of the <CODE>btpagefault</CODE> command.\n<P>\n\nBefore Project 3, a page fault exception in kernel code is always a bug\nin your kernel, because your kernel should never crash.  Starting with\nProject 3, the situation will change if you use the <CODE>get_user()</CODE> and\n<CODE>put_user()</CODE> strategy to verify user memory accesses\n(see section <A HREF=\"pintos_4.html#SEC49\">4.1.5 Accessing User Memory</A>).\n</P>\n<P>\n\n</P>\n</DL>\n<P>\n\n<A NAME=\"Example GDB Session\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC163\"></A>\n<H3> E.5.2 Example GDB Session </H3>\n<!--docid::SEC163::-->\n<P>\n\nThis section narrates a sample GDB session, provided by Godmar Back.\nThis example illustrates how one might debug a Project 1 solution in\nwhich occasionally a thread that calls <CODE>timer_sleep()</CODE> is not woken\nup.  With this bug, tests such as <CODE>mlfqs_load_1</CODE> get stuck.\n</P>\n<P>\n\nThis session was captured with a slightly older version of Bochs and the\nGDB macros for Pintos, so it looks slightly different than it would now.\nProgram output is shown in normal type, user input in <STRONG>strong</STRONG>\ntype.\n</P>\n<P>\n\nFirst, I start Pintos:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>$ <STRONG>pintos -v --gdb -- -q -mlfqs run mlfqs-load-1</STRONG>\nWriting command line to /tmp/gDAlqTB5Uf.dsk...\nbochs -q\n========================================================================\n                       Bochs x86 Emulator 2.2.5\n             Build from CVS snapshot on December 30, 2005\n========================================================================\n00000000000i[     ] reading configuration from bochsrc.txt\n00000000000i[     ] Enabled gdbstub\n00000000000i[     ] installing nogui module as the Bochs GUI\n00000000000i[     ] using log file bochsout.txt\nWaiting for gdb connection on localhost:1234\n</FONT></pre></td></tr></table><P>\n\nThen, I open a second window on the same machine and start GDB:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>$ <STRONG>pintos-gdb kernel.o</STRONG>\nGNU gdb Red Hat Linux (6.3.0.0-1.84rh)\nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType &quot;show copying&quot; to see the conditions.\nThere is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.\nThis GDB was configured as &quot;i386-redhat-linux-gnu&quot;...\nUsing host libthread_db library &quot;/lib/libthread_db.so.1&quot;.\n</FONT></pre></td></tr></table><P>\n\nThen, I tell GDB to attach to the waiting Pintos emulator:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>(gdb) <STRONG>debugpintos</STRONG>\nRemote debugging using localhost:1234\n0x0000fff0 in ?? ()\nReply contains invalid hex digit 78\n</FONT></pre></td></tr></table><P>\n\nNow I tell Pintos to run by executing <CODE>c</CODE> (short for\n<CODE>continue</CODE>) twice:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>(gdb) <STRONG>c</STRONG>\nContinuing.\nReply contains invalid hex digit 78\n(gdb) <STRONG>c</STRONG>\nContinuing.\n</FONT></pre></td></tr></table><P>\n\nNow Pintos will continue and output:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>Pintos booting with 4,096 kB RAM...\nKernel command line: -q -mlfqs run mlfqs-load-1\n374 pages available in kernel pool.\n373 pages available in user pool.\nCalibrating timer...  102,400 loops/s.\nBoot complete.\nExecuting 'mlfqs-load-1':\n(mlfqs-load-1) begin\n(mlfqs-load-1) spinning for up to 45 seconds, please wait...\n(mlfqs-load-1) load average rose to 0.5 after 42 seconds\n(mlfqs-load-1) sleeping for another 10 seconds, please wait...\n</FONT></pre></td></tr></table><P>\n\n<small>...</small>until it gets stuck because of the bug I had introduced.  I hit\n<KBD>Ctrl+C</KBD> in the debugger window:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>Program received signal 0, Signal 0.\n0xc010168c in next_thread_to_run () at ../../threads/thread.c:649\n649\t  while (i &lt;= PRI_MAX &amp;&amp; list_empty (&amp;ready_list[i]))\n(gdb) \n</FONT></pre></td></tr></table><P>\n\nThe thread that was running when I interrupted Pintos was the idle\nthread.  If I run <CODE>backtrace</CODE>, it shows this backtrace:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>(gdb) <STRONG>bt</STRONG>\n#0  0xc010168c in next_thread_to_run () at ../../threads/thread.c:649\n#1  0xc0101778 in schedule () at ../../threads/thread.c:714\n#2  0xc0100f8f in thread_block () at ../../threads/thread.c:324\n#3  0xc0101419 in idle (aux=0x0) at ../../threads/thread.c:551\n#4  0xc010145a in kernel_thread (function=0xc01013ff , aux=0x0)\n    at ../../threads/thread.c:575\n#5  0x00000000 in ?? ()\n</FONT></pre></td></tr></table><P>\n\nNot terribly useful.  What I really like to know is what's up with the\nother thread (or threads).  Since I keep all threads in a linked list\ncalled <CODE>all_list</CODE>, linked together by a <CODE>struct list_elem</CODE> member\nnamed <CODE>allelem</CODE>, I can use the <CODE>btthreadlist</CODE> macro from the\nmacro library I wrote.  <CODE>btthreadlist</CODE> iterates through the list of\nthreads and prints the backtrace for each thread:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>(gdb) <STRONG>btthreadlist all_list allelem</STRONG>\npintos-debug: dumping backtrace of thread 'main' @0xc002f000\n#0  0xc0101820 in schedule () at ../../threads/thread.c:722\n#1  0xc0100f8f in thread_block () at ../../threads/thread.c:324\n#2  0xc0104755 in timer_sleep (ticks=1000) at ../../devices/timer.c:141\n#3  0xc010bf7c in test_mlfqs_load_1 () at ../../tests/threads/mlfqs-load-1.c:49\n#4  0xc010aabb in run_test (name=0xc0007d8c &quot;mlfqs-load-1&quot;)\n    at ../../tests/threads/tests.c:50\n#5  0xc0100647 in run_task (argv=0xc0110d28) at ../../threads/init.c:281\n#6  0xc0100721 in run_actions (argv=0xc0110d28) at ../../threads/init.c:331\n#7  0xc01000c7 in main () at ../../threads/init.c:140\n\npintos-debug: dumping backtrace of thread 'idle' @0xc0116000\n#0  0xc010168c in next_thread_to_run () at ../../threads/thread.c:649\n#1  0xc0101778 in schedule () at ../../threads/thread.c:714\n#2  0xc0100f8f in thread_block () at ../../threads/thread.c:324\n#3  0xc0101419 in idle (aux=0x0) at ../../threads/thread.c:551\n#4  0xc010145a in kernel_thread (function=0xc01013ff , aux=0x0)\n    at ../../threads/thread.c:575\n#5  0x00000000 in ?? ()\n</FONT></pre></td></tr></table><P>\n\nIn this case, there are only two threads, the idle thread and the main\nthread.  The kernel stack pages (to which the <CODE>struct thread</CODE> points)\nare at <TT>0xc0116000</TT> and <TT>0xc002f000</TT>, respectively.  The main thread\nis stuck in <CODE>timer_sleep()</CODE>, called from <CODE>test_mlfqs_load_1</CODE>.\n</P>\n<P>\n\nKnowing where threads are stuck can be tremendously useful, for instance\nwhen diagnosing deadlocks or unexplained hangs.\n</P>\n<P>\n\n<A NAME=\"IDX213\"></A>\n</P>\n<DL>\n<DT><U>GDB Macro:</U> <B>loadusersymbols</B>\n<DD><P>\n\nYou can also use GDB to debug a user program running under Pintos.  \nTo do that, use the <CODE>loadusersymbols</CODE> macro to load the program's \nsymbol table:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>loadusersymbols <VAR>program</VAR>\n</pre></td></tr></table>where <VAR>program</VAR> is the name of the program's executable (in the host\nfile system, not in the Pintos file system).  For example, you may issue:\n<TABLE><tr><td>&nbsp;</td><td class=smallexample><pre><FONT SIZE=-1>(gdb) <STRONG>loadusersymbols tests/userprog/exec-multiple</STRONG>\nadd symbol table from file &quot;tests/userprog/exec-multiple&quot; at\n    .text_addr = 0x80480a0\n(gdb) \n</FONT></pre></td></tr></table><P>\n\nAfter this, you should be\nable to debug the user program the same way you would the kernel, by\nplacing breakpoints, inspecting data, etc.  Your actions apply to every\nuser program running in Pintos, not just to the one you want to debug,\nso be careful in interpreting the results:  GDB does not know\nwhich process is currently active (because that is an abstraction \nthe Pintos kernel creates).  Also, a name that appears in\nboth the kernel and the user program will actually refer to the kernel\nname.  (The latter problem can be avoided by giving the user executable\nname on the GDB command line, instead of <Q><TT>kernel.o</TT></Q>, and then using\n<CODE>loadusersymbols</CODE> to load <Q><TT>kernel.o</TT></Q>.)\n<CODE>loadusersymbols</CODE> is implemented via GDB's <CODE>add-symbol-file</CODE>\ncommand.\n</P>\n<P>\n\n</P>\n</DL>\n<P>\n\n<A NAME=\"GDB FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC164\"></A>\n<H3> E.5.3 FAQ </H3>\n<!--docid::SEC164::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT>GDB can't connect to Bochs.\n<DD><P>\n\nIf the <CODE>target remote</CODE> command fails, then make sure that both\nGDB and <CODE>pintos</CODE> are running on the same machine by\nrunning <CODE>hostname</CODE> in each terminal.  If the names printed\ndiffer, then you need to open a new terminal for GDB on the\nmachine running <CODE>pintos</CODE>.\n</P>\n<P>\n\n</P>\n<DT>GDB doesn't recognize any of the macros.\n<DD><P>\n\nIf you start GDB with <CODE>pintos-gdb</CODE>, it should load the Pintos\nmacros automatically.  If you start GDB some other way, then you must\nissue the command <CODE>source <VAR>pintosdir</VAR>/src/misc/gdb-macros</CODE>,\nwhere <VAR>pintosdir</VAR> is the root of your Pintos directory, before you\ncan use them.\n</P>\n<P>\n\n</P>\n<DT>Can I debug Pintos with DDD?\n<DD><P>\n\nYes, you can.  DDD invokes GDB as a subprocess, so you'll need to tell\nit to invokes <CODE>pintos-gdb</CODE> instead:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>ddd --gdb --debugger pintos-gdb\n</pre></td></tr></table><P>\n\n</P>\n<DT>Can I use GDB inside Emacs?\n<DD><P>\n\nYes, you can.  Emacs has special support for running GDB as a\nsubprocess.  Type <KBD>M-x gdb</KBD> and enter your <CODE>pintos-gdb</CODE>\ncommand at the prompt.  The Emacs manual has information on how to use\nits debugging features in a section titled &quot;Debuggers.&quot;\n</P>\n<P>\n\n</P>\n<DT>GDB is doing something weird.\n<DD><P>\n\nIf you notice strange behavior while using GDB, there\nare three possibilities: a bug in your\nmodified Pintos, a bug in Bochs's\ninterface to GDB or in GDB itself, or\na bug in the original Pintos code.  The first and second\nare quite likely, and you should seriously consider both.  We hope\nthat the third is less likely, but it is also possible.\n</DL>\n<P>\n\n<A NAME=\"Triple Faults\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC165\"></A>\n<H2> E.6 Triple Faults </H2>\n<!--docid::SEC165::-->\n<P>\n\nWhen a CPU exception handler, such as a page fault handler, cannot be\ninvoked because it is missing or defective, the CPU will try to invoke\nthe &quot;double fault&quot; handler.  If the double fault handler is itself\nmissing or defective, that's called a &quot;triple fault.&quot;  A triple fault\ncauses an immediate CPU reset.\n</P>\n<P>\n\nThus, if you get yourself into a situation where the machine reboots in\na loop, that's probably a &quot;triple fault.&quot;  In a triple fault\nsituation, you might not be able to use <CODE>printf()</CODE> for debugging,\nbecause the reboots might be happening even before everything needed for\n<CODE>printf()</CODE> is initialized.\n</P>\n<P>\n\nThere are at least two ways to debug triple faults.  First, you can run\nPintos in Bochs under GDB (see section <A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A>).  If Bochs has been built\nproperly for Pintos, a triple fault under GDB will cause it to print the\nmessage &quot;Triple fault: stopping for gdb&quot; on the console and break into\nthe debugger.  (If Bochs is not running under GDB, a triple fault will\nstill cause it to reboot.)  You can then inspect where Pintos stopped,\nwhich is where the triple fault occurred.\n</P>\n<P>\n\nAnother option is what I call &quot;debugging by infinite loop.&quot;\nPick a place in the Pintos code, insert the infinite loop\n<CODE>for (;;);</CODE> there, and recompile and run.  There are two likely\npossibilities:\n</P>\n<P>\n\n<UL>\n<LI>\nThe machine hangs without rebooting.  If this happens, you know that\nthe infinite loop is running.  That means that whatever caused the\nreboot must be <EM>after</EM> the place you inserted the infinite loop.\nNow move the infinite loop later in the code sequence.\n<P>\n\n</P>\n<LI>\nThe machine reboots in a loop.  If this happens, you know that the\nmachine didn't make it to the infinite loop.  Thus, whatever caused the\nreboot must be <EM>before</EM> the place you inserted the infinite loop.\nNow move the infinite loop earlier in the code sequence.\n</UL>\n<P>\n\nIf you move around the infinite loop in a &quot;binary search&quot; fashion, you\ncan use this technique to pin down the exact spot that everything goes\nwrong.  It should only take a few minutes at most.\n</P>\n<P>\n\n<A NAME=\"Modifying Bochs\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC166\"></A>\n<H2> E.7 Modifying Bochs </H2>\n<!--docid::SEC166::-->\n<P>\n\nAn advanced debugging technique is to modify and recompile the\nsimulator.  This proves useful when the simulated hardware has more\ninformation than it makes available to the OS.  For example, page\nfaults have a long list of potential causes, but the hardware does not\nreport to the OS exactly which one is the particular cause.\nFurthermore, a bug in the kernel's handling of page faults can easily\nlead to recursive faults, but a &quot;triple fault&quot; will cause the CPU to\nreset itself, which is hardly conducive to debugging.\n</P>\n<P>\n\nIn a case like this, you might appreciate being able to make Bochs\nprint out more debug information, such as the exact type of fault that\noccurred.  It's not very hard.  You start by retrieving the source\ncode for Bochs 2.6.2 from <A HREF=\"http://bochs.sourceforge.net\">http://bochs.sourceforge.net</A> and\nsaving the file <Q><TT>bochs-2.6.2.tar.gz</TT></Q> into a directory.  \nThe script <Q><TT>pintos/src/misc/bochs-2.6.2-build.sh</TT></Q>\napplies a number of patches contained in <Q><TT>pintos/src/misc</TT></Q>\nto the Bochs tree, then builds Bochs and installs it in a directory\nof your choice.\nRun this script without arguments to learn usage instructions.\nTo use your <Q><TT>bochs</TT></Q> binary with <CODE>pintos</CODE>,\nput it in your <CODE>PATH</CODE>, and make sure that it is earlier than\n<Q><TT>/usr/local/data/cs318/x86_64/bin/bochs</TT></Q>.\n</P>\n<P>\n\nOf course, to get any good out of this you'll have to actually modify\nBochs.  Instructions for doing this are firmly out of the scope of\nthis document.  However, if you want to debug page faults as suggested\nabove, a good place to start adding <CODE>printf()</CODE>s is\n<CODE>BX_CPU_C::dtranslate_linear()</CODE> in <Q><TT>cpu/paging.cc</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"Debugging Tips\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC167\"></A>\n<H2> E.8 Tips </H2>\n<!--docid::SEC167::-->\n<P>\n\nThe page allocator in <Q><TT>threads/palloc.c</TT></Q> and the block allocator in\n<Q><TT>threads/malloc.c</TT></Q> clear all the bytes in memory to\n<TT>0xcc</TT> at time of free.  Thus, if you see an attempt to\ndereference a pointer like <TT>0xcccccccc</TT>, or some other reference to\n<TT>0xcc</TT>, there's a good chance you're trying to reuse a page that's\nalready been freed.  Also, byte <TT>0xcc</TT> is the CPU opcode for &quot;invoke\ninterrupt 3,&quot; so if you see an error like <CODE>Interrupt 0x03 (#BP\nBreakpoint Exception)</CODE>, then Pintos tried to execute code in a freed page or\nblock.\n</P>\n<P>\n\nAn assertion failure on the expression <CODE>sec_no &lt; d-&gt;capacity</CODE>\nindicates that Pintos tried to access a file through an inode that has\nbeen closed and freed.  Freeing an inode clears its starting sector\nnumber to <TT>0xcccccccc</TT>, which is not a valid sector number for disks\nsmaller than about 1.6 TB.\n<A NAME=\"Development Tools\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_11.html#SEC155\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_12.html#SEC168\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}