{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_2.html#SEC19", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Project 0--Getting Real</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Project 0--Getting Real\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Project 0--Getting Real\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC15\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_1.html#SEC1\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_3.html#SEC25\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> 2. Project 0: Getting Real </H1>\n<!--docid::SEC15::-->\n<P>\n\nThis assignment is setup to prepare you for the later Pintos projects. It will \nwalk you through what happens after a PC is powered on till when an operating\nsystem is up and running, which you may have wondered about it before. You will\nsetup the development environment, learn the Pintos workflow, and run/debug it \nin QEMU and Bochs. You will then do a simple programming exercise to add a \ntiny kernel monitor to Pintos. For this project only, the programming and \ndocumentation comprises 30% and 70% of the score respectively. Note that this \nassignment is simpler than the reset of the projects as it is intentionally \ndesigned to help you warm up. Part of this project's description and exercise \nis borrowed from the MIT 6.828 and Caltech CS 124 course.\n</P>\n<P>\n\n<A NAME=\"Project 0 Background\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC16\"></A>\n<H2> 2.1 Background </H2>\n<!--docid::SEC16::-->\n<P>\n\n<A NAME=\"PC Bootstrap\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC17\"></A>\n<H3> 2.1.1 PC Bootstrap </H3>\n<!--docid::SEC17::-->\n<P>\n\nThe process of loading the operating system into memory for running\nafter a PC is powered on is commonly known as <STRONG>bootstrapping</STRONG>. The\noperating system will then be loading other software such as the shell\nfor running. Two helpers are responsible for paving the way for bootstrapping: \nBIOS (Basic Input/Output System) and bootloader. The PC hardware is designed\nto make sure BIOS is always gets control of the machine first after the computer is\npowered on. The BIOS will be performing some test and initialization, e.g., checking \nmemory available and activating video card. After this initialization, the BIOS \nwill try to find a bootable device from some appropriate location such as a \nfloppy disk, hard disk, CD-ROM, or the network. Then the BIOS will pass control of \nthe machine to the bootloader who will load the operating system. \n</P>\n<P>\n\nWhile BIOS and the bootloader have a large task, they have very few resources \nto do it with. For example, IA32 bootloaders generally have to fit within 512 bytes \nin memory for a partition or floppy disk bootloader (i.e., only the first disk\n<EM>sector</EM>, and the last 2 bytes are fixed signatures for recognizing it is \na bootloader). For a bootloader in the Master Boot Record (MBR), it has to fit \nin an even smaller 436 bytes. In addition, since BIOS and bootloader are running \non bare-metals, there are no standard library call like <CODE>printf</CODE> or system \ncall like <CODE>read</CODE> available. Its main leverage is the limited BIOS interrupt \nservices. Many functionalities need to be implemented from scratch. For example, \nreading content from disk is easy inside OSes with system calls, but in bootloader, \nit has to deal with disk directly with complex hardware programming routines. As \na result, the bootloaders are generally written in assembly language, because \neven C code would include too much bloat!\n</P>\n<P>\n\nTo further understand this challenge, it is useful to look at the PC's physical \naddress space, which is hard-wired to have the following general layout:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>\t\t\t\t\t+------------------+  &lt;- 0xFFFFFFFF (4GB)\n\t\t\t\t\t|      32-bit      |\n\t\t\t\t\t|  memory mapped   |\n\t\t\t\t\t|     devices      |\n\t\t\t\t\t|                  |\n\t\t\t\t\t/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n\t\t\t\t\t/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\t\t\t\t\t|                  |\n\t\t\t\t\t|      Unused      |\n\t\t\t\t\t|                  |\n\t\t\t\t\t+------------------+  &lt;- depends on amount of RAM\n\t\t\t\t\t|                  |\n\t\t\t\t\t|                  |\n\t\t\t\t\t| Extended Memory  |\n\t\t\t\t\t|                  |\n\t\t\t\t\t|                  |\n\t\t\t\t\t+------------------+  &lt;- 0x00100000 (1MB)\n\t\t\t\t\t|     BIOS ROM     |\n\t\t\t\t\t+------------------+  &lt;- 0x000F0000 (960KB)\n\t\t\t\t\t|  16-bit devices, |\n\t\t\t\t\t|  expansion ROMs  |\n\t\t\t\t\t+------------------+  &lt;- 0x000C0000 (768KB)\n\t\t\t\t\t|   VGA Display    |\n\t\t\t\t\t+------------------+  &lt;- 0x000A0000 (640KB)\n\t\t\t\t\t|                  |\n\t\t\t\t\t|    Low Memory    |\n\t\t\t\t\t|                  |\n\t\t\t\t\t+------------------+  &lt;- 0x00000000\n\n\n</pre></td></tr></table><P>\n\nThe first PCs, which were based on the 16-bit Intel 8088 processor, were only capable \nof addressing 1MB of physical memory. The physical address space of an early PC \nwould therefore start at <TT>0x00000000</TT> but end at <TT>0x000FFFFF</TT> instead of <TT>0xFFFFFFFF</TT>. \nThe 640KB area marked &quot;Low Memory&quot; was the only random-access memory (RAM) that \nan early PC could use; in fact the very earliest PCs only could be configured with \n16KB, 32KB, or 64KB of RAM!\n</P>\n<P>\n\nThe 384KB area from <TT>0x000A0000</TT> through <TT>0x000FFFFF</TT> was reserved by the hardware \nfor special uses such as video display buffers and firmware held in non-volatile memory. \nThe most important part of this reserved area is the BIOS, which occupies the \n64KB region from <TT>0x000F0000</TT> through <TT>0x000FFFFF</TT>. In early PCs the BIOS was \nheld in true read-only memory (ROM), but current PCs store the BIOS in updateable \nflash memory. \n</P>\n<P>\n\nWhen Intel finally &quot;broke the one megabyte barrier&quot; with the 80286 and 80386 \nprocessors, which supported 16MB and 4GB physical address spaces respectively, \nthe PC architects nevertheless preserved the original layout for the low 1MB \nof physical address space in order to ensure backward compatibility with existing \nsoftware. Modern PCs therefore have a &quot;hole&quot; in physical memory from <TT>0x000A0000</TT>\nto <TT>0x00100000</TT>, dividing RAM into &quot;low&quot; or &quot;conventional memory&quot; (the first \n640KB) and &quot;extended memory&quot; (everything else). In addition, some space at the \nvery top of the PC's 32-bit physical address space, above all physical RAM, is \nnow commonly reserved by the BIOS for use by 32-bit PCI devices.\n</P>\n<P>\n\n<A NAME=\"The Boot Loader\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC18\"></A>\n<H3> 2.1.2 The Boot Loader </H3>\n<!--docid::SEC18::-->\n<P>\n\nFloppy and hard disks for PCs are divided into 512 byte regions called sectors. \nA sector is the disk's minimum transfer granularity: each read or write operation \nmust be one or more sectors in size and aligned on a sector boundary. If the disk \nis bootable, the first sector is called the boot sector, since this is where the \nboot loader code resides. When the BIOS finds a bootable floppy or hard disk, it \nloads the 512-byte boot sector into memory at physical addresses <TT>0x7c00</TT> through \n<TT>0x7dff</TT>, and then uses a <CODE>jmp</CODE> instruction to set the CS:IP to <TT>0000</TT>:<TT>7c00</TT>, \npassing control to the boot loader. \n</P>\n<P>\n\nIA32 bootloaders have the unenviable position of running in <STRONG>real-addressing \nmode</STRONG> (also known as &quot;real mode&quot;), where the segment registers are used to compute \nthe addresses of memory accesses according to the following formula:  \n<VAR>address</VAR> = 16 * <VAR>segment</VAR> + <VAR>offset</VAR>. The code segment CS is used \nfor instruction execution. For example, when the BIOS jump to <TT>0x0000:7c00</TT>, \nthe corresponding physical address is 16 * 0 + <TT>7c00</TT> = <TT>7c00</TT>. Other \nsegment registers include SS for the stack segment, DS for the data segment,\nand ES for moving data around as well.  Note that each segment is 64KiB in size;\nsince bootloaders often have to load kernels that are larger than 64KiB, they\nmust utilize the segment registers carefully.\n</P>\n<P>\n\nPintos bootloading is a pretty simple process compared to how modern OS kernels\nare loaded.  The kernel is a maximum of 512KiB (or 1024 sectors), and must be\nloaded into memory starting at the address <TT>0x20000</TT>. Pintos does require a \nspecific kind of partition for the OS, so the Pintos bootloader must look for a \ndisk partition of the appropriate type.  This means that the Pintos bootloader \nmust understand how to utilize Master Boot Records (MBRs).  Fortunately they \naren't very complicated to understand. Pintos also only supports booting off of \na hard disk; therefore, the Pintos bootloader doesn't need to check floppy drives \nor handle disks without an MBR in the first sector.\n</P>\n<P>\n\nWhen the loader finds a bootable kernel partition, it reads the\npartition's contents into memory at physical address 128 kB.  The\nkernel is at the beginning of the partition, which might be larger\nthan necessary due to partition boundary alignment conventions, so the\nloader reads no more than 512 kB (and the Pintos build process\nwill refuse to produce kernels larger than that).  Reading more data\nthan this would cross into the region from 640 kB to 1 MB that\nthe PC architecture reserves for hardware and the BIOS, and a standard\nPC BIOS does not provide any means to load the kernel above 1 MB.\n</P>\n<P>\n\nThe loader's final job is to extract the entry point from the loaded\nkernel image and transfer control to it.  The entry point is not at a\npredictable location, but the kernel's ELF header contains a pointer\nto it.  The loader extracts the pointer and jumps to the location it\npoints to.\n</P>\n<P>\n\nThe Pintos kernel command line is stored in the boot loader (using about 128 bytes).  \nThe <CODE>pintos</CODE> program actually modifies a copy of the boot loader on disk each time it runs the kernel,\ninserting whatever command-line arguments the user supplies to the kernel,\nand then the kernel at boot time reads those arguments out of the boot\nloader in memory.  This is not an elegant solution, but it is simple\nand effective.\n</P>\n<P>\n\n<A NAME=\"The Kernel\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC19\"></A>\n<H3> 2.1.3 The Kernel </H3>\n<!--docid::SEC19::-->\n<P>\n\nThe bootloader's last action is to transfer control to the kernel's entry\npoint, which is <CODE>start()</CODE> in <Q><TT>threads/start.S</TT></Q>.  The job of\nthis code is to switch the CPU from legacy 16-bit &quot;<STRONG>real mode</STRONG>&quot; into\nthe 32-bit &quot;<STRONG>protected mode</STRONG>&quot; used by all modern 80<VAR>x</VAR>86 operating\nsystems.\n</P>\n<P>\n\nThe kernel startup code's first task is actually to obtain the machine's\nmemory size, by asking the BIOS for the PC's memory size.  The\nsimplest BIOS function to do this can only detect up to 64 MB of RAM,\nso that's the practical limit that Pintos can support. \n</P>\n<P>\n\nIn additional, the kernel startup code needs to to enable the A20 line, that\nis, the CPU's address line numbered 20. For historical reasons, PCs\nboot with this address line fixed at 0, which means that attempts to\naccess memory beyond the first 1 MB (2 raised to the 20th power) will\nfail.  Pintos wants to access more memory than this, so we have to\nenable it.\n</P>\n<P>\n\nNext, the kernel will do a basic page table setup and turn on \nprotected mode and paging (details omitted for now).  The final step \nis to call into the C code of the Pintos kernel, which from here on\nwill be the main content we will deal with.\n</P>\n<P>\n\n<A NAME=\"Project 0 Requirements\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC20\"></A>\n<H2> 2.2 Project 0 Requirements </H2>\n<!--docid::SEC20::-->\n<P>\n\n<A NAME=\"Project 0 Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC21\"></A>\n<H3> 2.2.1 Project 0 Design Document </H3>\n<!--docid::SEC21::-->\n<P>\n\nBefore you turn in your project, you must copy <A HREF=\"real.tmpl\">the project 0 design document template</A> into your source tree under the\nname <Q><TT>pintos/src/p0/DESIGNDOC</TT></Q> and fill it in. \n</P>\n<P>\n\n<A NAME=\"Booting Pintos\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC22\"></A>\n<H3> 2.2.2 Booting Pintos </H3>\n<!--docid::SEC22::-->\n<P>\n\nRead the <A HREF=\"pintos_1.html#SEC1\">1. Introduction</A> section to get an overview of Pintos. Have Pintos development \nenvironment setup as described in <A HREF=\"https://cs.jhu.edu/~huang/cs318/fall17/project/setup.html\">Project Setup</A>. Afterwards, execute\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>$ cd pintos/src/threads\n$ make qemu\n</pre></td></tr></table><P>\n\nIf everything works, you should see Pintos booting in the <A HREF=\"http://www.qemu.org, ,QEMU emulator\">http://www.qemu.org, ,QEMU emulator</A>,\nand print <CODE>Boot complete.</CODE> near the end. In addition to the shell where\nyou execute the command, a new graphic window of QEMU will also pop up printing\nthe same messages. If you are remotely connecting to a machine, e.g., the \nlab machines of the CS department, you probably will encounter this error:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>Unable to init server: Could not connect: Connection refused\ngtk initialization failed\n</pre></td></tr></table>You need to figure out how to resolve this error and make the QEMU window appear.\n<EM>Hint:</EM> an option in <CODE>ssh</CODE> may be useful, check <CODE>man ssh</CODE>. \n<P>\n\nNote that to quit the Pintos interface, for the QEMU window, you can just close\nit; for the terminal, you need to press <CODE>Ctrl-a x</CODE> to exit (if you are\nrunning inside GNU screen or Tmux and its prefix key is Ctrl-a, \npress <CODE>Ctrl-a</CODE> <EM>twice</EM> and <CODE>x</CODE> to exit). We also provide a Makefile \ntarget to allow you to run Pintos just in the terminal: <CODE>make qemu-nox</CODE>.\n</P>\n<P>\n\nWhile by default we run Pintos in QEMU, Pintos can also run in the \n<A HREF=\"http://bochs.sourceforge.net/, ,Bochs\">http://bochs.sourceforge.net/, ,Bochs</A> and VMWare Player emulator. \nBochs will be useful for the <A HREF=\"pintos_3.html#SEC25\">3. Project 1: Threads</A>. To run Pintos with\nBochs, \n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>$ cd pintos/src/threads\n$ make \n$ cd build\n$ pintos --bochs -- run alarm-zero\n</pre></td></tr></table><P>\n\nTake screenshots of the successful booting of Pintos in QEMU and Bochs, each in \nboth the terminal and the QEMU window. Put the screenshots under <Q><TT>pintos/src/p0</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"Debugging\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC23\"></A>\n<H3> 2.2.3 Debugging </H3>\n<!--docid::SEC23::-->\n<P>\n\nWhile you are working on the projects, you will frequently use the GNU Debugger \n(GDB) to help you find bugs in your code. Make sure you read the \n<A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A> section first. In addition, if you are unfamiliar with x86 assembly,\nthe  <A HREF=\"pintos_14.html#PCASM\">PCASM</A> is an excellent book to start. Note that you don't need to read \nthe entire book, just the basic ones are enough.\n</P>\n<P>\n\nYour first task in this section is to use GDB to trace the QEMU BIOS a bit to understand \nhow an IA-32 compatible computer boots. Answer the following questions in your\ndesign document:\n<UL>\n<LI>What is the first instruction that gets executed?\n<LI>At which physical address is this instruction located?\n<LI>Can you guess why the first instruction is like this?\n<LI>What are the next three instructions?\n</UL>\n<P>\n\nIn the second task, you will be tracing the Pintos bootloader. Set a breakpoint \nat address <TT>0x7c00</TT>, which is where the boot sector will be loaded. Continue \nexecution until that breakpoint. Trace through the code in <Q><TT>threads/loader.S</TT></Q>, \nusing the source code and the disassembly file <Q><TT>threads/build/loader.asm</TT></Q> \nto keep track of where you are. Also use the <CODE>x/i</CODE> command in GDB to disassemble \nsequences of instructions in the boot loader, and compare the original boot loader \nsource code with both the disassembly in <Q><TT>threads/build/loader.asm</TT></Q> and \nGDB.\n</P>\n<P>\n\nAnswer the following questions in your\ndesign document:\n<UL>\n<LI>How does the bootloader read disk sectors? In particular, what BIOS interrupt\nis used?\n<LI>How does the bootloader decides whether it finds the Pintos kernel?\n<LI>What happens when the bootloader could not find the Pintos kernel?\n<LI>At what point does the bootloader transfer control to the Pintos kernel?\n</UL>\n<P>\n\nAfter the Pintos kernel take control, the initial setup is done in assembly \ncode <Q><TT>threads/start.S</TT></Q>. Later on, the kernel will finally kick into \nthe C world by calling the <CODE>pintos_init()</CODE> function in <Q><TT>threads/init.c</TT></Q>.\nSet a breakpoint at <CODE>pintos_init()</CODE> and then continue tracing a bit into the \nC initialization code. Then read the source code of <CODE>pintos_init()</CODE> function.\nFor this task, you don't need to submit anything. \n</P>\n<P>\n\n<A NAME=\"Kernel Monitor\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC24\"></A>\n<H3> 2.2.4 Kernel Monitor </H3>\n<!--docid::SEC24::-->\n<P>\n\nAt last, you will get to make a small enhancement to Pintos and write some code!\nIn particular, when Pintos finishes booting, it will check for the supplied \ncommand line arguments stored in the kernel image. Typically you will pass\nsome tests for the kernel to run, e.g., <CODE>pintos -- run alarm-zero</CODE>.\nIf there is no command line argument passed, the kernel will simply finish up.\nThis is a little boring. You task is to add a tiny kernel shell to Pintos\nso that when no command line argument is passed, it will run this shell interactively. \nNote that this is a kernel-level shell. In later projects, you will be enhancing \nthe user program and file system parts of Pintos, at which point you will get to \nrun the regular shell.\n</P>\n<P>\n\nThe code place for you to add this feature is in line <TT>136</TT> of \n<Q><TT>threads/init.c</TT></Q> with <CODE>// TODO: no command line passed to kernel. \nRun interactively</CODE>. You only need to make this monitor very simple. It starts with \na prompt <TT>CS318&gt; </TT> and waits for user input. When a newline is entered, it\nparses the input and checks if it is <TT>whoami</TT>. If it is <TT>whoami</TT>, print \nyour name. Afterwards, the monitor will print the command prompt <TT>CS318 &gt;</TT> \nagain in the next line and repeat. If the user input is <TT>exit</TT>, the monitor\nwill quit to allow the kernel to finish. For the other input, print \n<TT>invalid command</TT>. \n</P>\n<P>\n\n<EM>Hint:</EM> You may need to use some functions provided in <Q><TT>lib/kernel/console.c</TT></Q>,\n<Q><TT>lib/stdio.c</TT></Q> and <Q><TT>devices/input.c</TT></Q>.\n<A NAME=\"Project 1--Threads\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_2.html#SEC15\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_3.html#SEC25\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}