{"url": "https://www.ics.uci.edu/~eppstein/junkyard/godfried.toussaint.html", "content": "<HR><PRE>\n<B>From:</B>           Peter Yamamoto &lt;<A HREF=\"mailto:pjyamamo@watdragon.uwaterloo.ca\">pjyamamo@watdragon.uwaterloo.ca</A>&gt;\n<B>Subject:</B>        Re: RGI lecture notes\n<B>Date:</B>           Wed, 18 Aug 1993 13:30:31 -0400 (EDT)\n</PRE><HR><PRE>\n\"Triangulations and Arrangements\"\nGodfried Toussaint\nMcGill University\n\nAll Institute Lecture\nJuly 12, 1993\n\nScribes: Laura Anderson, Peter Yamamoto\nAssistant Editor: Pedro Ramos\n\nProfessor Toussaint's lecture discussed algorithms for triangulating\nsimple polygons in the plane.  A polytope in higher dimensions may not\nhave any triangulation, but for a two-dimensional polytope a\ntriangulation always exists.  Several algorithms for computing a\ntriangulation were discussed including a short history of published but\nincorrect algorithms.  The first talk was limited to triangulations;\narrangements were discussed in another lecture.\n\n------------------------------------------------------------\n\nFirst, some definitions:\n\nA _diagonal_ of a polygon is a line segment which connects two vertices\nof the polygon and which lies entirely inside the polygon.\n\nA _triangulation_ of a polygon is a decomposition of the polygon into\nnon-overlapping triangles by diagonals.\n\nNote that there are (n-3) non-intersecting diagonals which divide the\npolygon into (n-2) non-overlapping triangles.\n\nA fundamental lemma states that any polygon with n &gt; 3 vertices can\nbe partitioned into two sub-polygons by inserting some diagonal of P.\n\nFirst, note that this lemma does not generalize to higher dimensions.\nA simple example, due to Sch\\\"onhardt in 1928, is constructed by\ntwisting a prism.  Construct a triangular prism in three dimensions by\nusing an equilateral (say of unit length) triangle base in the xy plane\nand a copy of the base elevated above it (say translated by unit\nlength).  Finish the prism by attaching the two triangles with vertical\nedges.  Now rotate one of the triangular faces 30 degrees about the\nvertical axes, twisting the edges connecting the two triangles.  The\nresulting polytope, with eight triangular faces, cannot be\ntriangulated. In fact, one cannot add even one diagonal without\nbreaking up a triangular face.\n\nSecond, despite the simplicity of the lemma, many published proofs of\nit, or triangulation algorithms based on the lemma, are incorrect.\nProfessor Toussaint outlined three such errors.  For a more detailed\ndiscussion the reader is referred to [Ho].\n\n-----------------------------------------------------------------------\n\nAlgorithms That Don't Work (But Made It Into Print):\n\nFirst, Professor Toussaint noted that geometric algorithms, step by\nstep constructions using primitive operations, dates back to Euclid.\nHe also noted that despite this careful description of a construction\nsome algorithms do not always work.\n\nThere are a family of triangulation algorithms (or constructive proofs\nof the lemma) which follow the same general approach:  at each step,\neither cut off one empty triangle or add one diagonal. The algorithm is\nthen repeated on the resulting sub-polygon(s).\n\nWe first label the vertices of the polygon x(1), x(2),...,x(n) so that\nfor every i, the vertices x_i and x_{i+1} have an edge between them.\n\n        Find vertex x_i with leftmost x-coordinate\n        Look at the triangle [x_{i-1},x_i,x_{i+1}] formed by joining the\n        two adjacent vertices.\n\n        Step 1. If there are no other vertices inside that triangle\n                then the triangle [x_{i-1},x_i,x_{i+1}] is empty so delete\n                the triangle and repeat Step 1 on the resulting subpolygon.\n        Step 2. Otherwise there is at least one vertex in the triangle. \n                Hence there is some vertex x(k) which can be joined\n                to x_i with a diagonal thus splitting the polygon\n                into 2 subpolygons.  Repeat Step 1 on the two subpolygons.\n\n        There have been several published methods for handling Case 2.\n        Most are based on an intuition which goes wrong.\n\n-------------------------------------------------------------------------\nQuestion: Do you have any ideas for determining how to join x_i to another\nvertex to form a diagonal?\n--------------------------------------------------------------------------\n\nIntuition 1: Find an empty sub-triangle of [x_{i-1},x_i,x_{i+1}] by\nrotating a ray anchored at x_i from x_{i-1} to x_{i+1}.  Since there is\nat least one vertex in the triangle, the ray will hit some vertex in\nthis rotation.  Suppose x(k) is the first such vertex.  Then the\ntriangle [x_{i-1},x_i,x(k)] doesn't contain any other vertices inside of it\n(otherwise such a vertex would have been hit by the ray).  So connect\nx_i to x(k).\n\nIntuition 2: If there is a vertex in the triangle then there must be a\nvertex closer to x_i than any other vertex (other than x_{i-1} and\nx_{i+1}). So find the closest vertex x(k) in the triangle and join x_i\nto x(k).\n\nIntuition 3: Find the leftmost vertex x(k) inside the triangle\nand join x_i to x(k).\n\nHints are at the end, but try to draw counterexamples to each of\nthe intuitions by yourself.\n\n----------------------------------------------------------------------\n\nA 20th-Century proof that Triangulations Always Exist\n\nWe define a vertex x_i of a polygon P to be _principal_ if\nthe triangle with vertices {x_{i-1}, x_i, x_{i+1}} is empty.\nIf such a vertex is a concave point of P we call it a _mouth_\nelse it is convex and we call it an _ear_.\n\nTHE TWO-EARS THEOREM (Meister, 1975): Every simple polygon with\nat least four sides contains at least two non-overlapping ears.\n\nMeister provided a constructive proof which also provides a correct\nbut slow algorithm for triangulating the polygon.  Well, that's o.k. for\nmathematicians but computer scientists were still unhappy...\n\nAnother proof is based on properties of the _dual graph of a\ntriangulation_.  Consider a point inside each triangle.  Attach one\npoint to another if their triangles share a side.  Note that a triangle\ncan share one, two, or three sides.  Furthermore note that the dual\ngraph must be a tree since if not, it has a cycle, and this would\nrepresent a hole in the polygon which is not allowed (triangulation of\npolygons with holes is another matter).\n\nNow note that a leaf in the dual tree corresponds to a triangle with\nonly one adjacent triangle: an ear.  Since a tree with more than one\nnode always has at least two leaves, the triangulation must also have\nat least two ears.\n\nThe theorem suggests a method for triangulating: ``find an ear and cut\nit off''. This gives a correct but long algorithm for triangulating:\nsearching for ears to cut off can be very time-consuming. In the worst\ncase, triangulating a polygon this way can take O(n^3) time.\n\n------------------------------------------------------------------\n\nSome Algorithms That Do Work (And Are Faster Than Cutting Off Ears)\n\nIn a simple polygon, we can always find either an ear or a diagonal\nin O(n) time.\n\nProcedure DIAGONAL\n\nInput: A simple polygon P oriented in a counterclockwise direction.\nOutput: Polygon P with a diagonal inserted in P.\n\nStep 1. Find a convex vertex x_i of P.\nStep 2. Construct a ray at x_i, ray(x_i), that bisects the interior of\n        angle(x_{i-1}x_ix_{i+1}).\nStep 3. Find the first intersection point, called y, of ray(x_i) with the\n        boundary of P, bd(P).  y is on some edge [x_j,x_{j+1}] of P.\nStep 4. Construct the triangle [x_i,y,x_{j+1}].\nStep 5. For all j+1 &lt; k &lt; i, if x_k lies in triangle [x_i,y,x_{j+1}]\n        then label x_k as x*_k.  If there are no labeled vertices\n        then exit with [x_i,x_j+1] as the diagonal.\nStep 6. For all labeled vertices, compute angle(y,x_i,x*_k) and select\n        that vertex, call it z, which minimizes the angle.\n        If z &lt;&gt; (is not equal to) x_{i-1}, then exit with [x_i,z] as the\n        diagonal.\nStep 7. Construct the triangle [x_j,y,x_i].\nStep 8. For all j &gt; k &gt; i, if x_k lies in triangle [x_j,y,x_i] then\n        label x_k as x*_k.  If there are no labeled vertices, exit with\n        [x_i,x_j] as the diagonal.\nStep 9. For all labeled vertices compute angle(y,x_i,x*_k) and select\n        that vertex, call it w, that minimizes this angle.  If w &lt;&gt;\n        x_{i+1} then exit with [x_i,w] as the diagonal.\nStep 10. Exit with [x_{i-1},x_{i+1}] as the diagonal.\n\nThis procedure can then be used to triangulate in O(n^2) time.\n\nTo get an algorithm that works in better than O(n^2) time, let's first\nconsider the special case of a convex polygon. An O(n) algorithm for\ntriangulating it would be to start at some edge {x_i, x_{i+1}}, then\nadd either the triangle {x_{i-1}, x_i, x_{i+1}} or the triangle {x_i,\nx_{i+1}, x(i+2)} to our triangulation. Then we repeat this with the\nedge we just added, and continue until the whole polygon is\ntriangulated.  Note that at every step we made a choice of which\ntriangle to add.\n\nConsider the triangulation of the convex polygon that results from\njoining every second vertex (remember the vertices of P are given as an\nordered sequence) to a fixed vertex and then joining every second\nvertex with an edge.  In this case the dual tree has O(n) internal\nnodes and O(n) leaves.\n\nNow consider the triangulation of the same convex polygon obtained by\ndrawing all diagonals from one fixed vertex to all the vertices (this\nis possible because of the convexity) resulting in a triangulation that\nlooks like a fan.  In this case, note that the dual tree is very\nsimple:  it is simply a chain since each triangle, except for the first\nand last, has two adjacent triangles.  A triangulated polygon whose\ndual tree is a chain is called a sleeve.  A convex polygon always has a\ntriangulation which is a sleeve.\n\nThe above triangulation process generalizes to simple polygons by\ntrying to triangulate subpolygons which are sleeves; these sleeves are\nthen joined together by triangles which are adjacent to three\ntriangles.  A diagonal, d, is inserted and the triangulation process\n(join an adjacent vertex) starts at d assuming the part of the polygon\nit is triangulating is indeed a sleeve.  Eventually the algorithm may\ndiscover that it made a mistake (we are not in a sleeve) so it\nbacktracks until the triangulated portion is really a sleeve.  Now we\nknow that this sleeve must be connected to the rest of the\ntriangulation by adding two diagonals instead of just one. So we add\ntwo diagonals and continue the sleeve searching from those two\ndiagonals.\n\nThis process will triangulate any simple polygon in O(n(1+t_0)) time,\nwhere t_0 is the number of triangles in our output that have no edges\non the boundary of the polygon.  Note that these _free triangles_\ncorrespond to degree 3 vertices in the dual graph (they have 3 edges).\nIn the worst case, there may be O(n) free triangles hence the algorithm\nhas worst case time complexity of O(n^2).\n\nSince an O(n) time algorithm for triangulating _any_ simple polygon has\nbeen found (a milestone in geometric computation), one may ask 'Why is\nsuch an algorithm, with time complexity dependent on the output\ntriangulation, of any interest?'\n\nThe main reason is that the algorithm is more straightforward than\nother algorithms (in particular the O(n) result is quite complicated\nand hard to implement), and for certain classes of polygons it will\nalways run in O(n) time.  Professor Toussaint next outlined a brief\nhistory of triangulation algorithms culminating in the recent O(n)\nalgorithm by Chazelle.  But he didn't end on that note, rather, he\ndescribed two more results on polygon triangulation.\n\n--------------------------------------------------------------------\n\nThe Complexity History of Triangulating a Simple Polygon\n\n        1) 1911 Lennes (American Math Journal but very computational essay)\n                O(n^2) via recursive diagonal insertion.\n                Question: Why was Lennes considering the triangulation problem \n                          in 1911?\n        2) 1975 Meister\n                O(n^3) via \"ear-cutting\"\n        3) 1978 Garey, Johnson, Preparata, Tarjan\n                O(n log n) via decomposition into monotone pieces.\n        4) 1982 Chazelle\n                O(n log n ) via divide-and-conquer technique.\n        5) 1983 Herbert and Mehlhorn\n                O(n + r log r ) where r is the number of reflex vertices.\n        6) 1983 Chazelle\n                O(n log s) where s is the sinuosity of P.\n        7) 1987 Tarjan and Van Wyk\n                O(n log log n) via \"involved\" data structures.\n        8) 1988 Toussaint\n                O( n (1 + t_0)) via sleeve searching where t_0 is the number\n                of \"free triangles\" in the output triangulation.\n        9) 1990 ElGindy, Everett, Toussaint\n                Finding an ear in O(n) time via \"prune and search\" technique\n                implies algorithm 2) can be done in O(n^2) time.\n        10) 1990 Chazelle\n                O(n) via very \"involved\" techniques.  \n                Essentially unimplementable.\n\n----------------------------------------------------------------------------\nIs triangulation of a simple polygon history?\n\nNo, not really. Certainly the most important complexity question has been\nanswered by Chazelle, but fast practical algorithms are still desired\nby industry  where practical may depend on the specific application.\nProfessor Toussaint went on to outline some of the other aspects\nof the triangulation polygon in particular classes of polygons which\ncan be triangulated in linear time.  Only a brief review of topics\nare listed as this \"summary\" is running a bit long.\n\nA Palm-Shaped Polygon with respect to a point O is a polygon such that\nthe shortest geodesic path from O to any point is either right turning\nor left turning.  This implies that the polygon may be\nsplit into left palm subdivisions and right palm subdivisions.\n\nNow Professor Toussaint went into an aside regarding the computation\nof the convex hull of a polygon using the Graham scan (an algorithm for\nfinding the convex hull of a set of points).\n\nASIDE: Convex Hull via Graham Scan [Graham]\n        3-coin description\n\n        Find smallest x-coordinate vertex. Place coin on it and next two\n        vertices. (or was it a convex turn?)\n\n        If three coins form a right turn\n                Then back coin goes to the front\n                Else (if left turn)\n                     middle coin goes back (if it can: can't go back \n                     behind starting vertex) and delete middle vertex.\n\n        OBSERVATION: The Graham scan triangulates CH(P) \\ P.\n\n        Problem: Graham scan works well for star-shaped polygons but can\n                 have problem with simple polygon: \n\n=&gt; Bad polygon for Graham Scan (see if you can find a polygon\non which the Graham scan fails).\n\nEND of ASIDE:\n\n        A right palm with respect to a point x.\n\nExercise: Show that you can always triangulate with the 3-coins\nalgorithm. (I guess he was running out of time).\n\nQuestion: How hard is it to determine palm-shaped-ness?\nAnswer: You can find the \"kernel\" of a palm polygon in linear time.\n\nSo we can triangulate palm-shaped polygons in linear time.\nIn fact, the palm shaped polygons themselves contain several\nother classes of polygons.  But that's not all...\n\nPalm Decomposition of a Monotone Polygon\n\nGiven a direction in which P is monotone P can be decomposed in linear\ntime into the union of left and right palm polygons.  Hence, monotone\npolygons may also be triangulated in linear time using the simple\n3-coins algorithm as a procedure.\n\n-----------------------------------------------------------------------\n\nComputing Bushy and Thin Triangulations\n\n        Shermer 1988\n\n        Thin  triangulation minimizes the number of degree 3 vertices in dual.\n        Bushy triangulation maximizes the number of degree 3 vertices in dual.\n\n        Algorithms:\n\n        Bushy: O( T(n) ) and O(n) space where T(n) is the time for\n               triangulating.\n        Thin: O(n^3).\n\nProblem: Can you do better for finding a thin triangulation?\n\n-----------------------------------------------------------------------\n\nTriangulating a Set of Points\n\n        Does it always exist?\n\n        Idea:   First, draw a simple polygon through the points.\n                Second, triangulate inside and outside separately.\n\n        Question: Can you always draw a simple polygon through a set of \n                  points?\n        Answer: Yes. Choose 2 points such that no 3rd is collinear.\n                Sort the other points with respect to perpendicular\n                projection onto line through the two points.\n\n-----------------------------------------------------------------------\n\nTriangulating a set of Line Segments\n\n        What is it?!\n\n        A triangulation of the end points of the segments such that the\n        segments are edges in the triangulation.\n\n        Idea:   First, draw a simple polygon through the line segments...\n\n        But that is not always possible.\n        [Counter example: Existence of \"Cutting line segment\" means can't do\n        it. \"Cutting line segment\": diagonal of the CH of the line segments].\n\nProblem: So how to compute the triangulation?\n\n-----------------------------------------------------------------------\n\nAt this point Professor Toussaint was out of time.  The last few\ntopics covered shows that there are still interesting triangulation\nproblems to be considered.\n\nTwo references are provided which contain more extensive\nbibliographies related to the material presented.\n\n[Ho]\n@article{h-dpt-76\n, author =      \"C.-W. Ho\"\n, title =       \"Decomposition of a polygon into triangles\"\n, journal =     \"Math. Gazette\"\n, volume =      60\n, year =        1976\n, pages =       \"132--134\"\n, keywords =    \"decomposition, polygon triangulation, elementary geometry\"\n, cites =       \"l-tsfpp-11\"\n, annote =      \"A short correct proof of decomposability.\"\n}\n\n[To]\n@inproceedings{t-ocspt-90,\n, author =      \"G. T. Toussaint\"\n, title =       \"An output-complexity-sensitive polygon triangulation algorithm\"\n, year =        1990\n, comments =    \"Published version of t-ocspt-90\"\n, booktitle =   \"CG International '90 Computer Graphics Around the World\"\n, publisher =   \"Springer-Verlag\"\n, year =        1990\n, pages =       \"443--466\"\n, keywords =    \"triangulation, shape-complexity\"\n\nHints for intuitions gone wrong.  The hint for all three\ncounterexamples is that while x(k) may be a vertex which forms a\ntriangle with no other vertices inside of it, it doesn't mean that\nthere are no _edges_ cutting through the triangle!  In other words,\nx(k) is separated from x(i) by some edge.  Given that hint, the trick\nsimply lies in constructing the polygon with an edge between x(i) and\nx(k) such that the vertices of that edge (or edges connecting it to the\nrest of the polygon) do not violate the \"empty\" conditions in the\nintuition.\n</PRE>\n", "encoding": "ascii"}