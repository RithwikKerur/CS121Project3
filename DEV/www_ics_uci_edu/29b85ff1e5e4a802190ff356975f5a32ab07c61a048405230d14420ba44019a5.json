{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990504.txt", "content": "Advanced Collections Minutes - May 4, 1999\n\nAttending: Judy Slein, Jason Crawford, Jim Whitehead, Geoff Clemm, Chuck Fay,\nTyson Chihaya\n\nACTION ITEMS\n\nJim: Finish spec revisions by the end of this week if possible.\n\nAll: Review the revised spec (03.3) for next meeting.\n\nGeoff: Describe DELETE semantics on the WebDAV mailing list.\n\nJim: Add to Geoff's DELETE semantics a discussion of what the server may do to \nstate when processing a DELETE request.\n\nChuck: Define a method that gets rid of the bits, send to WebDAV mailing list.\n\nJim: Talk with some implementers about the proposed treatment of redirect references\nto collections embedded in request-URIs (section 4.15 of the 03.2 spec).\n\nDEFINITIONS: BINDINGS, MAPPINGS, RESOURCES\n\nBindings: A binding associates a name with a resource, where the name is a URL \nsegment.\n\nMappings: A mapping associates an absolute URL with a resource.\n\nGeoff: We may want some term for the relationship between a resource and a file\nsystem object.  Proposal: \"implements\".  Jim: Let's avoid this concept.\n\nJim: The term \"mapping\" is very commonly used in a more general way than we are\nproposing.  Do we want a different term for our use of \"mapping\"?  Let's keep it\nfor now, and use the term \"associate\" for the generic sense of map.\n\nJim W: Our notion of \"mapping\" turns out to be very useful for making the point\nthat adding a single binding can create mult mappings.\nGeoff: It's also handy in versioning to make the point that the server is \nresponsible for maintaining mappings, but clients can control bindings.\n\nJim W: We are improving on our previous usage when we weren't distinguishing \nbetween mapping and binding.\n\nChuck: We do need to change the definition in the current specification (03.2).\n\nGeoff: Checked the versioning specification to see that everything would work\nproperly with our definition of binding.  It looks ok.\n\nJim W: The definition of \"resource\" in RFC 2396 is a good one.  We should just\nuse it.\n\nJudy: Likes the definition, but thinks that the examples that have been used in\nrecent e-mail are not consistent with it.  They treat the resource as a filename\nor something that mediates between a URL and a file.  But the definition, and\nespecially the examples that accompany it, make it sound more like the file is\nthe resource, since it is what determines the response entity.  In other cases it\nwon't be a file but a service, but it's whatever determines what the response entity\nwill be.\n\nJason: The interesting cases are the ones where a single resource can be associated\nwith multiple files.  You can get these cases even without appealing to cgi scripts\nor content negotiation, as the e-mail discussions show.\n\nGeoff:  All that we need from a definition of \"resource\" is the assurance that when \nyou bind 2 URL segments to the same resource, the results of a put to one of them \nare visible at the other.\n\nChuck: Does our use of \"mapping\" match the usage in RFC 2396? No. RFC 2396 talks\nabout \"conceptual mapping\", which is our association.\n\nLet us always use \"URL mapping\", never just \"mapping\".\n\nAgreed:  A binding is an association between a URL segment and a resource.  It is\npart of the state of a collection.\n\nAgreed:  We will always use the term \"URL mapping\", not just \"mapping\".  A URL \nmapping is an association between an absolute URL and a resource.\n\nAgreed:  The spec will include a discussion of the relationship between mappings\nand bindings, but it won't be in the terminology section.\n\nSEMANTICS OF BIND\n\nJim: The open issues about BIND semantics concern what happens if you issue BIND to \na URL that is already associated with a resource. Does that work or fail? People \nseem to prefer that it fail, so that you have to do UNBIND followed by BIND.  \n\nShould the same thing happen for a collection? Yes.\n\nJim: Wants to confirm that we are all committed to defending the position that BIND\nfor collections should work the same as BIND for an ordinary resource.  Agreed.\n\nJudy: Do we want to say anything about the cases where a server might not want to\nallow a BIND?  In particular, this might include content negotiation cases and\ncontent generated by a cgi script or other dynamically generated content.\n\nGeoff: A server is always free to fail a BIND if it can't satisfy the semantics\nof bindings that we specify, in particular insuring that any PUT through any binding\nwill be visible through any GET on any binding to the same resource.\n\nJim: It might be better to wait and see whether people ask about this.  At least be\ncareful not to set any requirements on servers for these cases.  You can imagine \nwith cgi that some servers might be willing to do the extra work to support bindings,\nwhile others might not.\n\nGeoff: We can say that if you do a GET with same headers on two bindings to the same\nresource, you should get back same entity.  If we phrase it that way, then\ncontent negotiation and cgi are encompassed.  \n\nWe also have to include PROPFIND. For dead properties.  Can we say for all live\nproperties? Jim W: There might be some hitherto unknown live properties that depend \non a particular binding that would be exceptions.\n\nUNBIND / DELETE / DESTROY\n\nJim W: What are the objections to defining DESTROY?\n\nJudy: Was just interested in avoiding having to sort out the complexities of the\nmeaning of \"resource\" and what exactly happens if you request DESTROY for content\nnegotiated and dynamically generated content cases.\n\nGeoff: Is no longer averse to defining DESTROY if it just means getting rid of any \nbindings created with BIND, with no commitments about garbage collection, etc.\n\nJudy: I thought that bindings created with BIND were no different from any other\nbindings (created with PUT or COPY or whatever).  DESTROY should get rid of all\nbindings, not just ones created with BIND.\n\nJim: Whether or not we say there's no difference between bindings created with BIND \nand bindings created with PUT, etc., we have difficulties.  There will still be \nother mappings that are less well defined -- a server-created mapping that happened \nto go to the same place, some cgi bin script happens to go to the same place but we \ndon't know about it.  (But these are mappings, not bindings -- they point to a \ndifferent resource.)  We would have to define DESTROY so that we are non-committal \non the other mappings.  Just require the server to get rid of all the bindings it \nknows about.\n\nJudy: DESTROY should also work the same in a RFC 2518 collection as in an advanced\ncollection. A binding is created in a regular collection by PUT or COPY.  DESTROY\nshould remove all bindings to an object in a regular collection, just as it does\nfor advanced collections.  There is no essential difference between a regular\ncollection and an advanced collection.  It's just that advanced collections accept\nBIND requests.  There are already bindings in regular collections.\n\nGeoff: If we say that regular collections have bindings, but DELETE has different\nsemantics for regular collections than for advanced collections, this is confusing.\nIt's simpler to say that bindings only exist in advanced collections.\n\nJim: If these concepts had been available when RFC 2518 was being written, we would \nhave defined collections this way. If DELETE is causing problems, lets go back and \nfix RFC 2518 so that WebDAV collections and advanced collections behave the same.\n\nGeoff: Is it ok to say that DELETE in an advanced collection has clear semantics \nbut in regular collection it does not?\n\nJim: DELETE is always guaranteed to unbind, and allow garbage collection.\n\nGeoff: If there are multiple bindings, DELETE will only delete one binding.\n\nJim: We want DELETE to mean the same in both places.  We can revise RFC 2518 if \nnecessary.  We can put binding semantics into WebDAV when it goes to draft.\n\nGeoff: We will get protests from implementers.\n\nJim: Let's make the proposal on the WebDAV mailing list now.\n\nJudy: Avoiding this controversy is one reason for leaving DELETE alone, and instead\ndefining a new UNBIND method.\n\nGeoff: Doesn't want a client to have to try UNBIND, then discover it's not in an\nadvanced collection, then try DELETE.  This is one reason he wants to avoid defining\nUNBIND, but instead give DELETE the semantics of UNBIND.\n\nJason: Can there be both ordinary collections and advanced collections on the same \nserver?  Jim: You would probably want any given hierarchy to be advanced or not. \nOtherwise a client would have to do OPTIONS at every level.\n\nGeoff: 2 modules on same server might have different capabilities.\n\nJim: Wants to roll the concept of bindings and consistent DELETE semantics into the\nmain spec, so that if both sorts of collections occur on the same server, there will\nbe more consistent behavior.\n\nMost people won't be affected by rolling it back into the spec.\n\nJim: Where are we?\n\nGeoff: Let's define DESTROY to mean delete all bindings.  Maybe we should use a \ndifferent name for the method because people might expect to be able\nto do resource management with a method called \"DESTROY\".  We could use a header on \nDELETE to make it delete all bindings.  The default would be to delete one binding.\n\nJim: Wants the destroy function, and thinks that implementing it as a header is fine.\n\nGeoff: Let's float this.  Geoff will describe DELETE for mailing list.\n\nJim: Proposed semantics of DELETE: without a header, the server MUST remove the \nbinding associated with the URL mapping of the request-URI.  If the last binding is \nremoved, the server may do state modification.  It's worth saying that -- otherwise,\npeople will raise questions.  State modification might not even be restricted to\nthe case where the last binding is being removed.  We saw some cases in e-mail where\nit might be desirable to change file names based on removal of a binding. Jim will \nadd something about state modification to Geoff's definition of DELETE.\n\nChuck: If we are not providing DELETE / destroy for resource management, do we need\nto provide some other method for doing that? \nA true destroy would not only make the resource inaccessible through HTTP / WebDAV,\nbut through any protocol or access method.\n\nGeoff: Not all resources involve disk space.  What if you try to destroy some\ncgi-bin derived thing? \n \nChuck: Exclude the dynamic cases.  For static resources, a client might want to do \nresource management using the protocol.\n  \nGeoff: If so, not in advanced collections.  \n\nChuck: An author wants to use WebDAV, and wants to get rid of something he did \nyesterday, wants the bits ato be gone.  The author wants to know for sure that the\nbits are gone -- maybe it's a security issue, maybe the thing he wrote yesterday was\na mistake and an embarrassment.  He wants to take it out of circulation.  \n\nJim: It would be possible to define this, but people won't want it mandatory to \nimplement.  \n\nChuck: Thought we were heading this direction when we started talking about defining\na destroy method.    \n\nJim: You can imagine WebDAV on a document management system, where everything is a \nbinding.  You could remove all bindings but leave the resource lying around.  Then \nthere's a difference between delete and destroy.  We could find language for this.  \nWould clients use the command? Maybe.  \n\nChuck: Maybe a client would implement a recycle bin.  A user can move things to the\nrecycle bin initially, but when he says empty recycle bin, then he really wants the\nthings to be deleted -- get rid of it, it's gone, free up the space. \n\nChuck: Is looking for a request that is defined by the protocol to fail unless the\nserver actually removed the  bits.  \n\nWhat level of guarantee do we want server to provide -- what would the details of \nthis be like?  What about replication, archives, backups, etc. \n\nChuck: The copy the client was dealing with is gone.  This doesn't concern backups, \narchives, etc.  Then you know no one can use some other protocol to get at that copy,\nat least.\n\nMAY vs MUST for getting rid of persistent state.\n\nGeoff: We don't want to hold up acceptance for a MUST here.\n\nChuck: It's not just about storage management.  It's about accessibility. The client \napplication can't be sure that the resource is inaccessible on the current \ndefinition. Geoff: Thinks it will make people unhappy.  Jim: Even defining destroy\nfor a file system is difficult.  Do you have to zero out the bits so that a disk\nmaintenance utility can't be used to recover the data? Requiring that level of \neffort from server would be unfortunate.  \nChuck: Disregard extreme cases like Norton utilities. Just satisfy the typical user.\n\nWe know what delete all bindings means.  That's clear.\n\nIt bothers Chuck that we can't make a promise to the user about the content, only \nabout the bindings.  Chuck will try to come up with definition for a method that\nwould satisfy him and float it to the list.  \n\nJim: Do we want a separate UNBIND?  (Depends on how we end up defining DELETE)\n\nJim is willing to explore not having it.  Judy: What would be the difference\nbetween UNBIND and DELETE without a header?  Jim: Maybe something about state\nmaintenance.  No, they would be the same.\n\nBACKPOINTERS\n\nJim: Weren't backpointers really for direct references?  Do we need them now that\nwe only have redirect references?\nThe only use case is for client-controlled integrity, but people normally accept \nthat redirect references could be dangling, so clients aren't likely to try to\nmaintain their integrity.  If in the future we add strong references, you won't need\nclients to do integrity maintenance.\n\nJudy: Assumed that backpointers were for both redirect and direct references.  It's\nuseful for both sorts of references to be able to find out what references there are\nto a given resource.  There are other use cases besides the ones related to\nintegrity:  navigating up, finding related information by looking in all the\ncollections from which the target is referenced.\n\nJudy: Actually backpointers are probably more important for bindings than for\nredirect references.  Xerox's product won't use redirect references, but will use\nbindings and needs some way to find out what bindings there are to a given resource.\nIf there's no way provided by the protocol, we'll do something non-standard.\n\nJim: Would we want to expand the DAV:references property to handle bindings as well\nas redirect references? Or have two separate properties, one for redirect references\nand one for bindings?  One approach might be easier for DASL searches.\n\nJason: Less interest in redirects than in bindings in the protocol.  \n\nJim: Maybe we want backpointers only to bindings.\n\nRedirects are more likely to go off server; so a server is less likely to be able to\nmaintain a useful list of them in DAV:references, but for bindings it could do \nso.\n\nProvisionally, DAV:references includes only bindings. We need to revisit this when\nJim Davis is present.\n\nCOLLECTIONS / REDIRECT REFERENCES\n\nJim: The behavior described in section 4.15 seems odd.  One of our goals for\nredirect references was to allow sharing of resources in a way that would make use\nof existing server functionality.  The server shouldn't have to do much new to \nsupport redirect references.  But allowing the use of request-URIs that have\nredirect references to collections embedded in them would all be a new mechanism\nfor the server to implement.  It could also slow down GET processing.\n\nGeoff: Suppose it was an advanced collection with a binding. In a file system, \nthis would be a hard link, so there would be no difference to GET processing.\n\nJudy: Are you suggesting that we not allow redirect references to collections?\nJim: No, you can create redirect references to collections, but you can't do a\nGET through one of those redirect references.  It's just that\nif you do a GET on a request-URI with a redirect reference in the middle, you\nget a 404.\n\nJim is concerned about the performance of GET requests.\n\nGeoff: The server would only go through this processing if when it examined the\nwhole request-URI it thought it would have to respond with 404. So this doesn't \naffect normal cases, and won't slow down processing of normal cases.  Only error \ncases are slowed down.\n\nJim: A redirect to a collection creates a whole bunch of extra mappings? bindings? \nwhat?\n\nGeoff: It's the same as for bindings. A redirect can create a whole set of mappings,\njust as bind can create a whole set of mappings.  All the redirect mappings will \nreturn 302's, so you can create a whole tree of 302's with a single redirect to a\ncollection.\n\nJim: A redirect shouldn't affect the namespace below it\n\nGeoff: MOVE subtree is normal operation, lightweight.  \n\nJim: Will discuss with implementers how difficult this would be to do.\n\nGeoff: left-to-right vs. right-to-left parsing of the request-URI.  Could a \nconfiguration file on the server cause you to jump over any redirects in the middle \nof a request-URI?  Can you predict where the configuration file wants to jump you?\nDo we have to constrain the configuration file in some way in order to satisfy the\nsemantics?\n\nCOMMENTS ON SPEC 03.2\n\nChuck:\n\nThe overview in 4.2 says that HTTP and WebDAV already define \"binding\", but they\ndon't use that term anywhere.  This claim needs to be clarified or removed.\n\n4.1.2 implies that referential integrity is guaranteed for bindings -- that it is\nimpossible to have a \"dangling\" binding.  But is this really true?  Couldn't a\ncross-server binding, in particular, be broken?\n\n", "encoding": "ascii"}