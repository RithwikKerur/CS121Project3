{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/Modules/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Modules</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Modules</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Python programs that span multiple files</p>\r\n\r\n<p>At a fundamental level, Python programs are written in much the same way as programs in almost every other programming language in popular use: We write our code as text and store that text in files.  To differentiate these files easily from others, we use the extension <b>.py</b> on their filenames &mdash; and, as we'll see, this turns out to be a requirement, not just a good habit to get into &mdash; but there is otherwise nothing special about them; they're just text files.  (In fact, you can write Python programs that <i>read</i> Python programs using the same techniques you've learned for reading from text files; you can even execute them using built-in functions like <b>eval()</b> and <b>exec()</b> to run them in whole or in part.)</p>\r\n\r\n<p>You can learn a lot about Python while writing only programs that are entirely stored in a single <b>.py</b> file, and there's a pretty good chance that this is all you've done in your prior coursework.  However, as programs grow beyond a certain size, it becomes important to split them up into separate files of a practical size, rather than writing them as one giant file.  You can imagine, for example, that a 400,000-line program written by many people over a period of multiple years would need some sense of organization, both so it becomes easier to find your way around it (i.e., you know where to look when you're looking for something in particular) and so it becomes easier for more than one person to work on it simultaneously without one person's changes stomping on another's.  If two pieces of relatively unrelated functionality are written in separate files (as they should be), then one person could work on one of them while the other worked on another, and there would be much less chance of a conflict.</p>\r\n\r\n<p>In this course, we're now reaching the point where our programs are large and complex enough that there is value in writing them so they span multiple files, so we're going to begin to require that you do it, beginning in <a href=\"../../ProjectGuide/Project2\">Project #2</a>.  But, in order to do that, you're going to need to know a little more about how Python allows you to write and run programs made up of more than one file, and you're going to need to start developing a sense of how best to decide what belongs in each file, and how to isolate unrelated functionality so that changes in one file have the least likelihood of affecting the others.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What are modules?</p>\r\n\r\n<p>A Python <i>module</i> is a file with a name ending in <b>.py</b> that contains a collection of <i>definitions</i>.  Each definition establishes a name for something &mdash; a function, a constant, or (as we'll see later this quarter) a class.  So, for example, a module might be as simple as this one:</p>\r\n\r\n<blockquote>\r\n<a href=\"powers.py\"><b><i>powers.py</i></b></a>\r\n<pre>\r\ndef square(n: 'number') -> 'number':\r\n    return n * n\r\n\r\ndef cube(n: 'number') -> 'number':\r\n    return n * n * n\r\n</pre>\r\n</blockquote>\r\n\r\n<p>You may previously have thought of <b>.py</b> files as containing Python <i>programs</i>, but if you load this particular module in IDLE and execute it (by pressing F5), it'll appear that nothing has happened; you'll simply see a standard Python interpreter prompt, but no other output.  Yet it's not as though executing the module had no effect, because you'll now be able to call the functions defined in that module:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>square(3)</b>\r\n9\r\n&gt;&gt;&gt; <b>cube(4)</b>\r\n64\r\n</pre></blockquote>\r\n\r\n<p>So there must be more to the story than we've discussed before.  To understand what's happening here, there are a few more details we need to be aware of.</p>\r\n\r\n<p class=\"subtitle\">Namespaces</i>\r\n\r\n<p>A running Python program, particularly a large one, might have a very large number of <i>names</i> that it knows: the names of variables, functions, parameters, constants, classes, and so on.  When programs are very small, organizing these names isn't much of an issue; variables can be global, all of your code can be in one module, and you can pay relatively little regard to organizational problems like these:</p>\r\n\r\n<ul>\r\n  <li>How can I tell, given something's name, where I might find the code that defines it?  (This isn't hard at all in a very small program, but it becomes an issue when programs are much larger.)</li>\r\n  <li>What do I do if I want to use the same name more than once, but have it mean different things in different places?  (This is a problem that's less likely to come up in a very small program, but happens more often than you might think in larger ones.)</li>\r\n</ul>\r\n\r\n<p>In Python, there isn't just one big global set of names.  And, in fact, you probably know that already, because you've no doubt already encountered the idea of <i>scope</i> in the context of functions.  For example, consider these two fairly nonsensical functions:</p>\r\n\r\n<blockquote><pre>\r\ndef foo(n):\r\n    m = n + n\r\n    return m\r\n\r\ndef bar(m):\r\n    n = m + m\r\n    return n\r\n</pre></blockquote>\r\n\r\n<p>When you look at these functions, you might notice that they both have one parameter and use one variable, each with opposite names (i.e., <b>foo</b> calls its parameter <b>n</b> and its variable <b>m</b>, while <b>bar</b> calls its parameter <b>m</b> and its variable <b>n</b>).  There are two key questions we should consider here.</p>\r\n\r\n<ul>\r\n  <li>What effect does calling one function have when the other one is called subsequently?  For example, <b>foo</b> stores a value in a variable <b>m</b>.  If we call <b>foo</b> and then call <b>bar</b>, what is the effect on <b>bar</b>'s parameter called <b>m</b>?</li>\r\n  <li>What effect does calling either function have when we call the same function a second time?  For example, <b>bar</b> stores a value in a variable <b>n</b>.  If we then call <b>bar</b> again, what value is in the variable <b>n</b> then?</li>\r\n</ul>\r\n\r\n<p>The answer, as you've likely seen in previous coursework, is that in <i>neither</i> of these scenarios is one call affecting another.  Every time <b>foo</b> is called, it has a fresh parameter called <b>n</b> and a new <i>local variable</i> called <b>m</b>; <b>bar</b> is similar.  We call these variables <i>local</i> because they belong to a particular call to a particular function.  And every time these functions return, their parameters and local variables are destroyed, so subsequent calls to functions are unaffected.  (Note, too, that this is even true of recursive functions: Every call to the function is separate, so if we're three levels deep in the recursion, we have three sets of the function's local variables.)</p>\r\n\r\n<p>What this tells us is that Python must already provide a way to organize its names, so it can differentiate between the names that are local to one function and the names that are local to another.  Python does this using what are called <i>namespaces</i>, which is a bit broader than just isolating local variables between functions, though that is part of what they do.  You can think of a <i>namespace</i> in Python as a dictionary that maps names to the objects that have those names.</p>\r\n\r\n<p>In general, the job of namespaces is to give meaning to a name that you use somewhere in a Python expression.  For example, consider this skeletal Python function:</p>\r\n\r\n<blockquote><pre>\r\ndef blah(...):\r\n    ...\r\n    print(x)\r\n    ...\r\n</pre></blockquote>\r\n\r\n<p>When we ask to print the value of <b>x</b>, where is <b>x</b>?  The answer is \"It depends\", and Python looks in a few places.  (A few details have been simplified here, but these are things that wouldn't affect programs written only using features we've learned so far.)</p>\r\n\r\n<ul>\r\n  <li>Python looks in the <i>local scope</i> first.  If there's a local variable or parameter in this function called <b>x</b>, that's the <b>x</b> that gets printed.</li>\r\n  <li>Failing that, Python looks in the module's <i>global scope</i> next.  In other words, it looks to see whether there is a global definition of <b>x</b> (e.g., a global variable) in this module; if so, that's the <b>x</b> that gets printed.</li>\r\n  <li>Failing that, Python looks in the <i>built-in scope</i> next, which is to say that it checks whether there's a built-in definition &mdash; some functions, like <b>len()</b> and <b>open()</b> are \"built-in\" in this way.  If so, that's the <b>x</b> that gets printed.</li>\r\n  <li>Failing all of these, the attempt to print <b>x</b> fails by raising a <b>NameError</b>, since <b>x</b> is not defined anywhere that Python has looked.</li>\r\n</ul>\r\n\r\n<p>Conspicuously absent from this list are other modules.  How does code in one module use definitions in another?  The answer is that the other module must be <i>imported</i> first.  You've probably seen the <b>import</b> statement in Python before, but may never have considered what it actually does.  But we've now reached the point where we need to understand it in more detail.</p>\r\n\r\n<p class=\"subtitle\">Importing modules</p>\r\n\r\n<p>When you want one module's definitions to be available to another, it becomes necessary to <i>import</i> that module.  Importing a module causes the code in that module to execute &mdash; so, for example, if it contains five function definitions, those functions are now defined &mdash; and then makes its definitions available to the module that imported it.  There are a couple of different ways to do it, with subtle but important differences in how they behave.</p>\r\n\r\n<p>Suppose you have the <b>powers</b> module written above, stored in the same directory as the module below.</p>\r\n\r\n<blockquote>\r\n<a href=\"example.py\"><b><i>example.py</i></b></a>\r\n<pre>\r\nimport powers\r\n\r\ndef read_and_square() -> None:\r\n    number = input('Number: ')\r\n    number_squared = powers.square(number)\r\n    print('The square of that number is {}'.format(number_squared))\r\n</pre>\r\n</blockquote>\r\n\r\n<p>Since we have a file called <b>powers.py</b> in the same directory as <b>example.py</b>, the attempt to <b>import powers</b> will succeed.  (The reason it's important that they're stored in the same directory is that this is the first place that Python looks when you import a module.  If there's a module with that name in the same directory, it'll find it.  If not, there are a few other places it'll look &mdash; and you can even configure this list, as it turns out &mdash; but we won't write programs in this course except ones where all of the modules are in the same directory.)</p>\r\n\r\n<p>However, note that the only way we can access the functions in <b>powers</b> from within <b>example</b> is to qualify the name (e.g., <b>powers.square</b>).  This is because only the <b>powers</b> module is added to <b>example</b>'s global namespace; the only way to access what's in the <b>powers</b> module is to say \"Give me the <b>square</b> function in the <b>powers</b> module,\" which you say by writing <b>powers.square</b>.</p>\r\n\r\n<p>In most cases, I find that this is the best way to import a module in Python.  While I have to type a few extra characters in order to call that module's functions, my code becomes easier to read, because when I use a function, it's clear what module it comes from.  My goal is never strictly to type less &mdash; and I would feel that way even if I typed a lot slower than I do &mdash; but to be able to read my code much later (after I've forgotten the details) and be able to find my way around and understand it at a glance.  Brevity sometimes helps with understanding; quite often, they are opposed.</p>\r\n\r\n<p>There is a variant of the <b>import</b> statement, though, that dumps individual definitions from within one module into the global namespace of another.  Consider the <b>example2</b> module below:</p>\r\n\r\n<blockquote>\r\n<a href=\"example2.py\"><b><i>example2.py</i></b></a>\r\n<pre>\r\nfrom powers import square\r\n\r\ndef read_and_square() -> None:\r\n    number = input('Number: ')\r\n    number_squared = square(number)\r\n    print('The square of that number is {}'.format(number_squared))\r\n</pre>\r\n</blockquote>\r\n\r\n<p>In this example, the <b>from..import</b> variant is used instead.  The difference is that we're asking Python to take the <b>square</b> function from the <b>powers</b> module and add it directly to the global namespace of <b>example2</b>.  This means that code in <b>example2</b> can now simply refer to it as <b>square</b>, without having to qualify it as <b>powers.square</b>.  It also means that this module can't define anything else called <b>square</b> (e.g., a function or a constant) defined globally; each module can only have value for each name.  (This latter issue is why I never, ever use the <b>from x import *</b> pattern, because this dumps a potentially large set of names into a module's global namespace, colliding with any same-named values in my own module.  And every time the <b>x</b> module changes, it might introduce a new conflict that wasn't there before.  This is a dangerous choice, especially in a program that will have a long life, as so many real-world programs do.)</p>\r\n\r\n<p>So, <b>from x import y</b> does appear to slightly simplify uses of <b>y</b>, but you should carefully consider the tradeoff that's being made here.  In return for typing less, you've also made your program a little bit harder to read and navigate.  When you read the <b>read_and_square</b> function, you have to wonder where <b>square</b> is defined, a detail you may have forgotten since you originally wrote it.  In a module as short as this one, it's probably not important one way or another; but as modules get longer and more complex, it becomes a lot more important for details to be as obvious and clear as possible.</p>\r\n\r\n<p class=\"subtitle\">Executable modules (<i>if __name__ == '__main__'</i>)</p>\r\n\r\n<p>When you load a module in IDLE and execute it (by pressing F5), the code in that module is executed.  If it generates any observable result, like printing output or asking the user for input, you'll see that in the interpreter.  Otherwise, you'll see a standard <b>&gt;&gt;&gt;</b> interpreter prompt, and all of the module's definitions will now be available &mdash; so, for example, if the module defines a function, you could now call it.</p>\r\n\r\n<p>As we've seen, modules in Python have names.  We can check the name of the currently-executing module at any time by accessing the global variable <b>__name__</b>, which is present in every module.</p>\r\n\r\n<p>In general, the names of modules are indicated by their filenames; a module written in a file <b>boo.py</b> has the name <b>boo</b>.  But there's one special case that we haven't talked about: When you execute a module in Python (i.e., by pressing F5 in IDLE), it's given the special name <b>__main__</b> while it runs.  (Anything you define in the Python interpreter will be considered part of the <b>__main__</b> module, as well.)</p>\r\n\r\n<p>This little fact can be a useful way of differentiating between whether a module has been executed (i.e., is it the \"entry point\" of a program?) or whether it's been imported.  In general, importing a module shouldn't suddenly cause things to happen &mdash; output to be generated, input to be read, and so on &mdash; but should, instead, simply make definitions available that weren't previously.  Even <i>executable modules</i>, the ones we expect to be able to execute as programs, should behave differently when imported than they do when executed.</p>\r\n\r\n<p>To facilitate this distinction, we can simply check the module's name by accessing the <b>__name__</b> variable.  If its value is <b>'__main__'</b>, the module has been executed; if not, the module has been imported.  So, in an executable module, we typically write the code that causes things to happen when the module is executed in an <b>if __name__ == '__main__':</b> block, so that it will only happen if the module has been executed.  Meanwhile, if the module is imported, its definitions will become available to another module, but there will otherwise be no effect.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Public vs. private definitions</p>\r\n\r\n<p>In a module that contains a collection of definitions, we can divide them clearly into two groups:</p>\r\n\r\n<ul>\r\n  <li>Definitions that you expect other modules to need in order to solve their problems.  In other words, these are the tools the module is actually intended to provide to other modules.</li>\r\n  <li>Definitions that are only intended to be used as utilities within a module, to allow the writer of that module to break up what might otherwise be large, complex definitions (e.g., a complicated function) into smaller pieces.  These make the module easier to write and easier to understand, but do not affect the code in other modules at all.</li>\r\n</ul>\r\n\r\n<p>The definitions in the former category are often called the <i>public</i> definitions; they're the tools that the module provides to other modules.  The definitions in the latter category are often called the <i>private</i> definitions; they're to be used within the module, but not outside of it.</p>\r\n\r\n<p>The words \"public\" and \"private\" are chosen for a reason.  They connote an idea of whether something is available from the perspective of code outside of the module.  A module makes some parts of itself available to others, but, in the process, there is an understanding that if those things change &mdash; particularly their \"contract\" (e.g., if it's a public function, what if a parameter is added to it?) &mdash; then code in other modules will certainly be affected.  A module hides other details, particularly the ones that are specific to its implementation, which are details that the author reasonably expects might change, be added, and disappear as the module's implementation evolves.</p>\r\n\r\n<p>In general, whenever you add a definition to a module &mdash; a function, a constant, or (as we'll see later) a class &mdash; you should consider whether it should be public or private.  One handy default is to think of everything as private unless it <i>needs</i> to be public, but this can be a bit of a nuanced distinction, and we'll see plenty of examples throughout the rest of this course that will make it easier for you to decide which is which.  The good news, too, is that you can change your mind later; you can always make a private function into a public one later, say, if you discover that you need it to be, and you shouldn't affect code in other modules, since no code in other modules will have been calling the function while it was private.</p>\r\n\r\n<p class=\"subtitle\">How to distinguish between public and private</p>\r\n\r\n<p>Python does not make explicit the distinction between \"public\" and \"private\"; there's no special keyword or style you can use that will explicitly enforce a function's \"privateness\" within a module, for example.  Even if you say a function is private, it will still be available to any module, anywhere, at all times.  Still, we should respect the distinction in the code we write, and when using code written by others, and there needs to be some way for Python programmers to recognize, at a glance, whether a definition is public or private.</p>\r\n\r\n<p>It turns out that there is a well-known naming convention that's long been in use &mdash; and that we'll use in this course &mdash; to make the distinction evident to readers of the module's code.  Python programmers traditionally separate the \"public\" from the \"private\" by prefixing the names of \"private\" definitions with a single underscore ('_') character.  Since the private functions, by their nature, are the ones that are more likely to be changed, added, or removed over time, the underscore serves as a sort of warning to users of the module that they should exercise caution and quite probably stay away from such functions, because they're likely to change in ways that will break callers.  I'll adopt the underscore convention for private definitions in modules from now on in this course; we'll expect you to do the same, and we'll also expect your code to respect private definitions and not use them from outside of the module in which they're defined.</p> \r\n\r\n<p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Some sensible style and design guidelines</p>\r\n\r\n<p>Since we're concerning ourselves not just with writing programs, but with writing programs <i>well</i>, the design of our programs is becoming as important as whether they work.  One of the broad goals of this course is improving your ability to write programs that are much larger than the ones you may have written in previous coursework.  So as we learn new techniques, it's important that we also learn some sensible guidelines for how to use them appropriately, with an eye toward helping you to manage the complexity of your own large programs.  Below are some good rules of thumb that you should follow this quarter when you're designing and implementing your modules.</p>\r\n\r\n<ul>\r\n  <li>The definitions in your modules should have what software engineers call <i>high cohesion</i> and <i>low coupling</i>.  These may sound like unfamiliar terms, but their meaning is quite simple:\r\n    <ul>\r\n      <li><i>Cohesion</i> refers to the extent to which the definitions in a module are related to one another; high cohesion means that they're highly related.  In short, do they \"belong together\"?  Functions that are all involved in implementing a communication protocol probably belong together; functions that are involved in implementing a protocol probably <i>don't</i> belong together with functions that comprise part of a user interface or print error messages in the Python interpreter.</li>\r\n      <li><i>Coupling</i> is the extent to which one module's code relies on the details of others; low coupling means that each module relies on individual details of the others as little as possible.  As a practical matter, of course, there will need to be at least <i>some</i> coupling between modules (e.g., if one module needs to call a function in another), but a good rule of thumb is that each module should reveal as few of its details to the other modules as possible.  We'll talk about a lot of techniques this quarter for limiting the \"leakage\" of these kinds of details.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Because we'll be using our modules together with others &mdash; some of our modules will need to <b>import</b> others &mdash; there are limitations on the names we can use for the files that contain our modules.  In particular, the filenames have to be legal Python identifiers with <b>.py</b> appended to them.  So we'll adopt the following convention for our module names:\r\n    <ul>\r\n      <li>Modules must be written in files whose names are made up entirely of lowercase letters and (optionally) underscores separating words, with the filenames having the extension <b>.py</b>.  So, for example, <b>hello.py</b>, <b>worldviewer.py</b> and <b>world_viewer.py</b> are all legal filenames, but <b>Hello.py</b>, <b>WorldViewer.py</b>, <b>World Viewer.py</b>, and <b>Project #2 - First Attempt.py</b> are all illegal.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Your modules should not have code that has an observable effect when imported.  There should be no global variables (though you can have constants or namedtuples), and the act of <b>import</b>ing a module should never cause it to do anything other than make things (e.g., functions, classes, etc.) available that weren't previously.\r\n    <ul>\r\n      <li>For modules that you intend to be <i>executable</i> (i.e., the ones that comprise a program's \"entry point\"), you can put code into an <b>if __name__ == '__main__':</b> block to get them started, though it should generally be kept short and simple (ideally, it calls a function and does little else).</li>\r\n    </ul>\r\n  </li>\r\n  <li>Always distinguish properly between public and private definitions in your modules.  In general, definitions should be private unless they have a reason to be public (i.e., you have a good sense that they'll be needed in some other module).</li>\r\n</ul>\r\n\r\n<p>Beginning with <a href=\"../../ProjectGuide/Project2\">Project #2</a>, we'll be applying these ideas in our grading of your projects.</p>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}