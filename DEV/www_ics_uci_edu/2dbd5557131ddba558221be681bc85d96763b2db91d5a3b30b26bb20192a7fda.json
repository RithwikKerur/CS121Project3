{"url": "https://www.ics.uci.edu/~ejw/versioning/arch/0117.html", "content": "<!-- received=\"Tue Sep  3 05:14:09 1996 PDT\" -->\n<!-- sent=\"Thu, 29 Aug 1996 13:38:03 -0500\" -->\n<!-- name=\"David G. Durand\" -->\n<!-- email=\"dgd@cs.bu.edu\" -->\n<!-- subject=\"Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies\" -->\n<!-- id=\"v02130505ae4b8f3533dc@[128.148.157.46]\" -->\n<!-- inreplyto=\"Seiwald Q &amp; A -- \"GET for EDIT\" cookies\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies</title>\n<h1>Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies</h1>\n<b>David G. Durand</b> (<a href=\"mailto:dgd@cs.bu.edu\"><i>dgd@cs.bu.edu</i></a>)<br>\n<i>Thu, 29 Aug 1996 13:38:03 -0500</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#117\">[ date ]</a><a href=\"thread.html#117\">[ thread ]</a><a href=\"subject.html#117\">[ subject ]</a><a href=\"author.html#117\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0118.html\">Yaron Goland: \"RE: Seiwald Q &amp; A\"</a>\n<li> <b>Previous message:</b> <a href=\"0116.html\">Jim Whitehead: \"RE: Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\nAt 10:00 PM 8/28/96, Christopher Seiwald wrote:\n&gt;Me again:\n&gt;Locking (\"reservations\") can be handled by LOCK, I quite agree.  But\n&gt;SCM systems don't hang all their context on a lock: they hang it on the\n&gt;\"checkout\".  That's when the user tells the system, \"I'll be changing\n&gt;this here document,\" and the system records that fact for the day when\n&gt;the user says, \"Uh, here's that document I changed.\" The SCM system uses\n&gt;this context to keep track of the dozens (thousands?) of users out there,\n&gt;all trying to change the same set of documents (but invariable all\n&gt;starting with different revisions of those documents).\n\nWell, _my_ interpretation of lock is that it's a notofication of intent to\nmodify a resource. I don't think (but not everyone agrees with me) that we\ncan specify a single policy for locking that will work for everyone: but we\ncan define operations the servers can interpret to \"do the right thing\"\nbased on the policies that they implement, and the clients can meaningfully\nimplement in way that will let them be used effectively with different\nservers.\n\n    I don't think (and intentionally avoided requiring) that we can\nguarantee that the same client used with different server will work exactly\nthe same way with each server. But a client should be able to work with\ndifferent servers and make effective use of the policies that the servers\ndo provide.\n\n    So an argument that CHECKOUT/CHECKIN are required separate from a\nLOCK/GET/PUT/UNLOCK cycle would have to be a case where a server needed to\nhave _both forms_ of operation in place, _and_ have both forms operate\noaccording to different semantics. We want sufficient operations to span\nthe space of behavior, but I don't think that the different behaviors need\ndistinct representations in the protocol, unless they need to be\nsimultaneously implemented.\n\n&gt;Not all SCM systems require a lock before checking in documents, and\n&gt;some acquire that lock automatically, so many PUTs are likely to happen\n&gt;in the absense of a LOCK.  But _all_ SCM systems (except CVS) require\n&gt;some sort of checkout (locking or non-locking) before checkin.\n   I think we have to handle CVS too, which means we already can't\n_require_ a CHECKOUT method.\n\nIf you don't need a lock, then LOCK followed by GET _is_ a checkout. Maybe\nthe name LOCK is bad. Maybe NOTIFY (of intention to write) would be better?\n\n\n&gt;  Now you\n&gt;could fudge it, and by remembering the URL and revision do a paired\n&gt;checkout/checkin to establish the required context.  But this defeats\n&gt;a feature that all modern SCM systems boast: tracking user activity.\n&gt;They have this feature because users don't remember what they're doing,\n&gt;and they certainly don't remember what other people are doing.  Half\n&gt;the job of SCM systems (and by extension, version aware web servers) is\n&gt;to keep track of who is doing what to what, just to remind everyone\n&gt;involved.  Those scenarios I cooked up (where Joe and Jane keep stepping\n&gt;on each other) weren't just from my past experience: they were from my\n&gt;past week's experience.\n\nI don't have a problem with a server having a policy that passes out\nmultiple locks (as long as we can represent the state properly). I don't\nsee the problem with the client having to present the version number with\nthe document when reigstering an update.\n\nIs the cookie a persisten session identifier? I'm still having trouble\nunderstanding what it is, rather than what you wan tot do with it...\n\n\n&gt;Only one user can LOCK a file.  If the context is established on LOCK\n&gt;then there will be only one context per document, precluding Joe and\n&gt;Jane from finding out that they're doctoring the same text.\nI'm not sure that this has to be the case. I'd rather relax the semantics\nof lock, and keep a single protocol with access and update orhtogonal than\ntighten the defintion, add more methods, and make client and server\nimplementation harder and more policy-dependent.\n\n&gt;Normally SCM systems have a tight association between the checkout\n&gt;context and the checked-out file, because often there is no way to work\n&gt;\"outside\" of the SCM system.  But if the SCM system is the backend of\n&gt;a version-aware web server, with the actual work happening in \"stateless\"\n&gt;web clients, then that context must be represented by a cookie.\nWhat is the context? If I understood that maybe I would undertsand\neverything. I still don't see what the cookie is _needed for_.\n\n&gt;The cookie belongs to the underlying SCM system; whether it is an MD5\n&gt;hash of the document contents, some cryptic string churned up from bowels\n&gt;of the SCM database, or \"allworkandnoplaymakesjohnnyadullboy\" is not\n&gt;HTTP's or a Web authoring tool's business.  They just have to keep it\n&gt;associated with the checked-out document so that it can be reunited with\n&gt;the checkout context at checkin time.\nMD5 was just an example... What does the cookie identify: a state of the\ndocument, a granted access request, a bunch of session information, or\nsomething else?\n\n&gt;\n&gt;This cookie is the single most important component of distributed web\n&gt;authoring, IMHO.\n\n\nMay be. I can see some use for session identifiers (So I can check out the\nsame thing 5 times and post a variety of variants).\n   Couldn't non-exclusive reservation also be handled by some kind of\ngeneric \"attach meta-data\" operation; I suspect we will need something like\nthis as a hook for specific config management strategies in the second\nphase anyway?\n\n\n    -- David\n\n--------------------------------------------+--------------------------\nDavid Durand                  <a href=\"mailto:dgd@cs.bu.edu\">dgd@cs.bu.edu</a> | david@dynamicDiagrams.com\nBoston University Computer Science          | Dynamic Diagrams\n<a href=\"http://www.cs.bu.edu/students/grads/dgd/\">http://www.cs.bu.edu/students/grads/dgd/</a>    | http://dynamicDiagrams.com/\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0118.html\">Yaron Goland: \"RE: Seiwald Q &amp; A\"</a>\n<li> <b>Previous message:</b> <a href=\"0116.html\">Jim Whitehead: \"RE: Microsoft Feature Support List (V 0.1, ALPHA, 8/26/96)\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n", "encoding": "ascii"}