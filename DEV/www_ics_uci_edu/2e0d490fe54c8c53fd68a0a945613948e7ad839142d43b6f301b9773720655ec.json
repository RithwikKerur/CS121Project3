{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/SortedArray.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Sorted array subroutine for conga line data structure subset sizes\n// Since there are few (O(log n)) subsets, we are best off avoiding\n// complicated binary search trees etc, and just using a sorted array.\n//\n// This is an object that acts like a normal array, except that\n// after changing an array entry you are supposed to call Update(),\n// and it will allow you to look up the min. array element or the\n// pair of elements having sizes with the smallest ratio.\n// For technical reasons involving the constructor of CongaLine,\n// the SortedArray constructor does little; instead call Allocate later.\n\n#include \"SortedArray.h\"\n#include \"Error.h\"\n\n// perform array lookup w/bounds checking\nunsigned long & SortedArray::operator[] (unsigned long i)\n{\n\tif (i >= array_size) error(\"SortedArray: index out of bounds\");\n\treturn values[i];\n}\n\n// swap sorted array indices at posns i and i+1\nvoid SortedArray::Swap(unsigned long i)\n{\n\tunsigned long temp = sorted_indices[i];\n\tsorted_indices[i] = sorted_indices[i+1];\n\tsorted_indices[i+1] = temp;\n\twhere_are_the_values[sorted_indices[i]] = i;\n\twhere_are_the_values[sorted_indices[i+1]] = i+1;\n}\n\n// reorder array after changing a value\nvoid SortedArray::Update(unsigned long i)\n{\n\ti = where_are_the_values[i];\t// translate to sorted array index\n\twhile (i < array_size - 1 &&\n\t\t   values[sorted_indices[i]] > values[sorted_indices[i+1]])\n\t{\n\t\tSwap(i);\n\t\ti++;\n\t}\n\twhile (i > 0 &&\n\t\t   values[sorted_indices[i-1]] > values[sorted_indices[i]])\n\t{\n\t\tSwap(i-1);\n\t\ti--;\n\t}\n}\n\n// find index with smallest value\nunsigned long SortedArray::MinValue()\n{\n\treturn sorted_indices[0];\n}\n\n// What is size ratio of positions i, i+1?\ndouble SortedArray::SizeRatio(unsigned long i)\n{\n\treturn ((double) values[sorted_indices[i+1]]) /\n\t\t   ((double) values[sorted_indices[i]]);\n}\n\n// find pair of indices closest in size\n// or, among equal choices, take indices w/smallest size\nvoid SortedArray::MinRatio(unsigned long & i, unsigned long & j)\n{\n\tunsigned long k = 0;\n\twhile (values[sorted_indices[k]] == 0 && k < array_size - 1) k++;\n\tif (k < array_size - 1) {\n\t\tdouble r = SizeRatio(k);\n\t\tfor (unsigned long x = k+1; x < array_size - 1; x++) {\n\t\t\tdouble xr = SizeRatio(x);\n\t\t\tif (xr < r) {\n\t\t\t\tr = xr;\n\t\t\t\tk = x;\n\t\t\t}\n\t\t}\n\t}\n\ti = sorted_indices[k];\n\tj = sorted_indices[k+1];\n}\n\n// set up and zero array\nvoid SortedArray::Allocate(unsigned long newsize)\n{\n\tif (array_size > 0) {\n\t\tdelete values;\n\t\tdelete sorted_indices;\n\t\tdelete where_are_the_values;\n\t}\n\tarray_size = newsize;\n\tif (array_size == 0) return;\n\tvalues = new unsigned long[array_size];\n\tsorted_indices = new unsigned long[array_size];\n\twhere_are_the_values = new unsigned long[array_size];\n\tif (values == 0 || sorted_indices == 0 || where_are_the_values == 0)\n\t\terror(\"SortedArray: unable to allocate arrays\");\n\tfor (unsigned long i = 0; i < array_size; i++) {\n\t\tvalues[i] = 0;\n\t\tsorted_indices[i] = i;\n\t\twhere_are_the_values[i] = i;\n\t}\n}\n", "encoding": "ascii"}