{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/inheritanceii.txt", "content": "\t\t\t\tInheritance II\r\n\r\nThis short lecture extends our discussion of inheritance from single-inheritance\r\nto multiple-inheritance: we will learn how to visualize multiple-inheritance\r\nrelationships (not as a N-ary tree, but as a more complicated network) and how\r\nto generalize the rules Python uses for locating attributes. We can use the\r\ninheritancetool.py module, along with any classes forming an inheritance\r\nhierarchy, to see how Python locates such attributes. We can use this tool with\r\nthe module defining the Counter/Modular_Counter classes, and with the\r\ninheritancesample.py module, which defines a more complicated hierarchy\r\ndiscussed below. We will also discuss the truth about the isintstance function\r\nand how Python matches exceptions in the except clause from the try/except\r\nstatement.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nVisualizing Multiple-Inheritance Hierarchies\r\n\r\nExamine the class structure below, which we have simplified by showing just\r\nthe class statement with a body of pass.\r\n\r\nclass B1a     : pass\t   # object is the base class of the derived class B1\r\nclass B1(B1a) : pass\t   # B1a is the base class of the derived class B1\r\nclass B2      : pass\t   # object is the base class of derived class B2\r\nclass C(B1,B2): pass\t   # B1 and B2 (in that order) are the base classes of C\r\n\r\nWe can visualize the relationship betweeen the derived and base classes using\r\nthe same building blocks we used for single-inheritance: a derived class refers\r\nupward to its direct base class. The three pictures below are all logically\r\nequivalent (in terms of derived classes and their arrows to base classes):\r\nalthough the \"location\" of some of the classes  are different in the pictures,\r\nin all cases B1 is the first/left base class from which C is derived; B2 is the\r\nsecond/right base class from which C is derived; B1 is derived solely from B1a,\r\nand B1a and B2 themselves are each derived from the base class object.\r\n\r\n        object\t\t\tobject\t\t\t  \r\n         ^   ^                   ^   ^\t         \t  \r\n        /     \\\t\t        /     \\\t\t\t\r\n      B1a     B2 \t      B1a     |\t\t     B1a --> object\r\n       ^       ^               ^      |\t\t      ^       ^\r\n       |       |\t       |      |\t\t      |       |\r\n       B1      /              B1     B2\t\t      B1      B2\r\n        ^     /                ^      ^\t\t       ^      ^\r\n         \\   /\t\t        \\    /\t\t        \\    /\r\n           C                       C\t\t           C\r\n\r\nBecause of the extra complexity of multiple-inheritance, the relationships can\r\nform a complex network that cannot be captured by a simple N-ary tree: for\r\nexample above C has two paths to the root, object, which is disallowed in trees\r\nrepresenting only singe inheritance. These more complicated structures mean\r\nPython's rules are more complicated for determining in which order classes are\r\nsearched for attributes.\r\n\r\nTo draw these inheritance networks, we start at the most derived class, and\r\nthen draw all its base classes (in the order they appear in the class\r\ndefinition, mirroring the left to right ordering), directly above the class(es)\r\nderived from them, with arrows leading from the derived class to the base class.\r\nFor the example above, because C is derived from B1 and B2 (in that order),\r\nthey appear (in that left to right order) above C; because B1 is derived from\r\nB1a, and B1a is derived from object, B1a appears above B1 and object appears\r\nabove B1a; because B2 is derived from object, object appears above B2 also.\r\n\r\nThese networks can get messy to visualize, with more complicated relationships\r\namong the classes, but the picture layout is not what is important: what is\r\nimportant is the individual logical relationships (which derived classes refer\r\nto which base classes, and in which order), which are directly used to locate\r\nattributes. In complicated inheritance networks, drawing the relationships might\r\nrequire crossing lines.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nLocating Attributes in Multiple-Inheritance Hierarchies\r\n\r\nI will now state the principle, in English, that Python uses for locating an\r\nattribute in an inheritance network. In the next section I'll show actual\r\nPython code that computes the equivalent information. Once this \"equivalent\r\ninformation\" is computed, it is stored with the class, so locating attributes\r\nbecomes trivial because the classes are searched in the stored order.\r\n\r\nThe search must take into account two fundamental principles:\r\n\r\n(1) Before searching a base class, all classes derived from it must be searched.\r\n\r\n(2) Base classes must be searched in the order they appear in each derived\r\n      class definition. The derived class specifies them in a left to right\r\n      order, with a left base class searched before a right base class.\r\n\r\nSo, \r\n\r\n(a) Python first tries to find the attribute in the instance object.\r\n\r\n(b) If Python failse, it searches the class that it was constructed from.\r\n\r\n(c) If Python fails, it searches (left before right) upward from the class the\r\n    object was constructed from (which appears at the bottom of the network),\r\n    towards the root/object class.\r\n\r\n(d) If Python reaches any base class andt has not already searched all of its\r\n    derived classes, that base class is not searched now; instead the derived\r\n    class searches its remaining (to the right) base classes; and if it has\r\n    searched all its base classes, its derived class searches its remaining (to\r\n    the right) base classes, etc. So, a base class can be searched only if all\r\n    its derived classes have already been searched.\r\n  \r\nIn the inheritance network above, if c is an object constructed from class C,\r\nand the attribute isn't found in c, Python searches the following classes in\r\nfollowing order, getting the attribute from the first class that defines it:\r\nC, B1, B1a, B2, \"object\". Here is why: It starts at C, then searches C's lefmost\r\nbase class B1, then searches B1's leftmost base class B1a. But when it sees\r\nB1a's leftmost base class, \"object\", has another derived class (B2) that has not\r\nbeen searched, Python doesn't search \"object\" yet. Instead it tries to search\r\nB1a's other base classes; there are none, so it tries to seach B1's other base\r\nclasses; there are none, so it tries to search C's other base classes, and\r\nthere is one, B2. Then it seaches  B2's base classes, \"object\", which is now\r\nactually searched, because all/both of its derived classes have already been\r\nsearched. Finally, \"object\" has no base class to search.\r\n\r\nHow does the search know how to go from a derived class to its base class(es)?\r\nEvery class object has a __bases__ attribute that is a tuple of its base\r\nclasses; the order that it uses for the base classes in the tuple is the same\r\norder the base classes appear in the class definition. So, the arrows shown in\r\nthe pictures above are really stored in Python class objects, in the tuple named\r\n__bases__. Recall that the arrows go only from derived classes to base classes,\r\nnot base classes to derived classes. So while every derived class knows the base\r\nclasses it is derived from, a base class does not know what derived classes are\r\nderived from it.\r\n\r\nFinally, when applied to a single-inheritance hierarchy, this algorithm\r\ndegenerates (each  __bases__ tuple has only one value in it) into looking from a\r\nderived class to its single base class, to the single base class of that base\r\nclass, etc. until reaching the object class. We are already familiar with that\r\nordering/process from the first inheritance lecture.\r\n\r\nIn fact, Python has a function getattr defined in the builtins module (note, no\r\nunderscores; it is not the dunder method __getattr__ defined in a class) \r\nthat performs exactly this task. It takes up to 3 arguments: an object\r\n(required), the name of an attribute for that object (as a string; required),\r\nand the value to return if it cannot find that attribute for an object\r\n(optional). If the third argument is not supplied, Python will raise\r\nAttributeError if it cannot find that attribute for the object. \r\n\r\n\r\nHow Python Actually Searches for Attributes:\r\n\r\nThe order of classes that Python uses to search for an attribute name is\r\nactually computed when a class is defined (so the order doesn't need to be\r\nrecomputed for each attribute access); it is stored in the class attribute\r\n__mro__; it is also retrievable by the parameterless method mro. So if C refers\r\nto a Class, then C.__mro__/C.mro() is a tuple/list (they return different types\r\nof results) of classes (starting with C), in the order they are searched for\r\nthe attribute, including C itself first.\r\n\r\nThe term \"mro\" stand for \"METHOD resolution order\", but it applies to all\r\nATTRIBUTES, not just methods (so a better name would be aro). The code directly\r\nbelow shows how the mro is used when searching for an attribute. It is followed\r\nby code that illustrates how to compute the mro for each newly defined derived\r\nclasses (based on having already computed the mros for its base classes).\r\n\r\nThe pgetattr function (pseudo getattr) defined below shows how Python locates\r\nthe value associated with any attribute of an_object. It locates the attribute\r\nin an_object itself, or searches its inheritance hierarchy starting with the\r\nclass from which an_object is constructed. The inheritancetool.py module\r\nincludes this code (and the algorithm below used in computing the __mro__ tuple)\r\n\r\nNote here how using *default will bind default to () which is the empty tuple,\r\nif no third argument is supplied. This is how Python can tell whether or not a\r\nthird argument was supplied to this function.\r\n\r\ndef pgetattr(an_object, attr, *default):\r\n    # Try to locate attr in in object itself\r\n    # Otherwise try to locate it in the classes in the __mro__ tuple\r\n    #   based on the type of an_object (in order), which starts with\r\n    #   type(an_object).\r\n    # Finally return default[0] (if a third argument, and no more, was specified) or\r\n    #   raise AttributeError if it was not\r\n\r\n    if attr in an_object.__dict__:\r\n        return an_object.__dict__[attr]\r\n    else:\r\n        for c in type(an_object).__mro__:  # or call .mro(): uses order from mro\r\n            if attr in c.__dict__:\r\n                return c.__dict__[attr]\r\n    \r\n    if len(default) == 1:                  # 3rd argument passed (no others)?\r\n        return default[0]\r\n    else:\r\n        raise AttributeError(\"'\"+type_as_str(an_object)+\"' object has no attribute '\"+attr+\"'\")\r\n\r\nPython also defines a hasattr function in the builtins module, returning a\r\nboolean value telling whether or not Python can access the specified attribute\r\nin the specified object: whether getattr will find the attribute and return its\r\nvalue. We could defined a pseudo version of this function simlarly to pgetattr\r\nabove.\r\n\r\ndef phasattr(an_object, attr):\r\n    # Try to locate attr in in object itself\r\n    # Otherwise try to locate it in the classes in the __mro__ tuple\r\n    #   based on the type of an_object (in order), which starts with\r\n    #   type(an_object).\r\n\r\n    if attr in an_object.__dict__:\r\n        return True\r\n    else:\r\n        for c in type(an_object).__mro__:\r\n            if attr in c.__dict__:\r\n                return True\r\n    return False\r\n\r\nor we can write it more compactly (and just as efficiently) as\r\n\r\ndef phasattr(an_object, attr):\r\n    return (attr in an_object.__dict__) or \\\r\n           any(attr in c.__dict__ for c in type(an_object).__mro__)           \r\n\r\nThe existence of the precomputed __mro__ class attribute simplifies these\r\nfunctions. We will discuss how to compute this class attribute below.\r\n\r\nFinally, the actual getattr/hasattr functions are bit more complicated than\r\npgetattr/phasattr because it works with some Python features that we have not\r\ndiscussed. But the general outline is the same.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nComputing the Method Resolution Order\r\n\r\nNow, let us see the algorithm to computer the __mro__ attribute of a derived\r\nclass, based on the __mro__ attributes of the base classes it is derived from.\r\nThe final order requires two properties (also stated above).\r\n\r\n(1) Before searching a base class, all classes derived from it must be searched.\r\n\r\n(2) Base classes must be searched in the order they appear in each derived\r\n      class definition. The derived class specifies them in a left to right\r\n      order, with a left base class searched before a right base class.\r\n\r\nThis algorithm is known as the \"C3 linearization algorithm\". It linearizes (puts\r\ninto a tuple) the search order for a network of classes in an inheritance\r\nhierarchy. It is called C3 because Python has twice changed the order in which\r\nclasses in an inheritance network are searched: as programmers wrote code in the\r\nthe language, the notion of the \"correct\" order evolved.\r\n\r\nIf there is no order that satsifies all these requirements (see below for an\r\nexample) then the algorithm will detect this fact and Python will raise a\r\nTypeError exception when the class itself is defined: the __mro__ attribute for\r\nthe class is computed when the class is defined. The result of raising the\r\nTypeError is that the class will not be defined and cannot be used.\r\n\r\nThe following function computes the mro: I haven included print statements\r\n(controlled by the debugging parameter) to help illustrate its computation.\r\n\r\n# bases is all the bases the new class is derived from\r\ndef compute_mro(*bases, debugging=False):\r\n    # constraints is a list of lists; each inner list specifies the constraints\r\n    #   for a base class or the new class (last, specified by *bases)\r\n    # mro is the final order for searching all the base classes\r\n    constraints = [list(c.__mro__) for c in bases] + [list(bases)]\r\n    mro         = []\r\n    \r\n    # While there are constraints to ensure are satisfied\r\n    while constraints:\r\n        if debugging: print('\\nConstraints =',constraints)\r\n        \r\n        # Find the first candidate in an inner constraint-list that does not\r\n        # appear anywhere but as the first in all other inner constraint-lists\r\n        # If none is found, raise TypeError (note use of else: in for loop)\r\n        for const in constraints:\r\n            candidate = const[0]\r\n            if debugging: print('Trying candidate:',candidate)\r\n            if not any([candidate in later[1:] for later in constraints]):\r\n                if debugging: print('Selected candidate:',candidate)\r\n                break\r\n        else: # for finished without breaking; no candidate is possible!\r\n            raise TypeError('Cannot create a consistent method resolution order (MRO) for bases ' +\\\r\n                               ', '.join(type_as_str(b) for b in bases))\r\n\r\n        # That candidate is next in the mro for the currehnt class\r\n        mro.append(candidate)\r\n        \r\n        # Remove candidate from being the first in any inner constraint-list\r\n        for const in constraints:\r\n            if const[0] == candidate:\r\n                if debugging: print('Removing candidate from:', const)\r\n                del const[0]\r\n                \r\n        # If any innner constraint-list has been reduced to [], remove it\r\n        constraints = [c for c in constraints if c != []]\r\n        \r\n    return tuple(mro)\r\n\r\nGiven the following classes, used at the start of this lecture note\r\n  class B1a     : pass\t# __mro__ is (B1a,object)\r\n  class B1(B1a) : pass  # __mro__ is (B1,B1a,object)\r\n  class B2      : pass  # __mro__ is (B2,object)\r\n\r\nWe can compute the mro for \r\n  class C(B1,B2): pass\r\n\r\nby calling print('\\nmro =',compute_mro(B1,B2,debugging=True)) which produces the\r\nfollowing results; match it with the English description of how the order (also\r\nappearing at the start of the lecture note).\r\n\r\n  Constraints = [[<class '__main__.B1'>, <class '__main__.B1a'>, <class 'object'>],\r\n                 [<class '__main__.B2'>, <class 'object'>],\r\n                 [<class '__main__.B1'>, <class '__main__.B2'>]]\r\n  Trying candidate: <class '__main__.B1'>\r\n  Selected candidate: <class '__main__.B1'>\r\n  Removing candidate from: [<class '__main__.B1'>, <class '__main__.B1a'>, <class 'object'>]\r\n  Removing candidate from: [<class '__main__.B1'>, <class '__main__.B2'>]\r\n\r\n  Constraints = [[<class '__main__.B1a'>, <class 'object'>],\r\n                 [<class '__main__.B2'>, <class 'object'>],\r\n                 [<class '__main__.B2'>]]\r\n  Trying candidate: <class '__main__.B1a'>\r\n  Selected candidate: <class '__main__.B1a'>\r\n  Removing candidate from: [<class '__main__.B1a'>, <class 'object'>]\r\n\r\n  Constraints = [[<class 'object'>],\r\n                 [<class '__main__.B2'>, <class 'object'>],\r\n                 [<class '__main__.B2'>]]\r\n  Trying candidate: <class 'object'>\r\n  Trying candidate: <class '__main__.B2'>\r\n  Selected candidate: <class '__main__.B2'>\r\n  Removing candidate from: [<class '__main__.B2'>, <class 'object'>]\r\n  Removing candidate from: [<class '__main__.B2'>]\r\n\r\n  Constraints = [[<class 'object'>], [<class 'object'>]]\r\n  Trying candidate: <class 'object'>\r\n  Selected candidate: <class 'object'>\r\n  Removing candidate from: [<class 'object'>]\r\n  Removing candidate from: [<class 'object'>]\r\n\r\n  mro = (<class '__main__.B1'>, <class '__main__.B1a'>, <class '__main__.B2'>, <class 'object'>)\r\n\r\nNote that we must prepend the C class itself to the result computed:\r\nThe actual mro for C is\r\n\r\n  mro = (<class '__main__.C'>, <class '__main__.B1'>, <class '__main__.B1a'>, <class '__main__.B2'>, <class 'object'>)\r\n\r\nNow, look at the following example of class that CANNOT meet the requirements\r\nof having a C3 linearizable mro:\r\n\r\nclass A     : pass   # __mro__ is (A, object)\r\nclass B     : pass   # __mro__ is (B, object)\r\nclass C(A,B): pass   # __mro__ is (C, A, B, object) :note A before B\r\nclass D(B,A): pass   # __mro__ is (D, B, A, object) :note B before A\r\nclass E(C,D): pass   # __mro__ is not possible\r\n\r\nNote here that for derived class E, the rules for its base class C require\r\nsearching A before B, but the rules for its base class D require searching B\r\nbefore A, which are incompatible: C says A must be searched before B but D says\r\nB must be searched before A. So given the definition of A, B, C, and D, calling \r\n\r\nWe can compute the mro for \r\n  class E(C,D): pass   # __mro__ is not possible\r\n\r\nby calling print('\\nmro =',compute_mro(C,D,debugging=True))  which produces the\r\nfollowing results.\r\n\r\n  Constraints = [[<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>],\r\n                 [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>],\r\n                 [<class '__main__.C'>, <class '__main__.D'>]]\r\n  Trying candidate: <class '__main__.C'>\r\n  Selected candidate: <class '__main__.C'>\r\n  Removing candidate from: [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]\r\n  Removing candidate from: [<class '__main__.C'>, <class '__main__.D'>]\r\n\r\n  Constraints = [[<class '__main__.A'>, <class '__main__.B'>, <class 'object'>],\r\n                 [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>],\r\n                 [<class '__main__.D'>]]\r\n  Trying candidate: <class '__main__.A'>\r\n  Trying candidate: <class '__main__.D'>\r\n  Selected candidate: <class '__main__.D'>\r\n  Removing candidate from: [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]\r\n  Removing candidate from: [<class '__main__.D'>]\r\n\r\n  Constraints = [[<class '__main__.A'>, <class '__main__.B'>, <class 'object'>],\r\n                 [<class '__main__.B'>, <class '__main__.A'>, <class 'object'>]]\r\n  Trying candidate: <class '__main__.A'>\r\n  Trying candidate: <class '__main__.B'>\r\n  Traceback (most recent call last):\r\n  Traceback (most recent call last):\r\n    File \"C:\\Users\\Pattis\\workspace\\inheritance\\inheritancetool.py\", line 85, in <module>\r\n      print('\\nmro =',compute_mro(C,D,debugging=True))\r\n    File \"C:\\Users\\Pattis\\workspace\\inheritance\\inheritancetool.py\", line 68, in compute_mro\r\n      raise TypeError('Cannot create a consistent method resolution order (MRO) for bases ' + ', '.join(type_as_str(b) for b in bases))\r\n  TypeError: Cannot create a consistent method resolution order (MRO) for bases __main__.C, __main__.D\r\n\r\nIn such a case, the class raising the exception will not be defined: it cannot\r\nbe defined because it can have no legal search order for its attributes,\r\naccording to the constraints of the C3 linearlization algorithm.\r\n\r\nHere is a recursive version of the compute_mro function (sans debugging print\r\nstatements). It defines and calls the recursive helper function merge. Note\r\nthe use of a for loop with an else; the else is executed if no good constraint\r\nis found (if no break is executed). Various recongnizable parts of the iterative\r\nalgorithm appear here too.\r\n\r\ndef compute_mro_r(*bases):\r\n    def merge(constraints):\r\n        if constraints == []:\r\n            return ()\r\n        else:\r\n            # find a constraint appearing that appears only in the first index\r\n            for const in constraints:\r\n                candidate = const[0]\r\n                if not any([candidate in later[1:] for later in constraints]):\r\n                    break\r\n            else: # for finished without breaking; no candidate is possible!\r\n                raise TypeError('Cannot create a consistent method resolution order (MRO) for bases ' +\\\r\n                                   ', '.join(type_as_str(b) for b in bases))\r\n            # if found, concatenate at front of mro of the solution to merging\r\n            #   the remaining constraints (with it removed; a smaller problem)\r\n            return (candidate,) + \\\r\n               merge([const[1:] if const[0] == candidate else const for const in constraints if const != [candidate]])\r\n    return merge([list(c.__mro__) for c in bases] + [list(bases)])\r\n\r\nGoing back to the definitions\r\n\r\n  class B1a     : pass\t# __mro__ is (B1a,object)\r\n  class B1(B1a) : pass  # __mro__ is (B1,B1a,object)\r\n  class B2      : pass  # __mro__ is (B2,object)\r\n\r\nWe can compute the mro for \r\n  class C(B1,B2): pass\r\n\r\nby computing compute_mro_r(B1,B2) which we can visualize as (dropping the\r\n  '__main__.' from each class name)\r\n\r\n= merge((B1a,object), (B1,B1a,object), (B2,object))\r\n= (B1,) + merge((B1a,object), (B1a,object), (B2,object))\r\n= (B1,) + (B1a,) + merge((object,), (object,), (B2,object))\r\n= (B1,) + (B1a,) + (B2,) + merge((object,), (object,), (object,))\r\n= (B1,) + (B1a,) + (B2,) + (object,)\r\n= (B1, B1a, B2, object)\r\n\r\nThe actual mro for C is (C, B1, B1a, B2, object) , including the class C itself.\r\n\r\nFinally, __mro__ is as read-only attribute; after Python computes it, its value\r\ncannot be changed (recall all the __setattr__ variants we wrote that restricted\r\nupdating attributes).\r\n\r\nFinally, in the next lecture we will see many examples of single-inheritance\r\nand multiple-inheritance. As of the end of this lecture, you should be able to\r\nunderstand how Python treats all inheritance hierarchies in terms of locating\r\nattributes.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe true meaning of the isinstance function (given inheritance)\r\n\r\n\r\nPython's boolean function isinstance has two parameters: the first should be\r\nbound to an instance object; the second to a class object. Before inheritance,\r\nour understanding of the call isinstance(o,C) meant return True if instance\r\nobject o was constructed from class object C: we could restate this computation\r\nusing the is operator as equivalent to: type(o) is C.\r\n\r\nBut now that we know about inheritance we can clarify the meaning of this\r\nisinstance function: it is a bit more general. The isinstance(o,C) function\r\ncall still returns True if type(o) is C, but it also returns True if type(o)\r\nis any class derived from C (meaning type(o) is derived from class C in one or\r\nmore steps). Stated another way, if isinstance(o,C) is True, it means that when\r\nsearching for attributes in o, eventually class C will be searched (if the\r\nattribute is not found in an earlier classes searched, by overriding), by the\r\nFundamental Equation of Object-Oriented Programming generalized in this lecture.\r\n\r\nSo, while \r\n\r\n  type(o) is C\r\n\r\ntruly asks whether o is an instance object constructed from class C,\r\nisinstance(o,C) is asking whether C can eventually be searched when trying to\r\nfind attributes in o. In the following picture isinstance(o,C) is True.\r\n\r\n               C\r\n               ^\r\n               |\r\n.....other Base Classes of type(o).....\r\n               ^\r\n               |\r\n   type(o): actual class of o\r\n\r\nGiven what we learned above, we can easily implement the operation of calling\r\nisinstance(o,C) in Python as\r\n\r\n  C in type(o).__mro__\r\n\r\nsince type(o).__mro__ contains o's actually class and all the base classes its\r\nclass is derived from.\r\n\r\nNote that isinstance(o,object) always returns True, because object is always\r\nsearched in an inheritance hierarchy; it is always the last class in __mro__.\r\n\r\nA very interesting fact is that if isinstance(o,C) is True and if a is an\r\nattribute defined in class C, then writing o.a will always find a binding for\r\nthe attribute a (and never raise AttributeError): the binding will either come\r\nfrom C itself (if the search goes all the way up to class C) or from some class\r\nderived from C that redefines/overrides this attribute (or because attribute\r\na is stored in the object o itself).\r\n\r\nSo, using an attribute defined in class C will always be legal to access for\r\nany class derived from C.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nExceptions and Inheritance\r\n\r\nIn fact, all Exceptions are arranged in an inheritance hierarchy. If we write\r\n\"except Foo\" in a try/except, it handles a raised exception that is from the\r\nFoo class or any class derived from Foo. Technically, if x refers to a raised\r\nexception object, \"except Foo\" handles any exception class for which\r\nisinstance(x,Foo) is True (what this means is x is an object constructed from\r\nthe Foo class or any class derived from Foo; remember derived means beneath it\r\nin the inheritance hierarchy).\r\n\r\nSo we can create a hierarchy of exception classes, some more general (higher\r\nup in the hierarchy, matching more general -many possible- exception classes)\r\nand some more specific (lower in the hierarachy). In a try/except statement\r\nwith multiple except parts, the excepts are checked sequentially: the first one\r\nmatching (by isinstance) executes its block and no other ones are tried. So,\r\nwhen we write a try/except with many except parts, we must order them in such a\r\nway that they are handled correctly (often meaning specific exceptions before\r\ngeneral ones). \r\n\r\nFor example, there might be a FileError exception for general file errors. We\r\nmight define\r\n\r\nclass FileError  (Exception) : ...\r\nclass InputError (FileError ): ...\r\nclass OutputError(FileError ): ...\r\nclass EOFError   (InputError): ...\r\n\r\nwhich would have the following hierarchy (Exception is derived from\r\nBaseException which is derived from object).\r\n\r\n               object\r\n                  ^\r\n                  |\r\n              BaseException\r\n                  ^\r\n                  |\r\n              Exception\r\n                  ^\r\n                  |\r\n              FileError\r\n               ^     ^\r\n              /        \\      \r\n       InputError   OutputError\r\n           ^\r\n           |\r\n        EOFError\r\n\r\nOther exceptions that we have seen, like AssertionError and TypeError, are\r\nderived from the base class Exception.\r\n\r\nThis is NOT the actual way it is done in Python, but serves as a good/simple\r\nillustrative example for the discussion below. You can write somemthing\r\nlike print(EOFError.__mro__ to see the actual derivation of EOFError).\r\n\r\nPython checks whether the exception object raised is an instance of the\r\nexception named in the except clause. So, for except EOFError, Python checks\r\nwhether isinstance(raised_exception_object, EOFError).\r\n\r\nSo, if we wrote\r\n\r\nexcept EOFError  :... handles only EOFError\r\n\r\nbecause EOFError is not the base class of any derived class shown above\r\n\r\nor\r\n\r\nexcept InputError:... handles both InputError and EOFError\r\n\r\nbecause InputError is the base class of EOFError. So if eofo is an object from\r\nthe EOFError class, and it is raised, isinstance(eofo, EOFError) is True and\r\nisinstance(eofo,InputError) is also True, so both exceptions are handled.\r\n\r\nor\r\n\r\nexcept FileError :... handles FileError, InputError, OutputError, and EOFError\r\n\r\nbecause, for example, if eofo is object from the EOFError class, and it is\r\nraised, isinstance(eofo, EOFError), and isinstance(eofo,InputError), and\r\nisinstance(eofo,FileError) all return True; likewise, if ieo is object from the\r\nInputError class, and it is raised, isinstance(ieo,InputError) and\r\nisinstance(ieo,FileError).\r\n\r\nThe except clauses are checked SEQUENTIALLY FROM TOP TO BOTTOM. The first one\r\nhaving the isinstance function return True, specifies how that exception is\r\nhandled (later ones are not tried). So, if we wrote\r\n\r\nexcept EOFError  :... handle an EOFError one way\r\nexcept FileError :... handle a FileErrorr another way\r\n\r\nwould handle EOFError in one way, and all other FileErrors in another way.\r\n\r\nIn fact, we can write a a single class or a tuple/list of classes after the\r\nexcept keyword. For a single class Python checks whether or note the exception\r\nis an instance of that class; for a tuple/list it checks whether the exception\r\nis an instance of any class in the list. So\r\n\r\nexcept (InputError,EOFError): ...handle either InputError or EOFError one way\r\nexcept OutputError          : ...handle OutputError another one way\r\n\r\nwould handle InputError and EOFError in one way, and OutputError another way.\r\n\r\nIn fact, we could simplify this to just \r\n\r\nexcept InputError : ...handle either InputError or EOFError one way\r\nexcept OutputError: ...handle OutputError another one way\r\n\r\nbecause any EOFError is also an instance of InputError (see the hierarchy).\r\n\r\nWARNING: The one thing that programmers need to watch out for is writing the\r\nfollowing (which just reverses the two except clauses used in an example above).\r\n\r\nexcept FileError :... \r\nexcept EOFError  :... \r\n\r\nHere the except EOFError clause will NEVER be tried, because EOFError is\r\nderived from FileError, and therefore will be processed by the code in the\r\nFileError's except clause. Generally, to process exceptions correctly, they\r\nshould be listed from most SPECIFIC to most GENERAL (and EOFError is more\r\nspecific thatn FileError: it is derived from FileError).\r\n\r\nThe programming language Java uses the same general mechanisms for inheritance\r\nand exception handling, but in addition it would issue an error if a more\r\ngeneral exception appeared before a more specific one. Java, like Python,\r\nknows the inheritance hierarchy of exceptions, and it actually checks for\r\ncorrect usage before running a Java program. We will discuss various forms of\r\n\"static checking\" during the last week of class.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n1) Given the following class definitions, draw the inheritance network and\r\nindicate in what order the class objects are searched for attributes.\r\n\r\nclass A          : pass\r\nclass B          : pass\r\nclass C(A,object): pass\r\nclass D          : pass\r\nclass E(D,B)     : pass\r\nclass F(B,C)     : pass\r\nclass G(E,F)     : pass\r\n\r\n2) Rewrite the pgetattr function to return a list (empty, one value, or\r\nmultiple values) that contains all the values found in the inheritance\r\nhierarchy of the given attribute name.\r\n\r\n3) For what second argument will isinstance always return True, no matter what\r\nthe first argument?\r\n\r\n4) We saw that writing\r\n\r\n  except EOFError  :...way1\r\n  except FileError :...way2\r\n\r\nhandles EOFError in way1 and FileError in way2. Explain why reversing the\r\norder\r\n\r\n  except FileError :...way2\r\n  except EOFError  :...way1\r\n\r\nwould cause both FileError and EOFError to be handled in way2.\r\n", "encoding": "ascii"}