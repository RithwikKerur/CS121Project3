{"url": "https://www.ics.uci.edu/~ejw/authoring/orlando/adv_col_breakout.html", "content": "<HTML>\n<HEAD>\n<TITLE>Notes from WebDAV Advanced Collections Breakout, IETF-43, Orlando,\nFlorida, December 8, 1998</TITLE>\n</HEAD>\n<BODY>\n<H2 ALIGN=CENTER>Breakout Session on Advanced Collections</H2>\n\n<H3 ALIGN=CENTER>IETF-43, Orlando, Florida<BR>\nTuesday, December 8, starting at 13:00</H3>\n\n<P>A breakout session on WebDAV Advanced Collections was held Tuesday,\nDecember 8, 1998.  This was not an official meeting of the WebDAV\nworking group.  However, since the discussions are of general interest\nto working group members, these minutes were taken to record the\ndiscussion. Judy Slein recorded the minutes.\n\n<P>The breakout session on advanced collections discussed several issues\nrelated to referencing: (1) whether we need to provide backpointers from\ntarget resources to the references that point to them, (2) whether we should\nreconsider our earlier decision to exclude referential integrity from our\nscope, (3) how to allow clients to operate on references as well as on their\ntargets, (4) whether we really need both direct and redirect references, (5)\nwhether to drop a requirement to be able to hide the location of a target\nresource, and (6) the relationship between the versioning spec and\nreferencing.\n\n<P>Attending:\n \n<P>Jim Whitehead (University of California / Irvine)<BR>\nJudy Slein (Xerox)<BR>\nKen Coar (IBM, Apache)<BR>\nManoj Kasichainula (IBM, Apache)<BR>\nGeoff Clemm (Rational - ClearCase)<BR>\nYuri Demchenko (TERENA)<BR>\n\n<P><B>BACKPOINTERS</B>\n\n<P>There has been a lot of controversy about whether to expose in the protocol\na property (DAV:references) that lists the references to a given resource.\nAn alternative is to perform a DASL search for resources that have\nDAV:reftarget equal to the URI of the resource in question.  (Since\nDAV:reftarget is a structured property, this strategy is only possible if\nDASL includes search on structured properties.)\n\n<P>Performance considerations are not decisive between the two strategies.\nSearch could be efficient.  This particular query could be optimized to\nexamine a property (not exposed through the protocol).  A DAV:references\nproperty might be implemented as a list, or might be computed on the fly by\nscanning the file system.\n\n<P>Clients need to know whether the search will be optimized before they\nrequest the search.  There is no way to find out.  DASL does include a\nmechanism for clients to limit the resources a server spends on a given\nquery.\n\n<P>Clients need to know whether the property is computed on the fly before\nrequesting it.  There is no way to find out.  The impact of computing on the\nfly is especially significant when a client requests allprop.  There may be\nother properties that are computed on the fly as well.  DAV:getetag is\ncomputed, and some versioning history properties may also be computed.\n\n<P>We could include an implementation note for clients, warning them not to\nassume that examining DAV:references will be more efficient that searching\non DAV:reftarget.\n \n<P>We could include an implementation note for servers, warning them to use\ncomputed properties with care, because of their potential impact on allprop.\nServers that are built on file systems may be unable to provide\nbackpointers.  In a Unix environment, if references are aliases it is easy\nto discover the references to a given resource; but if references are\nsymbolic links it is difficult or impossible.  Servers that are based on\nfile systems are unlikely to implement backpointers.\n\n<P>From a client's point of view, since many servers will not provide\nbackpointers, only advanced clients will take advantage of them. Clients\nthat are tailored for use with document management systems are the most\nlikely to make use of backpointers.\n  \n<P>DAV:references includes both direct and redirect references to the target\nresource.\n \n<P>Systems that provide strong references (e.g., systems that provide versioned\ncollections) use backpointers internally to keep DAV:reftargets up to date.\nUsers do want to be able to find out which versions and collections ever\ncontained this resource.\n  \n<P>Versioned collections need backpointers.  If backpointers are not provided\nin the collections protocol spec, the versioning spec will extend the\nsemantics of some sort of reference to get this functionality.\n \n<P>Conclusion: The attendees favor a DAV:references property, optional at the\nresource level.  There should be an implementation note addressed to\nservers: Be cautious about implementing DAV:references as a computed\nproperty, because of the possible impact of computation on allprop.  Be\nclear about the semantics of DAV:references: when it gets created, deleted,\nand updated.  If servers do implement backpointers, we want them to use the\nsame name for the property, and the same semantics.\n\n<P><B>STRONG REFERENCES</B>\n \n<P>Geoff Clemm is interested in reopening the issue of strong references.  He\nbelieves that support for strong references may not require much more than\nbackpointers. He believes that strong references will be important for\nversioning / configuration management systems.  If the collections spec does\nnot provide strong references, the versioning spec may have to.\n\n<P>Geoff will send a mailnote on this subject at least to the attendees of this\nmeeting.\n  \n<P>We need to try to recreate and capture for the record the considerations\nthat led to ruling strong references out of scope in the first place.\n\n<P><B>RE-DIRECT VS. NO-PASSTHROUGH HEADER</B>\n\n<P>The new Re-Direct header applies only to direct references, and makes them\nbehave like redirect references just for the request that includes the\nRedirect header.  It asks the server to apply the request to the reference\nitself, rather than to its target.\n\n<P>Jim Whitehead suggests that we really need a header like this for both\nredirect and direct references.\n\n<P>At the moment the collections spec requires servers to respond to HTTP\nrequests on redirect references with a 302.  This makes it possible for\nplain HTTP clients to take advantage of redirect references.  In fact, we\nshould require servers to respond with a 302 to WebDAV requests as well as\nto HTTP requests, so that non-referencing WebDAV clients can take advantage\nof redirect references.   Once we have made this change, there is no way to\noperate on the redirect reference itself.\n  \n<P>So we need a header that can be applied to both redirect and direct\nreferences, asking the server to apply the request to the reference itself,\nnot to its target.  Let's call it No-Passthrough.  The more common case is\nfor the client to want the request to be applied to the target.  So the\nheader will just be used for the less common case.\n\n<P><B>REDIRECT + DIRECT</B>\n\n<P>Judy Slein asked whether we really need both redirect and direct references.\nThey started out being very different from each other.  In the first draft,\nredirect references were just resources with no content and a DAV:reftarget\nproperty that a client could retrieve to locate the target resource, and\nthen perform operations on that resource.   But over time redirect and\ndirect references have become more similar.  First the semantics of redirect\nreferences changed to accommodate plain HTTP clients: responses to HTTP\nrequests got a 302 response accompanied by the DAV:reftarget property in the\nLocation header.  Now if we take Jim Whitehead's advice, all requests on\nredirect references will use this semantics, so that non-referencing WebDAV\nclients can be accommodated.  For both direct and redirect references, if\nthe client wants to operate on the reference itself, it must use the\nNo-Passthrough header.  At this point, is the distinction between redirect\nand direct references significant?\n\n<P>There is still an important difference in the difficulty of the server\nimplementation.  We need redirect references for cases where the target is\non a different server from the reference.  Direct references could not work\nacross servers unless the server had proxy capabilities or used some\nserver-to-server protocol.\n \n<P>We might want to let direct references respond with 302 if the target is on\na different server.\n\n<P>The direct / redirect distinction mirrors Apache's internal / external\nredirects.  Both are useful.\n \n<P>We may want redirect references to allow clients to update their tables. \n\n<P>Conclusion: We need both redirect and direct references.\n  \n<P><B>DELETE, MOVE, AND COPY</B>\n\n<P>Delete and move are special cases.  They always get applied to the\nreference, not to its target.  Why?\n \n<P>They amount to editing the collection containing the reference, not the\nobject being referenced.   In some systems performing a delete or a move\nonly requires a permission on the directory, not on the object.  This is a\ncommon semantics.  It is Unix semantics.\n\n<P>MOVE: We need to define the semantics for what happens to the backpointers\nwhen a reference gets moved.\n \n<P>What about MOVE requests from non-referencing clients?  Should these\nrequests ever result in the target being moved?  Would you ever want to do\nmove with pass-through?  In many systems it would be literally wrong to do a\nmove with pass-through semantics.  We don't want other references to the\ntarget to get broken.  We should not allow a pass-through move.\n \n<P>Conclusion: Stay with the status quo - DELETE, MOVE, and COPY are always\napplied to the reference, never to its target.\n \n<P><B>HIDING THE TARGET</B>\n \n<P>The requirement to be able to hide the location of a target resource was\nmotivated by a scenario.  Sue has a collection full of highly confidential\ninformation.  She doesn't want anyone to know about it.  But she needs to\ngive Tom access to one resource in the collection to get his comments on it.\nSo she would like to create a reference to it for him, but prevent him from\nknowing the location where it and all the other confidential resources\nreside.\n  \n<P>Another motivation: Tilde-name directories provide point of attack by\nrevealing a user name.\n\n<P>This is \"security through obscurity.\"  Security through obscurity is rarely\nthe right answer.\n  \n<P>Don't keep things in directory structures that reveal information you want\nto hide.\n\n<P>If we have access control, we don't need this.  We would need access control\non properties, so that we could prevent clients from seeing DAV:reftarget.  \nIn any case, this is not very important.  The security exposure is limited. \nWe can add this capability later if it really looks as if people want it.\nWait and see whether people implement it with properties.\n\n<P>Add a discussion of the risk to security considerations rather than add a\nheader.\n  \n<P>Conclusion: Drop the requirement that it be possible to hide the location of\na target resource.\n\n<P><B>VERSIONING AND REFERENCES</B>\n\n<P>Versioning of collections is being implemented on top of referencing.\n\n<P>Judy Slein requests that before extensions to referencing capabilities are\nput into the versioning spec, the team consider whether they would be more\ngenerally useful.  If so, they should be added to the collections\n(referencing) spec instead.\n\n<P>Do we need to extend the syntax of DAV:reftarget, to allow it to contain\nmore than just a URL?  Versioning may need it to include the URL of a\nversion graph, together with information about which member of the graph to\nselect.\n \n<P>We may want to make the syntax of DAV:reftarget extensible by using\nattribute-value pairs. The Ref-Target header would also have to become more\nflexible, and might need to be incorporated in an xml body.\n\n<P>*** Meeting Adjourned ***\n\n</BODY>\n</HTML>", "encoding": "ascii"}