{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/12.cutlink", "content": "HW: 14.1-5, 14.3-6, 14.3-7, 14-1\n\n\nCutting and linking trees\n\nProblem:\n    maintain a rooted forest of nodes (each non-root node -> parent, no cycles)\n    ops:\n\tnew node\n\tset parent of node x to y (if x has no parent and y not in same tree)\n\tclear parent of node x (making it a root)\n\tfind root of tree containing node x\n\n    application 1:\n\titerator objects -> each time you call \"next\", returns\n\t\tanother item from some stream\n\tdelegate iterator x to iterator y:\n\t\tuntil connection is broken,\n\t\teach time item from x requested,\n\t\tget one from y and return it\n\tnext():\n\t\tfind root of delegation tree\n\t\tand return item from it\n\n\te.g. inorder binary tree traversal:\n\t\tdelegate to left subtree traversal object\n\t\tthen return node itself\n\t\tthen delegate to right subtree traversal object\n\n\tnew iterator = new node\n\tdelegate = link\n\tstop delegating = cut\n\tnext = findroot\n\n    representation:\n\tchoose @ most one \"solid\" incoming edge @ ea. node, rest \"dashed\"\n\tso solid edges form paths\n\n\tstore splay tree for each path, tree order = path sequence\n\tallows quickly splitting, gluing, finding top of path\n\n\talso store outgoing dashed edge (if any) from root of path\n\n    expose(v): make v->root into a solid path\n\tsplit path(v) so v is bottom vertex\n\twhile pathtop(v) has a dashed edge t->u:\n\t\tsplit path containing u so u is bottom of path\n\t\tglue path(v), path(u)\n\n    link(x,y): expose(x), expose(y) and merge two paths\n\n    cut(v): expose(v) and separate v from rest of its path\n\n    findroot(v): expose(v) and find top vertex of path\n\n\n    analysis:\n\tall work done in expose, could make many changes to paths\n\t(dynamic trees not required to be balanced)\n\n\tpotential function based on \"heavy edges\"\n\n\tv->w heavy: #descs(v) > #descs(w)/2\n\t     light: not heavy\n\teach node has at most one incoming heavy edge\n\teach tree path (solid or not) has at most log_2 n light edges\n\n        Phi = # dashed heavy edges\n\n        expose:\n\t\tadd light edge to solid path: Phi += 1\n\t\t\thappens <= log_2 n times\n\t\tadd heavy edge to solid path: Phi -= 1\n\t\t\tcan happen more times\n\t\t\tbut paid for by decrease in Phi\n\n\t\tso: amortized # steps per expose <= log_2 n\n\n\teach step = splay tree op => O(log^2 n) time per operation\n\n\tmore careful analysis -- recall splay tree amortization involved\n\t\tnode weights\n\t    let weight(v) = #descs(v) - #descs(u)\n\t\twhere descs counted in actual dynamic tree (not splay tree)\n\t\tu->v is v's incoming solid edge (#descs(u)=0 if no such edge)\n\n\t    total weight tw(v) = sum_{splay tree descs(v)} weight(desc)\n\n\t    splay tree op takes time log({tw(root)}) - log({tw(v)})\n\n\t    times per expose telescope to O(log n)\n\n\t    have to be careful because cut/link ops change node weights\n\t\t=> change potential function used in splay tree amortized anal.\n\t\tbut only by logarithmic amount\n\n\tso: all cutting and linking operations O(log n) amortized time\n\n    application 2:\n\tmaintain edge costs in *undirected* tree\n\tfind maximum weight edge on path from v->root\n\n\tdirected->undirected:\n\t\tchoose arbitrary root\n\t\treroot @ v: expose(v), reverse its splay tree\n\t\t(augment splay tree to store reversal bit at each node)\n\n\taugment splay trees for max-edge queries (last week)\n\n\tincremental minimum spanning tree:\n\t\tmaintain current minimum spanning forest\n\t\t\t(w/arbitrary roots)\n\t\twhen new edge uv added:\n\t\t\treroot at u\n\t\t\texpose(v)\n\t\t\tif root(v) != u:\n\t\t\t\tlink(u,v)\n\t\t\telse find max edge xy on exposed path\n\t\t\t\tif weight(uv) < weight(xy):\n\t\t\t\t\tcut x-y\n\t\t\t\t\tlink(u,v)\n\n", "encoding": "ascii"}