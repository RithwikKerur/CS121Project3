{"url": "https://www.ics.uci.edu/~ejw/authoring/orlando/acl_breakout.html", "content": "<HTML>\n<HEAD>\n<TITLE>Breakout session on WebDAV Access Control, IETF-43, Dec. 9,\n1998</TITLE>\n</HEAD>\n<BODY>\n\n<H2 ALIGN=CENTER>\nBreakout session on WebDAV Access Control</h2>\n\n<h3 ALIGN=CENTER>IETF-43, Orlando, Florida<BR>Wednesday, December 9, starting at 15:30</h3>\n\n<P>A breakout session on access control for WebDAV was held on\nWednesday, December 9, 1998.  This was not a official meeting of the\nWebDAV working group.  However, since the discussions are of general\ninterest to working group members, these minutes were taken to record\nthe discussion.  Jim Whitehead recorded the minutes, and attempted to\nmediate floor control during the session.  In attendance during the\nbreakout session were: Jim Amsden, Derek Atkins, Ken Coar, Yaron\nGoland, Paul Hill, Alex Hopmann, Manoj Kasichainula, Rohit Khare, Paul\nLeach, Lisa Lippert, Larry Masinter, Judy Slein, Jim Whitehead.\n\n<P><B>SCOPE OF EFFORT: ACCESS CONTROL FOR WEB OR WEBDAV?</B>\n\n<P>The first discussion concerned the scope of the access control\neffort.  It was noted that the web in general, not just WebDAV, has a\nneed for a protocol for access control.  It was recommended that\nWebDAV access control develop a model document, so that WebDAV access\ncontrol can be applied to other domains/protocols more easily.  The\nmodel document can separate out those aspects of the access control\nprotocol which are not specifically tied to WebDAV.\n\n<P>** The attendees agreed that the access control effort should\nattempt HTTP access control, as well as WebDAV access control, unless\nit is proven to be too difficult to do both.  That is, the protocol\nshould use WebDAV mechanisms to set and read access control, but\naccess control should be applicable to HTTP operations in general, and\nnot just limited to WebDAV operations.\n\n<P><B>INTENDED USER OF THE PROTOCOL: ADMINISTRATORS OR AUTHORS?</B>\n\n<P>There was some discussion over who is intended to be the user of\nthis protocol.  Is the access control protocol intended for users who\nwill be performing authoring, or is it intended for use by system\nadministrators, who are interested in access control across an entire\nsite.\n\n<P><B>INHERITANCE:</B>\n\n<P>The topic of inheritance was discussed.  It was noted that the\naccess control inheritance within WebDAV is WebDAV-specific, since it\nis tied to WebDAV collections.  However, Calendaring and Scheduling\nhas a different inheritance model.  A participant raised the question\nof whether we should support multiple kinds of inheritance.  Today,\nservers support multiple kinds of inheritance, and hence it would be\ndesirable for the protocol to accomodate these servers.  However, the\ncomplexity of the user interface on the client is an important issue.\nSupporting multiple inheritance models would make the user interface\non the client more complex, and, some argued, too complex.\n\n<P>There was a suggestion to examine the Java Web Server for lessons\nwhich can be learned from its access control model, which is\nobject-oriented.\n\n<P><B>WEB-FORM MODEL FOR ACCESS CONTROL:</B>\n\n<P>A short-term solution for access control is to have a property\nrecorded on each resource which records a link pointing to a Web page\nwhich contains an access control form.  By manipulating the form using\na Web browser, a user can modify the access control for the resource.\nThis approach has the benefit that it can accomodate a wide range of\nrepositories, and each repository can have an access control user\ninterface which is tailored to the repository.  This approach can be\nspecified and fielded quickly.\n\n<P>The most significant drawback to this approach its lack of support\nfor a programatic interface to access control.  Furthermore, users\nwill be required to understand the access control mechanism for each\nserver they author against.  If the goal is to provide access control\nfor the Web, and not just for WebDAV, the Web-form approach has the\ndrawback that it depends on WebDAV properties, which are not\nunderstood by downlevel Web clients.  However, if these clients\ndiscover the Web-form page without reading a property, they could\nmanipulate the Web-form. Finally, the Web-form approach provides only\na coarse degree of interoperability.\n\n<P>However, it was noted that once a protocol for access control was\nfinished, the access control property might still be useful as an\n\"escape hatch\" for more sophisticated access control capabilities.\nHowever, if this were done, it would be necessary to call out which\nfunctionality can be access via the Web-form interface, and which can\nbe accessed programatically.\n\n<P>Yaron Goland volunteered to write up a draft specification for the\nWeb-form approach.\n\n<P><B>GROUPS:</B>\n\n<P>Groups were felt to be out of scope, since they are a (LDAP)\ndirectory concept.  However, the Java Web Server supports a notion of\nrealms (HTTP realms).\n\n<P><B>MAPPING OF ACCESS CONTROL PROTOCOL TO REPOSITORY ACCESS CONTROL:</B>\n\n<P>Access control for resources which are accessible via multiple\nprotocols, such as via HTTP and FTP, directly leads to this issue.\nFor resources which are accessible via multiple protocols, access\ncontrol via only one protocol is not a viable security model.  One way\nto address this problem is to ensure that access control set via one\nprotocol actually sets the access control for the underlying\nrepository where the data is stored.  In this way, access control set\nvia one protocol will apply to all other protocols used to access the\nsame resource.\n\n<P>However, it is a difficult problem to map access control rights in\nthe protocol into the appropriate rights in the underlying\nrepository. The difficulty arises from the case where there is not a\n1:1 mapping of rights from protocol to repository, which either leads\nto unpredictable behavior (rejecting a request), or the inadvertent\nopening of security holes (performing the request has unintended\nside-effects). This concern applies to all network protocols, and is\nnot specific to the Web, or WebDAV.\n\n<P>The following \"database cell\" scenario was discussed during the\nbreakout session, and highlights this issue.  Assume there is a\ndatabase which is being accessed via WebDAV.  Each cell in the\ndatabase contains a PUT body and WebDAV properties.  The database has\na very simple \"1 write bit\" access control mechanism - when the write\nbit is \"1\", you can write to the entire cell, and when the write bit\nis \"0\", you cannot write to any of the cell's contents.  Assume the\nWebDAV access control protocol has separate access rights for \"write\nproperties\" and \"write (PUT) body\".\n\n<P>The problem arises when trying to map the \"write properties\" access\ncontrol right into the rights supported by the repository.  If the\nclient submits a protocol request to grant it the \"write properties\"\nright, the repository has two choices:\n\n<OL>\n<LI>It can refuse to set the\nwrite bit for the database cell, causing the protocol request to fail.\n<LI>It can set the write bit, causing the protocol request to succeed.\nThis has the unintended consequence of allowing write access to the\nPUT body as well, thus creating a security risk.\n</OL>\n\n<P>There are two general approaches for handling this issue:\n<OL>\n<LI>Define a normative (generic) set of rights (e.g., the \"DAV set\" of\nrights), some of which might not apply to a given server.  A client\nthen performs access control operations using this set of rights.\nThis approach is easiest for clients.\n<LI>Discover the set of rights.  A client must first perform discovery\non the set of rights supported by the server, and then may perform\naccess control operations using these rights.\n</OL>\n\n<P>There was agreement that setting an access control right should not\nresult in unintended consequences, that is, consequences which are not\nsafe with respect to the underlying semantics of the store.\n\n<P>There was general agreement with the principle: in the event of a\nconflict between the semantics of the underlying repository's access\ncontrol capabilities, and the semantics of a particular access control\nprotocol request, the underlying repository semantics should always\ntake precedence.  There was general recognition that some access\ncontrol protocol requests might not be mappable into the access\ncontrol operations supported by a given repository.\n\n<P>There was agreement that the mapping issue needs to be recorded -\nthese minutes are a start at that, though it should also be explicitly\ndiscussed in the protocol document, and probably also the goals\ndocument.\n\n<P>There was agreement that it would help discussion to know the\naccess control semantics for several repositories.\n\n<P>Finally, it was noted that IMAP access control should be examined\nfor lessons learned.  It's approach is similar to #2 above in that the\nclient first performs discovery, which returns sets of methods whose\naccess control can be modified as a set.\n\n<P><B>PROBLEMS WITH METHOD-BASED ACCESS CONTROL</B>\n\n<P>There was discussion at the meeting on the use of method-based\naccess control, that is, access control where the access rights map\nexactly to HTTP methods.  Several participants at the breakout felt\nthis approach is a bad idea.\n\n<P>This approach has the benefit that it maps exactly onto HTTP\nmethods, which have specific semantics.  Thus the exact outcome of\nsetting a given access control right is well understood by client and\nserver.  A protocol which adopts this approach would likely be more\nsimple to specify and implement than other alternatives.\n\n<P>The drawbacks to this approach become evident when examining\nresources which are accessible via more than one protocol.  In this\ncase, HTTP methods might not map exactly onto operations available in\nother protocols.  Furthermore, HTTP methods might not map exactly onto\nthe access control rights provided by the underlying repository.  Due\nto this, clients would need to perform a trial-and-error style of\ninteraction when trying to set access control permissions, since\npresumably the underlying store would reject attempts to set access\ncontrol permissions which would result in security risks due to\nunintended side-effects.  The other drawback to method-based access\ncontrol is the difficulty of making a user-interface for the protocol.\nThe majority of users are not aware of the methods in the HTTP\nprotocol, and hence would be unable to set access control correctly\nusing a user interface which exposes the HTTP methods.\n\n<P>Most, but not all, participants at the breakout session felt that\nan approach which defines \"semantic\" access rights (e.g., \"modify\",\n\"read\", etc.) and then maps them into methods (e.g., \"modify\" -&gt; PUT,\nPOST, PROPPATCH) is better than a method-only approach.\n\n<P><B>NEW WORKING GROUP FOR APPLICATION LAYER PROTOCOL ACCESS CONTROL:</B>\n\n<P>There was some discussion on whether it would be better to have a\ngroup working just on Web and WebDAV access control, or have a group\nwhich tries to address access control across several application layer\nprotocols.  The advantage to addressing access control for several\nprotocols simultaneously is that the cross-protocol access control\nissue would be substantively addressed.  This is important, because\nmany network resources are accessible via multiple protocols, such as\nHTTP, FTP, news, mail, etc.  This would benefit administrators of\nservers for these protocols.  It would also tend to build critical\nmass for new application layer protocols to use this access control\nprotocol.\n\n<P>The disadvantage to having a cross-protocol access control effort\nis its scope.  It may prove to be too complicated to address the\naccess control issues of several protocols simultaneously.\n\n<P>A cross-protocol access control effort would be expected to produce\nthe following deliverables:\n<UL>\n<LI>a model document which is applicable across protocols\n<LI>a set of transport-independent objects (possibly in XML) which are\nexchanged to perform access control operations\n</UL>\n\n<P>*** End of Breakout Session ***\n\n</BODY>\n</HTML>", "encoding": "ascii"}