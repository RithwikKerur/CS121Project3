{"url": "https://www.ics.uci.edu/~ejw/versioning/arch/0119.html", "content": "<!-- received=\"Tue Sep  3 05:14:21 1996 PDT\" -->\n<!-- sent=\"Thu, 29 Aug 1996 14:00:23 -0700\" -->\n<!-- name=\"Jim Whitehead\" -->\n<!-- email=\"ejw@ics.uci.edu\" -->\n<!-- subject=\"Initial Dist. Auth. Requirements\" -->\n<!-- id=\"v02130505ae4b8f3533dc@[128.148.157.46]\" -->\n<!-- inreplyto=\"\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Initial Dist. Auth. Requirements</title>\n<h1>Initial Dist. Auth. Requirements</h1>\n<b>Jim Whitehead</b> (<a href=\"mailto:ejw@ics.uci.edu\"><i>ejw@ics.uci.edu</i></a>)<br>\n<i>Thu, 29 Aug 1996 14:00:23 -0700</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#119\">[ date ]</a><a href=\"thread.html#119\">[ thread ]</a><a href=\"subject.html#119\">[ subject ]</a><a href=\"author.html#119\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0120.html\">Roy T. Fielding: \"Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies\"</a>\n<li> <b>Previous message:</b> <a href=\"0118.html\">Yaron Goland: \"RE: Seiwald Q &amp; A\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\nHere is my initial draft of requirements that should be present in\nHTTP to support distributed authoring.  The intent is to only discuss\ndistributed authoring requirements in this document, and to not\ndiscuss versioning requirements, as much as this is possible (locking,\nedit notification, and relationships are overlapping issues, though.)\n\nI've posted this to both the versioning and distributed authoring lists,\nbut my intent is to have discussion take place on the distributed authoring\nlist (&lt;<a href=\"mailto:w3c-dist-auth-request@w3.org\">w3c-dist-auth-request@w3.org</a>&gt; to join).\n\nI'm hoping to be able to package this up in IETF standard format and\nsend it off for comment by the HTTP WG later next week.\n\nMany thanks to Yaron Goland, David Durand, Fabio Vitali, Christopher\nSeiwald, and Judith Slein for their ifnromative posts which really\nhelped clarify and provide rationale for these requirements.\n\n- Jim\n\n\nRequirements on HTTP for Distributed Editing\n\nJim Whitehead, U.C. Irvine, &lt;<a href=\"mailto:ejw@ics.uci.edu\">ejw@ics.uci.edu</a>&gt;\nRev. 0.1, August 29, 1996\n\nAbstract\n\nTBD.\n\n1.0 INTRODUCTION\n\nThis document describes functionality which, if provided in the HyperText\nTransfer Protocol (HTTP) Specification [Ref HTTP/1.1 Spec.], would support\nthe interoperability of tools which allow remote loading, editing and saving\n(publishing) of various media types using HTTP. As much as possible, this\nfunctionality is described without suggesting a proposed implementation,\nsince in general, there are many ways to perform the functionality within\nthe HTTP framework.\n\nMuch of the functionality described in this document stems from the\nassumption that people performing distributed authoring only have access to\nthe objects they are editing via the HTTP protocol. This is in contrast to\nthe majority of current authoring practice, where there is access to the\nunderlying storage media, often via a shell or graphical user interface to a\nfilesystem. Authors need more than just remote control over their individual\ndocuments: they need remote control over the namespace in which those\ndocuments reside. Currently, authors control their namespace by interacting\ndirectly with the underlying storage system, but when performing distributed\nauthoring this access is not available.\n\n2.0 REQUIREMENTS\n\nIn the requirement descriptions below, the requirement will be stated,\nfollowed by its rationale. If any current distributed authoring tools\ncurrently implement the requirement, this is also mentioned. It is assumed\nthat \"server\" means \"a program which receives and responds to HTTP\nrequests,\" and that \"distributed authoring tool\" or \"intranet enabled tool\"\nmeans \"a program which can retrieve a source entity via HTTP, allow editing\nof this entity, and then save/publish this entity to a server using HTTP.\" A\n\"client\" is \"a program which issues HTTP requests and accepts responses.\"\n\n  1. Source Retrieval. The source of any given entity should be retrievable\n     via HTTP.\n\n     There are many cases where the source entity stored on a server does\n     not correspond to the actual entity transmitted in response to an HTTP\n     GET. Current known cases are server side include directives, and SGML\n     which is converted on the fly to HTML. There are many possible cases,\n     such as automatic conversion of bitmap images into several variant\n     bitmap media types (e.g. GIF, JPEG), and automatic conversion of an\n     application's native media type into HTML. As an example of this last\n     case, a word processor could store its native media type on a server\n     which automatically converts it to HTML. A GET of this entity would\n     retrieve the HTML. Retrieving the source of this entity would retrieve\n     the word processor native entity.\n\n  2. Locks. It should be possible, via HTTP, to restrict modification of an\n     entity to a specific person, or list of persons. It should be possible\n     to query for whether a given URL has any active modification\n     restrictions, and if so, who currently has modification permission.\n  3. Independence of locks. It should be possible to lock an entity without\n     re-reading the entity, and without commiting to editing an entity.\n\n     At present, HTTP does not provide any support for preventing two or\n     more people from overwriting each other's modifications when they save\n     to a given URL. Furthermore, there is no way for people to discover if\n     someone else is currently making modifications to an entity. This is\n     known as the \"lost update problem,\" or the \"overwrite problem.\" Since\n     there can be significant cost associated with discovering and repairing\n     lost modifications, preventing this problem is crucial for supporting\n     distributed authoring. Furthermore, locking support is also a key\n     component of many versioning schemes, a desirable capability for\n     distributed authoring.\n\n     An author may wish to lock an entire web of entities even though they\n     are editing just a single entity, just to keep the other entities from\n     changing. In this way, an author can ensure that if a local hypertext\n     web is consistent in their distributed authoring tool, it will then be\n     consistent when they write it to the server. Because of this, it should\n     be possible to take out a lock without also causing transmission of the\n     contents of an entity. Similarly, it should not be assumed that because\n     an entity is locked, that it will necessarily be modified.\n\n  4. Notification of Intention to Edit. It should be possible to notify the\n     HTTP server that an entity is about to be edited by a given person. It\n     should be possible to query the HTTP server for the list of people who\n     have notified the server of their intent to edit an entity.\n\n     Experience from configuration management systems has shown that people\n     need to know when they are about to enter a parallel editing situation.\n     Once notified, they either decide not to edit in parallel with the\n     other authors, or they use out-of-band communication (face-to-face,\n     telephone, etc.) to coordinate their editing to minimize the difficulty\n     of merging their results. Notification is separate from locking, since\n     a lock does not necesssarily imply an entity will be edited, and a\n     notification of intention to edit does not carry with it any access\n     restrictions. This capability is supportive of versioning, since a\n     check-out is typically involves taking out a lock, making a\n     notification of intention to edit, and getting the entity to be edited.\n\n  5. Relationships. Via HTTP, it should be possible to create, query, and\n     delete arbitrary typed relationships (links) between entities of any\n     media type.\n\n     Relationships (or links which are not necessarily navigable) between\n     entities can be used for many purposes. Relationships support\n     pushbutton printing of a multi-resource document in a prescribed order,\n     jumping to the access control page for an entity, and quick browsing of\n     related information, such as a table of contents, an index, a glossary,\n     help pages, etc. While relationship support is provided by the HTML\n     \"LINK\" element, this is limited only to HTML entities, and does not\n     support bitmap image types, and other non-HTML media types.\n     AOLpress, America Online, currently \"allows pages to add toolbar\n     buttons on the fly using the HTML 3.2 &lt;LINK REL....&gt; tag. For example,\n     your page can add toolbar buttons that link to a home page, table of\n     contents, index, glossary, copyright page, next page, previous page,\n     help page, higher level page, or a bookmark in the document.\" (Source:\n     <a href=\"http://www.aolpress.com/press/1.2features.html\">http://www.aolpress.com/press/1.2features.html</a>)\n\n  6. Attributes. Via HTTP, it should be possible to create, query, and\n     delete arbitrary attributes on entities of any media type.\n\n     Attributes can be used to define fields (such as author, title,\n     subject, organization) on resources of any media type, which can be\n     used later in searches. Attributes also support the creation of catalog\n     entries as a placeholder for an entity which are not available in\n     electronic form, or which will be available later.\n\n  7. List URL Hierarchy Level. A listing of all entities, along with their\n     media type, and last modified date, which are located at a specific URL\n     [ref RFC 1738] hierarchy level in an http URL scheme should be\n     accessible via HTTP.\n\n     In [ref RFC 1738] it states that, \"some URL schemes (such as the ftp,\n     http, and file schemes) contain names that can be considered\n     hierarchical.\" Especially for HTTP servers which directly map all or\n     part of their URL name space into a filesystem, it is very useful to\n     get a listing of all resources located at a particular hierarchy level.\n     This functionality supports \"Save As...\" dialog boxes, which provide a\n     listing of the entities at a current hierarchy level, and allow\n     navigation through the hierarchy. It also supports the creation of\n     graphical visualizations (typically as a network) of the hypertext\n     structure among the entities at a hierarchy level, or set of levels. It\n     also supports a tree visualization of the entities and their hierarchy\n     levels.\n     AOLpress, America Online, currently supports \"Save As...\" dialog boxes,\n     and graphical network visualization of a portion of a site's hypertext\n     structure, which they term a \"mini-web.\"\n     FrontPage, Microsoft, also currently supports a graphical network\n     visualization and additionally support a tree visualization of a\n     portion of a site's structure.\n\n  8. Make URL Hierarchy Level. Via HTTP, it should be possible to create a\n     new URL hierarchy level in an http URL scheme.\n\n     The ability to create containers to hold related entities supports\n     management of a name space by packaging its members into small, related\n     clusters. This utility of this capability is demonstrated by its wide\n     implementation in recent operating systems. The ability to create a URL\n     hierarchy level also supports the creation of \"Save As...\" dialog boxes\n     with \"New Level/Folder/Directory\" capability, common in many\n     applications.\n     AOLpress, America Online, currently supports this capability through\n     their \"Save As...\" dialog box, and their custom MKDIR method.\n\n  9. Copy. Via HTTP, it should be possible to make a byte-for-byte duplicate\n     of an entity without a client loading, then resaving the entity. This\n     copy should leave an audit trail.\n\n     There are many reasons why an entity might need to be duplicated, such\n     as change of ownership, a precursor to major modifications, or to make\n     a backup. In combination with delete functionality, copy can be used to\n     implement rename and move capabilities, by performing a copy to a new\n     name, and a delete of the old name. Due to network costs associated\n     with loading and saving an entity, it is far preferable to have a\n     server perform an entity copy than a client. If a copied entity records\n     which entity it is a copy of, then it would be possible for a cache to\n     avoid loading the copied entity if it already locally stores the\n     original.\n\n 10. Rename. Via HTTP, it should be possible to change the URL of an entity\n     without a client loading, then resaving the entity under a different\n     name.\n\n     It is often necessary to change the name of an entity, for example due\n     to adoption of a new naming convention, or if a typing error was made\n     entering the name originally. Due to network costs, it is undesirable\n     to perform this operation by loading, then resaving the entity,\n     followed by a delete of the old entity. Ideally an HTTP server should\n     record the rename operation, and issue a \"301 Moved Permanently\" status\n     code for requests on the old URL. Note that moving an entity is\n     considered the same function as renaming an entity.\n\n\n--#--\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0120.html\">Roy T. Fielding: \"Re: Seiwald Q &amp; A -- \"GET for EDIT\" cookies\"</a>\n<li> <b>Previous message:</b> <a href=\"0118.html\">Yaron Goland: \"RE: Seiwald Q &amp; A\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n", "encoding": "ascii"}