{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/b-tree.txt", "content": "\tB-Trees: An Efficent Structure for Searching Data on External Memory\r\n\r\n\r\nIn this lecture we will examine one data structure and algorithm that is useful\r\nwhen storing data that needs more space than is available in main memory. We\r\nwill analyze this algorithm with respect to how often it moves blocks of data\r\nbetween main and external memory (discussed in the previous lecture). Typically\r\nthe cost of such memory transfers dominates the cost of executing code on the\r\nblock while it is in memory. That is, a transfer between main and external\r\nmemory might take 10 milliseconds, while processing the data in the block might\r\ntake microseconds (a few 1/1000ths of a millisecond) before making another\r\nmemory transfer. A processor executing 10^9 instructions per second can process\r\n10^7 (10 million) instructions in 10 ms. So, we can virtually ignore the time\r\ntaken to process each block retrieved from memory, counting only the number of\r\ntransfers to analyze its time requirements.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSearching with B-Trees:\r\n\r\nA B-Tree is special kind of N-ary Search Tree (NST - contrast to BST).\r\n\r\nThere are many different kinds of B-trees. We characterize each B-tree in terms\r\nof it ORDER, b: each memory block stores b-1 keys and b pointers to children\r\n(subtrees). For b = 5 -the example we will use here- we can visualize each node\r\nin the tree as containing two arrays: the key array (storing the keys aka\r\nvalues in the B-tree) and the subtree/children array, storing pointers to\r\nchildren nodes, their roots in subtrees. We will use the familiar terminology\r\nof root, internal node, and leaf to describe these trees.\r\n\r\nFor example, here is the data for one node in a B-tree of order 5: it has room\r\nfor 4 keys, 5 children. They keys are used to separate the childen: < the key\r\n(to its left) and > the key (to its right).\r\n\r\n            0   1   2   3\r\n          +---+---+---+---+\r\nkey       |   |   |   |   |\r\n          +---+---+---+---+\r\n          0   1   2   3   4\r\n        +---+---+---+---+---+\r\nsubtree |   |   |   |   |   |\r\n        +---+---+---+---+---+\r\n\r\nBy the order property (see it below)\r\nall values in subtree[0] are less than key[0]\r\nall values in subtree[1] are greater than key[0] and less than key[1],\r\nall values in subtree[2] are greater than key[1] and less than key[2],\r\nall values in subtree[3] are greater than key[2] and less than key[3],\r\nall values in subtree[4] are greater than key[3]\r\n\r\nB-Trees have other properties (listed below): for example, their arrays don't\r\nhave to be filled, but all nodes except the root must be at least half filled\r\nwith respect to the number of child pointers they store (see the structure\r\nproperty below).\r\n\r\nUltimately, b will be a large value, such that storing the arrays in the node\r\nwill take up the size of a large block easily readable from external storage \r\n(typically containing thousands of keys/subtree pointers). So, if it were\r\nconvenient to transfer blocks of 1,000 words of memory, we would choose b to\r\nbe 500, having 499 (b-1) keys and 500 (b) subtrees/children. It is not \r\nunreasonable to transfer blocks of 10K or even 100K or 1M words, because the\r\nlatency and bandwidth properties of external storage allow that much information\r\nto be transferred quickly.\r\n\r\nIn the examples below, we will choose b to be 5. This b is big enough to be\r\ninteresting (and different than a Binary Search Tree) but small enough to cause\r\nlots of node merges and splits when doing insertions and deletions: if b were\r\n500, we would have to insert 500 values before we required a second block of\r\nmemory to be used.\r\n\r\nWe will now characterize the order and structure properties of B-trees\r\n\r\nOrder Property\r\n  1) The keys in a node are sorted left to right, key[i]<key[i+1]\r\n      (for simplicity, assume unique values).\r\n  2) A subtree between key[i] and key[i+1] (see the picture above) contains\r\n      values x such that key[i]<x<key[i+1]. For a leftmost subtree, it contains\r\n      values x only such that x < key[0]; for a rightmost subtree k it contains\r\n      values x such that x > key[k-1]\r\n\r\nStructure Propery of B-trees of order b (5)\r\n  1) All leaves are at the same depth and store their information as keys only\r\n     (all the subtree pointers for leaves, of course, store nullptr, so this\r\n      space gets wasted)\r\n  2) Every non-leaf node with k keys contains k+1 children\r\n     (leaf nodes contain, by definition, no children)\r\n  3) Every node has at most b-1 keys (5-1=4)\r\n  4) Every node except the root has >= b/2 (5/2 = 2) keys (it is at least 1/2\r\n       full with respect to children pointers)\r\n  5) The root may be empty and it may also be a leaf\r\n\r\nBelow is the psuedocode for searching for, inserting, and removing values in a\r\nB-tree. Aside: I expect you to know (i.e., memorize) how to search and insert,\r\nbut not delete (which is a bit too complicated).\r\n\r\n------------------------------\r\n\r\nSearching for x in a node (start searching at the root):\r\n\r\nOverview: Recall that all leaves are at the same depth (call it d). At most we\r\nwill look at d+1 nodes, each requiring tranfering one block of memory from the\r\nexternal device to the main memory. Recall, the depth of the root is 0.\r\n\r\n  If there is no root node, x is not in the tree\r\n  If there is a root node\r\n    Using the order property, do a \"binary\" search on the keys in the node\r\n    (actually a (b)-ary search since each node has up to b children)\r\n      a) if there is an i such that keys[i] = x, x is in the tree at this node\r\n      b) otherwise, if x < key[0] search subtree with index 0\r\n                    if keys[i] < x < keys[i+1] search the subtree at index i+1\r\n                    if x > the last key[k] search the subtree with index k+1\r\n\r\nNote that we can do a normal binary search on array of the b-1 keys in a B-Node,\r\nwhich takes a trivial amount of time compared to bringing the block into memory.\r\nEven a B-Node with 1 million keys would take only 20 comparisons to search.\r\n\r\n------------------------------\r\n\r\nInsertion of x (assuming it is not already in the tree; for simplicity assume\r\nunique values, as in sets and maps):\r\n\r\nOverview: x will be added as a key/value in some leaf; if that leaf is already\r\nfull, it will split into two nodes, with one key/value propagating upward to\r\nits parent. If the parent is full, it too will split, .... Eventually a parent\r\nwill not be filled and accommodate the key, or a new root will be created,\r\nincreasing the height of the tree (and the depth of all the leaves) by 1. So\r\nunlike BSTs (which grow from their leaves downward), B-Trees grow from their\r\nroots upward.\r\n\r\n  Search the tree to find in which LEAF x belongs\r\n\r\n  If there is room in that leaf, put x in the key array at the correct index.\r\n  If there is NO room for the key/value in the leaf (the node's keys are full)\r\n    Find the median value among the values in the leaf, including the new value:\r\n      we can find the median in O(N)\r\n    Using the median as the separator value, split the leaf into two new nodes\r\n      (one with all values<median, one with all values>median)\r\n    Insert the median in the parent's node adjusting the children (now 1 more)\r\n      as necessary; if there is no room for the key/value in the parent\r\n      split it using these same instructions\r\n\r\n  It is possible, if this process goes back to a full root node, that the\r\n  root node will itself need to split into two children of a newly created\r\n  root, which will have just one value (allowed at the root by the structure\r\n  property). So, unlike BSTs, B-trees grow at the root, not the leaves. This \r\n  ensures the property that all the leaves are at the same depth.\r\n\r\nNote that when a median is inserted in the parent, the two children will be well\r\nbalanced, each containing half the values in the original leaf node that was\r\nsplit (no matter what order they were inserted). Also, each split node will be\r\nonly 1/2 full, so it will have room to add more keys later, without\r\nhaving to split immediately.\r\n\r\n------------------------------\r\n\r\nDeletion for x:\r\n\r\nOverview 1: Deletion in a B-Tree is similar to deletion in a BST. Either the\r\nvalue being deleted is in a leaf or it is in an internal node. If it is in a\r\nleaf, it is deleted there (see Overview 2); if it is in an internal node, we\r\nreplace its value by the largest value smaller than x or the smallest value\r\nbigger than x (that value will always be in a leaf) and delete this replacing\r\nvalue from its leaf (see Overview 2).\r\n\r\nOverview 2: To delete a value from a leaf we remove it; if it has enough keys/\r\nvalues (remember the structure propoerty, part 4) we are done. If the leaf has\r\ntoo few keys/values we try to borrow one from any of its adjacent siblings; if\r\nwe can (so the leaf and its sibling have the required minimum keys/values), we\r\nare done. If not we REBALANCE the leaf with one of its adjacent siblings and a\r\nvalue from its parent, possibly leading to more REBALANCE operations between the\r\nparent, its adjacent siblings, and its parent....ultimately possibly removing\r\nthe root node and decreasing the height of the tree.\r\n\r\n  Search the tree to find in which node x is present.\r\n  If it is not present, \"there is nothing left to do\" (TINLTD)\r\n\r\n  If the node containing x is is a LEAF\r\n    remove x  from the keys/values\r\n    if the node that contained x is also the root, or\r\n       the # of keys/values is still >= b/2: TINLTD\r\n\r\n    if the # of keys/values is now < b/2 and the node is not the root, we say\r\n      the node with  x removed \"deficient\" (it doesn't have >= b/2 values);\r\n      perform the code labeled \"REBALANCE\" below, which will restore a\r\n      deficient node but possible make its parent deficient (if so, requiring\r\n      REBLANCE to be called on it), possibly processing nodes all the way\r\n      up to the root.\r\n\r\n  If the node containing x is an INTERNAL NODE (not a leaf)\r\n    replace x by an \"extremal\" value (largest value in the left subtree or\r\n      smallest value in the right subtree) and then remove that value (which\r\n      is in a LEAF by the rules above).\r\n\r\n\r\nREBALANCE: A deficient node (DN) has < b/2 values\r\n\r\nBelow is the \"rebalance\" code when deleting x from a node that becomes\r\ndeficient. This code may terminate, or bring the deficiency from child to\r\nparent, where it is executed again. Note that it is ok for a root to be\r\ndeficient: we don't have to REBALANCE it.\r\n\r\nLet DN be the deficient node (originaly, the one from which x was removed).\r\nChoose one of the 3 possibilities below: Note 1 and 2 are symmetric for\r\nright/left siblings (if both are true, choose to do either one)\r\n\r\n1) If DN's right sibling has > b/2 (5/2 = 2) values\r\n     (in this case, it won't be deficient after removing one of its keys/value)\r\n     add the parent's separator of these siblings to the DN at the end\r\n      (remove it from the parent; the DN is now not deficient)\r\n     update the parent's separator to be the first element in the right sibling\r\n       (remove it from the right sibling)\r\n\r\n2) If DN's left sibling has > b/2 (5/2 = 2) values\r\n     (in this case, it won't be deficient after removing one of its keys/value)\r\n     add the parent's separator of these siblings to the DN at the beginning\r\n      (remove it from the parent; the DN is now not deficient)\r\n     update the parent's separator to be the last element in the left sibling\r\n       (remove it from the left sibling)\r\n\r\n3) If DN's left and right siblings are both <= b/2 values (5/2 = 2)\r\n   create a new node with DN's values, the values of one sibling, and the\r\n     separator in the parent of DN and that sibling; the DN is now not deficient\r\n   remove the separator from parent, if the parent is deficient (but not root)\r\n     repeat this rebalancing\r\n\r\n\r\nAnalysis:\r\n\r\nRecall that we are choosing a B-tree of order b. Such a tree, in the best case,\r\nwill have b-1 keys/values at the root; it will have b(b-1) keys/values at depth\r\n1, ... it will have b^d(b-1) at depth d. In the best case, the height\r\nof an N value tree will be about Log(base b) N (with each node filled with\r\nkeys/ values). In the worst case we will have b/2 values at all depths but the\r\nroot, so the height will be at worst about Log(base b/2) N.\r\n\r\nThe idea is to choose b to be as big as possible (the biggest possible base\r\nfor the logarithm) so that as many the keys and subtree pointers as possible\r\nfit into one block of memory that can be easily transferred between main and\r\nexternal memory. Recall that getting/putting information from/to external\r\nmemory takes about the same amount of time no matter how much inforation is\r\ntransferred, so let's transfer a lot each time. We make b so big that it stores\r\nthousand (to millions) of keys and subtree pointers in each memory block. Note\r\nthat for complexity class analysis, all log bases are the equivalent, but we\r\nknow that Log(base 2) N is going to be bigger than Log(base 1,000) N: by a\r\nfactor of about 10. So it would require doing 1/10th the number of block\r\ntransfers.\r\n\r\nFor all the B-tree operations, we must get the block for the root (we might as\r\nwell pre-fetch/cache this permanently in main memory), then get the block for\r\neach subtree node we visit on the path to each x we are searching for,\r\ninserting, or deleting. In the worst case for deletion, we must find the\r\nextremal node in one of the leaves and delete it. Thus, in the worst case we do\r\none access to external memory for each depth in the tree from root to leaf (and\r\nall leaves are at the same depth). In the worst case of insertion/deletion we\r\nmust revisit every node back on the path to the root. So, in the worst case we\r\ndo 2 Log (base b/2) N block transfers between external memory and main memory\r\nand back to external memory.\r\n\r\n(actually it is a bit worse, because in some cases of delete we must look at\r\nsibling nodes; but for every node there are only two siblings, so we look at\r\nmost at a node and its two siblings at each depth; so that would be 3 transfers\r\nto memory and 3 transfers back to extrenal memory for each depth).\r\n\r\nRoughly, for a B-tree of order 4,000, we can store about 2,000 keys and 2,000\r\npointers in each block. In the worst case each block stores half (1,000 keys).\r\nSo the worst height of such a B-tree is 1 (the root can store just one value)\r\n+ Log (base 1,000) N. So if N = 10^15 (a petabyte), the height of the B-tree\r\nstoring all its information is about 1 + 5 = 6. With each 6 transfers for\r\nevery node visited -except the root, which starts and stays in memory- that\r\nis a total of 30 transfers. If each takes .01 seconds, that is .3 seconds\r\nto search/update the B-tree.\r\n\r\nFor example, if we are doing an insert, we must\r\n\r\n  1) transfer each block into main memory going down the tree to a leaf\r\n  2) update the \"leaf\" block with the new value and transfer it back to\r\n       external memory\r\n  3) transfer each \"parent\" block into main memory when going back up the tree\r\n       (when promoting a value from child to parent; we can stop once there is\r\n        no more promotion)\r\n  4) update each \"parent block\" and transfer it back to external memory.\r\n\r\nNote, we are likely able to cache each block that is transfered on the way down,\r\nso step 3 is not necessary, but if we update each \"parent\" block, step 4 is\r\nstill necessary.\r\n\r\nFinally, there are pictures that are available online with this lecture that\r\nillustrates examples that I will do on the board in class, for inserting and\r\nremoving nodes from a B-tree of order 5: so every node (but the root) will\r\nstore between 2-4 values (and 3-5 pointers to subtrees).\r\n", "encoding": "ascii"}