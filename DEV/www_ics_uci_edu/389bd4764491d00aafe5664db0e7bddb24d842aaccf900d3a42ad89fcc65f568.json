{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/ThirdPartyLibraries/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Third-Party Libraries</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Third-Party Libraries</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">When Python's standard library falls short</p>\r\n\r\n<p>We've already seen that Python's standard library is an extensive, varied set of tools that are provided to us automatically (and free!) when we install Python.  If you peruse the table of contents of the <a href=\"https://docs.python.org/3/library/index.html\">Python standard library documentation</a>, particularly starting at chapter 6, you'll see a listing of modules for everything from string handling and searching, dates and calendars, complex data structures, numeric and mathematical tools, operating system and file handling, compression, networking, common Internet protocols, images and sounds, and on and on.  It's an astounding body of work, and it's all available right out of the box; if you have Python, you have all of these tools.</p>\r\n\r\n<p>The goal of a standard library in a programming language is to provide the kinds of functionality that are not inherent in the language, but that nonetheless address common needs that a broad group of users of that language will have.  Some standard libraries are slimmer than others, but even the large ones like Python's or Java's tend to be focused on the things that are common and broadly-applicable.  The narrower the applicability, the less likely you'll find it in a standard library.</p>\r\n\r\n<p>But what you can do with a programming language without writing it yourself isn't limited only to what's in its standard library.  Increasingly, <i>third-party libraries</i> have emerged to fill the gaps, where a library is written to serve a narrower purpose, but is then shared with the community under various terms.  Most of these libraries are <i>open source</i>, which simply means that the libraries' <i>source code</i> (i.e., the code that implements the library) is made available, in addition to \"pre-packaged\" versions of it, which means that you can not only use them, but you can also learn about how they work internally, or even suggest or make changes and fixes that might benefit the whole community of users.</p>\r\n\r\n<p>It should be noted that not all third-party libraries are free, and not even all open-source libraries come without strings attached.  If you're going to use a third-party library in a project of yours, you're going to want to be aware of the terms of its <i>license</i>.  It isn't necessarily the case that the agreement is \"Do what you want with this!\", even when you have access to the source code.  Particularly when you're interested in using it as part of a business, but even when you're not, you'll be well-advised to take a look at what the license terms of your chosen libraries are, before you commit to spending time learning and using them.  For example, some licenses require that any changes that you make to the library must be given back to the community; but if those changes are the \"secret sauce\" for a company you're building, you'll be loathe to give them up, so best not to use the library.  Other licenses don't permit commercial use without payment, which can lead to a thorny situation later if you begin making profitable use of a library in a business.</p>\r\n\r\n<p>For our work in this course, we'll respect license terms, but that will be easier for us, as we're not intending to use our work to create a business; we're mainly interested in experimentation and learning.  One way that open source software has dramatically changed the landscape in the last few decades is by providing a depth and breadth of work that is available for experimentation, free of charge; that's a wonderful environment to learn in.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Installing a third-party library in Python</p>\r\n\r\n<p>When we want to use a third-party library in our work, we'll first need to install it; since it doesn't come with Python, we'll need to find a way to make it available in our Python installation.  Of course, the simplest way to do this is just to obtain a <b>.py</b> file and include it in the same directory as our own code, but this approach has its limitations:</p>\r\n\r\n<ul>\r\n  <li>As programs get larger, it becomes difficult to easily tell the difference between code that's part of your own program and code that's part of a third-party library.  This can have an effect not only on your own understanding of your program, but also on your ability to monitor whether you're compliant with license terms, or to easily figure out which libraries you're using at a glance.</li>\r\n  <li>Some libraries are large and complex enough that they're not just a couple of <b>.py</b> files, so the amount of code that isn't part of your program begins to become overwhelmed by code that isn't &mdash; especially early on.  This is another reason it's better to keep them separate.</li>\r\n  <li>As libraries evolve, features are added and bugs are fixed.  You'll want to be able to benefit from these changes, but managing those changes &mdash; figuring out which files have changed, copying in new versions that don't disturb other parts of your program &mdash; gets harder when your program grows, too.</li>\r\n</ul>\r\n\r\n<p>So we should tend to want our third-party libraries to be more like the ones that are built into Python.  When we want to use the <b>socket</b> library, we don't have to go find a file called <b>socket.py</b> somewhere and copy it into the same directory as our code; instead, we just say <b>import socket</b> and Python is able to find the library for us.</p>\r\n\r\n<p>Third-party libraries can be set up in the same way, so that Python can find them for us in a more automated way.  If we want to use the third-party library <b>pygame</b>, for example, we'd like to just be able to say <b>import pygame</b> and be done with it.  Fortunately, the tools for setting that kind of thing up have improved a lot in recent years, with everything we need built into our Python installation.  The only trick is that we'll need to become familiar with using the <i>command line</i> (such as a Command Prompt on Windows or a Terminal window on a Mac) to make it work, but this is valuable knowledge going forward, anyway, so well worth our time.</p>\r\n\r\n<p class=\"subtitle\">Virtual environments</p>\r\n\r\n<p>The first problem we face is that installing third-party libraries entails a certain amount of risk.  I don't mean that libraries are \"out to get you,\" necessarily, or that something bad will necessarily happen because you installed one.  However, as you install more of them, you may discover that one library is incompatible with another, or that you want to use more than one version of the same library &mdash; an older version in an older project of yours that you don't want to update, but a newer version in a newer one.  For this reason, installing third-party libraries directly into our Python installation is a generally bad idea; it works fine initially, but can spiral out of control in a hurry.</p>\r\n\r\n<p>As an alternative, Python supports the ability to set up <i>virtual environments</i>, which are completely separate, self-contained Python installations that you place into a chosen directory.  Once you <i>activate</i> one of them, you'll be working within that environment instead of your \"global\" Python installation, which means you can work with relative impunity; the worst that can happen is you have to create a new one and start over if something goes wrong.</p>\r\n\r\n<p>Setting up a virtual environment requires a module called <b>venv</b>, which is part of Python's standard library.  It's best done using command-line tools, and how you do it is slightly different on one operating system as opposed to another.  Below are instructions on setting up a virtual environment, along with a third-party library called <b>pygame</b>, for both Windows and Mac OS X.</p>\r\n\r\n<p class=\"subtitle\">Setting up a virtual environment on Windows</p>\r\n\r\n<p>Your first order of business is to launch a Command Prompt window.  The easiest way to do this is to press <b>Win+R</b> (where <b>Win</b> is the \"Windows\" key on your keyboard), which is how you ask Windows to run a program for you.  In the ensuing dialog, type <b>cmd</b> and click <b>OK</b>.  This should pop up a window titled <b>Command Prompt</b>, though this detail can vary a bit from one version of Windows to another.</p>\r\n\r\n<p>What you should see in that window is literally a <i>command prompt</i>, which is to say a prompt at which you can enter commands.  A command prompt is somewhat like the Python shell, except that instead of interacting with Python one expression or statement at a time, you're instead interacting with your operating system one command at a time.  On Windows 10, what I see when I launch a Command Prompt window looks like this; yours may be slightly different.</p>\r\n\r\n<blockquote><pre>\r\nMicrosoft Windows [Version 10.0.17763.316]\r\n(c) 2018 Microsoft Corporation. All rights reserved.\r\n\r\nC:\\Users\\thornton&gt;\r\n</pre></blockquote>\r\n\r\n<p>A cursor will be blinking just after the <b>&gt;</b> character on the last line.  The <b>C:\\Users\\thornton&gt;</b> part is the <i>prompt</i>, the way that <b>&gt;&gt;&gt;</b> is a prompt within the Python shell.  One thing to notice about a command prompt, however, is that it contains a path to a directory &mdash; in this case, I've landed in my \"user\" directory, <b>C:\\Users\\thornton</b>, though this can be configured in other ways if you prefer to begin somewhere else.  That a command prompt includes a directory tells you something important: The commands you execute are executed <i>relative to a directory</i>, which means that what happens when you do certain things depends very much on where you are.</p>\r\n\r\n<p>You can move from one directory to another by using the command <b>cd</b>.  You give <b>cd</b> either an <i>absolute path</i> (which is the complete path to a directory on the same drive) or a <i>relative path</i> (which is the name of a directory you expect to find within the directory you're already in) as a parameter.  Note that parameters are separated by spaces.  (Note, too, that spaces <i>within</i> directory and file names can be problematic, so we're going to be fastidious about avoiding them from here on out.)</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton&gt; <b>cd Desktop</b>\r\n\r\nC:\\Users\\thornton\\Desktop&gt; <b>cd ..</b>\r\n\r\nC:\\Users\\thornton&gt;\r\n</pre></blockquote>\r\n\r\n<p>The directory <b>..</b> is special; it is the <i>parent</i> directory of wherever you are (i.e., the one that contains the directory you're currently in).</p>\r\n\r\n<p>To create our virtual environment, we're going to need a directory to put it in.  Decide where you want that directory to be, then change yourself into the directory that will contain it.  For example, if I wanted it on my desktop, I might next do this.</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton&gt; <b>cd Desktop</b>\r\n\r\nC:\\Users\\thornton\\Desktop&gt; \r\n</pre></blockquote>\r\n\r\n<p>Now, we can create our new directory using the command <b>mkdir</b>, giving it the name of the directory we want to create as a parameter; then, we can change into it.</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton\\Desktop&gt; <b>mkdir 32Example</b>\r\n\r\nC:\\Users\\thornton\\Desktop&gt; <b>cd 32Example</b>\r\n\r\nC:\\Users\\thornton\\Desktop\\32Example&gt;\r\n</pre></blockquote>\r\n\r\n<p>Next, we're ready to create our virtual environment, which we can do <i>from within the directory where we want it stored</i> by executing the following command.  Note that the space and the dot at the end are both important.  The special directory <b>.</b> generally always means \"The directory I'm in now,\" so what I'm really saying here is \"Create me a new virtual environment in the directory where I am now.\"</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton\\Desktop\\32Example&gt; <b>python -m venv .</b>\r\n</pre></blockquote>\r\n\r\n<p>It may take a little while to set this up; don't worry if it takes a minute or two.  (If you see an error message saying something like <b>'python' is not recognized as an internal or external command</b>, then this means you don't have Python set up to run from the command line properly.  See the <a href=\"../../ProjectGuide/Project0/InstallWindows.html\">Python installation instructions for Windows from Project #0</a>, and pay particular attention to Step 3, which explains how to set that up.)</p>\r\n\r\n<p>Once it's done, let's take a look at what we ended up with.  We can do that using the command <b>dir</b>, which means to show us what's in the current directory.</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton\\Desktop\\32AExample&gt; <b>dir</b>\r\n Volume in drive C is Win10\r\n Volume Serial Number is ABCD-1234\r\n\r\n Directory of C:\\Users\\thornton\\Desktop\\32Example\r\n\r\n11/21/2018  11:09 PM    &lt;DIR&gt;          .\r\n11/21/2018  11:09 PM    &lt;DIR&gt;          ..\r\n11/21/2018  11:09 PM    &lt;DIR&gt;          Include\r\n11/21/2018  11:09 PM    &lt;DIR&gt;          Lib\r\n11/21/2018  11:09 PM                75 pyvenv.cfg\r\n11/21/2018  11:09 PM    &lt;DIR&gt;          Scripts\r\n               1 File(s)             75 bytes\r\n               5 Dir(s)  318,214,103,040 bytes free\r\n</pre></blockquote>\r\n\r\n<p>So what do we see here?</p>\r\n\r\n<ul>\r\n  <li>The special directories <b>.</b> and <b>..</b> are listed, though they mean what we discussed already: <b>.</b> is where we are now, while <b>..</b> is the parent of where we are now.</li>\r\n  <li>Additionally, there are three directories, called <b>Include</b>, <b>Lib</b>, and <b>Scripts</b>.</li>\r\n  <li>Finally, there is one file called <b>pyvenv.cfg</b>, which contains some information about how the virtual environment was set up.  It's unlikely you'll need to do anything with this, but you will want to leave it there.</p>\r\n</ul>\r\n\r\n<p>Let's make an additional directory for our own source code, which we'll call <b>src</b>.  We won't use it right off, but we'll want it available to us a little later.</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton\\Desktop\\32Example&gt; <b>mkdir src</b>\r\n\r\nC:\\Users\\thornton\\Desktop\\32Example&gt;\r\n</pre></blockquote>\r\n\r\n<p>The <b>Scripts</b> directory turns out to be an important one, because it contains a script called <b>activate</b> that lets us \"turn on\" our virtual environment.  Until we've done that, the things we do will have an effect on our \"global\" Python installation, rather than the virtual environment that we've just created.</p>\r\n\r\n<blockquote><pre>\r\nC:\\Users\\thornton\\Desktop\\32Example&gt; <b>cd Scripts</b>\r\n\r\nC:\\Users\\thornton\\Desktop\\32Example\\Scripts&gt; <b>activate</b>\r\n\r\n(32Example) C:\\Users\\thornton\\Desktop\\32Example\\Scripts&gt; \r\n</pre></blockquote>\r\n\r\n<p>Notice that our prompt changed after running the <b>activate</b> script.  In addition to showing us the path to a directory, it's also showing us the name of our virtual environment; this is a handy way of helping us to remember that we've activated our virtual environment.</p>\r\n\r\n<p>Next, let's install a third-party library called <b>pygame</b>, which we can do using a tool built into Python called <b>pip</b>.  (Once we've activated our virtual environment, anything we install using <b>pip</b> will be installed into our virtual environment, rather than our global Python installation.)  What <b>pip</b> does, in short, is download a library from a community-run server on the Internet and then installs it for us.  There are all kinds of details that aren't especially important here, but when what you want is simple, it's easy to get.</p>\r\n\r\n<blockquote><pre>\r\n(32Example) C:\\Users\\thornton\\Desktop\\32Example\\Scripts&gt; <b>pip install pygame</b>\r\n\r\nCollecting pygame\r\n  Using cached pygame-1.9.4-cp37-cp37m-win_amd64.whl\r\nInstalling collected packages: pygame\r\nSuccessfully installed pygame-1.9.4\r\n</pre></blockquote>\r\n\r\n<p>Specifically what you'll see may vary a bit, but the general idea is that you'll be apprised of the installation progress.  (In my case, installation was a snap because I had downloaded this once already; you may see it being downloaded, in addition to the installation.)  The <b>1.9.4</b> that you see in a couple of places is a version number, which is the latest version, as of this writing; the <b>win_amd64</b> says that I've been given the 64-bit version of Python on Windows, which is the right one for my situation.  (Note, too, that all of this was automatic; I got the latest version that was appropriate for my installation of Python.)</p>\r\n\r\n<p>Finally, we can launch IDLE and start interacting with <b>pygame</b>.  However, we have to launch IDLE from <i>within our virtual environment</i>.  We'll also want all of our own modules to be loaded from our <b>src</b> directory (and to be saved there, too), so we'll change there and then launch IDLE from the command prompt manually.</p>\r\n\r\n<blockquote><pre>\r\n(32Example) C:\\Users\\thornton\\Desktop\\32Example\\Scripts&gt; <b>cd ..</b>\r\n\r\n(32Example) C:\\Users\\thornton\\Desktop\\32Example&gt; <b>cd src</b>\r\n\r\n(32Example) C:\\Users\\thornton\\Desktop\\32Example\\src&gt; <b>python -m idlelib</b>\r\n</pre></blockquote>\r\n\r\n<p>The module <b>idlelib</b> in Python's standard library is what it sounds like; it's IDLE.  What we're doing is saying \"run IDLE\"; it's really that simple.  An IDLE window should pop up, in which case we can make sure our installation is complete by attempting to import <b>pygame</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>import pygame</b>\r\n</pre></blockquote>\r\n\r\n<p>Assuming that this succeeded, you're in business.  You've got a virtual environment with <b>pygame</b> installed.  Next time you want to launch IDLE within your virtual environment from scratch, you can follow these steps:</p>\r\n\r\n<ul>\r\n  <li>Launch a Command prompt</li>\r\n  <li>Change into the directory containing your virtual environment</li>\r\n  <li>Change into the <b>Scripts</b> directory within that</li>\r\n  <li>Run the <b>activate</b> command</li>\r\n  <li>Change into the <b>src</b> directory in your virtual environment</li>\r\n  <li>Run the <b>python -m idlelib</b> command</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Setting up a virtual environment on Mac OS X</p>\r\n\r\n<p>Your first order of business is to launch a Terminal window.  Precisely how you do this is a little different from one version of Mac OS X to another, though the simplest way is to use the operating system's search feature and look for the program called <b>Terminal</b>.  (There are a variety of other techniques and shortcuts you can use; feel free to explore what else is available.)</p>\r\n\r\n<p>What you should see in that window is a <i>command prompt</i>, which is a line of text usually ending in <b>$</b>, but preceded by some other information.  For example, you might see something like this:</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~$ \r\n</pre></blockquote>\r\n\r\n<p>In this case, <b>AlexThornton-Mac</b> might be the name you've given to your computer previously.  After the <b>:</b> character might be a <b>~</b> character, which is actually a path to a directory; on Mac OS X, the path <b>~</b> is a shorthand for your home directory.  The <b>$</b> is the end of the prompt.  In general, a command prompt is somewhat like the Python shell, except that instead of interacting with Python one expression or statement at a time, you're instead interacting with your operating system one command at a time.</p>\r\n\r\n<p>A cursor will be blinking just after the <b>$</b> character.  One thing to notice right away is that your command prompt contains the path to a directory.  That's telling you something important: The commands you execute are executed <i>relative to a directory</i>, which means that what happens when you do certain things depends very much on where you are.  You're likely to have started in your home directory, which is why you may see a <b>~</b> here, but if you're curious where your home directory really is, you can use the command <b>pwd</b> to print the \"working directory\" (which means the directory where you currently are).</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~$ <b>pwd</b>\r\n/home/thornton\r\nAlexThornton-Mac:~$\r\n</pre></blockquote>\r\n\r\n<p>You can move from one directory to another by using the command <b>cd</b>.  You give <b>cd</b> either an <i>absolute path</i> (which is the complete path to a directory on the same drive) or a <i>relative path</i> (which is the name of a directory you expect to find within the directory you're already in) as a parameter.  Note that parameters are separated by spaces.  (Note, too, that spaces <i>within</i> directory and file names can be problematic, so we're going to be fastidious about avoiding them from here on out.)</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~$ <b>cd Desktop</b>\r\nAlexThornton-Mac:~/Desktop$ <b>pwd</b>\r\nAlexThornton-Mac:~$ <b>cd ..</b>\r\nAlexThornton-Mac:~$\r\n</pre></blockquote>\r\n\r\n<p>The directory <b>..</b> is special; it is the <i>parent</i> directory of wherever you are (i.e., the one that contains the directory you're currently in).</p>\r\n\r\n<p>To create our virtual environment, we're going to need a directory to put it in.  Decide where you want that directory to be, then change yourself into the directory that will contain it.  For example, if I wanted it on my desktop, I might next do this.</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~$ <b>cd Desktop</b>\r\nAlexThornton-Mac:~/Desktop$\r\n</pre></blockquote>\r\n\r\n<p>Now, we can create our new directory using the command <b>mkdir</b>, giving it the name of the directory we want to create as a parameter; then, we can change into it.</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~/Desktop$ <b>mkdir 32Example</b>\r\nAlexThornton-Mac:~/Desktop$ <b>cd 32Example</b>\r\nAlexThornton-Mac:~/Desktop/32Example$\r\n</pre></blockquote>\r\n\r\n<p>Next, we're ready to create our virtual environment, which we can do <i>from within the directory where we want it stored</i> by executing the following command.  Note that the space and the dot at the end are both important.  The special directory <b>.</b> generally always means \"The directory I'm in now,\" so what I'm really saying here is \"Create me a new virtual environment in the directory where I am now.\"</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~/Desktop/32Example$ <b>python3.7 -m venv .</b>\r\n</pre></blockquote>\r\n\r\n<p>It may take a little while to set this up; don't worry if it takes a minute or two.  (If you see an error message saying something like <b>'python3.7': command not found</b>, then this means you don't have Python set up to run from the command line properly.  See the <a href=\"../../ProjectGuide/Project0/InstallMac.html\">Python installation instructions for Mac OS X from Project #0</a>, and pay particular attention to Step 3, which explains how to set that up.)</p>\r\n\r\n<p>Once it's done, let's take a look at what we ended up with.  We can do that using the command <b>ls</b>, which means to show us a \"list\" of what's in the current directory.</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~/Desktop/32Example$ <b>ls</b>\r\nbin     include     lib    pyenv.cfg\r\nAlexThornton-Mac:~/Desktop/32Example$\r\n</pre></blockquote>\r\n\r\n<p>So what do we see here?</p>\r\n\r\n<ul>\r\n  <li>There are three directories, called <b>bin</b>, <b>include</b>, and <b>lib</b>.  (It may not be immediately evident that they're directories, though you can use the command <b>ls -F</b> to see directories shown with slashes at the end of their names, if you prefer.)</li>\r\n  <li>Also, there is one file called <b>pyvenv.cfg</b>, which contains some information about how the virtual environment was set up.  It's unlikely you'll need to do anything with this, but you will want to leave it there.</p>\r\n</ul>\r\n\r\n<p>Let's make an additional directory for our own source code, which we'll call <b>src</b>.  We won't use it right off, but we'll want it available to us a little later.</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~/Desktop/32Example$ <b>mkdir src</b>\r\nAlexThornton-Mac:~/Desktop/32Example$\r\n</pre></blockquote>\r\n\r\n<p>The <b>bin</b> directory turns out to be an important one, because it contains a script called <b>activate</b> that lets us \"turn on\" our virtual environment.  Until we've done that, the things we do will have an effect on our \"global\" Python installation, rather than the virtual environment that we've just created.</p>\r\n\r\n<blockquote><pre>\r\nAlexThornton-Mac:~/Desktop/32Example$ <b>cd bin</b>\r\nAlexThornton-Mac:~/Desktop/32Example/bin$ <b>source activate</b>\r\n(32AExample) AlexThornton-Mac:~/Desktop/32Example/bin$\r\n</pre></blockquote>\r\n\r\n<p>(Note that the <b>source activate</b> command won't work if you've set up a different Terminal shell than the one that is default on Mac OS X (which is called <b>bash</b>).  If, for example, you're using <b>tcsh</b> as your shell, you would need to say <b>source activate.csh</b> instead.  If you're not sure what Terminal shell you're running, the command <b>echo $SHELL</b> will likely tell you.)</p>\r\n\r\n<p>After we ran the <b>activate</b> script, our prompt changed.  In addition to showing us the path to a directory, it's also showing us the name of our virtual environment; this is a handy way of helping us to remember that we've activated our virtual environment.</p>\r\n\r\n<p>Next, let's install a third-party library called <b>pygame</b>, which we can do using a tool built into Python called <b>pip</b>.  (Once we've activated our virtual environment, anything we install using <b>pip</b> will be installed into our virtual environment, rather than our global Python installation.)  What <b>pip</b> does, in short, is download a library from a community-run server on the Internet and then installs it for us.  There are all kinds of details that aren't especially important here, but when what you want is simple, it's easy to get.</p>\r\n\r\n<blockquote><pre>\r\n(32Example) AlexThornton-Mac:~/Desktop/32Example/bin$ <b>pip install pygame</b>\r\n\r\nCollecting pygame\r\n  Using cached pygame-1.9.4-cp37-cp37m-macosx_10_9_intel.whl.whl\r\nInstalling collected packages: pygame\r\nSuccessfully installed pygame-1.9.4\r\n</pre></blockquote>\r\n\r\n<p>Specifically what you'll see may vary a bit, but the general idea is that you'll be apprised of the installation progress.  (In my case, installation was a snap because I had downloaded this once already; you may see it being downloaded, in addition to the installation.)  The <b>1.9.4</b> that you see in a couple of places is a version number, which is the latest version, as of this writing; the <b>macosx_10_9_intel</b> says that I've been given the appropriate version for Python running Mac OS X 10.9, which is the right one for my situation.  (Note, too, that all of this was automatic; I got the latest version that was appropriate for my installation of Python.)</p>\r\n\r\n<p>Finally, we can launch IDLE and start interacting with <b>pygame</b>.  However, we have to launch IDLE from <i>within our virtual environment</i>.  We'll also want all of our own modules to be loaded from our <b>src</b> directory (and to be saved there, too), so we'll change there and then launch IDLE from the command prompt manually.</p>\r\n\r\n<blockquote><pre>\r\n(32Example) AlexThornton-Mac:~/Desktop/32AExample/bin$ <b>cd ..</b>\r\n\r\n(32Example) AlexThornton-Mac:~/Desktop/32AExample$ <b>cd src</b>\r\n\r\n(32Example) AlexThornton-Mac:~/Desktop/32AExample/src$ <b>python3.7 -m idlelib</b>\r\n</pre></blockquote>\r\n\r\n<p>The module <b>idlelib</b> in Python's standard library is what it sounds like; it's IDLE.  What we're doing is saying \"run IDLE\"; it's really that simple.  An IDLE window should pop up, in which case we can make sure our installation is complete by attempting to import <b>pygame</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>import pygame</b>\r\n</pre></blockquote>\r\n\r\n<p>Assuming that this succeeded, you're in business.  You've got a virtual environment with <b>pygame</b> installed.  Next time you want to launch IDLE within your virtual environment from scratch, you can follow these steps:</p>\r\n\r\n<ul>\r\n  <li>Launch a Terminal window</li>\r\n  <li>Change into the directory containing your virtual environment</li>\r\n  <li>Change into the <b>bin</b> directory within that</li>\r\n  <li>Run the <b>source activate</b> command (or an appropriate alternative, if you're not using the default Terminal shell)</li>\r\n  <li>Change into the <b>src</b> directory in your virtual environment</li>\r\n  <li>Run the <b>python3.7 -m idlelib</b> command</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}