{"url": "https://www.ics.uci.edu/~dan/class/165/notes/splay.html", "content": "<HTML>\n<HEAD><TITLE> AVL and Splay Trees </TITLE></HEAD>\n<BODY>\n\n<H2>Dynamic Binary Search Trees</H2>\n\n<H3>Rotations</H3>\n\nRotating right or left in a binary search tree is illustrated below.\nNote that the tree maintains its characteristics as a binary search tree.\n<pre>\n\n     y       rotate (xy) R        x\n    / \\            ====>         / \\\n   x   3                        1   y\n  / \\        rotate (xy) L         / \\\n 1   2             <====          2   3\n\n\n            DOUBLE ROTATE (xyz) L\n    x        1. rotate (yz) R   \n     \\       2. rotate (xz) L       z\n      y          =======>          / \\\n     /                            x   y\n    z       DOUBLE ROTATE (xzy) R\n             1. rotate (xz) R        \n             2. rotate (yz) L   \n                 <=======\n</pre>\n\n<H3>AVL Trees (height-balanced trees) </H3>\n\nAn AVL (Adelson-Velskii, Landis) tree is a binary search tree\nin which the heights of the right and left subtrees of each node\ndiffer by at most 1.\n<P>\nThe height of a leaf (no children) is defined to be 0.&nbsp;\nThe height of an empty tree (no nodes) is defined to be -1.\n<P>\nIt can be shown by induction that the height, <I>H</I>, of an AVL tree with <I>n</I> nodes\nsatisfies &nbsp;lg(<I>n</I>+1)-1 <U>&lt;</U> <I>H</I> <U>&lt;</U> 1.44&nbsp;lg(<I>n</I>+2)-1.\n<P>\nThe <I>balance factor</I> of a node is defined to be\nHeight(RightSubtree) - Height(LeftSubtree).&nbsp;\nThus, in an AVL tree, the balance factor of each node will be\nin {-1,&nbsp;0,&nbsp;+1}.\n<P>\nInsertion into an AVL tree may change change the balance factors of\nsome nodes on the path from the inserted node to the root.&nbsp;\nAny balance factor will change by at most 1 and the resulting\nvalue might become illegal (i.e., -2 or +2).&nbsp;\nAfter determining the deepest node that is \"illegal\",\none single or one double rotation suffices to fix up the entire tree.&nbsp;\n<a href=\"avl.html\">Details</a>.\n<P>\nDeletion from an AVL tree is handled similarly,\nbut <I>O</I>(lg&nbsp;<I>n</I>) rotations may be required.\n\n<H3>Weight-balanced Trees</H3>\n\nInstead of height, weight (number of nodes) is balanced.&nbsp;\nBalance can be maintained using rotations in a similar manner.\n\n<H3>Splay Trees</H3>\n\nA splay tree is a binary search tree with no explicit balance condition,\nin which a special operation called a <I>splay</I> is done after each\nsearch or insertion operation.&nbsp;  Splaying at node <I>x</I> causes\nnode <I>x</I> to become the root of the binary search tree through\na specific series of <I>rotations</I> as follows.\n<P>\nThree cases:\n<P>\n<OL>\n<LI> <I>x</I> has no grandparent (<I>zig</I>)\n   <UL>\n   <LI> If <I>x</I> is left child of root <I>y</I>, then rotate (<I>xy</I>)R.\n   <LI> Else if <I>x</I> is right child of root <I>y</I>, then rotate (<I>yx</I>)L.\n   </UL>\n   <P>\n<LI> <I>x</I> is LL or RR grandchild (<I>zig-zig</I>)\n   <UL>\n   <LI> If <I>x</I> is left child of <I>y</I>, and <I>y</I> is left child of <I>z</I>,\n   <BR> then rotate at grandfather (<I>yz</I>)R and then rotate at father (<I>xy</I>)R.\n   <LI> Else if <I>x</I> is right child of <I>y</I>, and <I>y</I> is right child of <I>z</I>,\n   <BR> then rotate at grandfather (<I>yz</I>)L and then rotate at father (<I>xy</I>)L.\n   </UL>\n   If <I>x</I> has not become the root, then continue splaying at <I>x</I>.\n   <P>\n<LI> <I>x</I> is LR or RL grandchild (<I>zig-zag</I>)\n   <UL>\n   <LI> If <I>x</I> is right child of <I>y</I>, and <I>y</I> is left child of <I>z</I>,\n   <BR> then rotate at father (<I>yx</I>)L and then rotate at grandfather (<I>xz</I>)R.\n   <LI> Else if <I>x</I> is left child of <I>y</I>, and <I>y</I> is right child of <I>z</I>,\n   <BR> then rotate at father (<I>yx</I>)R and then rotate at grandfather (<I>xz</I>)L.\n   </UL>\n   If <I>x</I> has not become the root, then continue splaying at <I>x</I>.\n</OL>\n\n<HR>\n</BODY></HTML>\n", "encoding": "ascii"}