{"url": "https://www.ics.uci.edu/~irani/s11_22/Project5/Project5.html", "content": " <html>\r\n    <head>\r\n      <title>ICS 22/CSE 22 - Project #5: Signal to Noise</title>\r\n      <LINK href=\"../../style.css\" rel=\"StyleSheet\" type=\"text/css\">\r\n    </head>\r\n  <body bgcolor=\"DCFBFB\" text=\"5C4033\" >\r\n\r\n\r\n  <div id=\"content\">\r\n    <h1>Project #5: <i>Signal to Noise</i></h1>\r\n    <p class=\"center\"><b>Due date and time:</b> <i>Friday, May 27, 6:59pm</font></i></p>\r\n    <p class=\"center\"><i>This project is to be completed individually</i></p>\r\n\r\n    <h1>Introduction</h1>\r\n\r\n    <p>The ability to generate random data that conforms to a particular\r\n    format can be handy.  It's not uncommon for us to want to test our\r\n    programs with a large amount of data, so that we can find bugs and\r\n    inefficiencies, especially those that arise from dealing with large\r\n    data sets; this kind of testing is often called <i>stress testing</i>.\r\n    Generating large amounts of random data is a tedious task for people,\r\n    but a task that we can certainly imagine that a computer would be good at.\r\n    It's not hard to see that a program that's\r\n    capable of generating data in a given format would be very useful\r\n    in these kinds of circumstances.</p>\r\n\r\n    <p>For this project, you will write a program that randomly generates\r\n    data in a form described by a <i>grammar</i>.  (Grammars, in addition\r\n    to being a nice way to model this problem, are recurrent in the study\r\n    of computer science; you're likely to see them again in your\r\n    studies &mdash; more than once.)  You will also gain practice\r\n    implementing a recursive algorithm in Java, a vital skill that\r\n    you will find to be useful in many ways as you continue your study of computing.</p>\r\n\r\n    <h1>Grammars</h1>\r\n\r\n    <p>A <i>grammar</i> is a collection of substitution rules that describe a set of <i>sentences</i>.  Each sentence is a sequence of <i>terminals</i>.  Different kinds of sentence fragments are represented by <i>variables</i>, with a <i>rule</i> for each variable specifying how it can be replaced by one of a set of possible sequences of variables and terminals.  One of the variables is designated as the <i>start variable</i>, which means that it represents an entire sentence.</p>\r\n\r\n    <p>An example of a grammar follows.  The start variable is <i>A</i>.  The variables are <i>A</i> and <i>B</i>, while the terminals are 0, 1, and #.</p>\r\n\r\n    <ul class=\"nomarker\">\r\n    <li><i>A</i> &rarr; 0<i>A</i>1<i>A</i> | <i>B</i></li>\r\n    <li><i>B</i> &rarr; #</li>\r\n    </ul>\r\n\r\n    <p>This grammar states that the variable <i>A</i> can be replaced either with the sequence 0<i>A</i>1<i>A</i> or the variable <i>B</i>, while the variable <i>B</i> can only be replaced with #.</p>\r\n\r\n    <p>From a conceptual point of view, a grammar can be used to generate strings of terminals in the following manner.  (I should point out that this isn't precisely how your program will generate its strings, but your program will do something that has an equivalent effect.)</p>\r\n\r\n    <ol>\r\n    <li>Begin with the start variable.</li>\r\n    <li>So long as there are still variables that have not been substituted, pick a variable and a rule with that variable on the left-hand side.  Replace the variable with the right-hand side of the rule that you chose.</li>\r\n    </ol>\r\n\r\n    <p>A sequence of substitutions leading from the start variable to a string of terminals is called a <i>derivation</i>.  When the leftmost variable is always replaced at each step, the derivation is called a <i>leftmost derivation</i>.  The string 00#1#1# can be generated by the grammar above.  The following leftmost derivation &mdash; which begins with the start variable, with one substitution made at each step &mdash; proves that it can be done.</p>\r\n\r\n    <p><i>A</i> &rArr; 0<i>A</i>1<i>A</i> &rArr; 00<i>A</i>1<i>A</i>1<i>A</i> &rArr; 00<i>B</i>1<i>A</i>1<i>A</i> &rArr; 00#1<i>A</i>1<i>A</i> &rArr; 00#1<i>B</i>1<i>A</i> &rArr; 00#1#1<i>A</i> &rArr; 00#1#1<i>B</i> &rArr; 00#1#1#</p>\r\n\r\n    <p>Since 00#1#1# can be generated by the grammar, we would say that the string 00#1#1# is in the <i>language</i> of the grammar.  In other words, the language of a grammar is the set of all strings that can be generated from it.  (Many grammars, including this one, have an infinite number of strings in their languages.  This grammar generates an infinite number of strings since the rule <i>A</i> &rarr; 0<i>A</i>1<i>A</i> can be used an arbitrary number of times in a derivation.)</p>\r\n\r\n    <p>The concept of a grammar will be central to our random sentence generator.  A grammar will describe a set of sentences (which may indeed be infinite).  Each sentence you generate will be a sequence of words, with the words being the terminals in the grammar.  The variables in the grammar will describe sentence fragments, with the start variable describing an entire sentence.</p>\r\n\r\n    <h1>The program</h1>\r\n\r\n    <p>You will write a Java program that takes a <i>grammar file</i> as input and writes a specified number of randomly-generated sentences, one per line, into an output file.  The name of the input file, the number of sentences, the name of the start variable, and the name of the output file should be passed as command-line arguments to the program.  Your main( ) method should be placed into a class called <b>Generator</b>, so we will easily be able to figure out how to run it.  An example of how your program could be executed from the command line is:</p>\r\n\r\n    <pre>\r\n    java Generator grammar.grm 10 start sentences.out\r\n    </pre>\r\n\r\n    <p>This command specifies that the grammar file is a file called <b>grammar.grm</b>.  Ten sentences should be generated using the start variable <b>start</b> and written into an output file called <b>sentences.out</b>.  Your program is required to take these four command-line arguments in this order (though, of course, their values might be different).  If more or fewer than four command-line arguments are provided to your program, it should print an error message and terminate.</p>\r\n\r\n    <h1>The format of the grammar file</h1>\r\n\r\n    <p>One of the inputs to your program will be a grammar file containing one or more rules of the following form.</p>\r\n\r\n    <ul>\r\n    <li>Each rule starts with a left curly brace (\"{\") on its own line and ends with a right curly brace (\"}\") on its own line.</li>\r\n    <li>After the opening brace, the first line of the rule is its left-hand side.  Remember that the left-hand side of a rule is a variable.  Its name is delimited by brackets (\"[\" and \"]\"), which you should drop before storing the variable's name in memory.  (The substring( ) method in the String class will be handy here.)</li>\r\n\r\n    <li>Subsequent lines of the rule are alternative right-hand sides (i.e., different ways of rewriting the left-hand side).  Each right-hand side consists of a sequence of variables (whose names are enclosed in brackets) and terminals  in any combination, separated by whitespace.  The sequence ends with a semicolon, which will always be preceded by at least one space.</li>\r\n    <li>There may be lines of text outside the braces.  These lines are intended to be comments in the grammar and should be ignored by your program.</li>\r\n    </ul>\r\n\r\n    <p>You may assume that grammar files will always be in precisely this form.  You are not required to check for errors in the grammar file.</p>\r\n\r\n    <p>Here is an <a href=\"facile.grm\">example grammar file</a> that generates random Facile programs.  Since our program generates sentences that each appear on one line, the word <b>NL</b> is used in place of the newline character that separates lines in a Facile program; you can use find-and-replace in a text editor to solve this program and make it possible to execute the generated Facile programs using your interpreter from <a href=\"../Project3/Project3.html\">Project #3</a>.  (The generated programs will not have syntax errors in them, but they may have run-time errors or other problems, such as infinite loops or division by zero.)</p>\r\n\r\n    <p>Do not make assumptions about variable names because of what you see in the example grammar file.  You may assume that the names of variables will never have spaces or tabs in them, but you otherwise may not make assumptions about what the names of the variables will be, how many rules there will be, how many right-hand sides each rule will have, and so on.  In general, any grammar file that meets the requirements above should be parsed successfully by your program.</p>\r\n\r\n    <h1>Storing the grammar as a set of objects</h1>\r\n\r\n    <p>From the description of the grammar file, we can come to the following conclusions:</p>\r\n\r\n    <ul>\r\n\r\n    <li>The grammar file contains a collection of rules.</li>\r\n    <li>Each of the rules has a variable and a collection of right-hand sides.</li>\r\n    <li>A right-hand side is a sequence of terminals and variables.</li>\r\n    </ul>\r\n\r\n    <p>These facts lead directly to an idea of how to design the set of objects that will be used to store a grammar in memory.  I imagine the following classes comprising your design of a grammar.</p>\r\n\r\n    <ul>\r\n    <li><b>Terminal</b>.  Contains only the word that makes up one terminal.</li>\r\n\r\n    <li><b>Variable</b>.  Contains only the name of the variable.</li>\r\n    <li><b>RightHandSide</b>.  Contains a sequence of Terminals and Variables.  \"Sequence\" implies that the order is important, so I suggest using an ArrayList to store them.  (Since you'll want a sequence that can contain Terminals or Variables, but not other kinds of objects, it might make sense for Terminal and Variable to implement an interface called <b>Symbol</b>, which won't need methods, but will \"mark\" Terminal and Variable as being similar, for the purposes of grouping them together into an ArrayList&lt;Symbol&gt;.  If Terminal and Variable each implement Symbol, but nothing else does, an ArrayList&lt;Symbol&gt; will be able to contain Terminals or Variables, but nothing else.)</li>\r\n    <li><b>Rule</b>.  Contains the name of a variable and a set of RightHandSides.  Since you'll need to select a RightHandSide randomly by generating a random number, it makes sense to store these RightHandSides in an ArrayList, though the order of them turns out to be irrelevant.</li>\r\n\r\n    <li><b>Grammar</b>.  Contains the name of the start variable and a collection of Rules.  You will often need to search this collection, looking for the Rule for a particular variable.  You may use a flat data structure, such as an ArrayList or a linked list, to store the Rules, then do a linear search if you'd like.  However, there are some better approaches you could employ, which are discussed in the \"Additional challenges\" section later in the write-up.  (You'll learn more about these better approaches in ICS 23 / CSE 23.)</li>\r\n    </ul>\r\n\r\n    <p>I'd like you to use this, or a similar, object-oriented approach for storing the grammar in memory, as it will lead to a clean, recursive algorithm for generating sentences.  This algorithm is described in the next section.</p>\r\n\r\n    <h1>Generating random sentences from a grammar</h1>\r\n\r\n    <p>Once you've stored your grammar as the set of objects described in the previous section, it is possible to implement a relatively straightforward recursive algorithm to generate random sentences from it.  The algorithm revolves around the idea of generating sentence fragments, then putting the fragments together into a complete sentence.</p>\r\n\r\n    <p>The first step in the implementation is to establish the fact that all of the objects that make up a grammar &mdash; Grammars, Rules, RightHandSides, Variables, and Terminals &mdash; can have sentence fragments (or complete sentences) generated from them.  This concept can be wrapped up in an interface called <b>Generable</b>, which might look something like this:</p>\r\n\r\n    <pre>\r\n    public interface Generable\r\n    {\r\n    public String generate(Grammar g, Random r);\r\n    }\r\n    </pre>\r\n\r\n    <p>Grammar, Rule, RightHandSide, Variable, and Terminal should all implement this interface, though, of course, the actual implementation of the generate( ) method will differ from one class to another.  It's necessary for generate( ) to take a Grammar as a parameter, because, during the process of generating a sentence, it's sometimes necessary to look up the rule in the grammar that corresponds to a particular variable.</p>\r\n\r\n    <p>Here is a sketch of the sentence generation algorithm:</p>\r\n\r\n    <ul>\r\n    <li>To generate a sentence from a Grammar, call the generate( ) method on the Grammar object.  The Grammar object will then look up the Rule corresponding to the start variable and call generate( ) on it, passing itself (this) as a parameter.</li>\r\n    <li>The generate( ) method for Rule chooses one of the RightHandSides at random, using the Random object passed to it as a parameter, and calls generate( ) on it.</li>\r\n    <li>The generate( ) method for RightHandSide iterates through its terminals and variables from left to right, calling generate( ) on each, then putting the results together into a sentence fragment.</li>\r\n\r\n    <li>The generate( ) method for a Variable asks the Grammar for the Rule corresponding to that Variable, then calls generate( ) on it, returning the result as a sentence fragment.</li>\r\n    <li>The generate( ) method for a Terminal simply returns the value of the terminal as a sentence fragment.</li>\r\n    </ul>\r\n\r\n    <p>The amazing thing about this recursive strategy is that, with relatively little code, you'll be able to ask a grammar to generate its own random sentences.</p>\r\n\r\n    <h2>A caveat about your Symbol interface</h2>\r\n\r\n    <p>The Symbol interface, which should be implemented by both Terminal and Variable as a way to \"mark\" that both Terminals and Variables are symbols, should also specify that all symbols are generable; in other words, it should be possible to generate a sentence fragment from any kind of symbol, be it a terminal or a variable.</p>\r\n\r\n    <p>To do this requires one additional piece of syntax that we haven't learned.  It's possible for one interface to extend another.  In general, if an interface <i>J</i> extends the interface <i>I</i>, <i>J</i> contains all of the methods of <i>I</i> plus the methods that are listed in <i>J</i>.  In our case, the Symbol interface does not introduce any new methods, but it should include the generate( ) method from the Generable interface.  We write this in Java as follows:</p>\r\n\r\n    <pre>\r\n\r\n    public interface Symbol extends Generable\r\n    {\r\n    }\r\n    </pre>\r\n\r\n    <p>Because you'll be implementing the Symbol interface in Variable and Terminal, both Variable and Terminal will be required to have a generate( ) method; it will not be necessary for you to explicitly state that Variable or Terminal implements Generable, because that's implied by the fact that they implement Symbol.</p>\r\n\r\n    <h1>Random number generation</h1>\r\n    <h2>How does random number generation work?</h2>\r\n\r\n    <p>Since the program must generate sentences randomly, it is necessary for us to briefly discuss how random number generators work.  Computers cannot generate sequences of genuinely random numbers.  Instead, they generate sequence of numbers that satisfy statistical tests of randomness; these numbers are often called <i>pseudo-random numbers</i>.  Provided that the algorithm used to generate the sequence is well-chosen, there is little practical difference between random numbers and pseudo-random ones.</p>\r\n\r\n    <p>A <i>random number generator</i> is an object that generates a sequence of pseudo-random numbers.  Here's how it works:</p>\r\n\r\n    <ul>\r\n    <li>Each number in the sequence is determined by evaluating a mathematical function on the previous number in the sequence.  So, each time you say \"Give me the next pseudo-random number,\" a calculation is performed on the one you got back last time, with the result returned to you and a copy of it stored so it can be used later to determine the next number in the sequence.</li>\r\n    <li>In order to start the process, some number needs to be picked that will be used to calculate the opening number in the sequence.  This number is called the <i>seed</i>.</li>\r\n\r\n    </ul>\r\n\r\n    <p>The selection of a seed is important.  The same mathematical function is applied every time you ask for a random number.  If you always picked the same number as the seed, you'd always get the same sequence of pseudo-random numbers.  (This is handy when testing some programs that behave randomly, but it's not so good when you want truly random behavior.)  So a randomly-selected seed is also necessary.  Of course, computers cannot select numbers at random, but a common way to supply a \"randomly-selected\" seed is to take the current value in the system's clock and use it as the seed.  (This isn't truly random, but will be essentially impossible to control precisely, since the system clock is kept in terms of milliseconds.)</p>\r\n\r\n    <p>In Java, the <b>Random</b> class in the <b>java.util</b> package provides an easy-to-use random number generator that you can use in your program.  First, you need to create a Random object, which represents a sequence of pseudo-random numbers.  When you construct the object, it initializes the seed using the system clock.  Once you've created the Random object, you can ask it for the next pseudo-random number by calling methods such as nextInt( ), nextLong( ), nextBoolean( ), nextDouble( ), and so on.  An example of using the nextInt( ) method follows.</p>\r\n\r\n    <pre>\r\n    Random r = new Random();   // this should only be done once, with the\r\n    // resulting Random object being reused throughout\r\n    // the execution of the program\r\n    // ...\r\n\r\n    int i = r.nextInt(100);    // nextInt(100) returns a pseudo-random number in\r\n    // the range 0..99 inclusive\r\n    </pre>\r\n\r\n    <p>One important thing to remember about random number generation as you work on this project: a single Random object represents, in essence, a sequence of random numbers.  It's important to create one Random object and use it throughout the program's execution.  A good technique for solving this problem is to create your Random object outside of your Grammar and pass it as a parameter in each call you make to generate( ).  (There are other solutions to this problem, too, but this one makes it possible to test your program even though it's supposed to behave randomly.  I'll explain this further in the \"Testing\" section later in the write-up.)</p>\r\n\r\n    <h1>Why infinite recursion is expected behavior (in some cases)</h1>\r\n\r\n    <p>Grammars are permitted to be recursive.  For example, the following grammar is legal:</p>\r\n\r\n    <p><i>A</i> &rarr; <i>A</i>x</p>\r\n\r\n    <p>If you write this grammar in our input format and pass it to your program as input, your program will recurse infinitely and terminate with a StackOverflowError &mdash; which is what happens when Java runs out of space to store the \"call stack\" that keeps track of information about all the methods that are currently executing.</p>\r\n\r\n    <p>The reason this program will cause your program to crash is simply that there's no way out of the recursion:</p>\r\n\r\n    <ul>\r\n    <li>Suppose <i>A</i> is the start variable.</li>\r\n    <li>Grammar.generate( ) will be called.</li>\r\n\r\n    <li>The rule corresponding to <i>A</i> (the start variable) will be looked up.</li>\r\n    <li>Rule.generate( ) will be called on that rule.</li>\r\n    <li>Variable.generate( ) will be called on the first symbol on the rule's right-hand side, which is the Variable <i>A</i>.</li>\r\n    <li>The rule corresponding to <i>A</i> will be looked up in the Grammar.</li>\r\n\r\n    <li>Rule.generate( ) will be called on that rule.</li>\r\n    <li>Variable.generate( ) will be called on the first symbol on the rule's right-hand side, which is the Variable <i>A</i>.</li>\r\n    <li>The rule corresponding to <i>A</i> will be looked up in the Grammar.</li>\r\n    <li>... and so on ...</li>\r\n\r\n    </ul>\r\n\r\n    <p>We won't test your program with grammars like this, and it's expected &mdash; and, in fact, very difficult to avoid! &mdash; that your program to crash when given such grammars.  Another way to think about a grammar like this is that the only sentences in its language are infinitely long, so it's not surprising that a program to generate such sentences would recurse infinitely.</p>\r\n\r\n    <p>Note that not all recursive grammars have this problem:</p>\r\n\r\n    <p><i>A</i> &rarr; x<i>A</i> | x</p>\r\n\r\n    <p>This grammar describes an infinite language of sentences, each of which is a sequence of one or more x's.  If written in our input format and passed to your program, this grammar should cause your program to generate sentences with various numbers of x's.  (Roughly half of them will have one x, roughly one-quarter of them will have two x's, roughly one-eighth of them will have three x's, and so on.  Stop and think for a minute about why, on average, the sentences will be distributed this way.)</p>\r\n\r\n    <h1>Testing</h1>\r\n    <h2>The problem with randomness, revisited</h2>\r\n\r\n    <p>In this project, we're confronted with the problem of testing a program that has intentionally random behavior.  The randomness that makes the program more useful when it's finished complicates the matter of testing, because it's difficult to know whether the difference between what you expect and what you get is caused by a program bug or (intentionally) random fluctuations in the output.</p>\r\n\r\n    <p>There is a solution to this problem, which we'll explore in the testing phase of this project.  The solution is to set up something called a \"mock object.\"  A mock object is one that takes the place of an actual object that does some task that may behave unpredictably, or may require using resources external to the program (e.g., connect to a web site, load information from a database) that will cloud the results of our unit tests with possible failures that are unrelated to the issues we're testing for.</p>\r\n\r\n    <p>In this case, we'll use a \"mock\" random number generator called MockRandom.  It will behave just like the Random object from Java, in that it will have a nextInt( ) method.  It will also extend Random, so that a MockRandom can be used in place of a Random anywhere we'd like.  The difference is that our MockRandom, rather than giving back a sequence of random numbers, will actually give back exactly the sequence of numbers I ask it to.  This is useful in a test of our code here, because then we'll know exactly what to expect as output!</p>\r\n\r\n    <p>Here is a link to the code for MockRandom, which I'm providing for your use.  Check out the comment in this file for an example of how it works.</p>\r\n\r\n    <ul>\r\n    <li><a href=\"MockRandom.java\">MockRandom.java</a></li>\r\n    </ul>\r\n\r\n    <h2>What you'll need to test</h2>\r\n\r\n    <p>Write a JUnit test of the generate( ) methods in your various grammar classes.  Because so many of the objects are interrelated &mdash; Grammars contain Rules, Rules contain RightHandSides, RightHandSides contain Symbols, etc. &mdash; it's best to just write one JUnit test case class that tests sentence-generating behavior in total.</p>\r\n\r\n    <p>Note that you're not required to test the parsing of the input file or writing the output file.  It's just necessary to write tests that set up a Grammar (and its various sub-objects) and call generate( ).  Pass a MockRandom object to generate( ) in place of an actual Random object, deliberately choosing your sequence of \"random\" numbers so that you'll know what the result of generating a sentence should be.</p>\r\n\r\n    <p>Try to think of some interesting grammars to test with; don't just use one and generate two sentences from it and leave it at that.  What are some interesting cases you'd need to deal with?  Different numbers of right-hand sides in a rule?  Recursive rules (but not infinitely recursive rules)?  Think of what you might try that will uncover a bug.  It's fine to hard-code your grammars directly into your test methods.  So, for example, you might write something like this.  (You may need to write something slightly different, depending on the design and the names of your various methods.)</p>\r\n\r\n    <pre>\r\n    Grammar g = new Grammar();\r\n    Rule r1 = new Rule(\"X\");\r\n    RightHandSide rhs1 = new RightHandSide();\r\n    rhs1.addSymbol(new Terminal(\"Alex\"));\r\n    rhs1.addSymbol(new Terminal(\"is\"));\r\n    rhs1.addSymbol(new Variable(\"Y\"));\r\n    r1.addRightHandSide(rhs1);\r\n    // ...\r\n\r\n    </pre>\r\n\r\n    <p>Ultimately, you'll want each of your test methods to create a grammar, create a MockRandom with your chosen sequence of \"random\" numbers, call the generate( ) method, and assert that the resulting sentence is what you expected it to be.</p>\r\n\r\n    <h1>Deliverables</h1>\r\n\r\n    <p>You must submit all of the <b>.java</b> files that comprise your program.  Please do not turn in the <b>.class</b> files, or other files generated by your development environment.</p>\r\n\r\n    <p>Follow <a href=\"../submittingprojects.html\">this link</a> for a discussion of how to submit your project.</p>\r\n\r\n    <h1>Additional challenges</h1>\r\n\r\n    <p>As discussed earlier in the write-up, a sensible design strategy is to write a Grammar class, which encapsulates a complete grammar.  A grammar is a collection of rules, each of which can be represented as a Rule object.  In earlier sections of the write-up, I advocate storing these Rule objects in a flat data structure, such as an ArrayList or a linked list, and using a linear search whenever you need to look up the rule corresponding to a particular variable.</p>\r\n\r\n    <p>However, this is actually a poor approach if the number of rules will be large and many sentences will be generated by the program.  I invite you to explore these other strategies for implementing the storage of Rules in your Grammar class instead.</p>\r\n\r\n    <ul>\r\n    <li>Store the rules in an ArrayList, but keep them sorted in alphabetical order by variable name.  When you look up a rule for a particular variable, use binary search instead of linear search to find it.  There is a tradeoff at work here.  More time will be spent building the grammar initially, though this will only need to happen once.  Meanwhile, there might be hundreds of sentences being generated, all of which can be generated more quickly.</li>\r\n    <li>In computer science, we commonly need a data structure that stores a collection of data that is indexed by a unique <i>key</i>.  In this case, the rules in a grammar could be indexed uniquely by the names of their variables, since there is only one rule permitted for each variable.  The oft-used <i>map</i> data structure is exactly the right tool for such a job.  A map stores a collection of <i>associations</i>, each of which contains a unique key that is associated with some value.  In our case, the keys are the variable names and the values are the rules.  There are a couple of well-known implementations of maps that you'll learn about in ICS 23 / CSE 23, but you may implement one of them for this project if you wish: a binary search tree or a hash table.</li>\r\n\r\n    </ul>\r\n    </div>\r\n\r\n    <div id=\"aknowledgements\">\r\n    <ul class=\"nomarker\">\r\n    <li>Imported from Alex Thornton's ICS 22 by Eric Hennigan, Winter 2011</li>\r\n    <li>Originally written by Alex Thornton (with heavy influence from \"The Worst Joke Ever,\" by Alex Thornton), Winter 2007</li>\r\n    <li>Original concept by Mike Cleron of Stanford University; modified and adapted by Allison Hansen, Julie Zelinski, and others</li>\r\n    </ul>\r\n    </div>\r\n\r\n  </div>\r\n  </body>\r\n</html>\r\n\u0000", "encoding": "ascii"}