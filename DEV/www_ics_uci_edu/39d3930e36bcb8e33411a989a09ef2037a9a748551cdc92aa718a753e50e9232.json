{"url": "https://www.ics.uci.edu/~alspaugh/cls/shr/java-designPattern.html", "content": "<?xml version='1.1'?>\n<!DOCTYPE html\n     PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'\n     'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>\n<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>\n<head>\n  <title>Design Patterns</title>\n  <meta name='Author' content='Thomas A. Alspaugh'/>\n  <meta name='Description' content=\"Design Patterns\"/>\n  <meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'/>\n  <meta http-equiv='Content-Style-Type' content='text/css'/>\n  <link href='../../alspaugh-uci.css' rel='stylesheet' type='text/css'/>\n  <!-- <link href='../alspaugh-uci-cls.css' rel='stylesheet' type='text/css'/> -->\n  <style type='text/css'>\n    .lex {  font-variant: small-caps;  }\n    .var {  font-style: italic;  }\n    pre  {  padding-left: 2em;  }\n    pre code {  font-size: 100%;  }\n    @media screen {\n      body     {  background: url(\"img/bg-java-designPattern.png\") repeat-y;  }\n      #TMain   {  margin-left: 10.00em;  }\n    }\n  </style>\n</head>\n<body>\n\n<div id='TBg'>\n\n<div id='THeader'>\nJava Design Patterns\n<span class='newUrl'><a href='https://thomasalspaugh.org/pub/fnd/java-designPattern.html'\n  >thomasalspaugh.org/pub/fnd/java-designPattern.html</a></span>\n</div>\n\n<div id='TLinks1' class='Links'> <!-- - - - - - - - - - - - - - - - - - - - -->\n<p>  <a class='sc' href='../../index.html'>Home</a>\n</p>\n<div class='hr'> </div>\n<p>  <a href='index.html'>Foundations home</a>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='set.html'>Sets</a><br/>\n<a href='relation.html'>Relations</a><br/>\n<a href='correspondence.html'>Correspondences</a><br/>\n<a href='orderedSet.html'>Ordered Sets</a><br/>\n<a href='lattice.html'>Lattices</a><br/>\n<a href='graph.html'>Graphs</a><br/>\n<a href='powerset.html'>Powersets</a><br/>\n<a href='binaryString.html'>Binary Strings</a><br/>\n<a href='logicConcepts.html'>Logic</a><br/>\n<a href='allen.html'>AIA</a><br/><!-- -spell AIA -->\n<a href='greek.html'>Greek</a><br/>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='glossaryExternal.html'>Glossary</a><br/>\n<a href='goodAbstract.html'>Abstracts</a><br/>\n<a href='argument.html'>Argument</a><br/>\n<a href='inquiryCycle.html'>Inquiry Cycle</a><br/>\n<a href='hohfeld.html'>Legal Relations</a><br/>\n<a href='goodPresentation.html'>Presentations</a><br/>\n</p>\n<div class='hr'> </div>\n<p>\n<a href='quickStart.html'>Elicitation</a><br/>\n<a href='ontology.html'>Glossaries</a><br/>\n<a href='goal.html'>Goals</a><br/>\n<a href='istar.html'>i*</a><br/>\n<a href='SCR.html'>SCR</a><br/>\n<a href='tracing.html'>Tracing</a><br/>\n</p>\n<div class='hr2'> </div>\n<p>\n<a href='alloy.html'>Alloy</a><br/>\n<a href='msc.html'>MSCs</a><br/>\n<a href='regularExpression.html'>Regular Exprs.</a><br/>\n</p><!-- -spell MSCs Exprs -->\n<div class='hr2'> </div>\n<p>\n<a href='java-designPattern.html'>Design Patterns</a><br/>\n<a href='javadoc.html'>Javadoc</a><br/>\n<a href='java-package.html'>Java Packages</a><br/>\n<a href='java-type.html'>Java Types</a><br/>\n</p>\n<div class='hr2'> </div>\n<p>\n<a href='html.html'>(X)HTML</a><br/>\n<a href='xmlSchema.html'>XML Schemas</a><br/>\n<a href='xslt.html'>XSLT</a><br/>\n</p><!-- -spell XSLT -->\n</div>\n\n\n<!-- No right column -->\n<div id='TMain'><!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->\n<!--xhtml -y -->\n\n\n<!--spell EOF GHJV IOException LogicalConstant LogicalVariable PushbackReader -->\n<!--spell RuntimeException StringBuffer VisitorEvaluate VisitorToString -->\n<!--spell Vlissides Za constant's expectedLowerCase factoryConjunction -->\n<!--spell factoryDisjunction factoryLogicalConstant factoryLogicalVariable -->\n<!--spell factoryNegation formulaVisited inheritDoc javadoc leftValue -->\n<!--spell logicalConstant logicalVariable param pushback readName -->\n<!--spell rightValue skipWhitespace subformula's subformulaValue -->\n<!--spell subformulas util env io -->\n\n\n<p>\nDesign patterns are patterns of organizing program implementations.&nbsp;\nThey express good coding ideas that can be reused in other programs.&nbsp;\n<a href='#GHJV95'>[GHJV95]</a> is the basic reference,\nand a large number of patterns are published in other sources;\nof which a few of the most useful are discussed here.&nbsp;\n</p>\n\n\n<h1>Table of contents</h1>\n<div id='ToC'>\n</div>\n\n\n<h1 id='example'>The example</h1>\n\n<p>\nConsider a group of classes that represent\nlogical expressions.&nbsp;\nThese classes represent all the simple and compound elements\nof such expressions,\ndescribed in the grammars below.&nbsp;\nThe grammar is set up for ease of parsing.&nbsp;\nLexical elements are named in <span class='lex'>small caps</span>\nand specified as regular expressions.&nbsp;\n</p>\n\n<!-- <h2>Predicate logic</h2> -->\n\n<table class='noborder'>\n<tbody>\n  <tr>\n    <td class='var'>formula\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><span class='var'>logicalConstant</span>\n      | <span class='lex'>logicalVariable</span>\n      | <span class='var'>negation</span>\n      | <span class='var'>conjunction</span>\n      | <span class='var'>disjunction</span>\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>logicalConstant\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>0</b> | <b>1</b>\n    </td>\n  </tr>\n  <tr>\n    <td class='lex'>logicalVariable\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td>[<b>a-z</b>][<b>A-Za-z0-9</b>]*\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>negation\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>~</b> <span class='var'>formula</span>\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>conjunction\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>(</b> <span class='var'>formula</span> <b>&amp;</b>\n        <span class='var'>formula</span> <b>)</b>\n    </td>\n  </tr>\n  <tr>\n    <td class='var'>disjunction\n    </td>\n    <td class='ce'>&rarr;\n    </td>\n    <td><b>[</b> <span class='var'>formula</span> <b>|</b>\n        <span class='var'>formula</span> <b>]</b>\n    </td>\n  </tr>\n</tbody>\n</table>\n\n<!--\n<h2>First-order logic</h2>\n\n<p>\nAll the productions for predicate logic, plus also:\n\n<table class='noborder'>\n<tbody>\n  <tr>\n    <td class='var'>formula\n    <td class='ce'>&rarr;\n    <td><span class='var'>predicate</span>\n      | <span class='var'>universal</span>\n      | <span class='var'>existential</span>\n  <tr>\n    <td class='lex'>predicateName\n    <td class='ce'>&rarr;\n    <td>[<b>A-Z</b>][<b>A-Za-z0-9</b>]*\n  <tr>\n    <td class='var'>predicate\n    <td class='ce'>&rarr;\n    <td><span class='lex'>predicateName</span>\n        <b>(</b> <span class='lex'>domainConstant</span> <b>)</b>\n  <tr><td><td class='ce'>|\n    <td><span class='lex'>predicateName</span>\n        <b>(</b> <span class='lex'>domainVariable</span> <b>)</b>\n  <tr>\n    <td class='lex'>domainConstant\n    <td class='ce'>&rarr;\n    <td>[<b>A-Z</b>][<b>A-Za-z0-9</b>]*\n  <tr>\n    <td class='lex'>domainVariable\n    <td class='ce'>&rarr;\n    <td>[<b>a-z</b>][<b>A-Za-z0-9</b>]*\n  <tr>\n    <td class='var'>universal\n    <td class='ce'>&rarr;\n    <td> <b>&lowast;</b> <span class='lex'>domainVariable</span>\n        <span class='var'>formula</span>\n  <tr>\n    <td class='var'>existential\n    <td class='ce'>&rarr;\n    <td> <b>+</b> <span class='lex'>domainVariable</span>\n        <span class='var'>formula</span>\n</tbody>\n</table>\n -->\n\n<p>\nA basic Java implementation of this grammar is the\n<a href='formula/'><code>formula</code></a> package.&nbsp;\nIt and the <a href='formulaVisited/'><code>formulaVisited</code></a> package,\nwhich makes use of the patterns described below,\nare specified with <a href='javadoc/index.html'>javadoc documentation</a>.&nbsp;\n</p>\n\n\n<h1 id='Factory'>The Factory pattern</h1>\n\n<p>\nA constructor always produces an object\nof a specific class, the class whose constructor it is.&nbsp;\nIn some situations,\nit would be more helpful to be able to construct\nan object belonging to a subclass,\nwithout having to know ahead of time\nwhich subclass any particular object will belong to.&nbsp;\nA factory is a class or method\nthat constructs objects of a particular interface or superclass,\nchoosing which subclass is appropriate at run-time.&nbsp;\nFor example,\na method that reads strings for formulas, as defined in the grammar above,\nmight construct a Negation object if the top-level operation in the formula\nis a negation,\nor a Conjunction object if the top level was a conjunction.&nbsp;\nThe return type of the method would simply be Formula.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\nimport java.io.*;\n\n\n/**\n  A factory for creating formulas from a reader.\n  The specific Formula subclass that is returned\n  depends on what the reader reads.\n  Because the factory is stateless,\n  all its methods are static.\n  True and false are represented by 1 and 0;\n  variables are strings of letters and digits beginning with a lowercase letter;\n  the negation operator is '~';\n  conjunctions are in () with '&amp;' as the infix operator;  and\n  disjunctions are in [] with '|' as the infix operator.\n*/\npublic class Factory {\n\n  /**\n    Reads a character stream and returns\n    the formula corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static public Formula factory(PushbackReader _in) throws IOException {\n    int cc;\n    cc = _in.read();  _in.unread(cc);\n    if /**/ ( -1 == cc) {  throw new RuntimeException(\"Expected formula, found EOF\");  }\n    else if ('(' == cc) {  return factoryConjunction    (_in);  }\n    else if ('[' == cc) {  return factoryDisjunction    (_in);  }\n    else if ('~' == cc) {  return factoryNegation       (_in);  }\n    else if ('0' == cc) {  return factoryLogicalConstant(_in);  }\n    else if ('1' == cc) {  return factoryLogicalConstant(_in);  }\n    else if (Character.isLowerCase((char) cc)) {\n      return factoryLogicalVariable(_in);\n    }\n    else {\n      throw new RuntimeException(\"Expected formula, found \" + printable(cc));\n    }\n  }\n\n  /**\n    Reads a character stream and returns\n    the conjunction corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryConjunction(PushbackReader _in) throws IOException {\n    expect('(', _in);\n    Formula left  = factory(_in);\n    skipWhitespace(_in);\n    expect('&amp;', _in);\n    Formula right = factory(_in);\n    skipWhitespace(_in);\n    expect(')', _in);\n    return new Conjunction(left, right);\n  }\n\n  /**\n    Reads a character stream and returns\n    the disjunction corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryDisjunction(PushbackReader _in) throws IOException {\n    expect('[', _in);\n    Formula left  = factory(_in);\n    skipWhitespace(_in);\n    expect('|', _in);\n    Formula right = factory(_in);\n    skipWhitespace(_in);\n    expect(']', _in);\n    return new Disjunction(left, right);\n  }\n\n  /**\n    Reads a character stream and returns\n    the logical constant corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static LogicalConstant factoryLogicalConstant(PushbackReader _in) throws IOException {\n    String name = readName(_in);\n    if /**/ (name.equals(\"0\")) {  return LogicalConstant.zero();  }\n    else if (name.equals(\"1\")) {  return LogicalConstant.one ();  }\n    else {\n      throw new RuntimeException(\"Expected 0 or 1, found \\\"\" + name + \"\\\"\");\n    }\n  }\n\n  /**\n    Reads a character stream and returns\n    the logical variable corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryLogicalVariable(PushbackReader _in) throws IOException {\n    String name = readName(_in);\n    expectedLowerCase(name.charAt(0));\n    return new LogicalVariable(name);\n  }\n\n  /**\n    Reads a character stream and returns\n    the negation corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static Formula factoryNegation(PushbackReader _in) throws IOException {\n    expect('~', _in);\n    Formula subformula = factory(_in);\n    return new Negation(subformula);\n  }\n\n  /**\n    Reads a character stream and returns\n    the name corresponding to it, if any.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If there is a syntax error in the character stream.\n  */\n  static String readName(PushbackReader _in) throws IOException {\n    StringBuffer name = new StringBuffer();\n    int cc;\n    while (-1 &lt; (cc = _in.read()) &amp;&amp; Character.isLetterOrDigit((char) cc)) {\n      name.append((char) cc);\n    }\n    _in.unread(cc);\n    if (0 == name.length()) {  throw new RuntimeException(\"Name expected\");  }\n    return name.toString();\n  }\n\n  /**\n    Skips a string of whitespace in a character stream.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n  */\n  static void skipWhitespace(PushbackReader _in) throws IOException {\n    int cc;\n    while (-1 &lt; (cc = _in.read()) &amp;&amp; Character.isWhitespace((char) cc)) {}\n    _in.unread(cc);\n  }\n\n  /**\n    Reads a character and throws an exception\n    if the character is not the expected one.\n    @param _expected The expected character.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If the expected character was not next in the stream.\n  */\n  static void expect(char _expected, PushbackReader _in) throws IOException {\n    int cc;\n    if (_expected != (cc = _in.read())) {\n      throw new RuntimeException(\"Expected '(', found \" + printable(cc));\n    }\n  }\n\n  /**\n    Reads a character and throws an exception\n    if the character is not lowercase.\n    @param _in A pushback reader for the stream.\n    @throws IOException If the stream operations do.\n    @throws RuntimeException If the stream did not begin with a lowercase character.\n  */\n  static void expectedLowerCase(char _cc) {\n    if (!Character.isLowerCase(_cc)) {\n      throw new RuntimeException(\"Expected lowercase, found \" + printable(_cc));\n    }\n  }\n\n  /**\n    Returns a printable string representing a character.\n    @param  _cc The character.\n    @return _in A string describing _cc: \n      \"EOF\" if _cc is -1, \"newline\" if _cc is '\\n',\n      _cc in single quotes if _cc is printable,\n      and the numerical value of _cc otherwise.\n  */\n  static String printable(int _cc) {\n    if /**/ (-1   == _cc) {  return \"EOF\";  }\n    else if ('\\n' == _cc) {  return \"newline\";  }\n    else if (Character.isISOControl((char) _cc))\n                         {  return \"\" + _cc;  }\n    else                 {  return \"'\" + (char) _cc + \"'\";  }\n  }\n\n}\n\n</pre>\n\n<p>\nThis pattern is not discussed in <a href='#GHJV95'>[GHJV95]</a>,\nalthough two closely related patterns are\n(Abstract Factory and Factory Method).&nbsp;\n</p>\n\n\n<h1 id='Singleton'>The Singleton pattern</h1>\n\n<p>\nA singleton is the only instance of its type.&nbsp;\nThe singleton pattern is a way of coding a class\nso that only one instance of the class is constructed,\nand that instance is reused every time an object of the class is needed.&nbsp;\nIt can be adapted for classes that have only two or a small finite number\nof distinct instances,\nso they can be reused.&nbsp;\n</p>\n\n<p>\nTo write a class <code>C</code> that follows the Singleton pattern,\nmake its constructor private\n(so that no one outside the class can construct one).&nbsp;\nGive the class a private static variable <code>singleton</code>\nof type <code>C</code>,\nand a public static method <code>singleton()</code>\nwith no parameters and\nreturning a value of type <code>C</code>.&nbsp;\nMethods outside the class call this <code>singleton()</code> method\nto get an object of the class.&nbsp;\n</p>\n\n<p>\nThere are two ways to give the variable its value:&nbsp;\n</p>\n\n<ol>\n  <li> <b>eagerly</b>:&nbsp; initialize the variable by calling the (private) constructor,\n    then the <code>singleton()</code> method returns its value.\n  </li>\n  <li> <b>lazily</b>:&nbsp;  initialize the variable to null;&nbsp;\n    then the <code>singleton()</code> method checks to see if the variable is null,\n    gives it a non-null value by calling the (private) constructor if so,\n    and then returns the variable's value.&nbsp;\n  </li>\n</ol>\n\n<p>Example:&nbsp; the LogicalConstant class,\nwhich needs no more than two distinct instances.&nbsp;\nThe class is reimplemented using the Singleton pattern twice,\nonce for <b>0</b> and once for <b>1</b>.&nbsp;\n<b>0</b> uses the eager Singleton pattern,\nand\n<b>1</b> uses the lazy Singleton pattern.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  A logical constant, representing true or false.\n*/\npublic class LogicalConstant implements Formula {\n  \n  static private LogicalConstant one = new LogicalConstant(true);\n  /**\n    Returns a logical constant for 1 (true).\n    The same constant is returned for every call.\n    The constant is constructed at initialization time (eager initialization).\n  */\n  static public  LogicalConstant one() {  return one;  }\n  \n  static private LogicalConstant zero = null;\n  /**\n    Returns a logical constant for 0 (false).\n    The same constant is returned for every call.\n    The constant is not constructed until the first call (lazy initialization).\n  */\n  static public  LogicalConstant zero() {\n    if (null == zero) {\n      zero = new LogicalConstant(false);\n    }\n    return zero;\n  }\n  \n  boolean value;\n  /**\n    Constructs a logical constant.\n    @param _value The constant's value.\n  */\n  private LogicalConstant(boolean _value) {  value = _value;  }\n\n  public Object accept(Visitor _v) {  return _v.visit(this);  }\n\n}\n\n</pre>\n\n\n<h1 id='Visitor'>The Visitor pattern</h1>\n\n<p>\nA visitor is an object that traverses a tree (or other data structure)\nand performs an operation for each node of the tree,\nchoosing the appropriate operation for each node\nbased on the node's static type.&nbsp;\nIt allows the code that implements an operation\nto be localized in a single class,\nand can reduce the cost of adding a new operation\non the trees.&nbsp;\nOnce the node classes are set up for the visitor pattern,\nthey need not be changed if a new operation is added;&nbsp;\ninstead, a new visitor is implemented.&nbsp;\n</p>\n\n<p>\nTo implement the Visitor pattern,\ngive each node class a method <code>accept(Visitor _v)</code>\nthat calls the visitor's <code>visit(C _c)</code> method,\nwhere <code>C</code> is the node class.&nbsp;\nThis method is textually the same for every node class;&nbsp;\nthe compiler sets up a call to the right <code>visit</code> method\nbased on the type of the node.&nbsp;\n</p>\n\n<pre>\npublic Object accept(Visitor _v) {  return _v.visit(this);  }\n</pre>\n\n<p>\nThen the visitor class is implemented\nwith a separate <code>visit(C _c)</code> method for each node class\n<code>C</code>.&nbsp;\nEach <code>visit(C _c)</code> method does whatever is desired\nfor objects of that class <code>C</code>.&nbsp;\nIf a result is needed,\nit is packaged up as some kind of object and returned.&nbsp;\n</p>\n\n<p>\nExample:&nbsp;\nThe formula package rewritten to take visitors,\nwith a <code>Visitor</code> interface added\nto be the type of all visitors:&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  A visitor to formulas.\n  The visitor traverses the syntax tree of a formula,\n  and calculates some result for each kind of formula.\n  For kinds of formulas that have subformulas,\n  the results for the subformulas are combined\n  into the result for the formula.\n  Each formula's result is returned from the visit() method.\n*/\npublic interface Visitor {\n  /**  Calculates the result for a Conjunction.  */\n  public Object visit(Conjunction _f);\n  /**  Calculates the result for a Disjunction.  */\n  public Object visit(Disjunction _f);\n  /**  Calculates the result for a LogicalConstant.  */\n  public Object visit(LogicalConstant _f);\n  /**  Calculates the result for a LogicalVariable.  */\n  public Object visit(LogicalVariable _f);\n  /**  Calculates the result for a Negation.  */\n  public Object visit(Negation _f);\n}\n\n</pre>\n\n<p>\nNow all formula classes accept visitors:\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  The type of all logic formulas that accept visitors.\n*/\npublic interface Formula {\n  /**\n    Accepts a visitor.\n    Each subclass implements this method as \n    <code>{  return _v.visit(this);  }</code>,\n    and the compiler identifies the right {@link Visitor} method\n    based on the subclass (which is the type of <code>this</code>).\n    @param _v The visitor.\n    @return The result _v calculates for this formula.\n  */\n  public Object accept(Visitor _v);\n\n}\n\n</pre>\n\n<p>\nEach formula class implements the <code>accept</code> method\nby calling the visitor on itself:&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  The conjunction (\"and\") of two subformulas.\n  A conjunction is true if both subformulas are true,\n  and false if either or both subformulas are false.\n*/\npublic class Conjunction implements Formula {\n  Formula left;\n  Formula right;\n  /**\n    Constructs the conjunction of two subformulas.\n    @param _left  The first subformula.\n    @param _right The second subformula.\n  */\n  public Conjunction(Formula _left, Formula _right) {  left = _left;  right = _right;  }\n  \n  public Object accept(Visitor _v) {  return _v.visit(this);  }\n  \n}\n\n</pre>\n\n<p>\nEach visitor class implements a <code>visit</code> method\nfor each type of formula,\nwith the method producing the right result for that formula type.&nbsp;\nFor formula classes with subformulas,\nthe visitor uses the result it produces for each subformula\nin making the result for the formula containing them.&nbsp;\nThe <code>VisitorToString</code> class is a good example;&nbsp;\nfor a Conjunction, for example,\nit uses its own results for the left subformula\nand the right subformula\nin producing the result for the Conjunction.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\n\n\n/**\n  A visitor that produces a string representation for each formula.\n*/\npublic class VisitorToString implements Visitor {\n  \n  public Object visit(Conjunction _f) {\n    return \"(\" + (String) _f.left .accept(this) + \n           \"&amp;\" + (String) _f.right.accept(this) + \")\";\n  }\n  \n  public Object visit(Disjunction _f) {\n    return \"[\" + (String) _f.left .accept(this) + \n           \"|\" + (String) _f.right.accept(this) + \"]\";\n  }\n  \n  public Object visit(LogicalConstant _f) {\n    if (LogicalConstant.one().equals(_f)) {  return \"1\";  }\n    else                                  {  return \"0\";  }\n  }\n  \n  public Object visit(LogicalVariable _f) {\n    return _f.name;\n  }\n  \n  public Object visit(Negation _f) {\n    return \"~\" + _f.subformula.accept(this);\n  }\n  \n}\n\n</pre>\n\n<p>\nNow that the node classes are set up to accept visitors,\nwe can easily write a visitor to add any function.&nbsp;\nBelow is a visitor to evaluate the value of a logical formula.&nbsp;\n</p>\n\n<p>\nIn order to implement this visitor,\nwe need to write an <code>Environment</code> class\nthat gives the truth values (if any) for the logical variables\nand the domain constant values (if any) for the domain variables,\nand the truth values for the applications of each predicate to\neach of the domain constants.&nbsp;\nThe visitor is given an environment to use\nin determining the value of a formula;&nbsp;\nwe assume this environment has been set up to show (for example)\nthat logical variable <code>b</code> represents false,\nand that predicate <code>P</code> is true\nwhen applied to domain constant <code>E12</code>.&nbsp;\n</p>\n\n<p>\nThe visitor returns Boolean.FALSE\nif the formula being visited is false,\nBoolean.TRUE if the formula is true,\nand <code>null</code> if the value of the formula can't be determined.&nbsp;\n</p>\n\n<pre>\npackage formulaVisited;\nimport java.util.*;\n\n\n/**\n  A visitor that evaluates each formula, returning\n  Boolean.TRUE  if the formula is true,\n  Boolean.FALSE if the formula is false, and\n  null if its value cannot be determined.\n  The presence of undefined logical values,\n  or predicates whose value is not defined for every domain entity,\n  can result in formulas whose logical values that cannot be determined.\n*/\npublic class VisitorEvaluate implements Visitor {\n\n  Environment env;\n  /**\n    Construct a VisitorEvaluate that evaluates formulas\n    in the given environment.\n    @param _env The environment.\n  */\n  public VisitorEvaluate(Environment _env) {\n    env = _env;\n  }\n\n  /**\n    {@inheritDoc}\n    A conjunction is true if both its subformulas are true,\n    false if either of its subformulas is false,\n    and unknown otherwise.\n  */\n  public Object visit(Conjunction _f) {\n    Boolean leftValue  = (Boolean) _f.left .accept(this);\n    Boolean rightValue = (Boolean) _f.right.accept(this);\n    if /**/ (!leftValue .booleanValue()) {  return Boolean.FALSE;  }\n    else if (!rightValue.booleanValue()) {  return Boolean.FALSE;  }\n    else if ( leftValue .booleanValue() &amp;&amp;\n              rightValue.booleanValue()) {  return Boolean.TRUE;   }\n    else                                 {  return null;  }\n  }\n\n  /**\n    {@inheritDoc}\n    A disjunction is false if both its subformulas are false,\n    true if either of its subformulas is true,\n    and unknown otherwise.\n  */\n  public Object visit(Disjunction _f) {\n    Boolean leftValue  = (Boolean) _f.left .accept(this);\n    Boolean rightValue = (Boolean) _f.right.accept(this);\n    if /**/ ( leftValue .booleanValue()) {  return Boolean.TRUE;   }\n    else if ( rightValue.booleanValue()) {  return Boolean.TRUE;   }\n    else if (!leftValue .booleanValue() &amp;&amp;\n             !rightValue.booleanValue()) {  return Boolean.FALSE;  }\n    else                                 {  return null;  }\n  }\n\n  /**\n    {@inheritDoc}\n    The value of {@link LogicalConstant#one  LogicalConstant.one() } is true, and\n    the value of {@link LogicalConstant#zero LogicalConstant.zero()} is false.\n  */\n  public Object visit(LogicalConstant _f) {\n    if (LogicalConstant.one().equals(_f)) {  return \"1\";  }\n    else                                  {  return \"0\";  }\n  }\n\n  /**\n    {@inheritDoc}\n    The value of a logical variable is\n    the value the variable is bound to in the environment,\n    and unknown if the variable is bound to no value.\n    The environment used is the one with which this visitor was constructed.\n  */\n  public Object visit(LogicalVariable _f) {\n    return env.get(_f);\n  }\n\n  /**\n    {@inheritDoc}\n    A negation is false if its subformula is true,\n    false if its subformula is true,\n    and unknown if its subformula's value is unknown.\n  */\n  public Object visit(Negation _f) {\n    Boolean subformulaValue = (Boolean) _f.subformula.accept(this);\n    if /**/ (null == subformulaValue)        {  return null;  }\n    else if (subformulaValue.booleanValue()) {  return Boolean.FALSE;  }\n    else                                     {  return Boolean.TRUE;   }\n  }\n\n}\n\n</pre>\n\n\n<h1 id='References'>References</h1>\n\n<p id='GHJV95'>[GHJV95]&nbsp;\nErich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.&nbsp;\n<i>Design Patterns: Elements of reusable object-oriented software</i>.&nbsp;\nAddison-Wesley, 1995.\n</p>\n\n\n<!--xhtml -n -->\n</div>\n\n</div><!-- #TBg -->\n\n<div id='TFooter'>\n<div class='W3C'>\n  <a href='http://validator.w3.org/check?uri=referer'><img class='W3C'\n    src='../../img/valid-xhtml10-blue.png'\n    alt='Valid XHTML 1.0 Strict'/></a>\n  <br/>\n  <a href='http://jigsaw.w3.org/css-validator/check/referer'><img class='W3C'\n    src='../../img/vcss-blue.png'\n    alt='Valid CSS!'/></a>\n</div>\n<div class='timestamp'>2009Sep23We10:12</div>\n<div style='padding-top:1px;'>\n<a class='plain' href='./index.html' style='font-variant:small-caps;'\n>Thomas A. Alspaugh</a>\n<span style='padding-left:1em;'><span class='email ss sm'>alspaugh&nbsp;\n    <span class='ss sc sm'>at</span> &middot; ics &middot; uci &middot; edu</span>\n    <!-- -spell alspaugh uci edu --> </span>\n</div>\n</div>\n\n<!-- Google Analytics code -->\n<script type=\"text/javascript\">\nvar gaJsHost = ((\"https:\" == document.location.protocol)\n  ? \"https://ssl.\" : \"http://www.\");\ndocument.write(unescape(\"%3Cscript src='\" + gaJsHost +\n  \"google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E\"));\n</script>\n<script type=\"text/javascript\">\ntry {\nvar pageTracker = _gat._getTracker(\"UA-15281497-1\");\npageTracker._trackPageview();\n} catch(err) {}\n</script>\n\n</body>\n</html>\n\n", "encoding": "ascii"}