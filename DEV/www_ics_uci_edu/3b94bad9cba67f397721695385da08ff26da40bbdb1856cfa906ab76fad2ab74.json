{"url": "https://www.ics.uci.edu/~dan/class/165/notes/OptBST.html", "content": "<HTML><HEAD>\n<TITLE> Optimal binary search trees </TITLE>\n</HEAD><BODY>\n<H2>Optimal binary search trees</H2>\n\n(<small>useful as a static dictionary</small>)\n<P>\nGiven an ordered set S =\n<I>a</I><sub>1</sub> &lt;\n<I>a</I><sub>2</sub> &lt; ...\n<I>a</I><sub><I>n</I></sub>,\nwe wish to process sequences of MEMBER queries. &nbsp;\nWe also know the probability of various requests occurring:\n<P>\n<I>p<sub>i</sub></I> = Prob[ MEMBER(<I>a<sub>i</sub></I>,S) is asked],\nfor <I>i</I> = 1...<I>n</I>\n<BR>\n<I>q<sub>i</sub></I> = Prob[ MEMBER(<I>x</I>,S) is asked] &nbsp;\nwith <I>a<sub>i</sub></I> &lt; <I>x</I> &lt; <I>a</I><sub><I>i</I>+1</sub>,\nfor <I>i</I> = 0...<I>n</I>\n<BR>\nwhere <I>a</I><sub>0</sub> = <I>-</I>&infin;\nand <I>a</I><sub><I>n</I>+1</sub> = +&infin;\n<P>\nTo help analyze the time complexity, we add leaves to the binary\nsearch tree wherever we have a null link.\n<P>\nIf <I>x</I> is the label of node <I>v</I>\nthen cost( MEMBER(<I>x</I>,S) ) = 1 + depth(<I>v</I>).\n<P>\nIf <I>x</I> not in set S and\n<I>a<sub>i</sub></I> &lt; <I>x</I> &lt; <I>a</I><sub><I>i</I>+1</sub>\nthen cost( MEMBER(<I>x</I>,S) ) = depth(leaf <I>i</I>).\n<P>\nThe average time complexity for this tree can be found by summing the\ncosts of accessing a node mutiplied by the probability of that access.\n<P>\ncost(binary search tree T) =\n&sum;<sub><I>i</I> = 1 to <I>n</I></sub>\n( <I>p<sub>i</sub></I> [1 + depth(<I>a<sub>i</sub></I>)] ) +\n&sum;<sub><I>i</I> = 0 to <I>n</I></sub>\n( <I>q<sub>i</sub></I> depth(leaf <I>i</I>) )\n<P>\n<U>Problem</U>: &nbsp;\nGiven the <I>p</I>'s and <I>q</I>'s, find T to minimize cost.\n<P>\nThe divide-and-conquer approach suggests determining which element\nbelongs at the root and then determining what each of the subtrees\nlooks like. &nbsp;\nThere seems to be no easy way of determining what the root should be,\nwhich means that we would have to solve 2<I>n</I> subproblems,\nas each of the <I>n</I> elements could be at the root and\nfor each choice we must solve the left and right subtrees. &nbsp;\n(As an exercise, determine the time complexity of this recursive\napproach. &nbsp; Start by giving an explicit recurrence.) &nbsp;\nThis is too many for recursion, so we use dynamic programming.\n<P>\nFor 0 &le; <I>i &lt; j &le; n</I>, let\n<BR>\n&nbsp; T<sub><I>i, j</I></sub> = min cost tree for\nproblem {<I>a</I><sub><I>i</I>+1</sub>...<I>a<sub>j</sub></I>}\n<BR>\n&nbsp; <I>c<sub>i, j</sub></I> = cost(T<sub><I>i, j</I></sub>)\n<BR>\n&nbsp; <I>r<sub>i, j</sub></I> = root(T<sub><I>i, j</I></sub>)\n<BR>\nand define weight <I>w<sub>i, j</sub></I> =\n<I>q<sub>i</sub></I>\n+ (<I>p</I><sub><I>i</I>+1</sub>+<I>q</I><sub><I>i</I>+1</sub>)\n+ ...\n+ (<I>p<sub>j</sub></I>+<I>q<sub>j</sub></I>)\n<P>\nT<sub><I>i, j</I></sub> consists of a root containing\n<I>a<sub>k</sub></I>, for some <I>k</I> and left and right subtrees\nof the root, with the left subtree being an optimal (min cost)\ntree T<sub><I>i, k-</I>1</sub> and the right subtree being\nT<sub><I>k, j</I></sub>.\n<P>\nAlso, boundary conditions:\n<BR>\n&nbsp; T<sub><I>i, i</I></sub> = the empty tree\n<BR>\n&nbsp; <I>w<sub>i, i</sub></I> = <I>q<sub>i</sub></I>\n<BR>\n&nbsp; <I>c<sub>i, i</sub></I> = 0\n<P>\nIn T<sub><I>i, j</I></sub>, the depth of all vertices in the\nsubtrees is precisely 1 more than what the depths were in\nsubtrees T<sub><I>i, k-</I>1</sub> and T<sub><I>k, j</I></sub>. &nbsp;\nTherefore,\n<BR>\n<I>c<sub>i, j</sub></I>\n= (<I>c</I><sub><I>i, k-</I>1</sub> + <I>w</I><sub><I>i, k-</I>1</sub>)\n+ <I>p<sub>k</sub></I>\n+ (<I>c<sub>k, j</sub></I> + <I>w<sub>k, j</sub></I>)\n<BR>\n&nbsp; &nbsp; &nbsp; &nbsp; = <I>w<sub>i, j</sub></I> +\n<I>c</I><sub><I>i, k-</I>1</sub> + <I>c<sub>k, j</sub></I>, &nbsp;\nfor some <I>k</I>\n<P>\nThe optimal T<sub><I>i, j</I></sub> will have root <I>a<sub>k</sub></I>\nthat minimizes the sum\n<I>c</I><sub><I>i, k-</I>1</sub> + <I>c<sub>k, j</sub></I>.\n<P>\n<U>Construction of optimal binary search tree</U>\n<PRE>\n    <B>for</B> i := 0 <B>to</B> n <B>do</B>\n       w<sub>i,i</sub> := q<sub>i</sub>\n       c<sub>i,i</sub> := 0\n       r<sub>i,i</sub> := 0\n    <B>for</B> length := 1 <B>to</B> n <B>do</B>\n       <B>for</B> i := 0 <B>to</B> n-length <B>do</B>\n          j := i + length\n          w<sub>i,j</sub> := w<sub>i,j-1</sub> + p<sub>j</sub> + q<sub>j</sub>\n          m := value of k (with i &lt; k &le; j) which minimizes (c<sub>i,k-1</sub>+c<sub>k,j</sub>)\n          c<sub>i,j</sub> := w<sub>i,j</sub> + c<sub>i,m-1</sub> + c<sub>m,j</sub>\n          r<sub>i,j</sub> := m\n          Leftson(r<sub>i,j</sub>) := r<sub>i,m-1</sub>\n          Rightson(r<sub>i,j</sub>) := r<sub>m,j</sub>\n</PRE>\n<P>\nThe time complexity of this algorithm is <I>O</I>(<I>n</I><sup>3</sup>).\n<P>\nMaking a slight change\nwill reduce the complexity to be <I>O</I>(<I>n</I><sup>2</sup>). &nbsp;\n(<small>See, for example, Knuth v.3, 2nd ed.,p.436-9 and p.456#27</small>)\n<P>\nModify the range of considered values of <I>k</I>:\n<P>\n<PRE>\n          <B>if</B> length=1 <B>then</B>\n             m := j\n          <B>else</B>\n             m := value of k (with r<sub>i,j-1</sub> &le; k &le; r<sub>i+1,j</sub>) which minimizes (c<sub>i,k-1</sub>+c<sub>k,j</sub>)\n</PRE>\n<P>\n<HR>\n<A HREF=\"http://www.ics.uci.edu/~dan\">\nDan Hirschberg </A> <BR>\n<ADDRESS>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3435\n</ADDRESS>\n<tt>dan (at) ics.uci.edu</tt><br>\nLast modified: Oct 28, 2003\n</BODY></HTML>\n", "encoding": "ascii"}