{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990420.txt", "content": "Advanced Collections Minutes 4/20/99\n\nAttending: Judy Slein, Tyson Chihaya, Geoff Clemm, Chuck Fay, Jim\nWhitehead, Jim Davis\n\nACTION ITEMS\n\nGeoff: Send email to the webdav mailing list describing his MKRESOURCE\nproposal.\n\nJim W: Try again to spur discussion of server-maintained orderings.\n\nJudy: Revise spec based on today's decisions by COB Thursday. Then turn\nit over to Jim W for revisions.\n\nJim W: Revise spec after Judy is done.\n\nAll: Review spec revision 03.2 for next week.\n\nCOPY FOR COLLECTIONS\n\nWe don't want to modify the WebDAV spec or conflict with it.  It says that\na COPY on a collection with Depth: 0 creates an empty collection.\n\nGeoff wants some way to copy the bindings as well as the properties, and\nproposes defining semantics for Depth: 1 to do this.\n\nWe would like the Depth header to mean the same thing in the context of\nDELETE, COPY, PROPFIND.  In PROPFIND it makes sense for Depth: 0 to get\njust the properties of the collection, and Depth: 1 to get the properties\nof the collection and of the resources identified by its immediate members.\n\nBut Geoff wants COPY Depth: 1 to copy the properties and bindings, but not\nthe resources.  He wants the bindings in the new collection still to \nconnect to the original resources.  So if you did a PUT to an existing\nmember of the new collection, it would affect the member of the old\ncollection.\n\nThis is like a BIND operation with a Depth header.\n\nGeoff: For versioning, there needs to be some COPY semantics that leaves\nthe URIs at the destination still bound to old resources.\n\nJim W: As defined in WebDAV, COPY with Depth: infinity does create new \ncopies of the resources identified by the collection members.\n\nJudy: Using the Depth header to get Geoff's semantics departs too far from\nthe meaning of Depth.  It may be useful to have rebind semantics for COPY\non collections, but don't do it using Depth 1 semantics.  Use a new header.\n\nJim W: We could use a new method or new header. Jim would want a new \nmethod unless we use the Mandatory header.  Without Mandatory, an HTTP \nserver would ignore a new header that it didn't understand.\n\nJim W: What if we said to the versioning folks, if you need a new kind of \nCOPY, you must propose the new method?  Geoff: OK.\n\nDecisions:\nWe will not define semantics for COPY with Depth: 1.\nCOPY with Depth 0 is just as it was defined in Webdav: The collection's\nproperties get copied, but not its bindings.  We could say either\n  1. Bindings are not part of a collection's state for purposes of COPY\nor\n  2. Bindings are part of the collection's state, but they don't get\n     copied.\nWe prefer 2. \n\nChuck: Confirm that a binding is not part of the state of the target\nresource? That's what we intend.\n\nSEMANTICS OF MOVE\n\nYaron is ok with Geoff's proposal that MOVE be BIND+DELETE.  It's what he \nmeant in the first place.\n\nSo MOVE is fundamentally a rename.\n\nDecision:\nDefine MOVE as bind + delete, with an implementer's note that for cross-\nserver cases you can do COPY followed by fixup followed by DELETE.\n\nJudy: They're not really equivalent unless you think that fixup of\nproperty values is included in the fixup step.\n\nRFC 2518 didn't talk about creationdate, etc., on a MOVE.  We might cause \ndebate if we raise this issue.  But clients would appreciate the \nclarification.  Any volunteers to draft something describing the\naffected properties and how they need to be fixed up?  No.\n\nChuck: Clarify how MOVE means bind + delete.  You create a new binding to\nthe resource, then delete the old binding.  Delete is defined to be\nremove the binding in the request-URI.\n\nMOVE is a modification to 2 collections, not a change to the resource \nbeing moved.  Think about what you have to have checked out to do this\nin a configuration management system -- it's the collections, not the\nresource that's being moved.\n\nSEMANTICS OF DELETE\n\nIf we define DELETE to mean remove one binding, we need some way to delete\nthe resource.  We need either a destroy method or a header on DELETE\nspecifying which semantics to use.\n\nGeoff:  We need unbind and destroy.  One of them must be mapped to delete.\nFor versioning, we have to map unbind to delete or else there would\nbe serious consequences: versioning servers would have to fail all DELETE\nrequests and define new unbind and destroy methods. This is undesirable.\n\nBindings are different from direct references, but they have the same\nDELETE semantics we had agreed to for direct references.\n\nPUT to an existing binding affects its target resource, so again this is\nthe behavior we had agreed to for direct references.\n\nBindings force our choices on some cases that were difficult to decide\nfor direct references.\n\nIf a DELETE causes the last binding to be removed, the server can garbage \ncollect if it wants to.\n\nChuck: Won't this be unexpected behavior for down-level clients? \n\nHTTP is unclear about what happens on a DELETE. (They were careful not to \ncommit either way.) Look at Unix hard links for an example of choosing to\nremove the link rather than destroy the file.\n\nThere needs to be some way to destroy the resource.  Should we use a header\nor a new method?\n\nIf we define a header, the server may not understand it. At least it's not\ntoo damaging if the server does the wrong thing.  But if the server only \ndoes an unbind when the client wanted a destroy, the resource is still \nvisible in other locations.  This is a security hole.  The file may have\nbeen a sensitive file that it was really important to destroy.\n\nDELETE is advice to server.  HTTP 1.1 doesn't require the server to destroy\nthe resource.\n\nA DESTROY method would avoid the problem about the server ignoring a\ndestroy header.\n\nWhat if there are other flavors of destroy/delete needed in the future,\nsay by versioning? Will we want yet another method?  We can give clear \nsemantics for DELETE and DESTROY.  \n\nCan we find a better name than destroy? \"liberate\"?  Take the name\nquestion offline.\n\nCan we just use Depth: infinity on a DELETE? Then people will wonder what \ndoes Depth 5 mean.  We need a binary switch. It's also bad separation\nof concerns, since Depth header is currently for use with collections,\nto specify how deep in the collection hierarchy to go.\n\nJim W: Just use the name DESTROY. It's intuitive, and has been discussed \nbefore.  Should we define it in advanced collections or versioning?  \nBetter in collections.  Since we define DELETE, people will feel that we\nneed an answer to the question, how do you do a *real* delete?\n\nGeoff: Semantics of destroy will be remove all bindings, and\nthen servers are free to destroy the resource whenever they choose.  \n\nWill versioning need yet additional semantics?  For example, there are \naggregate resources such that when you destroy them, it destroys more than\none thing.  \n\nDefining DESTROY in advanced collections actually might help settle some \ndiscussions in versioning.\n\nDefine how the depth header works with DESTROY. DESTROY Depth: infinity \nshould work.\n\nChuck: Are bindings different from internal members? No. Every URI for a \nresource is a binding.  PUT creates a resource and a binding.\n\nDELETE is no longer ambiguous.  It removes the binding.\n\nBefore there was usually only one binding to a resource.\n\nChuck: People would have expected resource to go away.  If any server today\nimplemented DELETE to destroy the resource, it would not be in compliance.\n\nJim W: Can we define DELETE to be you must do unbind and may also destroy?\nGeoff: No, the client can't know what will happen then.\n\nJim W: This is like the PUT issue on the mailing list now.  The concern is\nthat users depend on the old definition, or one interpretation of it.  Now\nyou make that illegal and cause interoperability problems.\n\nChuck: HTTP 1.1 appears to require that the server delete the resource.\nJim W talked to Roy about what the intention of HTTP 1.1 was.  The \nassumption was that URI and resource were synonymous, so there was no \ndifference between a binding and a resource.  Really they meant to\ndelete the binding, but didn't have the language to express this.  \n\nJim W: Believes that people more often think delete should mean unbind. \n\nHTTP 1.1 doesn't say that you have to destroy bits.\n\nThe client needs to know what will happen before it makes the call.\n\nDESTROY: Definition should say that it removes all bindings, and stay \nweasly on destroying bits -- the server should intend to free the space.\n\nChuck is ok with this decision.\n\nSERVER-MAINTAINED ORDERINGS\n\nLast week we said we would stick with just client-maintained and see \nwhether the list wants server-maintained.  There was no further discussion\non the list this past week.\n\nJim W will try again to engage the list in a discussion.\n\nGeoff: is neutral on this issue, but would like to keep the spec simple.\n\nJudy: Server-maintained orderings are in the spec now.  It didn't seem\nlike a big deal.  We already had a property that says which ordering is\non a given collection.  We just needed to add something to OPTIONS for\nservers to advertise what orderings they can offer.  Review the current \nspec to see whether it does what the people on the list were asking for.\n\nMKRESOURCE\n\nGeoff didn't send his proposal to the mailing list, so that action item\nis still open.  It will stay MKREF in the spec for now.\n\nJim W supports MKRESOURCE.\n\nJudy: There are several separable parts to the proposal -- whether we want\na generic creation method, whether it should have a PROPPATCH-like body,\nand whether the resource type for the new resource is part of the body or\nin a header.  Geoff: And whether it should overwrite an existing \nresource.\n \nGoeff: The XML body is a critical part of the proposal.  He's not\ninterested in seeing a MKRESOURCE method without it.\n\n\n\n\n\n\n", "encoding": "ascii"}