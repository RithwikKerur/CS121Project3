{"url": "https://www.ics.uci.edu/~alexv/Java.html", "content": "\n<!DOCTYPE HTML SYSTEM \"html.dtd\">\n<HTML CHARSET=\"head\">\n<HEAD>   <TITLE>Mobile code</TITLE>\t</HEAD>\n\n<font color=\"cc9876\">\n<BODY><H2> Speeding up mobile code execution on <br> resource-constrained embedded processors.\n</H2> \n</font>\n\n<p>\nEmbedded platforms are increasingly connected to the Web and are executing mobile code.<br>\nThese platforms are a resource-constrained environment in which interpreted execution<br>\nof mobile codes is the norm and highly-optimized or dynamic compilation systems are not<br>\na suitable choice, primarily due to their high memory requirements.<br>\nAt the same time, the performance of the executed code is of critical importance and<br>\nis often the limiting factor in both the capabilities of the system and user perception.<br>\n</p>\n<p>\nThe goals of this research project were to significantly improve interpreter performance<br>\nfor mobile code on embedded platforms without increasing its resource requirements and to<br>\ndesign a resource constrained basic block dynamic compilation system to be used with an<br>\ninterpreter for adaptive optimization at \"low cost\".<br>\n</p>\n<p>\nThe framework proposed to achieve for both of these goals is based on \"superoperators\" and<br>\ncode \"annotations\".  The former are groups of instructions that can be executed as a unit and<br>\noptimized together.  The latter is a mechanism for passing information from a compiler producing<br>\nmobile code to the interpreter running on a client system.   The proposed approach shifts<br>\nas much of the work of identifying, compiling, and optimizing  superoperators as possible to<br>\nthe compiler and thus both simplifies and speeds up interpreted execution.  This is possible<br>\nbecause the annotations can carry the additional information (otherwise unavailable in the<br>\nmobile code) between the compiler and the interpreter.   Annotations can also reduce delays<br>\nand allow small applets to be optimized with little or no overhead when used with adaptive<br>\ndynamic optimization.  Currently such optimization requires dynamic profiling and incurs<br>\nthe associated overhead.<br>\n</p>\n<p>\nSuperoperators provide two main advantages for optimizing interpreter performance.  They reduce<br>\nthe dispatch overhead of individual bytecodes comprising the superoperator and they allow<br>\nstack-based communication to be converted to a more efficient form using registers.  The<br>\nregisters can be utilized without dynamic compilation if the superoperators are created statically.<br>\nAlternatively, they can be introduced by a simplified dynamic compilation module which is invoked<br>\nwhen specified by an annotation.<br>\n</p>\n<p>\nThe resulting combination of some of the main benefits of JIT compilation, superoperators (SO's)<br>\nand profile-guided optimization delivers a lightweight Java bytecode compilation system for<br>\nresource-constrained environments that achieves runtime performance similar to that of <br>\nstate-of-the-art JIT/Adaptive Optimization systems, while having a minimal impact on <br>\nruntime memory consumption.<br>\n<br>\nFor experimental evaluation, we developed three Virtual Machines (VMs). One deploys <br>\nour proposed techniques. This VM is first compared (w.r.t. runtime performance) <br>\nto a baseline interpreted VM and then to a VM that employs state-of-the-art JIT/AO. <br>\nOur system attains speedups ranging from a factor of 1.52 to a factor of 3.07, w.r.t. to the<br>\nbaseline VM. When compared to a state-of-the-art JIT/AO VM,<br>\nour system achieves performance which is within a factor of two w.r.t JIT/AO.<br>\nIt is actually better for three of the benchmarks and worse by less than a factor<br>\nof 2 for three others. But our SO-extended VM outperforms the JIT/AO system by a factor of<br>\n16, on average, w.r.t. runtime memory consumption.<br>\n</p>\n\n</BODY></HTML>\n", "encoding": "ascii"}