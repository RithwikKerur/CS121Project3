{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/speciallinkedlist.txt", "content": "\tReference Variables in Linked List Processing/Special Linked Lists\r\n\r\n\r\nIntroduction (mostly Special Linked Lists):\r\n\r\nIn this lecture we will first examine the use of references and pointers to\r\npointers to learn alternative ways to write some linked list processing code.\r\nThen we will examine some standard variations to simple linear-linked lists:\r\ncircular, header, trailer, and doubly-linked lists (and combinations of these).\r\nWe will discuss the tradeoffs between using these lists and simple linear-linked\r\nlists. Standard linear-linked lists are used much more often than any of these\r\nvariants, but it is interesting to see what tradeoffs the variants allow:\r\nProgramming Assignment #2 (and some later programming assignments) will involve\r\nusing these variants.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nReferences and Pointers to Pointers\r\n\r\nRecall that if a parameter is passed by reference, the parameter aliases the\r\nstorage location of the argument. We will draw pictures of aliased arguments by\r\nhaving a line (not an arrow, arrows are for pointers) connect the parameter\r\nto the argument (the parameter will not have its own box, it will just show the\r\narrowless line connecting it to the box it aliases). In the code, whenever we\r\nexamine/change a reference parameter we are really examining/changing the\r\nargument passed to it. The parameter is bound automatically to the address of\r\nthe argument and examined/stored by automatic dereferencing the address.\r\n\r\nNote that we often see \"const T&\" as the mode/type of a parameter: that\r\nprovides a fast way to do the equivalent of parameter mode/type \"T\": access an\r\nargument of type T and do not change it: for large chunks of data & is faster\r\nbecause it passes the address of of the argument; it doesn't copy all the values\r\nin the argument (but the const ensures the reference is not used to change the\r\nargument or any part of it). So this mode is fast and safe. For passing \"small\"\r\ntypes (like int), both take the same amount of time, but accessing a value\r\nthrough an address (indirectly) is a bit slower. So, there are efficiency\r\ntradeoffs.\r\n\r\nWe can use references to simplify code for the functions that change linked\r\nlists (e.g., adding/removing values): by writing void functions that do not have\r\nto return a value. Here are the standard void add_front, add_rear, and\r\nremove_lookahead functions, where the pointer to the begining of the linked\r\nlist is passed by reference (but NOT const). We read the mode/type specification\r\nbackwards (right to left) \"LN<T>*& l\" means \"l is a reference to a pointer\r\nto an LN object instantiated with values of type T\".\r\n\r\nIn all these cases, we call these functions like: add_front(x,some_value); they\r\ndo NOT return a result but instead change either x's state (by the reference\r\nmode parameter) or the state of some LN in the linked list x points to. The\r\nonly changes to the code from the original functions that we studied are that\r\nthe parameter l may be changed (meaning the argument matching l may be changed),\r\nand that no value is returned.\r\n\r\ntemplate<class T>\r\nvoid add_front(LN<T>*& l, const T& value) {\r\n  l = new LN<T>(value,l);  //change argument aliased to l\r\n}\r\n\r\ntemplate<class T>\r\nvoid add_rear(LN<T>*& l, cont T& value) {\r\n  if (l == nullptr)\r\n    l = new LN<T>(value); //change argument aliased to l\r\n  else {\r\n    for (LN<T>* p = l; /*see body for termination*/; p = p->next)\r\n      if (p->next == nullptr) {\r\n        p->next = new LN<T>(value);\r\n        break;\r\n      }\r\n  }\r\n}\r\n\r\ntemplate<class T>\r\nvoid remove_lookahead (LN<T>*& l, const T& to_remove) {\r\n  if (l == nullptr)\r\n    return;\r\n\r\n  if(l->value == to_remove) {\r\n    LN<T>* to_delete = l;\r\n    l = l->next;          //change argument aliased to l\r\n    delete to_delete;\r\n  }else{\r\n    for (LN<T>* p = l; p->next != nullptr; p = p->next)\r\n      if (p->next->value == to_remove) {\r\n        LN<T>* to_delete = p->next;\r\n        p->next = p->next->next;\r\n        delete to_delete;\r\n        break;\r\n      }\r\n  }\r\n}\r\n\r\nExamine the first picture accompanying this lecture note. It illustrates how\r\nadd_rear(x,...); works when x is nullptr (on the left) and when x points to a\r\nlinked list (on the right). Again, do some hand simulations to better\r\nunderstand how the reference parameter l is used in the code, following the\r\nrules and graphics for reference parameters.\r\n\r\nFinally, we can get some more leverage from using pointers to pointers in our\r\ncode, although the complexity and extra execution overhead can be higher. The\r\nfollowing function removes a value from a list. It uses p to \"point to a\r\npointer\" and uses a smaller amount of (complicated) code to remove the first LN\r\ncontaining to_remove from the list.\r\n\r\nIn a call remove_ptp(x,5) it starts with p pointing to the storage occupied by\r\nthe variable x. Here is the first example of a pointer that does NOT point to\r\nan object, but instead points to a storage location that points to an object:\r\np will first point to x's storage, and then p will point to the storage of\r\n\"next\" instance variables in the LN (list node) objects in the linked list.\r\n\r\nIn this code, p traverses the linked list until p points to a storage location\r\n(the \"x\" variable or the \"next\" instance variable in some LN object) such that\r\n(*p)->value equals to_remove: in this case the code updates the variable p\r\npoints to; it stores a pointer to the LN beyond the first one storing to_remove.\r\nNote (*p)->value is equivalent to (**p).value.\r\n\r\nHow do we \"advance\" p. We use the & operator to find the address of it argument,\r\ncomputing a pointer to it. So p = &((*p)->next) means, \"go to the location that\r\np points to, and follow that pointer to examine its next instance variable;\r\nthen store a reference (address: pointer to) that instance variable into p\".\r\n\r\nBy using a pointer to a pointer we don't need to use either lookahead or ghost\r\npointers, and there is no special case for removal at the front of the list.\r\nBut, the extra indirection of p pointing to a variable containing a pointer\r\nmakes the code complicated to understand and less efficient to execute.\r\n\r\nYou should still try hand simulating it using pictures, but I consider\r\nunderstanding this code a bit beyond what is required for this course.\r\n\r\ntemplate<class T>\r\nvoid remove_ptp (LN<T>*& l, T to_remove) {\r\n  for (LN<T>** p = &l; (*p) != nullptr; p = &((*p)->next))\r\n    if ((*p)->value == to_remove) {\r\n      LN<T>* to_delete = *p;\r\n      (*p) = (*p)->next;\r\n      delete to_delete;\r\n      break;\r\n    }\r\n}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCircular Linked Lists:\r\n\r\nA circular linked list is a linked list whose rear LN points to its front LN\r\n(so nullptr does not mark the end of the list). It becomes a bit arbitrary to\r\nspeak of a front and rear when these LN nodes are arranged in a circle. A\r\ncircular list may be empty, but if there are LN nodes, none of them have a next\r\ninstance variable storing nullptr. See the pictures of simple circular linked\r\nlists. The one LN version is especially interesting because its next instance\r\nvariable points to itself (since its single node is both its front and rear).\r\n\r\nHere is code to print a circular linked listing by printing the first node,\r\nthe second, ...., the last, and then literally \"...\" to show the nodes continue\r\nin a circle.\r\n\r\ntemplate<class T>\r\nvoid print(LN<T>* cl) {\r\n  if (cl == nullptr) {\r\n     std::cout << \"nullptr\";                      // No nodes at all\r\n     return;\r\n  }\r\n\r\n  std::cout << cl->value;                         // print \"Front value\"\r\n  for (LN<T>* p = cl->next; p != cl; p = p->next) // Loop until \"Front\" again\r\n    std::cout << \"->\" << p->value;                //   Not \"Front\" print it\r\n  std::cout << \"...\"\r\n\r\nThere are a few applications for circular lists. One allows us to represent\r\nand efficiently process a queue by having a single pointer to the \"rear\"\r\nvalue in the queue (instead of one to the front and one to the rear). Note that\r\nin a circular list, the node one beyond the rear is the front, so both the\r\nfront and rear nodes in a queue are easily reached from the rear node: all\r\n\"action\" in a queue takes place at the front (remove) or rear (add). If we\r\npointed to the front node, there could be an arbitrary number of nodes between\r\nit and the rear node, so it would take lots of time to reach the rear node from\r\nthe front; but it takes only one operation to reach the front node from the\r\nrear. So it isn't intuitive, but pointing to the rear node is the right node to\r\npoint to to efficiently process queues represented by circular lists.\r\n\r\nIf rear points to the last node an a queue represented by a circular list,\r\nhere is code to add to the rear of the queue (enqueue). Draw a picture of an\r\nempty list, a circular list with one node, and a circular list with 3-5 nodes\r\nand simulate this code on those lists to see that it is correct.\r\n\r\n  if (rear != nullptr)\r\n    rear = rear->next = new LN<int>(some_value,rear->next);//rear->next is front\r\n  else\r\n    rear = new LN(some_value);       //Make it a 1 node circular list,\r\n    rear->next = rear;               //  pointing to itself; cannot do in 1 line\r\n  }\r\n    \r\nIf rear points to the last node in a queue represented by a circular list,\r\nhere is code to remove the front of the queue. Draw a picture of an empty\r\nlist, a circular list with one node, and a circular list with 3-5 nodes and\r\nsimulate this code on those lists to see that it is correct.\r\n\r\n  if (rear != nullptr) {\r\n    int front_value = rear->next->value;  //Front is after rear (even if same)\r\n    if (rear->next == rear)               //Just 1 node in the list?\r\n      rear = nullptr; \t\t\t  //  Yes, make empty list\r\n    else\r\n      rear->next = rear->next->next;      //  No: rear->next refers to new front\r\n  }   \t\t   \t\t\t  //      the one currently after front \r\n\r\nFor simplicity, this code does not delete the removed LN.\r\n\r\nIf we had to represent a huge number of queues, most of which are empty,\r\nusing a class that stored one pointer to the rear of a circular linked list\r\nwill save space when compared to using a class that stores two pointers to the\r\nfront and rear of a linear-linked list.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHeader Linked Lists:\r\n\r\nA header linked list is a linked list that always contains a special header\r\nnode; an empty header list contains just this one node. The header node stores\r\nno real data (in its value: technically it stores the value computed by the\r\ntype's default constructor); this node exists solely to simplify code that\r\nprocesses linked lists by ensuring that every \"real\" node in the linked list is\r\npreceded (is pointed to) by some node. This guarantee allows us to never have\r\nto change what front points to (it always refers to the header) and therefore\r\nwe do not need any special-case code to handle this (now impossible) option, or\r\nreference parameters, or pointers to pointers (the other ways to simplify this\r\ncode).\r\n\r\nFor example, I originally wrote the following code for adding a value v to the\r\nrear of a linked list (which also caches a pointer to the rear LN)\r\n\r\n    if (front == nullptr)\r\n       front = rear = new LN<int>(v);\r\n    else\r\n       rear = rear->next = new LN<int>(v);\r\n\r\nIf the linked list were a header list, an empty list would have a front and\r\nrear: would both point to the header node (whose ->next is set to nullptr in the\r\nconstructor). We could simplify the codeabove to the following single line of\r\ncode (because front would never store a nullptr)\r\n\r\n    rear = rear->next = new LN<int>(e);\r\n\r\nIn a header list, one never changes front: it always refers to the header.\r\nSo every \"real\" node that we manipulate in the list is guaranteed to have a\r\nprevious node pointing to it (via its next instance variable). This guarantee\r\noften simplifies the code for adding and removing nodes (see the example above),\r\nalthough some other operations (like traversal) might be more complicated,\r\nbecause we must remember to skip the header node. \r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTrailer Linked Lists:\r\n\r\nA trailer linked list is a linked list that always contains a special trailer\r\nnode; an empty trailer list contains just this one node. As with a header node,\r\nthis node stores no real data in its value; this node exists solely to simplify\r\ncode that processes linked lists by ensuring that every \"real\" node in the\r\nlinked list is followed by a node. In \"trailer lists\", every list has a special\r\n(valueless) trailer node at the end. So, an \"emtpy trailer list\" would have one\r\nlist node in it. All \"real\" nodes in the list come before the trailer. By using\r\na trailer node, we can remove a node that we have a pointer to, without\r\nneeding a pointer to the node before it!\r\n\r\nI'll show this \"trick\" in class; hand simulate the following code again to see\r\nhow it works (do it with p pointing to the first, last and middle node in a\r\ntrailer list). Note that the \"last\" real node IN a trailer list (the last one\r\nstoring real data) is the one before the trailer node. This code works correctly\r\nonly if the node p points to is always followed by another node (which is\r\nguaranteed for a trailer list; and p -the node to be removed- must never point\r\nto the trailer itself).\r\n\r\n    LN<T>* to_delete = p->next;\r\n    p->value = to_delete->value;\r\n    p->next  = to_delete->next;\r\n    delete to_delete;\r\n\r\nin fact, in C++ we can collapse the inner two statements into\r\n   *p = *to_delete;\r\n\r\nThe statement *p = *to_delete copies both the instance variables in the LN\r\nto_delete points to into the LN p points to. It uses the = operator to copy\r\nthe contents of one LN<T> to another LN<T>.\r\n\r\nBeing able to remove the value/node referred to by a pointer (without know what\r\nnode is before it), is useful if we are implementing an iterator by pointing to\r\nits current node (the one we might need to erase). Otherwise the cursor for an\r\niterator will have to keep track of the current node and the one before it\r\n(which might be \"none\" if the current node is the first).\r\n\r\nSometimes it is useful to combine header and trailer nodes into one list,\r\nallowing all simple methods (both those simple for header lists and those\r\nsimple for trailer list) to be written simply. The next picture illustrates an\r\nempty header/trailer list and one containing three int values.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDoubly-Linked Lists:\r\n\r\nA doubly-linked list is a non-linear linked list: it contains pointers both to\r\nthe node that comes before (prev) and after (next) it in the linked list. We\r\nwould define such a doubly-linked node (DLN) as\r\n\r\ntemplate<class T>\r\nclass DLN {\r\n  public:\r\n    LN ()\r\n      : prev(nullptr), next(nullptr){}\r\n    LN (const DLN<T>& dln)\r\n      : value(dln.value), prev(dln.prev), next(dln.next){}\r\n    LN (T v, DLN<T>*p = nullptr, DLN<T>* n = nullptr)\r\n      : value(v), prev(p), next(n){}\r\n\r\n    T       value;\r\n    DLN<T>* prev;\r\n    DLN<T>* next;\r\n};\r\n\r\nGiven this definition, we can traverse a doubly-linked list in either direction:\r\nwe can reach any node from any other node. The cost for this flexibility is an\r\nincrease in the space needed to store a doubly-linked list: twice as many\r\npointers in each node (2 instead of 1) and the requirement to change twice as\r\nmany pointers when we mutate the list, e.g., when adding/removing values in\r\nnodes.\r\n\r\nFor example, when we add a node to a doubly-linked list, we need to make\r\nthe next variable of the one before it refer to the new node, and the prev\r\nvariable of the one after it refer to the new node. And in the new node itself,\r\nwe need to set its prev variable as well as its next instance variable.\r\n\r\nThe following method illustrates how to remove a node from a doubly-linked list.\r\nAssume DLN<T>* node_to_remove;\r\n  \r\n    if (node_to_remove->prev == nullptr) // or (front == node_to_remove)\r\n       front = node_to_remove->next;\r\n     else\r\n       node_to_remove->prev->next = node_to_remove->next;\r\n\r\n     if (node_to_remove->next != nullptr)\r\n       node_to_remove->next->prev = node_to_remove->prev;\r\n\r\n     delete node_to_remove;   \r\n\r\nIf the node added is at the front or rear of a doubly-linked list, there are\r\nall sorts of special cases to handle. By having both a header and a trailer\r\nnode in a doubly-linked list, we can simplify this code and remove all the\r\nspecial cases. For example, in a doubly-linked lists with header and trailer\r\nnodes, we can simplify the remove code above to\r\n\r\n     node_to_remove->prev->next = node_to_remove->next;\r\n     node_to_remove->next->prev = node_to_remove->prev;\r\n     delete node_to_remove;   \r\n\r\nBut now, even an empty list has two nodes: the header and trailer, linked to\r\neach other.\r\n\r\nNote that in a doubly-linked list with header and trailer nodes,\r\nnode_to_remove->prev will never be nullptr, and likewise node_to_remove->next\r\nwill never be nullptr; because, node_to_remove will point to a real node, not\r\nthe header or trrailer. But, to create an empty doubly-linked header/trailer\r\nlist requires the following code:\r\n\r\n  front = new DLN<int>()\r\n  front->next = new DLN<int>();\r\n  front->next->prev = front;\r\n\r\nwhich is a bit convoluted.\r\n\r\n\r\nThe overhead and extra complexity of these special linked lists make them more\r\ncumbersome to use than simple linear linked lists, but sometimes we require\r\ntheir extra functionality.\r\n\r\nProbably trailer lists are the most practical of all these special lists, and\r\nwe will use them in some part of out programming assignments.\r\n\r\n\r\nAdded Fall 2018:\r\n\r\nThere is a special data type called a double-ended queue (deque, pronounced\r\nlike \"deck\"). It has a front and rear, and allows pushing/popping at the front\r\n(like a stack) and enqueueing/dequeueing at the rear (like a queue). We can\r\nefficiently implement a deque using arrays or linked lists.\r\n\r\nMy standard 5 data types does not include an implementation of deques.\r\n", "encoding": "ascii"}