{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/if/if.txt", "content": "\t\t\t\tif Statements\r\n\r\n\r\nStatements in Python are like complete imperative sentences in English: each\r\ncommands Python to perform some action. Just as we said that Python evaluates\r\nexpressions, we say that Python executes statements. We already have studied\r\nthe Python assignment_statement and import_statement: both bind names to objects\r\n(and even introduce names into the name space of their module, if they is not\r\nalready there). A function_call and method_call are also statements: typically\r\nthe kinds of functions that we call as statements are commands that have an\r\neffect but return None as a value: the canonical example is the print function.\r\n\r\nWe will classify many statements as control structures: such statements control\r\n(conditionally/by repetition) the execution of other statements. They may even\r\ncontrol other control structures: statements can contain statements just as\r\nexpressions can contain other expressions.\r\n\r\nThe lecture covers how Python makes decisions: it uses boolean expressions to\r\ndecide whether to execute certain blocks of other statements. We will learn\r\nabout blocks and explore their use when discussing if statements, and then use\r\nblocks in many other kinds of statements (including in the definitions of\r\nfunctions). Blocks are all about indentation, so you will build knowledge about\r\nblocks on your knowlege of the indent/dedent tokens. Python is unique among\r\nthe \"popular\" programming languages in its use of indentation to indicate\r\nblocks.\r\n\r\nIn later lectures we will begin learning about about Python's for loop iterator\r\n(definite iteration), while loops (indefinite iteration, including discussion\r\nof the break_statement), and try/except statement (which allows us to handle\r\nraised exceptions that we have started to learn about). When we get this far,\r\nwe will learn how to use Python's while and try/except statements to write the\r\nequivalent of the for loop iterator, which will help us understand all these\r\nlanguage features better.\r\n\r\nWe can summarize our upcomming study with the following EBNF rule, showing the\r\nalternatives for Python statements that we will learn.\r\n\r\n  statement <= assignment_statement |\r\n               import_statement     |\r\n\t       function_call\t    |\r\n\t       method_call\t    |\r\n\t       if_statement         |\r\n\t       for_statement\t    |\r\n\t       while_statement\t    |\r\n\t       break_statement\t    |\r\n\t       try_except_statement\r\n\r\nWe have already discussed the form and meaning of the assignment_statement,\r\nimport_statement, function_call, and method_call. We will soon explore the\r\nform and meaning of the following control structures in detail.\r\n\r\n block     : execute a sequence of statements in order\r\n if        : decide whether/which block to execute\r\n for loop  : repeatedly execute a block (with values chosen from an iterable)\r\n while loop: repeatedly execute a block until a boolean condition is False\r\n break     : terminate execution of any loop (for or while)\r\n try/except: execute a block; if an exception is raised, handle it by executing\r\n             an alternative block\r\n\r\nFinally, we will begin discussing two analysis tools: hand simulation via trace\r\ntables, and statement/block boxing (which is the statement equivalent of oval\r\ndiagrams for expressions). \r\n\r\n------------------------------------------------------------------------------\r\n\r\nBlocks\r\n\r\nblock <= statement\r\n        {statement\r\n        }\r\n\r\nA block is a sequence of one or more statements (any of the ones chosen from\r\nthe EBNF rule above, once we learn each of them). What this EBNF rule cannot\r\nshow, but we will describe, is that all these statements must have the same\r\nindentation: an indent token marks the start of a new block, and a dedent token\r\nmarks the end of the current block.\r\n\r\nSemantically we execute a block by executing, in sequence, each of its\r\nstatements. So the order in which statements appear in a block is exactly the\r\norder tha Python will execute them. The order of statements in a block is\r\nsometimes mandated by their interdependencies: one statement might have to\r\nfinish before another one can start.\r\n\r\nSo, we can now tell a bit more of the truth about modules/scripts: each\r\nmodule/script is a block of statements. Recall the droptime module (shown here\r\nwithout comments for brevity):\r\n\r\n------------------------------\r\nimport prompt\r\nimport math\r\n\r\nheight  = prompt.for_float('Enter height of drop (in meters)')\r\ngravity = prompt.for_float('Enter gravitational acceleration (in meters/sec/sec)')\r\n\r\ntime = math.sqrt(2.*height/gravity)\r\n\r\nprint('Drop time =',time,'secs')\r\n------------------------------\r\n\r\nFirst, remember that all the names from the builtins module are imported\r\n(relevant here is the print function). The first two statements in this block\r\nimport the prompt and math names, binding them to these library modules (which\r\ncontain the functions for_float and sqrt, respectivey). The second two\r\nstatements assign the names height and gravity to float value objects entered by\r\nthe user. The fifth statement assigns to the name time the float value object\r\ncomputed by the expression math.sqrt(2.*height/gravity). The final statement\r\nis a function call that prints the computed value (Python does nothing with the\r\nvalue it returns: None). As stated above, Python executes these statements in\r\nthis order; of course, if we had put the print before the calculation of time,\r\nPython would have raised an exception because time would not exist as a name\r\nwhose value object could be printed. So order is important.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHand Simulation:\r\n\r\nAs programmers, we must be able to analyze our programs to verify that they are\r\ncorrect, or detect where bugs occur (the hard part) and fix them (an easier\r\npart). The most important way to analyze code is to be able to hand simulate it.\r\nThe \"input\" to a hand simulation: \r\n\r\n  (1) Names and the value objects they are bound to initially\r\n      (the initial state)\r\n  (2) A block  (a sequence of statements)\r\n  (3) Values that the user enters to prompts on the console (if needed)\r\n\r\nThe \"output\" to a hand simulation:\r\n  (1) Names and the value objects they are bound to finally, and the contents\r\n      of the console (called the final state)\r\n\r\nDuring a hand simulation we construct a trace table of state-changes for each\r\nstatement executed in the block of code; these include changes to the binding of\r\nnames and changes to the state of the console (what input/output the program\r\nperforms).\r\n\r\nNote we could use the current mechanism we know for hand simulating names in\r\nmodules (labeled names, boxes, arrow, labeled ovals), but it would be too\r\ncumbersome and show too much detail. It is important that we know exactly what\r\nis going on, and can produce such diagrams, but we can abbreviate this\r\ninformation in our trace tables, which allows us to focus on the most important\r\naspects of executing statements.\r\n\r\nHere is a simple example (no input/output) of such a trace table. Assume that\r\nintitially x refers to the object 5 and y refers to the object 8, and the block\r\nto execute is\r\n\r\nx = y\r\ny = x\r\n\r\nIf beginning students are asked to predict what the code does, the most common\r\nresponse is that it swaps the values in x and y (it certainly looks like it\r\ndoes). Let's see what really happens using a trace table (note that a table\r\ncell shows the value bound to a name after Python executes the statement on \r\nits line).\r\n\r\nStatement      |  x  |  y  |  Console\r\n---------------+-----+-----+------------\r\nInitial States |  5  |  8  |\r\nx = y          |  8  |     |\t \t \r\ny = x          |     |  8  |\r\n\r\nOn any given line, we find the current binding of a name on that line (it\r\njust changed) or the first one we find by looking upward from there in its\r\ncolumn.\r\n\r\nSo, we see that the values initially bound to the names are not swapped, but\r\nthat y's initial value ends up being bound to both x and y. In some sense, the\r\nsimplest thing to do with two names is to exchange their values; yet the\r\nintuitive way to write code for this task is incorrect. Don't gloss over this\r\nobservation, because it is very important. The kind of reasoning a programmer\r\ndoes about state changes in code over time is very different from the kind of\r\nreasoning a mathematician does about equations.\r\n\r\nOne correct way to swap the values stored in two names is shown below, along\r\nwith a hand simulation illustrating its correctness (using the same initial\r\nstate).\r\n\r\nStatement      |  x  |  y  | x_init |  Console\r\n---------------+-----+-----+--------+-----------\r\nInitial States |  5  |  8  |        |\r\nx_init = x     |     |     |   5    |\r\nx = y          |  8  |     |        |\r\ny = x_init     |  8  |  5  |        |\r\n\r\nNote how x_init is shown as not existing as a name initially. But x_init plays a\r\ncrucial part in the computation, while Python is executing the statements in\r\nthe block that it is declared in.\r\n\r\n***Aside, we can accomplish this task in Python much more simply by writing\r\n   x,y = y,x but we need to learn about tuples to understand this code,\r\n   and generalize the assignment_statement EBNF rule to allow any number\r\n   of names on the left hand side. We will get there soon.\r\n\r\nAs a final example, let's examine the trace table for a block that does I/O\r\ntoo. Here there are no names in the initial state: the block to execute is\r\nas follows (we assume the prompt module is imported and are concerned only with\r\nthe names below\r\n\r\nx = prompt.for_float('Enter x')\r\ny = x**3\r\nprint(x,'**3 =',y)\r\n\r\n\r\nFinally, when prompted, the user will enter a 5.1 on the console.\r\nStatement                       |      x      |      y      |  Console\r\n--------------------------------+-------------+-------------+------------\r\nInitial States                  |             |             | \r\nx = prompt.for_float('Enter x') |     5.1     |             |  Enter x: 5.1\r\ny = x**3                        |             |   132.651   |\r\nprint(x,'**3 =',y)              |             |             |  5.1 **3 = 132.651\r\n\r\nHere the Console column shows what is on each line (on the first line, the\r\nprompt and the value that the user enters; on the second line the answer). These\r\ntrace tables are certainly a lot of work for such a simple example; but if you\r\ncan easily write such trace tables, you can use them to debug code that has\r\nsubtle errors.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe if_statement\r\n\r\nThe if statement allows us to tell Python under what conidition to execute a\r\nstatement, or how to select which of many statements to execute: it uses\r\nboolean expression(s) to make the decision. There are three different forms of\r\nthe if statement that have names: if, if/else, and cascaded if (using elif and\r\npossible else). Note that if, elif, and else are all keywords in Python (as with\r\nimport, we cannot use them as names that bind to values): we will now learn\r\ntheir meaning. Notice also the placement of the ':' delimiter, which is\r\ncritical in if statements. A ':' is always followed by an indented block of one\r\nor more statements.\r\n\r\nWe will show all forms of the if statement in one complicated EBNF rule (which\r\nform depends on the number of repetitions -0 or more- and the option -included\r\nor discarded).\r\n\r\nNote that the two-dimensional form of control structures is important, as it was\r\nfor block. The blocksmust be indented at least 1 more space than the if, elif,\r\nand else keywords, but the standard identing in Python is 4 extra spaces.\r\n\r\nif_statement <= if expression:\r\n                    block\r\n               {elif expression:\r\n                    block\r\n               }[else:\r\n                    block]\r\n\r\nAs a syntax constraint, expression must result in a boolean value.\r\n\r\n------------------------------\r\n\r\nLet's first look at what we call an if statement, which according to the EBNF\r\nuse 0 repetitions and discards the option. So, it looks simply like\r\n\r\nif expression:\r\n    block\r\n\r\nTwo if statement examples are\r\n\r\nif x < 0:\r\n    x = -x\r\n\r\nif my_number == roulette_number:\r\n    my_wins  += 1\r\n    my_purse += stakes\r\n\r\nSemantically, Python executes an if statement as follows\r\n\r\n  (1) Evaluate the expression (True or False)\r\n  (2) If it is True, execute the block after the :\r\n  (3) If it is False, skip the block after the :\r\n\r\nSo, if the expression evaluates to True in the second example, Python executes\r\nthe block; it executes the block by sequentially executing the two statements\r\nthat comprise the block. If the expression evaluates to False in the second\r\nexample, Python skips the block (executing neither of its statements). So, an\r\nif/else in Python is must like a option in EBNF.\r\n\r\nHow does Python know where the end of the block is? The next line after the\r\nend of a block will have a dedent token before it.\r\n\r\n------------------------------\r\n\r\nNow lets look at the slightly more complicated if/else statement, which\r\naccording to the EBNF use 0 repetitions but includes the option. So, it looks\r\nlike\r\n\r\nif expression:\r\n    block-1\t\t# just a block, numbered 1 for ease of reference\r\nelse:\r\n    block-2\t\t# just a block, numbered 2 for ease of reference\r\n\r\nTwo example if/else statements are\r\n\r\nif x%2 == 0:     # is x is even?\r\n    x = x//2\r\nelse:\r\n    x = 3*x+1\r\n\r\nif x > y:\r\n    min = y\r\n    max = x\r\nelse:\r\n    min = x\r\n    max = y\r\n\r\nNotice the : delimiter after both the expression after if and after the else\r\nkeyword. Anywhere you see a : delimiter, a block follows, and Eclipse will\r\nautomatically indent the next line after one ending in a colon (and it will\r\nindent each other line at the same level of indentation as the previous one).\r\nNotice that the else must be dedented from the block, telling Python the block\r\nis done.\r\n\r\nSemantically, Python executes an if/else statement as follows\r\n\r\n  (1) Evaluate the expression (True or False)\r\n  (2) If it is True, execute block-1, then skip block-2\r\n  (3) If it is False, skip block-1, then execute block-2\r\n\r\nSo in if/else statements, Python always executes one of the two blocks of\r\nstatements that it controls. This is a bit different from the plain if\r\nstatement, which decides whether or not to execute the one block that it\r\ncontrols.\r\n\r\nHow does Python know where the end of the block-1 is? The else: line has a\r\ndedent token; how does Python know where the end of the block-2 is? The next\r\nline will have a dedent token.\r\n\r\nHere is another example of using an if/else. Suppose we bind the name cookies\r\nto the number of cookies we want to ask for: it could be 0, 1, 2, .... Here is\r\nan if/else to ask for that number of cookies gramatically\r\n\r\nif cookies == 1:\r\n    print('May I have 1 cookie?')\r\nelse:\r\n    print('May I have',cookies,'cookies?')\r\n\r\nIf we defined number as the following function (we are getting a bit ahead of\r\nourselves here because we have not studied how to write functions).\r\n\r\ndef number_match(number : int, singular : str, plural : str) -> str:\r\n    if number == 1:\r\n        return singular\r\n    else:\r\n        return plural\r\n\r\nWe could simplify the code above (the if/decision is now in the function) to\r\n\r\nprint('May I have',cookies,number_match(cookies, 'cookie','cookies')+'?')\r\n\r\n------------------------------\r\n\r\nNow lets look at the most complicated cascaded if statement, which according to\r\nthe EBNF use more than 0 repetitions and may include the option. A cascaded if\r\n(or cascaded if/else) decides which one (if any) of many  blocks to execute.\r\nSo, it looks like\r\n\r\nif expression-1:\r\n    block-1\r\nelif expression-2:\r\n    block-2\r\nelif expression-3:\r\n    block-3\r\nelif ...\r\n    ...\r\nelif expression-N:\r\n    block-N\r\n\r\nwithout the final else:   or  (with the final else:)\r\n\r\nif expression-1:\r\n    block-1\r\nelif expression-2:\r\n    block-2\r\nelif expression-3:\r\n    block-3\r\nelif ...\r\n    ...\r\nelif expression-N:\r\n    block-N\r\nelse:\r\n    block-N+1\r\n  \r\nA cascaded if is built from many matching expressions and blocks. An example\r\ncascaded if statement is\r\n\r\nif test_percent >= 90:\r\n    grade = 'A'\r\nelif test_percent >= 80:\r\n    grade = 'B'\r\nelif test_percent >= 70:\r\n    grade = 'C'\r\nelif test_percent >= 60:\r\n    grade = 'D'\r\nelse:\r\n    grade = 'F'\r\n\r\nSemantically, Python executes a cascaded if statement as follows\r\n\r\n  (1) Evaluate expression-1.\r\n  (2) If it is True, execute the block-1 and the cascaded if is finished\r\n      (don't check any more expressions or execute any more blocks in it)\r\n  (3) If it is False, evaluate the expression-2.\r\n  (4) If it is True, execute the block-2 and the cascaded if is finished\r\n      (don't check any more expressions or execute any more blocks in it)\r\n  Continue following rules of this form until some expression evaluates to True\r\n  and its block is executed, or expression-N is evaluated\r\n  (5) If expression-N evalutes to True, execute block-N and the cascaded if is\r\n      finished\r\n  (6) If expression-N evaluates to False and is not followed by else: then\r\n      the cascaded if is finished without executing any block; if it is False\r\n      and is followed by an else:, execute block-N+1 and then the cascaded if is\r\n      finished\r\n\r\nSo in the cascaded if, exactly one block -the one after after the first \r\nexpression to evaluate to True- is executed; if no expressions evaluates to\r\nTrue, either no blocks are executed (no else:) or the block following the else:\r\nis executed.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTrace tables for if statements\r\n\r\nWe can extend our use of trace tables to hand simulations of if statements. We\r\ninclude a special Explanation column to indicate the result of evaluating the\r\nboolean expression, and which block Python executes next. Let's write two trace\r\ntables for hand simulating the first if statement shown above. \r\n\r\nIn all these trace tables, we omit Console because no prompting or printing\r\noccurs in these blocks, but technically these should be in the trace tables.\r\n\r\nStatement\t|  x  |  Explanation\r\n----------------+-----+-------------\r\nInitial State   | -5  |\r\nif x < 0:\t|     |  True: execute next block\r\nx = -x          |  5  |  1st/only block statement; block/if finished\r\n\r\n\r\nStatement\t|  x  |  Explanation\r\n----------------+-----+-------------\r\nInitial State   |  5  |\r\nif x < 0:\t|     |  False: skip the block\r\nx = -x          | -5  |  if finished\r\n\r\n\r\nNext, let's write two trace tables for hand simulating the second if/else\r\nstatement shown above.\r\n\r\nStatement     |  x  |  y  | min | max |  Explanation\r\n--------------+-----+-----+-----+-----+---------------\r\nInitial State |  5  |  3  |     |     |\r\nif x > y:     |     |     |     |     | True: execute next block\r\nmin = y       |     |     |  3  |     | 1st block statement\r\nmax = x       |     |     |     |  5  | 2nd block statement; block/if finished\r\n\r\n\r\nStatement     |  x  |  y  | min | max |  Explanation\r\n--------------+-----+-----+-----+-----+---------------\r\nInitial State |  3  |  5  |     |     |\r\nif x > y:     |     |     |     |     | False: execute block after else:\r\nmin = x       |     |     |  3  |     | 1st block statement\r\nmax = y       |     |     |     |  5  | 2nd block statement; block/if finished\r\n\r\n\r\nWhat is the trace table for this example if the values stored in x and y are\r\nequal? Does it produce the correct result? Can you change the relational\r\noperators to >= and still always get the same result? Can there be two\r\ndifferent ways of getting the same result? \r\n\r\nFinally, let's write a trace table for hand simulating the cascaded if\r\nstatement shown above.\r\n                           test\r\nStatement               | _percent | grade |  Explanation\r\n------------------------+----------+-------+--------------\r\nInitial State           |    73    |       |\r\nif test_percent >= 90   |          |       | False: check next elif expression\r\nelif test_percent >= 80 |          |       | False: check next elif expression\r\nelif test_percent >= 70\t|          |       | True: execute next block\r\ngrade = 'C'             |          |  'C'  | only statement in block; block/if\r\n                                           |  finished\r\n\r\n------------------------------------------------------------------------------\r\n\r\nA clock example\r\n\r\nLet's take a quick look at an interesting task that combines all the statements\r\nthat we have studied. Assume that we have declared the following names for a\r\n\"military\" style clock: e.g., 00:00 represents midnight, 9:03 represents 9:03am,\r\n14:23 represents 2:23 pm, and 23:59 represents 11:59pm.\r\n\r\nAssume that we have defined the names minute and hour to store values that\r\nare appropriate: 0-59 for minute and 0-23 for hour. Finally, assume that the\r\nfollowing code is called once a minute by the operating system; when you study\r\nPython threads in ICS-32 you will learn how to arrange for such an action to\r\noccur repeatedly: such is very useful for animation.\r\n\r\nif minute != 59:\r\n    minute += 1\r\nelse:\r\n    print((hour+1)*'Beep ') # simulate a sound by just printing something\r\n    minute = 0\r\n    if hour != 23:\r\n        hour += 1\r\n    else:\r\n        hour = 0\r\n\r\nEach time the code is called, it advances the clock by one minute (and hour, if\r\nit is the last minute in the current hour) ensuring that minute and hour store\r\nonly legal values; on the hour, the code beeps that many times (once at 1 am,\r\ntwice at 2am, ... 12 times at noon, 13 times at 1pm, ..., and 24 times at\r\nmidnight). Let's write two trace tables for hand simulating this code in two\r\ndifferent initial situations: first at 10:15 (10:15am).\r\n\r\n\r\nStatement          | hour | minute | Explanation\r\n-------------------+------+--------+------------------\r\nInitial State\t   |  10  |   15   |\t \t \r\nif minute != 59:   |      |        | True: execute next block\r\nminute += 1        |      |   16   | block finished; if/else finished\r\n\r\nHere, the minute is incremented by 1, and nothing else happens.\r\n\r\nNow lets write a trace table for the initial situation 22:59 (10:59pm).\r\n\r\nStatement          | hour | minute | Explanation\r\n-------------------+------+--------+------------------\r\nInitial State      |  22  |   59   |\t \t \r\nif minute != 59:   |      |        | False: execute block after else: in if/else\r\nprint(...)         |      |        | 1st statement in block:print beep 23 times\t\r\nminute = 0         |      |    0   | 2nd statement in block\r\nif hour != 23:     |      |        | True: execute next block\r\nhour += 1          |  23  |        | block finished; inner if/else finished, and\r\n                                   |   outer if/else finished\r\n\r\nHere, much more happens: the clock beeps 23 times (for 11:00pm) and the minute\r\nis reset to 0, while the hour advances to 23. \r\n\r\n------------------------------------------------------------------------------\r\n\r\nPragmatics\r\n\r\nWhen writing decisions, we should first try to determine the correct form we\r\nneed: if, if/else, or cascaded if. If we are unsure about which one is correct,\r\ntry the simplest forms first. If one doesn't work, the knowledge we gain will\r\nhelp us with subsequent decisions. Of course we must indent the blocks correctly\r\notherwise Python will not execute the code (it will raise a SyntaxError \r\nexception.\r\n\r\nThe key to understanding an if statement is understanding its boolean\r\nexpression(s). Ensure that for some bindings of its names, every test can\r\nevaluate to True, and for other bindings False (otherwise -if the expression is\r\nalways True or always False, the expression is probably wrong). For example,\r\nwhat is wrong with the following code?\r\n\r\nStudy it carefully and hand simulate it for a few different values of x.\r\n\r\nif x > 2 || x < 5:\r\n    x += 1\r\n\r\nIs this test really the right one? probably not: no int value bound to x makes\r\nthe test False; try to find one. If this test were the one we really wanted, we\r\ncould simplify this code by removing the whole if statement, simplifying it to\r\njust x += 1, which always performs this action (since the test would always be\r\nTrue).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nBoxing blocks and if_statements\r\n\r\nBoxing statements illustrate which statements are controlled by which others.\r\nThis process is similar to drawing oval diagrams to analyze expressions. In a\r\nstatement boxing diagram, everything that is a statement or a block is placed\r\nin its own box. See the link to today's lecture to see a boxing diagram of the\r\nclock code above. It shows quite a lot of detailed information about these\r\nstatements.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunctions:\r\n\r\nHere is a simple function that computes the minimum of the arguments passed to\r\nits parameters. Again, we will learn all the details bout functions soon, but\r\nthis minimum function illustrates how an if statement can be used in a function.\r\nNotice that the function header ends with a : and what follows (similar to what\r\nwe know about what follows : in if statements) is a block; each block in the if\r\nis just a single returns statement (which we will learn about when we study\r\nfunctions, but basically it says the function is finished and the expression\r\ncoming fater return is the value of the function).\r\n\r\ndef minimum(i,j):\r\n    if i < j:\r\n        return i\r\n    else:\r\n        return j\r\n\r\nprint( minimum(3,5) )\r\n\r\nwould print 3.\r\n\r\nLikewise we could define the function get_grade using a cascaded if statement.\r\nCopy and past this code into a script and run it.\r\n\r\ndef compute_grade(test_percent):\r\n    if test_percent >= 90:\r\n        return 'A'\r\n    elif test_percent >= 80:\r\n        return 'B'\r\n    elif test_percent >= 70:\r\n        return 'C'\r\n    elif test_percent >= 60:\r\n        return 'D'\r\n    else:\r\n        return 'F'\r\n\r\nimport prompt\r\nscore = prompt.for_int('Enter student score')\r\nprint('Student grade =', compute_grade(score))\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems\r\n\r\n(1) Assume that we define grade to bind to  a single letter string corresponding\r\nto a UCI grade: 'A', 'B', 'C', 'D', or 'F'. Write an if statement that computes\r\nthe number of quality points for that grade and stores it in the name qp: an A\r\nis worth 4, a B is worth 3, a C is worth 2, a D is worth 1, and an R is worth 0.\r\n\r\n(2) Assume that we define hours bound to an int. Write an if statement that\r\ncomputes the pay (in cents) due a worker according the following formulas:\r\n625*hours if the hours worked is less than or equal to 40; 625*Hours + \r\n725*(hours-40) if the hours worked is greather than 40. Store the result in the\r\nname cents_pay. Try a few examples under, at, and over 40 hours to verify your\r\nif statement is correct.\r\n\r\n(3) Assume that we defined two names x and y and bind them to int valuse. Write\r\na trace table for the hand simulation of the following Python statements: one\r\nwhere x binds to 3 and y binds to 5; and another where x binds to 5 and y binds\r\nto 3. State whether the results are the same or different in each case.\r\n\r\nif x < y:              if x < y:\r\n    is_it = True           is_it = True\r\nelse:                  is_it = False\r\n    is_it = False;\r\n\r\nWhich statement (left or right) is equivalent to the assignment statement\r\n\r\nis_it = (x < y)\r\n\r\n(4) Assume that the names student_answer and correct_answer are bound to strings\r\nand wrong_count is bound to anb int value. Explain what is wrong with the\r\nfollowing if/else statement (there is a syntax error).\r\n\r\nif student_answer == correct_answer:\r\nelse:\r\n    wrong_count += 1\r\n\r\nExplain how to fix this problem in a simple way.\r\n\r\n(5) Modify the cascaded if for computing grades, so that grade stores '?' if\r\ntest_percent is outside the range 0 to 100 inclusive.\r\n\r\n(6) Write a trace table for the clock code, if the clock starts at 11:59pm (one\r\nminute before midnight).\r\n\r\n(7) Assume that we define the name s to refer to a float value. Write a\r\ncascaded if statement that binds to signum the value -1, if s is less than\r\n0., 0. if x is equal to 0., and 1. if s is greater than 0.\r\n\r\n(8) Assume that we define the names min, x, and max and bind them to float\r\nvalues. Write a cascaded if statement that stores into x the value min if x\r\nis less than min; max if x is greater than max; nothing new otherwise (leave its\r\nvalue untouched).\r\n\r\n(9) Assume that we defined the names  x, y, and z and bound them to ints. Write\r\nan if statement that stores into min the minimum of the values stored in x, y,\r\nand z. Try to do this with the smallest amount of code.\r\n\r\n(10) Re-examine the cascade if that computes a course grade. Show neither of the\r\nfollowing scripts is equivalent to it (find values for test_percent that lead\r\nto differt results stord in grade)? The left side shows a cascaded if; the\r\nrights side shows a block of if and an final if/else. The look OK but are not.\r\n\r\nif test_percent >= 60:          if test_percent < 60:\r\n    grade = 'D';                    grade = 'F';\r\nelif test_percent >= 70:        if test_percent < 70:\r\n    grade = 'C';                    grade = 'D';\r\nelif test_percent >= 80:        if test_percent < 80:\r\n    grade = 'B';                    grade = 'C';\r\nelif test_percent >= 90:        if test_percent < 90:\r\n    grade = 'A';                    grade = 'B';\r\nelse:                           else:\r\n    grade = 'F';                    grade = 'A';\r\n\r\nWhat simple changes would correct each?\r\n\r\n(11) Suppose that we modify the clock code to print the beeps at the bottom of\r\nits block, and also change its argument to just hour. Will this code always\r\nwork as before? If not, for what hour and minute combination(s) will it fail?\r\n\r\nif minute != 59:\r\n    minute += 1\r\nelse:\r\n    minute = 0\r\n    if hour != 23:\r\n        hour += 1\r\n    else:\r\n        hour = 0\r\n    print(hour*'Beep ') # simulate a sound by just printing something\r\n\r\nNote that to be correct, the code must be correct for every hour and minute.\r\nThere are 24x60 = 1,440 different possiblities; which ones are crucial to check?\r\nSuppose that we modify the clock code as follows. Will this code always work as\r\nbefore? If not, for what hour and minute will it fail?\r\n\r\nminute += 1\r\nif minute == 60:\r\n    minute = 0\r\n    hour += 1\r\n    print(hour*'Beep ') # simulate a sound by just printing something\r\n    if hour == 24:\r\n        hour = 0\r\n\r\nNote that to be correct, the code must be correct for every hour and minute.\r\nThere are 24x60 = 1,440 different possiblities; which ones are crucial to check?\r\n\r\n(12) Box the code at the bottom of problem (11)\r\n\r\n(13) Assume that we define hour binding an int between 0 and 23 inclusive.\r\nWrite an if statement(s) to display on the console the hour in a standard\r\nformat: e.g., when hour stores 3 display 3am; when hour stores 15 display 3pm.\r\nWhen hour stores 0 display 12midnight and when hour stores 12 display 12noon.\r\nTry to do this with the simplest possible code\r\n", "encoding": "ascii"}