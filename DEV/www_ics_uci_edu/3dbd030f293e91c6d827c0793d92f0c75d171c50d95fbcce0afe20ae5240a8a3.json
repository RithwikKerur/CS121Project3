{"url": "https://www.ics.uci.edu/~kay/courses/141/init.txt", "content": "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;                                         ;;;\n;;;  file init.scm                          ;;;\n;;;  ICS 22 Scheme lab assignment file      ;;;\n;;;                                         ;;;\n;;;  Revised and tested for Windows NT by   ;;;\n;;;    Li-Wei (Gary) Chen                   ;;;\n;;;                          Summer 1998    ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n;; Redefine \"car\" and \"cdr\" for clarity\n(define first car)\n(define rest cdr)\n\n;; Define atom? in terms of pair?\n(define atom?\n    (lambda (x)\n      (not (pair? x))))\n      \n;; Define some math functions for fun\n(define (fact n)\n    (cond\n     ((<= n 0) 1)\n     ((= n 1) 1)\n     (else (* n (fact (- n 1))))))\n(define pi \n3.14159265358979323846264338327950288419716939937510582097494459230781620628620862)\n \n\n; Here is some code to output rational numbers as inexact, fixed-point\n; decimals, instead.\n\n;; Construct the numeral for the correctly rounded\n       ;; approximation to num, then (if necessary) pad it on the\n       ;; left with spaces until it is field-width columns wide.\n\n       (define (output-fixed-point num field-width fraction-length)\n         (pad-on-left (rounded-numeral num fraction-length)\n                      #\\space\n                      field-width))\n\n       ;; To construct the numeral for a real number, rounded to a\n       ;; specified number of places after the decimal point:\n       ;;\n       ;; (1) If fraction-length is zero, so that no decimals\n       ;; should appear, just round off the number and push it\n       ;; through number->string.\n       ;;\n       ;; (2) Otherwise, determine the sign, separate the integer\n       ;; part of the number's absolute value from its fractional\n       ;; part, multiply the fractional part by the power of ten\n       ;; that will push the required number of decimal places to\n       ;; the left-hand side of the decimal point, and round it\n       ;; off.  Check whether this generates a carry; if so, the\n       ;; integer part should be one larger and the digits after\n       ;; the decimal point should be 0.  Call the empoint\n       ;; procedure to put the pieces of the numeral together and\n       ;; attach the sign.\n\n       (define (rounded-numeral num fraction-length)\n         (if (zero? fraction-length)\n             (number->string (inexact->exact (round num)))\n             (let* ((sign (if (negative? num) \"-\" \"\"))\n                    (abs-num (abs num))\n                    (integer-part\n                     (inexact->exact (truncate abs-num)))\n                    (fractional-part\n                     (- abs-num integer-part))\n                    (frac-multiplier\n                     (expt 10 fraction-length))\n                    (postpoint\n                     (inexact->exact \n                      (round (* fractional-part\n                                frac-multiplier)))))\n               (string-append\n                sign\n                (if (= postpoint frac-multiplier)\n                   (empoint (+ integer-part 1) 0 fraction-length)\n                   (empoint integer-part postpoint fraction-length))))))\n\n       ;; Given an integer to print to the left of a decimal point\n       ;; and an integer representing a decimal fraction to print\n       ;; to the right of a decimal point, convert both to strings\n       ;; and pad the latter on the left with enough zeroes to\n       ;; bring it up to the specified fraction-length, then\n       ;; concatenate the strings, inserting a decimal point\n       ;; between them.\n\n       (define (empoint int frac fraction-length)\n         (string-append (number->string int)\n                        \".\"\n                        (pad-on-left (number->string frac)\n                                     #\\0\n                                     fraction-length)))\n\n       ;; To pad a string on the left with copies of a specified\n       ;; character in order to bring it up to a specified minimum\n       ;; length, check whether any padding is needed, and if it\n       ;; is, prepend a string consisting of copies of the pad\n       ;; character and equal in length to the difference between\n       ;; the specified minimum length and the current length.\n\n       (define (pad-on-left str pad-char desired-length)\n         (let ((len (string-length str)))\n           (if (<= desired-length len)\n               str\n               (string-append (make-string (- desired-length len)\n                                           pad-char)\n                              str))))\n\n\n", "encoding": "ascii"}