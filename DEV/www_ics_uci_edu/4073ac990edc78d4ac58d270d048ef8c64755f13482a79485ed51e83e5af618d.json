{"url": "https://www.ics.uci.edu/~eppstein/261/s13-hw3-answers.txt", "content": "CS 261, Spring 2013, Homework 3 Solutions\n\n\n1. Suppose you have two Bloom filters FA and FB (each having the same\nnumber of cells and the same hash functions) representing the two sets A\nand B. Let FC = FA & FB be the Bloom filter formed by computing the\nbitwise Boolean and of FA and FB.\n\n(a) FC may not always be the same as the Bloom filter that would be\nconstructed by adding the elements of the set (A intersect B) one at a\ntime. Explain why not.\n\n    Because an element of A \\ B (the elements that belong to A but not\n    B) and another element of B \\ A may both map to the same cell of the\n    Bloom filter; if they do, that cell will belong to FC even if it is\n    not covered by any element of the set intersection. For instance, if\n    A and B are the single-element sets {a} and {b}, and some cells are\n    covered by both a and b, then those cells will be nonzero in FC even\n    though the correct Bloom filter for (A intersect B) has all cells\n    zero.\n\n(b) Does FC correctly represent the set (A intersect B), in the sense\nthat it gives a positive answer for membership queries of all elements\nin this set? Explain why or why not.\n\n    Yes. Every element in (A intersect B) will have all its cells nonzero\n    in both FA and FB, so they will all be nonzero in FC.\n\n\n2. Suppose that we want to store a set S of n = 20 elements, drawn from\na universe of U = 10000 possible keys, in a Bloom filter of exactly N =\n100 cells, and that we care only about the accuracy of the Bloom filter\nand not its speed. For this problem size, what is the best choice of the\nnumber of cells per key (the parameter k in the lecture)? (I.e., what\nvalue of k gives the smallest possible probability that a key not in S\nis a false positive?) What is the probability of a false positive for\nthis choice of k?\n\n   I think the easiest way to solve this problem is computationally.\n   The probability that a cell is missed is (1-1/100)^{20k},\n   so the probability that it is hit is (1 - (1-1/100)^{20k}) and\n   the probability of a false positive is (1 - (1-1/100)^{20k})^k.\n   The Python expression\n   \n   min(((1-(1-1./100)**(20*k))**k,k) for k in range(1,30))\n\n   gives the answer (0.09286327705662296, 3): that is, setting k=3 gives\n   false positive probability approximately 0.0929. (k=4 is worse, but\n   only slightly worse: its false positive probability is approximately\n   0.0932.)\n\n   For values of k greater than or equal to 30, the probability that\n   there exists a missed cell is at most 100 (1-1/100)^{20k} < 0.25, and\n   if there is no missed cell then there is definitely a false positive,\n   so the probability of a false positive is at least 0.75, clearly not\n   the minimum possible. So it's safe to terminate the computational\n   search for the best k at k=30.\n\n   It would also have been ok to derive the answer mathematically rather\n   than computationally, but doing this exactly (rather than resorting\n   to approximations) seems more difficult than the computational\n   approach.\n\n\n3. Recall that the MinHash sketch stores the k elements of a set that\nhave the smallest hash values (for a parameter k that determines the\naccuracy of the sketch, and for a fixed hash function that is used for\nall such sketches). Suppose that we wish to compute the MinHash sketch\nfor a set S of n elements, where n is so big that S does not fit into\nmain memory, and can only be accessed as a data stream. Design an\nalgorithm for computing the sketch using only an amount of storage\nsufficient to hold O(k) set elements or their hash values, in a single\npass over the data, in total time O(n).\n\nYou may assume that each evaluation of the hash function takes time\nO(1). You may also find it helpful to recall that the xth largest\nelement of a set of y values can be computed in time O(y) (this is\ncalled \"linear time selection\"). You should not assume that k is a\nconstant that can be omitted from O-notation.\n\n   The intended answer is to keep a buffer of at most 2k elements\n   that is guaranteed to contain the k smallest elements seen so far.\n   For each element in the data stream, we add it to the buffer, and\n   then when the buffer size reaches exactly 2k we cut it back down\n   to k by doing a single linear time selection computation. There\n   are O(n/k) selection steps, each taking time O(k), so the total\n   time is O(n). When we reach the end of the stream, we need one\n   more selection step to find the k smallest keys overall.\n\n   A Java implementation of a randomized variation of this answer\n   can be found at http://www.ics.uci.edu/~eppstein/161/KBest.java\n   \n   Probably there are other ways of achieving the same bounds.\n   Answers that use a priority queue are generally not good enough\n   (they take time O(n log k) rather than O(n)). Applying the\n   linear time selection algorithm to the whole data set is\n   also not good enough: it takes O(n) time but also uses O(n) space.", "encoding": "ascii"}