{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/Functions/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Python Background Notes: Functions</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Python Background Notes: Functions</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Functions and abstraction</p>\r\n\r\n<p>We've seen already that Python includes a collection of <i>functions</i> built into the language, such as <b>type()</b>, <b>len()</b>, and constructors such as <b>int()</b> and <b>str()</b>.  The ones we've seen so far have been pretty fundamental &mdash; in the sense that they mainly don't do jobs that we could have done in some other way in Python, but instead provide baseline functionality that we need in order to do bigger things.  Fundamental functions like these are a good place to start, but we can achieve more with functions than just fundamental things; certainly, not all functions are fundamental.</p>\r\n\r\n<p>The key benefit a function provides in a design is <i>abstraction</i>.  Abstraction is hiding complexity beneath a veil of simplicity.  It takes something that might be quite complex and makes it easy to use, so that you don't have to know every detail of how it works in order to use it.  To use an abstraction, you need to understand how to interact with it &mdash; what you have to do, and what result or effect you expect to get back in return &mdash; but not how it works.  For example, imagine you do something like this in the Python shell.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>name = 'Alex'</b>\r\n&gt;&gt;&gt; <b>len(name)</b>\r\n4\r\n</pre></blockquote>\r\n\r\n<p>When you do this, it's not important that you understand <i>how</i> the <b>len()</b> function is able to determine the string's length.  Maybe there's a <b>while</b> loop in the <b>len()</b> function that counts characters.  Maybe the length is just an integer stored in another variable, hidden behind the scenes somewhere.  Maybe the operating system or the underlying hardware has some mechanism for tracking it.  Whatever the implementation details are, all you need to know is that some objects in Python have a length, and if you call the <b>len()</b> function, you obtain that length.  That's it.</p>\r\n\r\n<p>So, if functions are such a powerful device for hiding complexity, it stands to reason that we should be want to write our own functions, too.  If Python can provide us built-in functions that make certain commonly-done tasks easier, that's nice in itself.  But if we can write our own functions, we can take the complexity that arises in our own designs &mdash; things that aren't so common that everyone who writes Python programs would need them, but that are instead specific to the program we're writing &mdash; and neatly hide it away.  In small, simple programs, this probably isn't that big of a deal.  But most software isn't just written once and thrown away, but is instead built and maintained over a long of period of time, often by many different people.  So we need a way to allow someone to work on one part of the program without accidentally introducing problems into other parts of it; if someone has to remember every detail of a 50,000-line program in order to successfully change any detail about it, no one will ever be able to change it successfully.  Isolating indivdual portions of our program from one another as much as we can is the only way we can build large programs that stand the test of time.  Functions are the most primary tool to achieve that isolation.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Writing functions</p>\r\n\r\n<p>We can introduce a new function into a Python program by using a statement called <b>def</b>.  (The word <b>def</b> is short for <i>definition</i> or <i>function definition</i>.)  Like everything else in Python, you can do this in the Python shell, though we'll much more often do it in scripts.</p>\r\n\r\n<p>A <b>def</b> statement is a compound statement, the way that <b>if</b> statements and loops are compound; <b>def</b>s have other statements inside of them.  The syntactic mechanism for expressing this is the same: We write a colon at the end of the first line of the <b>def</b>, then use indention to indicate what other statements are meant to be inside of it.</p>\r\n\r\n<p>So what might you need to say in order to define a function?  Let's consider how you call a function.  (Calling a function is what you do when you want to use it.  When you define it, you want it to be ready to be used, so there's a correspondence between how you use it and what you might say in order to define it.)</p>\r\n\r\n<ul>\r\n  <li>When you call a function, you specify its name.  If you were to define a function, then, you would expect that you would need to give it that name, so you could call it later.</li>\r\n  <li>When you call a function, you can pass <i>arguments</i> to it.  Defining a function will require specifying what arguments the function needs in order to do its job.</li>\r\n  <li>When you call a function, you get back a <i>return value</i> when it finishes running; it gives you an answer.  Defining a function will require us to say how that return value is determined.</li>\r\n</ul>\r\n\r\n<p>As a first example, we could define a function <b>gimme_five</b> in the Python shell.  Suppose that our intent is to be able to call it by passing it no arguments and, no matter what, it will always return the integer 5.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>gimme_five()</b>\r\n5\r\n</pre></blockquote>\r\n\r\n<p>How do we achieve that intent?  Here's the definition of that function, followed by a call to it.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>def gimme_five():\r\n        return 5</b>\r\n\r\n&gt;&gt;&gt; <b>gimme_five()</b>\r\n5\r\n</pre></blockquote>\r\n\r\n<p>Let's unpack this syntax a bit:</p>\r\n\r\n<ul>\r\n  <li>The word <b>def</b> is a way of saying you've started to define a function.</li>\r\n  <li>Immediately after that is the name of the function; in this case, that name is <b>gimme_five</b>.</li>\r\n  <li>Immediately after that are a pair of parentheses, in which we define the function's <i>parameters</i>.  If arguments are what you pass to a function when you call it, parameters are, correspondingly, where those arguments are passed.  If you pass three arguments to a function, there would need to be three parameters in the function to accept them.  In our case here, we didn't want to have to pass any arguments, so we have no parameters; nonetheless, the parentheses are necessary.</li>\r\n  <li>Immediately after the parameters appears a colon, followed by the function's <i>body</i>, beginning on the next line (and indented).  The body of a function is a sequence of statements that will be executed when the function is called.  You'll notice, in this case, that we have a statement called <b>return</b> in the body; that statement is a way to say \"When you reach this statement, exit the function and give back this return value to whoever called it.\"  The word <b>return</b> is followed by an expression, which will be evaluated; whatever that expression's value is, that's what will be returned from the function.</li>\r\n</ul>\r\n\r\n<p>Calling a function that returns an integer, like this one, is a lot like any other expression that returns an integer.  This means you can take that integer and do whatever you'd like with it: print it, store it in a variable, use it in an arithmetic expression, and so on.  Every time the function is called within an expression, its body is executed, and its return value becomes the value of that call within the expression.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>print(gimme_five())</b>\r\n5\r\n&gt;&gt;&gt; <b>x = gimme_five()</b>\r\n&gt;&gt;&gt; <b>x + 10</b>\r\n15\r\n&gt;&gt;&gt; <b>gimme_five() + (gimme_five() * 3)</b>\r\n20\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">The difference between a function and a function call</p>\r\n\r\n<p>I should point out, too, that calling a function requires the parentheses, even if you're not passing any arguments to it; it's the parentheses that establish that you want to call it.  That doesn't mean you can't evaluate <b>gimme_five</b> without the parentheses in the Python shell, but you should be aware that you would be doing something very different: Its result would be the function itself, as opposed to the result you'd get from calling it.  Functions, as it turns out, are objects, just like strings, ints, bools, and so on; their type is <b>function</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>gimme_five</b>\r\n&lt;function gimme_five at 0x000001E5497A16A8&gt;\r\n&gt;&gt;&gt; <b>type(gimme_five)</b>\r\n&lt;class 'function'&gt;\r\n</pre></blockquote>\r\n\r\n<p>(The funny-looking value 0x000001E4497A16A8 is an address in memory; you might find, if you try the same thing, that you get a different address than I did.  For the most part, we're unconcerned about addresses in memory when we write Python code; we care about two addresses being equal or different sometimes, but not so much about specifically what their values are.)</p>\r\n\r\n<p>The implications of functions themselves being objects are more powerful than you might at first realize, but that's a conversation we'll return to later.  For now, you should be aware that you need parentheses both around the arguments when you call a function <i>and</i> around the parameters when you define them, even when there aren't any arguments or parameters.</p>\r\n\r\n<p class=\"subtitle\">Parameters and arguments</p>\r\n\r\n<p>More often than not, the functions you write will need parameters.  Functions are each intended to do a job; quite frequently, it takes some kind of input for the function to know what job you want done, so you'll need to pass arguments to it (and the function will need parameters to accept those arguments).  The <b>print()</b> function needs arguments because it needs to know what you want printed; the <b>int()</b> function needs an argument because it needs to know what value you want to attempt to convert to an integer; and so on.</p>\r\n\r\n<p>If you want to write a function that accepts arguments, you'll need to define the corresponding parameters.  You'll also need them to have names, because you'll need to refer to them within the body of the function.  Parameters are a lot like variables, in the sense that their job is to store an object and allow it to be used later.  The difference is that they are more temporary than the variables we've seen so far; they live only as long as the function is executing, then they're destroyed.</p>\r\n\r\n<p>Suppose you wanted to write a function that takes a number and tells you its square (i.e., the result of multiplying that number by itself).  After you've written the function, you might expect to be able to do this.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>square(3)</b>\r\n9\r\n</pre></blockquote>\r\n\r\n<p>How you would write that function is similar to how we wrote <b>gimme_five()</b> above, with the main difference being that we'll need to define one parameter (to accept the number that we want squared), and then we'll need to use that parameter within the body of the function (so we can square it).</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>def square(n):\r\n        return n * n</b>\r\n\r\n&gt;&gt;&gt; <b>square(3)</b>\r\n9\r\n&gt;&gt;&gt; <b>square(5.5)</b>\r\n30.25\r\n</pre></blockquote>\r\n\r\n<p>Defining a parameter in a function is as simple as listing the parameter's desired name within the parentheses after the function's name; this is enough to establish its existence.  You can define multiple parameters by simply separating their names with commas.  (If you've previously written programs in a language like Java or C++, you might wonder why you don't need to specify parameters' types.  There is no explicit restriction on what type of value can be passed into a parameter, similar to how there is no restriction on what type of value can be stored in a variable.)  Once you've defined a parameter, you're free to use it within the body of the function by simply specifying its name.</p>\r\n\r\n<p>When you call a function, the arguments are matched to the parameters in the order specified, with the first argument passed into the first parameter, the second argument passed into the second parameter, and so on.  (If the number of arguments doesn't match the number of parameters, an error will occur.)  The body of the function is then executed, with the values of the parameters being whatever was passed into them.  So, in the case of the call <b>square(3)</b> above, the following things happen.</p>\r\n\r\n<ul>\r\n  <li>The integer 3 is passed to <b>square</b>.</li>\r\n  <li><b>square</b>'s first parameter, <b>n</b>, is given the value 3.</li>\r\n  <li><b>n * n</b> is calculated within the body of <b>square</b>.  Since the value of <b>n</b> is 3, <b>n * n</b> is 9.</li>\r\n  <li>Since <b>n * n</b> is the expression in a <b>return</b> statement, the integer 9 is returned from the function.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Type errors</p>\r\n\r\n<p>Even though the types of the parameters are not explictly specified, there is nonetheless an assumption being made within the body of the function about their types.  By virtue of what we do with those parameters within the function, a particular type of argument might be compatible or incompatible with it.</p>\r\n\r\n<p>For example, the <b>square()</b> function we wrote above is making an implicit assumption, even if we didn't say it directly in the code we wrote.  The value of <b>n</b> has to be something that can be multiplied by itself.  This means that <b>n</b> could certainly accept an integer or a float &mdash; because you can certainly multiply numbers by numbers &mdash; but could not accept a string.</p>\r\n\r\n<p>However, even though our <b>square()</b> function can't successfully process a string argument that you pass to it, it is still possible for a Python program to run with this line of code in it.</p>\r\n\r\n<blockquote><pre>\r\nsquare('Boo')\r\n</pre></blockquote>\r\n\r\n<p>The program would still be syntactically legal Python, so it would still be possible for it to run.  However, it wouldn't necessarily run <i>successfully</i>; the function <b>square</b> will fail, at run time, when it's called with an argument that can't be multiplied by itself.</p>\r\n\r\n<p>We can see this in the Python shell by trying to call it that way.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>square('Boo')</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;\r\n    square('Boo')\r\n  File \"&lt;pyshell#2&gt;\", line 2, in square\r\n    return n * n\r\nTypeError: can't multiply sequence by non-int of type 'str'\r\n</pre></blockquote>\r\n\r\n<p>A couple of interesting facts emerge from this example.</p>\r\n\r\n<ul>\r\n  <li>This kind of failure is the same as other kinds of failure we've seen before, such as dividing by zero or trying to convert a string to an integer when it doesn't contain digits.  Aside from syntax errors &mdash; code that is structurally incorrect Python, such as an <b>if</b> statement without a colon in the right place, or not following the indention rules correctly &mdash; all error-checking is done at run-time, and it is all reported (and, ultimately, handled) the same way.</li>\r\n  <li>Tracebacks don't only tell us where the error occurred.  Notice that we saw two different lines of code listed in the traceback this time: the line of code in the <b>square()</b> function (which is where the failure occurred, trying to multiply two strings together), as well as the line of code where the <b>square()</b> function was called.  This is why they're called \"tracebacks,\" because we're \"tracing back\" through the entire chain of function calls that have led to where we are now.  That can give us a lot of evidence to use when we're trying to understand why something failed.</p>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Docstrings</p>\r\n\r\n<p>The body of a Python function can begin with a <i>docstring</i>, which is a string literal that describes &mdash; to a human reader &mdash; how a function works.  The best docstrings briefly describe what the function's job is, along with anything that one would need to know about its parameters, its return value, and the ways in which it might fail.  What you'll find, generally, is that the need to write a long, complex docstring is actually indicative of a function that is solving too many problems; functions that have a single responsibility will tend to have short docstrings, for the simple reason that there won't be that much to say about them.</p>\r\n\r\n<p>Writing a function with a docstring is as simple as beginning its body with a string literal.</p>\r\n\r\n<blockquote><pre>\r\ndef square(n):\r\n    'Computes the square of a numeric argument'\r\n    return n * n\r\n</pre></blockquote>\r\n\r\n<p>When you write functions in this course, you'll generally want to write a docstring, both to communicate your design goals to us, but also to ensure that you're thinking about them yourself.  If you can't figure out what to write in a docstring, how can you understand what function you're trying to write?  How will you know when you're done?</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Writing functions in Python scripts</p>\r\n\r\n<p>Aside from when we're experimenting, most of the functions we write in Python will be written in Python scripts.  Functions allow us to take complexity in our program and \"hide\" it &mdash; not in the sense that the complexity can't then be seen, but in the sense that we can then call the function without considering every small detail of how it works.  Where this kind of thing pays off is when we're writing programs that we can use again and again, so it stands to reason we would tend to benefit from this when we're writing scripts.</p>\r\n\r\n<p>We write functions in Python scripts the same way we do in the Python shell, by writing <b>def</b> statements.  For example, we could create a new Python script and write these statements in it.</p>\r\n\r\n<blockquote><pre>\r\ndef square(n):\r\n    return n * n\r\n\r\n\r\ndef cube(n):\r\n    return n * n * n\r\n</pre></blockquote>\r\n\r\n<p>Suppose we then ran that script in IDLE.  Here's what we would see, after the shell restarted.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt;\r\n</pre></blockquote>\r\n\r\n<p>Why didn't we see any numbers get squared or cubed?  Remember that there is a difference between <i>defining</i> a function and <i>calling</i> it.  Here, we have a script that defines two functions, <b>square</b> and <b>cube</b>, but doesn't call either of them.  Defining a function makes it available to be called, but doesn't actually call it.  Of course, having executed the script, the functions will have been defined, so we could then call them within the Python shell.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>square(4)</b>\r\n16\r\n&gt;&gt;&gt; <b>cube(5)</b>\r\n125\r\n</pre></blockquote>\r\n\r\n<p>Many Python scripts we write will only contain definitions.  In other words, their role will be to make things available to other scripts, but not to <i>do</i> anything on their own.  But when we want to write Python scripts that are stand-alone programs &mdash; ones that should <i>do</i> something when we run them &mdash; then they'll need not only to define functions, but also to call them somewhere.  The simplest way to do that is to include the calls directly within the script.</p>\r\n\r\n<blockquote><pre>\r\ndef square(n):\r\n    return n * n\r\n\r\n\r\ndef cube(n):\r\n    return n * n * n\r\n\r\n\r\ndef read_number():\r\n    return int(input('Enter a number: '))\r\n\r\n\r\nnum = read_number()\r\nprint('The square of', num, 'is', square(num))\r\nprint('The cube of', num, 'is', cube(num))\r\n</pre></blockquote>\r\n\r\n<p>The order in which we say all of this matters.  Python will execute this script in the order that it's written; executing it will cause the following things to happen <i>in the following order</i>.</p>\r\n\r\n<ul>\r\n  <li>The function <b>square</b> will be defined first.</li>\r\n  <li>Next, the function <b>cube</b> will be defined.</li>\r\n  <li>After that, the function <b>read_number</b> will be defined.  (Note that nothing has happened yet, except that there are now functions available to be used later.  But, so far, we haven't multiplied any numbers, read any input, or anything else; the functions haven't been called yet.)</li>\r\n  <li>Now, the statement <b>num = read_number()</b> executes, which calls the function <b>read_number()</b> that we already defined, then stores the result in a variable called <b>num</b>.</li>\r\n  <li>Next, we call <b>square(num)</b> and use it as part of some output that we print out.</li>\r\n  <li>Finally, we call <b>cube(num)</b> and use it as part of some output that we print out.</li>\r\n</ul>\r\n\r\n<p>So, if we executed this script in IDLE, we would be able to have the following interaction with it (including evaluating some additional expressions in the shell after it finishes running).</p>\r\n\r\n<blockquote><pre>\r\nEnter a number: <b>5</b>\r\nThe square of 5 is 25\r\nThe cube of 5 is 125\r\n&gt;&gt;&gt; <b>num</b>\r\n5\r\n&gt;&gt;&gt; <b>cube(7)</b>\r\n343\r\n</pre></blockquote>\r\n\r\n<p>Why the order in which the script is written matters is because, broadly, things need to be defined before they're used in Python.  The functions <b>square</b>, <b>cube</b>, and <b>read_number</b> can only be called once they've already been defined.  So, the last three statements in our script &mdash; which call each of the three functions &mdash; must appear at the bottom of our script.  If they appeared before the definitions of the functions, the script would terminate with an error, because of an attempt to call a function that didn't yet exist.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Scope and scoping rules</p>\r\n\r\n<p>So far, we've only seen Python functions whose bodies each contain a single <b>return</b> statement.  While we will write one-line functions like these sometimes, many of the functions we write will be longer than that.  All of the statements that we've seen so far in Python can be used within the body of a function, and functions can legally contain as many statements in their bodies as you'd like, which are subject to the same rules of control flow &mdash; <b>if</b> statements for conditionality, loops for repetition, and so on &mdash; that we've seen already.  (The only \"special\" statement we've seen so far is <b>return</b>, which can only appear in the body of a function.)</p>\r\n\r\n<p>Suppose that we wanted to write a function that asks a user to specify a person's first name and last name separately, then return that name formatted with the last name specified first, the first name specified afterward, and a comma separating them.  And, for the sake of argument, let's assume that both the first and last name have to be non-empty &mdash; though, of course, there are people who don't have both.  All of this actually entails a fair bit of complexity, so it would be worth writing a function to encapsulate it.</p>\r\n\r\n<blockquote><pre>\r\ndef read_name():\r\n    while True:\r\n        first_name = input('What is the first name? ').strip()\r\n\r\n        if first_name == '':\r\n            print(\"You'll need to enter a first name\")\r\n        else:\r\n            last_name = input('What is the last name? ').strip()\r\n\r\n            if last_name == '':\r\n                print(\"You'll need to enter a last name after the first\")\r\n            else:\r\n                return last_name + ', ' + first_name\r\n</pre></blockquote>\r\n\r\n<p>If you wrote this function by itself in a Python script and then executed that script in IDLE, the function would be available to call, which might lead to an interaction like this in the Python shell.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>name = read_name()</b>\r\nWhat is the first name? <b>Boo</b>\r\nWhat is the last name? \r\nYou'll need to enter a last name after the first\r\nWhat is the first name? <b>Boo</b>\r\nWhat is the last name? <b>Thornton</b>\r\n&gt;&gt;&gt; <b>name</b>\r\n'Thornton, Boo'\r\n</pre></blockquote>\r\n\r\n<p>Notice that the body of the function <b>read_name</b> contained assignments to two variables: <b>first_name</b> and <b>last_name</b>.  Based on what we've seen so far, it stands to reason that we should be able to obtain their values in the Python shell &mdash; whenever we've defined something in a Python script, we've been able to get to it in the Python shell after the script finishes executing.  So, let's try it and see what happens.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>first_name</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;\r\n    first_name\r\nNameError: name 'first_name' is not defined\r\n</pre></blockquote>\r\n\r\n<p>As usual, this error message turns out not to be an accident; it's indicative of some additional rules in Python that we've not seen yet.  When we define a name in Python &mdash; such as when we assign a value to a variable or define a function &mdash; it is not necessarily available throughout the entire program.  Not all names are defined globally; many of them are (purposefully) defined more restrictively than that.  (This is an example of a broader principle we'll see throughout this course: Perhaps paradoxically, our programs become more flexible as we restrict the ways that each part of it can be used.)</p>\r\n\r\n<p class=\"subtitle\">Global and local scopes</p>\r\n\r\n<p>In Python, each definition exists within a <i>scope</i>, which is the portion of the program in which that definition is available.  Anything that is named &mdash; variables, functions, parameters, and so on &mdash; are subject to this rule.</p>\r\n\r\n<p>A <i>global definition</i> is one that is made within a Python script (or within the Python shell), but not inside of a function.  For example, consider the following Python script.</p>\r\n\r\n<blockquote><pre>\r\nx = 10\r\ny = 20\r\nz = 30\r\n\r\ndef foo(a, b, c):\r\n    parameter_sum = a + b + c\r\n    return x + y + z + parameter_sum\r\n</pre></blockquote>\r\n\r\n<p>In this script, the variables <b>x</b>, <b>y</b>, and <b>z</b> are part of the <i>global scope</i>, as is the function <b>foo()</b>.  For that reason, we would expect that we could execute the script and then access <b>x</b>, <b>y</b>, <b>z</b>, and <b>foo()</b> from within the Python shell.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x</b>\r\n10\r\n&gt;&gt;&gt; <b>y + z</b>\r\n50\r\n&gt;&gt;&gt; <b>foo(1, 2, 3)</b>\r\n66\r\n</pre></blockquote>\r\n\r\n<p>This is because our shell interactions, too, are being made from within the global scope; we can access anything in the shell that is globally accessible.</p>\r\n\r\n<p>By way of contrast, the function <b>foo()</b> contains some definitions that are in its <i>local scope</i>, which is to say that they are accessible only from within the function.  The parameters <b>a</b>, <b>b</b>, and <b>c</b>, and the variable <b>parameter_sum</b>, are all local to <b>foo()</b>.  Let's think about why that is.</p>\r\n\r\n<ul>\r\n  <li>Every time the function <b>foo()</b> is called, it will be passed a set of arguments.  Each time, the three parameters &mdash; <b>a</b>, <b>b</b>, and <b>c</b> may well have different values.</li>\r\n  <li>While the function <b>foo()</b> runs, the variable <b>parameter_sum</b> is re-calculated from the values of the arguments passed into the function.</li>\r\n  <li>Once the function <b>foo()</b> returns, its job is done; there's little value in being able to access its parameters or variables afterward.  Being able to depend on prior values in these parameters or variables invites our program to become more brittle, such that changes to the function later could invalidate other seemingly-unrelated parts of the program.</li> \r\n  <li>One thing we'll see later in the course is that functions in Python can be <i>recursive</i>, which means that a function can call itself (directly or indirectly).  For this reason, it's vital that there be a local scope, so that each call to the function can have its own separate copy of its parameters and variables.</li>\r\n</ul>\r\n\r\n<p>So, when we assign to a variable from within a function, we're assigning to a <i>local variable</i>, which is to say a variable that is defined in the function's local scope.  Note that this is true even when we're talking about variables with the same name within and outside of a function.</p>\r\n\r\n<blockquote><pre>\r\nq = 5\r\n\r\ndef example(n):\r\n    q = n * n\r\n    return q\r\n\r\nprint(example(q))\r\nprint(q)\r\n</pre></blockquote>\r\n\r\n<p>If we executed the Python script above, the output would look like this:</p>\r\n\r\n<blockquote><pre>\r\n25\r\n5\r\n</pre></blockquote>\r\n\r\n<p>This is because the assignment to <b>q</b> in the <b>example()</b> function does not affect the global variable <b>q</b>; it instead creates a new local variable <b>q</b>, which is local to the function <b>example()</b> and is separate from the global one defined previously.  When the same name is defined in more than one scope, there are rules about which one Python will \"prefer,\" which generally boil down to \"Prefer things that are defined more closely to where you are.\"</p>\r\n\r\n<p>There is one other additional rule to be aware of, which might come as a surprise if you haven't thought it through carefully.  Consider this Python script, which is similar to the previous one, but is not quite the same.</p>\r\n\r\n<blockquote><pre>\r\nq = 5\r\n\r\ndef example(n):\r\n    m = q * n\r\n    q = m * n\r\n    return q\r\n\r\nprint(example(q))\r\nprint(q)\r\n</pre></blockquote>\r\n\r\n<p>Consider what might happen if we executed this script.  Knowing what we know about Python already, we would expect the following things to happen.</p>\r\n\r\n<ul>\r\n  <li>The global variable <b>q</b> is defined, with its value set to 5.</li>\r\n  <li>The function <b>example()</b> is defined.  Remember that functions aren't called when they're defined; they're available to be called, but haven't been called yet.</li>\r\n  <li>The first call to <b>print()</b> will occur, but only after <b>example(q)</b> returns.  So, the next thing to happen is <b>example(q)</b> is called.  Since this call is in the global scope, <b>q</b> is the global variable whose value is already 5.</li>\r\n  <li>Next, we begin the call to <b>example()</b>.  The parameter <b>n</b> is set to the value of the argument, the global variable <b>q</b>, which is 5.</li>\r\n  <li>The first statement of <b>example()</b> executes first, in which we multiply <b>q * n</b>, then assign its value to <b>m</b>.  We know that <b>m</b> will become a local variable within <b>example()</b>, because we know that assigning to a variable within a function will assign to a local one.  But what is the value of <b>q</b> in this statement?  There will be an assignment to a local variable <b>q</b> on the second line of the function, where we said <b>q = m * n</b>, but that hasn't happened yet.  So what happens here?  The answer might surprise you.</li>\r\n</ul>\r\n\r\n<blockquote><pre>\r\nTraceback (most recent call last):\r\n  File \"D:/Examples/32/scopes3.py\", line 8, in &lt;module&gt;\r\n    print(example(q))\r\n  File \"D:/Examples/32/scopes3.py\", line 4, in example\r\n    m = q * n\r\nUnboundLocalError: local variable 'q' referenced before assignment\r\n</pre></blockquote>\r\n\r\n<p>This outcome may seem a little bit perplexing, because the local variable <b>q</b> doesn't seem to exist yet.  Its value will not be assigned until the second statement within the <b>example()</b> function.  But Python first scans a function's body and determines all of the local variables it will need.  They're all created at the beginning of the function's execution &mdash; albeit without values, which is what it means for them to be \"unbound\" &mdash; but they can't be used until a value has been assigned to them.  So, in this case, we see an error message.  You can't use a local variable until <i>after</i> you've assigned a value to it.</p>\r\n\r\n<p class=\"subtitle\">Functions defined inside of functions</p>\r\n\r\n<p>Functions don't have to be defined only in the global scope, though that's most often where you'll define them.  It turns out that you can define them locally &mdash; within other functions &mdash; as well.  Like local variables, this will render them usable only within the function in which they're defined.  (In truth, it's not all that often that I use this technique; it's comparatively rare that I want to write a function this way.  But, as we'll see later in the quarter, isolating functions can have its uses.  For now, though, we'll focus on the affect this technique has on the scoping rules of Python.)</p>\r\n\r\n<p>Suppose you wrote the following Python function.</p>\r\n\r\n<blockquote><pre>\r\ndef read_and_sum_numbers():\r\n    def read_number():\r\n        return int(input('Enter a number, or 0 to stop: '))\r\n\r\n    total = 0\r\n\r\n    while True:\r\n        number = read_number()\r\n\r\n        if number == 0:\r\n            return total\r\n\r\n        total += number\r\n</pre></blockquote>\r\n\r\n<p>Here, we've written a function <b>read_and_sum_numbers()</b>, which reads a sequence of numbers from the user as input, then returns the sum of the numbers it read.   Part of what it does is encapsulated in a smaller function <b>read_number()</b> inside of it, which is used to read a single number.  Like anything else defined locally within a function, <b>read_number()</b> can only be called from within <b>read_and_sum_numbers()</b>, which we've done here.</p>\r\n\r\n<p>We've seen previously that names defined globally can be accessed from within a function, unless they're \"hidden\" by a more locally defined version of the same name.  But what if there are multiple nested scopes, like we have here?  Now we're ready to take a more complete look at how names are looked up in Python when we use them.</p>\r\n\r\n<p class=\"subtitle\">Python's name lookup rule: Local, Enclosing, Global, Built-in (LEGB)</p>\r\n\r\n<p>At any given time, there may be multiple scopes in play.  For example, in the previous example, when we're within the function <b>read_number()</b>, there are three scopes whose names are potentially accessible:</p>\r\n\r\n<ul>\r\n  <li>The scope of the function <b>read_number()</b>.</li>\r\n  <li>The scope of the function <b>read_and_sum_numbers()</b>.</li>\r\n  <li>The global scope (i.e., the one in which <b>read_and_sum_numbers()</b> is defined).</li>\r\n</ul>\r\n\r\n<p>Note that what makes a scope accessible is structural &mdash; it's a matter of which functions are <i>defined</i> within which other functions, not which functions have <i>called</i> which other functions.</p>\r\n\r\n<p>When you use a name in a statement or expression, Python uses a simple rule that is sometimes abbreviated as <i>LEGB</i> to determine which name you've used.  LEGB stands for <i>Local, Enclosing, Global, Built-In</i> and is the order in which Python looks for that name.</p>\r\n\r\n<ul>\r\n  <li>First, the local scope is checked.  If the name is defined in that scope, that's the one you'll get.</li>\r\n  <li>If the name is not found in the local scope, next the enclosing scope is checked.  This only comes into play when functions are nested within one another &mdash; the enclosing scope of <b>read_number()</b> is the scope of <b>read_and_sum_numbers()</b>, for example.  If there are multiple levels of nesting, all are checked, in the order of how close they are to where the name was used.</li>\r\n  <li>If the name is not found in any enclosing scope, next the global scope is checked.  If the name is defined globally, that's the one you'll get.</li>\r\n  <li>Finally, if the name doesn't appear in a local, enclosing, or global scope, Python checks the <i>built-in scope</i>, which consists of the names of things that are built into the language, such as the function <b>type()</b> or the type <b>int</b>.  If the name is built in, that's the one you'll get.</li>\r\n  <li>And, if the name isn't found in any of these scopes, it is an error; you're not allowed to look for a name that isn't there.</li>\r\n</ul>\r\n\r\n<p>For the most part, we will avoid assigning values to variables defined in scopes other than the local one, though we will feel free to <i>read</i> values from outer scopes (as we will feel free to have global <i>constants</i> &mdash; variables whose values we never intend to change &mdash; even if we won't use global variables whose values vary).  Particularly as our programs grow larger, it is paramount that we be able to understand portions of them without having to consider the fine-grained details from other portions.  Global variables are problematic because they essentially tie an entire program together; they're a detail that transcends our entire program, making it more difficult to keep different parts of the program isolated from the others.  Since one of our key goals in this course is \"leveling up\" our skills, so that we can write dramatically larger programs than we could before, we'll stick to techniques that scale up properly.</p>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}