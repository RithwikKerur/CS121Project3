{"url": "https://www.ics.uci.edu/~thornton/ics142/LabManual/Assignment4/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course2.css\" type=\"text/css\" />\r\n\r\n<title>ICS 142 Winter 2004, Assignment #4</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 142 Winter 2004 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../LabManual\">Lab Manual</a> |\r\n<a href=\"news:ics.142\">ics.142 newsgroup</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 142 Winter 2004<br />\r\n   Assignment #4</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Thursday, March 4, 11:59pm</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>As we discussed at the outset of this course -- and as you had no doubt heard or read before -- there are two major types of language processors: <i>compilers</i> and <i>interpreters</i>.  Compilers translate a program in one language into an equivalent program in another, often lower-level, language.  Interpreters execute a program and generate its output, in a sense translating the program from the source to the target language as it executes.  Though their overall aims are different, they share a great deal of functionality.  Both compilers and interpreters must read and understand the structure and meaning of the source program.  Both must be able to determine whether the program is syntactically or semantically erroneous, and must report errors in some usable fashion.  (It should be noted that an interpreter may do this work before executing the program, or may do some or all of this work piecemeal as the program is executing.)</p>\r\n\r\n<p>For a language like Monkie2004, in which the majority of semantic rules can be checked statically (i.e. before the program executes), either kind of language processor is best off starting with the phases that we've built in the first three assignments: scanning the input program and breaking it into tokens, parsing these tokens and determining the syntactic structure of the program, building an intermediate representation of the program (such as an abstract syntax tree), and performing static semantic checking on it.  When these phases have been completed, it is clear that the program is syntactically and semantically correct -- at least with respect to semantic rules that can be checked statically -- and there is a convenient tree-based representation of the program ready to be operated upon.</p>\r\n\r\n<p>From this point, however, the way we should proceed is radically different, depending on whether we intend to build a compiler or an interpreter.  If we're building a compiler, we may proceed by writing a module that takes the abstract syntax tree and generates a \"flat\" intermediate representation for it, one that is closer to the machine code that we will eventually want to emit.  We'll then want our compiler to perform various optimizations on it to reduce, if possible, the amount of time and/or memory that it will consume when executed.  Next, we'll need to map this intermediate code to machine code, which will require us to select the appropriate sequence of machine instructions for each intermediate code instruction, as well as deciding on how we'll use registers and/or cache memory to reduce the number of accesses to main memory (or, worse yet, virtual memory stored on disk!).  Finally, our compiler, using all of the knowledge about the source program that it has gained during these phases, will emit target code.</p>\r\n\r\n<p>On the other hand, an interpreter is not concerned with rewriting the input program; it's concerned with executing it and determining its output.  Given an intermediate representation of the program, such as an abstract syntax tree, an interpreter operates by traversing it and evaluating the meaning of its nodes on the fly.  For example, for some expression tree rooted with an addition operation, an interpreter can evaluate it by first evaluating the left subtree and determining its value, then evaluating the right subtree and determining its value, and finally adding these two values together to yield the final result of the addition.  Since the interpreter is viewing the program at, essentially, the source level, it needs to maintain a symbol table, declaring variables into it as their declarations are reached, then removing declarations when the variables fall out of scope.  Some mechanism needs to be included to support calls to subprograms, which may either involve the creation and maintenance of an explicit run-time stack (complete with activation records), or a simpler approach built on subprogram calls in the interpreter's source language.</p>\r\n\r\n<p>So, what we should do next depends on what kind of language processor we intend to build.  This assignment will ask you to build upon the work you did in the previous assignment, extending your program to be a complete Monkie2004 interpreter.  When you're done, you'll be able to execute Monkie2004 programs and view their output.  Future assignments will explore some aspects of the remaining tasks performed by a compiler (though it should be pointed out here that we will not be building a complete Monkie2004 compiler this quarter).</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Changes to the Monkie2004 language for this assignment</p>\r\n\r\n<p>No changes have been made to the syntax or static semantic rules of the language; they remain as they were in the previous assignment.</p>\r\n\r\n<p>There is one change to the apparent intent of the language, though it involves a rule that has never formally been specified: the meaning of the <b>ref</b> keyword.  It was originally intended that <b>ref</b> would be used to signify that a formal parameter was to be passed using pass-by-reference semantics.  For this assignment, the <b>ref</b> keyword may still appear in a parameter list as before, but, as a simplification, it will not have any meaning.  All parameters will be passed by value.  (Optionally, you may implement pass-by-reference semantics for <b>ref</b> if you wish, but it is not required, and I won't be offering any extra credit for it.  If you want some ideas about how to implement it, feel free to contact me.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The dynamic semantic rules of Monkie2004</p>\r\n\r\n<p>The following is a list of the dynamic semantic rules for Monkie2004.  It is considered a supplement to the static semantic rules presented in the previous assignment, and only applies to programs that have no lexical, syntactic, or static semantic errors.  The rules below cover aspects of Monkie2004 programs that only have meaning at run-time.  Most of the rules describe the behavior of legal Monkie2004 programs.  In a few cases, <i>dynamic semantic errors</i> are described.  When a Monkie2004 program encounters a dynamic semantic error, it prints an error message to the output and terminates immediately.</p>\r\n\r\n<p>Execution of a Monkie2004 program begins with all global declarations being made.  All global variables are assigned their default initial values, as described in the rules below.  After all global declarations have been made, a procedure with the following signature is called:</p>\r\n\r\n<pre>\r\n    procedure program()\r\n</pre>\r\n\r\n<p>If no such procedure exists, it is a dynamic semantic error and the program terminates immediately.  If it does exist, the execution of the program lasts until program( ) returns.</p>\r\n\r\n<p>The dynamic semantic rules of Monkie2004 are:</p>\r\n\r\n<ul>\r\n  <li>There are three types of variables in Monkie2004 programs: <b>integer</b>, <b>boolean</b>, and <b>string</b>.</li>\r\n  <li>Integer variables may contain signed 32-bit integral values in the range -2<sup>31</sup> to 2<sup>31</sup> - 1 inclusive.  (Not coincidentally, this mirrors the allowable range of Java <b>int</b> values.)\r\n    <ul>\r\n      <li>Addition, subtraction, multiplication, division, and integer negation work as you would expect, yielding the result of performing that mathematical operation on the appropriate number of integer operands.  Overflow and underflow causes the value to \"wrap around\" as it does in Java, e.g. (2<sup>31</sup> - 1) + 1 = -2<sup>31</sup>.  This is not considered a dynamic semantic error in Monkie2004, which means that you need not write any special code to handle or avoid this case.</li>\r\n      <li>The relational operators ==, /=, &lt;, &lt;=, &gt;, and &gt;= work as you would expect, as well.  If given two integer operands, the values of those operands are compared using the given relational operator, yielding a boolean result of <b>true</b> if the comparison is true and <b>false</b> otherwise.</li>\r\n      <li>A division operation in which the right operand is zero is a dynamic semantic error in Monkie2004.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Boolean variables may contain one of two possible values: <b>true</b> and <b>false</b>.  A number of operators take boolean operands, so it is necessary to define the effect of each:\r\n    <ul>\r\n      <li>The <b>not</b> operator takes one boolean operand and yields the negation of the value of that operand, i.e. <b>not false</b> yields <b>true</b> and <b>not true</b> yields <b>false</b>.</li>\r\n      <li>The <b>and</b> operator takes two boolean operands and yields <b>true</b> if and only if both operands have the value <b>true</b>.  <b>and</b> is not short-circuited, meaning that both operands are always evaluated before yielding a result.</li>\r\n      <li>The <b>and then</b> operator is similar to the <b>and</b> operator, except that it is short-circuited.  Its left operand is evaluated first.  If it has the value <b>false</b>, the <b>and then</b> operation yields <b>false</b>.  If not, the <b>and then</b> operation yields the value of the right operand.</li>\r\n      <li>The <b>or</b> operator takes two boolean operands and yields <b>false</b> if and only if both operands have the value <b>false</b>.  <b>or</b> is not short-circuited.</li>\r\n      <li>The <b>or else</b> operator is similar to the <b>or</b> operator, except that it is short-circuited.  Its left operand is evaluated first.  If it has the value <b>true</b>, the <b>or else</b> operation yields <b>true</b>.  If not, the <b>or else</b> operation yields the value of the right operand.</li>\r\n      <li>The <b>xor</b> operator takes two boolean operands and yields <b>true</b> if and only if the two operands evaluate to different values.  <b>xor</b> is not short-circuited.</li>\r\n      <li>The <b>implies</b> operator takes two boolean operands.  It is a short-circuited operation.  Its left operand is evaluated first.  If it has the value <b>false</b>, the <b>implies</b> operation yields <b>true</b>.  If not, the <b>implies</b> operation yields the value of the right operand.</li>\r\n      <li>The relational operators == and /= may take two boolean operands.  In this case, they behave in the way you would expect: they compare the values of the operands, yielding <b>true</b> if the comparison is true and <b>false</b> if not.</li>\r\n    </ul>\r\n  </li>\r\n  <li>String variables contain a sequence of zero or more characters.  Each character is a member of the Unicode character set, represented by a 16-bit character code.  Not surprisingly, this is the same representation that Java uses to store its strings.  A few operators take string operands:\r\n    <ul>\r\n      <li>The <b>&</b> operator takes two string operands and yields the concatenation of the value of the right operand to the value of the left.  For example, <b>\"Monkie\" & \"2004\"</b> yields <b>\"Monkie2004\"</b>.</li>\r\n      <li>The relational operators ==, /=, &lt;, &lt;=, &gt;, and &gt;= may take two string operands, in which case they perform a <i>lexicographical comparison</i> of the values of the operands.  Each such operation yields <b>true</b> if the comparison is true and <b>false</b> otherwise.\r\n        <ul>\r\n          <li>A lexicographical comparison of strings in Monkie2004 behaves in the same fashion as a similar comparison of strings in Java using the compareTo( ) method.  For more information, see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#compareTo(java.lang.String)\">this link</a>.</li>\r\n        </ul>\r\n      </li>\r\n    </ul>\r\n  </li>\r\n  <li>Variables are implicitly initialized to a default value at the time of their declaration.\r\n    <ul>\r\n      <li>Integers are implicitly initialized to zero.</li>\r\n      <li>Strings are implicitly initialized to the empty string (i.e. \"\").</li>\r\n      <li>Booleans are implicitly initialized to false.</li>\r\n      <li>This rule applies to global variables, local variables, and the implicitly-declared <b>Result</b> variable in all functions.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Procedure and function calls behave similarly to many other programming languages that you may have learned previously.  The actual parameters are evaluated in left-to-right order.  The resulting values are matched up positionally with the corresponding formal parameters and are used to initialize them (i.e. the first actual parameter's value is used to initialize the first formal parameter, and so on).</li>\r\n  <li>The implicitly-declared <b>Result</b> variable in a function represents the function's return value.  The return value of a function is the last value assigned to <b>Result</b> while the function's body executed.  (If <b>Result</b> is never assigned, the return value is the default value assigned to <b>Result</b> at the function's outset.)</li>\r\n  <li>Block statements are executed by executing each statement within them in order.</li>\r\n  <li>If statements are executed in the following way:\r\n    <ul>\r\n      <li>First, the conditional expression is evaluated, yielding a boolean value.</li>\r\n      <li>If its value is <b>true</b>, the block statement that follows the <b>then</b> keyword is executed.  If its value is <b>false</b>, the block statement that follows the <b>else</b> keyword (if any) is executed.</li>\r\n    </ul>\r\n  </li>\r\n  <li>While loops are executed in the following way:\r\n    <ul>\r\n      <li>First, the conditional expression is evaluated, yielding a boolean value.</li>\r\n      <li>If its value is <b>false</b>, the while loop is exited and control moves on to the statement that follows the while loop.</li>\r\n      <li>If its value is <b>true</b>, the block statement that follows the <b>do</b> keyword is executed.  After the block statement has finished executing, control jumps back to the top of the while loop and the condition is tested again.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Assignment statements are executed in the following way:\r\n    <ul>\r\n      <li>The expression on the right hand side of the assignment is evaluated, yielding a value.</li>\r\n      <li>That value is placed into the variable named on the left hand side of the assignment.</li>\r\n    </ul>\r\n  </li>\r\n  <li>The seven predefined subprograms, which are used for console input and output, behave in the following way:\r\n    <ul>\r\n      <li><b>function read_string( ): string</b>.  The input cursor appears and the user may type input and hit the Enter key.  All of the input that they typed prior to hitting the Enter key is combined into a string value, which is returned from the function.</li>\r\n      <li><b>procedure print_string(s: string)</b>.  The characters contained in the string s are printed to the console.  The output cursor remains on the same line afterward.</li>\r\n      <li><b>function read_integer( ): integer</b>.  The input cursor appears and the user may type input and hit the Enter key.\r\n        <ul>\r\n          <li>If the input typed by the user before pressing Enter is a sequence of digits (optionally preceded by a minus sign) which, when converted to the corresponding integer value, lies within the legal range of integer values, this function returns the corresponding integer value.</li>\r\n          <li>If the input typed by the user is anything else (including input that begins with a legal integer, but additionally contains any other characters), it is a dynamic semantic error.</li>\r\n        </ul>\r\n      </li>\r\n      <li><b>procedure print_integer(i: integer)</b>.  A string representation of i's value is printed to the console.  Positive integers are printed in decimal form (e.g. <b>17</b>).  Negative integers have their magnitudes printed in decimal form, preceded by a minus sign (e.g. <b>-17</b>).  The output cursor remains on the same line afterward.</li>\r\n      <li><b>function read_boolean( ): boolean</b>.  The input cursor appears and the user may type input and hit the Enter key.\r\n        <ul>\r\n          <li>If the input typed by the user before pressing Enter was exactly the string <b>\"true\"</b>, this function returns the boolean value <b>true</b>.</li>\r\n          <li>If the input typed by the user before pressing Enter was exactly the string <b>\"false\"</b>, this function returns the boolean value <b>false</b>.</li>\r\n          <li>If the input typed by the user is anything else (including input that begins with either \"true\" or \"false\" but additionally contains any other characters), it is a dynamic semantic error.</li>\r\n        </ul>\r\n      </li>\r\n      <li><b>procedure print_boolean(b: boolean)</b>.  If b's value is true, the string \"true\" is printed to the console, otherwise the string \"false\" is printed to the console.  The output cursor remains on the same line afterward.</li>\r\n      <li><b>procedure print_endline( )</b>.  The output cursor is moved to the beginning of the next line.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Implementing your interpreter</p>\r\n\r\n<p>Assuming that you completed a solution to at least Part 1 of the previous assignment, you have a completed CUP script specifying a parser that builds an AST for the input program.  To support this, you also have a set of Java classes that implement the various kinds of AST nodes.  Each AST node, at present, contains an analyze( ) method, which is used to perform static semantic checking on it (and its children, as appropriate).</p>\r\n\r\n<p>Given an AST and a symbol table, an interpreter is relatively straightforward to implement.  (Don't get me wrong; there are plenty of devilish details.  But conceptually, it's not difficult to explain.)  Much of what I've suggested here is provided as example code in the starting point.</p>\r\n\r\n<ul>\r\n  <li>Each variable stored in the SymbolTable will need to be accompanied by its value.  Since different variables will have different values, we'll unfortunately need to store an Object reference with each variable in the SymbolTable.  In the case of integer variables, we'll store an Integer object.  For boolean variables, we'll store a Boolean object.  For strings, we'll store String objects.\r\n    <ul>\r\n      <li>When initially declaring a variable, it will be given its default value (0 for integers, false for booleans, the empty string for strings).  To easily support the determination of initial values, I added a getInitialValue( ) method to the Type class, which returns an Object that is the initial value for variables of that type.</li>\r\n    </ul>\r\n  </li>\r\n  <li>Each Definition node (global variable declarations and subprogram declarations) needs a declare(SymbolTable st) method added to it.  The declare( ) method adds a declaration for either the global variable or the subprogram to the symbol table.  If you've already got code in your analyze( ) method that declares the symbols into the symbol table, you can reuse it.</li>\r\n  <li>Each Statement node needs an execute(SymbolTable st) method added to it.  Depending on what kind of statement it is, the body of this method will be different, but the basic idea is that it will affect whatever changes are implied by the statement.  For example, an assignment statement will cause a variable's value to be changed.</li>\r\n  <li>Each Expression node needs an evaluate(SymbolTable st) method added to it, which returns an Object that represents the expression's value.  Depending on what kind of expression it is, the body of this method will be different, but the basic idea is that each evaluate( ) method will evaluate the appropriate kind of expression, returning the appropriate value.  For example, the evaluate( ) method in the ConcatenationExpression will first evaluate its left-hand operand (by calling evaluate( ) on it), then evaluate its right-hand operand, then return the concatenation of these two results.</li>\r\n  <li>To support procedure and function calls, each subprogram that is declared in the symbol table needs to be accompanied by the AST node that represents the subprogram.  For example, if you had a SubprogramDeclaration class (which extends Definition) in your solution to the previous assignment, you'd add a SubprogramDeclaration field to the Subprogram class, along with an accessor method to access it, and an additional parameter to the Subprogram constructor (and the declareSubprogram( ) method in the SymbolTable class) to pass it in.  Also, you should add a call( ) method to your SubprogramDeclaration class, which takes two parameters: the SymbolTable and an ArrayList of the values of the actual parameters.  The call( ) method should return an Object, which is the return value of the subprogram.  (Procedures can return null, while functions can return Integer, Boolean, or String objects, as appropriate.)</li>\r\n  <li>Since dynamic semantic errors cause the interpreter to immediately terminate the program, I created an unchecked exception class called InterpreterException.  Every dynamic semantic error causes one of these to be thrown.  They are caught in my Driver class.</li>\r\n  <li>The predefined I/O subprograms can be implemented as classes that extend your SubprogramDeclaration class (or its equivalent).  Its call( ) method, instead of traversing an AST, will simply consist of Java code.  I've provided an example of this in the starting point, along with a utility class called ConsoleInput that you'll likely find useful.</li>\r\n</ul>\r\n\r\n<p>One fact will greatly simplify your implementation: you may freely assume that, by the time the interpreter begins executing it, the input program is free of lexical, syntactic, or static semantic errors.  So, for example, you may assume that both operands to a concatenation operation are strings, the type of the expression on the right-hand side of an assignment statement matches the type of the variable on the left-hand side, and so on.  This means that, even if you have to do quite a bit of casting, you can at least assume that the casts will be proper.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Starting point</p>\r\n\r\n<p>Officially, the starting point for this assignment is your solution to the previous assignment.  We won't be testing your static semantic checker again for this assignment, meaning that we will only test your solution to this assignment using Monkie2004 programs that are syntactically correct and do not violate the static semantic rules.  So, if you weren't able to get the previous assignment done, you will not be doubly penalized, unless your solution to the previous assignment reported errors for legal Monkie2004 programs.  However, if you were unable to complete Part 1 of the previous assignment, you will need to get it finished before you can proceed with this one.</p>\r\n\r\n<p>While I want you to use your own code as a starting point, I am providing some suggested approaches and example code from my interpreter, which you can use or ignore at your discretion.  They are available as a Zip archive.</p>\r\n\r\n<ul>\r\n  <li><a href=\"StartingPoint.zip\">Zip archive</a></li>\r\n</ul>\r\n\r\n<p>Be aware that the code I provided may not fit in perfectly with your design, so you may need to make some modifications to it.  All of this code is provided as-is (much of it uncommented) to give you some ideas about how to proceed with your solution to this assignment.  Since each of you will be starting with a somewhat different solution to the previous assignment, it was not really practical for me to provide code that would surely work with each of your previous designs.  But I thought that the files that I've provided would help lead you in a good direction.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>Place your completed CUP script and all of the .java files that comprise your program into a Zip archive, then submit that Zip archive.  You need not include the .java files created by CUP (Parser.java and Tokens.java), but we won't penalize you if you do.  However, you should be aware that we'll be regenerating these ourselves during the grading process, to be sure that they really did come from your CUP script.  Please don't include other files, such as .class files, in your Zip archive.  Also, don't include any of the example code from the starting point that you didn't end up using.</p>\r\n\r\n<p>Follow <a href=\"../SubmittingAssignments.html\">this link</a> for a discussion of how to submit your assignment.  Remember that we do not accept paper submissions of your assignments, nor do we accept them via email <i>under any circumstances</i>.</p>\r\n\r\n<p>In order to keep the grading process relatively simple, we require that you keep your program designed in such a way as it can be compiled and executed with the following set of commands:</p>\r\n\r\n<pre>\r\n    cup monkie.cup\r\n    javac *.java\r\n    java Driver inputfile.m\r\n</pre>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Limitations</p>\r\n\r\n<p>The limitations from the previous assignment still apply to this one; you may not make changes to the Monkie2004 grammar that was given to you in the previous assignment, except for the actions you wrote to build your abstract syntax tree (and any modifications you needed to make to them for this assignment) and adding names to the symbols on the right-hand sides of rules when you need to refer to their associated values.  Other changes to the CUP script are not permitted.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li>Originally written by Alex Thornton, Winter 2004.</li>\r\n</ul>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}