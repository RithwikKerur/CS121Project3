{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/problemsolving.txt", "content": "\t\tProblem Solving with Recursive Backtracking\r\n\r\n\r\nIntroduction: \r\n\r\nIn the next two lectures we will look at how to think about solving certain\r\nkinds of problems, by thinking about finding their solutions as the process of\r\nsearching through trees. In this lecture, we will look at problem solving using\r\n\"depth first search\" and backtracking.\r\n\r\nActually no tree gets constructed explicitly (no new TreeNode() statements will\r\nappear in any code), but the pattern of recursive calls to try solving the\r\nproblem can be nicely visualized as a tree of choices, which the recursive code\r\ngenerates piece by piece until it finds one solution, all solutions, or fails\r\nto find any solution. Really, this is just a variant of some recursive\r\ncalls/structure that we found in the size or height of a tree (especially N-ary\r\ntrees), by recurring on each subtree. We will illustrate backtracking search\r\nwith a few different examples and then some code.\r\n\r\nGenerally, we start with a problem of some specific SIZE and we repeatedly\r\nreduce the size of a problem by choosing some ASPECT of the problem and\r\ngenerating all the possible VALUES for that aspect. Think of every node in\r\nthe tree representing some problem and the children of that node each\r\nrepresenting a smaller problem: we label the edge between each parent and child\r\nwith the aspect chosen and the value for that aspect, which reduces the problem\r\nsize.\r\n\r\nEventually either there are no aspects left to choose for a problem, or an\r\naspect has no possible values. If the problem has been reduced to size 0,\r\nwe can check for a solution by examining all the aspects and their chosen\r\nvalues. If they do not correspond to a solution, then we can BACKTRACK, undoing\r\nsome aspect/value choices and continue to examine other aspect/value choices\r\n(either if we did not find a solution or found a solution but want ALL\r\nsolutions).\r\n\r\nWe use the term \"combinatorial searching\" to characterize this approach to\r\nsolving these problems, because we search through all possible combinations\r\nof aspects and their values. If we drew out complete search trees, we would\r\ngenerate a tremendous number of nodes (this is called the \"combinatorial\r\nexplosion\"). For a problem of size N, If the average number of children of a\r\nnode in the solution tree is C (meaning each aspect chosen has C possible\r\nvalues), then there will be C^N nodes at depth N. So even if C is small, say 2,\r\na problem with 10 aspects will require a search tree with 1,000 leaf nodes; a\r\nproblem with twice as many aspects (20) will require a search tree with\r\n1,000,000 leaf nodes. Examing all these nodes is in complexity class O((C^N):\r\nexponential in the N.\r\n\r\nWe will now look at three problems that can be solved simply by recursive\r\nbacktracking: satisfiability of boolean formulas, N-queens (placing N queens\r\non an NxN chessboard so that no queen can attack another), N-colorability\r\n(finding N colors, if possible, to color a graph so that no connected nodes\r\nare the same color). Finally, we will look at a general algorithm to solve all\r\nthese problems.\r\n\r\n\r\nSatisfiability:\r\n\r\nThe first problem that we will show how to solve with bactracking search is:\r\nGiven some boolean formula, try to find one or all assignments to each of its\r\nvariables (each is assigned either true or false) that \"satisfies\" the formula:\r\ni.e., make the formula evaluate to true.\r\n\r\nFor some formulas, there may be just one assignment, for others many\r\nassignments, for others all assignments work (such a formula is called a\r\ntautology: e.g., a || !a), and for others no assignments work (such a formula\r\nis called a contradiction or unsatisfiable: a && !a:). We might want to stop\r\nwhen we find the first solution, or continue searching until we find all\r\nsolutions.\r\n\r\nWe will examine the formula (!a || b) && (a || !b) && (a || b).\r\n\r\nWe show the root of the solution tree as a problem with two unknown\r\naspects/variables a and b: {a=?,b=?}. \r\n\r\n          {a=?,b=?}\r\n\r\nThen we start by choosing some unknown aspect of the problem: any variable that\r\nwe have not assigned a value to. In some problems we might use some special\r\ninformation to determine which aspect to choose (sometimes it is better to\r\nchoose one aspect over another). In this problem, we just choose the first\r\nvariable, a. Then, there are two possible choices for values of a: false and\r\ntrue. So we draw these choices as follows (using T to abbreviate true and F to\r\nabbreviate false). The children each have one fewer unknown aspect of the\r\nproblem.\r\n\r\n                      {a=?,b=?}\r\n         a=F/                       \\a=T\r\n        {a=F,b=?}                {a=T,b=?}\r\n\r\nLet's explore the left subtree first (and the right one later). On the left we\r\nchoose any unknown aspect: the only variable remaining is b, so we choose it.\r\nLikewise, it has two possible values, true and false. Each leads to a node with\r\nno unknown aspects.\r\n\r\n                    {a=?,b=?}\r\n         a=F/                       \\a=T\r\n       {a=F,b=?}                 {a=T,b=?}\r\n     b=F/     \\b=T\r\n {a=F,b=F} {a=F,b=T}\r\n   \r\nAgain, let's explore the left subtree first (and the right one later). There\r\nare no unknown aspects of the problem (we have assigned values to all the\r\nvariables) so we can evaluate the formula with a=false and b=false; the result\r\nis false (the third conjunct is false), so this assignment is not a solution\r\nto our problem, so we mark it NS.\r\n\r\n                    {a=?,b=?}\r\n         a=F/                       \\a=T\r\n       {a=F,b=?}                 {a=T,b=?}\r\n     b=F/     \\b=T\r\n {a=F,b=F} {a=F,b=T}\r\n    NS\r\n\r\nSo we now explore the right subtree (of the left child of the root). Again\r\nthere are no unknown aspects of the problem, so we can evaluate the formula\r\nwith a=false and b=true; the result is false again (the second conjunct is\r\nfalse), so this assignment is not a solution to our problem either.\r\n\r\n                    {a=?,b=?}\r\n         a=F/                       \\a=T\r\n       {a=F,b=?}                 {a=T,b=?}\r\n     b=F/     \\b=T\r\n {a=F,b=F} {a=F,b=T}\r\n    NS          NS\r\n\r\nNow we have completely explored the left subtree of the root (all possibilites\r\nwhen a = F), but have found no solutions. We next backtrack to explore the\r\nright subtree of the root (where a is assigned a different value, T). On the\r\nright we choose any unknown aspect: the only variable remaining is b, so we\r\nchoose it. Likewise, it has two possible values, true and false. Each leads to\r\na node with no unknown aspects.\r\n\r\n                    {a=?,b=?}\r\n         a=F/                       \\a=T\r\n        {a=F,b=?}                {a=T,b=?}\r\n     b=F/       \\b=T          b=F/       \\b=T\r\n {a=F,b=F}   {a=F,b=T}      {a=T,b=F}   {a=T,b=T}\r\n    NS          NS\r\n\r\nAgain, let's explore the left subtree first (and the right one later). There\r\nare no unknown aspects of the problem (we have assigned values to all the\r\nvariables) so we can evaluate the formula with a=true and b=false; the result\r\nis false (the first conjunct is false), so this assignment is not a solution\r\nto our problem, so we mark it NS.\r\n\r\n                    {a=?,b=?}\r\n         a=F/                       \\a=T\r\n        {a=F,b=?}                {a=T,b=?}\r\n     b=F/       \\b=T          b=F/       \\b=T\r\n {a=F,b=F}   {a=F,b=T}      {a=T,b=F}   {a=T,b=T}\r\n    NS          NS             NS\r\n\r\nSo we now explore the right subtree (of the right child of the root). Again\r\nthere are no unknown aspects of the problem, so we can evaluate the formula\r\nwith a=true and b=true; the result is true (all conjuncts are true), so this\r\nassignment is a solution to the problem and we mark it S.\r\n\r\n                    {a=?,b=?}\r\n         a=F/                       \\a=T\r\n        {a=F,b=?}                {a=T,b=?}\r\n     b=F/       \\b=T          b=F/       \\b=T\r\n {a=F,b=F}   {a=F,b=T}      {a=T,b=F}   {a=T,b=T}\r\n    NS          NS             NS           S\r\n\r\nSo, we have systematically generated and examined all possible combinations of\r\nvalues for the variables a and for b. We represented all these choices in a\r\nbinary tree (two choice for each variable), where each node shows the known and\r\nunknown aspects of a problem.\r\n\r\nNote that each time the problem size (the number of boolean variables in the\r\nformula) goes up by 1, the depth of the tree increases by 1, and the total\r\nnumber of nodes at the bottom (where we evaluate the formula) doubles. Thus,\r\nthe height of the tree is the same as the problem size, and there are 2^height\r\nleaves in the tree of possible solutions. The complexity class of solving this\r\nproblem is thus O(2^n) which is a function that grows more quickly than any\r\npolynomial function of N: e.g. O(N^1000) is more slowly growing than O(2^N).\r\n(at what value is 2^N = N^1000? when N = 1000Log2N, or N = 13,747; so 2^N is\r\nbigger when N > 13,747.\r\n\r\nAgain, this is called a \"combinatorial explosion\": the number of combinations\r\nof variables and values \"explodes\" for larger and larger N.  The satisfiability\r\nproblem is a well studied and useful problem in computing. Often proving the\r\ncorrectness of a circuit (or a protocol for transfering information) can\r\nwritten as a boolean formula with a very large number of variables. There are\r\nno algorithms that are known to have a complexity class below O(2^N) although\r\nclever algorithms have a constant so low that problem of N in the thousands can\r\nbe solved. \r\n\r\nIf anyone discovers an algorithm for solving this problem that is polynomial\r\n(not exponential) in time, variants of that algorithm can be used to solve very\r\nmany problems that are all similar and important: all such problems are in a\r\nclass of problems called NP, which stands for problems whose solution is\r\n\"checkable in  Polynomial time). The satisfiability problem is an NP-complete\r\nproblem: as hard as any problem in the NP class, and a polynnomial solution to\r\nit implies a polynomial solution to all problems in the NP class).\r\n\r\nProving whether NP problems can be solved by an algorithm in polynomial time is\r\none of the most famous open problems in mathematics. It can be proven by\r\nfinding an algorithm that solves an NP-complete problem in polynomial time\r\n(which no one has done); it can be disproven by showing that no such\r\nalgorithm can exist (a harder problem, which no one has proven).\r\n\r\nIn fact, the Clay Institute of Mathematics has offered a $1 million prize for\r\nanyone proving or disproving the existence of this kind of algorithm. They\r\nhave prizes for other mathematical conjectures (one of which has been solved\r\nsince the prizes were offered). See http://www.claymath.org/index.php. For the\r\nproblems, see http://www.claymath.org/millennium/ and click P vs. NP for this\r\nparticular problem.\r\n\r\n\r\nN-Queens:\r\n\r\nWe can use this same approach to generate solutions for the N-Queens problem.\r\nIn the N-Queens problem, we ask whether it is possible to place N queens on an\r\nNxN chessboard so that no queen is able to capture any of the others (moving\r\nvertically, horizontally, or diagonally; it is not possible to place N+1 queens\r\non such a board, because then 2 queens would be on the same row, and could\r\ncapture each other). If such a configuration is possible, we want to know the\r\nrow and column positions of every queen.\r\n\r\nThis problem is more interesting than the satisfiability problem (although\r\nnowhere near as important in computer science) because there is not a fixed\r\nbranching factor at every node: the branching factor is based on where queens\r\nhave previously been placed.\r\n\r\nLet's choose a small-sized problem: the 6-Queens problem. We will represent\r\nthe root of the problem tree by 6 aspects: in which column does the queen in\r\nrows 1-6 reside.\r\n\r\n                        {r1=?,r2=?,r3=?,r4=?,r5=?,r6=?}\r\n\r\nFor writing purposes, this notation is actually too big, so we will just\r\nabbreviate it more compactly as {??????}, 6 question marks, where the ith ?\r\nrepresents ri (row i): the value there represents the columns in which the\r\nqueen is placed for that row.\r\n\r\nWe will use a board to keep track of where queens are placed and which squares\r\ncan be attacked. We will choose the aspects as row 1, row 2, ... row 6 in that\r\norder. So, to start we choose r1 and see that we can assign it 6 different\r\nvalues: columns 1-6. So the branching factor for root node is 6.\r\n\r\n\t\t\t       {??????}\r\n   r1=c1/      r1=c2/      r1=c3/     \\r1=c4      \\r1=c5       r1=c6  \r\n   {1?????}    {2?????}    {3?????}    {4?????}    {5?????}    {6?????}\r\n\r\nNext we explore the leftmost child. Note that the edge is labeled r1=c1 meaning\r\nthat the queen in row 1 is in column 1. Here is a picture of that queen and all\r\nthe squares that other queens CANNOT occupy.\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X |   |   |   |   |\r\n  +---+---+---+---+---+---+\r\n3 | X |   | X |   |   |   |\r\n  +---+---+---+---+---+---+\r\n4 | X |   |   | X |   |   |\r\n  +---+---+---+---+---+---+\r\n5 | X |   |   |   | X |   |\r\n  +---+---+---+---+---+---+\r\n6 | X |   |   |   |   | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {1?????}. We will zoom in on the part of the\r\nsearch tree and elide the other parts for now, because of space constraints.\r\nFor this node r2 can have the values c3, c4, c5, and c6 (the queen in r1,c1\r\ncan capture queens at r2,c1 and r2,c2.\r\n\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       .....\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n\r\nSo the branching factor for the leftmost child of the root {1?????} is 4: its\r\nchoices are a bit more constrained.\r\n\r\nNext we explore the leftmost child (13????}. Here is a picture of both queens\r\nand all the squares that other queens CANNOT occupy.\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X | Q | X | X | X |\r\n  +---+---+---+---+---+---+\r\n3 | X | X | X | X |   |   |\r\n  +---+---+---+---+---+---+\r\n4 | X |   | X | X | X |   |\r\n  +---+---+---+---+---+---+\r\n5 | X |   | X |   | X | X |\r\n  +---+---+---+---+---+---+\r\n6 | X |   | X |   |   | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {13????}. We will again zoom in on the part\r\nof the search tree and elide the other parts for now, because of space\r\nconstraints. For this node r3 can have the values c5, and c6.\r\n\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       ...\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n  r3=c5/    \\r3=c6\r\n{135???}    {136???}\r\n\r\nSo the branching factor for {13???} is 2: its choices are even more\r\nconstrained.\r\n\r\nNext we explore the leftmost child (135??}. Here is a picture of all three\r\nqueens and all the squares that other queens CANNOT occupy.\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X | Q | X | X | X |\r\n  +---+---+---+---+---+---+\r\n3 | X | X | X | X | Q | X |\r\n  +---+---+---+---+---+---+\r\n4 | X |   | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n5 | X |   | X |   | X | X |\r\n  +---+---+---+---+---+---+\r\n6 | X | X | X |   | X | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {135???}. For this node r4 can have only the\r\nvalue c2.\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       ...\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n  r3=c5/    \\r3=c6\r\n{135???}    {136???}\r\nr4=c2|\r\n{1352??}\r\n\r\nSo the branching factor for {135???} is 1!\r\n\r\nNext we explore the only child (1352??}. Here is a picture of all four\r\nqueens and all the squares that other queens CANNOT occupy.\r\n\r\nOf course, we can see a problem here on row 6: every column in that row can\r\nbe captured by a previously placed queen. But let us still constinue running\r\nthe algorithm.\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X | Q | X | X | X |\r\n  +---+---+---+---+---+---+\r\n3 | X | X | X | X | Q | X |\r\n  +---+---+---+---+---+---+\r\n4 | X | Q | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n5 | X | X | X |   | X | X |\r\n  +---+---+---+---+---+---+\r\n6 | X | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {1352??}. For this node r5 can have only the\r\nvalue c4.\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       ...\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n  r3=c5/    \\r3=c6\r\n{135???}    {136???}\r\nr4=c2|\r\n{1352??}\r\nr5=c4|\r\n{13524?}\r\n\r\nSo the branching factor for {1352??} is also 1\r\n\r\nNext we explore the only child (13524?}. Here is a picture of all five queens\r\nand all the squares that other queens CANNOT occupy.\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X | Q | X | X | X |\r\n  +---+---+---+---+---+---+\r\n3 | X | X | X | X | Q | X |\r\n  +---+---+---+---+---+---+\r\n4 | X | Q | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n5 | X | X | X | Q | X | X |\r\n  +---+---+---+---+---+---+\r\n6 | X | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {13524?}. THERE CAN BE NONE! With the\r\npositions already chosen for the previous queens, there is no choice for\r\nthe queen in the 6th row that will not be captured by another queen. So\r\nwe mark that path NS\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       ...\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n  r3=c5/    \\r3=c6\r\n{135???}    {136???}\r\nr4=c2|\r\n{1352??}\r\nr5=c4|\r\n{13524?}\r\n   NS\r\n\r\nNow we must backtrack to this node's parent: {1352??}. There are no other\r\nchildren of this node, so we must backtrackyu to its parent: {135???}. There\r\nare no other children of this node, so we must backtrack to its parent:\r\n{13???}. There is another child of this node, so we explore it: {136???}. Here\r\nis a picture of all three queens and all the squares that other queens CANNOT\r\noccupy after backtracking. Note that backtracking just means undoing a decision\r\n(binding a value to an aspect) that we have explored, so that we can explore\r\nother decisions.\r\n\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X | Q | X | X | X |\r\n  +---+---+---+---+---+---+\r\n3 | X | X | X | X | X | Q |\r\n  +---+---+---+---+---+---+\r\n4 | X |   | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n5 | X |   | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n6 | X |   | X |   |   | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {136???}. For this node r4 can have only the\r\nvalue c2.\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       ...\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n  r3=c5/    \\r3=c6\r\n{135???}    {136???}\r\nr4=c2|     r4=c2|\r\n{1352??}  {1362??}\r\nr5=c4|\r\n{13524?}\r\n   NS\r\n\r\nSo the branching factor for {136???} is 1!\r\n\r\nNext we explore the only child (1362??}. Here is a picture of all three\r\nqueens and all the squares that other queens CANNOT occupy.\r\n\r\n    1   2   3   4   5   6\r\n  +---+---+---+---+---+---+\r\n1 | Q | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n2 | X | X | Q | X | X | X |\r\n  +---+---+---+---+---+---+\r\n3 | X | X | X | X | X | Q |\r\n  +---+---+---+---+---+---+\r\n4 | X | Q | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n5 | X | X | X | X | X | X |\r\n  +---+---+---+---+---+---+\r\n6 | X | X | X | X |   | X |\r\n  +---+---+---+---+---+---+\r\n\r\nNow let's explore the children of {1362??}. THERE CAN BE NONE! With the\r\npositions already chosen for the previous queens, there is not choice for\r\nthe queen in the 5th row that will not be captured by another queen. So\r\nwe mark that path NS.\r\n\r\n\t\t\t\t{??????}\r\n                         r1=c1/                         \\\\\\\\\\\r\n                         {1?????}                       ...\r\n       r2=c3/      r2=c4/      \\r2=c5      \\r2=c6\r\n       {13????}    {14????}    {15????}    {16????}\r\n  r3=c5/    \\r3=c6\r\n{135???}    {136???}\r\nr4=c2|       r4=c2|\r\n{1352??}     {1362??}\r\nr5=c4|          NS\r\n{13524?}\r\n   NS\r\n\r\nNow we must backtrack to this node's parent: {136???}. There are no other\r\nchildren of this node, so we must backtrack to its parent: {13????}. There are\r\nno other children of this node, so we must backtrack to its parent: {1?????}.\r\nThere is another child of this node, so we explore it: {14????}.\r\n\r\nOK, so we won't explore it. This process is much better carried out by a\r\nmachine than us. But I have shown the details of how the machine does it. There\r\nare 4 solutions to the 6-Queens problem, but we would have to do a lot of hard\r\nwork to find them.\r\n\r\nSee the following references.\r\n\r\nhttp://mathworld.wolfram.com/QueensProblem.html\r\nhttp://en.wikipedia.org/wiki/Eight_queens_puzzle\r\n\r\n\r\n\r\nN-Coloring a Graph:\r\n\r\nWe can use this same approach to generate solutions for the N-color problem.\r\nIn the N-Color problem, we ask whether it is possible to color a graph (and \r\nwhat those colors would be) with N different colors, such that no nodes in the\r\ngraph that are connected by an edge are the same color. Not all graphs can be\r\nN-colored. For example the following graph cannot be 3-colored because each of\r\nits 4 nodes is connected by edges to the 3 others, so with only 3 colors one\r\nof the 4 nodes would have the same color as a node that it is connected to.\r\n\r\n   1  -  2\r\n   | \\ / |\r\n   |  +  |\r\n   | / \\ |\r\n   3  -  4\r\n\r\nThis problem is related to a very old and interesting mathematical problem,\r\nknown as the 4-color conjecture. It concerns the number of colors needed\r\nto display a geographic map, such that two adjacent \"countries\" (consider\r\noceans countries too) are not the same color. We can tranform any geographic\r\nmap into an equivalent graph (if you can N-color one, you can N-color the\r\nother) by representing each \"country\" by a node, with edges connecting nodes\r\nrepresenting countries that share a border. The resulting graph will be called\r\n\"planar\" meaning it can be drawn in the plane, with no intersecting edges.\r\n\r\nNote that the graph above is not planar, because the + sign in the middle shows\r\nwhere two edges cross. The graph below has 4 nodes and 5 edges, and is planer.\r\nIt can be 3 colored with the colors red, green, and blue (labeled R, G, and B).\r\nNote that the two nodes labeled r are not connected by an edge. Such a graph\r\ncannot be 2 colored (try it).\r\n\r\n   R  -  G\r\n   |   / |\r\n   |  /  |\r\n   | /   |\r\n   B  -  R\r\n\r\nIt was proven in the late 1800s that any geographic map can be 5-colored. There\r\nwere many known examples of geographic maps that could not be 3-colored. But\r\nno one had a proof, or a counter example, as to whether every geographic map\r\ncould be 4-colored. A few (incorrect) proofs of this conjecture were proposed\r\nand one was accepted as proof (no one could find a mistake at the time), but\r\nmany years later it was shown to be incorrect. Finally, in 1976 Appel and Haken\r\nproved that every geographic map was reducable to one of 1936 different ones,\r\nand they wrote a computer program that verified that each was 4-colorable. The\r\nuse of a computer program in a mathematical proof raised all sorts of\r\nphilosophical questions about the nature of mathematical proof that are still\r\nbeing debated today. A well-written account of the history of this problem is:\r\nWilson, \"Four Colors Suffice: How the Map Problem Was Solved.\"\r\n\r\nLike the N-Queens problem, the branching factor for a node depends on the\r\npreviously chosen aspects and their values.\r\n\r\nLet's attempt to 3-color the following graph (you have to draw in the edges).\r\n\r\n\r\n                      1\r\n                 \r\n             2        3        4\r\n\r\n                 5        6\r\n\r\n\r\n                 7        8\r\n\r\n             9                 10\r\n\r\nConnections:\r\n  1: to 2, 3, and 4\r\n  2: to 1, 5, and 9\r\n  3: to 1, 7, and 8\r\n  4: to 1, 6, and 10\r\n  5: to 2, 6, and 8\r\n  6: to 4, 5, and 7\r\n  7: to 3, 6, and 9\r\n  8: to 3, 5, and 10\r\n  9: to 2, 7, and 10\r\n 10: to 4, 8, and 9\r\n\r\nWe will represent each node as\r\n\r\n              {1=?,2=?,3=?,4=?,5=?,6=?,7=?,8=?,9=?,10=?}\r\n\r\nwhere each ? can be the color red, green, or blue. For writing purposes, we\r\nwill abbrevate these colors as R, G, and B and abbreviate this notation  as\r\n{??????????} where the ith ? represents node i. We will choose these aspects\r\nin the order 1, 2, ... It might be better (generate solutions faster) to\r\nchoose the node that has the most number of edges (or the fewest) as the next\r\naspect to try. This would be an interesting topic to explore on the computer,\r\nbut is beyond what I can discuss here.\r\n\r\nWe start by choosing an aspect (node in a graph) and the colors that it can be\r\n(say, Red, Green, or Blue), given the nodes that it is connected to that\r\nalready have colors. Let's choose 1.\r\n\r\n                           {??????????}\r\n              1=R/            1=G|              \\1=B                \r\n           {R?????????}    {G?????????}      {B?????????}\r\n\r\nWe continue by exploring the left-most node and choose aspect 2. Since node 2\r\nis connected to node 1, which already has color R, there are only 2 choices for\r\ncolors for aspect 2.\r\n\r\n                           {??????????}\r\n              1=R/            1=G|              \\1=B                \r\n           {R?????????}    {G?????????}      {B?????????}\r\n        2=G/            \\2=B       \r\n     {RG????????}  {RB????????}\r\n\r\nWe continue by exploring the left-most node and choose aspect 3. Since it is\r\nconnected to 1, which already has color R, there are only 2 choices for\r\ncolors for aspect 3. In the tree below we will focus on {RGG???????} eliding\r\nits siblings.\r\n\r\n                               {??????????}\r\n                                   1=R/                1=G|             \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n\r\nWe continue by exploring the left-most node and choose aspect 4. Since it is\r\nconnected to 1, which already has color R, there are only 2 choices for\r\ncolors for aspect 4. In the tree below we will focus on {RGGG??????}.\r\n\r\n                               {??????????}\r\n                                   1=R/                1=G|             \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n\r\nWe continue by exploring the left-most node and choose aspect 5. Since it is\r\nconnected to 2, which already has color G, there are only 2 choices for\r\ncolors for aspect 5. In the tree below we will focus on {RGGGR?????}.\r\n\r\n                                 {??????????}\r\n                                   1=R/                1=G|             \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n\r\nWe continue by exploring the left-most node and choose aspect 6. Since it is\r\nconnected to 4 and 5, which already have colors G and R, there is only 1\r\nchoice for the color for aspect 6. In the tree below we will focus on\r\n{RGGGRB????}.\r\n\r\n                                 {??????????}\r\n                                     1=R/             1=G|              \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n6=B|\r\n{RGGGRB????}\r\n\r\nWe continue by exploring this node and choose aspect 7. Since it is connected\r\nto 3 and 6, which already have colors G and B, there is only 1 choice for the\r\ncolor for aspect 7. In the tree below we will focus on {RGGGRBR???}.\r\n\r\n                                 {??????????}\r\n                                    1=R/             1=G|              \\1=B \r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n6=B|\r\n{RGGGRB????}\r\n7=R|\r\n{RGGGRBR???}\r\n\r\nWe continue by exploring this node and choose aspect 8. Since it is connected\r\nto 3 and 5, which already have colors G and R, there is only 1 choice for the\r\ncolor for aspect 8. In the tree below we will focus on {RGGGRBRB??}.\r\n\r\n                                 {??????????}\r\n                                     1=R/             1=G|              \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n6=B|\r\n{RGGGRB????}\r\n7=R|\r\n{RGGGRBR???}\r\n8=B|\r\n{RGGGRBRB??}\r\n\r\nWe continue by exploring this node and choose aspect 9. Since it is connected\r\nto 2 and 7, which already have colors G and R, there is only 1 choice for the\r\ncolor for aspect 8. In the tree below we will focus on {RGGGRBRBB?}.\r\n\r\n                                 {??????????}\r\n                                     1=R/             1=G|              \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n6=B|\r\n{RGGGRB????}\r\n7=R|\r\n{RGGGRBR???}\r\n8=B|\r\n{RGGGRBRB??}\r\n9=B|\r\n{RGGGRBRB??}\r\n\r\nWe continue by exploring this node and choose aspect 10. Since it is connected\r\nto 4, 8, and 9, which already have colors G, B, and B, there is only 1 choice\r\nfor the color for aspect 8. In the tree below we will focus on {RGGGRBRBBR}.\r\n\r\n                                 {??????????}\r\n                                     1=R/             1=G|              \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n6=B|\r\n{RGGGRB????}\r\n7=R|\r\n{RGGGRBR???}\r\n8=B|\r\n{RGGGRBRB??}\r\n9=B|\r\n{RGGGRBRBB?}\r\n10=R|\r\n{RGGGRBRBBR}\r\n\r\nThere are no aspects left for the problem, so the apsects and their values\r\ndescribe a solution: 1 is red, 2 is green, 3 is green, 4 is green, 5 is red,\r\n6 is blue, 7 is red, 8 is blue, 9 is blue, and 10 is red.\r\n\r\nTo generate more solutions we would backtrack to node 4 (the last time we\r\ngenerated two subtrees), and take the right subtree by assigning aspect 5 a\r\nvalue of B. Then we would choose aspect 6 again. Since it is connected to 4 and\r\n5, which now have colors G and B, there is only 1 choice for colors for aspect\r\n6.\r\n\r\n                                 {??????????}\r\n                                     1=R/             1=G|              \\1=B\r\n                               {R?????????}         {G?????????}   {B?????????}\r\n                       2=G/                    \\2=B       \r\n                  RG????????}              {RB????????}\r\n            3=G/                \\3=B       \r\n       {RGG???????}        {RGB???????}\r\n    4=G/          \\4=B       \r\n{RGGG??????}      {RGGB???????}\r\n5=R/         \\5=B       \r\n{RGGGR?????} {RGGGB??????}\r\n                6=R|\r\n              {RGGGRB????}\r\n\r\nAnd the search would continue through all combination of colors.\r\n\r\nIn the worst case, each aspect would have three possible values, which would\r\nlead to 3^N leaves. But, we see that some aspects (especially those \"lower\" in\r\nthe tree) are constrained to have fewer: 2, or even 1 (or possibly 0 aspects,\r\nmeaning no solution is possible for the choices already made).\r\n\r\n\r\nGeneral Algorithm:\r\n\r\nThere is a rather compact algorithm for implementing recursive-backtracking\r\nsearch. Generally, each recursive call reduces the problem size by choosing an\r\naspect and iterating through all possible values for it (like searching an\r\nN-ary tree) finding those values for the aspect that lead to a solution. All\r\nsolutions are accumulated in a set of solution maps: each solution map in the\r\nset has all the aspects as keys, with each key mapping to its value in that\r\nsolution.\r\n\r\n  //Find all solutions to a problem  (each is a Map) and return a Set of them\r\n  public static void solveAll (Problem problem,\r\n                               Set<Map<Problem.Aspect,Object>> solutions) { \r\n    try {\r\n      //Choose an aspect (and exclude it from being chosen again)\r\n      //  Possibly throw Succeed/Fail\r\n      //Succeed if no more aspect to choose from and problem solved\r\n      //Fail    if no more aspect to choose from and problem NOT solved\r\n      Problem.Aspect aspect = problem.chooseAndExcludeAspect();\r\n\r\n      //For every possible value for that aspect, recursively attempt to\r\n      //  solve a copy of the problem with that aspect bound to that value\r\n      //If a solution is found, return it; if not, unbind the aspect and\r\n      //  continue looping (finding a new value to bind to the aspect).\r\n      for (Object value : aspect) {\r\n        problem.assignAspectValue(aspect, value);\r\n        solveAll (problem.copy(), solutions);\r\n        problem.removeAspectValue(aspect);\r\n      } \r\n    } catch (Succeed s){solutions.add(problem.getSolution());}\r\n      catch (Fail    f){}\r\n  }\r\n}\r\n\r\nOn the page that lists sample programs, there is a download for \"Backtracking\"\r\nwhich include a few classes comprising this general problem solver, as well\r\nas  classes to represent and solve the satisfiability problem, the N-Queens\r\nproblem, and Sudoku. Here is a recap of the aspects and values for these\r\nproblems as well as N-Coloring of maps and maze escaping.\r\n\r\nWhen writing code to solve a new problem, you must examine the Problem and\r\nAspect classes. If you can correctly write the Problem and Aspect classes,\r\n supplying all the specified methods to represent and manipulate a specific \r\nproblem to solve, the code in the backtracking package will solve that problem.\r\n\r\nThat code works without knowing what problem it is solving, much like sort\r\nmethods can sort using a comparison function, without knowing what they are\r\nsorting, so long as the comparison function correctly determines which is\r\nsmaller.\r\n\r\nExamples\r\n\r\n  Satisfiability: Illustrate with\r\n    Aspect  : a variable\r\n    Values  : false, true\r\n    Solution: Map[variable] -> boolean\r\n\r\n  N-Queens\r\n    Aspect  : a row for the queen\r\n    Values  : a column for the queen (not attacked by any placed queen)\r\n    Solution: Map[row] -> column of queen in that row\r\n\r\n  N-Coloring a Graph (related to 3-Coloring a Geographic Map)\r\n    Aspect  : a node to color\r\n    Values  : one color (number them 1-N) not the same as an adjacent node\r\n    Solution: Map[node] -> color of that node\r\n\r\n  Sudoku:\r\n    Aspect  : an entry in the digit matrix\r\n    Values  : a digit allowable in that entry by the Sudoku rules\r\n              (unique digits in colunns, rows, and 3x3 blocks/regions)\r\n    Solution: Map[entry in digit matrix] -> digit in the matrix position\r\n\r\n  Maze Exploration\r\n    Aspect  : the spot you are standing if you are not at the exit\r\n    Values  : the spots you can move to in one step (not moving through walls)\r\n    Solution: Map[time] -> which-way you stepped at that time (North, South,\r\n              East, or West)\r\n\r\nI'm looking for students to implement classes that my problem solver can use\r\nto solve N-Coloring, Maze Exploration, and other problems solvable within\r\nthis framework.\r\n", "encoding": "ascii"}