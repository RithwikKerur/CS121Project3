{"url": "https://www.ics.uci.edu/~eli/courses/cs153-f09/example-seq.txt", "content": "---------------------------------------------------\n-- n-bit Register (ESD book figure 2.6)\n-- by Weijun Zhang, 04/2001\n--\n-- KEY WORD: concurrent, generic and range\n---------------------------------------------------\n\t\nlibrary ieee ;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\n---------------------------------------------------\n\nentity reg is\n\ngeneric(n: natural :=2);\nport(\tI:\tin std_logic_vector(n-1 downto 0);\n\tclock:\tin std_logic;\n\tload:\tin std_logic;\n\tclear:\tin std_logic;\n\tQ:\tout std_logic_vector(n-1 downto 0)\n);\nend reg;\n\n----------------------------------------------------\n\narchitecture behv of reg is\n\n    signal Q_tmp: std_logic_vector(n-1 downto 0);\n\nbegin\n\n    process(I, clock, load, clear)\n    begin\n\n\tif clear = '0' then\n            -- use 'range in signal assigment \n            Q_tmp <= (Q_tmp'range => '0');\n\telsif (clock='1' and clock'event) then\n\t    if load = '1' then\n\t\tQ_tmp <= I;\n\t    end if;\n\tend if;\n\n    end process;\n\n    -- concurrent statement\n    Q <= Q_tmp;\n\nend behv;\n\n---------------------------------------------------\n\n\n\n----------------------------------------------------\n-- VHDL code for n-bit counter (ESD figure 2.6)\n-- by Weijun Zhang, 04/2001\n--\n-- this is the behavior description of n-bit counter\n-- another way can be used is FSM model. \n----------------------------------------------------\n\t\nlibrary ieee ;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\n----------------------------------------------------\n\nentity counter is\n\ngeneric(n: natural :=2);\nport(\tclock:\tin std_logic;\n\tclear:\tin std_logic;\n\tcount:\tin std_logic;\n\tQ:\tout std_logic_vector(n-1 downto 0)\n);\nend counter;\n\n----------------------------------------------------\n\narchitecture behv of counter is\t\t \t  \n\t\n    signal Pre_Q: std_logic_vector(n-1 downto 0);\n\nbegin\n\n    -- behavior describe the counter\n\n    process(clock, count, clear)\n    begin\n\tif clear = '1' then\n \t    Pre_Q <= Pre_Q - Pre_Q;\n\telsif (clock='1' and clock'event) then\n\t    if count = '1' then\n\t\tPre_Q <= Pre_Q + 1;\n\t    end if;\n\tend if;\n    end process;\t\n\t\n    -- concurrent assignment statement\n    Q <= Pre_Q;\n\nend behv;\n\n-----------------------------------------------------\n\n-----------------------------------------------------\n-- VHDL FSM (Finite State Machine) modeling\n-- (ESD book Figure 2.7)\n-- by Weijun Zhang, 04/2001\n--\n-- FSM model consists of two concurrent processes\n-- state_reg and comb_logic\n-- we use case statement to describe the state \n-- transistion. All the inputs and signals are\n-- put into the process sensitive list.  \n-----------------------------------------------------\n\nlibrary ieee ;\nuse ieee.std_logic_1164.all;\n\n-----------------------------------------------------\n\nentity seq_design is\nport(\ta:\t\tin std_logic;\n\tclock:\t\tin std_logic;\n\treset:\t\tin std_logic;\n\tx:\t\tout std_logic\n);\nend seq_design;\n\n-----------------------------------------------------\n\narchitecture FSM of seq_design is\n\n    -- define the states of FSM model\n\n    type state_type is (S0, S1, S2, S3);\n    signal next_state, current_state: state_type;\n\nbegin\n    \n    -- cocurrent process#1: state registers\n    state_reg: process(clock, reset)\n    begin\n\n\tif (reset='1') then\n            current_state <= S0;\n\telsif (clock'event and clock='1') then\n\t    current_state <= next_state;\n\tend if;\n\n    end process;\t\t\t\t\t\t  \n\n    -- cocurrent process#2: combinational logic\n    comb_logic: process(current_state, a)\n    begin\n\n\t-- use case statement to show the \n\t-- state transistion\n\n\tcase current_state is\n\n\t    when S0 =>\tx <= '0';\n\t\t\tif a='0' then\n\t\t\t    next_state <= S0;\n\t\t\telsif a ='1' then\n\t\t\t    next_state <= S1;\n\t\t\tend if;\n\n\t    when S1 =>\tx <= '0';\n\t\t\tif a='0' then \n\t\t\t    next_state <= S1;\n\t\t\telsif a='1' then \n\t\t\t    next_state <= S2;\n\t\t\tend if;\n\n\t    when S2 =>\tx <= '0';\n\t\t\tif a='0' then\n\t\t\t    next_state <= S2;\n\t\t\telsif a='1' then\n\t\t\t    next_state <= S3;\n\t\t\tend if;\n\n\t    when S3 =>\tx <= '1';\n\t\t\tif a='0' then \n\t\t\t    next_state <= S3;\n\t\t\telsif a='1' then \n\t\t\t    next_state <= S0;\n\t\t\tend if;\n\n\t    when others =>\n\t\t\tx <= '0';\n\t\t\tnext_state <= S0;\n\n\tend case;\n\n    end process;\n\nend FSM;\n\n-----------------------------------------------------\n\n", "encoding": "ascii"}