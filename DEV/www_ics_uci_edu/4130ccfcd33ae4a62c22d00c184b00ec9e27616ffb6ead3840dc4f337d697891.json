{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990518.txt", "content": "Advanced Collections Minutes - May 18, 1999\n\nAttending: Judy Slein, Jim Whitehead, Geoff Clemm, Jim Davis, Jason Crawford\n\nACTION ITEMS\n\nJudy: Draft language about how DELETE on a collection depends on locks below that\ncollection in the hierarchy.\n\nJudy: Revise the section on embedded redirect references to collections, to \nsimplify it in line with Geoff's comments.\n\nJudy: Start a discussion on the mailing list on the semantics of DELETE.\n\nJim W: Start a discussion on redirect references to collections.\n\nJudy: Edit spec till COB Friday.\n\nJim W: Edit spec when Judy is done.\n\nSLASHES IN MEMBER NAMES\n\nGeoff: Is the slash included in the member name for members that are collections? \nIt seems so obvious that it is not that it's hard to explain why. \n\nJim W: It depends whether you come from a file system background.  From the point\nof view of the URI world, it makes perfect sense for two URIs, one of which ends in \na slash and the other of which does not, to refer to different things.  There may\nbe a server convention that makes them always refer to the same thing.\n\nJim W: rfc 2518 says that the server can interpret such URIs as being to the same \nresource, but clients should differentiate.  \n\nGeoff: This would cause interoperability problems.  \n\nJim W:  The client would just have to know what kind of server it's talking to.  \nThis approach saves the URL spec from defining namespace foldings for slash.  \n\nGeoff thinks we are being inconsistent, Jim does not.\n\nGeoff eventually wants to have a property that lists a collection's members, and\nhe wants the semantics to be clear for that property. \n\nJim W: Leave slash folding undefined like case folding.\n\nGeoff: If we listed all bindings, we would have to list both foo and foo/ separately,\nfolding would not be allowed.\n\nJim: For case folding, conceptually there are lots of bindings but only one gets \nincluded in listings.\n\nGeoff: All file-system-based servers are slash-folding.\n\nJim W: This is ok as long as when the server reports to the client, it includes \na slash when the binding is to a collection. AGREED.\n\nGeoff wants a binding name to be a slash-free segment. AGREED.\n\nLOCK / DELETE AND BINDINGS\n\nJim W: The problems we've been having in sorting out the effects of LOCK on \nnamespaces result from our assumption that bindings are owned by collections. If we \nshift our thinking to be that a resource has some ownership over its end of \na binding as well, that will resolve this locking problem.\n\nJim W's mail: Binding is more than just state on a collection; it has to be owned\nby both ends of the relationship.  If it is just owned by the collection, then you \ncould make the target of the binding inaccessible even though the resource is locked.\nWe've defined delete to be unbind. If only the collection owns the binding, then \nlock on its target doesn't affect the binding / collection.\n\nGeoff: Lock has 2 aspects: it locks state and locks something in the namespace.  \nIf you have 2 URLs mapped to a resource and submit a LOCK via one of them, the state \nis locked but the only part of the namespace that is locked is the part that is in \nthe request-URL.  Geoff really would prefer that LOCK have no effect on the\nnamespace. Yaron thinks (judging from e-mail conversations) that LOCK only affects \nnamespace of the one binding that was used to LOCK the resource.  \n\nJudy: But look at rfc 2518 section 8.10.3.  That seems to say that all URIs through\nwhich the locked resource is accessible must be preserved.\n\nJim W: Also interprets RFC 2518 to say that LOCK on a resource doesn't lock all \npossible paths to it, but only the one that was used to request the lock.\n\nGeoff would prefer: (for versioning) Only state is locked, namespace is not affected.\nThe server can choose to lock the namespace.  It can choose to lock one or all or \nnone of the URLsthat give access to the locked resource.\n\nJim W: In that case, you could make a locked resource completely inaccessible.\n\nGeoff: If the locked resource had 3 bindings and I remove one while it's locked,\nthat's ok.\n\nJim W: We don't want to allow the last binding to be removed.  As long as lock \nalways insures that the binding used for the lock stays (or at least keeps one \nbinding available), that's what he is looking for.\n\nGeoff: A good compromise position is that a LOCK just preserves one binding.  It's \njust too hard for a server to make sure that none of the bindings to a locked \nresource can be removed.\n\nJason: We all agree that when we lock resource, we need a guarantee that there will\nbe a URL to access it while it is locked, so we'll maintain the one we used to lock \nit.  But this depends on lots of bindings scattered through the hierarchy.\n\nGeoff: It's the possibility of multiple bindings on parents that makes it too hard \nto require that all URLs stay valid.\n\nGeoff: Let's just say that if a resource is LOCKed, it must be possible to use the \nURL that was used to request the lock, and that you can't violate any locks when \nyou DELETE a collection.\n\nTyson: what is a lock? it locks a resource.  what is this about bindings?\n\nGeoff: Locking something in a namespace affects lots of collections.  We need the \nconcept of locking a mapping. That's well defined.  Then the requirement is that\ndeletion of a binding may not violate anyv locks on mappings.\n\nACTION: Judy will draft this.\n\nBINDINGS IN RFC 2518 COLLECTIONS\n\nJudy: Geoff and I seem to have a basic disagreement about whether advanced \ncollections differ from rfc 2518 collections in having bindings as part of their\nstate.  I think that both have bindings as part of their state.\n\nGeoff: DELETE on an rfc 2518 collection could do one thing or another, but on an\nadvanced collection DELETE has specific meaning.\n\nJim W; Why is this a problem?\n\nGeoff: We can take either of 2 positions:\n   Both kinds of collections have bindings as part of their state, but DELETE means \n   something different; or \n   DELETE means the same thing for both sorts of collections, but only advanced\n   collections have bindings as part of their state. \n\nJim W: What we should do is deprecate the requirement in RFC 2518 that DELETE\nremoves all URIs to the resource being deleted.\n\nGeoff: As long as we can be clear about DELETE semantics, it's ok to say that \nbindings exist in both.\n\nJim W: Wants to make the changes in rfc 2518.\n\nGEOFF'S TERMINOLOGY ISSUES\n\nIn the definition of \"Binding\" you talk about members instead of internal members.\nJim only changed from the rfc 2518 language because thought old language\ncaused confusion. Is this worse?\n\n\"Reference\" is a bad term to apply to both bindings and redirect references. Let's \nthink of url-to-url associations as references. You can create them even though\nthe resource isn't there yet.  You can't do that for name-to-resource association\n(binding). Let's use the term \"association\" to encompass bindings, mappings, and \nredirect references. AGREED.\n\nWe don't need the definitions of strong / weak references.  Integrity is always\nguaranteed for bindings.  We don't think servers will ever provide strong integrity\nfor redirect references (their appeal was supposed to be simplicity for the server).\nLet's get rid of the Ref-Integrity header and refintegrity property, and add them\nlater if needed.  AGREED.\n\nJim W: Can we just call a redirect reference a redirect (or redirect resource)? \n\nJudy: We may sometimes need to distinguish a redirect reference from a redirect as\ndefined in HTTP 1.1.  \n\nJim W: We should comb through both the HTTP 1.1 spec and the collections spec to see\nwhether there is baggage associated with redirect from HTTP 1.1 that we need differs\nfrom redirect references.\n\nCONSISTENCY OF MAPPINGS VS. BINDINGS\n\nGeoff: Section 4.1 says that MOVE and DELETE operations cannot leave mappings in an\ninconsistent state.  This is not true.  Bindings always have to be consistent, but\nmappings are not guaranteed to have integrity. \n\nDESTINATION HEADER WITH BIND\n\nGeoff: BIND as currently specified uses the Ref-Target header, but he would prefer\nto use the Destination header to make it like COPY / MOVE.  AGREED.  \n\nCurrently, Ref-Target is allowed to be a relative URL.  The Destination header is\ndefined in rfc 2518 to be an absolute URL.  Can we allow Destination to be relative \nin the context of BIND? (Geoff would actually like to see it allow relative URLs in \nMOVE and COPY as well.)  Can we extend the definition given in rfc 2518?  Jim W\nthinks not.  There was no extension mechanism built into the BNF in rfc 2518.\n\nTo be consistent, we will require the value of Destination to be an absolute URL.\nAGREED.\n\nURL MAPPINGS CREATED BY BIND\n\nGeoff: A much simpler definition of the set of mappings could be given, rather than\nthe recursive rule now in the spec.\n\nJim W: But then it doesn't leap out at you that if the parent has multiple bindings, \nthere's an exponential explosion of mappings.  \n\nGeoff: The example shows this.  As it is now, the rules give the impression that the\nrelationship between bindings and mappings is very complicated.\n\nBIND EXAMPLE IN 4.2.6\n\nGeoff: The description of the example says that a new binding is created and \"in\naddition\" the binding is added to the collection.  It should say \"as part of this \nprocess\". A binding is just part of the state of a collection.  The only way to \ncreate a new binding is to put it in a collection.\n\nCOPY AND BINDINGS 4.2.9\n\nGeoff: This discussion loses the distinction between COPY and MOVE.  The essence of\nCOPY is that it creates a new resource, but that's not clear here.\n\nJim W: Wants the method descriptions to be deltas on 2518.  We shouldn't be \nduplicating definitions from other specs.\n\nGeoff: Basing MOVE on COPY in rfc 2518 was a mistake and will cause continuing \nconfusion.\n\nBACKPOINTERS\n\nJim D concurs with our May 11 decision to have backpointers for bindings, but\nnot for redirect references.  They wouldn't be useful for redirects off server,\nbut they are especially crucial for bindings because there is no reftarget property\non bindings that could be searched with DASL.  Backpointers are, as in earlier drafts,\noptional.\n\nRESOLVING EMBEDDED REDIRECT REFERENCES TO COLLECTIONS\n\nGeoff: This can be much simpler than it currently looks in the spec.  It's the\napparent complexity that scares people. You don't have to talk about any constraints \non types of resources (collection or not). Geoff wants to allow embedded redirects \nand thinks it should be easy to define processing for this. Jason is mildly concerned\nabout it.  Jim W had an action item to investigate implementation and performance\nimplications of this feature, but hasn't completed the action.  Judy will try to\nrevise this section.\n\nINTEGRITY OF BINDINGS\n\nJudy: We need to state clearly the integrity requirements on bindings.  She would\nprefer to see a separate section on this, since it relates to a number of methods.\nGenerally speaking, the requirement is that servers must fail any method that \nwould create a binding (BIND, COPY, MOVE, PUT, etc) unless it can guarantee that no\nMOVE or DELETE through another binding will ever leave this binding broken.\n\nOthers prefer that the integrity constraints be discussed in the methods where they\napply.  Jim W does not want to see a summary section for this information, because in\ngeneral duplicated information causes confusion and is a maintenance headache.\n\nGeoff: Do say that PUT and COPY create a single binding. A server shouldn't\nleave around a dangling binding after a DELETE that could result later in a PUT or \nCOPY making multiple bindings available.  \n\nJim W: There might be cases where you would want PUT to create multiple bindings.\nMaybe if we someday provide authoring for variants, we might want to let clients do\na PUT on the resource that negotiates with a header that says I'm really giving the \nFrench variant.  \n\nGeoff: Let variants be mappings, not bindings.  \n\nJim W: It seems overly restrictive to allow only 1 binding.  \n\nGeoff: It violates the intent of DELETE if I have bindings to a resource in 2\ncollections, and delete them both, but a resource can reappear in both collections\nwhen I do a PUT on one of those bindings. \n\nJim W: If a server has this behavior, it's becuase it knows its own namespace and \nis doing it for some good reason.\n\nJim W: In favor of some extra language, but keep it distributed and be careful of\nextra MUSTs.\n\nJUDY'S MINOR CONCERNS\n\nAt this point, Jim Davis and Geoff Clemm had left.  So it was decided to spend the\nrest of the meeting resolving minor issues.\n\nJudy's comment #6: There are several points about the semantics of bindings that\nwe agreed on in the 5/4/99 phone conference, but have not found their way into the\nspecification.  These should be added to section 4.1 (Overview).\n\n- PUT through one binding must be visible in a GET on any binding to the same\n  resource\n\n- GET with the same headers on 2 bindings to the same resource must result in\n  the same entity\n\n- PROPFIND through one binding must result in the same values for all properties\n  (except if there turn out to be live properties whose value depends on which\n  binding is used) as through any other binding to the same resource\n\n- A server is free to decide whether to allow bindings to a resource that supports\n  content negotiation or to content generated by a cgi script or to any dynamically\n  generated content\n\nAGREED: These points will be added to 4.1.\n\nJudy's comment #7: There are several remaining questions about topics other than\nbindings.\n\n- Do we allow Passthrough: T with MOVE or DELETE for redirect references?\n\nJudy: The result of such a request would be a 302, and then the client would decide\nwhether to resubmit the request to the target resource.  For a collection that\ncontains redirect references, it would result in a multistatus response with 302s\nfor all the redirect references.\n\nJim W: Multistatus is already defined for MOVE and DELETE, so that is not a problem.\nAllowing Passthrough: T wouldn't cause any semantic problems.\n\nAGREED:  We will allow this.\n\n- Jim's proposal of a new status code for use when a client tries to position a\ncollection member in an unordered collection.\n\nJudy: There seems to be continuing discussion of this on the list.\n\nJim W: Is not prepared to invent a new general purpose error mechanism as part of\nhandling this case.\n\nJudy: New status code seems fine.  It should also apply to the case where a client\ntries to position a collection member in a collection whose ordering is server-\nmaintained.\n\nAGREED: We will introduce a new status code for these cases.  \n\nJudy's comment #8: Get rid of state from all diagrams. Distinguishing between a\nresource and its state adds nothing to the discussion.  Nothing depends on this\ndistinction, and it's also debatable whether it's consistent with the definition\nof \"resource\" in the URI spec, so let's not show it.\n\nJim W: Had already thought about doing this.\n\nAGREED: The diagrams will not distinguish state from resource.\n\nJudy's comment #9: I think there is some confusion (sloppiness?) in the spec about\nthe distinction between a URI path segment and a binding.  A binding is an\nassociation between a URI path segment and a resource, but sometimes we talk as if\nthe binding is just the URI path segment.  Do we want to say that the\nmembers of a collection are URI path segments or that they are bindings?\n\nJim W: They are bindings.\n\nJudy: It may not actually matter unless there are things that would be implemented\ndifferently depending on which answer we give.  There are inconsistencies in the\nspec, though -- places where we talk as if the members are URI segments, and other\nplaces where we say they are bindings.\n\nJim W: We should comb for collection member in both RFC 2518 and the collection\nspec to see whether there are any conflicts or problems if we stay with our position \nthat collection members are bindings.\n \nJudy: Check for consistency within the collection spec, too.\n\nJudy's comment #10:  Agree with Jim W that we need to clean up the spec to get rid\nof duplicate information, but unclear how to do this.  We agreed at one point that\nmethod descriptions would include normative language about which headers MAY / MUST\nbe used with the method.  Normative language about values of the headers and server\nbehavior for each value would be in the definition of the header.\n\nJim W: Yes. In the method description, just list headers with no description of what\nthey mean.  You can give readers a general sense of what the headers are for just \nthrough their names and implicitly in the rest of the discussion.  There should be\nno explicit discussion of what the headers are for in the method description. AGREED.\n\nJudy's comment #11: I don't believe what we say in paragraph 3 of 4.2.8 about our\ninterpretation of DELETE being consistent with RFC 2068.  It's just not true that\nan HTTP 1.1 client couldn't tell whether a single binding or all bindings had been\nremoved.\n\nJim: Would you be happier just flatly saying that we are reinterpreting DELETE?\n\nJudy: Yes.\n\nAGREED: We will rewrite this paragraph to say that we are reinterpreting DELETE.\n\nJudy's comment #12:  In section 4.2.1 we equate a request-URI having \"no path \nsegment\" with a Request-URI having \"just a scheme and authority\", but a request-URI\nnever has an explicit scheme and authority.  Besides, the point we are really trying\nto make is that you can't create a binding to the root collection (because there's\nno collection for the binding to belong to).  That point would be clearer if we\ndefined request-URI having no path segment as request-URI \"/\".\n\nAGREED.\n\nJudy's comment #13: Some of the diagrams we use were originally designed for more\ncomplicated scenarios, and so are more complicated than they need to be in their\nnew context. Judy will simplify these.\n\nJudy's comment #14: I need someone to explain how a resource can have an infinite \nnumber of mappings.\n\nJim W:  This can happen if there is a binding loop.  \n\nWe should either mention binding loops where we say that a resource can have an\ninfinite number of bindings or just say that a resource can have many bindings.\n\nJudy's comment #15: The definition of \"target resource\" allows it to apply only\nto redirect references.  Do we want to be able to talk about the target of a\nbinding?\n\nNo.  The definition can stand as it is.\n\nJudy's comment #16: In section 3 (overview of ordering) there is some discussion\nof human language descriptions, but nothing in advanced collections addresses\nthis problem, so let's get rid of it.\n\nAGREED.\n\nJudy's Comment #17: Section numbering of the appendices is confused.\n\nJim W: We don't want to lose the hard-won understanding of strong references.  We may\nneed it if we later add direct references.  So he the discussion of strong references\nto an appendix.\n\nJudy: We could move it into the rationale document.  The risk is that that document\nwill never be completed.\n\nNot resolved.\n\nJudy's comment #18: We introduce section 4.1 by saying that the mechanisms we provide\nfor resource sharing are bindings and redirect references, and then immediately\nstart talking about mappings.  This is confusing.\n\nJim W: It seemed reasonable to do this because both bindings and mappings are\ndefined in an earlier section.\n\nJudy: Has some ideas about how to re-organize this discussion.  Judy will edit and see\nwhat Jim thinks.\n\nJudy's comment #19:  There is a significant typo in the example of generating a\nset of mappings (Section 4.2.4, step 5).  Judy will fix this.\n\nJudy's comment #20: The titles of the examples in 4.2.6 and 4.2.7 don't really reflect\nwhat the examples show.\n\nJim W: Each example may show multiple points.  Anyhow, since we are replacing the\nRef-Target header with the Destination header, which must be an absolute URI, the\nexamples and their titles will change.\n\nJudy's comment #21: We agreed in an earlier meeting that we would never use the term\n\"mapping\" alone (unless in its generic sense), but instead would always use\n\"URL mapping\".  Judy will fix this.\n\nREVIEW OF ACTION ITEMS\n\nThere have been a number of action items from the past few weeks that were never\ncompleted.  Which of these still matter?\n\nJudy will start a discussion on the mailing list on the semantics of DELETE.\n\nJim will start a discussion on redirect references to collections.\n\nWe don't need to have a general discussion of the semantics of bindings.\n\n", "encoding": "ascii"}