{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/WebAPIs/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Web APIs</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Web APIs</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>In our previous <a href=\"../HTTP\">example</a>, we saw that the Python standard library makes it easy to download a web page.  Given a URL, which specifies the location of the page you want to download, the <b>urllib.request.urlopen()</b> function hides nearly all of the details of the conversation between your Python program and the web server that will send the page back to it.  You do have to know what HTTP is, and you do have to understand a few details of how it works (e.g., status codes, URLs, and perhaps headers), but you don't have the implement the HTTP protocol from scratch, you don't have to know the precise format of an HTTP request or response, and the function more or less \"just works,\" as long as the page is available, your Internet connection is active, and you open the right URL.</p>\r\n\r\n<p>However, writing a program to download a web page &mdash; the same page you might see if you visited a particular URL in a web browser &mdash; often isn't the right choice.  A web page is suitable for display to a human user within a browser, but isn't necessarily a suitable result for a program to download.  For example, you can visit YouTube and search for whatever you'd like &mdash; say, <b>lakers clippers</b>, if you like basketball &mdash; and you'll get back a result like this one:</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://www.youtube.com/results?search_query=lakers+clippers\">https://www.youtube.com/results?search_query=lakers+clippers</a></li>\r\n</ul>\r\n\r\n<p>But if you wanted to write a Python program that was capable of obtaining just the titles of the videos on that page, you'd have a surprisingly difficult time doing it.  The problem is that the web page isn't what it first seems.  Its structure looks simple and straightforward when displayed in a browser, but it's actually surprisingly complex.  If you've never looked at the source code of a web page before, visit the YouTube link above, then right-click in an empty area of the page and select something like <b>View Page Source</b> &mdash; it'll be slightly different depending on what browser you use, but will likely be available in any browser running on a laptop or desktop machine, though perhaps not on a smartphone or other small-sized device.  What you'll see is a combination of HTML, JavaScript, CSS, and other code used to make the page look the way it does.  When your Python program downloads that page, this source code is what your program will get back; finding the important parts &mdash; this is sometimes called <i>web scraping</i> &mdash; is a challenge, one made worse by the fact that YouTube will make changes to its pages periodically that will render your scraping algorithm incompatible, and you'll be back to square one again.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Using web APIs instead of web pages</p>\r\n\r\n<p>Fortunately, some sites provide an alternative interface, one that's intended to be used by programs instead of people.  These are sometimes called <i>APIs</i> (application programming interfaces), because their goal is to provide an interface that application programs can use to access them.  (Note that the term \"API\" is actually a pretty open-ended one, used not only to describe interfaces to web sites, but also any other kind of software library; here, though, when I say \"API,\" I'm referring to a web API.)</p>\r\n\r\n<p>YouTube is owned by the tech giant Google.  In addition to providing YouTube as a web site that you can visit normally in a browser, Google also provides a set of APIs that can be used to access information about YouTube videos, channels, playlists, and users; to upload new videos to your YouTube account; to view an analysis of things like advertisement sales on your own videos; and so on.  Some of what's provided requires payment, while other parts are free.  While a fair amount of what they provide is only available if you <i>authenticate</i> (i.e., you've gone through a procedure to log into the API using your Google account, which is beyond the scope of what we're doing here), some of the more innocuous functionality &mdash; such as finding videos that match a search query &mdash; is available to anyone, subject only to reasonable usage limits (i.e., how many times per day you can run a query).</p>\r\n\r\n<p>Since our goal here is to display titles and descriptions of videos matching a YouTube search query, we'll need an API called the <a href=\"https://developers.google.com/youtube/v3/\">YouTube Data API</a>.  The YouTube Data API is a web API, meaning that a program interacts with it by sending an HTTP request &mdash; just like downloading a web page &mdash; and gets its answer back as an HTTP response.  The URL specifies not only the operation we want to perform (e.g., search), but also the parameters for that operation (e.g., the search query).  Meanwhile, the response is formatted in a way that's structured so that it will be easy for a program to parse and understand, in a format that's published (it's part of the API), so you can rest assured that it won't change when YouTube periodically changes the look of their web pages for human users.</p>\r\n\r\n<p>Using web APIs effectively requires us to learn a handful of new techniques, though we'll find that most of them (certainly YouTube's) are implemented around <i>standards</i>, in ways that are common among most web APIs.  These techniques are so common that Python's standard library provides implementations of all of them, so we don't have to deal with any of the low-level details; we just have to know what parts of the library we need, and we'll be in business.  To find what we need in the library, we first have to learn a little bit about the standard techniques that are being used.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Standards for web APIs</p>\r\n\r\n<p>While there are certainly differences between web APIs, and there are common techniques that we won't need here, the YouTube Data API uses a few standard techniques that we'll need to be familiar with.</p>\r\n\r\n<p class=\"subtitle\">URLs with query parameters</p>\r\n\r\n<p>Since the very early days of the World Wide Web, it has been necessary to specify URLs that carry parameters, particularly on web sites whose content is generated dynamically.  For many years, there has been a standard for URLs that include these kinds of parameters, which are called <i>query parameters</i>.  A hypothetical example of a URL with query parameters follows:</p>\r\n\r\n<ul>\r\n  <li>http://www.blah.com/some/page?param1=value1&amp;param2=value2&amp;param3=value3</li>\r\n</ul>\r\n\r\n<p>Before the <b>?</b> character, this looks just like any other URL.  The <b>?</b> is special; it indicates that what follows it will be a sequence of query parameters.  Each parameter is specified as a name and a value, with an <b>=</b> separating them; the parameters themselves are separated by <b>&amp;</b> characters.</p>\r\n\r\n<p>For example, I opened Amazon.com in my browser and searched for <b>u2 the joshua tree</b> and here's the URL that my browser directed me to:</p>\r\n\r\n<ul>\r\n  <li>https://www.amazon.com/s/ref=nb_sb_noss_2/183-7159112-3775704?url=search-alias%3Daps&field-keywords=u2+the+joshua+tree</li>\r\n</ul>\r\n\r\n<p>We can see that the parameters here are <b>url</b> (whose value is some kind of URL, though it's not clear exactly what it's being used for) and <b>field-keywords</b> (which appears to be my original query, with the spaces mysteriously replaced with <b>+</b> characters).  We would have to know more about how Amazon's web site is implemented to know for sure what the query parameters mean, but we can sometimes suss out their meaning just by looking at them.</p>\r\n\r\n<p class=\"subtitle\">URL encoding</p>\r\n\r\n<p>So, in general, the syntax for URLs with query parameters is quite simple.  After the <b>?</b>, parameters are separated by <b>&amp;</b> characters, with the name and value of each parameters separated by <b>=</b> characters.  But how do we specify a parameter whose value contains an <b>=</b> character?  How about a parameter whose name includes a <b>?</b> character?  Or a parameter whose value includes <b>&amp;</b>?  Or a parameter whose value includes spaces (which turn out to be illegal in URLs, no matter where you want to put them)?</p>\r\n\r\n<p>The answer lies in a technique called <i>URL encoding</i>, in which any character that's considered \"special\" (i.e., it has a meaning in the syntax, like <b>=</b> or <b>&amp;</b>) is replaced by something else.  There are two main rules:</p>\r\n\r\n<ul>\r\n  <li>Spaces are replaced with <b>+</b> characters.</li>\r\n  <li>Other special characters &mdash; anything that isn't legal in a URL, or has a special meaning (such as <b>?</b>, <b>&amp;</b>, or <b>=</b>) is replaced by a <b>%</b> followed by a \"character code\" (a numeric code, expressed in <i>hexadecimal</i> (i.e., base 16) corresponding to the character).  For example, a <b>?</b> is replaced with <b>%3F</b>.</li>\r\n</ul>\r\n\r\n<p>A much more detailed explanation of this kind of encoding is <a href=\"http://en.wikipedia.org/wiki/Percent-encoding\">here</a>, if you're curious about it, though there's no need for you to understand it any better than I've explained it here.  The basic idea is identical to the way that escape sequences are used in Python string literals, so we can include characters in them &mdash; like quotes or newlines &mdash; that are otherwise syntactically problematic.</p>\r\n\r\n<p>We do need to be able to recognize whether something has been URL encoded &mdash; which we can pick up visually just by looking for <b>%</b> characters followed by two hexadecimal digits &mdash; but the details will be left to part of Python's standard library to implement for us.</p>\r\n\r\n<p class=\"subtitle\">JavaScript Object Notation (JSON)</p>\r\n\r\n<p>The YouTube Data API, like many web APIs, returns its results in a common format called <b>JavaScript Object Notation</b> &mdash; usually referred to by its acronym, <b>JSON</b>.  Because many web APIs are consumed by web pages, and the \"guts\" of many web pages are written in a programming language called JavaScript, JSON (which has its roots in JavaScript) turns out to be a natural format for web APIs to return.  And JSON has become so common in web APIs and across the Internet, the Python standard library provides a module that can parse it, so we won't have to.</p>\r\n\r\n<p>JSON is actually quite simple.  An example follows:</p>\r\n\r\n<blockquote><pre>\r\n{ \"name\": \"Boo\", \"age\": 13, \"qualities\": [\"smart\", \"cute\", \"playful\", \"relentless\", \"perfect\", \"forever\"] }\r\n</pre></blockquote>\r\n\r\n<p>This is a JSON description of an <i>object</i>, which consists of a collection of <i>attributes</i> (much like Python's objects do).  In this example, the attribute <b>name</b> has the string value <b>\"Boo\"</b>, the attribute <b>age</b> has the numeric value <b>13</b>, and the attribute <b>qualities</b> has a value that is an array (you can think of these like Python lists) containing the strings <b>\"smart\"</b>, <b>\"cute\"</b>, <b>\"playful\"</b>, <b>\"relentless\"</b>, <b>\"perfect\"</b>, and <b>\"forever\"</b>.</p>\r\n\r\n<p>The details of JSON are described at <a href=\"http://json.org/\">json.org</a>, but they're not much more complicated than that; the entire standard for JSON is four printed pages long, largely made up of large-sized diagrams.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Using the YouTube Data API</p>\r\n\r\n<p>The YouTube Data API allows us to send a wide variety of different kinds of requests, but we'll focus on just one for this example.  Our goal is to issue a search query &mdash; like we might do on YouTube's web page &mdash; and display the titles and descriptions of videos that match the request.</p>\r\n\r\n<p>The appropriate request in the YouTube Data API is called <b>search</b>, which is described in detail here:</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://developers.google.com/youtube/v3/docs/search/list\">https://developers.google.com/youtube/v3/docs/search/list</a></li>\r\n</ul>\r\n\r\n<p>Boiling down their documentation, we need to know only a few things, though you might want to look through and see what else is available, in case you want to experiment with aspects of it that we're not covering here.</p>\r\n\r\n<ul>\r\n  <li>A <b>search</b> request is issued using a URL that starts out like this:\r\n    <ul>\r\n      <li><b>https://www.googleapis.com/youtube/v3/search</b></li>\r\n    </ul>\r\n  </li>\r\n  <li>Following the word <b>search</b> in the URL, we add a <b>?</b> character and then include a list of query parameters.  There are lots of parameters we might like to pass, but these are the ones we need in order to accomplish our goal:\r\n    <ul>\r\n      <li><b>key</b>, which is an <i>API key</i> that uniquely identifies us as a user of Google's web APIs.  We're required to set up an API key and associate with our Google account if we want to use Google's APIs, though I've already done that for us (and I'll send out an API key in an email message).  You can feel free to create your own, too, if you'd like, by logging into your Google account and then visiting the <a href=\"https://console.developers.google.com/\">Google Developers Console</a>.</li>\r\n      <li><b>type</b>, which specifies what we want to search for.  In our case, we want to search for <b>video</b>, though we could also search for other things (<b>channel</b> or <b>playlist</b>) instead.</li>\r\n      <li><b>part</b>, which specifies what part of YouTube's information you're interested in seeing.  In our case, we want something called a <b>snippet</b>, which briefly describes a few aspects of each video.</li>\r\n      <li><b>maxResults</b>, which specifies how many results we want (at most).</li>\r\n      <li><b>q</b>, which specifies our search query.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>So a complete URL might look like this:</p>\r\n\r\n<ul>\r\n  <li>https://www.googleapis.com/youtube/v3/search?key=<b><i>YOUR_API_KEY</i></b>&amp;type=video&amp;part=snippet&amp;maxResults=10&amp;q=lakers+clippers</li>\r\n</ul>\r\n\r\n<p>Of course, we need to be sure that the parameters are URL encoded in case, for example, the search query includes special characters in it.  Note the <b>+</b> sign between <b>lakers</b> and <b>clippers</b> in the example above; that's because the search query contained a space, but spaces are URL encoded to <b>+</b> signs.  Note, also, that other special characters like <b>?</b>, <b>&amp;</b>, and <b>=</b> are <i>not</i> URL encoded, because we want them to have their natural meaning in a URL: separating the portions of the URL from each other.  If, instead, we'd wanted a search query that included these characters in it, then we'd need to URL encode them.</p>\r\n\r\n<p>We then issue the request &mdash; an HTTP request, just like we've seen before, albeit one that includes encryption (which is why the URL starts with <b>https</b> instead of <b>http</b>) &mdash; and the result is returned as a JSON object.</p>\r\n\r\n<p>The only remaining trick is to understand what parts of the JSON response we're interested in.  Construct a URL using the pattern above (replacing <b><i>YOUR_API_KEY</i></b> with a valid Google API key, such as the one I will email to you) and visit it in a browser, then take a look through the JSON response to see if you can understand what parts of it you might need, given our goal to display the titles and descriptions of the matching videos.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">How the Python standard library can help</p>\r\n\r\n<p>There are three basic operations we need here:</p>\r\n\r\n<ul>\r\n  <li>To URL encode a set of query parameters, so that it's safe to pass them to a web API.</li>\r\n  <li>To issue an HTTP request to the URL we built and get the HTTP response.</li>\r\n  <li>To parse the response, which will be a JSON object in the format documented in the YouTube Data API documentation.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">URL encoding your query parameters</p>\r\n\r\n<p>The module <b>urllib.parse</b>, which sounds like it knows how to parse (i.e., read) URLs, happens also to contain a function that knows how to URL encode query parameters.  The easiest way to use it is to pass it a list of two-element tuples, and it will generate URL-encoded query parameters from it.  For example:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>import urllib.parse</b>\r\n&gt;&gt;&gt; <b>urllib.parse.urlencode([('name', 'Boo'), ('age', 12), ('description', 'pekingese/perfect'), ('search', 'lakers clippers')])</b>\r\n'name=Boo&age=12&description=pekingese%2Fperfect&search=lakers+clippers'\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Issuing an HTTP request and getting the HTTP response</p>\r\n\r\n<p>This is actually no different than what we did in the previous <a href=\"../HTTP\">example</a>.  We use the <b>urllib.request.urlopen</b> and pass it our full URL, including the URL-encoded parameters, just like we did before.</p>\r\n\r\n<p class=\"subtitle\">Parsing the JSON response</p>\r\n\r\n<p>Once we've retrieved a <b>bytes</b> object containing the content of our HTTP response, we'll have the response text in JSON format.  However, it won't be a string; it'll be a <b>bytes</b> object.  We could turn it into a string &mdash; we've seen already how to do that &mdash; but that doesn't leave us in a much better place, as it turns out.  A string in JSON format isn't a very convenient thing to have; to process it, we'll need to start searching for curly braces, double quotes, commas, colons, brackets, etc., in order to build an understanding of what's there and act on it.  If, fundamentally, a JSON description of an object boils down to \"a set of attributes with unique names, each with its own value\", then it might be nice if we could take a string in JSON format and turn it into something we could use more conveniently in a Python program.</p>\r\n\r\n<p>That would be a tall task, except for one important bit of good news: The Python standard library includes a module called <b>json</b> that knows how to do this already!  It can turn JSON into Python dictionaries (and also Python dictionaries back into JSON again, though we won't need that here).  For example, if we have a string variable containing JSON describing some object, the function <b>json.loads</b> &mdash; where <b>loads</b> is short for \"load from string\" &mdash; can convert the string to a dictionary for us.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>import json</b>\r\n&gt;&gt;&gt; <b>x = '{ \"name\": \"Boo\", \"age\": 12, \"qualities\": [\"intelligent\", \"cute\", \"playful\", \"perfect\"] }'</b>\r\n&gt;&gt;&gt; <b>obj = json.loads(x)</b>\r\n&gt;&gt;&gt; <b>obj['name']</b>\r\n'Boo'\r\n&gt;&gt;&gt; <b>obj['age']</b>\r\n12\r\n&gt;&gt;&gt; <b>for quality in obj['qualities']:\r\n        print(quality)</b>\r\n\r\nintelligent\r\ncute\r\nplayful\r\nperfect\r\n</pre></blockquote>\r\n\r\n<p>We can do the same thing with a file object (or something that you can read from like a file object, such as the HTTP response you get back from <b>urllib.request.urlopen</b>); the only difference is that we call <b>json.load</b> instead of <b>json.loads</b>, passing it the file object.  It reads the contents of the file and converts it.  So, for example, if you pass the HTTP response to <b>json.load</b>, it will read its contents and convert them to a Python object, provided that the contents are valid JSON.</p>\r\n\r\n<p>Now <i>that's</i> handy, isn't it?</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>Bringing all of this together, below is the program that we wrote in lecture that uses the YouTube Data API to display information about YouTube videos that are relevant, given a search phrase such as <b>lakers clippers</b>.  The program requires an <i>API key</i> from Google.  I created one for this course, which I will send out separately via email; you can also create your own via the <a href=\"https://console.developers.google.com/\">Google Developers Console</a> and use that, if you prefer.</p>\r\n\r\n<ul>\r\n  <li><a href=\"youtube.py\"><b>youtube.py</b></a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}