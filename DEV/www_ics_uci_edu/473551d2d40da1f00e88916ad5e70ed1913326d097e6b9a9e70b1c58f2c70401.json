{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/03.pq", "content": "Priority Queues\n\nMOTIVATION:\nDijkstra's algorithm for shortest paths from vertex s in graph G\n\ndef Dijkstra(s,G):\n    tentative = dict mapping s->0, others->+infty\n    final = {}\n    while tentative:\n        find vertex v minimizing tentative[v]\n        for each edge v->w:\n            if w not in final:\n                tentative[w] = min(tentative[w], tentative[v]+length(v,w))\n        final[v] = tentative[v]\n        del tentative[v]\n\nWhat data structure operations are performed?\n(1) store and update tentative and final scores for vertices\n    (here written as dict, could instead be attributes on vertex objs)\n(2) keep data structure maintaining minimum tentative score\n\ndata structure mapping objects to values and keeping track of\nminimum values is called a priority queue (or sometimes a heap)\n\nbasic priority queue operations:\n- create new priority queue\n- add item to queue (with given value)\n- find smallest item in priority queue\n- remove smallest item in priority queue\n\nunfortunate terminology:\n  priorities are called \"keys\"\n  opposite meaning to dictionary keys\n\nalso used here:\n- change priority of an item already in the queue\n  (here, decrease key / increase priority)\n\nuseful in some other applications:\n- remove non-minimal item (could implement change = remove + add)\n- merge priority queues\n\n\nBinary heaps\n- array structure: x[i] >= x[(i-1)//2]\n- tree structure\n- new pq: queue = []\n- add item: append then bubble up\n- find smallest: queue[0]\n- remove smallest: replace with last item then bubble down\n\nTime per add/remove: O(log n)\n\nHow to use binary heaps for Dijkstra:\n(1) maintain auxiliary dict mapping vertices to heap locations;\n    update dict when items bubble up or down;\n    decrease_key by changing value then bubbling up\ntime = O((m+n) log n), space=O(n)\n\n(2) modify Dijkstra's algorithm so that it doesn't use decrease_key:\n\ndef Dijkstra(s,G):\n    tentative = heap containing s with key 0\n    final = {}\n    while tentative:\n        find and remove min object v and key d from tentative\n        if v not in final:\n            for each edge v->w:\n                tentative.add(w, d+length(v,w))\n        final[v] = d\n\ntime=O((m+n) log n) again, no extra dict, space goes up\n(each vertex may be in heap many times)\n\n\n\nSURVEY OF ALTERNATIVE HEAP STRUCTURES\n\nBinary heap:\n    add, remove, change key operations O(log n); find min O(1)\n    very little overhead (single array of object-key pairs)\n\nd-ary heap:\n    like binary can be stored in array (condition: x[(i-1)//d] <= x[i])\n    add-item, decrease_key O(log_d n) [fewer steps in bubble up]\n    remove item O(d log_d n) [each bubble down step looks at d children]\n    e.g. in Dijkstra, choose d ~ m/n gives time O(m log_{m/n} n)\n\nleftist heap:\n    unlike binary heap, allows merge operations\n\n    instead of complete binary tree, allow any \"leftist\" binary tree\n    (represented by nodes with left/right child pointers and height values)\n\n    leftist = at all nodes, left subtree is deeper than right\n\tso to find shortest path to null pointer, follow right children\n        (in particular right path has length O(log n))\n    nodes store object-key values, decreasing towards root\n\n    version 1:\n        also store parent pointers per node\n\n\tto merge two leftist heaps, follow right paths\n\t(giving two sorted sequences of O(log n) values),\n\tmerge the two sorted sequences to form a single tree,\n\tthen swap left-right at selected nodes to make leftist again\n\n        to add an item, make a new one-item heap and merge\n\n\tto delete an item with nonempty children,\n        replace it with the merge of its two children\n\n\tto delete an item with no children,\n\tclear the pointer at its parent node and swap children if nec.\n\n        to change a key, delete it and re-add the item\n\n        => all operations O(log n), a little cumbersome\n\n    version 2 (lazy):\n        no parent pointers\n\n\tto delete an item, mark it as \"deleted\"\n\tto merge two heaps, make a new parent marked as \"deleted\"\n\tto add an item, make a new one-item heap and merge\n\tto change a key, delete the old key and add the new one\n\n        but where is the minimum value?  no longer at root\n\n\tto find the minimum, traverse the tree finding\n\tpaths of deleted nodes from the root, collecting non-del children\n\tthen use non-lazy meld on all children\n\n        => each op leads to O(1) marks => O(1) later melds\n\tso amortized O(log n) per operation\n\nbinomial heaps [ch.19]:\n    alternative more complicated mergeable heap\n    all operations O(log n)\n\nFibonacci heaps [ch.20]:\n    heap allowing insert, delete-min (not arbitrary delete),\n    decrease-key (not arbitrary change-key), merge\n    \n    all operations O(1) time (amortized for decrease-key)\n    except delete O(log n) (amortized)\n    so Dijkstra time becomes O(m + n log n)\n\n    arbitrary delete and change-key could be handled\n    by lazy deletion, O(log n) amortized each\n\n    structure:\n        forest of rooted non-binary trees\n        heap-ordered (key[parent] <= key[self])\n\tall degrees <= log n\n\n\trepresented by nodes with:\n\t\tparent\n\t\tchild: arbitrary one of the node's children\n\t\tleft, right: doubly linked circular list of siblings\n                (left, right pointers of roots give list of all trees)\n\t\tdegree (# of children)\n\t\tmark (boolean, true if lost a child since parent last changed)\n\toverall structure is represented by pointer to tree w/smallest root\n\talso store total number of nodes in the tree\n\n    insert new item:\n        make it into a new singleton tree\n\tadd it into the circular list of tree roots\n\tchange pointer to min root if new item is smaller\n\n    find min item:\n        obvious\n\n    merge two trees:\n        concatenate their list of tree roots\n\tset min root pointer to smaller of two min roots\n\n    delete min:\n\tturn children of min into roots of new trees\n\tgroup roots by their degrees (e.g. bucket sort)\n\twhile two roots x and y have the same degree, root(x)<root(y):\n            make y into a child of x and update buckets\n\n    decrease key:\n        remove the item x from its parent's list of children\n\t    and make it into a new tree root\n\tdo the same for the sequence of marked ancestors of x\n\t    until finding an unmarked ancestor, which gets marked\n", "encoding": "ascii"}