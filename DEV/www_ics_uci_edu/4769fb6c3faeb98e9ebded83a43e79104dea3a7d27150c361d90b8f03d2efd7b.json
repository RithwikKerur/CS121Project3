{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/re.txt", "content": "\t\t\t\tRegular Expressions\r\n\r\nIntroduction:\r\n\r\nRegular Expressions are patterns that we can specify (as strings) and use to\r\nsearch for and replace text in other strings (often the sequence of strings that\r\nmakes up the lines in a file). Python (as well as many other languages) includes\r\na module to perform various operations on regular expressions. In these\r\nlectures, we will cover the form of regular expressions (in the first lecture),\r\nand then what functions/methods can take regular expressions as arguments, and\r\nhow to use the results of matching regular expressions against text -including\r\nthe concept of capturing groups (in the second lecture).\r\n\r\nIn the first lecture we will discuss the components of regular expression\r\npatterns themselves. We will discuss each component individually, and the ways\r\nto combine these components into more complicated regular expressions (just as\r\nwe studied the syntax of a few simple control structures in Python, which we can\r\ncombine into more complicated control structures). We will cover many -but\r\nnot all- of the patterns usable in regular expressions: there are entire books\r\nwritten on regular expressions: on Amazon I found over 15 books with \"Regular\r\nExpressions\" in their title.\r\n\r\nIn the second lecture we will examine various functions and methods, from a\r\nPython module, which take regular expressions as arguments. Typically they\r\nmatch a regular expression pattern string against some text string, and return\r\ninformation about whether or not the match succeeded, and what parts of the\r\npattern matched which parts of the text.\r\n\r\nPython's module for doing these operations is named re. There is a special\r\ntester module that accompanies these lectures, which you can download and run\r\nto experiment with regular expressions and learn how they match text strings.\r\nWe will also look at an online resource for learning and testing regular\r\nexpressions, which is simpler to use.\r\n\r\nFor more complete information about regular expressions, see Section 6.2 of the\r\nPython Standard Library.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n\t\t\t\tLecture 1\r\n\r\n\r\nGeneral Rule for Matching Regular Expressions Patterns against Text\r\n  (both are represented as strings):\r\n\r\n  Regular expression patterns match the most number of characters possible in\r\n  the text; this is called a greedy match.\r\n\r\n  There are ways to specify patterns that match the fewest number of characters\r\n  possible: although we will mention these, we will not discuss nor use those\r\n  \"non-greedy\" specifications.\r\n\r\n\r\nMatching:\r\n  Characters generally match themselves, except for the following...\r\n\r\nMetacharacters\r\n .\tMatches any single character (except newline: \\n)\r\n []\tMatches one character specified inside square brackets []; e.g., [aeiou]\r\n -      Matches one character in range inside []: e.g., [0-9] matches any digit\r\n        To match any letter (upper/lower case) or digit we write [A-Za-z0-9]\r\n [^]\tMatches any one character NOT specified inside [^]; e.g., [^aeiou]\r\n        We can use ranges here too, to specify the characters NOT to match\r\n\r\nAnchors (these don't match characters, but match positions in a string)\r\n ^\tmatches beginning of line (except when used in [^])\r\n $\tmatches end of line (except when used in [] or [^])\r\n\r\nTo start, in all of the patterns that we experiment with/use, we will specify\r\n^ as the first character and $ as the last. This will require a full match of \r\nthe pattern and text, from the first to last character in both (much like how\r\nwe discussed matching EBNF rules to symbols). Later, in a few cases, we will\r\ndeviate from this convention.\r\n\r\nPatterns: Assume R, Ra, Rb represent regular expression patterns (like the ones\r\n          above, and also including the ones built below), here are the more\r\n          complicated patterns that we can build from these.\r\n\r\n RaRb\tMatches a sequence (one after the other) of Ra followed by Rb\r\n\r\n Ra|Rb\tMatches either alternative Ra or Rb (just like | in ENBF)\r\n\r\n R?\tMatches regular expression R 0/1 time: R is optional (like [] in EBNF)\r\n\r\n R*\tMatches regular expression R 0 or more times (like {} in EBNF)\r\n\r\n R+\tMatches regular expression R 1 or more times (note */+ difference)\r\n\r\n R{m}\tMatches regular expression R exactly m times: e.g., R{5} = RRRRR\r\n\r\n R{m,n}\tMatches regular expression R at least m and at most n times:\r\n          R{3,5} = RRR|RRRR|RRRRR = RRRR?R?\r\n\r\n----- Sidenote\r\nIncluded only in this sidenote, but NOT USED in this lecture/course, are the\r\npatterns R??, R*?, R+?,and  R{m,n}?. The postfix ? means match as FEW characters\r\nas possible (not the most: so not greedy). We will NOT USE or need to understand\r\nthese patterns.\r\n-----\r\n\r\nParenthesized Patterns\r\n\r\nParentheses are used for \r\n   1) Grouping (as they are in arithmetic expressions/formulas)\r\n   2) Remembering the text matching subpatterns (called a \"Capturing Group\").\r\n      These capturing groups are mostly relevant when we examine the functions\r\n        in the Python re module.\r\n\r\nBy placing subpattern R in parentheses, the text matching R will be remembered\r\n(either by its number, starting at 1, or its name, if named: see ?P below) in a\r\n\"capturing group\" which we mostly refer to just as a \"group\". We can use these\r\ngroups when extracting information from the matched text, when we call re\r\nfunctions.\r\n\r\n (R)\t     Matches R and delimits a group (1, 2, ...) (remembers/captures\r\n               matched text in a group). The rules below show how capturing\r\n               groups are numbered: they are simple.\r\n\r\n (?P<name>R) Matches R and remembers/captures matched text in a group\r\n               using name for the group (it is still numbered as well); see\r\n               the groupdict method below (2nd lecture) for uses of \"name\".\r\n             An example is (?P<id>[A-Za-z0-9]+) which matches any sequence of\r\n               upper and lower-case letters and digits with the capture group\r\n               named id.\r\n\r\n (?:R)       Matches R but does not remember/capture matched text in a capturing\r\n               group.\r\n             So here (?:R) is used only for grouping regular expression R, not\r\n               specifying a capturing group. So, ?: is useful when we want only\r\n               important/capturing groups to be numbered (and not others). It\r\n               takes extra space to specify.\r\n\r\n-----Sidenote\r\nIncluded only in this sidenote, but NOT USED in this lecture/course\r\n\r\n (?P=name)   Matches remembered text with name (for backreferencing which text)\r\n\r\n (?=R)\t     Matches R, doesn't remember matched text or consume text matched\r\n             For example (?=abc)(.*) matches abcxyz with group 1 'abcxyz';\r\n               it doesn't match abxy because this text doesn't start with abc\r\n\r\n (?!R)       Matches anything but R and does not consume input needed for match\r\n               (hint: != means \"not equal\", ?!R means \"not matching R)\r\n-----\r\n\r\nComputing the group number of a subpattern for extracting its matching text:\r\n\r\n  Each new left parenthesis starts a new group (unless it is \"(?:...)\"). Some\r\n  groups are sequential (one after another); some groups are nested (one inside\r\n  another). Here is an example\r\n\r\n                         ( (  ) (  ) ( ( (  ) ) ) )\r\n  Where groups start/end 1 2  2 3  3 4 5 6  6 5 4 1     \r\n  Group 1                (------------------------)\r\n  Group 2                  (--)\r\n  Group 3                       (--)\r\n  Group 4                            (----------)\r\n  Group 5                              (------)\r\n  Group 6                                (--)\r\n\r\nCapturing Group 0 (in Python) is considered the entire regular expression, even\r\nwhen it is not in any parentheses. So, in the pattern \"^a(b(c.d)+)?(e)$\r\n  Capturing Group 0 is a(b(c.d)+)?e\r\n  Capturing Group 1 is (b(c.d)+)?\r\n  Capturing Group 2 is (c.d)\r\n  Capturing Group 3 is (e)\r\n\r\nIf we match this pattern against the string \"abc1dc2de\" then \r\n  Capturing Group 0 is \"abc1dc2de\": the entire string matches\r\n  Capturing Group 1 is \"bc1dc2d\": everything in between a and (e)\r\n  Capturing Group 2 is \"c2d\", the last characters matched in this repetition\r\n  Capturing Group 3 is \"e\", from the last Capturing Group\r\n\r\nNote that \"ae\" matches too, \r\n  Capturing Group 0 is \"ae\": the entire string matches\r\n  No Capturing Group 1 (or 2 inside 1): ? ignores Capturing Group 1\r\n  Capturing Group 3 is \"e\", from the last Capturing Group\r\n\r\nThe Regular Expressions website we use displays Group 0 as \"Full Match\".\r\n\r\nContext\r\n  1)  - matches itself if not in [] between two characters: e.g., [-+] vs. [a-z]\r\n  2) Special characters (except \\) are treated literally in []: e.g, [.]\r\n       matches only \".\". To match the \\ special character write [\\\\]. Writing\r\n       [a-z] matches all lower-case characters; [a\\-z] matches a, -, or z.\r\n  3) Generally, if interpreting a character makes no sense one way, try to find\r\n       another way to interpret it that fits the context\r\n\r\nEscape Characters with Special Meanings\r\nSymbol  Meaning\r\n \\\tUsed before .|[]-?*+{}()^$\\ (and others) to specify a special character\r\n        The meaning of \\. is the same as [.] (see rule 2 above)\r\n\r\n \\t\ttab\r\n \\n\tnewline\r\n \\r\tcarriage return\r\n \\f\tformfeed\r\n \\v\tvertical tab\r\n\r\n \\d\t[0-9]\t\t\tDigit\r\n \\D\t[^0-9]\t\t\tnon-Digit\r\n \\s\t[ \\t\\n\\r\\f\\v]\t\tWhite space\r\n \\S\t[^ \\t\\n\\r\\f\\v]\t\tnon-White space\r\n \\w\t[a-zA-Z0-9_]\t\talphanumeric(or underscore): used in identifiers\r\n \\W\t[^a-zA-Z0-9_]\t\tnon alphanumeric\r\n\r\nInteresting Equivalences\r\n a+         == aa*\r\n a(b|c|d)e  == a[bcd]e      only if b, c, and d are single characters\r\n R{0,1}     == R?           0 or 1 times means the same as optional\r\n\r\n\r\nHints on Using | (a low-precedence operator for Regular Expression)\r\n\r\nIn Python, we know that writing a*b+c*d performs * before +: we say * has higher\r\nprecedence than +, so it is performed earlier. We could be explicit and write\r\nthis as (a*b)+(c*d). If we wanted to add BEFORE multiply, we must use\r\nparentheses: a*(b+c)*d. Think of REs as having sequence as an operation (it is\r\nimplicit, with no operator written between the regular expressions in the\r\nsequence).\r\n\r\nThe seqeuence precendence is lower than the precedence of all postfix operators\r\n(like ?, *, +, and {}): e.g., ab* has the same meaning as a(b*). The | operator\r\nhas the lowest precendence of all (even lower than implicit sequencing). So\r\nwriting ab|cd is the equivalent of writing  (ab)|(cd), which matches either ab\r\nor cd only: the pattern does the sequencing BEFORE the | operator.\r\n\r\nNow, given this understanding, look what ^a|b$ means. By above, it means the\r\nsame as (^a)|(b$). Type ^a|b$ into the online tool and read its Explanation).\r\nNote that the ^ anchor applies only to a, and the $ anchor applies only to b\r\n(see its parenthesized equivalent). So ^a|b$, which is equivalent to (^a)|(b$),\r\nwill match (using the online tool)\r\n\r\n  1) any text starting with an a: a or aa or aaab or abcda ($ is not part of it)\r\n  2) any text ending   with a  b: b or cb or ccbb or abcdb (^ is not part of it)\r\n\r\nTo avoid confusion, I strongly recommend ALWAYS WRITING ALL THE ALTERNATIVES IN\r\nA REGULAR EXPRESSION AS A GROUP IN PARENTHESES: ^(a|b)$ to ensure that the |\r\napplies only to the alternatives inside the ()s. This regular expression is a\r\nsequence of 3 regular expressions: the ^ anchor, followed by a choice of a or\r\nb, and finally followd by the $ anchor.\r\n\r\nSo sometimes we use () to ensure that our regular expression is correct, and in\r\nthe process, we automatically introduce a new numbered (capturing) group. Of\r\ncourse we can write this as ^(?:Ra|b)$ to ensure that no new Capturing Group\r\nnumber is created by our grouping.\r\n\r\n\r\n\r\nProblems:\r\n\r\nWrite the smallest pattern that matches the required characters. Check your\r\npatterns with the Regular Expression Tester (see the Sample Programs link) to\r\nensure they match correct exemplars and don't match incorrect ones. Note that\r\nfor a match, group #0 should include all the required characters.\r\n\r\n1. Write a regular expression pattern that matches the strings Jul 4, July 4,\r\n   Jul 4th, July 4th, July fourth, and July Fourth.\r\n   Hint: my RE pattern was 24 characters.\r\n\r\n2. Write a regular expression pattern that matches strings representing times on\r\n   a 12 hour clock. An example time is  5:09am or 11:23pm. Allow only times that\r\n   are legal (not 1:73pm nor 13:02pm)\r\n   Hint: my RE pattern was 32 characters.\r\n\r\n3. Write a regular expression pattern that matches strings representing phone\r\n   numbers of the following form.\r\n\r\n   Normal: a three digit exchange, followed by a dash, followed by a four digit\r\n           number: e.g., 555-1212\r\n\r\n   Long Distance: a 1, followed by a dash, followed by a three digit area code\r\n           enclosed in parentheses, followed by a three digit exchange,\r\n           followed by a dash, followed by a four digit number: e.g.,\r\n           1-(800)555-1212\r\n\r\n   Interoffice: a single digit followed by a dash followed by a four digit\r\n            number: e.g., 8-2404.\r\n\r\n   Hint: my RE pattern was 30 characters; note that you must use \\( and \\) to\r\n   match parentheses.\r\n\r\n4. Write a regular expression pattern that matches strings representing simple\r\n   integers: optional + or - signs followed by one or more digits.\r\n   Hint: my RE pattern was 7 characters.\r\n\r\n5. Write a regular expression pattern that matches strings representing\r\n   normalized integers (each number is either an unsigned 0 or is unsigned or\r\n   signed and starts with a non-0 digit) with commas in only the correct\r\n   positions\r\n   Hint: my RE pattern was 30 characters.\r\n\r\n6. Write a regular expression pattern that matches strings representing float\r\n   values. They are unsigned or signed (but not normalized: see 5) and any\r\n   number of digits before or after a decimal point (but there must be at least\r\n   one digit either before or after a decimal point: e.g., just . is not\r\n   allowed) followed by an optional e or E followed by an unsigned or signed\r\n   integer (again not normalized).\r\n   Hint: my RE pattern was 36 characters.\r\n\r\n7. Write a regular expression pattern that matches strings representing trains.\r\n   A single letter stands for each kind of car in a train: Engine, Caboose,\r\n   Boxcar, Passenger car, and Dining car. There are four rules specifying how\r\n   to form trains.\r\n     1. One or more Engines appear at the front; one Caboose at the end.\r\n     2. Boxcars always come in pairs: BB, BBBB, etc.\r\n     3. There cannot be more than four Passenger cars in a series.\r\n     4. One dining car must follow each series of passenger cars.\r\n   These cars cannot appear anywhere other than these locations. Here are\r\n   some legal and illegal exemplars.\r\n\r\n     EC Legal: the smallest train\r\n     EEEPPDBBPDBBBBC Legal  : simple train showing all the cars\r\n     EEBB            Illegal: no caboose (everything else OK)\r\n     EBBBC           Illegal: three boxcars in a row\r\n     EEPPPPPDBBC     Illegal: more than four passenger cars in a row\r\n     EEPPBBC         Illegal: no dining car after passenger cars\r\n     EEBBDC          Illegal: dining car after box car\r\n   Hint: my RE pattern was 15 characters.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n\t\t\t\tLecture 2\r\n\r\nGenerally, the functions discussed in this lecture operate on a regular\r\nexpression pattern (specified by a string) and text (also specified by a\r\nstring). These functions produce information (capture groups: see parenthesized\r\npatterns above) related to attempting to match the pattern and text: which parts\r\nof the text matched which parts of the pattern.\r\n\r\nWe can use the compile function to compile a pattern (producing a regex), and \r\nthen call methods on that regex directly, as an object to perform the same\r\noperations as the functions, but more efficiently if the pattern is to be used\r\nrepeatedly (since the pattern is compiled into the regex once, not in each\r\nfunction call).\r\n\r\nWe will omit discussing/using the [,flags] option in this discussion, but see\r\nsection 6.2 of the Python Library Documentation for a discussion of A/ASCII,\r\nDEBUG, I/IGNORECASE, L/LOCALE, M/MULTILINE, S/DOTALL, and X/VERBOSE.\r\n\r\n----------\r\n\r\nA (not too) Simple but Illustrative Example\r\n  (the details of HOW this works follow in later sections):\r\n\r\nIn this example (representative of what we do with regular expressions) we \r\n  1) define a regular expression\r\n  2) call a re function (match) on it and some text\r\n  3) check whether the pattern matches the text\r\n  4) do something with (print) the captured groups (by number or name)\r\n\r\nA 2nd version is shown further down, using the re.compile function and calling\r\n.match on the object it returns.\r\n\r\nphone = r'^(?:\\((\\d{3})\\))?(\\d{3})[-.](\\d{4})$'\r\nm = re.match(phone,'(949)824-2704')\r\nassert m != None, 'No match'\r\nprint(m.groups())\r\narea, exchange, number = [int(i) if i != None else None for i in m.group(1,2,3)]\r\nprint(area, exchange, number)\r\n\r\n1) Here, phone is a  pattern anchored at both ends (by ^ and $ respectively).\r\n\r\n(a) r'...' is a raw string; we typically use them to specify patterns\r\n\r\n    It starts with ^(?:\\((\\d{3})\\))?\r\n    controlling an optional area code. The ?: means that the parentheses are not\r\n    used to create a group, but are used with the ? (postfix option) symbol.\r\n\r\n    Inside it is \\((\\d{3})\\): a left parenthesis \\(, group 1 which consists of\r\n    any 3 digits,  and a right parenthesis \\).\r\n\r\n(b) Next is (\\d{3}) group 2, which consists of any 3 digits. \r\n\r\n(c) Next is [-.] that is one symbol, either a - or . (not in a group).\r\n\r\n(d) Next is (\\d{4}) group 3, which consists of any 4 digits. \r\n\r\n2) Calling the re.match function matches the pattern against some text, it \r\nreturns a match object that is bound to m.\r\n\r\n3) If the match m is None, there is no match (raises AssertionError exception).\r\n\r\n4) Converts every non-None string from groups 1, 2, and 3 into an int.\r\n\r\n5) Prints the the groups\r\n\r\nTry also replacing line 2 by \r\n\r\n  m = re.match(phone,'824-2704')\t\t# area is None\r\n  m = re.match(phone,'(949)824:2704')\t\t# : instead of - or .; no match\r\n  m = re.match(phone,'(94)824-2704')\t\t# only 2 in area code; no match\r\n\r\nAlso, we can replace the first two lines by the following equivalent lines\r\n\r\nphone_pat = re.compile(r'^(?:\\((\\d{3})\\))?(\\d{3})[-.](\\d{4})$')\r\nm = phone_pat.match('(949)824-2704')\r\n\r\nIn this example, because match is called only once, there is no speed \r\nimprovement by compiling the pattern. But if we called match on multiple text\r\nstrings (e.g., every string read from a file), then using compile would be more\r\nefficient. The compiling feature is discussed below.\r\n\r\n----------\r\n\r\nRegular Expression (re) functions:\r\n  called like re.match(...) the module name prefaces the function\r\n\r\nReturns a regex (compiled pattern) object (see calling methods on regex below)\r\n  compile   (pattern, [,flags])\t\tCreates compiled pattern object\r\n\r\nReturns a match object, consisting of tuple of groups (0,1,...)\r\n  match\t    (pattern, text [,flags])\tMatches start at the text's beginning\r\n  search    (pattern, text [,flags])\tMatches can start anywhere in the text\r\n\r\n---The online regular expression web page uses SEARCH to do its matching, which\r\n---is why we wrote our patterns as ^....$, to ensure matching started at the\r\n---beginning and ended at the end of each line.\r\n\r\n  re.match (\"(a+)b\",\"aaab\") matches; re.match (\"(a+)b\",\"xaaab\") doesn't match\r\n  re.search(\"(a+)b\",\"aaab\") matches; re.search(\"(a+)b\",\"xaaab\") matches\r\n    by writing the patterns like ^...$, these functions produce the same results\r\n\r\nReturns a list of strings: much like calling text.split(...)\r\n  split     (pattern, text [,maxsplit, flags]) like the text.split(...) method,\r\n               but using a regular expressions pattern to determine how to split\r\n               the text: re.split('[.-]', 'a.b-c')  returns ['a','b','c'],\r\n               spliting on either . (a period; . here does not mean \"any\r\n               character\") or -. The standard string split function,\r\n               text.split(...) can't split on EITHER character; note that\r\n               'a.b-c'.split(\".-\") splits only on '.-' both a . followed by a -,\r\n               so in this case it fails to split anywhere, since '.-' is not\r\n               anywhere in the text at all. Note we can also write\r\n               re.split('(?:\\.|-)', 'a.b-c') which also returns ['a','b','c'].\r\n               Note we must write \\. here because . would mean any character) \r\n            If the pattern has groups (this one uses ?: so doesn't), then the\r\n              text matching each group is included in the resulting list too:\r\n              use ?: to avoid these groups.\r\n            So re.split(';+'  ,'abc;d;;e') returns ['abc', 'd', 'e'] and\r\n               re.split('(;+)','abc;d;;e') returns ['abc', ';', 'd', ';;', 'e'] \r\n\r\nReturns a string\r\n  sub       (pattern, repl, text, [,count, flags])\r\n             If there is a match between pattern and text, build a string that\r\n               a)  replaces pattern by repl, which is a string that can refer to\r\n                   matched groups via \\# (e.g. \\1) or \\g<#>, (e.g., \\g<1>), or\r\n                   \\g<name> (where name comes from ?P<name>)\r\n               b) replaces pattern by the result returned by CALLING repl, which\r\n                  is a function that is passed a match object as its argument)\r\n             If there is no match, then it just returns the text parameter's\r\n               value, unchanged\r\n            re.sub('(a+)','{as}','aabcaaadaf') returns    {as}bc{as}d{as}f\r\n            re.sub('(a+)','(\\g<1>)','aabcaaadaf') returns (aa)bc(aaa)d(a)f\r\n\r\n----- Sidenote\r\nIncluded only in this sidenote, but NOT USED in this lecture/course, are the\r\n\r\nReturns a list of string/of tuples of string (the groups), specifying matches\r\n  findall   (pattern, text [,flags])\tMatches can start anywhere in the text;\r\n              the next attempted match starts one character after the previous\r\n              match terminates.\r\n            If the pattern has groups, then the string matching each group is\r\n              included in the resulting list too: use ?: to avoid these groups\r\n            re.findall('a*b','abaabcbdabc') returns ['ab', 'aab', 'b', 'ab']\r\n            re.findall('((a*)(b))','abaabcbdabc') returns \r\n              [('ab','a','b'), ('aab','aa','b'), ('b','','b'), ('ab','a','b')]\r\n\r\nReturns a iterable of the information returned by findall (ignore this one)\r\n  finditer  (pattern, text [,flags])\tReturns iterable equivalent of findall\r\n\r\n  subn      same as sub but returns a tuple: (new string, number of subs made)\r\n  escape    (string)\t\t\tstring with nonalphanum back-slashed\r\n-----\r\n\r\nIn findall and sub/subn, only non-overlapping patterns are found/replaced:\r\nin text aaaa there are two non-overlapping occurrence of the pattern aa:\r\nstarting in index 0 and 2 (not in index 1, which overlaps with the previous\r\nmatch in indexes 0-1).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nregex (compiled pattern) object methods (see the compile method above, which\r\nproduces regexes) are called like c = re.compile(p). It is then efficient to\r\ncall c.match(...) many times. Calling re.match(p,...) many times with the same\r\npattern recompiles and matches the pattern each time re.match is called;\r\nwhereas c = re.compile(p) compiles the pattern ONCE and c.match(...) just has to\r\nmatch it against text each time that it is called.\r\n\r\nUsing this feature allows us to compile a pattern and reuse it for all the\r\noperations above: re.match(p,s) is just like re.compile(p).match(s); if we\r\nare doing MANY MATCHES WITH THE SAME PATTERN, it is most efficient to compile\r\nthe pattern once and then use the compiled pattern with the match method below\r\nmany times (as illustrated above). We often compile patterns when using them to\r\nmatch agains all the lines in a file.\r\n\r\npos/endpos are options that specify where in text the match starts and ends\r\n(from pos to endpos-1). pos defaults to 0 (the beginning of the text) and\r\nendpos defaults to the length of the text so endpos-1 is its last character).\r\n\r\nEach of the re functions above has an equivalent method using a compiled\r\npattern to call the method, but omitting the pattern from its argument list.\r\n\r\n  match    (text [,pos][,endpos])\t  See match above, with pos/endpos\r\n  search   (text [,pos][,endpos])\t  See search above, with pos/endpos\r\n  findall  (text [,pos][,endpos])\t  See findall above, with pos/endpos\r\n  finditer (text [,pos][,endpos])\t  See finditer above, with pos/endpos\r\n  split    (text [,maxsplit])\t\t  See split above, with pos/endpos\r\n  sub\t   (repl, text [,count])\t  See sub above, with pos/endpos\r\n  subn\t   (repl, text [,count])\t  See subn above, with pos/endpos\r\n\r\nSo, for example, instead of writing\r\n\r\n  for line in open_file:\r\n    ...re.match(pattern_string,line)\r\n\r\nwhich implicitly compiles the same pattern_string during each loop iteration\r\n(whenever re.match executes) we can write\r\n\r\n  for line in open_file:\r\n    pattern = re.compile(pattern_string)\r\n    ...pattern.match(line)\r\n\r\nwhich explicitly compiles the pattern_string during each loop and uses the\r\ncompiled version (insted of the function re.match) to call \"match\" (just two\r\nways of doing the same thing). NOW...if we know the pattern_string stays the\r\nsame, we can factor the call to re.compile out before the loop exceutes and\r\nwrite it as\r\n\r\n  pattern = re.compile(pattern_string)\r\n  for line in open_file:\r\n    ...pattern.match(line)\r\n\r\nwhich explicitly compiles the pattern_string ONCE, before the loop executes,\r\nand calls \"match\" on it during each loop iteration. This is the most efficient\r\nway to test the same pattern against every line in a file. See the grep.py\r\nmodule in the remethods download that accompanies this lecture for code that\r\ncalls re.compile.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nMatch objects and (Capture) Groups\r\n\r\nMatch objects record information about which parts of a pattern match the text.\r\nEach group (referred to by either its number or an optional name) can be used\r\nas an argument to a function that specifies information about the start, end,\r\nspan, and characters in the matching text.\r\n\r\nCalling match/search produces None or a match object\r\nCalling findall produces None, a list of strings (if there are no groups) or a\r\n  list of tuples of strings (if there are groups, with the tuple index\r\n  representing the each group #)\r\nCalling finditer produces None or an iterable of groups (not used in the course)\r\n\r\nEach group is indexed by a number or name (a name only when the group was\r\n  delimited by (?P<name>)); group 0 IS ALL THE CHARACTER IN THE MATCH, groups\r\n  1-n are for delimited matches inside. For example, in the pattern (a)(b(c)(d))\r\n  the a is in group 1, the b is in group 2 (group 2 includes groups 3 and 4),\r\n  c is in group 3, and d in is group 4: groups are numbered by in what order we\r\n  reach their OPENING parenthesis. that is why group 2 includes all of b(c)(d).\r\n\r\n  Note that if a parenthesized expression looks like (?:...) it is NOT numbered\r\n  as a group. So in (a)(?:b(c)(d)) the a is in group 1, the b is in NO group,\r\n  c is in group 2, and d in is group 3.\r\n\r\n  If a group is followed by a ? and the pattern in the group is skipped, its\r\n  group will be None. In the result of re.match('a(b)?c','ac') group 1 will be\r\n  None. If the group itself is not optional, but the text inside the group is,\r\n  the group will show as matching an empty string. So the result of\r\n  re.match('a(b?)c','ac') group 1 will be ''. The same is true for a repetition\r\n  that matches 0 times. Compare re.match('a(b)*c','ac') group 1 and\r\n  re.match('a(b*)c','ac') group 1.\r\n\r\n  If a group matches multiple times (e.g., a(.)*c ), only its last match is\r\n  available, so for axyzc group 1, the (.) group, is bound to the character z.\r\n  If we wrote this as a(.*)c the (.*) group is bound to the characters xyz. If\r\n  we wrote it as a((.)*)c group 1 is xyz and grups 2 is just z.\r\n\r\nPrinting the .groups() method called on a match object prints a tuple of the\r\nmatching characters for each group 1-n (not group #0)\r\n\r\nWe can look at each resulting group by its number (including group #0), using\r\nany of the following methods that operate on match objects\r\n\r\n    group(g)\t\ttext of group with specified name or number\r\n    group(g1,g2, ... )  tuple of text of groups with specified name or number\r\n    groups()\t\ttuple of text of all groups but #0 (can iterate over tuple)\r\n    groupdict()\t\ttext of all groups as dict (see ?P<name> for keys)\r\n    start([group])\tstarting index of group (or entire matched string)\r\n    end([group])\tending index of group (or entire matched string)\r\n    span([group])\ttuple: (start([group]), end([group]))\r\n  \r\nTry doing some matches and calling .groups() on the result.\r\n\r\nUnzip remethods.zip and examine the phonecall.py and readingtest.py modules\r\nfor examples of Python programs that use regular expressions (and groups) to\r\nperform useful computations.\r\n\r\n\r\n\r\nLoose Ends:\r\n\r\n1) Raw Strings\r\n\r\nWhen writing regular expression pattern strings as arguments in Python it is\r\nbest to use raw strings: they are written in the form r'...' or r\"...\". These\r\nshould be used because of an issue dealing with using the backslash character in\r\npatterns, which is sometimes necessary. For example, in normal strings when\r\nyou write '\\n' Python turns that into a 1 character string with the newline\r\ncharacter: len('\\n') is 1. But with raw strings, writing r'\\n' specifies a\r\nstring with a backslash followed by an n: len(r'\\n') is 2. Normally this isn't\r\na big issue because writing '\\d' or' \\*' in normal strings doesn't generate an\r\nescape character, since there is no escape character for d or ( so len('\\d') and\r\nlen('\\*') is 2.\r\n\r\n\r\n2) **d in function/method calls (where d is a dict)\r\n\r\nIf we call a function we can specify **d as one or more of its arguments. For\r\neach **d, Python uses all its keys as parameter names and all its values as\r\ndefault arguments for these parameter names. For example\r\n\r\n  f(**{'b':2, 'a':1, 'c':3} ) is translated by Python into f(b=2,a=1,c=3)\r\n\r\nNote that this is useful in regular expressions if we use the (?P<name> ...)\r\noption and then the groupdict() method for the match it produces.\r\n\r\nThere is also a version that works the other way. Suppose we have a functions\r\nwhose header is\r\n\r\n  def f(x,y,**kargs):  # The typical name is **kargs\r\n\r\nif we call it by f(1,2,a=3,b=4,c=5) then\r\n\r\n  x     is bound to 1\r\n  y     is bound to 2\r\n  kargs is bound to a dictionary {'b':4, 'a':3, 'c':5}\r\n\r\nSee the argument/parameter matching rules from the review lectuer for a\r\ncomplete description of what happens.\r\n\r\nSo (in reverse of the order explained above) ** as a parameter creates a\r\ndictionary of \"extra\" named-arguments suppled when the function is called, and\r\n** as an argument supplies lots of named-arguments to the function call. We\r\nwill cover this information again when we examine inheritance\r\n\r\nThe parse_phone_named method (in phoncecall.py) uses this language feature.\r\n\r\n\r\n3) Translation of a Regular Expression Pattern into a NDFA\r\n\r\nHow do the functions/methods in re compile a regular expression string and match\r\nit against a text string? It translates every regular expression into a\r\nnon-deterministic finite automaton (see Programming Assignment #1, part 4), and\r\nthen matches against the text (ibid) to see if the match succeeds (reaches the\r\nspecial last state).\r\n\r\nThe general algorithm (known as Thompson's Algorithm) is a bit beyond the scope\r\nof this course and uses a concept we haven't discussed (epsilon -aka empty-\r\ntransitions), but you can look up the details if you are intereseted. Here is\r\nan example for the regular expression pattern ((a*|b)cd)+. It produces an NDFA\r\ndescribed by\r\n\r\nstart;a;1;a;2;b;2;c;3\r\n1;a;1;a;2\r\n2;c;3\r\n3;d;start;d;last\r\nlast\r\n\r\nThis pattern matches a text string by starting in state 'start' and exhausting\r\nall the characters and having 'last' in its possible states at the end.\r\n\r\n\r\n\r\n\r\n\r\n\r\nProblems:\r\n\r\nWrite functions using regular expression patterns\r\n\r\n8. Write a function named contract that takes a string as a parameter. It\r\nsubstitutes the word 'goal' to replace any occurrences of variants of this word\r\nwritten with any number of o's, e.g., 'gooooal') in its argument. So calling\r\ncontract('It is a goooooal! A gooal.') returns 'It is a goal! A goal.'.\r\n\r\n9. Write a function named grep that takes a regular expression pattern string\r\nand a file name as parameters. It returns a list of 3-tuples consisting of the\r\nfile-name, line number, and line of the file, for each line whose text matches\r\nthe pattern. Hint: Using enumerate and a comprehension, this is a 3 line\r\nfunction, but you can use explicit looping in a longer function.\r\n\r\n10. Write a function named name_convert that takes two file names as\r\nparameter. It reads the first file (which should be a Python program) and\r\nwrites each line into the second file, but with identifiers originally written\r\nin camel notation converted to underscore notation: e.g. aCamelName converts to\r\na_camel_name. Camel identifiers start with a lower-case letter followed by\r\nupper/lower-case letters and digits: each upper-case letter is preceded by an\r\nunderscore and turned into a lower-case letter.\r\n", "encoding": "ascii"}