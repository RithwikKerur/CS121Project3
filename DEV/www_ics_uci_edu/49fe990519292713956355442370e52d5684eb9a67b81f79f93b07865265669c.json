{"url": "https://www.ics.uci.edu/~jiac5/PMVS/index.html", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html><head><meta content=\"text/html; charset=ISO-8859-1\" http-equiv=\"content-type\"><title>PMVS by Jia Chen</title></head>\r\n<body style=\"width: 901px;\"><h1 style=\"text-align: center;\">Patch-based Multi View Stereo </h1><div style=\"color: red; text-align: center;\"><br></div><h1 style=\"text-align: justify;\">Introduction</h1><div style=\"text-align: justify;\">This\r\nproject is an implementation of PAMI 2010 paper \"Accurate, dense, and\r\nrobust multi-view stereopsis\" by Yasutaka Furukawa and Jean Ponce. The\r\nsystem is able to reconstruct patches from a set of calibrated images,\r\nby going through the match -&gt; expand -&gt; filter procedure. Some of\r\nthe results are shown as below. Since currently only the patch\r\nreconstruction part of the algorithm (section III of the paper) is\r\nimplemented, the polygonal mesh cannot be generated yet. Besides that,\r\nconsidering that there are still a big space to be improved for my\r\ncurrent patch reconstruction result, I expect everything to be ready in\r\nearly March. <br><div style=\"text-align: center;\"><img style=\"width: 279px; height: 235px;\" alt=\"Front\" src=\"Front.png\"><img style=\"width: 279px; height: 235px;\" alt=\"side\" src=\"Side.png\"><img style=\"width: 193px; height: 235px;\" alt=\"bottom\" src=\"back.png\"><br></div><a href=\"PMVS_JC_src.rar\">Source code (Feb 22, 2014 version)</a><br><a href=\"PMVS_JC_patches.rar\">Patches generated for Skull data set (Feb 22, 2014)</a> can be viewed by PatchViewer provided by <a href=\"http://www.di.ens.fr/pmvs/pmvs-1/index.html\">PMVS</a><br></div><h1 style=\"text-align: justify;\">Algorithm and Implementation Details</h1><h2 style=\"text-align: justify;\">Step 1. Initial Match</h2><h3 style=\"text-align: justify;\">1.1 Feature Detection</h3><div style=\"text-align: justify;\">For\r\neach images, blob and corner features are detected by Harris&nbsp;and\r\nDoG operators, as shown below. &nbsp;Currently, for convenience, this\r\npart is implemented with OpenCV (Version 2.6.4), which lead my\r\nimplementation dependent on OpenCV, so I plan to replace it with my own\r\ncode later. &nbsp;<br></div><div style=\"text-align: center;\"><img style=\"width: 400px; height: 420px;\" alt=\"Feature detection\" src=\"FeatureDetection.jpg\"><br></div><h3 style=\"text-align: justify;\">1.2 Feature Matching</h3><div style=\"text-align: justify;\">Since\r\nall the images are calibrated, for each feature f0 in image 0 (as shown\r\nin the left figure), we can determine the epipolar line in another\r\nimage i from their corresponding projection matrices (shown as green\r\nline in the figure below). And only the features (1) fall on the\r\nepipolar line and (2) with the same type (Harris or DoG) as the\r\nreference feature wil be considered as matching candidates. <br>For\r\nthe epipolar geometry calculation, I tried to use OpenCV at first, but\r\nthe results produce by OpenCV triangulation methods seems quite\r\nproblematic. So I had to create my own implementation, and found the\r\nbible book \"Multiple view geometry in computer vision\" an excellent\r\nreference for implementing this. <br></div><div style=\"text-align: center;\"><img style=\"width: 400px; height: 420px;\" alt=\"Feature in view 0\" src=\"1.FeatureInView0.jpg\"><img style=\"width: 400px; height: 420px;\" alt=\"Feature Matching\" src=\"FeatureMatching.jpg\"><br></div><div style=\"text-align: justify;\">Left:\r\nA feature detected in view 0, Right: the epipolar line are shown as\r\ngreen,&nbsp; while the matching candidates are red points<br></div><h3 style=\"text-align: justify;\">1.3 Initial Match</h3><div style=\"text-align: justify;\">As\r\nshown in the figure above, there are often multiple candidates which\r\nmeet geometry constraints, so we still have to filter out those fake\r\npositives with photometric discrepancy function as eq (1) in the paper.\r\n<br>For this part, I generally follows the algorithm below. Except for\r\nthe Patch Optimization (Refine) part, while the conjugate gradient\r\nmethod was applied by the paper using Wnlib library, I met some\r\nproblems when compiling Wnlib under Windows. So as a temporary\r\nsolution, I applied a simple searching method (iteratively search for\r\nminimum point in the nearby value space) instead, which I think\r\nalthough slower, but should have the same effect as conjugate gradient\r\nmethod. <br><br><div style=\"text-align: center;\"><img style=\"width: 419px; height: 367px;\" alt=\"Initial Matching Algorithm\" src=\"InitialMatching.png\"><br></div><br><h2>Step 2. Expansion</h2><div style=\"text-align: center;\"><div style=\"text-align: justify;\">As\r\nthe initial match has only a sparse set of patches, expansion is\r\nimportant to produce patches dense enough for reconstruction. In this\r\nstage, I followed the algorithm below. And since most of the patches\r\nare actually added into patch list in this stage, expansion took the\r\nmost of processing time (70% percent of total time).<br></div><img style=\"width: 402px; height: 335px;\" alt=\"Expansion\" src=\"Expansion.png\"><br><img style=\"width: 259px; height: 225px;\" alt=\"ResultWithoutExpansion\" src=\"WithoutExpansion.png\"><img style=\"width: 270px; height: 225px;\" alt=\"Expansion3\" src=\"expansion3.png\"><img style=\"width: 238px; height: 225px;\" alt=\"Expan2\" src=\"Side.png\"><br></div><h2>Step 3. Filtering</h2>Currently\r\nfiltering is the most problematic part of the system, some outliers are\r\nnot filtered out properly.&nbsp; A big improvement is expected to be\r\ndone. </div><h1 style=\"text-align: justify;\">Known Issues and Future Work</h1><div style=\"text-align: justify;\">As the project is still on going, the tasks below are to be finished: <br>1. The filtering issue mentioned above. <br>2. Polygonal mesh reconstruction. <br>3.\r\nPerformance improvement. This implementation runs over an hour to\r\nproduce patches, while official PMVS needs less than 20 minutes. I\r\nguess that the reasons for the performance issue include: &nbsp;(1) The\r\nsearching method I applied in patch optimization is much slower than\r\nconjugate gradient method (2) PMVS might apply multi thread (or GPU ? I\r\nam not sure) (3) Some calculation duplication in my implementation <br>4.\r\nPatchViewer. Currently the 3D views are rendered using PatchViewer\r\nprovided by PMVS, as a customized viewer will provide more convenience\r\nfor debugging and testing, I plan to implement my own PatchViewer in\r\nnext step.</div><h1 style=\"text-align: justify;\">References:</h1><div style=\"text-align: justify;\">1.\r\nFurukawa Y, Ponce J. Accurate, dense, and robust multiview\r\nstereopsis[J]. Pattern Analysis and Machine Intelligence, IEEE\r\nTransactions on, 2010, 32(8): 1362-1376.<br>2. R. I. Hartley and A. Zisserman,Multiple View Geometry in Computer Vision. Cambridge University Press, 2004.</div></body></html>\n", "encoding": "ascii"}