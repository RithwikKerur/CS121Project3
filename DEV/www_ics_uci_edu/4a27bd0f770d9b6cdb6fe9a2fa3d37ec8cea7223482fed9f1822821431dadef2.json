{"url": "https://www.ics.uci.edu/~theory/research.html", "content": "<html>\n  <head>\n    <title>Center for Algorithms and Theory of Computation</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <img src=\"logo/CATOC2.jpg\" align=bottom ALT=\"ICS Theory Group\">\n\n    <h1>Research in Algorithms and Theory of Computation at UC-Irvine</h1>\n\n    <p>The goal of research in theoretical computer science is to produce\n    results, supported by rigorous proof, about problems dealing with\n    computers and their applications. The questions to be investigated are\n    often motivated by practical problems, but the goal of understanding\n    the fundamental structure of the problem is often as important as\n    producing a solution of immediate applicability. Despite this emphasis,\n    it turns out that results that first might appear to be only of\n    theoretical value are sometimes of profound relevance to practical\n    problems.</p>\n\n    <p>In particular, one of the major subareas of theoretical computer\n    science, and the one pursued by the faculty and graduate students at\n    UCI, is concrete complexity: We look at specific problems and try to\n    determine the complexity (i.e., the amount of resources required) for\n    obtaining a solution. Our work falls into three main areas:  design of\n    algorithms and data structures; analysis; problem complexity.</p>\n\n    <h2>Design of Algorithms and Data Structures</h2>\n\n    <p>Given a problem, we try to find efficient solution methods. A data\n    structure is a way of organizing information; sometimes the design of\n    an appropriate data structure can be the foundation for an efficient\n    algorithm, and we have made a number of significant contributions to\n    the field of data structures. In addition, one of our members has\n    written a widely used and respected text on data structures, and is\n    presently completing a second more introductory text.</p>\n\n    <p>In addition to the design of new data structures, we are also\n    interested in efficient algorithms for problems arising in a variety of\n    fields. Often such problems can be represented in terms of trees,\n    graphs, or strings, and we are interested in the design of efficient\n    solutions for such problems.</p>\n\n    <p>The field of computational geometry investigates the complexity of\n    problems involving two-dimensional (or higher) spaces. This is an\n    active research area which has not only theoretical depth but also\n    practical applications in areas such as pattern recognition, VLSI\n    layout, statistics, and image processing. One major area of our work is\n    the investigation of certain properties of geometric constructs which\n    can be modeled by graphs. We have also explored how solutions to\n    geometric problems such as linear programming or the minimum spanning\n    tree can be made dynamic, i.e., how we can efficiently maintain the\n    solution when the input data are subject to change.</p>\n\n    <p>Also of interest is the compression of data. For example, we have\n    reduced the complexity of algorithms for compressing strings, and have\n    also investigated the compression of structures such as quadtrees which\n    are used for storing spatial data.</p>\n\n    <p>Current work in genetics provides an exciting application area for\n    algorithms. Some work done long ago by our present faculty, on longest\n    common subsequences and on PQ-trees, has turned out to be valuable in\n    solving problems that arise in genetics.  More recently, one of our\n    faculty has introduced sophisticated new methods for speeding the\n    solution of problems such as DNA sequence comparison.</p>\n\n    <p>Much of our work has dealt with the fast solution of problems by a\n    single processor. The combination of declining cost of processors and\n    the desire for fast solutions to problems has led to a great deal of\n    interest in the use of parallelism to speed up computation. One natural\n    question is thus: how long does it take to solve a given problem with a\n    limited number of parallel processors? Some of us have been especially\n    interested in solving problems on graphs very quickly without using an\n    excessive number of processors.</p>\n\n    <H2>Analysis</H2>\n\n    <p>Once a solution method has been proposed, we seek to find a rigorous\n    statement about its efficiency; analysis of algorithms can go\n    hand-in-hand with their design, or can be applied to known algorithms.\n    Some of this work is motivated in part by the theory of NP-completeness,\n    which strongly suggests that certain problems are just too hard to\n    solve exactly and efficiently all of the time. It may be, though, that\n    the difficult cases are relatively rare, so we attempt to investigate\n    the behavior of problems and algorithms under assumptions about the\n    distribution of inputs.</p>\n\n    <p>Our group at UCI has made major contributions in the area of\n    probabilistic analysis. We have done work in algorithms for problems\n    such as packing, partitioning, marking algorithms, and hashing. In\n    particular, we have obtained a surprising result about the behavior of\n    a well known marking algorithm, and an elegant analysis of double\n    hashing.</p>\n\n    <p>Probability can provide a powerful tool even when we do not assume a\n    probability distribution of inputs. In an approach called\n    randomization, one can introduce randomness into the algorithm itself\n    so that even on on worst-case input it works well with high\n    probability. For example, for the classical List Update Problem, which\n    involves organizing data so that we can perform searches efficiently,\n    one of our faculty has shown how to use randomization to beat the\n    inherent limit of a deterministic approach.</p>\n\n    <p>An area of considerable recent interest is on-line algorithms. Here we\n    investigate the performance of algorithms which must provide answers\n    based on part of the input before the remainder is available.  A good\n    example is memory paging---when swapping, the system must decide which\n    memory pages to keep in its cache before it sees which ones will\n    actually be used later. Earlier analysis of this problem had not been\n    fully successful in explaining why a common heuristic performs so well.\n    One of our faculty developed a new approach which formally models\n    locality of reference, and thus can better explain the performance of\n    paging algorithms.</p>\n\n    <h2>Problem complexity</h2>\n\n    <p>When efficient solutions appear difficult, negative results can\n    sometimes provide very helpful guidance. Two major types of results are\n    possible here.</p>\n\n    <ul>\n      <li>In some cases one can actually prove that, under some model,\n      the problem does not admit solution without a certain level of\n      resources.</li>\n\n      <li>For many problems, good bounds of the above type are not\n      available, but the problem can be shown to be equivalent in\n      complexity to some well-known class of problems. For example, if a\n      problem is NP-complete it cannot be solved in polynomial time\n      unless P=NP, which is a major open question.</li>\n    </ul>\n\n    <p>Such results can save wasted effort by researchers, and in some cases\n    might also suggest that algorithms from a different model should be\n    considered.</p>\n\n    <hr>\n\n    <address>\n      Department of Computer Science<br/>\n      University of California, Irvine, CA 92697-3425<br/>\n    </address>\n  </body>\n</html>\n", "encoding": "ascii"}