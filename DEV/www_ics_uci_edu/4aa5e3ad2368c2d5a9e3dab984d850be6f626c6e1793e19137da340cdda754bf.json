{"url": "https://www.ics.uci.edu/~majumder/VC/211HW3/vlfeat/vl/ikmeans_lloyd.tc", "content": "/** @file ikmeans_lloyd.tc\n ** @brief Integer K-Means - LLoyd Algorithm - Definition\n ** @author Brian Fulkerson\n ** @author Andrea Vedaldi\n **/\n\n/*\nCopyright (C) 2007-12 Andrea Vedaldi and Brian Fulkerson.\nAll rights reserved.\n\nThis file is part of the VLFeat library and is made available under\nthe terms of the BSD license (see the COPYING file).\n*/\n\n/** @internal\n ** @brief Helper function to initialize a filter for Lloyd algorithm\n **\n ** @param f filter.\n **/\n\nstatic void\nvl_ikm_init_lloyd (VlIKMFilt * f VL_UNUSED)\n{ }\n\n/** @internal\n ** @brief LLoyd algorithm\n ** @param f IKM quantizer.\n ** @param data Training data.\n ** @param N Number of traning data.\n ** @return error code.\n **/\n\nstatic int\nvl_ikm_train_lloyd (VlIKMFilt* f, vl_uint8 const* data, vl_size N)\n{\n  int err =  0 ;\n  vl_uindex iter, i, j, k  ;\n  vl_uint32 *asgn = vl_malloc (sizeof(vl_uint32) * N) ;\n  vl_uint32 *counts = vl_malloc (sizeof(vl_uint32) * N) ;\n\n  for (iter = 0 ; 1 ; ++ iter) {\n    vl_bool done = 1 ;\n\n    /* ---------------------------------------------------------------\n     *                                               Calc. assignments\n     * ------------------------------------------------------------ */\n\n    for (j = 0 ; j < N ; ++j) {\n      vl_ikmacc_t best_dist = 0 ;\n      vl_index best = -1 ;\n\n      for (k = 0; k < f->K ; ++k) {\n        vl_ikmacc_t dist = 0 ;\n\n        /* compute distance with this center */\n        for (i = 0; i < f->M ; ++i) {\n          vl_ikmacc_t delta =\n            data [j * f->M + i] - f->centers [k * f->M + i] ;\n          dist += delta * delta ;\n        }\n\n        /* compare with current best */\n        if (best == -1 || dist < best_dist) {\n          best = k ;\n          best_dist = dist ;\n        }\n      }\n      if (asgn [j] != best) {\n        asgn [j] = (vl_uint32) best ;\n        done = 0 ;\n      }\n    }\n\n    /* stopping condition */\n    if (done || iter == f->max_niters) break ;\n\n    /* ---------------------------------------------------------------\n     *                                                   Calc. centers\n     * ------------------------------------------------------------ */\n\n    /* re-compute centers */\n    memset (f->centers, 0, sizeof(*f->centers) * f->M * f->K);\n    memset (counts,  0, sizeof(*counts) * f->K);\n    for (j = 0; j < N; ++j) {\n      vl_uindex this_center = asgn [j] ;\n      ++ counts [this_center] ;\n      for (i = 0; i < f->M ; ++i) {\n        f->centers [this_center * f->M + i] += data[j * f->M + i] ;\n      }\n    }\n\n    for (k = 0; k < f->K; ++k) {\n      vl_index n = counts [k];\n      if (n > 0xffffff) {\n        err = 1 ;\n      }\n      if (n > 0) {\n        for (i = 0; i < f->M; ++i) {\n          f->centers [k * f->M + i] /= n;\n        }\n      } else {\n        /*\n           If no data are assigned to the center, it is not changed\n           with respect to the previous iteration, so we do not do anything.\n        */\n      }\n    }\n  }\n\n  vl_free (counts) ;\n  vl_free (asgn) ;\n  return err ;\n}\n\n\n/** @internal\n ** @brief LLoyd algorithm\n ** @param f     IKM quantizer.\n ** @param asgn  Assignments (out).\n ** @param data  Data to quantize.\n ** @param N     Number of data.\n **/\n\nstatic void\nvl_ikm_push_lloyd (VlIKMFilt *f, vl_uint32 *asgn, vl_uint8 const *data, vl_size N)\n{\n  vl_uindex j ;\n  for(j = 0 ; j < N ; ++j) {\n    asgn[j] = vl_ikm_push_one (f->centers, data + j * f->M, f->M, f->K);\n  }\n}\n\n/*\n * Local Variables: *\n * mode: C *\n * End: *\n */\n", "encoding": "ascii"}