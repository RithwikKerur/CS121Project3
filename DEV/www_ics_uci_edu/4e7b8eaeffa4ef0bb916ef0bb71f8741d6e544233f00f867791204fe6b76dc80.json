{"url": "https://www.ics.uci.edu/~ejw/versioning/arch/0055.html", "content": "<!-- received=\"Fri Jun 07 05:23:00 1996 PDT\" -->\n<!-- sent=\"Fri, 07 Jun 1996 08:22:23 -0400\" -->\n<!-- name=\"David J. Fiander\" -->\n<!-- email=\"davidf@worf.mks.com\" -->\n<!-- subject=\"Re: High-level capabilities\" -->\n<!-- id=\"ade263cf3d021004aef5@[128.195.21.209]\" -->\n<!-- inreplyto=\"High-level capabilities\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Re: High-level capabilities</title>\n<h1>Re: High-level capabilities</h1>\n<b>David J. Fiander</b> (<a href=\"mailto:davidf@worf.mks.com\"><i>davidf@worf.mks.com</i></a>)<br>\n<i>Fri, 07 Jun 1996 08:22:23 -0400</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#55\">[ date ]</a><a href=\"thread.html#55\">[ thread ]</a><a href=\"subject.html#55\">[ subject ]</a><a href=\"author.html#55\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0056.html\">David J. Fiander: \"Re: More versioning thoughts.\"</a>\n<li> <b>Previous message:</b> <a href=\"0054.html\">Fabio Vitali: \"Re: More versioning thoughts\"</a>\n<li> <b>Maybe in reply to:</b> <a href=\"0047.html\">Jim Whitehead: \"High-level capabilities\"</a>\n<!-- nextthread=\"start\" -->\n<li> <b>Next in thread:</b> <a href=\"0058.html\">David J. Fiander: \"Re: High-level capabilities\"</a>\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\nDavid G. Durand says:\n&gt; At 11:57 AM 6/6/96, Jim Whitehead wrote:\n&gt; &gt;3. Retrieval of derivation relationships between versions of an entity: The\n&gt; &gt;ability to trace the development and ownership of an entity provides\n&gt; &gt;visibility into the development of that entity, and into the namespace of\n&gt; &gt;version identifiers for versions of that entity.\n&gt;\n&gt; I agree that tracing ancestry relationships is useful. I'm not sure what\n&gt; kind of insight you can gain into the \"namespace\" of &lt;em&gt;opaque&lt;/em&gt;\n&gt; version identifiers. You should be able to gain information about the\n&gt; relationships of specific instantiated items in the namespace, but more\n&gt; insight than that breaks the opaqueness of the version-id.\n\nThis retrieval of the the relationships can be accomplished two\ndifferent ways: create a new method: \"HISTORY\", or perhaps\n\"INDEX\"; provide a cgi-bin which takes a URL and returns the\nhistory.  The former ensures that the functionality is always\navailable in a standard way, while the latter keeps the protocol\nsmall.\n\n&gt; &gt;4. Writing to a given version of an entity: Once changes have been made to\n&gt; &gt;an entity, versioning policies often dictate that the changes be written\n&gt; &gt;into a new, stated version of that entity.\n&gt;\n&gt; I think that this is mainly a server issue, not a protocol one.\n\nWhile the server is the final arbiter when it comes to what, if\nany, version identifier (VID) is assigned to a checked-in\nversion, the protocol should provide a mechanism for the client\nto specify the desired VID.  (This becomes important in an\nSCCS-based environment, since SCCS allows a single user to have\nmultiple different versions of the same file locked.  The user\nmust specify which version she's checking in.)\n\n&gt; &gt;6. Parallel development support: Since it frequently occurs that multiple\n&gt; &gt;people edit the same entity simultaneously, this type of activity must be\n&gt; &gt;supported.  User agents must be supplied with enough information to inform\n&gt; &gt;their users when they are entering a parallel development situation, and\n&gt; &gt;they must be supplied with the versions of parallel entities so they can\n&gt; &gt;provide merge support for the entity contents.  Futhermore, since it is\n&gt; &gt;currently beyond the state of the art to provide merge support for certain\n&gt; &gt;entity types (e.g., MPEG video), it must be possible to disallow parallel\n&gt; &gt;development on these entity types.\n&gt;\n&gt; Server issue. I don't think this affects the protocol at all.\n\nGiven that the requirements of the (deleted) point 5 are met,\nthen yes, this is a server issue.\n\n&gt; &gt;7. Visibility control: Through the user agent, it should be possible to\n&gt; &gt;control the external visibility of an entity.  For example, this is useful\n&gt; &gt;for ensuring that working revisions of an entity are not accessible by the\n&gt; &gt;entire world.\n&gt;\n&gt; This sounds like a non-minimal requirement to me, because it is another\n&gt; policy issue Some servers might control this automatically, or require\n&gt; manual intervention via some separet communication channel. Do we perhaps\n&gt; need a general protocol for negotiating server policy options? Then we'd\n&gt; have a way to standardize setting of such options, but leave the door open\n&gt; to the wide variety of different policies.\n\nI agree with David.  authorization (security) and authentication\n(identity) issues are server issues.  In the words of the ANSI C\nstandard, it's a \"quality of implementation\" issue.\n\n&gt; &gt;8. Configuration support: The user must be able to create versioned\n&gt; &gt;collections of versioned entities.  When creating online documentation, an\n&gt; &gt;author will create multiple pages, which may, for example, contain an HTML\n&gt; &gt;document and supporting bitmap graphics and applet objects.  The author\n&gt; &gt;will want to make a versionable collection of the entities which comprise\n&gt; &gt;each page, as well as a versionable collection of all the pages.\n&gt;\n&gt; This seems like the update portion of requirement 2. Seems like a\n&gt; non-minimal issue to me (except possibly again in dealing with the \"current\n&gt; version\").\n\nWell, it's non-minimal but, in the long run, configuration\nmanagement is important.  We have to leave room in the early\nspecification for CM to be slotted in later.  One interesting\nproblem is that, given that a user has a set of pages that are\nconsistent, how does she check them &lt;em&gt;all&lt;/&gt; in and ensure that\nthe server's view of the world is always consistent?\n\n&gt; &gt;Note that you might not want all users to be able to employ all\n&gt; &gt;capabilities all the time.  For the development of these requirements, I\n&gt; &gt;have assumed a super-user who would be able to do everything, all the time.\n&gt; &gt;Access control mechanisms can limit which users can employ which\n&gt; &gt;capabilities.\n&gt;\n&gt; We seem to be at policy again. I had been assuming that HTTP authorization\n&gt; mechanisms would provide sufficient security so that a server could\n&gt; implement whatever policy it wants.\n\nDavid's right.  This is quality of implementation again.  A\nserver that hangs loose and lets just anybody check in or lock\npages, with no way to tighten access up, won't win.\n\n- David\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0056.html\">David J. Fiander: \"Re: More versioning thoughts.\"</a>\n<li> <b>Previous message:</b> <a href=\"0054.html\">Fabio Vitali: \"Re: More versioning thoughts\"</a>\n<li> <b>Maybe in reply to:</b> <a href=\"0047.html\">Jim Whitehead: \"High-level capabilities\"</a>\n<!-- nextthread=\"start\" -->\n<li> <b>Next in thread:</b> <a href=\"0058.html\">David J. Fiander: \"Re: High-level capabilities\"</a>\n<!-- reply=\"end\" -->\n</ul>\n", "encoding": "ascii"}