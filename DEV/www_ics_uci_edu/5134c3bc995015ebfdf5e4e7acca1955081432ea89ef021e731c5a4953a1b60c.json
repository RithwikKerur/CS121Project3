{"url": "https://www.ics.uci.edu/~kay/courses/i42/hw/labA.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Wednesday, February 22, 2006 4:19 PM\">\n<TITLE>Lab Assignment A</TITLE>\n\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"AD90657D\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 2, CS2, assignment, Java, OOP\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"A lab assignment for Informatics 42, a second-quarter course in computer science for Informatics majors in the Bren School of Information and Computer Sciences, UC Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2005 by David G. Kay.  All rights reserved.\">\n<link href=\"/~kay/courses/i42/code.css\" rel=\"stylesheet\" type=\"text/css\" />\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<P>\n<FONT FACE=\"Goudy Old Style\">Informatics 42 &bull; Winter 2012 &bull; David G. Kay\n&bull; UC Irvine</FONT></P>\n<P>\n<FONT SIZE=6><B>Lab Assignment A</B></FONT><br />\n<FONT FACE=\"Goudy Old Style\">\"Luck, Be a Lady Tonight\"</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">This assignment is due at the end of lab on\nWednesday, January 25.  This is enough time for a novice Python programmer to\ncomplete the task, bearing in mind that Informatics 42 is a six-unit course\nthat typically will require work outside of the normally scheduled lab hours.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">You will also notice that the specifications\nfor most assignments in this course are longer than we&#39;ve seen before.\n This is a good thing:  the more explanation we give, the more guidance\nyou have.  But technical specifications are not like novels.  You cannot\nspeed-read through them just one time and expect to gain the information\nyou need.  Plan to read the specifications carefully, and plan to go back\nand read them again to pick up additional details.</FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">We expect you to complete this assignment in\npairs, following the usual <A HREF=\"http://www.ics.uci.edu/~kay/courses/i41/hw/pair.html\">pair programming guidelines</A>.\n You may not choose\nthis project as your one &quot;pair programming holiday&quot; this quarter.\n There are lots of little details to get through, and it&#39;s really hard\nto do it alone.  We suggest that you try to pick a partner whose experience\nlevel is relatively close to your own; that seems to optimize both the effectiveness\nand the efficiency of both partners&#39; learning (i.e., you&#39;ll learn\nmore with less effort).</FONT></P>\n<P>\n<B>Problem synopsis:</B> \nWrite a program to play the dice game \"craps,\" including playing\nagainst the computer, compiling statistics on the fairness of the\ndice, and handling bets.</P>\n<p>\nThis assignment is divided into four stages. Each succeeding stage is built upon what you have already written for the previous stage. We expect you to design, write, and test this program according to these stages\u2014first get the first-stage program working, then modify it to satisfy the second stage, and so on.\n</p>\n<p>\nYou should make sure that each stage is entirely correct and working perfectly before you go on to the next. As you complete each stage, you must demonstrate briefly to your TA or tutor that it works correctly before you go on to the following stage. If you try to add the second-stage features before your first stage is debugged, you'll just have twice as large a program to search through for errors. In fact, breaking up the problem into several subprograms will speed up your coding, aid you in debugging, and keep you from getting too far off on the wrong track.\nSometimes students think, \"Yes, this business about stages would be a\nnice idea if I had the time, but it'll take me too long.\" This is\nwrong. What will take you the most time (and thus cause you the most\nfrustration and unhappiness) is trying to debug the whole program at\nonce. If it seems longer to do it by stages, it's only because each\nstage is a nicely manageable piece that's not too taxing by itself.\n</p>\n<p>\nYou will find that this program focuses mostly on control\nstructures\u2014how to get the right things to happen in the right\norder, including managing interactions with the user.  \nThese are skills you need to program in languages like Python.\nBut you won't find that object-oriented design, model-view-controller\norganization, or even unit testing will help you all that much.  You\nshould certainly try to isolate separate functionality (like rolling\ntwo dice and returning the result) into separate functions, but the\ninteractive nature of the program and the randomness of the dice will\nlead you simply to run interactive tests as frequently as you can.\n</p>\n<p>\n<b>Grading:</b> Your score will depend primarily on correctness and on adherence to\nthe specifications (which is essentially the same thing).  It is\nalways far better to implement a subset of the functionality correctly\nthan to attempt to implement more features in a program that retains\nsome bugs.  Secondary aspects of your score will include contract\nand purpose information where appropriate, reasonable adherence to\nPython coding conventions and idioms, and avoidance of grossly clumsy\nor stylistically poor code.\n</p>\n<p><FONT FACE=\"Goudy Old Style\">In assignments for this class, code that doesn&#39;t\ncompile correctly will receive very little credit, no matter how long or\nhow hard you worked on it.  If it doesn&#39;t compile, there&#39;s no real\nway to tell what it does or doesn&#39;t do.</FONT></p>\n<p>\n  <strong>Statement of the problem:</strong> \n  The operators of the oldest established permanent floating crap game in New York have decided to computerize their racket, figuring that since a computer can shoot craps faster than a human, more games can be played, so more money can be made. Sky Masterson has fingered you to write the program.\n</p><p>\nCraps is a game played with two six-sided dice; each die's faces are\nnumbered from 1 to 6. The player (or \"shooter\") rolls the dice. The shooter wins\nright away If the total of the two faces is a \"natural\" (7 or 11).\nIf it is \"craps\" (2, 3, or 12), the shooter loses. \nAnything else becomes the shooter's \"point\". The shooter then keeps on\nrolling until either winning by \n\"making the point\" (i.e., rolling that number again) or losing by\n\"crapping out\" (rolling a 7). (The rolls 2, 3, 11, and 12 have no\nspecial meaning when the shooter is trying to make the point.)\n</p>\n<p>\n<strong>Stage I:</strong>\n In this stage you will write an interactive program to play a single\n game of craps. When you complete this stage, it should produce sample\n sessions like the following:</p>\n<pre><code>Welcome to Sky Masterson's Craps Game \n\nRoll is  7\nNatural; shooter wins\nThank you for playing</code></pre>\nAnother possible session is:\n<pre><code>Welcome to Sky Masterson's Craps Game \n\nRoll is  6\nThe point is 6\nRoll is  12\nRoll is  12\nRoll is  4\nRoll is  10\nRoll is  7\nCrapped out; shooter loses\nThank you for playing</code></pre>\n\n<p>Use your reference materials (the online Python documentation or the textbook) to find out how to generate random numbers.  Often we'll just tell you specific details like this, but you do need the experience of looking things up yourself and this is an easy thing to find. (But if it takes you more than ten minutes, ask someone rather than spending more time on it.)</p>\n<p><b>Stage II:</b> \n  [Make your enhancements for this stage on a separate copy of your\n  Stage I program.  Don't modify your only copy.]\n</p><p>\nFor this stage, modify your program so that it plays a succession of\ngames, continuing until the player asks to quit, and alternating games\nplayed between the human player and the computer. That is, after the\nhuman player plays a single game (as described in Stage I), the\ncomputer will roll dice for a game. Then, your program should ask the\nplayer if he would like to play another round. If the answer is yes,\nthen the whole process is repeated. If not, the program prints its\nfinal message and halts, as before.\n</p><p>\nA sample session for this stage follows;\nthe user's input is shown in <code><strong>bold face</strong></code>.\n<pre><code>Welcome to Sky Masterson's Craps Game \n\nYour game:\nRoll is  7\nNatural; shooter wins\n\nComputer's game:\nRoll is  3\nCraps; shooter loses\n\nWould you like to play again? (y or n):  <b>y</b>\nYour game:\nRoll is  3\nCraps; shooter loses\n\nComputer's game:\nRoll is  8\nThe point is 8\nRoll is  7\nCrapped out; shooter loses\n\nWould you like to play again? (y or n):  <b>y</b>\nYour game:\nRoll is  6\nThe point is 6\nRoll is  8\nRoll is  11\nRoll is  10\nRoll is  5\nRoll is  7\nCrapped out; shooter loses\n\nComputer's game:\nRoll is  8\nThe point is 8\nRoll is  6\nRoll is  10\nRoll is  4\nRoll is  8\nMade the point; shooter wins\n\nWould you like to play again? (y or n):  <b>n</b>\nThank you for playing</code></pre>\n<p><b>Stage III:</b>\nSky doesn't trust you completely, though; he's afraid you might make\nthe game crooked so a pal of yours can beat the odds. In this stage\nyou will demonstrate that the dice aren't loaded (i.e., that the roll\nfunction is pretty random). Modify your program so that it keeps track\nof the number of times each possible total (2 through 12) comes up\nduring the entire session.\n</p><p>\n After the player decides to stop playing,\ncontinue rolling silently until you have exactly 2000 rolls. Then plot\nthe results in histogram form, showing how frequently each possible\ntwo-dice total (2 through 12) came up.  Your results might look like\nthis:\n<pre><code>Welcome to Sky Masterson's Craps Game\n\nYour game:\nRoll is  2\nCraps; shooter loses\n\nComputer's game:\nRoll is  10\nThe point is 10\nRoll is  5\nRoll is  10\nMade the point; shooter wins\n\nWould you like to play again? (y or n):  <b>n</b>\n\nThank you for playing\n\nDistribution of dice rolls\n\n 2:    54 ( 2%)  **\n 3:   118 ( 5%)  *****\n 4:   164 ( 8%)  ********\n 5:   228 (11%)  ***********\n 6:   253 (12%)  ************\n 7:   333 (16%)  ****************\n 8:   284 (14%)  **************\n 9:   227 (11%)  ***********\n10:   157 ( 7%)  *******\n11:   116 ( 5%)  *****\n12:    66 ( 3%)  ***</code></pre>\n<p><b>Stage IV:</b>\nWe expect that every pair will be able to complete this final stage;\nsimilar students in similar classes in the past have done it (singly).  \nBut if your pair runs into unusual difficulty on this stage, you\nshould know that you can get a reasonable score on the assignment\nwithout it (assuming that what you do turn in is entirely correct).\n</p><p>\nIn this stage you will add betting to the game. Initially, the player\nand the computer are both given $500. The program will play a series\nof games, alternating turns between the human player and the computer,\njust as in Stage II. The program ends either when the player doesn't\nwant to play any more (as before) or when the player runs out of money\n(goes broke). When play is over, the program will print betting\nstatistics (described below) before printing its final message and\nending.\n</p><p>\nThe computer, unlike the human player, has infinite credit; its funds can go below zero without affecting the play. But neither player may make a negative bet.\n</p><p>\nBefore the human player's turn starts, the program asks how much the\nplayer wants to bet.\nAnd if the human player needs to roll to make a point, the program\nwill ask before each roll how much more to add to the current bet.\nIf the player tries to bet more money than he or she has, the program\nwill print a message and ask for another amount.\n</p><p>\nWhen it is the human player's turn, the computer will simply match the\nhuman player's bet.\n</p>\n<p>\nWhen it is the computer's turn, the computer will bet half of its\ncurrent funds or $75, whichever is lower. But if the computer is in\ndebt or broke, it will bet $15. The amount of the computer's bet is\ndisplayed, and the player will be asked to make a bet. The most the\nplayer can bet is the amount the computer bet or the amount the player\nhas, whichever is lower. If the player attempts to bet more than he or\nshe has, handle it as above. If the player bets more than the computer\nbet, the program lowers the player's bet to match. If the player bets\nless than the computer, the computer will reduce its bet to match the\nplayer's bet. After these initial bets, no other betting occurs during\nthe computer's turn.\n</p>\n<p>\nFinally, your program should also keep track of some statistics and\nprint them out at the end of the entire session. Keep track of how\nmuch each player (human and computer) has bet and has won, and how\nmuch they have left at the end. Also, keep track of the smallest and\nlargest pot of the game and the average pot size.\n</p><p>\nHere is a sample session for this stage:\n<pre><code>Welcome to Sky Masterson's Craps Game\n\nYour game:\nHow much would you like to bet?  <strong>100</strong>\nRoll is  10\nThe point is 10\nHow much would you like to bet?  <strong>300</strong>\nRoll is  9\nHow much would you like to bet?  <strong>50</strong>\nRoll is  8\nHow much would you like to bet?  <strong>100</strong>\nSorry; you've already bet $450.00 and you can't bet more than the $50.00 you have left.\nHow much would you like to bet?  <strong>0</strong>\nRoll is  8\nHow much would you like to bet?  <strong>0</strong>\nRoll is  2\nHow much would you like to bet?  <strong>0</strong>\nRoll is  9\nHow much would you like to bet?  <strong>0</strong>\nRoll is  10\nMade the point; shooter wins\n\nYou have $950.00; computer has $50.00.\n\nComputer's game:\nComputer bets $25.00\nHow much would you like to bet?  <strong>100</strong>\nYou can't bet more than the computer; bet changed to $25.00.\nRoll is  6\nThe point is 6\nRoll is  10\nRoll is  11\nRoll is  6\nMade the point; shooter wins\n\nYou have $925.00; computer has $75.00.\nWould you like to play again? (y or n):  <strong>y</strong>\n\nYour game:\nHow much would you like to bet?  <strong>500</strong>\nRoll is  7\nNatural; shooter wins\n\nYou have $1425.00; computer has $-425.00.\n\nComputer's game:\nComputer bets $15.00\nHow much would you like to bet?  <strong>15</strong>\nRoll is  8\nThe point is 8\nRoll is  7\nCrapped out; shooter loses\n\nYou have $1440.00; computer has $-440.00.\nWould you like to play again? (y or n):  <strong>n</strong>\n\nFinal game statistics\n\n        Total amount bet        Total amount won        Final balance\nYou               990.00                 1930.00              1440.00\nComputer          990.00                   50.00              -440.00\n\nSmallest pot of game: $   30.00\nLargest pot of game:  $ 1000.00\nAverage pot value:    $  495.00\n\nThank you for playing\n\nDistribution of dice rolls\n\n 2:    70 ( 3%)  ***\n 3:   120 ( 6%)  ******\n 4:   151 ( 7%)  *******\n 5:   218 (10%)  **********\n 6:   266 (13%)  *************\n 7:   319 (15%)  ***************\n 8:   289 (14%)  **************\n 9:   240 (12%)  ************\n10:   173 ( 8%)  ********\n11:    98 ( 4%)  ****\n12:    56 ( 2%)  **</code></pre>\n<P>\n  <FONT FACE=\"Goudy Old Style\"><B>How to get started:</B>  Read the assignment\nspecification.  Reading it through twice wouldn&#39;t hurt.  </FONT></P>\n<P>\n  <FONT FACE=\"Goudy Old Style\">It is absolutely essential that you work in\n    very small increments.  After each tiny change, run your code to make sure it behaves correctly.  Novice programmers (and even some experienced\n    ones) sometimes fall into this terrible trap:  They add a whole lot of code\n    to their program all at once, then they try to run it, and their code doesn&#39;t\n    even compile correctly.  The debugging job is enormous at that point, because\n    there&#39;s no easy way to tell which part of the code has the error in\n    it.  When you add one tiny portion of code at a time, rerunning\n    after each addition and not adding more until what you have is correct,\n    your overall development time is shorter because you can locate any error\nin the small part of code you most recently added. (For a non-computing-related illustration of how it's better to take small, easy steps rather than trying to bite off a lot at once, everyone should read <a href=\"http://www.newyorker.com/reporting/2007/12/10/071210fa_fact_gawande\">Atul Gawande's article</a> about ICU checklists.)</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\">Keep adding new functionality, small piece\nby small piece, running and testing as you go, until you&#39;ve satisfied\nall the requirements in the assignment specification.  When you have a way\nto approach a task, it&#39;s less daunting.</FONT></P>\n<P>Here's one more hint: As you add functionality, add extra print statements that print out the values of variables that are changing. That way you can see the progress (correct or otherwise) of your computations. Even if you'll remove those statements once you're sure the code works, having them during development is helpful.</P>\n<P>\n  <FONT FACE=\"Goudy Old Style\"><B>What to turn in:</B>  Turn in via Checkmate\n    one Python source code (.py) file containing all your code for the final version you completed.  If you haven&#39;t registered yourself for\n  Checkmate this quarter, do it now; instructions are on the syllabus.  </FONT><FONT FACE=\"Goudy Old Style\">As usual, each pair should submit just one\nsolution, with both partners&#39; names clearly listed at the top of each\nfile.</FONT></P>\n<P>\n  <FONT FACE=\"Goudy Old Style\">Also as usual, every student must fill out\n    a partner evaluation form at eee.uci.edu.  You can get to the partner evaluation for this lab by\n    logging in at eee.uci.edu, choosing MyEEE, and selecting Survey.  Your class\n    participation score will suffer if you neglect to do this.  We have not\n    turned on the Email nagging option for this evaluation; it&#39;s up to you\nto remember to do it within a day or so of the due date.</FONT></P>\n<P>\n  <FONT FACE=\"Helvetica\" SIZE=1>Original concept (and references to the musical <em>Guys and Dolls</em>) by David A. Smallberg. Rewritten by David G. Kay, September 1985. Modified for use in ICS 21 by David G. Kay, October 1990. Revised by Norman Jacobson, Winter 1991. Minor revisions by Norman Jacobson, Fall 1991, by David G. Kay, Winter 1992, by Norman Jacobson, Fall 1992, and by David G. Kay, Winter 1993. Revised for Python and Informatic 42 by David G. Kay, Winter 2012.</FONT>\n</P>\n</BODY>\n</HTML>\n", "encoding": "utf-8"}