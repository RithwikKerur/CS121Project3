{"url": "https://www.ics.uci.edu/~eppstein/261/w18-hw1.html", "content": "<!DOCTYPE html>\n<html>\n<head>\n<title>CompSci 261, Winter 2018, Homework 1</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n</head>\n<body>\n<h1>CompSci 261, Winter 2018, Homework 1</h1>\n<ol>\n<li><p>The dynamic array data structure described in the lectures maintains a block $B$ of memory and a number $L$, the length of the dynamic array.\nIn the lectures, we analyzed it with the potential function $\\Phi=|2L-\\operatorname{sizeof}(B)|$,\nusing an absolute value operation to make sure that the potential function stays non-negative. Instead, in this question, we will make the function non-negative a different way, by choosing $\\Phi=\\max(0,2L-\\operatorname{sizeof}(B))$.</p>\n<ol type=\"a\">\n<li><p>Would this change of potential function affect the analysis of grow operations that replace $B$ by a larger block? Why or why not?</p></li>\n<li><p>Recall that the shrink operation described in class only decreases $L$ by one, without ever replacing $B$. If the new potential function has the value $x$ before a shrink operation, what possible values (as a function of $x$) could the potential function have after the operation?</p></li>\n<li><p>Suppose that we use a shrink operation that replaces $B$ by a shorter block, of length exactly $2L$, whenever $L\\lt\\operatorname{sizeof}(B)/4$.\nWe saw in class that, with the original potential function, this operation takes constant amortized time. Would it still have constant amortized time with the new potential function? Explain why or why not.</p></li>\n</ol>\n<li><p>The dynamic arrays described in class (and as implemented in Python) cannot efficiently remove an item $A[i]$ from the middle of an array $A$.\nInstead, performing this operation while preserving the order of the remaining items requires time proportional to the length of the array to move each element in a position greater than $i$ one position earlier in the array.\nBut suppose that we do not care whether the remaining items stay in the same order, as long as the array contains the same remaining items in some order.\nIn this case, describe how to remove $A[i]$ from an array, using only a constant number of get, set, grow, or shrink operations.</p></li>\n<li><p>Your friend, a bad computer programmer, has implemented a stack data structure badly, so that its pop operation takes $O(n)$ time to perform, when there are $n$ items in the stack. However, your friend's stack implementation only takes $O(1)$ time per push, and it works correctly: it produces the same results as a dynamic array based stack would produce, but takes more time to do it. Describe a potential function $\\Phi$ such that, with your potential function, the times for the two operations of your friend's stack are reversed: it takes $O(1)$ amortized time per pop and $O(n)$ amortized time per push.</p>\n\n<p><i>(Hint: Choose your function to grow quickly as a function of $n$, so that it shrinks quickly on each pop and cancels the actual time of the pop. How quickly can you make it grow while still having only $O(n)$ time per push?)</i></li>\n<li><p>In class we studied a binary counter, for which the times per operation had the sequence\n$$1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,\\dots,$$\nand we showed that the average time per operation was $O(1)$, both by using the potential function method and by averaging these numbers directly. In this sequence, the number at position $i$ (starting from $i=1$) is just one plus the number of zeros in the low-order positions of the binary representation of $i$.\nSuppose instead that we have a new data structure whose times per operation are\n$$1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,1,2,1,4,1,2,1,8,\\dots,$$\nwhere each number $x$ in the first sequence is replaced by $2^{x-1}$.\nBy averaging these numbers directly, give an accurate bound in $O$-notation for the average time per operation of this new data structure, as a function of the total number $n$ of operations performed.</p>\n\n<p><i>(Hint: compute the average by summing the copies of each power of two separately. Among the first $n$ operations, how many copies of each power of two are there? How many different powers of two are there?)</i></p></li>\n</ol>\n</body>\n</html>\n", "encoding": "ascii"}