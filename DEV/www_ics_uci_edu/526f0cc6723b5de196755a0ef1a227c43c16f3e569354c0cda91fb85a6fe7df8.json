{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/07.balbst", "content": "Survey of binary search data structures\n\nGeneral principle:\n    handle insert, delete, successor, predecessor in logarithmic time\n    \"balanced\" tree: each path has length O(log n)\n    each operation modifies items on a single path\n    various mechanisms for forcing tree to stay balanced\n    various additional advantages/disadvantages beyond e.g. treaps\n\tfaster for certain types of operation\n\tstorage space\n\t...\n\ntreap:\n\tdescribed last time\n\tused in LEDA algorithm library\n\tadvantage:\n\t\tsame properties as random-insert model for any seq of ops\n\t\tdata structure state does not depend on history\n\t\taverage access 2 ln n, relatively good\n\t\tconceptually simple \n\tdisadvantages:\n\t\tdeepest path larger (by constant) than other balanced trees\n\t\trandomized\n\nskip list:\n\teach new item flips coin until getting heads\n\t\tmakes array of pointers #flips long\n\tpointer[i] -> sorted singly linked list of items with >= i flips\n\tsearch(x):\n\t\ti = max(#flips)\n\t\tpos = first item with i flips\n\t\twhile i >= 0:\n\t\t\tif x <= pos.array[i]:\n\t\t\t\tpos = pos.array[i]\n\t\t\telse:\n\t\t\t\ti = i - 1\n\texpect O(log n) steps per search\n\n\tadvantage:\n\t\tsimple\n\t\tdata structure state does not depend on history\n\tdisadvantages:\n\t\tvariable size nodes\n\t\trandomized\n\na,b-tree: [CLRS 18]\n\tNOT binary\n\tall items stored at leaves (can also mod to store items internally)\n\teach internal node has a <= #children <= b, b >= 2a-1\n\t\t(so search step at each node more complicated)\n\tinsert:\n\t\tfind place to add\n\t\tif too many children, split and zipper upwards\n\tdelete:\n\t\tremove child, rebalance w/sibling if necessary\n\t# nodes touched by update = O(log_a n)\n\n\t(2,3)-tree: O(log n) per update\n\tadvantage: none?\n\n\tB-tree: node size = memory page, O(log_B n) per update\n\tadvantage: adapts to memory hierarchy\n\nred-black tree: [CLRS 13]\n\tbinary search tree (items stored in both internal nodes and leaves)\n\teach node stores one bit: colored red or black\n\n\troot must be black\n\tany child of a red node must be black\n\tall paths root->null pointer have same # black nodes\n\n\tview as similar to 2-4 tree:\n\t\tgroup red nodes with their parents into single supernode\n\t\t=> height <= 2 log_2 n\n\n\tinsert:\n\t\tdo normal tree insert, color new node x red\n\t\t\t(preserves all-path property, may mess up any child)\n\t\twhile x and parent(x) both red:\n\t\t\tif parent(x) = root:\n\t\t\t\trecolor it black\n\t\t\telse if sibling(parent(x)) red:\n\t\t\t\tflip colors among parent,grandparent,sibling\n\t\t\t\tx = grandparent\n\t\t\telse if x-parent-grandparent zigzags:\n\t\t\t\trotate x-parent\n\t\t\t\tx = old parent (now child of x, no zigzag)\n\t\t\telse:\n\t\t\t\trotate parent->grandparent and swap colors\n\n\tdelete: similar with more cases (read the book)\n\n\tadvantages:\n\t\tlittle extra memory (one bit per node)\n\t\teach insert does at most two rotations\n\t\t\t(useful for persistence, later)\n\nAVL trees:\n\tfirst balanced bst: Adel'son, Velskii, Landis 1962.\n\n\tat each node, heights of subtrees differ by at most one\n\teach node stores two bits: which of left and right is deeper\n\tsimilar case analysis and rotation-based updates as red-black trees\n\n\tadvantages:\n\t\tlittle extra memory\n\t\tmore balanced than red-black:\n\t\t\theight log_phi n instead of 2 log_2 n\n\nBB[alpha]-trees:\n\tat each node, #descendants(child) <= (1-alpha) * #descendants(node)\n\teach node stores #descendants so we can check this condition\n\n\tmax height: log_(1/(1-alpha)) n\n\n\tinsert, delete:\n\t\tperform standard binary search tree ins/del\n\t\tpropagate new #descendants up tree\n\t\tat *highest* unbalanced node,\n\t\t\treplace whole subtree with new complete binary tree\n\n\tamortized analysis:\n\t\tPhi = sum_(nodes) | #left - #right |\n\t\teach ins/del adds O(log n) to Phi\n\t\teach rebuild takes time O(k), reduces Phi by alpha k - O(log n)\n\t\t=> amortized time O(log n)\n\n\tadvantages:\n\t\tcan get height (1+epsilon) log_2 n\n\t\t\tat cost of more frequent rebuilds, slower amort update\n\t\tcan store large complicated data structures at each node,\n\t\t\trebuild them infrequently, not worry about rotate\n\tdisadvantages:\n\t\ttime is amortized instead of worst case\n\nscapegoat trees:\n\tno extra information per node (not even one bit), just tree structure\n\totherwise similar to BB[alpha]-tree\n\tif insert places node too deep,\n\t\tcomputes balance of larger and larger subtrees at ancestors\n\t\tuntil finding non-alpha-balanced subtree\n\t\t\tthen rebuilds that subtree to be balanced\n\t\tsearch time adds in geometric series to rebuild time\n\n\ttime per search worst case O(log n)\n\ttime per update amortized O(log n)\n\nweighted binary trees (e.g. BB[alpha]-trees with total weight instead of #)\n\ttime to insert/del/find item i: O(log W/w_i)\n\tadvantages:\n\t\tcan speed up times for frequently accessed items\n\tdisadvantages:\n\t\tmore complex\n\t\t\nfinger search trees (locality of reference)\n\ttime to insert/del find item i: O(log |pos_i - pos_{i-1}|)\n\tadvantages:\n\t\tlocality of reference in input sequence\n\t\t(e.g. sequential order => linear time)\n\tdisadvantages:\n\t\tmore complex\n\nSplay trees:\n\tnext time\n\tadvantages:\n\t\tmost of above\n\t\tno extra space, weighted w/o change to data struc,\n\t\t\tfinger searches (again w/o change)\n\tdisadvantages:\n\t\tamortized\n", "encoding": "ascii"}