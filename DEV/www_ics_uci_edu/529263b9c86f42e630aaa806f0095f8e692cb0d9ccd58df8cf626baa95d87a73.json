{"url": "https://www.ics.uci.edu/~dan/class/165/notes/bigarrays.html", "content": "<HTML><HEAD>\n<TITLE> Big arrays in C procedures\n</TITLE>\n</HEAD><BODY>\n\n<H2> Big arrays in C procedures </H2>\n\nThere is a not-very-huge number N such that,\nif a procedure declares a local integer array larger than N,\n<!-- 360^2 ?? -->\nyou get a segmentation fault when the procedure is called.&nbsp;\nThe same holds for multiple arrays\nwhose total space is equivalent.&nbsp;\nApparently whatever C\nuses for automatic variables cannot handle this\nmagnitude of array on the stack of procedure calls.&nbsp;\nI would suggest that you use one of the following methods:\n<P>\n<OL>\n<LI> Declare the large arrays as a local variable in one file,\n     and as a global variable in all procedures.&nbsp;\n     This works, but I can see no advantage to it relative to\n     the following two methods.\n<LI> Declare the arrays in the procedures as static.&nbsp;\n     This retains locality of variables, and is quite simple.&nbsp;\n     However, the (excessive) storage remains in existence even when\n     the procedures that use it are not executing.\n<LI> Only declare <tt>(int **)</tt> variables,\n     and use calloc to get the required space when needed,\n     returning it when done.&nbsp;  This retains locality of\n     variables without wasting a large chunk of space when the\n     procedures that use the big arrays are not in use.&nbsp;\n     There is an added bonus in that you can save much space\n     for each array by building triangular arrays,\n     which is not much harder than building square ones when using\n     C's pointer-vector system.\n</OL>\n<P>\n\n<HR>\n<ADDRESS>\n<A HREF=\"http://www.ics.uci.edu/~dan\">\nDan Hirschberg </A> <BR>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3435<BR>\n</ADDRESS>\n<tt>dan (at) ics.uci.edu</tt><br>\nLast modified: Mar 22, 1999\n</BODY></HTML>\n", "encoding": "ascii"}