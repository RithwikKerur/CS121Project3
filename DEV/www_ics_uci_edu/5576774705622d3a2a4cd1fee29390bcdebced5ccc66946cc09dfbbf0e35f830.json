{"url": "https://www.ics.uci.edu/~jmoorkan/vhdlref/vhdl.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head>\n\n\n   <meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n   <meta name=\"GENERATOR\" content=\"Microsoft FrontPage 5.0\">\n   <meta name=\"OPERATOR\" content=\"Victor P Nelson\">\n</head><body>\n\n<h1>\n<a name=\"top\"></a>VHDL MINI-REFERENCE</h1>\n\n<h4>\nSee the VHDL Language Reference Manual (<b>VLRM</b>) for Additional Details</h4>\nThe following Mini-Reference can be divided into the following parts:\n<p>I.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#primary\">Primary Design Unit\nModel Structure</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.&nbsp;&nbsp;&nbsp; <a href=\"#entity\">Entity\nDeclaration Format</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.&nbsp;&nbsp;&nbsp; <a href=\"#architecture\">Architecture</a>\n<br>II.&nbsp;&nbsp;&nbsp; <a href=\"#packages\">Packages</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.&nbsp;&nbsp;&nbsp; <a href=\"#packages\">Declaration\nand Libraries</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.&nbsp;&nbsp;&nbsp; <a href=\"#numbers\">Identifiers,\nNumbers, Strings, and Expressions</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.&nbsp;&nbsp;&nbsp; <a href=\"#data\">Data\nTypes</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D.&nbsp;&nbsp;&nbsp; <a href=\"#objects\">Objects:\nSignals, Constants, and Variables</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E.&nbsp;&nbsp;&nbsp; <a href=\"#concurrent\">Concurrent\nStatements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#concurrent\">Signal\nAssignment</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#process\">Process\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#block\">Block Statement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#procedure\">Procedure\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#instantiation\">Component\nInstantiation</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#assertion\">Concurrent\nAssertion</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#generate\">Generate\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F.&nbsp;&nbsp;&nbsp; <a href=\"#sequential\">Sequential\nStatements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#wait\">Wait Statement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#seq_assign\">Signal\nAssignment</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#var_assign\">Variable\nAssignment</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#procedure_call\">Procedure\nCall</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#conditional\">Conditional\nStatements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#loop\">Loop Statements</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#procedure_syntax\">Procedure\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href=\"#function_syntax\">Function\nStatement</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G.&nbsp;&nbsp;&nbsp; <a href=\"#other_ieee\">Other\nIEEE \"std.logic\" Functions</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; H.&nbsp;&nbsp;&nbsp; <a href=\"#object_attr\">Object\nAttributes</a>\n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I.&nbsp;&nbsp;&nbsp;&nbsp;\n<a href=\"#textio\">The TEXTIO Package</a>\n</p><h1>\n<a name=\"primary\"></a>PRIMARY DESIGN UNIT MODEL STRUCTURE - <a href=\"#top\">Back\nTo Top</a></h1>\nEach VHDL design unit comprises an \"entity\" declaration and one or more\n\"architectures\". Each architecture defines a different implementation or\nmodel of a given design unit. The entity definition defines the inputs\nto, and outputs from the module, and any \"generic\" parameters used by the\ndifferent implementations of the module.\n<h2>\n<a name=\"entity\"></a>Entity Declaration Format - <a href=\"#top\">Back To\nTop</a></h2>\n\n<pre>&nbsp;&nbsp;&nbsp; <b>entity</b>&nbsp; name&nbsp; <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>port(</b> port definition list <b>);</b>-- input/output signal ports\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>generic(</b> generic list<b>);</b>&nbsp;&nbsp; -- optional generic list\n&nbsp;&nbsp;&nbsp; <b>end</b> name;</pre>\nPort declaration format: <i>port_name: mode data_type;</i>\n<p>The <i>mode</i> of a port defines the directions of the singals on that\npirt, and is one of: <b>in</b>, <b>out</b>, <b>buffer</b>, or\n<b>inout</b>.\n</p><dl>Port Modes:\n<dt>\nAn <b>in</b> port</dt>\n\n<dd>\ncan be read but not updated within the module, carrying information into\nthe module. (An in port cannot appear on the left hand side of a signal\nassignment.)</dd>\n\n<dt>\nAn <b>out</b> port</dt>\n\n<dd>\ncan be updated but not read within the module, carrying information out\nof the module. (An out port cannot appear on the right hand side of a signal\nassigment.)</dd>\n\n<dt>\nA <b>buffer</b> port</dt>\n\n<dd>\nlikewise carries information out of a module, but can be both updated and\nread within the module.</dd>\n\n<dt>\nAn <b>inout</b> port</dt>\n\n<dd>\nis bidirectional and can be both read and updated, with multiple update\nsources possible.</dd>\n</dl>\n\n<li>\nNOTE: A buffer is strictly an output port, i.e. can only be driven from\nwithin the module, while inout is truly bidirectional with drivers both\nwithin and external to the module.</li>\n\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; entity counter is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port (Incr, Load, Clock: in&nbsp;&nbsp;&nbsp;&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Carry:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&nbsp;&nbsp;&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data_Out:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer bit_vector(7 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data_In:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp;&nbsp;&nbsp;&nbsp; bit_vector(7 downto 0));\n&nbsp;&nbsp; end counter;</pre>\n<b>Generics</b> allow static information to be communicated to a block\nfrom its environment for all architectures of a design unit. These include\ntiming information (setup, hold, delay times), part sizes, and other parameters.\n<h4>\n<b>Example</b></h4>\n\n<pre>&nbsp;&nbsp;&nbsp; entity and_gate is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(a,b: in&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c:&nbsp;&nbsp; out bit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generic (gate_delay: time := 5ns);\n&nbsp;&nbsp;&nbsp; end and_gate;</pre>\n\n<h2>\n<a name=\"architecture\"></a>Architecture - <a href=\"#top\">Back To Top</a></h2>\nAn architecture defines one particular implementation of a design unit,\nat some desired level of abstraction.\n<pre>&nbsp; <b>architecture</b> arch_name <b>of</b> entity_name <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp; declarations ...\n&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp; concurrent statements&nbsp; ...\n&nbsp;&nbsp; end</pre>\n<i>Declarations</i> include data types, constants, signals, files, components,\nattributes, subprograms, and other information to be used in the implementation\ndescription. <i>Concurrent statements</i> describe a design unit at one\nor more levels of modeling abstraction, including dataflow, structure,\nand/or behavior.\n<ul>\n<li>\n<b>Behavioral Model:</b> No structure or technology implied. Usually written\nin sequential, procedural style.</li>\n\n<li>\n<b>Dataflow Model:</b> All datapaths shown, plus all control signals.</li>\n\n<li>\n<b>Structural Model:</b> Interconnection of components.</li>\n</ul>\n\n<h1>\n<a name=\"packages\"></a>VHDL PACKAGES - <a href=\"#top\">Back To Top</a></h1>\nA VHDL <i>package</i> contains subprograms, constant definitions, and/or\ntype definitions to be used throughout one or more design units. Each package\ncomprises a \"declaration section\", in which the available (i.e. exportable)\nsubprograms, constants, and types are declared, and a \"package body\", in\nwhich the subprogram implementations are defined, along with any internally-used\nconstants and types. The declaration section represents the portion of\nthe package that is \"visible\" to the user of that package. The actual implementations\nof subroutines in the package are typically not of interest to the users\nof those subroutines.\n<h3>\nPackage declaration format:</h3>\n\n<pre>&nbsp;&nbsp; <b>package</b> package_name <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp; ... exported constant declarations\n&nbsp;&nbsp;&nbsp;&nbsp; ... exported type declarations\n&nbsp;&nbsp;&nbsp;&nbsp; ... exported subprogram declarations\n&nbsp;&nbsp; <b>end</b> package_name;</pre>\n\n<h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; package ee530 is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant maxint: integer := 16#ffff#;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type arith_mode_type is (signed, unsigned);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function minimum(constant a,b: in integer) return integer;\n&nbsp;&nbsp;&nbsp; end ee530;</pre>\n\n<h3>\nPackage body format:</h3>\n\n<pre>&nbsp;&nbsp; <b>package body</b> package_name <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... exported subprogram bodies\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... other internally-used declarations\n&nbsp;&nbsp; <b>end</b> package_name;</pre>\n\n<h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp; package body ee530 is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function minimum (constant a,b: integer) return integer is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable c: integer; -- local variable\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if a &lt; b then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c := a;&nbsp; -- a is min\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c := b;&nbsp; -- b is min\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c;&nbsp; -- return min value\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;\n&nbsp;&nbsp;&nbsp; end ee530;</pre>\n\n<h3>\nPackage Visibility</h3>\nTo make all items of a package \"visible\" to a design unit, precede the\ndesired design unit with a \"use\" statement:\n<h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp; <b>use</b> library_name.package_name.all</pre>\nA \"use\" statement may precede the declaration of any entity or architecture\nwhich is to utilize items from the package. If the \"use\" statement precedes\nthe entity declaration, the package is also visible to the architecture.\n<h3>\nUser-Developed Packages</h3>\nCompile user-developed packages in your current working library. To make\nit visible:\n<pre>&nbsp;&nbsp;&nbsp; <b>use</b> package_name<b>.all;</b></pre>\nNote: '<b>std</b>' and '<b>work</b>' (your current working library) are\nthe two default libraries. The VHDL 'library' statement is needed to make\nthe 'ieee' library and/or additional libraries visible.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; <b>library</b> lib_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- make library visible\n&nbsp;&nbsp; <b>use</b> lib_name.pkg_name.all;&nbsp;&nbsp; -- make package visible</pre>\n\n<h3>\nVHDL Standard Packages</h3>\n\n<ul>STANDARD - basic type declarations (always visible by default)\n<br>TEXTIO - ASCII input/output data types and subprograms</ul>\nTo make TEXTIO visible: <b>use</b> std.textio.all;\n<h3>\nIEEE Standard 1164 Package</h3>\nThis package contained in the 'ieee' library supports multi-valued logic\nsignals with type declarations and functions. To make visible:\n<pre>&nbsp;&nbsp; <b>library ieee;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- VHDL Library stmt\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>use</b> <b>ieee.</b>std_logic_1164<b>.all;</b></pre>\n\n<h3>\nSpecial 12-valued data types/functions to interface with QuickSim II and\nschematic diagrams.</h3>\n\n<pre>&nbsp;&nbsp; library mgc_portable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Special Mentor Graphics Library\n&nbsp;&nbsp; use mgc_portable.qsim_logic.all; -- Quicksim portable data types</pre>\n\n<h2>\n<a name=\"numbers\"></a>VHDL IDENTIFIERS, NUMBERS, STRINGS, AND EXPRESSIONS\n- <a href=\"#top\">Back To Top</a></h2>\n\n<h3>\nIdentifiers</h3>\nIdentifiers in VHDL must begin with a letter, and may comprise any combination\nof letters, digits, and underscores. Note that VHDL internally converts\nall characters to UPPER CASE.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp; Memory1, Adder_Module, Bus_16_Bit</pre>\n\n<h3>\nNumeric Constants</h3>\nNumeric contants can be defined, and can be of any base (default is decimal).\nNumbers may include embedded underscores to improve readability.\n<p>Format: <b>base#digits#</b> -- base must be a decimal number\n</p><h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp; 16#9fba#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hexadecimal)\n&nbsp;&nbsp;&nbsp;&nbsp; 2#1111_1101_1011#&nbsp; (binary)\n&nbsp;&nbsp;&nbsp;&nbsp; 16#f.1f#E+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (floating-point, exponent is decimal)\n\n</pre>\n\n<h3>\nBit String Literals</h3>\nBit vector constants are are specified as literal strings.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp; x\"ffe\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (12-bit hexadecimal value)\n&nbsp;&nbsp;&nbsp;&nbsp; o\"777\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (9-bit octal value)\n&nbsp;&nbsp;&nbsp;&nbsp; b\"1111_1101_1101\" (12-bit binary value)</pre>\n\n<h3>\nArithmetic and Logical Expressions</h3>\nExpressions in VHDL are similar to those of most high-level languages.\nData elements must be of the type, or subtypes of the same base type. Operators\ninclude the following:\n<ul>\n<li>\nLogical: <b>and</b>, <b>or</b>, <b>nand</b>, <b>nor</b>,\n<b>xor</b>, <b>not</b>\n(for boolean or bit ops)</li>\n\n<li>\nRelational: =, /=, &lt;, &lt;=, &gt;, &gt;=</li>\n\n<li>\nArithmetic: +, -, *, /, mod, rem, **, abs</li>\n\n<br>(a mod b takes sign of b, a rem b takes sign of a)\n<li>\nConcatenate: <b>&amp;</b></li>\n\n<br>(ex. a &amp; b makes one array)</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; a &lt;= b nand c;\n&nbsp;&nbsp; d := g1 * g2 / 3;\n&nbsp;&nbsp; Bus_16 &lt;= Bus1_8 &amp; Bus2_8;</pre>\n\n<h2>\n<a name=\"data\"></a>VHDL DATA TYPES - <a href=\"#top\">Back To Top</a></h2>\nEach VHDL objects must be classified as being of a specific data type.\nVHDL includes a number of predefined data types, and allows users to define\ncustom data types as needed.\n<h3>\nPredefined Scalar Data Types (single objects)</h3>\n\n<h4>\nVHDL Standard:</h4>\n\n<ul>\n<li>\n<b>bit</b> values: '0', '1'</li>\n\n<li>\n<b>boolean</b> values: TRUE, FALSE</li>\n\n<li>\n<b>integer</b> values: -(231) to +(231 - 1) {SUN Limit}</li>\n\n<li>\n<b>natural</b> values: 0 to integer'high (subtype of integer)</li>\n\n<li>\n<b>positive</b> values: 1 to integer'high (subtype of integer)</li>\n\n<li>\n<b>character</b> values: ASCII characters (eg. 'A')</li>\n\n<li>\n<b>time</b> values include units (eg. 10ns, 20us)</li>\n</ul>\n\n<h4>\nIEEE Standard 1164 (package ieee.std_logic_1164.all)</h4>\n\n<ul>\n<li>\n<b>std_ulogic</b> values: 'U','X','1','0','Z','W','H','L','-'</li>\n\n<ul>'U' = uninitialized\n<br>'X' = unknown\n<br>'W' = weak 'X'\n<br>'Z' = floating\n<br>'H'/'L' = weak '1'/'0'\n<br>'-' = don't care</ul>\n\n<li>\n<b>std_logic</b> resolved \"std_ulogic\" values</li>\n\n<li>\n<b>X01</b> subtype {'X','0','1'} of std_ulogic</li>\n\n<li>\n<b>X01Z</b> subtype {'X','0','1','Z'} of std_ulogic</li>\n\n<li>\n<b>UX01</b> subtype {'U','X','0','1'} of std_ulogic</li>\n\n<li>\n<b>UX01Z</b> subtype {'U','X','0','1','Z'} of std_ulogic</li>\n</ul>\n\n<h3>\nPredefined VHDL Aggregate Data Types</h3>\n\n<ul>\n<li>\n<b>bit_vector</b> array (natural range &lt;&gt;) of bit</li>\n\n<li>\n<b>string</b> array (natural range &lt;&gt;) of char</li>\n\n<li>\n<b>text</b> file of \"string\"</li>\n</ul>\n\n<h3>\nIEEE Standard 1164 Aggregate Data Types</h3>\n(From package: <i>ieee.std_logic_1164.all</i>)\n<ul>\n<li>\n<b>std_ulogic_vector</b> array (natural range &lt;&gt;) of std_ulogic</li>\n\n<li>\n<b>std_logic_vector</b> array (natural range &lt;&gt;) of std_logic</li>\n</ul>\n\n<h4>\n<b>Examples</b></h4>\n\n<pre>&nbsp;&nbsp;&nbsp; signal dbus: bit_vector(15 downto 0);\n&nbsp;&nbsp;&nbsp; dbus (7 downto 4) &lt;= \"0000\"; (4-bit slice of dbus)\n&nbsp;&nbsp;&nbsp; signal cnt:&nbsp; std_ulogic_vector(1 to 3);\n&nbsp;&nbsp;&nbsp; variable message: string(0 to 20);</pre>\n\n<h3>\nUser-Defined Enumeration Types</h3>\nAn enumerated data type can be created by explicitely listing all possible\nvalues.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; type opcodes is (add, sub, jump, call);&nbsp; -- Type with 4 values\n&nbsp;&nbsp; signal instruc: opcodes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Signal of this type\n&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; if instruc = add then&nbsp;&nbsp; -- test for value 'add'\n&nbsp;&nbsp;&nbsp;&nbsp; ...</pre>\n\n<h3>\nOther user-defined types</h3>\nCustom data types can include arrays, constrained and unconstrained, and\nrecord structures.\n<ul>\n<li>\n<i>Constrained array:</i> Upper and lower indexes are specified.</li>\n\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; <b>type</b> word <b>is</b> <b>array</b> (0 to 15) <b>of</b> bit;</pre>\n\n<li>\n<i>Unconstrained array:</i> Indexes are specified when a signal or variable\nof that type is declared.</li>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; <b>type</b> memory <b>is</b> array (integer range &lt;&gt;) of bit_vector(0 to 7);\n&nbsp; -- a type which is an arbitrary-sized array of 8-bit vectors\n&nbsp;&nbsp; <b>variable</b> memory256: memory(0 to 255); -- a 256-byte memory array\n&nbsp;&nbsp; <b>variable</b> stack: memory(15 downto 0);&nbsp; -- a 16-byte memory array</pre>\n\n<li>\n<i>Subtype:</i> A selected subset of values of a given type. Elements of\ndifferent subtypes having the same base type may be combined in expressions\n(elements of different types cannot). Subtypes can be used to detect out-of-range\nvalues during simulation.</li>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; <b>subtype</b> byte_signed <b>is</b> integer <b>range</b> -128 to 127;\n&nbsp;&nbsp; <b>subtype</b> byte_unsigned <b>is</b> integer <b>range</b> 0 to 255;</pre>\n</ul>\n\n<h3>\nAliases</h3>\nAn alias\" defines an alternate name for a signal or part of a signal. Aliases\nare often used to refer to selected slices of a bit_vector.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; signal instruction: bit_vector(31 downto 0);\n&nbsp;&nbsp; alias opcode: bit_vector(6 downto 0) is instruction(31 downto 25);\n&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp; opcode &lt;= \"1010101\";&nbsp; -- Set the opcode part of an instruction code</pre>\n&nbsp;\n<h2>\n<a name=\"objects\"></a>VHDL OBJECTS: CONSTANTS, VARIABLES, AND SIGNALS -\n<a href=\"#top\">Back\nTo Top</a></h2>\n\n<h3>\nConstants</h3>\nA <i>constant</i> associates a value to a symbol of a given data type.\nThe use of constants may improve the readability of VHDL code and reduce\nthe likelihood of making errors. The declaration syntax is:\n<ul><b>constant</b> symbol: type := value;</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp; <b>constant</b>&nbsp; Vcc:&nbsp; signal:= '1';&nbsp;&nbsp; --logic 1 constant\n&nbsp; <b>constant</b>&nbsp; zero4: bit_vector(0 to 3) := ('0','0','0','0');</pre>\n\n<h3>\nVariables</h3>\nA <i>variable</i> is declared within a blocks, process, procedure, or function,\nand is updated immediately when an assignment statement is executed. A\nvariable can be of any scalar or aggregate data type, and is utilized primarily\nin behavioral descriptions. It can optionally be assigned initial values\n(done only once prior to simulation). The declaration syntax is:\n<ul><b>variable</b> symbol: type [:= initial_value];</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp; process\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable count: integer&nbsp; := 0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable rega: bit_vector(7 downto 0);\n&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count := 7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- assign values to variables\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rega&nbsp; := x\"01\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp; end;</pre>\n\n<h3>\nSignals</h3>\nA <i>signal</i> is an object with a history of values (related to \"event\"\ntimes, i.e. times at which the signal value changes).\n<p>Signals are declared via signal declaration statements or entity port\ndefinitions, and may be of any data type. The declaration syntax is:\n</p><ul><b>signal</b> sig_name: data_type [:=initial_value];</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; signal clock: bit;\n&nbsp;&nbsp;&nbsp; signal GND:&nbsp;&nbsp; bit := '0';\n&nbsp;&nbsp;&nbsp; signal databus: std_ulogic_vector(15 downto 0);\n&nbsp;&nbsp;&nbsp; signal addrbus: std_logic_vector(0 to 31);</pre>\nEach signal has one or more \"drivers\" which determine the value and timing\nof changes to the signal. Each driver is a queue of events which indicate\nwhen and to what value a signal is to be changed. Each signal assignment\nresults in the corresponding event queue being modified to schedule the\nnew event.\n<blockquote>\n<li>\nsignal line x</li>\n\n<p><br>10ns '0' Driver of\n</p><p>20ns '1' signal x\n</p><li>\nEvent Values</li>\n\n<li>\nTimes</li>\n</blockquote>\nNOTE: If no delay is specified, the signal event is scheduled for one infinitessimally-small\n\"delta\" delay from the current time. The signal change will occur in the\nnext simulation cycle.\n<h4>\nExamples</h4>\n(Assume current time is T)\n<pre>&nbsp;&nbsp;&nbsp; clock&nbsp;&nbsp; &lt;= not clock after 10ns;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- change at T + 10ns\n&nbsp;&nbsp;&nbsp; databus &lt;= mem1 and mem2 after delay; -- change at T + delay\n&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= '1';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- change to '1' at time T + \"delta\";</pre>\nElement delay models may be specified as either \"inertial\" or \"transport\".\nInertial delay is the default, and should be used in most cases.\n<ul>\n<li>\n<b>Inertial delay:</b> The addition to an event queue of an event scheduled\nat time T automatically cancels any events in the queue scheduled to occur\nprior to time T, i.e. any event shorter than the delay time is suppressed.</li>\n\n<li>\n<b>Transport delay</b>: Each new event is simply inserted into the event\nqueue, i.e. behavior is that of a delay line. The keyword <b>transport</b>\nis used to indicate transport delays.</li>\n</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; B &lt;= A after 5ns;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- inertial delay\n&nbsp;&nbsp;&nbsp; C &lt;= transport A after 5 ns; -- transport delay</pre>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5______15 17_________30\n&nbsp;&nbsp;&nbsp; A _______|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_____________&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ____________________\n&nbsp;&nbsp;&nbsp; B ___________|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_________ (Inertial Delay)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _______&nbsp;&nbsp; __________\n&nbsp;&nbsp;&nbsp; C ___________|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_________ (Transport Delay)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20 22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35</pre>\nWhere there are multiple drivers for one signal, a \"resolution function\"\nmust be provided to determine the value to be assigned to the signal from\nthe values supplied by the multiple drivers. This allows simulation of\nbuses with multiple sources/drivers.\n<p>NOTE: The <i>std_logic</i> and <i>std_logic_vector</i> types from the\nieee library have predefined resolution functions:\n</p><h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; signal data_line: std_logic;\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block1:&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_line &lt;= '1';&nbsp;&nbsp;&nbsp;&nbsp; -- one driver\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block2:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_line &lt;= 'Z';&nbsp; -- 2nd driver</pre>\nThe resolved value is '1' since '1' overrides a 'Z' (floating) value. If\nthe two values had been '1' and '0', the resolved value would have been\n'X', indicating an unknown result.\n<h2>\n<a name=\"concurrent\"></a>CONCURRENT STATEMENTS - <a href=\"#top\">Back To\nTop</a></h2>\nConcurrent statements are included within architecture definitions and\nwithin \"block\" statements, representing concurrent behavior within the\nmodelled design unit. These statements are executed in an asynchronous\nmanner, with no defined order, modeling the behavior of independent hardware\nelements within a system.\n<h3>\nConcurrent Signal Assignment</h3>\nA signal assignment statement represents a process that assigns values\nto signals. It has three basic formats.\n<ol>\n<li>\nA &lt;= B;&nbsp;<l1>A &lt;= B when condition1 elseC <b>when</b> condition2\n<b>else</b>\nD <b>when</b> condition3 <b>else</b> E;</l1></li>\n\n<li>\n<b>with</b> expression <b>select</b> A <b>&lt;=</b> B <b>when</b> choice1,\nC <b>when</b> choice2, D <b>when</b> choice3, E when others;</li>\n</ol>\nFor each of the above, waveforms (time-value pairs) can also be specified.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; A &lt;= B after 10ns when condition1 else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C after 12ns when condition2 else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D after 11ns;\n\n&nbsp;&nbsp;&nbsp; -- 4-input multiplexer (Choice is a 2-bit vector)\n&nbsp;&nbsp;&nbsp; with Choice select&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Out &lt;=&nbsp; In0 after 2ns when \"00\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In1 after 2ns when \"01\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In2 after 2ns when \"10\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In3 after 2ns when \"11\";\n\n&nbsp;&nbsp;&nbsp; -- 2-to-4 decoder (Y = 4-bit and A = 2-bit vectors)\n&nbsp;&nbsp;&nbsp; Y &lt;= \"0001\" after 2ns when A = \"00\" else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"0010\" after 2ns when A = \"01\" else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"0100\" after 2ns when A = \"10\" else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"1000\" after 2ns ;\n\n&nbsp;&nbsp;&nbsp; -- Tri-state driver: (Y is logic4; X is bit_vector)\n&nbsp;&nbsp;&nbsp; Y &lt;= '0' after 1ns when En = '1' and X = '0' else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '1' after 1ns when En = '1' and X = '1' else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Z' after 1ns;\n\n&nbsp;&nbsp;&nbsp; -- A is a 16-bit vector\n&nbsp;&nbsp;&nbsp; A &lt;= (others =&gt; '0');&nbsp;&nbsp; -- set all bits of A to '0'</pre>\nThe keyword \"others\" in the last example indicates that all elements of\nA not explicitly listed are to be set to '0'.\n<h3>\n<a name=\"process\"></a>Process Statement - <a href=\"#top\">Back To Top</a></h3>\nAn independent sequential process represents the behavior of some portion\nof a design. The body of a process is a list of sequential statements.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; label: <b>process</b> (sensitivity list)&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... local declarations ...&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequential statements ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>end process</b> label;</pre>\n\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; DFF: process (clock)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if clock = '1' then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q&nbsp; &lt;= D after 5ns;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QN &lt;= not D after 5ns;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end process DFF;</pre>\nThe sequential statements in the process are executed in order, commencing\nwith the beginning of simulation. After the last statement of a process\nhas been executed, the process is repeated from the first statement, and\ncontinues to repeat until suspended. If the optional sensitivity list is\ngiven, a <b>wait on</b> ... statement is inserted after the last sequential\nstatement, causing the process to be suspended at that point until there\nis an event on one of the signals in the list, at which time processing\nresumes with the first statement in the process.\n<h3>\n<a name=\"block\"></a>Block Statement - <a href=\"#top\">Back To Top</a></h3>\nA <i>block</i> is a grouping of related concurrent statements that can\nbe used in representing designs in a hierarchical manner.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp; label: <b>block</b> (guard expression)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... local declarations ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... concurrent statements ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end block label;</pre>\nIf a <i>guard expression</i> is given, \"guarded\" a boolean variable GUARD\nis automatically defined and set to the boolean value of the guard expression.\nGUARD can then be tested within the block, to perform selected signal assignments\nor other statements only when the guard condition evaluates to TRUE.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; -- D Latch: Transfer D input to Q output when Enable = '1'&nbsp;\n&nbsp;&nbsp;&nbsp; block (Enable = '1')\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q &lt;= guarded D after 5ns;\n\n&nbsp;&nbsp;&nbsp; end block;\n\n&nbsp;&nbsp;&nbsp; -- D Flip-flop: Transfer D to Q on falling edge of Clock\n&nbsp;&nbsp;&nbsp; block (Clock'EVENT and Clock = '0')\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q &lt;= guarded D after 5ns;\n&nbsp;&nbsp;&nbsp; end block;\n\n&nbsp;&nbsp;&nbsp; -- Tristate driver with input B and output A&nbsp;\n&nbsp;&nbsp;&nbsp; block (Enable = '1')\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A &lt;= B when GUARD = '1' else 'Z';\n&nbsp;&nbsp;&nbsp; end block;\n\n</pre>\nIn the last example, B is assigned to signal A only when GUARD is true,\nwhich implies Enable = '1'.\n<h3>\n<a name=\"procedure\"></a>Concurrent Procedure Call - <a href=\"#top\">Back\nTo Top</a></h3>\nAn externally defined procedure/subroutine can be invoked, with parameters\npassed to it as necessary. This serves the same function and behaves in\nthe same manner as a \"process\" statement, with any signals in the passed\nparameters forming a sensitivity list.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; ReadMemory (DataIn, DataOut, RW, Clk);\n&nbsp;&nbsp; (where the ReadMemory procedure is defined elsewhere)</pre>\n\n<h3>\n<a name=\"instantiation\"></a>Component instantiation - <a href=\"#top\">Back\nTo Top</a></h3>\nInstantiates (i.e. create instances of) predefined components within a\ndesign architecture. Each such component is first declared in the declaration\nsection of that architecture, and then \"instantiated\" one or more times\nin the body of the architecture.\n<ul>\n<li>\nIn the declaration section: list the \"component declaration\" and one or\nmore \"configuration specifications\".<br>\n<br></li>\n\n<br>The \"component declaration\" defines the component interface, which\ncorresponds to the component's entity declaration. This allows the VHDL\ncompiler to check signal compatibilities.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; component adder\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(a,b:&nbsp; in&nbsp; bit_vector(7 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s:&nbsp;&nbsp;&nbsp; out bit_vector(7 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin:&nbsp; in&nbsp; bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout: out bit);\n&nbsp;&nbsp;&nbsp; end component;</pre>\n\n<li>\nThe \"configuration specification\" identifies specific architecture(s) to\nbe used for each instance of the component. (There may be multiple architectures\nfor a given component.)</li>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; for ALL:&nbsp;&nbsp;&nbsp;&nbsp; comp1 use entity work.comp1 (equations);\n&nbsp;&nbsp;&nbsp; for ADDER1:&nbsp; adder use entity work.adder (equations);\n&nbsp;&nbsp;&nbsp; for ADDER2:&nbsp; adder use entity work.adder (dataflow);</pre>\nIn all three examples, the prefix <b>work.</b> indicates that the current\nworking library contains the indicated component models. In the first example,\narchitecture <i>equations</i> of entity\n<i>comp1</i> is used for all instances\nof <i>comp1</i>. In the other examples, architecture <i>equations</i> is\nto be used for instance <i>ADDER1</i> of component <i>adder</i>, and architecture\n<i>dataflow</i>\nis to be used for instance ADDER2 of component <i>adder</i>.</ul>\n\n<h3>\nComponent Instantiation Each instance of a declared component is listed,\nan instance name assigned, and actual signals connected to its ports as\nfollows:</h3>\n\n<ul>instance_name: component_name <b>port map</b> (port list);</ul>\nThe port list may be in either of two formats:\n<li>\n(1) \"Positional association\": signals are connected to ports in the order\nlisted in the component declaration.</li>\n\n<li>\nEx. A1: adder port map (v,w,x,y,z)</li>\n\n<ul>\n<li>\nv,w, and y must be bit_vectors, y and z bits</li>\n</ul>\n\n<li>\n(2) \"Named association\": each signal-to-port connection is listed explicitly\nas \"signal=&gt;port\".</li>\n\n<h4>\nExample</h4>\nA1: adder port map(a=&gt;v, b=&gt;w, s=&gt;y, cin-&gt;x, cout-&gt;z);\n<p>(The signal ordering is not important in this format)\n</p><h4>\nExample:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; architecture r1 of register is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component jkff\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(J,K,CLK: in bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q,QN:&nbsp;&nbsp;&nbsp; out bit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end component;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ALL: jkff use entity work.jkff (equations);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Use architecture <i>equations</i> of entity jkff\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for all instances\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component dff\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port(D,CLK: in bit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q,QN:&nbsp; out bit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end component;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for DFF1: dff&nbsp; use entity work.dff&nbsp; (equations);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for DFF2: dff&nbsp; use entity work.dff&nbsp; (circuit);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --Use different architectures of <i>dff</i> for instances\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFF1 and DFF2\n&nbsp;&nbsp;&nbsp; begin\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JKFF1: jkff port map (j1,k1,clk,q1,qn1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JKFF2: jkff port map (j2,k1,clk,q2,qn2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFF1:&nbsp; dff&nbsp; port map (d1,clk,q4,qn4);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFF2:&nbsp; dff&nbsp; port map (d2,clk,q5,qn5);\n&nbsp;&nbsp;&nbsp; end.</pre>\n\n<h3>\n<a name=\"assertion\"></a>Concurrent assertion - <a href=\"#top\">Back To Top</a></h3>\nA <i>concurrent assertion statement</i> checks a condition (occurrence\nof an event) and issues a report if the condition is not true. This can\nbe used to check for timing violations, illegal conditions, etc. An optional\nseverity level can be reported to indicate the nature of the detected condition.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; <b>assert</b>&nbsp; (clear /= '1') or (preset /= '1')\n&nbsp;&nbsp;&nbsp; <b>report</b> \"Both preset and clear are set!\"\n&nbsp;&nbsp;&nbsp; <b>severity warning;</b></pre>\n\n<h3>\n<a name=\"generate\"></a>Generate statement - <a href=\"#top\">Back To Top</a></h3>\nA <i>generate statement</i> is an iterative or conditional elaboration\nof a portion of a description. This provides a compact way to represent\nwhat would ordinarily be a group of statements.\n<h4>\nExample</h4>\nGenerate a 4-bit full adder from 1-bit full_adder stages:\n<pre>&nbsp; add_label:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Note that a label is required here\n&nbsp;&nbsp;&nbsp; for i in 4 downto 1 generate\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FA: full_adder port map(C(i-1), A(i), B(i), C(i), Sum(i));\n&nbsp;&nbsp;&nbsp; end generate;</pre>\n\n<pre>The resulting code would look like:\n\n&nbsp;&nbsp;&nbsp; FA4: full_adder port map(C(3), A(4), B(4), C(4), Sum(4));\n&nbsp;&nbsp;&nbsp; FA3: full_adder port map(C(2), A(3), B(3), C(3), Sum(3));\n&nbsp;&nbsp;&nbsp; FA2: full_adder port map(C(1), A(2), B(2), C(2), Sum(2));\n&nbsp;&nbsp;&nbsp; FA1: full_adder port map(C(0), A(1), B(1), C(1), Sum(1));</pre>\n\n<h2>\n<a name=\"sequential\"></a>SEQUENTIAL STATEMENTS - <a href=\"#top\">Back To\nTop</a></h2>\nSequential statements are used to define algorithms to express the behavior\nof a design entity. These statements appear in process statements and in\nsubprograms (procedures and functions).\n<h3>\n<a name=\"wait\"></a>Wait statement - <a href=\"#top\">Back To Top</a></h3>\n- suspends process/subprogram execution until a signal changes, a condition\nbecomes true, or a defined time period has elapsed. Combinations of these\ncan also be used.\n<h4>\nSyntax:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; <b>wait</b> [<b>on</b> signal_name {,signal_name}]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<b>until</b> condition]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<b>for</b> time expression]</pre>\n\n<h4>\nExample</h4>\nSuspend execution until one of the two conditions becomes true, or for\n25ns, whichever occurs first.\n<pre>&nbsp;&nbsp;&nbsp; wait until clock = '1' or enable /='1' for 25ns;</pre>\n\n<h3>\n<a name=\"seq_assign\"></a>Signal assignment statement - <a href=\"#top\">Back\nTo Top</a></h3>\nAssign a waveform to one signal driver (edit the event queue).\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; A &lt;= B after 10ns;\n&nbsp;&nbsp;&nbsp; C &lt;= A after 10ns;&nbsp; -- value of C is current A value</pre>\n\n<h3>\n<a name=\"var_assign\"></a>Variable assignment statement - <a href=\"#top\">Back\nTo Top</a></h3>\nUpdate a process/procedure/function variable with an expression. The update\ntakes affect immediately.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; A := B and C;\n&nbsp;&nbsp;&nbsp; D := A;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- value of D is new A value</pre>\n\n<h3>\n<a name=\"procedure_call\"></a>Procedure call - <a href=\"#top\">Back To Top</a></h3>\nInvoke an externally-defined subprogram in the same manner as a concurrent\nprocedure call.\n<h3>\n<a name=\"conditional\"></a>Conditional Statements - <a href=\"#top\">Back\nTo Top</a></h3>\nStandard <i>if..then</i> and <i>case</i> constructs can be used for selective\noperations.\n<pre>&nbsp;&nbsp;&nbsp; <b>if</b> condition <b>then\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements...&nbsp;\n&nbsp;&nbsp;&nbsp; <b>elsif</b> condition <b>then\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements...\n&nbsp;&nbsp;&nbsp; <b>else</b>&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements...\n&nbsp;&nbsp;&nbsp; <b>end if;</b></pre>\nNOTE: <i>elsif</i> and <i>else</i> clauses are optional.\n<pre>&nbsp;&nbsp;&nbsp; <b>case</b> expression <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>when</b> choices <b>=&gt;</b> sequence of statements\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>when</b> choices <b>=&gt;</b> sequence of statements\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>when others</b> <b>=&gt;</b> sequence of statements\n&nbsp;&nbsp;&nbsp; <b>end case;</b></pre>\nNOTE: <i>case</i> choices can be expressions or ranges.\n<h3>\n<a name=\"loop\"></a>Loop statements - <a href=\"#top\">Back To Top</a></h3>\nSequences of statements can be repeated some number of times under the\ncontrol of <b>while</b> or <b>for</b> constructs.\n<pre>&nbsp;label: <b>while</b> condition <b>loop\n</b>&nbsp;&nbsp;&nbsp; ... sequence of statements ...\n&nbsp;&nbsp;&nbsp; <b>end loop</b> label;</pre>\n\n<pre>&nbsp;label:&nbsp; <b>for</b> loop_variable <b>in</b> range <b>loop\n</b>&nbsp; ... sequence of statements...\n&nbsp;&nbsp; <b>end loop</b> label;</pre>\nNOTE: the label is optional.\n<p><b>Loop termination statements</b> - allow termination of one iteration,\nloop, or procedure.\n</p><p><b>next</b> <b>[when</b> condition<b>];</b> -- end current loop iteration\n</p><p><b>exit [when</b> condition<b>];</b> -- exit innermost loop entirely\n</p><p><b>return</b> expression; -- exit from subprogram\n</p><p>NOTES: 1. The next/exit condition clause is optional.\n</p><p>2. The return expression is used for functions.\n</p><li>\n8. <b>Sequential assertion</b> - same format as a concurrent assertion.</li>\n\n<h3>\n<a name=\"procedure_syntax\"></a>PROCEDURES - <a href=\"#top\">Back To Top</a></h3>\nA <i>procedure</i> is a subprogram that is passed parameters and may return\nvalues via a parameter list.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; <b>procedure</b>&nbsp; proc_name (signal clk: in vlbit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constant d: in vlbit;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal data: out vlbit) <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... local variable declarations ...\n&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... sequence of statements ...\n&nbsp;&nbsp; <b>end</b> proc_name;</pre>\nProcedure call: proc_name(clk1, d1, dout);\n<h3>\n<a name=\"function_syntax\"></a>FUNCTIONS - <a href=\"#top\">Back To Top</a></h3>\nA <i>function</i> is a subprogram that is passed parameters and returns\na single value. Unlike procedures, functions are primarily used in expressions.\n<h4>\nExample</h4>\n\n<pre>&nbsp;&nbsp; -- Convert bit_vector to IEEE std_logic_vector format\n&nbsp;&nbsp; -- (attributes LENGTH and RANGE are described below)\n&nbsp;&nbsp; <b>function</b> bv2slv (b:bit_vector) <b>return</b> std_logic_vector <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable result: std_logic_vector(b'LENGTH-1 downto 0);\n&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in result'RANGE loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case b(i) is\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when '0' =&gt; result(i) := '0';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when '1' =&gt; result(i) := '1';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end case;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end loop;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;\n&nbsp;&nbsp; <b>end;</b></pre>\n\n<pre>&nbsp;&nbsp; -- Convert bit_vector to unsigned (natural) value&nbsp;\n&nbsp;&nbsp; <b>function</b> b2n (B: bit_vector) <b>return</b> Natural <b>is\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable S: bit_vector(B'Length - 1 downto 0) := B;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable N: Natural := 0;\n&nbsp;&nbsp; <b>begin\n</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in S'Right to S'Left loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if S(i) = '1' then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N := N + (2**i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end loop;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return N;\n&nbsp;&nbsp; <b>end;</b></pre>\n\n<h4>\nFunction Calls:</h4>\n\n<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal databus:&nbsp; vector4(15 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal internal: bit_vector (15 downto 0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable x: integer;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; databus &lt;= bv2slv (internal);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x := b2n(internal);</pre>\nData conversion between ieee types and bit/bit_vector (functions in \"ieee.std_logic_1164\")\n<ul><b>To_bit(sul)</b> - from std_ulogic to bit\n<br><b>To_bitvector(sulv)</b> - from std_ulogic_vector/std_logic_vector\n<br><b>To_StdULogic(b)</b> - from bit to std_ulogic\n<br><b>To_StdLogicVector(bv)</b> - from bit_vector or std_ulogic_vector\n<br><b>To_StdULogicVector(bv)</b>- from bit_vector or std_logic_vector\n<br><b>To_X01(v)</b> - from bit, std_ulogic, or std_logic to X01\n<br><b>To_X01Z(v)</b> - from bit, std_ulogic, or std_logic to X01Z\n<br><b>To_UX01(v)</b> - from bit, std_ulogic, or std_logic to UX01</ul>\n\n<h3>\n<a name=\"other_ieee\"></a>Other \"ieee.std_logic_1164\" functions - <a href=\"#top\">Back\nTo Top</a></h3>\n\n<ul><b>rising_edge(s)</b> - true if rising edge on signal s (std_ulogic)\n<br><b>falling_edge(s)</b> - true if falling edge on signal s (std_ulogic)</ul>\nAdditional Mentor Graphics-supplied functions for elements of types Bit_vector\n(implemented as overloaded operator definitions):\n<ul><b>library mgc_portable;</b>\n<br><b>use mgc_portable.qsim_logic.ALL;</b></ul>\nArithmetic between bit_vectors: use normal binary operator tokens\n<p>a + b, a - b, a * b, a / b, a mod b, a rem b\n</p><p>Logical operations between all signal types and vectors of signal types\nin the \"ieee\" library.\n</p><p><b>and, or, nand, nor, xor, xnor, not</b>\n</p><p>Shift/rotate left/right logical/arithmetic operators:\n</p><p><b>sll, srl, sra, rll, rrl</b>\n</p><p>Ex. a := x sll 2; -- \"shift left logical\" bit_vector x by 2 bits\n</p><p>Relational operations: <b>=,/=,&lt;,&gt;,&lt;=,&gt;=</b>\n</p><p>Type conversion:\n</p><ul><b>to_bit</b> (from integer)\n<br><b>to_integer</b> (from bit_vector)</ul>\n\n<h2>\n<a name=\"object_attr\"></a>OBJECT ATTRIBUTES - <a href=\"#top\">Back To Top</a></h2>\nAn <i>object attribute </i>returns information about a signal or data type.\n<h3>\nSignal Condition Attributes (for a signal S)</h3>\n\n<ul><b>S'DELAYED(T)</b> - value of S delayed by T time units\n<br><b>S'STABLE(T)</b> - true if no event on S over last T time units\n<br><b>S'QUIET(T)</b> - true if S quiet for T time units\n<br><b>S'LAST_VALUE</b> - value of S prior to latest change\n<br><b>S'LAST_EVENT</b> - time at which S last changed\n<br><b>S'LAST_ACTIVE</b> - time at which S last active\n<br><b>S'EVENT</b> - true if an event has occurred on S in current cycle\n<br><b>S'ACTIVE</b> - true if signal S is active in the current cycle\n<br><b>S'TRANSACTION</b> - bit value which toggles each time signal S changes</ul>\n\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; if (clock'STABLE(0ns)) then&nbsp; -- change in clock?\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- action if no clock edge\n&nbsp;&nbsp;&nbsp; else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- action on edge of clock\n&nbsp;&nbsp;&nbsp; end if;</pre>\n\n<pre>&nbsp;&nbsp;&nbsp; if clock'EVENT and clock = '1' then\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Q &lt;= D after 5ns;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- set Q to D on rising edge of clock\n&nbsp;&nbsp;&nbsp; end if;</pre>\n\n<h3>\nData Type Bounds (Attributes of data type T)</h3>\n\n<ul><b>T'BASE</b> - base type of T\n<br><b>T'LEFT</b> - left bound of data type T\n<br><b>T'RIGHT</b> - right bound\n<br><b>T'HIGH</b> - upper bound (may differ from left bound)\n<br><b>T'LOW</b> - lower bound</ul>\n\n<h3>\nEnumeration Data Types (Variable/signal x of data type T)</h3>\n\n<ul><b>T'POS(x)</b> - position number of value of x of type T\n<br><b>T'VAL(x)</b> - value of type T whose position number is x\n<br><b>T'SUCC(x)</b> - value of type T whose position is x+1\n<br><b>T'PRED(x)</b> - value of type T whose position is x-1\n<br><b>T'LEFTOF(x)</b> - value of type T whose position is left of x\n<br><b>T'RIGHTOF(x)</b> - value of type T whose position is right of x</ul>\n\n<h3>\nArray Indexes for an Array A (Nth index of array A)</h3>\n\n<ul><b>A'LEFT(N)</b> - left bound of index\n<br><b>A'RIGHT(N)</b> - right bound of index\n<br><b>A'HIGH(N)</b> - upper bound of index\n<br><b>A'LOW(N)</b> - lower bound of index\n<br><b>A'LENGTH(N)</b> - number of values in range of index\n<br><b>A'RANGE(N)</b> - range: A'LEFT to A'RIGHT\n<br><b>A'REVERSE_RANGE(N)</b> - range A'LEFT downto A'RIGHT</ul>\nNOTE: For multi-dimensional array, Nth index must be indicated in the attribute\nspecifier. N may be omitted for a one-dimensional array.\n<h4>\nExamples</h4>\n\n<pre>&nbsp;&nbsp;&nbsp; for i in (data_bus'RANGE) loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...\n&nbsp;&nbsp;&nbsp; for i in (d'LEFT(1) to d'RIGHT(1)) loop\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</pre>\n\n<h3>\nBlock Attributes (of a block B)</h3>\n\n<ul><b>B'BEHAVIOR</b> - true if block B contains no component instantiations\n<br><b>B'STRUCTURE</b> - true if no signal assignment statements in block\nB</ul>\n\n<h2>\n<a name=\"textio\"></a>THE TEXTIO PACKAGE - <a href=\"#top\">Back To Top</a></h2>\n<i>TEXTIO</i> is a package of VHDL functions that read and write text files.\nTo make the package visible:\n<ul><b>use std.textio.all;</b></ul>\n\n<h3>\nData Types:</h3>\n\n<ul><b>text</b> - a file of character strings\n<br><b>line</b> - one string from a text file</ul>\n\n<h4>\nExample Declarations</h4>\n\n<pre>&nbsp;&nbsp; <b>file</b> Prog: <b>text is in</b> \"file_name\"; --text file \"file_name\"\n&nbsp;&nbsp; <b>variable</b> L: <b>line</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- read lines from file to L</pre>\n\n<h3>\nReading Values From a File:</h3>\n\n<dl>\n<dt>\n<b>readline(F, L)</b></dt>\n\n<dd>\nRead one line from \"text\" file F to \"line\" L</dd>\n\n<br>&nbsp;\n<dt>\n<b>read(L, VALUE, GOOD);</b></dt>\n\n<dd>\nRead one value from \"line\" L into variable VALUE</dd>\n\n<ul>\n<li>\nGOOD is TRUE if successful</li>\n\n<li>\nData_type of VALUE can be bit, bit_vector, integer, real, character, string,\nor time.</li>\n</ul>\n</dl>\n\n<h3>\nWriting values to a file:</h3>\n\n<dl>\n<dt>\n<b>writeline(F, L);</b></dt>\n\n<dd>\nWrite one line to \"text\" file F from \"line\" L</dd>\n\n<br>&nbsp;\n<dt>\n<b>write(L, VALUE, JUSTIFY, FIELD);</b></dt>\n\n<dd>\nWrite one value to \"line\" L from variable VALUE</dd>\n\n<ul>\n<li>\nData_type of VALUE can be bit, bit_vector, integer, real, character, string,\nor time.</li>\n\n<li>\nJUSTIFY is \"left\" or \"right\" to justify within the field</li>\n\n<li>\nFIELD is the desired field width of the written value</li>\n\n<br>&nbsp;\n<p>&nbsp;</p></ul>\n</dl>\n&nbsp;<a href=\"#top\">Back To Top</a>\n</body></html>", "encoding": "ascii"}