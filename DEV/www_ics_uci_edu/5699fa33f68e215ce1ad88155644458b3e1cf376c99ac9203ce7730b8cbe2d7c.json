{"url": "https://www.ics.uci.edu/~thornton/cs141/ProjectGuide/Project3/BST.hs", "content": "-- BST.hs\r\n-- CompSci 141 / CSE 141 / Informatics 101 Spring 2013\r\n-- Project #3\r\n--\r\n-- An implementation of a binary search tree in Haskell.  This implementation\r\n-- in functional, meaning that functions like bstAdd don't change an existing\r\n-- tree, but instead return a new tree that is equivalent to the one given\r\n-- except that a new element has been added to it.\r\n\r\nmodule BST where\r\n\r\n\r\n-- This is an algebraic data type.  It says that BST is a new type\r\n-- of data, which comes in two forms: an EmptyBST or a BSTNode,\r\n-- which has four fields, listed not as names but as types (i.e.,\r\n-- what kinds of fields it holds, rather than names for the fields).\r\n-- \r\n-- The \"k v\" that follows \"data BST\" is the Haskell way of specifying\r\n-- a generic type; in other words, we've said that different BSTs can\r\n-- have different kinds of keys and values.  The appearance of k and\r\n-- v in the rest of the data declaration is a way of saying, for\r\n-- example, that the first field of a BSTNode is the same type as the\r\n-- type of key in the BST; the second field is the same as the type\r\n-- of value; and the third and fourth fields are additional BSTs (the\r\n-- left and right subtrees) with the same kind of key and the same kind\r\n-- of value as this one.\r\n--\r\ndata BST k v = EmptyBST\r\n             | BSTNode k v (BST k v) (BST k v)\r\n               deriving (Eq, Show)\r\n\r\n\r\n-- Adds a new key/value pair to a binary search tree.  Note that\r\n-- this function (and the others) restrict the type k to be one\r\n-- that is a member of the type class Ord; this is analogous to\r\n-- what we did in Java when we said BinarySearchTree<K extends\r\n-- Comparable<K>, V>.  This is what allows us to use the <, >,\r\n-- and == operators to compare keys.\r\n--\r\nbstAdd :: Ord k => k -> v -> (BST k v) -> (BST k v)\r\nbstAdd key value EmptyBST                = BSTNode key value EmptyBST EmptyBST\r\nbstAdd key value (BSTNode nk nv nl nr)\r\n\t| key < nk                           = BSTNode nk nv (bstAdd key value nl) nr\r\n\t| key > nk                           = BSTNode nk nv nl (bstAdd key value nr)\r\n\t| key == nk                          = error \"Duplicate key\"\r\n\r\n\r\n\r\n-- Lookups up the value associated with a key.\r\n--\r\nbstLookup :: Ord k => k -> (BST k v) -> v\r\nbstLookup key EmptyBST                   = error \"Key not found\"\r\nbstLookup key (BSTNode nk nv nl nr)\r\n\t| key < nk                           = bstLookup key nl\r\n\t| key > nk                           = bstLookup key nr\r\n\t| key == nk                          = nv\r\n\r\n\r\n-- Removes the given key and its value.\r\n--\r\nbstRemove :: (Eq v, Ord k) => k -> (BST k v) -> (BST k v)\r\nbstRemove key EmptyBST                   = error \"Key not found\"\r\nbstRemove key (BSTNode nk nv nl nr)\r\n\t| key < nk                           = BSTNode nk nv (bstRemove key nl) nr\r\n\t| key > nk                           = BSTNode nk nv nl (bstRemove key nr)\r\n\t| nl == EmptyBST && nr == EmptyBST   = EmptyBST\r\n\t| nl /= EmptyBST && nr == EmptyBST   = nl\r\n\t| nl == EmptyBST && nr /= EmptyBST   = nr\r\n\t| otherwise                          = BSTNode maxkey maxval nlWithoutMax nr\r\n\t\t\twhere (BSTNode maxkey maxval _ _)   = bstFindMax nl\r\n\t\t\t      nlWithoutMax                  = bstRemoveMax nl\r\n\r\n\r\n-- Utilities for use in implementing bstRemove.\r\n\r\nbstFindMax :: (BST k v) -> (BST k v)\r\nbstFindMax (BSTNode nk nv nl EmptyBST)   = BSTNode nk nv nl EmptyBST\r\nbstFindMax (BSTNode nk nv nl nr)         = bstFindMax nr\r\n\r\n\r\nbstRemoveMax :: (BST k v) -> (BST k v)\r\nbstRemoveMax (BSTNode nk nv nl EmptyBST) = nl\r\nbstRemoveMax (BSTNode nk nv nl nr)       = BSTNode nk nv nl (bstRemoveMax nr)\r\n\r\n\r\n\r\n-- *** Add your implementation of bstToList and bstCount below. ***\r\n", "encoding": "ascii"}