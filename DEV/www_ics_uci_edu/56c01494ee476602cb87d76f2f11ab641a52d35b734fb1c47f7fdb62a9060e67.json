{"url": "https://www.ics.uci.edu/~thornton/ics32a/Notes/FileSystems/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32A Fall 2019, Notes and Examples: Files, Paths, and File Systems</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32A Fall 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"../../GradeCalculator\">Grade Calculator</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32A Fall 2019<br />\r\n   Notes and Examples: Files, Paths, and File Systems</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Files and file systems</p>\r\n\r\n<p>So far, the only kind of input our Python programs can accept comes from the keyboard, in response to a call to the built-in <b>input()</b> function.  Of course, that's a nice start, but it feels awfully limiting.  If we think about the programs we actually use, we quickly realize that they take input from sources other than just what we type.  Another source of input that's quite common is to read information from a file system.</p>\r\n\r\n<p class=\"subtitle\">What is a file system?</p>\r\n\r\n<p>If you've ever used a personal computer &mdash; a desktop machine or a laptop, for example &mdash; there's a good chance that you've interacted with a <i>file system</i>, even if you've never heard the term before.  A file system is software that manages how information is stored on a storage device such as a hard drive or a USB stick.  There are a number of different kinds of file systems in use &mdash; sometimes more than one kind on the same operating system! &mdash; but they mostly share the same basic characteristics, while differing mainly in the fine-grained details.  So if you know about those shared characteristics, you'll quickly find yourself at home using just about any file system on just about any operating system.</p>\r\n\r\n<p>The basic abstraction in a file system is that of a <i>file</i>.  A file is a container in which a sequence of <i>bytes</i> is stored.  Each byte is effectively a sequence of eight \"digits\" that are either 1 or 0; each of these digits is called a <i>bit</i>.  The bytes in each file are interpreted differently depending on what kind of file it is, and it should be noted that this is largely a matter of what the program reading the file expects that it should contain (e.g., text, an image, a song); the file system itself is mostly unconcerned with what's in each file, except for the <i>metadata</i> associated with the file, which keeps track of things like who owns the file, who has access to the file, and when the file was last modified.  The file system manages the containers in which the bytes are stored, but cares little about the bytes inside of each file, other than to make sure that a file's contents don't change unless you ask for them to be changed.</p>\r\n\r\n<p>The most basic things we'll want to do with files in Python are read data from them (so we can use it as input to our program) and write data to them (so we can \"save\" it, or use it in another program).  We'll start our story there.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Files</p>\r\n\r\n<p>Interacting with files in Python requires first that we establish a sort of a connection to them.  The values we store in variables are part of our program; they're part of what Python knows or calculates while the program runs.  But the contents of files lie outside of our program, so we'll need some way to cross that boundary.</p>\r\n\r\n<p>In Python, we do that by <i>opening a file</i>, which can most easily be done using the built-in function <b>open()</b>.  If we call <b>open()</b> and pass it a single argument that is the path to a file &mdash; an indication of where the file is &mdash; then we'll get back a <i>file object</i> that we can use to interact with it.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>the_file = open('D:\\\\Examples\\\\data\\\\myfile.txt')</b>\r\n</pre></blockquote>\r\n\r\n<p>When we open a file, we also have to establish what we want to do with it, which requires us to specify a couple of things.</p>\r\n\r\n<ul>\r\n  <li>Whether we want to <i>read</i> the file or <i>write</i> to it.  In other words, we may want information that's in the file to become input to our program; that's reading.  We may also want information in our program to be stored in the file instead; that's writing.  For the most part, you'll only ever want one or the other on a particular file at any given time.</li>\r\n  <li>What you expect the file to contain.  For our purposes, there are two kinds of things we expect to find in a file: <i>text</i> or <i>binary data</i>.  For now, we'll focus our attention on files that contain only text.</li>\r\n</ul>\r\n\r\n<p>If you pass a second argument to the built-in <b>open()</b> function, you can specify both of these choices; the default, if you don't pass a second argument, is that you intend to read text.  So we would expect <b>the_file</b> to be a file object from which we can read text.  Let's see what we got.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>type(the_file)</b>\r\n&lt;class '_io.TextIOWrapper'&gt;\r\n</pre></blockquote>\r\n\r\n<p>It's not especially important that we know exactly what a <b>_io.TextIOWrapper</b> is, but the name at least gives us the sense that it provides input or output capabilites &mdash; that what is often abbreviated in computing as <i>I/O</i> &mdash; and that it deals with text.  In this course, I'll just refer to these as \"file objects.\"</p>\r\n\r\n<p>I tend to prefer to be explict about whether I intend to read from a file or write to it, so I'll generally pass the second argument.  (It's a little more to type, but it makes clear that I intend to read from the file, as opposed to my simply having forgotten to say anything.)  The way we say that we want to read text from the file is to pass the string literal <b>'r'</b> in the second argument.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>the_file = open('D:\\\\Examples\\\\data\\\\myfile.txt', 'r')</b>\r\n</pre></blockquote>\r\n\r\n<p>Once you have a file object, you can read from it or write to it, which we'll return to shortly.  But one important detail that we should consider first is that the notion of \"opening\" might make you wonder if there exists an inverse notion of \"closing,\" as well.  Indeed there is, and, in fact, it's a vital one.  When you're done using a file, you're always going to want to close it, which you do by calling the <b>close()</b> method on the file object.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>the_file.close()</b>\r\n</pre></blockquote>\r\n\r\n<p>Once closed, you'll no longer be able to use it, but you'll have ensured that any operating system resources involved in keeping it open will no longer be in use, and that other programs that may want to open the file will be able to do so.  We'll always close files we've opened after we're done with them.</p>\r\n\r\n<p class=\"subtitle\">Reading text from a file</p>\r\n\r\n<p>If you open a file because you want to read text from it, then there are methods you can to read that text.  There are a number of methods available, but we'll only need a small handful of them, so let's focus on the ones we need; we'll see others later if we find a use for them.</p>\r\n\r\n<p>The <b>readline()</b> method reads a line of text from the file.  The file object has a sort of \"cursor\" inside of it, which keeps track of our current position in the file; each time we read a line, that cursor is moved to the beginning of the next line, so that each subsequent call to <b>readline()</b> gives us back the next line of text that we haven't yet seen.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>the_file = open('D:\\\\Examples\\\\data\\\\myfile.txt', 'r')</b>\r\n&gt;&gt;&gt; <b>the_file.readline()</b>\r\n\"'Boo'\\n\"\r\n&gt;&gt;&gt; <b>the_file.readline()</b>\r\n'is\\n'\r\n&gt;&gt;&gt; <b>the_file.readline()</b>\r\n'happy\\n'\r\n&gt;&gt;&gt; <b>the_file.readline()</b>\r\n'today'\r\n&gt;&gt;&gt; <b>the_file.readline()</b>\r\n''\r\n&gt;&gt;&gt; <b>the_file.readline()</b>\r\n''\r\n&gt;&gt;&gt; <b>the_file.close()</b>\r\n</pre></blockquote>\r\n\r\n<p>The contents of the file we're reading in the example above look like this, with newlines on the end of every line <i>except the last one</i>.</p>\r\n\r\n<blockquote><pre>\r\n'Boo'\r\nis\r\nhappy\r\ntoday\r\n</pre></blockquote>\r\n\r\n<p>There are a couple of wrinkles in the example above worth noting.</p>\r\n\r\n<ul>\r\n  <li>Each time we called <b>readline()</b>, we got back a line of text with a newline on the end of it.  The only time that wasn't true is when we reached the last line &mdash; which, in the file, didn't have one.</li>\r\n  <li>When we had reached the end of the file already, every subsequent call to <b>readline()</b> gave us back the empty string.  This provides us a handy way to know that we've reached the end of the file.</li>\r\n</ul>\r\n\r\n<p>Given those two facts, we can write a loop that prints the contents of a file.</p>\r\n\r\n<blockquote><pre>\r\nthe_file = open('D:\\\\Examples\\\\data\\\\myfile.txt', 'r')\r\n\r\nwhile True:\r\n    line = the_file.readline()\r\n\r\n    if line == '':\r\n        break\r\n    elif line.endswith('\\n'):\r\n        line = line[:-1]\r\n\r\n    print(line)\r\n\r\nthe_file.close()\r\n</pre></blockquote>\r\n\r\n<p>The one trick that might seem strange there is this part: <b>line = line[:-1]</b>.  Recall that this is slice notation, which can legally be done on strings (and returns a substring of that string).  When <b>line</b> is a string, the expression <b>line[:-1]</b> gives you back a string containing everything but the last character of <b>line</b>.  We're using this technique to eliminate the newline if it's there.</p>\r\n\r\n<p>Iterating through every line of a file is so common, there are a couple of techniques that automate it.  One of them is the method <b>readlines()</b>, which returns all of the lines of the file, instead of one at a time; what you get back is a list of strings.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>the_file = open('D:\\\\Examples\\\\data\\\\myfile.txt', 'r')</b>\r\n&gt;&gt;&gt; <b>the_file.readlines()</b>\r\n[\"'Boo'\\n\", 'is\\n', 'happy\\n', 'today']\r\n&gt;&gt;&gt; <b>the_file.close()</b>\r\n</pre></blockquote>\r\n\r\n<p>The good news is that <b>readlines()</b> provides a single method you can call to read an entire text file in a form that it can be handy to use &mdash; as a list of its lines.  However, the bad news is that it read the entire file into that list.  If you have no need to store the entire file at once, you might instead want to process one line at a time.  It turns out that file objects that read text can be iterated using a <b>for</b> loop, in which case there is one iteration of the loop for each line of text.  Like <b>readline()</b> and <b>readlines()</b>, you'll get the newline on the end of each line.  Using that technique, we could rewrite our loop that prints the contents of a file more simply this way.</p>\r\n\r\n<blockquote><pre>\r\nthe_file = open('D:\\\\Examples\\\\data\\\\myfile.txt', 'r')\r\n\r\nfor line in the_file:\r\n    if line.endswith('\\n'):\r\n        line = line[:-1]\r\n\r\n    print(line)\r\n\r\nthe_file.close()\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Writing text to a file</p>\r\n\r\n<p>Opening a file to write text into it is similar to how we opened it for reading; the only difference is the second argument we pass to <b>open()</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>output_file = open('D:\\\\Examples\\\\data\\\\stuff.txt', 'w')</b>\r\n</pre></blockquote>\r\n\r\n<p>The file object you'll get back from <b>open()</b> turns out to have the same type.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>type(output_file)</b>\r\n&lt;class '_io.TextIOWrapper'&gt;\r\n</pre></blockquote>\r\n\r\n<p>However, it is configured differently, expecting to write text into the file instead of read from it.  In fact, we can ask a file object what its <i>mode</i> is, which means whether it is intended to read or write, by accessing its <b>mode</b> attribute.  (Note that <b>mode</b> is not a method, so we don't put parentheses after its name.  It's not something we can call; it's more akin to a variable that lives inside the object.)</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>output_file.mode</b>\r\n'w'\r\n</pre></blockquote>\r\n\r\n<p>Once you've got a file object whose mode is writing, you can call the <b>write()</b> method to write text into it.  You can pass only one argument to <b>write()</b>, a string, and whatever text is in that string will then be written to the file.  Newlines aren't added by default, so if you want them, you'll need to include them in that string.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>output_file.write('Hello there\\n')</b>\r\n&gt;&gt;&gt; <b>output_file.write('Boo is ')</b>\r\n&gt;&gt;&gt; <b>output_file.write('perfect today')</b>\r\n&gt;&gt;&gt; <b>output_file.close()</b>\r\n</pre></blockquote>\r\n\r\n<p>After writing this text and closing the file, the file's contents will be:</p>\r\n\r\n<blockquote><pre>\r\nHello there\r\nBoo is perfect today\r\n</pre></blockquote>\r\n\r\n<p>Note that when you've written text to a file, closing the file when you're done becomes more than just good hygiene; it's essential to writing a program that works.  It turns out that there's more going on than meets the eye when you write to a file.  Writing data into a file on, say, a hard disk involves a fair amount of overhead, so that writing a lot of it isn't much slower than writing only a tiny amount.  (It takes longer for a storage device to decide where to write it than the actual writing, as it turns out.)  For this reason, file objects use a technique called <i>buffering</i>, which means that they don't write the text immediately.  Instead, they store it internally in what's called a <i>buffer</i>.  Once in a while, when there's enough text stored in the file object to make it worth writing to the file, the text is written and the buffer is emptied.  If you're writing a lot of text to a file, but writing it a little bit at a time, this can make the entire process significantly faster, because the overhead of all of the tiny writes is eliminated.</p>\r\n\r\n<p>The problem is that the buffer is only written when it's explictly <i>flushed</i>.  (<i>Flushing</i> is the act of taking the text in the buffer and writing it into the file, then emptying the buffer.)  One thing that causes a buffer to flush is when the buffer's capacity is exceeded; that happens automatically at some point.  But when you're done writing to the file, there will probably be text still in the buffer.  One of the things that happens when you close a file is the buffer is flushed.  So you'll really want to be sure that you close files when you're done with them, particularly when you're writing to them; otherwise, the text that was buffered but never flushed to the file will never appear in the file, even though your program ran to completion with no apparent errors.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Paths</p>\r\n\r\n<p>You've no doubt seen before that each file on a file system has a name, which we quite often call its <i>filename</i>; the filename is one piece of metadata associated with each file.  But there's more to identifying a file than its name.  Because there are so many files stored on a typical file system &mdash; as I was writing this originally, I asked Windows to count how many files are stored on my laptop and found that the answer was about 700,000! &mdash; there needs to be some way to keep them all organized, so we can find files not only by their names, but by some other sort of categorization.  While operating systems are gradually adding progressively better search capabilities, there is still an underlying reality that hasn't changed much in the last few decades: File systems are quite often a <i>hierarchy</i> of directories, with each directory containing both files and other directories.  So, if we want to uniquely identify a file on our storage devices, we have to specify not only the file's name, but also where the file is stored in that hierarchy; without knowing more about the location of the file, the file system won't easily be able to find it. The location of a file is identified uniquely using a <i>path</i>.</p>\r\n\r\n<p>Different operating systems use different conventions for paths, the most common two of which are these:</p>\r\n\r\n<ul>\r\n  <li>Windows stores each file on a <i>drive</i> (e.g., a hard drive or a USB storage device) identified by an uppercase letter.  Quite commonly, a Windows machine's \"main\" drive (the one where the operating system is stored) will be known as C (for historical reasons that aren't all that interesting anymore), and others will have the letters D, E, and so on.  On each drive is a <i>root directory</i>, which can contain files and other directories; those directories can contain files and other directories; and so on.  A path on Windows specifies the drive letter, the directory within the root directory that contains the file, the directory within that directory that contains the file, and so on.  The drive letter is followed by a colon and the directories are separated by backslashes, leading to a path like the example below:\r\n    <ul>\r\n      <li><b>D:\\Examples\\32\\data\\myfile.txt</b></li>\r\n    </ul>\r\n  </li>\r\n  <li>Unix-based operating systems, which include macOS and various flavors of Linux, use what are sometimes called <i>POSIX-style paths</i>, which eschew the notion of a drive letter, and instead map certain directories to individual devices behind the scenes.  As on Windows, directories contain files and other directories, which contain files and other directories, and so on.  Unlike on Windows, a forward slash is used (instead of a backslash) to separate one directory from another.  This leads to paths that look like the example below:\r\n    <ul>\r\n      <li><b>/home/thornton/Examples/32/data/myfile.txt</b></li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n<p>The complexities of these rules aside, the important thing to realize is that there are slightly different rules on different operating systems, though the ideas are similar on all of them: that directories form a recursive hierarchy (directories containing other directories, which contain other directories) is fairly standard &mdash; even mobile operating systems like Android and iOS have this notion, albeit more or less invisible to users &mdash; and the differences are mainly minor details.  Still, if we want to write Python programs that work with file systems correctly regardless of operating system, as you're doing in <a href=\"../../ProjectGuide/Project1\">Project #1</a>, you're best off using the right kinds of tools for the job, so that you won't find yourself making assumptions (such as the character that separates directories in a path) that are correct on one operating system and wrong on another.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Finding what you need in the Python Standard Library</p>\r\n\r\n<p>Python is not just a programming language.  When you install Python, you also get the <i>Python Standard Library</i>, which is a large collection of pre-built components that solve a wide variety of commonly-occurring real-world programming problems, so that you won't have to.  We've talked before about the benefits of using a library that already exists, especially one that's been in use for a long time by a large number of people.  But, as a practical matter, there is a still a problem to be dealt with.  When you have a problem to solve, how do you know whether the Python Standard Library solves it?  And how do you find the right component to use?</p>\r\n\r\n<p>Of course, one way to solve that problem is simply to use an Internet search engine and poke around online to see what information you can find.  This is a fine approach sometimes, but what you'll find is that you have to develop a sense of what information is believable and reasonable, and what information isn't.  You also have to be wary of when advice is correct but inapplicable, such as someone offering details of Python 2 &mdash; an older version of Python that is nonetheless still used quite widely &mdash; when you're using Python 3.</p>\r\n\r\n<p>But I would suggest not giving in to the Google urge immediately.  Especially when you're first learning, there's value in spending a little time hunting for your own solutions to problems.  You tend to find solutions not only to the problem you have now, but to five related problems you don't realize you have yet.  You begin to develop a sense for what kinds of things you would find in the Standard Library, and notice commonalities in the way those components are designed, which can help you write better code yourself.  Learning the \"lay of the land\" in computing takes time, and there's no short-circuiting that process.  When you talk to people that seem to have these things all figured out already, you don't realize just how much time those people have put into learning their craft.  Don't worry; you'll get to that point, too, but you'll have to put in that time.</p>\r\n\r\n<p>So I suggest starting by taking a look through the Python Standard Library.  Go to the front page of the library documentation, which you'll find here:</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://docs.python.org/3.7/library/\">Python 3.7 Standard Library</a></li>\r\n</ul>\r\n\r\n<p>Look through the table of contents.  Don't feel like you have to memorize everything you see, and don't worry if many of the terms are things you don't recognize.  If you see things that you're curious about and you're not in a huge hurry, satisfy your curiosity and take a quick look at them; in so doing, you'll find yourself learning all kinds of terms that you haven't heard before.  But, fundamentally, what you're looking for are things that can help you with the particular problem you have.  So, for example, if you're looking for components that might help you deal with files, filenames, paths, and the like, then see which modules in the Python Standard Library sound like they might apply.  (Go ahead.  Check some of them out now!  I'll wait...)</p>\r\n\r\n<p>There are several modules in the Python Standard Library that should stand out as you look through the list.  One whole section of the library contains tools used for <b>File and Directory Access</b>, which sounds like it should definitely have something to do with the problem at hand.  You might also notice a section of the table of contents titled <b>Generic Operating System Services</b>, too, which might contain useful tools, since file systems are part of the operating system.</p>\r\n\r\n<p class=\"subtitle\">Importing a module</p>\r\n\r\n<p>Most Python programs aren't entirely self-contained, in the sense not all of the code that comprises the program is written in a single script.  Instead, it is most often the case that the Python scripts you write will need to use code that's written in other <i>modules</i>.  A Python module is similar to what we've been calling a Python script; you write modules as text in files whose names end in <b>.py</b>, just like scripts, and modules consist of Python code.  The difference is that modules, on their own, don't <i>do</i> anything.  Their job is to provide tools to programs, not themselves to <i>be</i> programs.</p>\r\n\r\n<p>When you want to make use of code in another module, you'll need to first <i>import</i> it.  Importing a module makes the tools provided by that module &mdash; functions, types, etc. &mdash; available in the module where it was imported.  You import a module using a statement called <b>import</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>import math</b>\r\n&gt;&gt;&gt; <b>math.sqrt(9)</b>\r\n3.0\r\n&gt;&gt;&gt; <b>math.gcd(15, 21)</b>\r\n3\r\n</pre></blockquote>\r\n\r\n<p>Note that <b>import</b> makes every definition in the module available, but its name must be <i>qualified</i> by the name of that module.  In the example above, we imported the <b>math</b> module, which is part of the Python standard library.  This made a variety of functions &mdash; such as <b>sqrt()</b> and <b>gcd()</b> &mdash; available to us.  However, to call those functions, we had to precede their names with the name of the module (<b>math</b>) and a dot.  I should point out that this, in and of itself, is not a bad thing; the acronym <b>gcd</b> might mean different things in different contexts, but <b>math.gcd</b> more clearly looks like what it is (greatest common divisor).  Much more often than not, I'll import modules this way, and I'll use their names whenever I use the definitions inside of them; I'm less concerned about typing less and more concerned about being able to read a program later and quickly understand it.</p>\r\n\r\n<p>That said, there is a way to import a definition from a module and make it directly available without qualification, using a variant of the <b>import</b> statement that you might call <b>from ... import</b>.  For example, if we wanted to import the <b>sqrt()</b> function from the <b>math</b> module this way, we might do this.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>from math import sqrt</b>\r\n&gt;&gt;&gt; <b>sqrt(9)</b>\r\n3.0\r\n</pre></blockquote>\r\n\r\n<p>Again, I somewhat rarely will do this, unless I think the name of what I'm importing makes its meaning pretty self-evident.</p>\r\n\r\n<p>One thing I never do, but that is supported in Python, is to import <i>every</i> definition in a module and allow it to be used without qualification.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>from math import *</b>\r\n&gt;&gt;&gt; <b>sqrt(9)</b>\r\n3.0\r\n&gt;&gt;&gt; <b>gcd(15, 21)</b>\r\n3\r\n</pre></blockquote>\r\n\r\n<p>The main reason that I never do this is because the meaning of a program will potentially change every time that other module does.  As new versions of Python are released, new functions may be added to the <b>math</b> module.  (For example, the <b>gcd</b> function didn't exist until Python 3.5, which was released in the summer of 2015.)  If I have a long-lived program that says <b>from math import *</b>, the meaning of a name may suddenly change, because I may upgrade Python and suddenly be importing new functions that I didn't used to be importing.  I'm a big believer in using techniques that scale and that stand the test of time.  So I avoid anything that makes it more difficult to write large programs, and I also avoid anything that will allow someone else's change &mdash; someone adding a function to a module I didn't write, say &mdash; to change the meaning of my program.</p>\r\n\r\n<p>Why it's less dangerous to say <b>from math import sqrt</b> is that I've only imported the one name.  Designers of libraries are reluctant to change the meaning of an existing function, so it's pretty safe to assume that <b>math.sqrt</b> will always mean the same thing in Python.  If new functions are added to the <b>math</b> library, that won't change the meaning of <b>from math import sqrt</b>, so that's safer ground.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Manipulating paths using Python's pathlib</p>\r\n\r\n<p>Having taken a look through the Python Standard Library, you should have noticed a library called <b>pathlib</b>, whose documentation is linked below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://docs.python.org/3.7/library/pathlib.html\">Python 3.7 <i>pathlib</i> documentation</a></li>\r\n</ul>\r\n\r\n<p>Take a quick look through that documentation, again focusing on getting a broad idea of what's there and what it can do.  Don't worry if you don't understand everything you're seeing, and don't worry if you feel like a fish out of water because you've never read documentation like this before.  See what things resonate and just get a broad mental picture of what's available.  Then you can use the Python shell to experiment with it to find out more about how it works.</p>\r\n\r\n<p class=\"subtitle\">Creating a Path object</p>\r\n\r\n<p>Path objects represent paths on a file system.  They aren't files and they aren't strings; they're paths, which means they are explicitly intended to represent the way that a file system keeps track of where a file is.  Since there are substantial commonalities between different kinds of file systems, there can be one kind of object that represents those commonalities.  (Interestingly, there are also ways to represent the differences, as we'll see.  Path objects handle all of those details, so you won't have to.)</p>\r\n\r\n<p>In a Python shell, you first need to import the <b>pathlib</b> module and, specifically, it helps to import the <b>Path</b> type from it, which you can do like this:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>from pathlib import Path</b>\r\n</pre></blockquote>\r\n\r\n<p>(I'm using the <b>from ... import</b> syntax here, because I think the meaning of the word <b>Path</b> is pretty self-evident, while adding <b>pathlib.</b> to the front of it won't really make it any clearer.)</p>\r\n\r\n<p>Now, anytime you use the word Path, you're specifically asking for the <b>Path</b> type in the <b>pathlib</b> library.  Having imported it, you can now create objects of the <b>Path</b> type.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p = Path('D:\\\\Examples\\\\data')</b>\r\n&gt;&gt;&gt; <b>p</b>\r\nWindowsPath('D:/Examples/data')\r\n</pre></blockquote>\r\n\r\n<p>Did you notice what happened when we showed the value of <b>p</b> in the shell?  Its type appears to have changed!  What we created was a <b>Path</b> object, but its type is something else called a <b>WindowsPath</b>!</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>type(p)</b>\r\n&lt;class 'pathlib.WindowsPath'&gt;\r\n</pre></blockquote>\r\n\r\n<p>So what happened?  The answer is that creating a <b>Path</b> object automatically gives you the right <i>kind</i> of <b>Path</b> object depending on what operating system you're running.  I ran this example on Windows, which is why I got a <b>WindowsPath</b>; if, instead, you did the same thing on macOS or another operating system that uses POSIX-style paths, you'd get a <b>PosixPath</b> object instead.</p>\r\n\r\n<p>Another minor detail to note is that our backslashes got turned into forward slashes.  That's mainly because the various <b>Path</b> types endeavor to hide as many of the differences between file systems as possible; internally, when we use <b>Path</b> object to get out to the actual file system, they do the right thing in the right circumstance automatically.</p>\r\n\r\n<p class=\"subtitle\">What can you do with Path objects?</p>\r\n\r\n<p>There are all kinds of useful things you can do with <b>Path</b> objects.  This isn't an exhaustive list, but the examples below should give you an idea of what's available and how to use them.</p>\r\n\r\n<p>When you manipulate paths, you often find yourself combining them together.  That's easily done using the <b>Path</b> type; the <b>/</b> operator, when used between two <b>Path</b>s, combines the two paths together into a single one.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p = Path('D:\\\\Examples\\\\data')</b>\r\n&gt;&gt;&gt; <b>q = p / Path('myfile.txt')</b>\r\n&gt;&gt;&gt; <b>q</b>\r\nWindowsPath('D:/Examples/data/myfile.txt')\r\n</pre></blockquote>\r\n\r\n<p>You can do the same thing to combine a <b>Path</b> with a string, too, which can be a handy shorthand.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>r = p / 'test.txt'</b>\r\n&gt;&gt;&gt; <b>r</b>\r\nWindowsPath('D:/Examples/data/test.txt')\r\n</pre></blockquote>\r\n\r\n<p>If you want to know if a <b>Path</b> object represents something that actually exists on your hard drive, you could just ask it:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p.exists()</b>\r\nTrue\r\n</pre></blockquote>\r\n\r\n<p>If you want to know if it's a directory or a file, you can ask it those things, as well.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p.is_file()</b>\r\nFalse\r\n&gt;&gt;&gt; <b>p.is_dir()</b>\r\nTrue\r\n</pre></blockquote>\r\n\r\n<p>If it's a file, you might like to open it; that's supported, too.  Opening a <b>Path</b> is a lot like the built-in <b>open</b> function you've probably seen previously, except that it doesn't need a parameter specifying the location of the file, since the <b>Path</b> acts as that location already.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>f = q.open('r')</b>\r\n&gt;&gt;&gt; <b>f.readlines()</b>\r\n['Alex\\n', 'is\\n', 'happy\\n', 'today']\r\n&gt;&gt;&gt; <b>f.close()</b>\r\n</pre></blockquote>\r\n\r\n<p>If it's a directory, you might like to know what's in it.  A method called <b>iterdir</b> can tell you the answer to that, though there's one wrinkle: It returns something called a <i>generator</i> (which is a story for ICS 33), but you can easily turn a generator into a list by simply calling the built-in function <b>list</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>list(p.iterdir())</b>\r\n[WindowsPath('D:/Examples/data/myfile.txt'), WindowsPath('D:/Examples/data/test.txt')]\r\n</pre></blockquote>\r\n\r\n<p>Or you could iterate through the result with a <b>for</b> loop, rather than making a list out of it:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>for x in p.iterdir():\r\n       print(x)</b>\r\n\r\nD:\\Examples\\data\\myfile.txt\r\nD:\\Examples\\data\\test.txt\r\n</pre></blockquote>\r\n\r\n<p>There are lots of other things you can do with <b>Path</b> objects &mdash; get a filename, get a filename's extension, get a path's \"parent\", and so on &mdash; and I'd encourage you to take a look through the documentation to see what's available.</p>\r\n\r\n<p class=\"subtitle\">Why use <i>pathlib</i> and not <i>os.path</i>?</p>\r\n\r\n<p>The <b>pathlib</b> library is a relatively recent addition to the Python Standard Library, having been added in version 3.4.  Prior to that, there was a library &mdash; which still exists, but is a lot less useful &mdash; called <b>os.path</b>, which provides functions that manipulate strings instead of <b>Path</b> objects, but still hide some of the details between file systems, such as combining them with the right kinds of slashes depending on what operating system you're using.</p>\r\n\r\n<p>But using strings and manipulating them with <b>os.path</b> nonetheless leaves you with a lot of room to make mistakes.  Strings are simply text; you can store any text you want in a string, whether it's a valid path or not.  So you're better off using a tool that was built for the job at hand: When you want to manipulate paths, use the <b>pathlib</b> library.</p>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}