{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/introjava.txt", "content": "\t\t\t\tFirst Draft\r\n\r\n\t\t\t\tIntroducing Java\r\n\r\nIn this lecture we will explore a bit of the Java language: I chose Java\r\nbecause I know it better than C++ (both, like Python, are still changing and\r\nevolving). The main point of this lecture is to show a more conventional\r\nlanguage similar to Python (still in the same general family: object-oriented\r\nlanguages that use statements to compute their results) but with some\r\ndifferences.\r\n\r\nI have tried to discuss the most important and interesting differences between\r\nthese language, broadly broken into four main areas.\r\n\r\n  1) Compilation and compile-time vs. run-time issues\r\n  2) Syntax differences\r\n  3) Static vs dynamic typing\r\n  4) Built-in vs Class Supplied Data Structures\r\n\r\nNote that you all should have Java installed on your computers (to run Eclipse)\r\nso you can use Eclipse to write and run Java programs. I suggest buying older\r\neditions of Java texbooks authored by Horstmann or Savitch (cheaper than the\r\nmost current editions).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCompilation\r\n\r\nAs with Python, Java translates programs into a special instruction set that\r\nruns on the Java Virtual Machine (JVM). In fact, the JVM is so well-known that\r\nother languages are translated to run on the JVM. Java programs run 5 times as\r\nfast as Python programs (and C++ programs run another factor of 5-10 faster) but\r\nwith a price: there are important Python programming features (e.g., eval and\r\nexec) that Java does not support (and likewise, C++ doesn't support certain\r\nfeatures that makes checking/debugging Java programs easier*). So this is an\r\nexample of languages trading-off power and ease of programming for speed of\r\nexecution. \r\n\r\n-----\r\n*For example, Python checks its lists (and Java its arrays) for indexes that\r\nare out of bounds, and raises an exception if they are. Typically it reports an\r\nillegal index error at run-time (Java further reports the illegal index used;\r\nPython just says the index is illegal without reporting its value). When an\r\nillegal index is used with a C++ array, typically there is no runtime error:\r\ninstead C++ just uses the information in its memory where the value at the\r\nillegal index would appear if it were in the array; what is actually there, in\r\nthe computer's memory, is some random/garbage value. So the program keeps\r\nrunning, although it is likely the bad data will corrupt the computation. By\r\navoiding checking indexes, C++ allows correct programs (e.g., ones doing no\r\nillegal indexing) to run faster. But incorrect programs don't fail when the\r\nerror occurs: instead they keep excuting and maybe fail later, but often instead\r\nprint wrong results (or worse, incorrectly buy/sell a stock, or catastrophically\r\ndecide to launch a nuclear attack, because of an incorrect program). Sometimes\r\na C++ program will crash immediately, giving no information about where it\r\nstopped: that is the best case!\r\n-----\r\n\r\nPython reads and translates imported modules on the fly, while it is runing\r\nprograms. Java breaks running programs into two separate processes: compiling\r\nprograms first (translating them into JVM instructions) and then running these\r\ninstructions on the JVM. Errors are categorized as to when they occur: at\r\ncompile-time or at run-time. The program that does the compilation is called\r\nthe Java Compiler.\r\n\r\nCertain Java errors are called syntax or compile-time errors; others are called\r\nexecution or run-time errors. Actually Python has the concept of syntax errors\r\n(even if there is no separate compile-time/run-time distinction). For example\r\nin Python, if we misspell a keyword or name, or indent a block incorrectly,\r\nPython reports the error, but only when we run the program; although the\r\nEclipse editor often flags such errors for us before we run our program:\r\nindicating that if we run it, Python will find an error. Likewise, when Java\r\ncompiles a program, Java checks it for the same kinds of errors (and more; see\r\nbelow). But, we cannot run Java software until all its files compile correctly.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nImportant Syntactic Differences\r\n\r\nPython and Java are similar languages in that both define statements that are\r\nexecuted in sequences known as blocks. The syntax of Python requires that each\r\nstatement is on a different line and that blocks are indented. The syntax of\r\nJava requires that statements are separated by semicolons (so one can easily\r\nhave multiple statements per line or one statement covering multiple blocks)\r\nand that blocks (of more than one statement) must appear in the {} braces. Java\r\npromotes a certain format for writing blocks (so that the code is clearly\r\nindented and actually looks like Python code) but such style rules are not\r\nrequired of programmers writing in the language. In fact, style rules for \r\nJava and C++ are a bit different.\r\n\r\nPython\t   \t     \t Java\r\n\r\nif x < y:\t\t if (x < y) {\r\n    min = x\t\t     min = x;\r\n    max = y\t\t     max = y\r\nelse:\t  \t\t }else{\r\n    min = y\t\t     min = y;\r\n    max = x\t\t     max = x\r\n                         }\r\n\r\nNote that the syntax of Java requires () parentheses in more places than Python\r\ndoes: like surrounding the test in an if (or while) statement. Also note that\r\nwe can write this Java code as\r\n\r\nif (x < y) {min = x; max = y}else{min = y; max = x}\r\n\r\nand it has the same meaning to the Java compiler. Even the following code\r\n(indented nonsensically)\r\n\r\nif (x < y)\r\n{min = x;\r\n    max = y}\r\n  else{min\r\n= y; max\r\n   = x}\r\n\r\nhas the same meaning. A program is just a sequence of tokens with all the\r\nwhitespace removed. In Python, line-endings and indentation are important.\r\n\r\nWe can write the Python code on the left below as either Java code on the right:\r\nthe first uses one statements in the if/else; the second uses blocks \r\n(optional, because they contain just one statement). Note the meaning of / in\r\nJava: int/int in Java is like int//int in Python, because both truncate the\r\nresult to an integer. There is no Java operator to compute a float value from\r\ntwo int values.\r\n\r\nif x%2 == 0:\t\tif (x%2 == 0)\t\t  if (x%2 == 0) {\r\n    x = x//2                x = x / 2                 x = x /2\r\nelse:                   else\t\t\t  }else{\r\n    x = 3*x + 1             x = 3*x + 1\t\t      x = 3*x + 1\r\n\r\nNames in Java are written in \"camel\" notation. In Python we wrote a_var_name\r\nand in Java we write aVarName (the capital letters are like humps on a Camel).\r\nBy Java convention, most names start with a lower-case letter, but class names\r\nstart with an upper-case letter.\r\n\r\nHere is an minor but interesting difference: Python interprets the expression\r\n\"a < b < c\" as \"a < b and b < c\". Java interprets this expression as \"a < b < c\"\r\nto compare the boolean result of the first < to c, which is likely to cause a\r\nstatic-typing compilation error described below. In Java we must write\r\n\"a < b < c\" more explicitly, as \"a < b && b < c\" (where && is Java's equivalent\r\nto Python's \"and\" operator).\r\n\r\nFor commenting // is used in Java is like # is use in Python, as a\r\nline-oriented comment. Java also has multiline comments\r\nsuch as \r\n\r\n/*\r\n   This is a multi-line\r\n   comment in Java\r\n*/\r\n\r\nIn Python, files contain modules or classes. In Java there is no equivalent to\r\nmodules, so files contain only classes, one class per file. The name of file\r\nand the name of the class it contains must be the same. So everything that we\r\nwrite in Java we write in some class: there is a special method named \"main\" in\r\na class which Java calls to start a program executing (similar to Python, in\r\nwhich we write code in a module like if __name__ == '__main__':).\r\n\r\nNote that Java divides types into primitive and reference types. Primitive\r\ntypes are things like integers (ints) and floating point values (double).\r\nReferences store references to objects constructed from classes (just like\r\nPython; all values in Python are objects). In fact Java includes classes like\r\nInt and Double that are the object equivalent of the primitive types: they are\r\nmore cumbersome and slower to use, but we can use them in places where class\r\nobjects must be used (not primitives: there are a few rough corners like this).\r\nJava operators work primarily on primitive types; reference types use methods\r\nto perform computations. Java classes cannot overload operators the way Python\r\ndoes (but C++ can).\r\n\r\nJava allows only single inheritance. Classes can refer to information\r\nin their super classes by using the keyword super. So if the inc method in the\r\nModular_Counter subclass (as they are know in Java, the same as a derived class\r\nin Python) overrides the inc method in its Counter superclass (the same as a\r\nbase class in Python) the inc method in Modular_Counter can call super.inc() to\r\ncall the inc method in Counter. In Python we would write Counter.inc() instead.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nStatic and Dynamic Typing (relating to the types of values)\r\n\r\nPython is a dynamically typed language. Java (and C++) is a statically typed\r\nlanguage. In a dynamically typed language, each name refers to an object that\r\nis of some type, but we cannot always know to what type of object a name refers\r\nto. For one example we can write x = 1 and later x = [1,2,3] so x first refers\r\nto an int and later a list of ints.*\r\n\r\n-----\r\n*Note that ints in Java are 32 bit quantities, not arbitrarily sized integers\r\nas in Python. Java does have a type name BigInteger that stores arbitrarily\r\nlarge integers, but is a class we must operate on it with methods. So we end up\r\nwriting code like x = BigInteger(\"2984248239834923\"); y = x.multiply(x).add(x)\r\n(which in Python we would write as just x = 2984248239834923 and  y = x*x+x)\r\nRecall that operators in Java generally work only on the primitive types. We\r\ncannot write classes that overload operators in Java as we did in Python (but\r\ncan overload operators in C++)\r\n-----\r\n\r\nFor another example, if we define the following function in Python\r\n\r\ndef randtype():\r\n    if random.random() < .5:\r\n        return 1\r\n    else:\r\n        return 1.\r\n\r\nx = randtype()\r\n\r\nThen we don't know what type of object the name x refers to: it might be int or\r\nit might be float. But we can compute type(x) to find out. So, in a dynamically\r\ntyped language when we define names we don't need to specify their type: we\r\nassign them a reference to a value. Not knowing the type of value associated\r\nwith a name (and having to compute it at run-time) is another reason Python\r\nruns more slowly than Java and C++. Whenever Python must do something with the\r\nvalue associated with a name, it must first compute its type: think of the \r\nfundamental equation of object-oriented programming.\r\n\r\nIn a statically typed language like Java, we must specify the type of each\r\nname: in Java we talk about declaring (not defining names). We can write either\r\nint x; or int x = 1; the former declares x to always store an int but currently\r\nstore no value, while the latter declares x to always store an int and\r\ncurrently store 1. \r\n\r\nWe must also specify the type of parameters and local variables and specify the\r\nreturn type of any method, where the type name \"void\" means that it returns no\r\nvalue: Python functions returning None is a different but similar idea to Java\r\nmethods having a \"void\" return type: note that there are no pure \"functions\" in\r\nJava in the Python sense, there are only methods; but static methods in Java\r\nare most like pure functions in Python, because we can call them by specifying\r\nthe class and method name, much like importing a Python module and using the\r\nmodule and its function name. So we might see a method defined in the Math\r\nclass by\r\n\r\nstatic int factorial (int n) {\r\n    int answer = 1;\r\n    for (int i = 1; i<n; i++)  //like Python's: for i in range(1,n,1):\r\n        answer *= i;\r\n    return answer\r\n}\r\n\r\nand call it by Math.factorial(5).\r\n\r\nHere n, answer, and i are all declared to be int, and the method also returns\r\nan int. Notice the for loop which has a variable declaration/initialization\r\n(int i = 1), followed by a continuation test (i<n), followed by an increment\r\n(i++ which means i += 1). Notice how {} contains the block that is the body of\r\nthis method. The for loop has just one statement in its body, so we do not need\r\nto specify a block with {}.\r\n\r\nOnce Java knows variable names and their types, and the parameter/return types\r\nof functions (and of course it knows the types of all its constants) it can\r\ndetermine the type of any expression using operators and functions, and it can\r\ndetermine any type mismatches at compile time. For example, if we have defined\r\n\r\ndouble  d(int    a) ...\r\ndouble d2(double a)\r\nint     i(int    a) ...\r\n\r\nint x;\r\n\r\nThen the Java compiler knows\r\n\r\n x = d(3) results in type mismatch: the d function takes an int as an argument\r\n(3 is an int) and produces a double, but the type of x is an int, so there is a\r\ntype mismatch reported by the compiler: it cannot assign a double value to an\r\nint name.\r\n\r\nLikewise, calling i(d(3)) results in a type mistmatch: the d function takes \r\nan int as an argument (3 is an int) and produces a double, but the i function\r\ntakes an int as an argument, but d(3) is a double, so there is a type mismatch\r\nreported by the compiler.\r\n\r\nGenerally, if we try to assign a value of one type to a name declared to be of\r\nanother type, Java reports a compile-time error. Likewise, if we try to pass\r\nan argument of one type to a parameter name declare to be of another type, Java\r\nreports a compile-time error.*\r\n\r\n-----\r\n*Certain implicit type conversions, called promotions, automatically occur to\r\n\"solve\" some type mismatches. For example, if we call d2(i(3)) Java will allow\r\nit:  the i function takes an int as an argument (3 is an int) and produces an\r\nint, but the d2 function takes a double as an argument, so Java will implicitly\r\npromote the int to its equivalent double value. This promotion works because\r\nevery int value can be converted into an equivalent double value (note that for\r\ndoubles, this is not the case: there is no int value equivalent to 1.5).\r\n\r\nThere is a way to convert a double into an int by throwing away its decimal\r\npart. This is called casting, and we can write i((int)(d(3)) for which Java\r\ndoes not report a  type mismatch. Likewise we can avoid implicit conversion by\r\nexplicitly converting with casting, as in d2((double)i(3)).\r\n-----\r\n\r\nNote that in Python we can specify a parameter that expects an int values but\r\nhas a default value of None (two different types). For example, if we define\r\n\r\ndef f(max=None): .... \r\n\r\nwe can call f(1) where max = 1 or f() where max = None.\r\n\r\nJava does not allow this kind of function, because we cannot have a parameter\r\nthat is sometimes an int and sometimes None. But it we wanted to do the\r\nequivalent  of def f(max=0), we can do it in Java by defining two version of f\r\n(with two different parameter structures)\r\n\r\n... f(int max ) {...}\r\n... f()         {...}\r\n\r\nNow if we call f(1) it executes the first function with max = 1; if we call f()\r\nit executes the second function. In such a case, we might implement the second\r\nfunction by calling the first with the argument 0 - the default value we want.\r\n\r\nGenerally, Java (and C++) are much more restrictive than Python in the ways\r\nthat function calls bind their arguments to parameters. This is one simple\r\ndifference.\r\n\r\nNote that Python annotations CAN play a SIMILAR roll to static typing but with\r\na large time cost at runtime. Generally, annotations are just ignored. We have\r\nseen that we can write a function decorator and turn on annotation checking.\r\nThis means that every time a Python function is called it checks all the values\r\nof its parameters (and possibly its return value). This checking takes place at\r\nrun-time, and can take a long time when checking large data structures.\r\nContrast this approach with Java's, where it performs all its checking once, at\r\ncompile-time: there is an increased compile-time cost, but no run-time cost.\r\n\r\nSo overall, it is harder to get a Java program to compile, because the compiler\r\nis checking for type compatability. But when a Java program compiles correctly,\r\nwhen it is run it will never report the kinds of incompatible type errors that\r\nappear frequently in Python. So if we code a type error, we must fix it in Java\r\nand Python, but the Java compiler will report the problem (and the statement\r\ncausing it) at compile-time, before running the program. Python will run the\r\nprogram and only then report the problem at run-time (and then, only if the\r\nwrong code is executed). So by providing type information to the compiler, it\r\ncan check that we using names in approprate ways according to their declared\r\ntypes.\r\n\r\nInterfaces specify the parameter/return types of one or more methods in a\r\nclass. Classes can specify that they implement any number of interfaces (so\r\nlong as they define the methods with the required parameter/return types).\r\nImplementing multiple interfaces is similar to multiple inheritance (it is more\r\nrestrictive but cleaner).\r\n\r\nWe can use the names of interfaces to specify a type: objects of any class\r\nimplementing that interface are allowed to match it.\r\n\r\nIf we specify\r\n\r\ninterface LikeBoolean {\r\n  boolean bool();\r\n}\r\n\r\nThen if we define a class C and specify it implements LikeBoolean, and we\r\ndeclare LikeBoolean c = C(..) we can call c.bool() which returns a boolean\r\nvalue representing the object of class C that c refers to. We can pass an\r\nobject of class C as the first argument to the following method (note that in\r\nJava a ? b : c in Java is like the conditional expression b if a else c \r\nin Python).\r\n\r\nint choose(LikeBoolean lb, int trueV, int falseV) {\r\n  return lb.bool() ? trueV : falseV\r\n}\r\n\r\nSo choose(c,1,0) would return 1 if c.bool() were true and 0 if c.bool() were\r\nfalse (in Java, the boolean values are true/false not True/False).\r\n\r\nIf class D also implements LikeBoolean, then we can also pass an object of\r\nclass D to choose. So choose(d,1,0) would return 1 if d.bool() were true and\r\n0 if d.bool() were false.\r\n\r\nSo by using interfaces, we specify the argument matching the parameter lb can\r\nbe an object constructed from any class, so long as that class implements the\r\nLikeBoolean interface: meaning the class defines a bool method, which is the\r\nonly method choose calls on its lb parameter.\r\n\r\nFinally, the types of names can be prefaced by attributes like public and\r\nprivate, determining whether the name can be referred to in code outside the\r\nclass (public) or can be acccessed only in methods inside the class (private).\r\nJava does this cleanly; we saw ways some ways to gain this control in Python\r\nby overloading special __...__ methods.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nBuilt-in vs Class Supplied Data Structures\r\n\r\nJava builds-in the primitive types and references. One other built-in type is\r\narrays: which are like lists, but cannot grow. When we allocate an array object\r\nwe must specify its length. We can use less than its length, but if we need to\r\nuse more we must allocate a new/bigger array and then copy all the values from\r\nthe old array to the new one. Arrays in Java are homogenous: they store the\r\nsame type of value in each spot. Although, with interfaces and the use of\r\ninheritance, values constructed from many different classes can be stored in an\r\narray. We can declare and construct array objects like int [] i = new int[10].\r\nor LikeBoolean[] lb = new LikeBoolean[10]. Here, read int[] as int array and\r\nnew int[10] constructs an array of 10 int objects. As described earlier,\r\naccessing an array out of bounds: using a negative index or an index >= the\r\narrays's length (given in Java by writing x.length, which is equivalent to\r\nPython's len(x)), is checked and raises an exception. Note if we declare a Java\r\narray of length 10, it is always length 10 no matter how many values are\r\nactually stored in the array; if we are using fewer values, we must have a \r\nvariable to keep track of how many values are stored in the array.\r\n\r\nNote that the compiler allows us to call lb[5].bool() because each value in\r\nthe lb array is of type LikeBoolean, and we can call .bool() on any value of\r\nthe LikeBoolean type (based on the interface specifying that method).\r\n\r\nJava has an isinstance function that can determine whether a value comes from\r\na specific type (or any of its subclasses, just as in Python).\r\n\r\nUnlike Python, Java does not build in lists, sets, or dictionaries. But its\r\nstandard library includes interfaces that describe these data types and\r\nclasses (sometimes multiple classes) that implement these interfaces. The\r\ninterfaces are List, Set, and Map (which is like a dictionary, mapping a key\r\nto a value) and example classes that we can use that implement these interfaces\r\ninterfaces, are ArrayList, HashSet, and HashMap.\r\n\r\nBecause these data structures are supplied as classes, there is no special\r\nsyntax for using them (e.g., no {} to create maps or [] to access/set maps).\r\nSo instead of code like graph[source] we must write graph.get(source). And\r\ninstead of graph[from] = destinations we must write\r\ngraph.put(from,destintations)\r\n\r\nSome people say, it is \"only syntax\". But it does make codes a bit harder to\r\nread, understand, and write, especially when the key/value is more complicated.\r\n\r\nI don't have enough time to go into how these classes are used, but here is\r\nJava code that solves the Reachability problem from Programming Assignment #1\r\nin ICS-33. Note that Map<String,Set<String>> (for defininig the graph) defines\r\na type which is a Map from String to a Set containing String. If we were to try\r\nto put a key or associated value in the map that violated these type\r\nspecification is, the Java compiler would detect and report an error at\r\ncompile-time.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nimport edu.uci.ics.pattis.introlib.Prompt;\r\nimport edu.uci.ics.pattis.introlib.TypedBufferReader;\r\nimport edu.uci.ics.pattis.ics23.collections.*;\r\n\r\nimport java.util.StringTokenizer;\r\nimport java.io.EOFException;\r\n\r\n\r\npublic class Reachable {\r\n\r\n    private static void printGraph(Map<String,Set<String>> edges, String label) {\r\n        System.out.println(\"\\n\"+label);\r\n        List<String> sources = new ArrayList<String>(edges.keys());\r\n        Collections.sort(sources);\r\n        for (String source : sources)\r\n            System.out.println(\"  \"+source+\" -> \"+edges.get(source));\r\n       }\r\n\r\n\r\n    private static Set<String> reachable(Map<String,Set<String>> graphMap, String start) {\r\n        Set<String>   reachable = new ArraySet<String>();\r\n        Queue<String> toSearch  = new ArrayQueue<String>();\r\n\r\n        toSearch.add(start);\r\n    \r\n        while (!toSearch.isEmpty()) {\r\n            String nextToProcess = toSearch.remove();\r\n            reachable.add(nextToProcess);\r\n            Set<String> destinations = graphMap.get(nextToProcess);\r\n           if (destinations != null)\r\n              for (String candidate : destinations)\r\n                  if (!reachable.contains(candidate))\r\n                      toSearch.add(candidate);\r\n        }\r\n    \r\n        return reachable;\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        Map<String,Set<String>> graphMap = new ArrayMap<String,Set<String>>();\r\n        TypedBufferReader       tbr      = new TypedBufferReader(\"Enter name of file with graph\");\r\n\r\n        for(;;)\r\n            try {\r\n                StringTokenizer st = new StringTokenizer(tbr.readLine(),\";\");\r\n                String from = st.nextToken();\r\n                String to   = st.nextToken();\r\n                Set<String> destinations = graphMap.get(from);\r\n                if (destinations == null) {\r\n                    destinations = new ArraySet<String>();\r\n                    graphMap.put(from,destinations);\r\n                }\r\n                destinations.add(to);\r\n            } catch (EOFException e) {break;}\r\n\r\n        printGraph(graphMap, \"Graph: source -> {destination} edges\");\r\n        String start = Prompt.forString(\"\\nEnter node to start from\");\r\n        System.out.println(\"Node(s) reachable from \" + start + \" = \" + reachable(graphMap,start));\r\n    }\r\n}\r\n", "encoding": "ascii"}