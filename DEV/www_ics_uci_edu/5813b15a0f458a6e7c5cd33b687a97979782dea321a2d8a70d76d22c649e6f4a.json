{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/voe/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Variables and Operators</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Variables, Operators, and Expressions</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III\r\n<br>\r\nICS-21/-22/-23\r\n<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will first learn how to declare and visualize variables\r\n    storing any type of data (both primitive and reference types).\r\n  Then, we will learn a variety of operators (arithmetic, relational, logical,\r\n    textual, and state-change) and methods that compute results (produce more\r\n    values) from such data.\r\n  Along the way, we will introduce new terminology for discussing operators\r\n    and methods generally.\r\n  <p>\r\n  Finally, we will learn how to combine literals, variables, operators, and\r\n    methods (which are like function calls) to build arbitrarily complicated\r\n    expresions (formulas that Java can evaluate).\r\n  We being by examining the structure and evaluation process for expressions,\r\n    including the concepts of operator precedence and operator associativity.\r\n  Then we will learn how to build oval diagrams: the main analytic tool that\r\n    we will use to investigate/understand large expressions (along with our\r\n    knowledge of prototypes).\r\n  We should understand how to translate complicated formulas into their\r\n    equivalent Java expressions and verify that the translation is correct.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Declaring Variables -->\r\n\r\n<a name=\"Declarations\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Declaring Variables</b></td>\r\n<td width =\"80%\">\r\n  Programs declare variables to store/remember information; they manipulate\r\n     (examine and update) this information when they run.\r\n  Simple variables typically store some value input by the user, or some value\r\n    calculated by the program from user-inputs.\r\n  When a program runs, the values in some of its variables change: thus, the\r\n    value stored in a variable can <b>vary</b> as the program runs.\r\n<p>\r\n  The EBNF rules for variable declaration appear below.\r\n  Each declaration is a statement -a complete command to the computer- which\r\n    the computer executes.\r\n  We will cover many of Java's other statements in the next lecture.\r\n  <p>\r\n&nbsp &nbsp <i>primitive-type</i> &nbsp<= int | double | boolean | char<br> \r\n&nbsp &nbsp <i>reference-type</i> <= String | ... (we will learn others soon)<br> \r\n&nbsp &nbsp <i>type</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n       <= <i>primitive-type</i> | <i>reference-type</i><br>\r\n  <br> \r\n&nbsp &nbsp <i>expression</i> <= <i>literal</i> | ... (we will generalize this rule later)<br> \r\n  <br> \r\n&nbsp &nbsp <i>variable-declarator</i> &nbsp<= <i>identifier</i> [=<i>expression</i>]<br> \r\n&nbsp &nbsp <i>variable-declarators</i> <= <i>variable-declarator</i>{,<i>variable-declarator</i>}<br> \r\n  <br>\r\n&nbsp &nbsp <i>local-variable-declaration-statement</i> <= <i>type</i> <i>variable-declarators</i> ;<br> \r\n  <p>\r\n  Declarations are simple statements, which means that they end with a\r\n   semicolon (see the last rule above).\r\n  Variables are always declared with a type (e.g., a primitive type like\r\n    <b>int</b> or a reference type like <b>String</b>), one or more names\r\n    (an identifier that the programmmer chooses) which can be optionally\r\n     initialized to store a specified value.\r\n  <p>\r\n  The simplest form of a declaration is <b>int sum;</b> which declares one\r\n     variable named <b>sum</b> to be of the type <b>int</b>, meaning that\r\n     <b>sum</b> stores only <b>int</b> values.\r\n  Again, notice the semicolon ending this statement.\r\n  When a variable is declared this way, the value that it initially stores is\r\n    undefined.\r\n  We will have more to say about what Java does with undefined variables later;\r\n    it is not a mistake to declare certain variables without initializing\r\n     them.\r\n  <p>\r\n  If we want to declare a variable and at the same time initialize it, we can\r\n    write something like <b>int gamesPlayed = 0;</b> explicitly telling Java\r\n    to declare the variable named <b>gamesPlayed</b> and store zero as its\r\n    value initially.\r\n  <p>\r\n  In fact, we can declare a few variables in the same declaration: e.g., \r\n    <b>double angle, magnitude;</b> declares two variables, both of type\r\n    <b>double</b> and both storing undefined values.\r\n  In multi-variable declarations, all the variables are declared to be of\r\n    the same type -the one type that starts the declaration.\r\n  <p>\r\n  If we want to declare and initialize multiple variables in a single\r\n    declaration (using the repetition in the <i>variable-declarators</i>\r\n    EBNF rule), we must explicitly specify the initial value <b>for each\r\n    variable</b>.\r\n  For example, <b>int n = 0, sum = 0;</b> initializes each variable to zero.\r\n  WARNING: <b>int n,sum = 0;</b> initializes <b>sum</b> to zero, but leaves\r\n    <b>n</b> uninitialized; making this mistake is common for beginning\r\n    programmers.\r\n  In fact, Java always executes declarations with multiple variables as a\r\n     sequence of  declarations of single variables.\r\n   So executing <b>int n,sum = 0;</b> is equivalent to executing\r\n   <b>int n;</b> then <b>int sum = 0;</b>, which makes this problem more\r\n   obvious.\r\n  <p>\r\n  Java imposes a syntax constraint on initialized variables: the declared\r\n     <i>type</i> of the variable (specified at the start of the declaration)\r\n    must be compatible with the type of the <i>expression</i>.\r\n  We will discuss \"compatibility\" more, when we discuss implicit conversions;\r\n    for now, assume that compatible means that the two types must be the same.\r\n  <p>\r\n  So in the declaration <b>int n = true;</b> although the EBNF rules are\r\n    correctly followed, the Java compiler will detect and report a syntax\r\n    constraint error because <b>true</b> (a <b>boolean</b> literal) is not an\r\n    <b>int</b> value; likewise <b>boolean atCapacity = 0;</b> exhibits the\r\n    same kind of error in reverse.\r\n  <p>\r\n  To be truthful, Java will in fact automatically convert an <b>int</b> value\r\n    into a <b>double</b> if necessary , so <b>double x = 1;</b> is legal, and\r\n    is treated as equivalently to <b>double x = 1.;</b>\r\n  More obscurely, Java will automatically convert a <b>char</b> value into an\r\n    <b>int</b> value (and vice-versa) if necessary.\r\n  We will learn more about \r\n  <a href=\"#ImplicitConversion\" target=\"main\">implicit type conversion</a>\r\n    later in this lecture. \r\n  <p>\r\n  Programmers often use line-oriented comments (here called side-bar comments)\r\n     in declarations to document some interesting facet of a variable that is\r\n     not captured by even a well-chosen name.\r\n  For example, in the declarations statements\r\n  <pre><b>    double  tankSize;        //Gallons\r\n    double  mileage;         //Miles/Gallon</b></pre>\r\n  Here the programmer has used the comments to describe the units of the\r\n    quantity the variable stores.\r\n  Extending the variable name to <b>tankSizeInGallons</b> is probably making\r\n    it a bit too long.\r\n  Note that for this style of declaration/comment, we declare just one variable\r\n    per declaration statement.\r\n  Pragmatically, most declarations declare just one variable.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<a name=\"DrawingDeclarations\">\r\n<hr align=\"left\" width=\"33%\">\r\n\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Drawing Declarations<br>(primitive and reference types)</b></td>\r\n<td width =\"80%\">\r\n  Throughout the semester, we will learn a variety of graphic aids to help us\r\n    understand and analyze the meanings of Java language constructs.\r\n  We will start here, learning how to draw simple pictures that illustrate the\r\n     meanings of declarations.\r\n  Some students fail to appreciate the power of such simple pictures, when\r\n    drawn correctly: but time and time again these pictures -often used in much\r\n    more complicated contexts, as in class instance variables- can provide\r\n    insight into the meaning/semantics of the Java language, as we will see\r\n    repeatedly.\r\n  <p>\r\n  To illustrate the meaning of a declaration, we draw a box: we label the box\r\n    on the top left with the variable's type and on the top right with the\r\n    variable's name; we store the initial value (if any) inside the box; if\r\n    the declarator specifies no initialization option, we write a question\r\n    mark inside the box.\r\n  So, we always write something in each box: a value of the right type or a\r\n    question mark (not a <b>char</b> or <b>String</b> literal: just a question\r\n    mark).\r\n  <p>\r\n  There are two major categories of types in Java: primitive and reference.\r\n  All primitive types are fixed in the language, named by keywords; we will\r\n    learn more about, and repeatedly use the primitive types <b>int</b>,\r\n    <b>double</b>, <b>boolean</b>, and <b>char</b>. \r\n  All reference types come from class libraries that are written by\r\n    programmers\r\n  Right now, the only reference type that we currently know is <b>String</b>,\r\n     which is declared in the standard Java library.\r\n  We will learn about other reference types soon, and how to declare our own\r\n    new reference types a bit later.\r\n  The <b>String</b> reference type is special, because it is the only\r\n    one that also has literal values..\r\n  <p>\r\n  The only difference between primitive and reference types is what can appear\r\n    inside the box in the picture of a variable.\r\n  Variables declared of a primitive type store values; variables declared of a\r\n    reference type store references.\r\n  For a variable of a primitive type, we write in its box either a question\r\n    mark or a literal of the declared  type.\r\n  For a variable of a reference type, we write in its box either a question\r\n    mark, the literal value <b>null</b> (usable for all reference types: it\r\n    means that the variable refers to nothing), or an arrow (called a\r\n    reference) that leads to an <b>object</b> (an oval labelled by the same\r\n    type) that stores a collection of data (for <b>String</b>s, the collection\r\n    of characters that comprise the <b>String</b>'s value).\r\n  <p>\r\n  We will learn much much more about primitive and reference types later.\r\n  For now, it is critical just that you understand, given a declaration, how\r\n    to illustrate its meaning with a picture.\r\n  The pictures below illustate the meaning of the following declarations.\r\n  <pre><b>    int     a;\r\n    int     b = 0;\r\n    boolean c = false;\r\n    String  d;\r\n    String  e = null;\r\n    String  f = \"Hello\";\r\n  </b></pre>\r\n  <p>\r\n<img src=\"images/declarations.gif\"></image><p>\r\n  We will explore such illustrations further when we learn about\r\n    <b>state-change</b> operators in this lecture.\r\n  We will extend the use of such illustrations later when we learn about using\r\n    other kinds of variables: <b>parameter</b> variables declared in methods;\r\n    <b>instance</b> variables declared in bjects constructed from classes.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Operator Prototypes -->\r\n\r\n<a name=\"Prototypes\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Operator Prototypes and Signatures<br>(introducing exceptions)</b></td>\r\n<td width =\"80%\">\r\n   There are two aspects to describing operators in Java.\r\n   <ol>\r\n     <li>Describe their syntax via <b>prototypes</b>\r\n         <ul>\r\n           <li>what <b>type</b> of operand(s) they work on\r\n           <li>what <b>type</b> of result they produce\r\n           <li>whether they can throw any exceptions\r\n         </ul>\r\n     <li>Describe their semantics/meaning in English\r\n         <ul>\r\n           <li>how they compute the value of the result from the operand(s)\r\n           <li>under what conditions they throw an exception\r\n         </ul>\r\n   </ol>\r\n  We can specify the syntax of a prototype formally as\r\n  <p>\r\n  <i>return-type</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp \r\n       &nbsp<= <i>type</i><br> \r\n  <i>operand-types</i> &nbsp &nbsp &nbsp &nbsp <= <i>type</i>{,<i>type</i>}<br> \r\n  <i>exception-identifier</i> <= ArithmeticException | ... (we will learn more more later)<br> \r\n  <i>exception-types</i> &nbsp &nbsp &nbsp \r\n       <= <i>exception-identifier</i>{,<i>exception-identifier</i>}<br> \r\n  <br>\r\n  <i>prototype</i> <= <i>return-type</i> <i>operator</i> ([<i>operand-types</i>]) [throws <i>exception-types</i>]<br> \r\n  <p>\r\n   So, prototypes start with the type of the result returned by the operator,\r\n     followed by the operator itself, followed by a pair of parentheses\r\n     (with the type(s) of the operand(s), if any, separated by commas, on the\r\n      inside).\r\n   For example, each of the following lines specifies an operator prototype:\r\n   <pre><b>      int     + (int,int)\r\n      double  - (double)\r\n      int     * (int,int)\r\n      double  * (double,double)</b></pre>\r\n   The first prototype means that when Java adds two <b>int</b>s (with the\r\n      <b>+</b> operator), the result is an <b>int</b>.\r\n   The second prototype means that when Java negates a <b>double</b> (with the\r\n     <b>-</b> operator), the result is a <b>double</b>.\r\n   The third prototype means that when Java multiplies two <b>int</b>s (with\r\n     the <b>*</b> operator), the result is an <b>int</b>.\r\n   The fourth prototype meants that when Java multiplies two <b>double</b>s\r\n    (with the <b>*</b> operator), the result is a <b>double</b>.\r\n   <p>\r\n   Of course, we already know the semantics/meanings of addition, negation,\r\n     and multiplication in mathematics, so we do not need to discuss them here.\r\n   We will soon see prototypes for more interesting operators, such as\r\n   <pre><b>      boolean <  (int,int)\r\n      boolean && (boolean,boolean)</b></pre>\r\n   The first prototype means that when Java compares two <b>int</b>s (with the\r\n      <b>&lt</b> operator), the result is a <b>boolean</b>; you probably\r\n      already know the semantics of this kind of comparison too.\r\n   The second prototype means that when Java <b>and</b>s together (that is how\r\n     the <b>&&</b> operator is pronounced) two <b>boolean</b>s, the result is\r\n     a <b>boolean</b>; if you have studied logic or truth tables (which we\r\n     will do below) you might know the semantics of this operation too (what\r\n     result is produced from what operands).\r\n   <p>\r\n   As we learn these and more operators in Java, we will first present their\r\n     syntax (with prototypes) and then their semantics (using English and other\r\n     tools).\r\n   <p>\r\n   Finally, some operators specify that they throw exceptions.\r\n   An operator throws an exception if it cannot correctly compute a result\r\n      for its operand(s).\r\n   For example, integer division (the <b>/</b> operator in Java) cannot compute\r\n     a result if its denominator is zero.\r\n   A prototype indicates this information by using the keyword <b>throws</b>\r\n     followed by the identifier <b>ArithmeticException</b> (about which we will\r\n     learn many more details later).\r\n   So the prototype for integer division is fully written as\r\n   <pre><b>      int / (int,int) throws ArithmeticException</b></pre>\r\n   <p>\r\n   A signature is a subset of the information in a prototype; it includes just\r\n     the information about the types of operands (not the return type and not\r\n     the exceptions).\r\n  We can specify the syntax of a signature formally (reusing some of the EBNF\r\n     rules written above) as\r\n  <p>\r\n  <i>signature</i> <= <i>operator</i> ([<i>operand-types</i>])<br> \r\n  <p>\r\n  In fact, using this EBNF rule, we could rewrite the <i>prototype</b> rule as\r\n    simply\r\n  <p>\r\n  <i>prototype</i> <= <i>return-type</i> <i>signature</i> [throws <i>exception-types</i>]<br> \r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Terminology -->\r\n\r\n<a name=\"Terminology\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Operator Terminology</b></td>\r\n<td width =\"80%\">\r\n  A bit of terminology will make it easier to discuss and explore operators.\r\n  <ul>\r\n    <li>Number of Prototypes\r\n      <ul><li>An operator is <b>overloaded</b> if it has more than one\r\n                prototype: e.g, the <b>*</b> operator above has one prototype\r\n                for <b>int</b> operands and one for <b>double</b> operands,\r\n                hence it is overloaded.\r\n          <li>The term overloaded is not a \"bad\" term; in fact, most Java\r\n                operators are overloaded.\r\n          <li>Overloaded operators must have different signatures: i.e.,\r\n                either a different number of operands or the same number but\r\n                with different types for some operands.\r\n          <li>Given this restriction, Java can use the types of the operands to\r\n                 determine which prototype to use.\r\n          <li>Note that we cannot have the following two prototypes for\r\n               the <b>/</b><br>\r\n               &nbsp &nbsp int &nbsp &nbsp &nbsp &nbsp/ (int,int)<br>\r\n               &nbsp &nbsp double  / (int,int)</b><br>\r\n              because they both have the same signature: <b>/ (int,int)</b>\r\n      </ul>\r\n    <li>Number of Operands\r\n      <ul><li><b>Unary</b> operators have one operand (e.g., the negate\r\n              operator; think of a <b>un</b>icycle, with one wheel).\r\n          <li><b>Binary</b> operators have two operands (e.g., the multiply\r\n              operator; think of a <b>bi</b>cycle, with two wheels).</ul>\r\n    <li>Operator Location\r\n      <ul><li><b>Infix</b> operators are written in-between their operands\r\n             (e.g., <b>3*5</b>; infix operators are binary).\r\n          <li><b>Prefix</b> operators are written before their operand\r\n             (e.g., <b>-5</b>; prefix operators are unary).\r\n          <li><b>Postfix</b> operators are written after their operand\r\n             (e.g., <b>Count++</b>; postfix perators are unary)</ul>\r\n  </ul>\r\n  It is important to gain an intuitive understanding of these terms now,\r\n    because we will use them repeatedly throughout the semester.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Operators in Java -->\r\n\r\n<a name=\"Operators\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Operators in Java</b></td>\r\n<td width =\"80%\">\r\n  Java contains a large number of operators, but most fall into only a few categories.\r\n  <pre><b>    Arithmetic          +  -  *  /  %\r\n    Relational          ==  !=  <  >  <=  >=\r\n    Logical             !  &&  ||\r\n    State Change        ++  --  =  +=  -=  /=  %=  ...\r\n    Textual             +</b></pre>\r\n  In this lecture we will examine each of these categories of operators, first\r\n    examining their syntax (with prototypes) and then examining their \r\n    semantics (using English, operand/result tables, etc.)\r\n  Although there are other operators in Java, these are by far the most\r\n    common and useful ones.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- + Operator -->\r\n\r\n<a name=\"+Operator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The + Operator: Add/Catenate</b></td>\r\n<td width =\"80%\">\r\n  The <b>+</b> operator is overloaded in Java, with the following arithmetic\r\n    prototypes.\r\n  <pre><b>    int    + (int)\r\n    double + (double)\r\n    int    + (int,int)\r\n    double + (double,double)</b></pre>\r\n  Let us take a look at the semantics of each of these prototypes.\r\n  We say that \"Java evaluates operators, to produce results from operands.\"\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Prototype</th><th>Semantics</th><th>Examples</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td><pre><b>int    + (int)</b></pre></td>\r\n    <td>A unary prefix operator; its result is the same as its operand.</td>\r\n    <td><b>+7</b> evaluates to <b>7</b></td>\r\n  <tr valign=\"top\"><td><pre><b>double + (double)</b></pre></td>\r\n    <td>A unary prefix operator; its result is the same as its operand.</td>\r\n    <td><b>+7.25</b> evaluates to <b>7.25</b></td>\r\n  <tr valign=\"top\"><td><pre><b>int    + (int,int)</b></pre></td>\r\n    <td>A binary infix operator; its result is the sum of its operands.</td>\r\n    <td><b>3+5</b> evaluates to <b>8</b></td>\r\n  <tr valign=\"top\"><td><pre><b>double + (double,double)</b></pre></td>\r\n    <td>A binary infix operator; its result is the sum of its operands.</td>\r\n    <td><b>2.4+5.1</b> evaluates to <b>7.5</b></td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  The <b>+</b> operator is also a textual operator (called catenate), with the\r\n    following further prototypes (so it is highly overloaded).\r\n  Notice that in each case at least one operand is a <b>String</b> and the\r\n    final result is always a <b>String</b> too.\r\n  <pre><b>    String + (String,int)\r\n    String + (String,double)\r\n    String + (String,boolean)\r\n    String + (String,char)\r\n    String + (String,String)\r\n    String + (int,String)\r\n    String + (double,String)\r\n    String + (boolean,String)\r\n    String + (char,String)</b></pre>\r\n  Semantically, the <b>(String,String)</b> case is the simplest; it builds\r\n    a <b>String</b> containing all the characters in the first operand followed\r\n    by all of the characters in the second operand.\r\n  For example, <b>\"Hi\"+\"Low\"</b> evaluates to <b>\"HiLow\"</b>.\r\n  Next simplest is catenation of a <b>String</b> and <b>char</b> (regardless of\r\n    the order).\r\n  For example, <b>'a'+\"String\"</b> evaluates to <b>\"aString\"</b>.\r\n  In the other cases, the value (whether its type is <b>int</b>, <b>double</b>,\r\n    or <b>boolean</b>) is first automatically converted into an\r\n   <i>equivalent</i> <b>String</b> and then is catenated to the other operand\r\n     (which is already a <b>String</b>).\r\n  For example, <b>12+\" in a dozen\"</b> evaluates to\r\n    <b>\"12 in a Dozen\"</b> because the <b>int</b> value <b>12</b> is first\r\n       automatically converted into the <b>String</b> value <b>\"12\"</b>.\r\n  <p>    \r\n  Note that <b>1+1</b> results in <b>2</b> while <b>\"1\"+1</b> and <b>1+\"1\"</b>\r\n    both result in <b>\"11\"</b>.\r\n  <p>\r\n  Finally, note that <b>true+\" is a boolean\"</b> results in\r\n    <b>\"true is a boolean\"</b> because the <b>boolean</b> value <b>true</b> is\r\n    first automatically converted into the <b>String</b> value <b>\"true\"</b>.\r\n  <p>\r\n  Using <b>+</b> for catenation is very common in Java, when outputing various\r\n     types of information to the console.\r\n  You will become very familiar with this operator when you start writing\r\n    programs.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- - Operator -->\r\n\r\n<a name=\"-Operator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The - Operator: Negate/Subtract</b></td>\r\n<td width =\"80%\">\r\n  The <b>-</b> operator is overloaded in Java, with the following prototypes.\r\n  <pre><b>    int    - (int)\r\n    double - (double)\r\n    int    - (int,int)\r\n    double - (double,double)</b></pre>\r\n  Let us take a look at the semantics of each of these prototypes.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Prototype</th><th>Semantics</th><th>Examples</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td><pre><b>int    - (int)</b></pre></td>\r\n    <td>A unary prefix operator; its result is the negated value of its operand.</td>\r\n    <td><b>-7</b> evaluates to negative <b>7</b></td>\r\n  <tr valign=\"top\"><td><pre><b>double - (double)</b></pre></td>\r\n    <td>A unary prefix operator; its result is the negated value of its operand.</td>\r\n    <td><b>-7.25</b> evaluates to negative <b>7.25</b></td>\r\n  <tr valign=\"top\"><td><pre><b>int    - (int,int)</b></pre></td>\r\n    <td>A binary infix operator; its result is the difference between its first and second operands.</td>\r\n    <td><b>8-3</b> evaluates to <b>5</b></td>\r\n  <tr valign=\"top\"><td><pre><b>double - (double,double)</b></pre></td>\r\n    <td>A binary infix operator; its result is the difference between it first and second operands.</td>\r\n    <td><b>7.5-2.4</b> evaluates to <b>5.1</b></td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note that in Java, writing <b>-6</b> means negate the literal <b>6</b>.\r\n  Recall that all literals are non-negative, so <b>-6</b> technically is not\r\n    a literal: it is an operator and a literal; still, we will write <b>-6</b>\r\n    and often pretend it is purely a value (for example, when writing values\r\n    inside variables).\r\n  Seem confusing? Don't worry about this detail too much: don't let this\r\n    weird tree stop you from seeing the forest.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- * Operator -->\r\n\r\n<a name=\"*Operator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The * Operator: Multiply</b></td>\r\n<td width =\"80%\">\r\n  The <b>*</b> (multiply) operator is overloaded in Java, with the following prototypes.\r\n  <pre><b>    int    * (int,int)\r\n    double * (double,double)</b></pre>\r\n  Note that unlike <b>+</b> and <b>-</b> there is no unary version of the <b>*</b> operator.\r\n  Let us take a look at the semantics of each of these prototypes.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Prototype</th><th>Semantics</th><th>Examples</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td><pre><b>int    * (int,int)</b></pre></td>\r\n    <td>A binary infix operator; its result is the product of its operands.</td>\r\n    <td><b>3*5</b> evaluates to <b>15</b></td>\r\n  <tr valign=\"top\"><td><pre><b>double * (double,double)</b></pre></td>\r\n    <td>A binary infix operator; its result is the product of its operands.</td>\r\n    <td><b>4.2*5.8</b> evaluates to <b>24.36</b></td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note that unlike mathematics, there is no \"implicit\" multiplication in Java.\r\n  Assuming that we declare <b>int A,B;</b> then <b>3A</b> and <b>3(A+B)</b>\r\n    are NOT LEGAL expressions: they would have to be written explicitly with the <b>*</b>\r\n    operator as <b>3*A</b> and <b>3*(A+B)</b>.\r\n  We will study expressions (with arbitrarily complicated combinations of the operators that\r\n    we are discussing here) later in this lecture.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- / Operator -->\r\n\r\n<a name=\"DivideOperator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The / Operator: Divide</b></td>\r\n<td width =\"80%\">\r\n  The <b>/</b> (divide) operator is overloaded in Java, with the following prototypes.\r\n  <pre><b>    int    / (int,int)       throws ArithmeticException\r\n    double / (double,double)</b></pre>\r\n  Note that like the <b>*</b> operator, there is no unary version of the\r\n     <b>/</b> operator.\r\n  Let us take a look at the semantics of each of these prototypes.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Prototype</th><th>Semantics</th><th>Examples</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td><pre><b>int    / (int,int)</b></pre></td>\r\n    <td>A binary infix operator; its result is (the integer part of) the first\r\n          operand divided by the second (ignore the remainder).\r\n        If the second operand is <b>0</b>, this operator throws an\r\n          exception.</td>\r\n    <td><b>13/5</b> evaluates to <b>2</b></td>\r\n  <tr valign=\"top\"><td><pre><b>double / (double,double)</b></pre></td>\r\n    <td>A binary infix operator; its result is the first operand divided by\r\n          the second.\r\n        If the second operand is <b>0.</b>, this operator returns the result\r\n           <b>Infinity</b>\r\n           (if the first operand is positive), or <b>-Infinity</b> (if the\r\n            first operand is negative),\r\n          or <b>NaN</b> (Not a Number, if the first operand is also zero).</td>\r\n    <td><b>13./5.</b> evaluates to <b>2.6</b></td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here are the first \"nonintuitive\" semantics for a Java arithmetic operator.\r\n  When Java divides two <b>int</b> values (<b>13</b> by <b>5</b>) the prototype\r\n    tells us that the result must be an <b>int</b>.\r\n  So, Java takes the \"mathematical\" answer, <b>2.6</b> (the one that is\r\n    intuitive to us)  and <b>truncates</b> it (throws away <b>.6</b> the\r\n    non-integral part).\r\n  Only when two <b>double</b> values are divided does Java keep the decimal\r\n    part in the returned result.\r\n  Students find this difference strange and nonintuitive; they often aren't\r\n    careful, when using the <b>/</b> operator in their programs, to distinguish\r\n    between <b>int</b> and <b>double</b> operands.\r\n  <p>\r\n  Finally, if the second operand to the <b>/</b> operator (with <b>int</b>\r\n    operands) is zero, the operator does not compute a result, but instead\r\n    throws an exception.\r\n  Throwing an exception is like throwing up your hands and saying, \"I cannot\r\n     do the computation\".\r\n  At the end of our study of Java statements, we will learn how catch (handle)\r\n    thrown exceptions, so throwing an exception doesn't mean that the program\r\n    must stop.\r\n  <p>\r\n  The case for the result of the division of two <b>double</b> values is\r\n    stranger.\r\n  There is a long and tortured history of how computers should deal with this,\r\n    and  related, problems involving anomalous operations on\r\n    <b>double</b> values, which was finally resolved in the IEEE 754 standard.\r\n  We will ignore this issue now, and the problem shouldn't come up in simple\r\n     programs; but remember that if you print a <b>double</b> and it appears\r\n     as <b>Infinity</b>, <b>-Infinity</b> or <b>NaN</b> it means you divided\r\n     by zero, which probably means you made a mistake in your program.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- % Operator -->\r\n\r\n<a name=\"%Operator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The % Operator: Remainder</b></td>\r\n<td width =\"80%\">\r\n  The <b>%</b> (remainder) operator is overloaded in Java with the following\r\n    two prototypes.\r\n  <pre><b>    int % (int,int) throws ArithmeticException\r\n    double % (double,double)</b></pre>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Prototype</th><th>Semantics</th><th>Examples</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td><pre><b>int % (int,int)</b></pre></td>\r\n    <td>A binary infix operator; its result is the <b>remainder</b> left when\r\n          the first operand is divided by the second.\r\n        Technically, the result's sign is the same sign of its first operand;\r\n          the result's magnitude is the same as the remainder when the absolute\r\n          values of its operands are divided.\r\n        If the second operand is <b>0</b>, this operator throws the\r\n          <b>ArithmeticException</b>.</td>\r\n    <td><b>13%5</b> evaluates to <b>3</b>, because <b>5</b> goes into <b>13</b>\r\n          just <b>2</b> times (<b>13/5</b> evaluates to <b>2</b>) leaving a\r\n          remainder of <b>3</b>; <b>-13%5</b> evaluates to <b>-3</b>\r\n          because the sign of its first operand is negative and its magnitude\r\n          is the same as <b>13%5</b>; <b>13%-5</b> evaluates to <b>3</b>\r\n          because the sign of its first operand is positive and its magnitude\r\n          is the same as <b>13%5</b>; <b>-13%-5</b> evaluates to <b>-3</b>\r\n          because the sign of its first operand is negative and its magnitude\r\n          is the same as <b>13%5</b></td>\r\n  </tbody>\r\n  <tr valign=\"top\"><td><pre><b>double % (double,double)</b></pre></td>\r\n    <td>This space intentionally left blank.</td>\r\n    <td>This space intentionally left blank.</td>\r\n  </table>\r\n  <p>\r\n  Although most students have never seen this operator in mathematics (but\r\n    have seen remainders in long division), it is sometimes useful in Java\r\n    programming (and certainly not that hard to understand, at least in the\r\n    case of non-negative integers).\r\n  Therefore, you must know its prototype and semantics for non-negative\r\n    integers only.\r\n  <p>\r\n  Obviously the <b>/</b> and <b>%</b> operators (with <b>int</b> operands) are\r\n    related: we can call <b>/</b> the <b>quotient</b> operator and <b>%</b>\r\n    the remainder operator.\r\n  Generally: <b>x%y</b>, when both are non-negative integers, returns the same\r\n     value as <b>x-(x/y)*y</b>: try evaluating this second formula for a few\r\n     values (remember to truncate after division).\r\n  <p>\r\n  Two interesting facts are that if we declare <b>x</b> to be an <b>int</b>\r\n    and store a non-negative value in it, <b>x%10</b> is the last digit of that\r\n    number and <b>x/10</b> is every digit but the last one.\r\n  For example, if we declare <b>int x = 4125;</b> then <b>x%10</b> evaluates to\r\n    <b>5</b> and <b>x/10</b> evaluates to <b>412</b>.\r\n  You must be able to understand and use both \"division\" operators in your\r\n     program.\r\n  <p>\r\n  Finally, as with the <b>/</b> operator, the <b>%</b> operator throws the\r\n    <b>ArithmeticException</b> if its second operand is zero.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Relational Operators -->\r\n\r\n<a name=\"RelationalOperators\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Relational Operators<br>(for primitive types only)</b></td>\r\n<td width =\"80%\">\r\n  Java includes sixth relational operators (<b> == </b> &nbsp <b> != </b>\r\n    &nbsp <b> < </b> &nbsp <b> <= </b> &nbsp <b> > </b> &nbsp <b> >= </b>).\r\n  The first pair are known as the equality operators, the final four are\r\n    known as the inequality operators.\r\n  The equality operators are overloaded for all pairs of the same\r\n      <b>primitive</b> type; the inequality operators are\r\n      overloaded likewise, except <b>not</b> for the <b>boolean</b> type.\r\n  The result produced by each is a <b>boolean</b> value.\r\n  While only the prototypes of the <b>==</b> operator are shown below, the\r\n    other relational operators have similar prototypes too.\r\n  <p> \r\n  Note the <b>==</b> computes \"is equal to\" and <b>!=</b> computes\r\n    \"is not equal to\"; <b>&lt</b> computes \"is less than\"; <b>&lt;=</b>\r\n    computes\r\n    \"is less than or equal to\"; <b>&gt</b> computes \"is greather than\";\r\n    <b>&gt=</b> computes \"is greater than or equal to\". \r\n  <pre><b>    boolean == (int,int)\r\n    boolean == (double,double)\r\n    boolean == (boolean,boolean)\r\n    boolean == (char,char)</b></pre>\r\n  So each relational operator compares two values of the same type and produces\r\n    a <b>boolean</b> result.\r\n  We must learn to think of an operator like <b>&lt</b> just as we would think\r\n    about an operator like <b>+</b>.\r\n  Both take two operands and computes a result (in the former case a\r\n    <b>boolean</b>; in the later case some numeric value).\r\n  So we say <b> 3 < 5 </b> computes the result <b>true</b> just as we would\r\n    say <b> 3 + 5 </b> computes the result <b>8</b>.\r\n  We must learn to think of all Java operators, regardless of their operand\r\n    and result types, as computing a value in this way.\r\n  <p>\r\n  Semantically, these operators work as we would expect on numeric\r\n    (<b>int</b> and <b>double</b>) values.\r\n  <p>\r\n  Again, one can compare <b>boolean</b> values with <b>==</b> and </b>!=</b>\r\n    but not the other four relational operators.\r\n  <p>\r\n  For the text type <b>char</b>, the values compare according to their ASCII\r\n    values: each <b>char</b> value can convert to/from a small <b>int</b>\r\n    according to the\r\n     <a href=\"../../../common/handouts/ascii.html\">ASCII</a> conversion table.\r\n  You should certainly NOT memorize the ASCII table, but programmers should\r\n    know that <b>'0'<'1'<...<'9' < 'A'<'B'<...<'Z' < 'a'<'b'<...<'z'</b>\r\n    in ASCII.\r\n  <p>\r\n  The inequality operators do NOT work at all for reference types.\r\n  The equality operators do NOT work in a straightforward way for\r\n    variables/values of the type <b>String</b>, which you should recall is a\r\n    class type and not a primitive type.\r\n  We will discuss later various methods for comparing <b>String</b> values. \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Logical Operators -->\r\n\r\n<a name=\"LogicalOperators\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Logical Operators</b></td>\r\n<td width =\"80%\">\r\n  Java includes three logical operators (<b> ! </b> &nbsp <b> && </b> &nbsp\r\n    <b> || </b>) which are not overloaded: each has just one prototype, with\r\n    <b>boolean</b> operands and a <b>boolean</b> result.\r\n  The <b>!</b> operator is read \"not\"; the <b>&&</b> operator is read \"and\";\r\n    the <b>||</b> operator is read \"or\".\r\n  <pre><b>    boolean !  (boolean)\r\n    boolean && (boolean, boolean)\r\n    boolean || (boolean, boolean)</b></pre>\r\n  Semantically, these operators are described by the following truth table.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr align=\"center\">\r\n  <th><i>A</i></th><th><i>B</i></th><th><i>A</i> && <i>B</i></th><th><i>A</i> || <i>B</i></th><th>!<i>B</i></th>\r\n  </thead>\r\n  <tbody> \r\n  <tr align=\"center\"><td><b>false</b></td><td><b>false</b></td><td><b>false</b></td><td><b>false</b></td><td><b>true</b></td>\r\n  <tr align=\"center\"><td><b>false</b></td><td><b>true</b></td><td><b>false</b></td><td><b>true</b></td><td><b>false</b></td>\r\n  <tr align=\"center\"><td><b>true</b></td><td><b>false</b></td><td><b>false</b></td><td><b>true</b></td><td></td>\r\n  <tr align=\"center\"><td><b>true</b></td><td><b>true</b></td><td><b>true</b></td><td><b>true</b></td><td></td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Programmers must memorize these tables to be able to analyze expressions\r\n    that use these operators.\r\n  Here are some short-cuts.\r\n  Note that the result of the <b>&&</b> operator is <b>true</b> only when both\r\n    of its operands are <b>true</b>.\r\n  Note that the result of the <b>||</b> operator is <b>false</b> only when\r\n    both of its operands are <b>false</b>.\r\n  Note that the <b>!</b> operator just has one operand, so it looks a bit\r\n    different in the truth table.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Implicit Conversion -->\r\n\r\n<a name=\"ImplicitConversion\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Implicit Conversion</b></td>\r\n<td width =\"80%\">\r\n  What is Java to make of <b>3 + 5.2</b>?\r\n  We have seen that the arithmetic <b>+</b> operator has two binary\r\n    prototypes, in which either both operands are <b>int</b> or both are\r\n    <b>double</b>.\r\n  In fact, there are actually two different circuits in computers for\r\n    arithmetic: one for adding pairs of <b>int</b>s and one for adding pairs\r\n    of <b>double</b>s.\r\n  Every addition must go through one of these two circuits.\r\n  <p>\r\n  Java could just rejectusing this combination of operator and operands.\r\n  Instead, when Java sees a binary operator with one <b>int</b> operand and one\r\n    <b>double</b> operand, it automatically converts the <b>int</b> value into\r\n    a <b>double</b> and then uses the <b>double</b>-operands prototype of\r\n    <b>+</b>(and its related circuit) to do the  addition.\r\n  This is called <b>implicit conversion</b>.\r\n  Java does implicit conversion (always <b>int</b> to <b>double</b>) whenever\r\n    a binary arithmetic operator has different numeric types for its operands.\r\n  <p>\r\n  Java performs one other implicit conversion when necessary: a <b>char</b> is\r\n    implicitly converted to an <b>int</b> (according to its value in the ASCII\r\n    table).\r\n  So in <b>'A'+1</b>, the <b>char 'A'</b> is first implicitly converted to the\r\n    <b>int 65</b> so that it can be added to the <b>int 1</b> finally producing\r\n    an <b>int</b> result of <b>66</b>.\r\n  In fact, in the expression <b>1.5+'A'</b>, <b>'A'</b> is first implicitly\r\n    converted to the <b>int 65</b> and then implicitly converted to the\r\n    <b>double 65.</b> finally producing an <b>double 66.5</b> as a result.\r\n  <p>\r\n  Finally, the expression <b>'5'-'0'</b> implicitly converts both <b>char</b>\r\n    values to <b>int</b> (<b>53</b> and <b>48</b> respectively: see the ASCII\r\n    table) and then performs subtraction: the result in this case is the\r\n    <b>int 5</b>.\r\n  In fact, if we declare <b>char d = '8';</b> (or initialize it by any other \r\n    character that is a digit), then writing <b>d-'0'</b> results in an\r\n    <b>int</b> equivalent to the digit (in this case <b>8</b>).\r\n  Note that the ASCII value of <b>'8'</b> is <b>56</b> and of <b>'0'</b> is\r\n   <b>48</b>.\r\n  <p>\r\n  Collectively, these implicit conversion are called promotion, which always\r\n    works in just one way: <b>char</b> promoted to <b>int</b> promoted to\r\n    <b>double</b>.\r\n  No promotion loses information: every <b>char</b> can be represented as an\r\n    equivalent <b>int</b> and every <b>int</b> can be represented as a\r\n    equivalent <b>double</b>.\r\n  Notice that the remaining primitive type, <b>boolean</b>,\r\n   plays no part in promotion.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- State Change Operators -->\r\n\r\n<a name=\"StateChangeOperators\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>State-Change Operators<br>(primitive types)</b></td>\r\n<td width =\"80%\">\r\n  Most operators in Java just examine their operands and produce a result\r\n    (e.g., <b>*</b> produces a result that is the product of its two operands).\r\n  But, there is a special category of Java operators that not only produce a\r\n    result, but also change the state of one of its operands (which is\r\n    restricted, by a syntax constraint,  to be the name of a variable).\r\n  Operators in this category are called <i>state-change</i> operators.\r\n  <p>\r\n  The most common state-change operator in Java is the <b>=</b> operator. \r\n  The <b>=</b> operator (known as the <i>assignment</i> or <i>stores</i>\r\n    operator) is overloaded for each of the primitive types that we know in\r\n    Java, with the following prototypes.\r\n  <pre><b>   int     = (int    , int)\r\n   double  = (double , double)\r\n   boolean = (boolean, boolean)\r\n   char    = (char   , char)  </b></pre>\r\n  For these binary operators, Java restricts the first operand to be the name\r\n    of a variable:  so <b>x=0</b> is a legal expression but <b>0=x</b> is\r\n    illegal, according to this restriction.\r\n  <p>\r\n  Semantically, the value of the right operand (which can be any expression) is\r\n    stored into the variable specified by the left operand (which is restricted\r\n    to be a variable name), <b>AND</b> this value is also the result of the\r\n    expression.\r\n  So, we can use state-change operators to change the state (value) stored in\r\n    any variable.\r\n  <p>\r\n  For example, if we declare <b>int x = 0;</b> and then evaluate the\r\n    expression <b>x = x+1</b> Java first computes <b>x+1</b> (we will soon\r\n    learn that <b>=</b> has is lower precedence than <b>+</b>, so the\r\n    <b>+</b> operator is evaluated first) whose result is <b>1</b>, then Java\r\n    uses the <b>=</b> operator, which changes the value stored in <b>x</b> to\r\n    <b>1</b>; the result (of the entire expression) is <b>1</b> also.\r\n  If we evaluate the expression <b>x = x+1</b> again, Java changes the value\r\n     stored in <b>x</b> to <b>2</b>; the result (of the entire expression) is\r\n    <b>2</b> also.\r\n    char   += (char,char)</b></pre>\r\n  As with other state-chance operators, there is a syntax constraint that the\r\n    first operand is the name of a variable.\r\n  <p>\r\n  Semantically, the expression <b>x+=<i>e</i></b> is a simpler way to write\r\n    <b>x = x+(<i>e</i>)</b> (and  similarly for the operators <b> -= </b>\r\n    &nbsp <b> *= </b> &nbsp <b> /= </b> &nbsp and <b> %= </b>).\r\n  So <b>x+=2</b> computes <b>x+2</b> and then stores the result into <b>x</b>;\r\n   this new result is also the resuklt of the entire expression: it is\r\n    equivalent to <b>x=x+2</b>.\r\n  <p>\r\n  Finally, Java includes two very special operators <b>++</b> and <b>--</b>\r\n   (which increment and decrement variables by <b>1</b>).\r\n  Both operators can be used in a prefix or postfix form; they are overloaded\r\n    for the following types ( and the are restricted to operate on variables\r\n    names only (we cannot write <b>0++</b>).\r\n  <pre><b>    int    ++ (int)               int    -- (int)\r\n    double ++ (double)            double -- (double)\r\n    char   ++ (char)              char   -- (char)</b></pre>\r\n  Semantically, for both prefix and postfix <b>++</b> the value of the variable\r\n    gets incremented by 1; if the <b>++</b> is written before the variable\r\n    (a prefix operator), the result of the operator is the NEW/CURRENT value\r\n    stored in the variable; if the <b>++</b> is written after the variable\r\n    (a postfix operator), the result of the operator is the  OLD/ORIGINAL value\r\n     stored in  the variable.\r\n  Likewise for <b>--</b> which subtracts 1 (decrements) from its variable.\r\n  <p>\r\n  If the variable is of type <b>char</b> it is changed to store the character\r\n    one higher (for <b>++</b>) and one lower (for <b>--</b>). \r\n  <p>\r\n  So, if we declare <b>int x=0, y;</b> and then write <b>y = x++</b> then\r\n    <b>x</b> is incremented from <b>0</b> to <b>1</b>, but its result produced\r\n    by this operator is <b>0</b> (the old/original value stored in <b>x</b>),\r\n    which is stored into <b>y</b>, and this value (<b>0</b>) is the result of\r\n    the entire expression.\r\n  If we instead write <b>y = ++x</b> then <b>x</b> is incremented from\r\n    <b>0</b> to <b>1</b>, and its result is <b>1</b> (the new/current value\r\n    stored in <b>x</b>) which is stored into <b>y</b>, and this value\r\n   (<b>1</b>) is the result of the entire expression.\r\n  <p>\r\n  While the prefix/postfix distinction for these operators may seem strange,\r\n    they are both useful and we will see important uses of each soon.\r\n  <p>\r\n  To illustrate state change operators, we often use before/after pictures\r\n   (the same kind of pictures used to illustrate variable declarations).\r\n  For example, we can illustrate the meaning of <b>x=y</b> as follows.\r\n  <p>\r\n<img src=\"images/assignment.gif\"></image><p>\r\n  <p>\r\n  Next, we can illustrate the meaning of <b>y=x++</b> as follows.\r\n  <p>\r\n<img src=\"images/statechange2a.gif\"></image><p>\r\n  And finally, we can illustrate the meaning of <b>y=++x</b> as follows.\r\n  <p>\r\n<img src=\"images/statechange2b.gif\"></image><p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- == vs = -->\r\n\r\n<a name=\"Equals\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>= vs ==</b></td>\r\n<td width =\"80%\">\r\n  When programming, we must be careful to distinguish the <b>=</b> operator\r\n    from the <b>==</b> operator (many people pronounce both as \"equals\",\r\n    leaving it to the hearer to disambiguate which from context; more careful \r\n    Java programmers pronounce the second \"equals equals\" or \"double equals\").\r\n  After a few weeks using each, they won't seem so confusing.\r\n  <p>\r\n  As we have just learned, <b>=</b> is a state change operator: it changes the\r\n     state of its left operand (which must be a variable) to store the value of\r\n     its right operand (a value of the same type, or a value derived by\r\n    implicit conversion); its result is also the value stored.\r\n  Thus, a expression such as <b>x = x+1</b> serves to increment the value\r\n    stored in <b>x</b> by 1 (yes, there are other ways to do this as well).\r\n  <p>\r\n  On the other hand, <b>==</b> is not a state change operator: it compares the\r\n    two values of its operands (which must be of the same type, but neither\r\n    has to be a variable), and its result is always of type <b>boolean</b>; it\r\n    changes neither operand.\r\n  An expression such as <b>x == x+1</b> is syntactically legal, but completely\r\n    useless: it always computes the value <b>false</b> and has no other effect\r\n    (it changes no states of any variables involved).\r\n  <p>\r\n  Confusing <b>=</b> and </b>==</b> is common.\r\n  Be on the lookout for such mistakes, which can cause subtle bugs in your\r\n   programs.\r\n  In many cases the Java compiler will issue a warning if it suspects you have\r\n     misused one of these operators (we will see examples in the next lecture)\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Methods -->\r\n\r\n<a name=\"Methods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Mathematical Methods</b></td>\r\n<td width =\"80%\">\r\n  We can use a variety of mathematical <b>methods</b> (Java's name for\r\n    functions) in Java by using the <b>Math</b> class (we will examine how to\r\n    read classes soon, and write classes a bit later in the course).\r\n  We will specify the syntax of methods also by using prototypes (just as we\r\n    did with operators).\r\n  But instead of operator tokens, these methods are named by a class name\r\n   (e.g., <b>Math</b>) followed by the period separator, followed by the method\r\n    name).\r\n  When we learn more about classes, we will discuss this naming convention\r\n    further.\r\n  Here is a sampling of the prototypes of some useful methods in the\r\n   <b>Math</b> class.\r\n  <pre><b>    int    Math.abs    (int)\r\n    double Math.abs    (double)\r\n    int    Math.min    (int,int)\r\n    double Math.min    (double,double)\r\n    int    Math.max    (int,int)\r\n    double Math.max    (double,double)\r\n    double Math.pow    (double,double)\r\n    double Math.sqrt   (double)\r\n    double Math.log    (double)\r\n    double Math.log10  (double)\r\n    double Math.exp    (double)\r\n    double Math.cos    (double)\r\n    double Math.sin    (double)\r\n    double Math.tan    (double)\r\n    double Math.random ()</b></pre>\r\n  Semantically\r\n  <ul>\r\n    <li><b>abs</b> returns the absolute value of its operand (overloaded for\r\n      <b>int</b> and <b>double</b>).\r\n    <li><b>min</b> returns the minimum of its two operands (overloaded for\r\n       <b>int</b> and <b>double</b>).\r\n    <li><b>max</b> returns the maximum of its two operands (overloaded for\r\n       <b>int</b> and <b>double</b>).\r\n    <li><b>pow</b> returns the first operand (which must be non-negative\r\n       unless the second operand is integral: e.g., 3.)\r\n       raised to the power of the second operand: <b>pow(x,3.5)</b> computes\r\n       <b>x<sup>3.5</sup></b> if <b>x</b> is non-negative; otherwise it\r\n       returns <b>NaN</b>. \r\n    <li><b>sqrt</b> returns the square root of its operand (which must be\r\n        positive, otherwise returns <b>NaN</b>): <b>sqrt(x)</b> is better than\r\n        <b>pow(x,.5)</b> (faster and more accurate) although  both are legal. \r\n    <li><b>log</b> returns the logarithm (base e) of it operand (which must be\r\n        positive, otherwise returns <b>NaN</b>).\r\n    <li><b>log10</b> returns the logarithm (base 10) of it operand (which must\r\n        be positive, otherwise returns <b>NaN</b>).\r\n    <li><b>exp</b> returns the e raised to the power of its operand.\r\n    <li><b>cos</b> returns the cosine of its operand (which is expressed in\r\n          radians, not degrees)\r\n    <li><b>sin</b> returns the sine of its operand (which is expressed in\r\n          radians, not degrees)\r\n    <li><b>random</b> returns a random number in the range [0.,1.); e.g., this\r\n          semi-open interval specifies that it can return the value <b>0.</b>\r\n          but returns a value always strictly less than (never equal to)\r\n          <b>1.</b>\r\n  </ul>\r\n  We call/invoke these methods by specifying their full name (class and method,\r\n    separated by a period), and then enclosing the required operands (if any)\r\n    in parentheses (separated by commas).\r\n  This is the correct syntax for calling/invoking a method.\r\n  So writing <b>Math.max(3,4)</b> results in the <b>int 4</b>.\r\n  <p>    \r\n  The <b>random</b> method is interesting because it is the first one that we\r\n     have seen whose prototype specifies no operands.\r\n  Yet, we still must call it with parentheses, as we must for all methods:\r\n    <b>Math.random()</b>, which will effectively return a different, random,\r\n    result each time that it is called.\r\n  <p>\r\n  Note that none of these methods are state-change methods; they produce values\r\n    but do not change what is  stored in any variables used as operands.\r\n  So, given <b>int a = 3, b = 4;</b> then <b>Math.max(a,b)</b> also results in\r\n    the <b>int 4</b>, and neither <b>a</b> nor <b>b</b> changed: they still\r\n    store <b>3</b> and <b>4</b> respectively.\r\n  In fact, the Java programming language prohibits writing methods that change\r\n    the states of their operands: this is a bit too subtle to understand here,\r\n    but we will examine this statement and its ramifications soo.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- I/O -->\r\n\r\n<a name=\"IO\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Input/Output</b></td>\r\n<td width =\"80%\">\r\n  Java uses two methods for outputing information onto the console:\r\n    <b>print</b> and <b>println</b>.\r\n  These methods have funny prefixes: <b>System.out.</b>\r\n  When we learn more about classes and fields, we will discuss these prefixes\r\n    further.\r\n  For now, scan the overloaded prototypes of these methods.\r\n  <pre><b>    void   System.out.print  (int)\r\n    void   System.out.print  (double)\r\n    void   System.out.print  (boolean)\r\n    void   System.out.print  (char)\r\n    void   System.out.print  (String)\r\n\r\n    void   System.out.println()\r\n    void   System.out.println(int)\r\n    void   System.out.println(double)\r\n    void   System.out.println(boolean)\r\n    void   System.out.println(char)\r\n    void   System.out.println(String)</b></pre>\r\n  A <b>void</b> return type means that the method performs a command/action\r\n    (in this case displaying something on the console) only: there is no\r\n     resulting value that is returned.\r\n  If I ask my son what he did in school today, I expect him to answer; if I \r\n    ask him to clean up his room, I expect no answer but just for him to\r\n    perform an action (I actually don't expect him to clean up his room either,\r\n    but that has to do with the semantics of my son).\r\n  <p>\r\n  Each of the <b>print</b> methods displays a value in the console window and \r\n    stays on the same line (so any subsequent output will continue to be\r\n    displayed on that same line).\r\n  Each of the <b>println</b> methods displays a value in the console window\r\n    and then goes to the beginning of the next line.\r\n  In fact, writing just <b>System.out.println()</b> in a program (supplying no\r\n     operands to the method call) will print nothing and go to the beginning\r\n     of the next line.\r\n  So <pre><b>    System.out.print(\"A\");\r\n    System.out.println(\"B\");\r\n    System.out.println(\"C\");\r\n    System.out.print(\"D\");\r\n    System.out.print(\"E\");</b></pre>\r\n  displays the output <pre><b>    AB\r\n    C\r\n    DE</b></pre>\r\n  with the next output following on the same line after <b>E</b>\r\n  <p>\r\n  We can also accomplish the equivalent by carefully using the newline\r\n    escape characters: <b>System.out.print(\"AB\\nC\\nDE\");</b>\r\n  The <b>print</b> method processes the escape character <b>'\\n'</b>\r\n    by finishing the current line and starting a new line.\r\n  <b>System.out.print(\"A\\n\\nB\");</b> displays the output\r\n  <pre><b>    A\r\n\r\n    B</b></pre>\r\n  <p>\r\n  We frequently use the catenation operator (which always produces a\r\n    <b>String</b>) inside these methods: e.g., \r\n  if we declare <b>int gamesPlayed = 0;</b> and then give the command <pre>\r\n  <b>System.out.println(\"Games Played so far: \" + gamesPlayed);</b></pre>\r\n  Java will print <b>Games Played so far: 0</b>.\r\n  <p>\r\n  The <b>Prompt</b> class contains a variety of methods for inputing\r\n    information.\r\n  The prototypes for the simplest of these methods (there are more) are\r\n  <pre><b>    int    Prompt.forInt    (String)\r\n    int    Prompt.forInt    (String,int,int)\r\n    double Prompt.forDouble (String)\r\n    char   Prompt.forChar   (String,String)\r\n    String Prompt.forString (String)</b></pre>\r\n  In each case, the <b>String</b> operand specifies a message that the user\r\n    sees, prompting  him/her as to what information to enter.\r\n  <b>Prompt.forInt</b> is overloaded; its second version allows the programmer\r\n    to specify the smallest and largest allowable values (if the user inputs a\r\n    value outside this range, he/she is reprompted).\r\n  Likewise, the second <b>String</b> in the <b>Prompt.forChar</b> method\r\n    specifies all the characters that the user is allowed to enter (if the user\r\n    inputs a value outside this range, he/she is reprompted).\r\n  A typical use of a prompt method in a program might be in the initialization\r\n    part of a declartion.\r\n  <pre><b>int  cashToBet = Prompt.forInt(\"Enter amount of Cash to Bet\"); \r\nchar action    = Prompt.forChar(\"Action: w=withdraw d=deposit\",\"wd\");</b></pre> \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Experiment -->\r\n\r\n<a name=\"Experiment\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Experiment</b></td>\r\n<td width =\"80%\">\r\n  If you have questions about operators, write a tiny program to perform an\r\n    experiment to test your understanding (like performing a small physics or\r\n    chemistry experiment).\r\n  For example, what happens if you try to \"add\" two characters?\r\n  Here is the simple code to put in a program to perform this experiment.\r\n  <pre><b>System.out.println('A'+'B');</b></pre>\r\n  Can you guess what answer is printed; if the answer is different from the one\r\n    you expected, can you revise your understanding of implicit conversion and\r\n    the semantics of the <b>+</b> operator to reconcile the result produced?\r\n  <p>\r\n  It is important to get into the habit early of not being shy about running\r\n    experiments on the computer, even if they are as simple as this one.\r\n  In fact, thinking of the simplest experiment to perform to check some Java\r\n    features requires a deep understanding of programming.\r\n  As I've been learning Java, I've run hundreds of these small experiments\r\n    (including many for some of the more technical points in this lecture).\r\n  <p>\r\n  There should be a very low threshold for you to start an Eclipse project\r\n    with a tiny program in it to test your understanding of Java.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Expressions Structure and Evaluation -->\r\n\r\n<a name=\"StructureAndEvaluation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Structure and Evaluation of Expressions</b></td>\r\n<td width =\"80%\">\r\n   In this section we begin our examination of how to build simple and\r\n     complicated expressions from literals, variables, operators, and methods.\r\n   The EBNF rules specifying the structure of expressions are overly \r\n     complicated, so instead we will just describe their syntax in English\r\n     (one of the few times we shall do so).\r\n   Here are the three structural rules for expressions; each rule concerns\r\n     the syntax of legal expressions (and their type).\r\n  <ul>\r\n    <li><b>S1</b>: A literal is a legal expression; its type is the type of the\r\n          literal.\r\n    <li><b>S2</b>: A variable is a legal expression; its type is the declared\r\n          type of the variable.\r\n    <li><b>S3</b>: An operator (or method) whose operands (each of which must\r\n          be a legal expression) match any of its prototypes (possibly with the\r\n          aid of automatic conversion) is a legal expression; its type is\r\n          the result type specified in the prototype.\r\n  </ul>\r\n  So, by looking at an expression (and knowing the types of its literals and\r\n    variables, and knowing the prototypes of its operators and methods) we can\r\n    determine if the expression is well-formed according to the structural\r\n    rules in Java,  and determine the type that results from evaluating the\r\n    expression.\r\n  To do this we (and Java) don't even have to know the values stored in its\r\n    variables (we just need to know their types) nor the semantics of it\r\n    operators/methods (we just need to know their prototypes).\r\n  <p>\r\n  For each syntax rule there is a companion semantic rule for <b>evaluating</b>\r\n    expressions.\r\n  In some sense, each expression is a question, \"What is the value of ...\"\r\n    which Java answers by evaluating the expression.\r\n  <ul>\r\n    <li><b>E1</b>: A literal evaluates to itself (a trivial but noteworthy\r\n          rule, for the sake of completeness).\r\n    <li><b>E2</b>: A variable evaluates to the current value stored in it;\r\n          remember evaluating expressions with state-change operators can\r\n          change the values stored in variables.\r\n    <li><b>E3</b>: An operator (or method)\r\n    <ul><li>Evaluates each of its operands (which are themselves legal\r\n              expressions).\r\n        <li>Performs any implicit conversions (needed to match its prototype).\r\n        <li>Applies the operator (or method) to its operands to compute its\r\n              result, which is based on the semantics of that operator/method.\r\n            </ul>\r\n  </ul>\r\n  Here, as above, <b>E1</b> and <b>E2</b> are simple rules; all the power is\r\n    in rule <b>E3</b>.\r\n  <p>\r\n  For example, assume that we declare <b>int x = 3;</b> in a program and then\r\n    want to determine whether the expression <b>3*x+1</b> is a legal expression\r\n   (and what its resulting type and value is).\r\n  The entire proof follows.\r\n  <ul>\r\n    <li>We can prove that <b>3</b> is a legal expression of type <b>int</b>\r\n        (by <b>S1</b>); its value is <b>3</b> (by <b>E1</b>)\r\n    <li>We can prove that <b>x</b> is a legal expression of type <b>int</b>\r\n        (by <b>S2</b>); its value is <b>3</b> (by <b>E2</b>)\r\n    <li>We can prove that <b>3*x</b> is a legal expression of type <b>int</b>\r\n          (by <b>S3</b>: we just proved both <b>3</b> and <b>x</b> are legal\r\n          expressions of type <b>int</b>, and one of the prototypes of\r\n          <b>*</b> is <b>int * (int,int)</b>); its result type is <b>int</b>\r\n          and its value is <b>9</b> (by <b>E3</b> and applying the semantics\r\n          of the multiply operator).\r\n    <li>We can prove that <b>1</b> is a legal expression of type <b>int</b>\r\n          (by <b>S1</b>); its value is <b>1</b> (by <b>E1</b>).\r\n    <li>Finally, we can prove that <b>3*x+1</b> is a legal expression of type\r\n          <b>int</b> (by <b>S3</b>: we just proved both <b>3*x</b> and\r\n          <b>1</b> are legal expressions of type <b>int</b>, and one of the\r\n          prototypes of <b>+</b> is <b>int + (int,int)</b>); its result type\r\n          is <b>int</b> and its values is <b>10</b> (by <b>E3</b> again,\r\n          and applying the semantics of the add operator).\r\n  </ul>\r\n  In fact, these three rules allow us to identify the structure of -and\r\n    evaluate- arbitrarily complicated expressions built from literals,\r\n    variables, operators, and methods.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Oval Diagrams -->\r\n\r\n<a name=\"OvalDiagrams\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Oval Diagrams</b></td>\r\n<td width =\"80%\">\r\n  To illustate that we understand how Java structures and evaluates our\r\n    expressions (and more importantly, to give us a tool to analyze and debug\r\n    incorrectly written expressions), we will study how to illustrate an\r\n    expression as an <b>Oval</b> diagram.\r\n  As we write expressions with many operators/methods mixing many types, this\r\n    tool will become more and more important.\r\n  <p>\r\n  To create an oval diagram, first circle (or draw an oval around) every \r\n    literal and variable in the expression.\r\n  These expressions are like atoms in chemistry: they contain no smaller\r\n    constituents.\r\n  Next, label their types on top and label their values (if you know them)\r\n    on the bottom.\r\n  Then, draw an oval around each operator (or method) and its operands; label\r\n    the type with the result type of the matching prototype for that operator,\r\n    and label the bottom with the result value (if you know how to compute it\r\n    from its semantics).\r\n  <p>\r\n  Note that even if we do not know the values stored in variables, we can\r\n    still produce an oval diagram that verified the legality of an expression;\r\n    we just cannot determine what value it computed.\r\n  The outermost oval is labelled by the type of the entire expression.\r\n  Here is an example of an oval diagram for the previously discussed expression: <b>3*x+1</b>\r\n<p>\r\n<img src=\"images/oval1.gif\"></image><p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Operator Precedence -->\r\n\r\n<a name=\"OperatorPrecedence\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Operator Precedence and Associativity</b></td>\r\n<td width =\"80%\">\r\n  Examine the oval diagram below.\r\n  It has exactly the same tokens as the oval diagram above, but the ovals are\r\n     a bit different.\r\n  They both seem to \"follow all the rules\" for forming/evaluating expressions,\r\n    but the ovals are in different positions, and they ultimately produce\r\n    different results.\r\n  The questions are: which oval diagram is correct (which is the way Java\r\n     analyzes and evaluates expressions) and what extra rules do we need to\r\n     know about to  construct correct oval diagrams?\r\n <p><img src=\"images/oval2.gif\"></image><p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  The answers have to do with the concepts of \"operator precedence\" and\r\n   \"operator associativity\": which operators take precedence over other\r\n    operators (which operators are circled/evaluated first) in an expression.\r\n  We will learn that we can also use parentheses to override the standard\r\n    operator precedence when we need to.\r\n  Here is an operator precedence/association table that includes all the\r\n    operators that we have learned so far (there are more in Java, and we will\r\n    learn just a few more in this course). \r\n<p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr align=\"left\">\r\n  <th>Operator</th><th>Name</th><th>Precedence</th><th>Associativity</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr align=\"left\"><td><pre><b>++ --</b></pre></td><td>postfix increment/decrement</td><td>15</td><td>none: all unary</td>\r\n  <tr align=\"left\"><td><pre><b>+ - ! ++ --</b></pre></td><td>unary plus/minus/negate<br>prefix increment/decrement</td><td>14</td><td>none: all unary</td>\r\n  <tr align=\"left\"><td><pre><b>(type)</b>expression</pre></td><td>casting (see below)</td><td>13</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>* / %</b></pre></td><td>multiply divide remainder</td><td>12</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>+ -</b></pre></td><td>add, subtract</td><td>11</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>< <= > >=</b><pre><b>instanceof</b></pre></td><td>inequality relational</td><td>9</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>== !=</b></pre></td><td>equality relational</td><td>8</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>&&</b></pre></td><td>logical and</td><td>4</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>||</b></pre></td><td>logical or</td><td>3</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>= += -= *= /= %=</b></pre></td><td>state change</td><td>1</td><td>right</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  The rules for using these tables on expressions are\r\n  <ul>\r\n    <li>O1: When an expression contains two consecutive operators, neither\r\n            appearing in parentheses, Java applies the higher precedence\r\n            operator first.\r\n    <li>O2: When an expression contains two consecutive operators, neither\r\n            appearing in parentheses, and both have the same precedence,\r\n            Java applies left associative operators left to right and it\r\n            applies right associative operators right to left.\r\n    <li>O3: Java always evaluates expressions in parentheses before it uses\r\n            them as operands in other expressions (so we can use parentheses\r\n            to override precedence, forcing the operators inside the\r\n            parentheses to be evaluated before the operators outside the\r\n            parentheses).\r\n    <li>O4: Java always evaluates the operands of a method, in a left-to-right\r\n            order, before it applies the method (computes the method's result).\r\n  </ul>\r\n  Thus, in the expression <b>3*x+1</b> we start by circling all literals and\r\n    variables.\r\n  Then we see two consecutive operators with no parentheses: the <b>*</b>\r\n    operator has a higher precedence than the <b>+</b> operator, so it and its\r\n    operands are circled first.\r\n  Then the <b>+</b> operator and its operands are circled, completing the\r\n    oval diagram. \r\n  Remember, lower precedence operators are evaluated last.\r\n  <p>\r\n  In the expression below <b>3*(x+1)</b> the subexpression <b>x+1</b> appears\r\n    in parentheses.\r\n  Again, we start by circling all literals and variables.\r\n  Then we see two consecutive operators, but this time the second one is in\r\n    parentheses.\r\n  By rule O3, we must handle all the operators inside the parentheses first\r\n    (circling the <b>+</b> operator first) and then circling the <b>*</b>\r\n    operator last, after its operand has been circled.\r\n  This complete this oval diagram.\r\n  <p>\r\n <p><img src=\"images/oval3.gif\"></image><p>\r\n In fact, the parentheses themselves are suggestive of two sides of an \r\n   oval; you can always draw ovals around parenthesized expressions: they\r\n   can be used to represent the result computed by the last operator inside\r\n   the parentheses.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Common Mistakes -->\r\n\r\n<a name=\"CommonMistakes\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Common Mistakes</b></td>\r\n<td width =\"80%\">\r\n  Note that in the expression <b>A &nbsp / &nbsp B*C</b> it looks like\r\n    <b>A</b> is being divided by the product <b>B*C</b>, but both operators\r\n    have the same precedence, and are left associative, and all the redundant\r\n    white space is meaningless once we have tokenized the expression (which is\r\n    exactly what Java does first).\r\n  So, this expression is equivalent to <b>(A/B)*C</b> and not <b>A/(B*C)</b>.\r\n  If a formula has the product of <b>B</b> and <b>C</b> in the denominator,\r\n    then according to the rules of operator precedence and associativity, we\r\n    must use parentheses in the denominator.\r\n  Some students, in an attempt to avoid parentheses, write this expression as\r\n    <b>A/B/C</b>, but I think that this form is uglier and harder to\r\n    understand.\r\n  <p>\r\n  Next, examine the following four expression that each attempt to compute the\r\n    volume of  a sphere with radius <b>r</b>.\r\n  The only difference among these expressions are the types of the literals\r\n    used (the ones without decimal points are <b>int</b> and the ones with\r\n    decimal points are <b>double</b>).\r\n  Assume that we have already declared <b>double pi = 3.1416;</b>  \r\n <pre><b>    4./3.*pi*Math.pow(r,3.)                 4./3*pi*Math.pow(r,3.)\r\n    4 /3.*pi*Math.pow(r,3.)                 4 /3*pi*Math.pow(r,3.)</b></pre>\r\n  If we assume <b>double r = 2.;</b>, the correct answer is <b>33.510314</b>.\r\n  This answer is computed by ALL BUT the bottom right expression.\r\n  In all the correct expressions, every operator has operands that are\r\n    <b>double</b> or implicitly converted to <b>double</b>.\r\n  But in the bottom right expression, two <b>int</b>s are divided first,\r\n    creating an <b>int</b> result, which is only then implicitly converted to\r\n    a <b>double</b> before multiplying by the <b>double</b> variable <b>pi</b>\r\n    (note <b>1 -> 1.</b> shows exactly where and when the implicit conversion\r\n    occurs in the oval diagram below).\r\n  The final result is an incorrect answer.\r\n  <p>\r\n  Thus, we can use oval diagrams not only to compute the type/value of an\r\n    expression, we can use them to debug incorrectly formed expressions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<img src=\"images/sphere1.gif\"></image><p>\r\n\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\nOne correct version of this expression (also involving implicit conversion,\r\n   but at theright time and place) appears below.\r\nNote that there is NO integer division in this expression.\r\n<p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<img src=\"images/sphere2.gif\"></image><p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  When combining relational and logical operators, it is very easy to make\r\n     mistakes.\r\n  Our generally good intuition about arithmetic operators does not easily\r\n    extend to these other kinds of operators, which are not themselves in\r\n    the standard mathematics we've learned.\r\n  <p>\r\n  For example, suppose that we want to determine whether an <b>int</b> variable\r\n    named <b>x</b> is between <b>0</b> and <b>10</b> inclusive.\r\n  If we evaluate such an expression with <b>x</b> storing <b>5</b> the result\r\n    should be <b>true</b>; if we evaluate such an expression with <b>x</b>\r\n    storing <b>20</b> the result should be <b>false</b>.\r\n  Let's examine the following expression, which looks like good mathematics, \r\n    with oval diagrams to see if it is  correct: <b>0 <= x <= 10</b>\r\n  <p>\r\n  <img src=\"images/badbetween.gif\"></image>\r\n  <p>\r\n  Here the expression has two <b>&lt;=</b> operators (therefore they have the\r\n    same precedence), and they are left associative (like the plus operators\r\n    in <b>a+b+c</b>).\r\n  So, Java evaluates the left operator first, which has a <b>boolean</b>\r\n    result; but when it tries to evaluate the right operator, Java cannot find\r\n    a prototype for it, even with implicit conversion (<b>boolean</b> values\r\n    don't implicitly convert to anything).\r\n  Thus, although this expression makes perfect sense to us, using notations\r\n    from mathematics, it will be rejected by Java (at least it won't be a more\r\n    subtle error, as was implicit conversion in the previous example).\r\n  <p>\r\n  The correct expression to test this condition is <b>0 <= x && x <= 10</b>,\r\n    whose oval diagram is shown below for the two given examples.\r\n  <p>\r\n  <img src=\"images/goodbetween.gif\"></image>\r\n  <p>\r\n  Notice that there is no need for implicit conversions in this expression.\r\n  Generally, implicit conversion can lead to all kinds of errors, and should\r\n    be avoided.\r\n  When analyzing oval diagrams, play close attention to any implicit\r\n    conversion and study carefully whether it always works correctly.\r\n  <p>\r\n  The following complicated oval diagram analyzes the expression<br>\r\n    &nbsp &nbsp <b>b = (y = x++ + 1) < 8</b><br>\r\n  which contains three state-change operators (two <b>=</b> and one\r\n    </b>++</b>).\r\n  <p>\r\n  <img src=\"images/statechange.gif\"></image>\r\n  <p>\r\n  Notice the precedence of these operators and the use of parentheses to force\r\n    evaluation of the inner <b>=</b> operator (lowest precedence) before the\r\n    <b>&lt</b> operator.\r\n  <p>\r\n  We will examine various more complicated expressions (including others\r\n    having multiple state-change operators) in class and learn how to apply\r\n    these rules to create oval diagrams for them.\r\n  It is best for you to see the process, rather than static pictures.\r\n  Make sure you are there, awake, and paying attention.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Explicit Conversion -->\r\n\r\n<a name=\"ExplicitConversion\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Explicit Conversion<br>(casting)</b></td>\r\n<td width =\"80%\">\r\n  Sometimes it is useful to convert a value from one type to another.\r\n  But, we should make the conversion <i>explicit</i>, not implicit.\r\n  This is called <b>casting</b> in Java.\r\n  Notice that casting is considered a high precedence operator (higher\r\n    precedence than all the unary operators).\r\n  <p>\r\n  For example, it is sometimes the case that a program declares a few\r\n    <b>int</b> counters, and then must compute ratios of these counters;\r\n    to avoid the truncation that occurs with <b>int</b> division, we can\r\n    explicitly convert an <b>int</b> value into a <b>double</b>.\r\n  For example, suppose that we declared\r\n    <b>int attendance = 78, capacity = 100;</b>\r\n  Writing <pre><b>  (double)attendance/(double)capacity</b></pre> first\r\n    converts each <b>int</b> value into a <b>double</b> (but there are no\r\n    state-changes in the variables converted) and then performs <b>double</b>\r\n    division on these values, computing an exact\r\n    <b>double</b> answer without truncation (<b>78.</b>\r\n  Of course, writing either <b>(double)attendance/capacity</b> or\r\n    <b>attendance/(double)capacity</b> would work too; if one of <b>/</b>'s\r\n    operands is a <b>double</b> then Java will implicitly convert the other to \r\n    a <b>double</b>.\r\n  We might as well write both casts, though, to make all the conversions that \r\n   occur more clear.\r\n  <p>\r\n  Note that <b>(double)(attendance/capacity)</b> does NOT do the job.\r\n  It first performs integer division, so it is equivalent to\r\n    <b>(double)(0)</b> whose result is <b>0.</b> \r\n  <p>\r\n  Sometimes casts are necessary to satisfy syntax constraints.\r\n  Suppose that we wanted to generate a random integer between 1 and 6 and\r\n    store it in the variable named <b>choice</b>.\r\n  We CANNOT write <b>int choice = 1 + 6*Math.random();</b>\r\n  In this expression Java would implicitly convert <b>6</b> to a <b>double</b>\r\n    to perform the multiplication (returning a <b>double</b> result), and then \r\n    Java would implicitly convert <b>1</b> to a <b>double</b> to perform the\r\n    addition (returning a <b>double</b> result); finally, we cannot store a\r\n    <b>double</b> value into an <b>int</b> variable.\r\n  <p>\r\n  Instead, we can write this expression correctly as\r\n     <b>int choice = 1 + (int)(6*Math.random());</b>\r\n  In this case, the compiler will report no syntax constraint error because we\r\n   have explicitly casted <b>(6*Math.random())</b> to an <b>int</b>\r\n  Thus, the value ultimately stored in <b>choice</b> is a integer from\r\n   <b>1</b> to <b>6</b> inclusive.\r\n  Casting does not change the values stored in any variables.\r\n  <p>\r\n  Write an oval diagram for the expression above, and compute the result stored\r\n    into <b>choice</b> for different random numbers between <b>0</b> (which\r\n    can be generated) and <b>1</b> (which cannot be generated); try a few\r\n    values including <b>0</b> and something a tad less than <b>1</b>.\r\n  Use other oval diagrams to understand why\r\n    <b>1 + 6*(int)Math.random()</b> and\r\n    <b>1 + (int)6*Math.random()</b> do not always compute correct results.\r\n    Does <b>(int)(1 + 6*Math.random())</b> work; use an oval diagram to find\r\n      out.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Expression Pragmatics -->\r\n\r\n<a name=\"ExpressionPragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Expression Pragmatics</b></td>\r\n<td width =\"80%\">\r\n  Write expressions correctly (for computers) and clearly (for people,\r\n    including yourself).\r\n  Use suggestive spacing, redundant parentheses, or both to clarify (for the\r\n    person) the meanings of complicated expressions.\r\n  <ul>\r\n    <li>Suggestive Spacing: use extra whitespace around lower-precedence\r\n          operators to suggest that they are evaluated later.\r\n        Recall that whitespace doesn't change the meaning of a program (all the\r\n          tokens remain the same).\r\n    <li>Redundant Parentheses: use unneeded parentheses (they do not override\r\n          the precedence of any operators) around higher-precedence operators\r\n          to suggest that they are evaluated earlier.\r\n  </ul>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Expression</th><th>Suggestive Spacing</th><th>Redundant ()</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td><pre><b>.5*A*T*T+V*T+D</b></pre></td>\r\n    <td><pre><b>.5*A*T*T + V*T + D</b></pre></td>\r\n    <td><pre><b>(.5*A*T*T)+(V*T)+D</b></pre></td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Also, use literals of the correct type to avoid implicit conversion (which\r\n    often leads to hard-to-find errors).\r\n  If you want conversion to occur, use casting to make it explicit: doing so\r\n    doesn't change how Java evaluates the expression (implicit conversion and \r\n    casting both do the same thing) but for anyone reading the program, the\r\n    expression will be easier to understand.\r\n  You can check the expressions you write by analyzing them with oval diagrams,\r\n    evaluating them for a few different values to ensure that they compute the\r\n    right answers.\r\n  <p>\r\n  Don't cast literals; when I see students write <b>(double)5</b> it pains me\r\n    greatly: write just <b>5.</b> instead.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, a Tutor,\r\n    or any other student.\r\n  <ol>\r\n    <li>Show a few different ways to declare <b>A</b> and <b>B</b> as <b>int</b> variables\r\n          initially storing <b>0</b> and <b>1</b> respectively.\r\n        Do it with one declaration statement; with two declaration statments; write\r\n          slightly different variants of these that still accomplish the job.\r\n\r\n    <p>\r\n    <li>Both of the following are illegal declarations (according to EBNF)\r\n<pre><b>  int x = 0, boolean isOK = false;\r\n  int x = y = 0;</b></pre>\r\n        Explain why.\r\n        Write legal declarations that accomplish what these are trying to do.\r\n\r\n    <p>\r\n    <li>Write prototypes for each of the following methods.\r\n        Infer the information needed in the prototype from each function's description.\r\n       <ul>\r\n         <li><b>countPrimesBetween</b> returns the number of primes occuring between two\r\n                  integers: e.g., <b>countPrimesBetween(11,24)</b> evaluates to <b>5</b>,\r\n                  because 11, 13, 17, 19, and 23 are prime.\r\n         <li><b>distance</b> returns the euclidean distance between two points in the plane\r\n                  (each point is represented by two <b>double</b>s).\r\n         <li><b>inSameQuandrant</b> returns whether or not two points lie in the same\r\n                   quadrant (each point is represented by two <b>double</b>s).\r\n         <li><b>shuffle</b> returns the interleaved characters from its operands:\r\n                <b>shuffle(\"abcd\",\"efgh\")</b> returns <b>\"aebfcgdh\"</b>.\r\n       </ul>\r\n    <p>\r\n\r\n    <li>What are the results of each of the the following operators?\r\n    <pre><b>    7/10   7./10   7/10.   7./10.\r\n    7/10   57/10   157/10   2157/10\r\n    7%10   57%10   157%10   2157%10</b></pre>\r\n    <p>\r\n\r\n    <li>Show the result produced by each of the following operators/methods\r\n          (or indicate that some syntax error is present).\r\n        If the state of some variable is changed, show that too (and indicate any\r\n          implicit conversions). \r\n        Assume <b>int x = 0; String s = \"ABC\";</b> before each call\r\n<pre><b>  false == false          'a' < 'Z'          'a'-'A'\r\n  true  != true           true && false      true || false\r\n  x++                     ++x                1 = x\r\n  x = 1                   x == 1             x = 'A'\r\n  Math.abs(-3.5)          Math.abs(3.5)      Math.max(3.5, 8)\r\n  Math.sqrt(-1.)          Math.pow(-3.,2.)   Math.pow(-3.,.5)\r\n\r\n  s = System.out.println(\"Hi\");\r\n</b></pre>\r\n    <p>\r\n\r\n    <li>Assume that we declare <b>int a = 1;</b>\r\n        What would be stored in <b>a</b> after evaluating <b>a = a++</b>?\r\n        What would be stored in <b>a</b> after evaluating <b>a = ++a</b>?\r\n        What do you think the programmer is trying to accomplish?\r\n        What is an easy way to accomplish it?\r\n    <p>\r\n       \r\n    <li>What is printed in each of the following method calls.\r\n  <pre><b>  System.out.println(\"\" + 1 + 1 + 1);\r\n  System.out.println(1 + 1 + 1 + \"\");\r\n  System.out.println('1' + 1 + \"\");</b></pre>\r\n  <p>\r\n\r\n    <li>Analyze each of the following expressions, assuming <b>int a=1,b=2;</b> and write an\r\n          oval diagram for each.\r\n    <pre><b>      (a+b)/2       a+b/2\r\n      100.*a/b      100.*(a/b)      a/b*100.</b></pre>\r\n    <p>\r\n\r\n    <li>Assume that we declare <b>double a,b;</b>\r\n        evaluate the expression <b>(a+b - Math.abs(a-b))/2.</b> when\r\n        <ul>\r\n          <li><b>a</b> stores <b>3.</b> and <b>b</b> stores <b>5.</b>\r\n          <li><b>a</b> stores <b>5.</b> and <b>b</b> stores <b>3.</b>\r\n        </ul>\r\n        Try a few other example values for <b>a</b> and <b>b</b>.\r\n        Describe in general terms what this expression evaluates to.\r\n    <p>\r\n        \r\n    <li>Assume that we declare <b>int a,b;</b> also assume that the\r\n          method whose prototype is <b>int Util.characteristic(boolean)</b>\r\n          returns <b>1</b> if its operand is <b>true</b> and <b>0</b> if its\r\n          operand is <b>false</b>.\r\n        Evaluate the expression <br>\r\n          &nbsp &nbsp <b>Util.characteristic(a&lt;b)*a+Util.characteristic(a>=b)*b</b></br>\r\n        when\r\n        <ul>\r\n          <li><b>a</b> stores <b>3</b> and <b>b</b> stores <b>5</b>.\r\n          <li><b>a</b> stores <b>5</b> and <b>b</b> stores <b>3</b>.\r\n        </ul>\r\n        Try a few other example values for <b>a</b> and <b>b</b>.\r\n        Describe in general terms what this expression evaluates to.\r\n    <p>\r\n        \r\n    <li>Translate each of the following mathematical formulas (7 on the top line, 3 on the\r\n          middle and bottom lines) into Java expressions.\r\n        Assume that all variables (some have subscripts) are declared to be of\r\n          type <b>double</b>.\r\n        Writing <b>|x|</b> means the absolute value of <b>x</b>.\r\n        Analyze each expression by writing its oval diagram.<br>\r\n    <img src=\"images/formulas.gif\"></image><p>\r\n    <p>\r\n\r\n    <li>Suppose that we declare <b>int attendance = 3000, capacity=10000;</b> the number of\r\n          fans attending an event at a stadium and the maximum number of fans possible at that\r\n          stadium respectively.\r\n        Which of the following Java expressions evaluates to 30, the percentage of fans\r\n          in the stadium? What do the \"incorrect\" expressions evaluate to?\r\n        <pre><b>        attendance/capacity\r\n        100*attendance/capacity\r\n        100*(attendance/capacity)\r\n        attendance/capacity*100        </b></pre>\r\n\r\n     <li>The expression <b>x < 10 && y</b> does not compute whether <b>x</b> is less than both\r\n           <b>10</b> and <b>y</b>.\r\n         Show that the syntax of this expression is incorrect; how far can Java get before\r\n           it discovers the error?\r\n         Find a way to correctly test if <b>x</b> is less than <b>10</b> and <b>x</b> is less than <b>y</b>.\r\n         Assume we declare <b>int x = 50, y = 20;</b>\r\n         Draw an oval diagram that shows what value Java computes for your expression (it should\r\n           evaluate to <b>false</b>, because <b>x</b> is not less than <b>y</b>: is that what it computes?).\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>int x;</b>\r\n         Write an expression whose result is <b>X</b> rounded to the nearest 10: e.g.,\r\n           if <b>x</b> were <b>1432</b> the result would be <b>1430</b>;\r\n           if <b>x</b> were <b>1437</b> the result would be <b>1440</b>;\r\n           if <b>x</b> were <b>1435</b> round up so the result would be <b>1440</b> also.\r\n         Use only the standard arithmetic operators and casting.\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>double x;</b>\r\n         Write an expression whose result is the <b>int</b> value closest to <b>x</b>: e.g.,\r\n           if <b>x</b> were <b>3.2</b> the result would be <b>3</b>;\r\n           if <b>x</b> were <b>3.9</b> the result would be <b>4</b>;\r\n           if <b>x</b> were <b>3.5</b> round up so the result would be <b>4</b> also.\r\n         Just casting doesn't work, because of truncation: <b>3.9</b> would be cast to <b>3</b>.\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>int year;</b>\r\n         Write an expression whose result is <b>true</b> whenever <b>year</b> stores a leap year\r\n           and <b>false</b> otherwise.\r\n         We define a leap year as any year that is a perfect multiple of of <b>4</b>, but not if it\r\n           is a perfect multiple of <b>100</b> (unless it is also a perfect multiple of <b>400</b>).\r\n         Note that one number is a perfect multiple of another if the remainder after division equals zero.\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n         <b>int a = 2, b = 5;</b>\r\n         What are the values of <b>a</b>, <b>b</b>, and the entire expression, after evaluating\r\n           the expression <b>a+++b</b>; the same question, but for the expression <b>a+ ++b</b>?\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>int x,y,z;</b>\r\n         Write an expression that computes whether...\r\n         <ul>\r\n            <li>...<b>x</b> is odd\r\n            <li>...<b>x</b> is a multiple of 20 (e.g., 20, 40, 60, ...)\r\n         </ul>\r\n         Assume that zero is a positive number.\r\n         Write an expression that computes whether...\r\n         <ul>\r\n            <li>...<b>x</b> and <b>y</b> are both positive\r\n            <li>...<b>x</b> and <b>y</b> have the same sign (both are positive or both are negative)\r\n            <li>...<b>x</b> and <b>y</b> have different signs (one is positive and one is negative)\r\n         </ul>\r\n         Write an expression that computes whether...\r\n         <ul>\r\n            <li>...all three variables (<b>x</b>, <b>y</b>, and <b>z</b>) store the same value\r\n            <li>...all three variables (<b>x</b>, <b>y</b>, and <b>z</b>) store different values (none the same)\r\n            <li>...two variables store the same value, but the third one is different\r\n         </ul>\r\n       <p>\r\n\r\n    <li>Assume that we declare <b>char c;</b>\r\n         Write an expression that evaluates to <b>true</b> when <b>c</b> stores...\r\n         <ul>\r\n            <li>...a lower-case letter\r\n            <li>...a lower-case or upper-case letter\r\n            <li>...a character that is a digit\r\n            <li>...an upper-case vowel\r\n         </ul>\r\n     <p>\r\n\r\n     <li>Assume that we specify two points in the place with the declaration\r\n           <b>double x1,y1, x2,y2;</b>\r\n         Write an expression that computes...\r\n         <ul>\r\n            <li>...the distance between these points\r\n            <li>...the slope of the line from the first point to the second\r\n            <li>...whether both points lie on the same line from the origin\r\n            <li>...whether the first point is above the second\r\n            <li>...what quadrant the first point lies in (1st, 2nd, 3rd, or 4th)\r\n            <li>...whether the two points lie in the same quadrant\r\n         </ul>\r\n     <p>\r\n\r\n     <li>Assume that we specify a circle with the declaration \r\n           <b>double centerX, centerY, radius;</b>\r\n           and a point by the declaration <b>double x,y;</b>\r\n         Write an expression that computes whether or not the point lies inside the circle\r\n            (including the boundary).\r\n     <p>\r\n\r\n     <li>Assume that specify an interval by a pair of <b>int</b> values (the ones at the beginning\r\n           and end of the interval in the place with the declaration): <b>5</b> and <b>8</b> would\r\n           specify the interval containing the numbers <b>5</b>, <b>6</b>, <b>7</b>, and <b>8</b>\r\n           inclusive.\r\n         We declare <b>int b1,e1, b2,e2;</b> to represent the beginning and end of two intervals,\r\n           and <b>int x;</b> so represent some value.\r\n         Note that we will guarantee that the intervals are \"well formed\": <b>b1 <= e1</b> and \r\n           <b>b2 <= e2</b>.\r\n         <ul>\r\n            <li>Write an expression that computes the number of values in an interval beginning with\r\n                  <b>b1</b> and ending with <b>e1</b>.\r\n            <li>Write an expression that computes whether...\r\n               <ul>\r\n                 <li>...<b>x</b> is inside the first interval\r\n                 <li>...<b>x</b> is not inside the first interval\r\n                 <li>...<b>x</b> is inside the first interval but not the second\r\n                 <li>...<b>x</b> is inside either the first or second interval (or both)\r\n                 <li>...<b>x</b> is inside either the first or second interval (but not both)\r\n               </ul>\r\n            <li>Write an expression that computes whether...\r\n               <ul>\r\n                 <li>...the first interval is the same as the second\r\n                 <li>...the first interval ends before the second one begins\r\n                 <li>...the first interval ends on the same value as the second one begins\r\n                 <li>...the first interval is inside the second one\r\n                 <li>...the first interval and the second interval overlap (at least one common value)\r\n                 <li>...the first interval and the second interval do not overlap (no common values)\r\n               </ul>\r\n         </ul>\r\n         Draw pictures to help you visualize the relationships; choose your relational and logical\r\n           operators carefully, and try a few examples to convince yourself that your expressions are\r\n           correct.\r\n         For example, the following picture shows the first interval inside the second.<br>\r\n         <img src=\"images/inside.gif\"></image>\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>int x,y,z;</b>\r\n         Write an expression that computes the minimum of these three values.\r\n         You may use the <b>Math.min</b> method.\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n         <b>char d;</b> and guarantee that it stores a character corresponding\r\n         to a digit: <b>'0'</b>, <b>'1'</b>, <b>'2'</b>, ... <b>'9'</b>.\r\n         Write an expression that computes the <b>int</b> equivalent to that value:\r\n           <b>0</b> for <b>'0'</b>, <b>1</b> for <b>'1'</b>, etc.\r\n         Note that <b>(int)d</b> converts the <b>char</b> to an <b>int</b>, but not\r\n           the right one: e.g., by the ASCII table <b>(int)'0'</b> results in <b>48</b>,\r\n           <b>(int)'1'</b> results in <b>49</b>, ... (which should give you a clue)\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n         <b>char c;</b> and guarantee that it stores a character corresponding\r\n           to a lower-case letter: <b>'a'</b>, <b>'b'</b>, <b>'c'</b>, ... <b>'z'</b>.\r\n         Write an expression that computes the upper case equivalent to that value:\r\n           <b>'A'</b> for <b>'a'</b>, <b>'B'</b> for <b>'b'</b>, etc.\r\n         Eventually, you must use casting.\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n         <b>int low, high, x;</b> and that we guarantee that <b>low <= high</b>.\r\n         Write an expression whose result is <b>low</b> if <b>x</b> is smaller than <b>low</b>,\r\n          <b>high</b> if <b>x</b> is greater than <b>high</b>, and <b>x</b> if it is between\r\n          these values.\r\n          You may use the <b>Math.min</b> and the <b>Math.max</b> methods.\r\n     <p>\r\n\r\n\r\n </ol>\r\n</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}