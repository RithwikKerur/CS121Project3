{"url": "https://www.ics.uci.edu/~dan/class/267P/datasets/calgary/paper5", "content": ".pn 0\n.EQ\ndelim $$\ndefine RR 'bold R'\ndefine SS 'bold S'\ndefine II 'bold I'\ndefine mo '\"\\(mo\"'\ndefine EXIST ?\"\\z\\-\\d\\z\\-\\r\\-\\d\\v'0.2m'\\(br\\v'-0.2m'\"?\ndefine NEXIST ?\"\\z\\-\\d\\z\\o'\\-\\(sl'\\r\\-\\d\\v'0.2m'\\(br\\v'-0.2m'\"?\ndefine ALL ?\"\\o'V-'\"?\ndefine subset '\\(sb'\ndefine subeq  '\\(ib'\ndefine supset '\\(sp'\ndefine supeq  '\\(ip'\ndefine mo '\\(mo'\ndefine nm ?\"\\o'\\(mo\\(sl'\"?\ndefine li '\\& sup ['\ndefine lo '\\& sup ('\ndefine hi '\\& sup ]'\ndefine ho '\\& sup )'\n.EN\n.ls 1\t\n.ce\nA LOGICAL IMPLEMENTATION OF ARITHMETIC \n.sp 3\n.ce\nJohn G. Cleary \n.ce\nThe University of Calgary, Alberta, Canada.\n.sp 20\n\\u1\\dAuthor's Present Address: Man-Machine Systems Group, Department of\nComputer Science, The University of Calgary, 2500 University Drive NW\nCalgary, Canada T2N 1N4. Phone: (403)220-6087.  \n.br\n.nf\nUUCP:  ...!{ihnp4,ubc-vision}!alberta!calgary!cleary\n       ...!nrl-css!calgary!cleary\nARPA:  cleary.calgary.ubc@csnet-relay\nCDN:   cleary@calgary\n.fi\n.sp 2\n.ls 2\n.bp 0\n.ls 2\n.ce\nAbstract\n.pp\nSo far implementations of real arithmetic within logic programming\nhave been non-logical.  A logical description of the behaviour of arithmetic\non actual\nmachines using finite precision numbers is not readily available.  \nUsing interval analysis a simple description of real arithmetic is possible.\nThis can be translated to an implementation within Prolog.\nAs well as having a sound logical basis the resulting system \nallows a very concise and powerful programming style and is potentially\nvery efficient.\n.bp\n.sh \"1 Introduction\"\n.pp\nLogic programming aims to use sets of logical formulae as\nstatements in a programming language.\nBecause of many practical difficulties the full generality of logic\ncannot (yet) be used in this way.   However, by restricting the\nclass of formulae used to Horn clauses practical and efficient\nlanguages such as PROLOG are obtained.\nOne of the main problems in logic programming is to extend this area\nof practicality and efficiency to an ever wider range of formulae and \napplications.  \nThis paper considers such an implementation for arithmetic.\n.pp\nTo see why arithmetic as it is commonly implemented in PROLOG systems\nis not logical consider the following example:\n.sp\n.nf\n\tX = 0.67, Y = 0.45, Z is X*Y, Z = 0.30\n.fi\n.sp\nThis uses the notation of the 'Edinburgh style' Prologs.\n(For the moment we assume an underlying floating point\ndecimal arithmetic with two significant places.)\nThe predicate 'is' assumes its righthand side is an arithmetic\nstatement, computes its value, and unifies the result with its lefthand side.\nIn this case the entire sequence succeeds, however, there are some serious \nproblems.\n.pp\nIn a pure logic program the order of statements should be irrelevant to\nthe correctness of the result (at worst termination or efficiency might be\naffected).  This is not true of the example above.  The direction of execution\nof 'is' is strictly one way so that\n.sp\n\tY = 0.45, Z = 0.30, Z is X*Y\n.sp\nwill deliver an error when X is found to be uninstantiated inside 'is'.\n.pp\nThe second problem is that the answer Z = 0.30 is incorrect!\\ \nThe correct infinite precision answer is Z = 0.3015.  This inaccuracy\nis caused by the finite precision implemented in the floating point\narithmetic of modern computers.\nIt becomes very problematic to say what if anything it means when\nZ is bound to 0.30 by 'is'.  This problem is exacerbated by long sequences\nof arithmetic operations where the propagation of such errors can lead the\nfinal result to have little or no resemblence to the correct answer.\n.pp\nThis is further class of errors, which is illustrated by the fact that the\nfollowing two sequences will both succeed if the underlying arithmetic rounds:\n.sp\n\tX = 0.66, Y = 0.45, Z = 0.30, Z is X*Y\n.br\n\tX = 0.67, Y = 0.45, Z = 0.30, Z is X*Y\n.sp\nThis means that even if some invertable form of arithmetic were devised\ncapable of binding X when:\n.sp\n\tY = 0.45, Z = 0.30, Z is X*Y\n.sp\nit is unclear which value should be given to it.\n.pp\nThe problem then, is to implement arithmetic in as logical a manner\nas possible while still making use of efficient floating point arithmetic.\nThe solution to this problem has three major parts.\nThe first is to represent PROLOG's \narithmetic variables internally as intervals of real numbers.\nSo the result of 'Z is 0.45*0.67' would be to bind Z to the \nopen interval (0.30,0.31).  \nThis says that Z lies somewhere in the interval\n$0.30 < Z < 0.31$, which is certainly true, and probably as informative\nas possible given finite precision arithmetic.\n(Note that Z is NOT bound to the data structure (0.30,0.31), this\nis a hidden representation in much the same way that pointers are used\nto implement logical variables in PROLOG but are not explicitly visible\nto the user.  Throughout this paper brackets such as (...) or [...] will\nbe used to represent open and closed intervals not Prolog data structures.)\n.pp\nThe second part of the solution is to translate expressions such as\n\\&'Z is (X*Y)/2' to the relational form 'multiply(X,Y,T0), multiply(2,Z,T0)'.\nNote that both the * and / operators have been translated to 'multiply'\n(with parameters in a different order).  This relational form will be seen to \nbe insensitive to which parameters are instantiated and which are not,\nthus providing invertibility.\n.pp\nThe third part is to provide a small number of control 'predicates' able\nto guide the search for solutions.\nThe resulting system is sufficiently powerful to be able to\nsolve equations such as '0 is X*(X-2)+1' directly.\n.pp\nThe next section gives a somewhat more formal description of arithmetic\nimplemented this way.  Section III gives examples of its use and of the\ntypes of equations that are soluble within it.  Section IV compares our \napproach here with that of other interval arithmetic systems and with\nconstraint networks.  Section V notes some possibilities for a parallel \ndataflow implementation which avoids many of the difficulties of traditional\ndataflow execution.\n.sh \"II. Interval Representation\"\n.pp\nDefine $II(RR)$ to be the set of intervals over the real numbers, $RR$.\nSo that the lower and upper bounds of each interval can be operated on as \nsingle entities they will be treated as pairs of values.  \nEach value having an attribute of being open or closed \nand an associated number.  For example the interval (0.31,0.33] will be\ntreated as the the pair $lo 0.31$ and $hi 0.33$.  \nThe brackets are superscripted to minimize visual confusion when writeing \nbounds not in pairs.\nAs well as the usual real numbers \n$- inf$ and $inf$, will be used as part of bounds,\nwith the properties that $ALL x mo RR~- inf < x < inf$ \nThe set of all upper bounds is defined as:\n.sp\n\t$H(RR)~==~\\{ x sup b : x mo RR union \\{ inf \\},~b mo \\{ hi , ho \\} \\} $\n.sp\nand the set of lower bounds as:\n.sp\n\t$L(RR)~==~\\{ \\& sup b x : x mo RR union \\{ -inf \\},~b mo \\{ li , lo \\} \\} $\n.sp\nThe set of all intervals is then defined by:\n.sp\n\t$II(RR)~==~L(RR) times H(RR)$\n.sp\nUsing this notation rather loosely intervals will be identified \nwith the apropriate subset of the reals.  For example the following \nidentifications will be made:\n.sp\n\t$[0.31,15)~=~< li 0.31, ho 15 >~=~ \\{ x mo RR: 0.31 <= x < 15 \\}$\n.br\n\t$[-inf,inf]~=~< li -inf , hi inf> ~=~ RR$\n.br\nand\t$(-0.51,inf]~=~< lo -0.51 , hi inf >~=~ \\{ x mo RR: 0.51 < x \\}$\n.sp\nThe definition above carefully excludes 'intervals' such as $[inf,inf]$\nin the interests of simplifying some of the later development.\n.pp\nThe finite arithmetic available on computers is represented by a\nfinite subset, $SS$, of $RR$.  It is assumed that \n$0,1 mo SS$.  The set of intervals allowed over $SS$ is $II(SS)$ defined as \nabove for $RR$.  $SS$ might be a bounded set of integers or some more complex\nset representable by floating point numbers.\n.pp\nThere is a useful mapping from $II(RR)$ to $II(SS)$ which associates\nwith each real interval the best approximation to it:\n.nf\n.sp\n\t$approx(<l,h>)~==~<l prime, h prime >$\n.br\nwhere\t$l prime mo L(SS), l prime <= l, and NEXIST x mo L(SS)~l prime <x<l$\n.br\n\t$h prime mo H(SS), h prime >= h, and NEXIST x mo H(SS)~h prime >x>h$.\n.pp\nThe ordering on the bounds is defined as follows:\n.sp\n\t$l < h, ~ l,h mo II(RR)~ <->~l= \\& sup u x and h = \\& sup v y$\n\t\t\tand $x<y$ or $x=y$ and $u<v$\nwhere \t$ ho, li, hi, lo$ occur in this order and $x<y$ is the usual ordering \non the reals extended to include $-inf$ and $inf$.  \nThe ordering on the brackets is carefully chosen so that intervals such as\n(3.1,3.1) map to the empty set.\nGiven this definition it is easily verified that 'approx' gives\nthe smallest interval in $II(SS)$ enclosing the original interval in $II(RR)$.\nThe definition also allows the intersection of two intervals to be readily \ncomputed:\n.sp\n\t$<l sub 1,h sub 1> inter <l sub 2, h sub 2>~=~$\n\t\t$< max(l sub 1 , l sub 2), min(h sub 1 , h sub 2 )>$\n.sp\nAlso and interval $<l,h>$ will be empty if $l > h$.  For example, according\nto the definition above $lo 3.1 > ho 3.1$ so (3.1,3.1) is correctly computed\nas being empty.\n.pp\nIntervals are introduced into logic by extending the notion of \nunification.  A logical variable I can be bound to an interval $I$,\nwritten I:$I$.  Unification of I to any other value J gives the following\nresults:\n.LB\n.NP\nif J is unbound then it is bound to the interval, J:$I$;\n.NP\nif J is bound to the interval J:$J$ then\nI and J are bound to the same interval $I inter J$.\nThe unification fails if $I inter J$ is empty.\n.NP\na constant C is equivalent to $approx([C,C])$;\n.NP\nif J is bound to anything other than an interval the unification fails.\n.LE\n.pp\nBelow are some simple Prolog programs and the bindings that result when\nthey are run (assuming as usual two decimal places of accuracy).\n.sp\n.nf\n\tX = 3.141592\n\tX:(3.1,3.2)\n\n\tX > -5.22, Y <= 31, X=Y\n\tX:(-5.3,32]  Y:(-5.3,31]\n.fi\n.sp\n.rh \"Addition\"\n.pp\nAddition is implemented by the relation 'add(I,J,K)'\nwhich says that K is the sum of I and J.\n\\&'add' can be viewed as a relation on $RR times RR times RR$ defined\nby:\n.sp\n\t$add ~==~ \\{<x,y,z>:x,y,z mo  RR,~x+y=z\\}$\n.sp\nGiven that I,J, and K are initially bound to the intervals $I,J,K$ \nrespectively, the fully correct set of solutions with the additional\nconstrain 'add(I,J,K)' is given by all triples in the set \n$add inter I times J times K$.  \nThis set is however infinite, to get an effectively computable procedure\nI will approximate the additional constraint by binding I, J and K\nto smaller intervals.  \nSo as not to exclude any possible triples the new bindings, \n$I prime, J prime roman ~and~ K prime$ must obey:\n.sp\n\t$add inter I times J times K ~subeq~ I prime times J prime times K prime$\n.sp\nFigure 1 illustrates this process of\n.ul\nnarrowing.\nThe initial bindings are I:[0,2], J:[1,3]\nand K:[4,6].  After applying 'add(I,J,K)' the smallest possible bindings\nare I:[1,2], J:[2,3] and K:[4,5].  Note that all three intervals have been\nnarrowed.\n.pp\nIt can easily be seen that:\n.sp\n\t$I prime supeq \\{x:<x,y,z> ~mo~ add inter I times J times K \\}$\n.br\n\t$J prime supeq \\{y:<x,y,z> ~mo~ add inter I times J times K \\}$\n.br\n\t$K prime supeq \\{z:<x,y,z> ~mo~ add inter I times J times K \\}$\n.sp\nIf there are 'holes' in the projected set then $I prime$ will be a strict\nsuperset of the projection, however, $I prime$ will still \nbe uniquely determined by the projection.  This will be true of any\nsubset of $RR sup n$ not just $add$.\n.pp\nIn general for\n.sp\n\t$R subeq RR sup n,~ I sub 1 , I sub 2 , ... , I sub n mo II(RR)$\nand $I prime  sub 1 , I prime  sub 2 , ... , I prime  sub n mo II(RR)$\n.sp\nI will write \n.br\n\t$R inter I sub 1 times I sub 2 times ... times I sub n nar \nI prime sub 1 times I prime sub 2 times ... times I prime sub $\n.br \nwhen the intervals $I prime sub 1 , I prime sub 2 , ... , I prime sub $\nare the uniquelly determined smallest intervals including all solutions.\n\n.sh \"IV. Comparison with Interval Arithmetic\"\n.pp\n.sh \"V.  Implementation\"\n.pp\n.sh \"VI. Summary\"\n.sh \"Acknowledgements\"\n.sh \"References\"\n.ls 1\n.[\n$LIST$\n.]\n", "encoding": "ascii"}