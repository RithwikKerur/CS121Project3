{"url": "https://www.ics.uci.edu/~pattis/ICS-46/assignments/program1/program.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program 1</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program 1</h1>\r\n<h1>\r\nProgramming using the ICS-46 Template Library (ITL):<br>\r\nStack, Queue, Priority Queue, Set, and Map\r\n</h1>\r\n<p>\r\n<h2>ICS-46: Data Structure Implementation and Analysis<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis programming assignment is designed to ensure that you know how to use\r\n  combinations of ITL's templated classes to model and compactly write code\r\n  that solves a variety of different programming problems.\r\nThe kind of abstract thinking that goes into modeling solutions to these\r\n  programming problems with these data types (and iteration over them) is\r\n  important to your development as programmers.\r\nThis assignment will also start you on understanding the compiler error-messages\r\n  produced when using templated classes incorrectly.\r\n<p>\r\nThere are five parts to this assignment.\r\nIn each you will be asked to write a program (<b>.cpp</b> file) that defines a\r\n  few functions and has a <b>main</b> function, which ties these functions\r\n  together to solve the problem.\r\n<p>\r\nYou should download the \r\n  <a href=\"program1.zip\">program1</a> project folder and use it to create an\r\n  CLion project (needing only <b>courselib</b> not <b>googletest</b>).\r\nYou will create each program in this project, and submit each program\r\n  separately in Checkmate.\r\nThe project folder contains boiler-plated files (including some <b>typedefs</b>\r\n  that I found useful in my code: you may change their names) and contains all\r\n  the data files that you need to test/debug you programs.\r\n<b>Important: In the standard download, only one of the <b>.cpp</b> files can\r\n   be active/tested at any time</b> (each contains a <b>main</b> method).\r\nIn the download, all are active; so I suggest that you inactivate the\r\n  <b>runoffvoting.cpp</b>, <b>fa.cpp</b>, <b>ndfa.cpp</b>, and\r\n  <b>wordgenerator.cpp</b> files and then work on  <b>reachable.cpp</b> first.\r\nThen, as you finish each program, submit it, deactivate it, and activate the\r\n  next program you will work on.\r\n<p>\r\nTo make a program inactive, select it (in the editor tab), use the <b>Ctrl+a</b>\r\n  command to select all its lines, and then <b>Ctrl+/</b> (or click\r\n  <b>Source</b> at the top left of the menu and choose <b>Toggle Comment</b>):\r\n  every line will now appear in a comment; by reusing these same instructions,\r\n  you can toggle back those lines to remove the comments.\r\n<p>\r\n<!---\r\nAlternatively, you can also use a existing/working project folder: remove (but\r\n  save) all the files in its <b>src</b> folder and then put all the <b>.cpp</b>\r\n  files from the downloaded project's <b>src</b> folder into the\r\n  existing/working project's <b>src</b> folder.\r\nAlso put all the data files into the existing project folder, not in the\r\n <b>src</b> folder, but at the same level as the <b>src</b> folder.\r\n--->\r\n<p>\r\n<b>IMPORTANT: Turn in .cpp files that are runnable: their code should not be\r\n     commented-out.</b>\r\n<p>\r\nI recommend that you work on this assignment in pairs.\r\nTry to find someone who lives near you, with similar programming skills,\r\n  and work habits/schedule: e.g., talk about whether you prefer to work\r\n  mornings, nights, or weekends; what kind of commitment you will make to submit\r\n  program early.\r\n<p>\r\nOnly <b>ONE STUDENT</b> should submit the assignment (all parts of it).\r\nIf students work in pairs, <b>BOTH NAMES</b> and their UCInetID names must\r\n  appear in a comment at the top of each submitted program.\r\nFor example if Romeo Montague (whose UCInetID is romeo1) submitted a program\r\n  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)\r\n  the comment at the top of each submitted file would appear as:\r\n<pre><b>  // Submitter: romeo1(Montague, Romeo)\r\n  // Partner  : jcapulet(Capulet, Juliet)\r\n  // We certify that we worked cooperatively on this programming\r\n  //   assignment, according to the rules for pair programming</b></pre>\r\nIf you do not know what the terms <b>cooperatively</b> and/or\r\n  <b>rules for pair programming</b> mean, please read about\r\n  <a href=\"../../../common/handouts/pairprogramming.html\">Pair Programming</a> \r\n  before starting this assignment.\r\nIf the names do not appear at the top of all your submissions in exactly this\r\n  form, points will be deducted.\r\nIf you are submitting by yourself, you may omit all lines but the first\r\n  (<b>Submitter</b>).\r\nPlease <b>do</b> turn in each program <b>as you finish it</b>, so that I can\r\n  accurately assess the progress of the class as a whole during this assignment;\r\n  <b>do not</b> turn in all the programs at the same time.\r\n<p>\r\nPrint this document and carefully read it, marking any parts that contain\r\n  important detailed information that you find (for review before you turn in\r\n  the files).\r\nYou should familiarize yourselves with the <b>ics46goody.hpp</b> file in the\r\n  <b>courselib/src</b> folder.\r\nIt contains functions useful in all these programs: <b>split</b> and <b>join</b>\r\n  (like their counterparts in Python, they use <b>std::string</b> and \r\n  <b>vector&lt;std::string></b>), <b>prompt_string</b>, and <b>safe_open</b>.\r\n<p>\r\nThis assignment has five parts: pairs should work on each part together, not\r\n  split them up and do them separately.\r\nParts 1-3 are 14 points each (42 points total); Part 4 is worth 10 points;\r\n   Part 5 is worth 8 points.\r\nThis skewing of points towards the simpler parts means students finishing the\r\n  first three parts correctly will have a 70% average; those finishing the\r\n  first four parts correctly will have about an 87% average; but to get an A on\r\n  this assignment requires solving all parts correctly.\r\nRemember that I'm going to be running MOSS on the parts of this assignment to\r\n  check for program similarity (both for submission this quarter, and for\r\n  previous quarters).\r\n<p>\r\n<b>Important</b>:\r\nThe <a href=\"../../programs/cross_reference.zip\">cross_reference</a>\r\n  program shows an example of the form of code that you need to write for these\r\n  programs: study and understand its code before attempting to start\r\n  solving these problems.\r\nQuestions about <b>cross_reference</b>? Post them on a Message Board in the\r\n  Forum (and feel free to read and answer the questions of other students).\r\n<p>\r\nUse the array implementations supplied in the ITL for all the data types.\r\nThe programs in the folder you will download have <b>#include</b> statements at\r\n  the top for all the files that you need to use.\r\n<p>\r\nAlong with the details of the functions, I've included the number of lines\r\n  that I wrote in my solution.\r\nI am supplying these number of lines <b>not</b> as a requirement, but as a\r\n  ballpark estimate of the amount of code you should write.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 1 -->\r\n\r\n<a name=\"problem1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>#1: Reachability<br>(14 pts)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li>Write a program that prompts the user to enter the name of\r\n       a file representing a graph.\r\n<li>Read the information in the file, storing the graph in a map.\r\n<li>Print the graph.\r\n<li>Repeatedly prompt the user for a starting node in the graph, and compute and\r\n      print all the nodes that are reachable from it by following zero or more\r\n      edges in the graph (e.g., a node is reachable from itself): convert the\r\n      algorithm for reachability, described in detail below, into C++/ITL code.\r\n</ul>\r\n<h3>Input and Output</h3>\r\nRead a file of pairs of node names (representing edges) in a directed\r\n  graph, building a <b>Map</b> whose key is a <b>std::string</b> source node\r\n  and whose value is a <b>Set</b> of <b>std::string</b> destination nodes that\r\n  are each reachable from the source node key.\r\nAlthough most of the supplied input files use 1-letter names, your code should\r\n  work for any strings: use the <b>split</b> function in <b>ics46goody.hpp</b>.\r\n<p>\r\nTwo nodes appear on each line: first the source node, then the destination\r\n  node, with these node names separated by one semicolon character.\r\nFor example, the input file <b>graph1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other):\r\n<b><pre>  c;f\r\n  b;d\r\n  a;c\r\n  c;e\r\n  d;g\r\n  a;b\r\n  e;d\r\n  f;g\r\n  f;d</pre></b>\r\nwhich represent the graph\r\n<p>\r\n<image src=\"images/graph.gif\">\r\n<p>\r\nPrint the graph, one source node per line (the source nodes are printed\r\n  alphabetically) followed by the set of all the destination nodes that the\r\n  source can immediately reach.\r\nThe graph above would print as\r\n<b><pre>    Graph: a node -> set[showing all its destination nodes]\r\n    a -> set[c,b]\r\n    b -> set[d]\r\n    c -> set[f,e]\r\n    d -> set[g]\r\n    e -> set[d]\r\n    f -> set[g,d]</pre></b>\r\n<p>\r\nNote that the source nodes are <b>sorted</b> alphabetically, but the <b>Set</b>\r\n   of destination nodes does <b>not have to be sorted</b>:\r\n  in fact it makes no sense to talk about sorted <b>Sets</b>; we could talk\r\n  about a sorted <b>Priority Queue</b> whose contents came from a <b>Set</b>.\r\nNote that because node <b>g</b> is not a source node (it is only a\r\n  destination node), it does not appear first on any line (and appears only\r\n  in the <b>Sets</b> for source nodes <b>d</b> and <b>f</b>).\r\n<p>\r\nThere are multiple data files for this program: <b>graph1.txt</b>,\r\n  <b>graph2.txt</b>, <b>graph3.txt</b>, and <b>graph4.txt</b>; test/debug your\r\n  program on  the first file; when you are done, test it on the rest.\r\nDraw the graph represented by each file to ensure that your code correctly\r\n  prints it and computes the nodes reachable from any source node (which you\r\n  can do by eyeballing the graphs: they are small).\r\n<p>\r\nRepeatedly prompt the user for a starting node in the graph (until <b>quit</b>\r\n  is entered) and compute and print all the nodes that are reachable from it by\r\n  following edges in the graph.\r\nReject any node not present as a key in the graph.\r\nAn example interaction (processing the graph above) might be\r\n<b><pre>  Enter the starting node (or enter quit): <i>e</i>\r\n  From node e its reachable nodes: set[e,d,g]\r\n\r\n  Enter the starting node (or enter quit): <i>x</i>\r\n    x is not a source node in the graph\r\n\r\n  Enter the starting node (or enter quit): <i>a</i>\r\n  From node a its reachable nodes: set[a,c,b,f,e,d,g]\r\n\r\n  Enter the starting node (or enter quit): <i>quit</i></pre></b>\r\n<h3>Functions and Program</h3>\r\nWrite the following functions and <b>main</b> program.\r\nI am providing line counts not as requirements, but to indicate the lengths of\r\n  well-written C++ code.\r\n<ul>\r\n<li><b>read_graph</b> has a (open) file parameter; it returns the <b>Map</b>\r\n     representing the graph\r\n    (mine is 12 lines of well-formatted code).\r\n<p>\r\n<li><b>print_graph</b> has a <b>Map</b> parameter (representing the graph); it\r\n    returns nothing, but it prints the graph in the appropriate form\r\n     (mine is 6 lines of well-formatted code).\r\n<p>\r\n<li><b>reachable</b> has a <b>Map</b> parameter (representing the graph) and\r\n    a <b>std::string</b> start node in the graph (technically a key in the\r\n    <b>Map</b>); it returns a <b>Set</b> of all the nodes reachable from the\r\n    start node by  following edges in the graph\r\n   (mine is 15 lines of well-formatted code).\r\n<p>\r\n<li>Write a <b>main</b> function at the bottom of this file that calls these\r\n     functions to solve the problem\r\n     (mine is 22 lines of well-formatted code).\r\n    To simplify the interaction, you may prompt for the file name and specify\r\n      a default value (<b>graph1.txt</b>): see my <b>safe_open</b> function\r\n     in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.\r\n<p>\r\nHere is the basic algorithm for computing reachability; it is simple to explain\r\n  and not (very) complicated to implement.\r\nBut, you have to understand these instructions and carefully translate them into\r\n  C++/ITL code.\r\nYou should hand-simulate this algorithm using the graph above, and verify that\r\n  it produces the results you expect before coding it.\r\nYou might be tempted to use recursion, but please don't: unless recursion is\r\n  done very carefully, it will run forever on graphs with cycles: one of the\r\n  input files is a graph with cycles.\r\n<ol>\r\n<li>To compute all the reachable nodes in a graph, create a <b>Set</b>\r\n   (initially empty) of reached nodes and a <b>Queue</b> (initially containing\r\n   the  parameter start node) of nodes that we are going to explore (to find\r\n   nodes they can reach).\r\n<p>\r\n<li>While the <b>exploring queue</b> still has nodes, remove the first one\r\n    and put it into the <b>reached set</b>; if it is a key in the graph (not all\r\n    nodes are) then for all its destination nodes that are not already in the\r\n   <b>reached set</b>, put them in the <b>exploring queue</b>.\r\n<p>\r\n<li>When the <b>exploring queue</b> becomes empty (can you argue that this\r\n      always will happen -there is no infinite looping?), return the\r\n      <b>reached set</b>.\r\n</ol>\r\n<p>\r\nPrint the set containing all these node labels.\r\nWhen debugging this algorithm, print the entire <b>Set</b> and <b>Queue</b>\r\n  contents (using <b>&lt;&lt;</b>, the standard insertion operator for these\r\n  data types) after every interesting change, or use the debugger to observe\r\n  these changes.\r\n</ul>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one (sets will match if they have the same\r\n  contents, independent of their order).\r\nYou should also check that it works for other starting nodes, and\r\n  a variety of starting nodes in the other graphs.\r\n\r\n<b><pre>  Enter the file name describing this graph[graph1.txt]: \r\n\r\n  Graph: a node -> set[showing all its destination nodes]\r\n    a -> set[c,b]\r\n    b -> set[d]\r\n    c -> set[f,e]\r\n    d -> set[g]\r\n    e -> set[d]\r\n    f -> set[g,d]\r\n\r\n  Enter the starting node (or enter quit): <i>e</i>\r\n  From node e its reachable nodes: set[e,d,g]\r\n\r\n  Enter the starting node (or enter quit): <i>x</i>\r\n    x is not a source node in the graph\r\n\r\n  Enter the starting node (or enter quit): <i>a</i>\r\n  From node a its reachable nodes: set[a,c,b,f,e,d,g]\r\n\r\n  Enter the starting node (or enter quit): <i>quit</i></pre></b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem #2 -->\r\n\r\n<a name=\"problem6\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>#2: Instant Runoff Voting<br>(14 pts)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li> Write a program that prompts the user to enter the name of\r\n       a file representing the candidate preferences of a sequence of voters.\r\n<li>Read the information in the file, storing it in a <b>Map</b>.\r\n<li>Print the voter preferences.\r\n<li>Repeatedly display the vote count for ballots (sorted both by candidate\r\n      and numerically), eliminating from the election the candidate(s)\r\n      receiving the fewest votes, until one candidate (the winner) or no\r\n      candidates (a tie) remain.\r\n</ul>\r\nThis form of election is known as <b>instant runoff voting</b>.\r\nEvery voter submits a ballot that ranks all the candidates in an election, from\r\n  most favorite candidate to least favorite (we will use a <b>Queue</b>\r\n  for this purpose</b>: earlier candidates in the <b>Queue</b> are more\r\n  favored than later candidates).\r\n<p>\r\nDuring the first ballot, votes are counted for each of the candidates according\r\n  to the rankings of the voters.\r\nThen the candidate(s) with the fewest number of votes are removed from the\r\n  election: if more than one candidate receives the least number of votes, all\r\n  candidates receiving these least number of votes are removed from the\r\n  election.\r\n<p>\r\nDuring the second ballot, votes are tallied for the <b>remaining candidates</b>\r\n  (there are at least 1 fewer candidates); if a voter's first ranked candidate\r\n  is not still in the  election, then his/her second ranked candidate should\r\n  receive the vote; but if his/her second ranked candidate has been removed\r\n  from the election, then his/her third ranked candidate should receive the\r\n  vote ...).\r\n<p>\r\nThis ballot process continues until either 1 candidate remains, or 0 candidates\r\n  remain (meaning that all the remaining candidates from the previous ballot\r\n  tallied the same number of votes).\r\nNote that the preferences <b>Map</b> never changes, but how it is interpreted\r\n  (which candidate gets the vote) does change, since the interpretation is based\r\n  on which candidates remain in the election.\r\n<h3>Input and Output</h3>\r\nRead a file of voters and their ranking of the candidates, separated\r\n  by semicolons, building a <b>Map</b> whose key is each voter and whose\r\n  value is a <b>Queue</b> of candidates ranked by that voter (they appear in the\r\n  file in order, from most favorite to least favorite).\r\n<p>\r\n\r\nFor example, the input file <b>votepref1.txt</b> contains the following\r\n  lines (which could appear in this order, or any other):\r\n<b><pre>  A;X;Y;Z\r\n  B;Y;Z;X\r\n  C;Y;Z;X\r\n  D;Z;Y;X\r\n  E;Z;Y;X</pre></b>\r\nThe first line means, voter <b>A</b> ranks candidate <b>X</b> first,\r\n  candidate <b>Y</b> second, and candidate <b>Z</b> third.\r\nThe second line means, voter <b>B</b> ranks candidate <b>Y</b> first,\r\n  candidate <b>Z</b> second, and candidate <b>X</b> third.\r\nEach line will have a unique voter and a permutation of all the \r\n  candidates running.\r\n<p>\r\nPrint all the associations in this <b>Map</b>, one per line (the voters are\r\n  printed alphabetically) using the following form.\r\nEach line contains the voter and his/her complete ranking of the candidates.\r\nFor example, the file above would produce:\r\n<b><pre>    Preferences: voter -> queue[candidates in order]\r\n    A -> queue[X,Y,Z]:rear\r\n    B -> queue[Y,Z,X]:rear\r\n    C -> queue[Y,Z,X]:rear\r\n    D -> queue[Z,Y,X]:rear\r\n    E -> queue[Z,Y,X]:rear</pre></b>\r\n<p>\r\nNote that the voter names are <b>sorted</b> alphabetically, but the <b>Queue</b>\r\n  of preferences appears in the same order they appeared in the file.\r\nThere are multiple data files for this program: <b>votepref1.txt</b>, \r\n  <b>votepref2.txt</b>, <b>votepref3.txt</b>, and <b>votepref4.txt</b>;\r\n  test/debug your program on the first file; when you are done, test it on the\r\n  rest.\r\n<p>\r\nStart with all the candidates.\r\nEvaluate the ballot to determine how many votes each candidate received.\r\nPrint this vote count two ways: sorted alphabetically and sorted numerically\r\n  (in decreasing order: if more than one candidate receives the same number of\r\n   votes, they should appear sorted alphabetically).\r\nRemove the candidate(s) receiving the fewest votes, and repeat this process\r\n  until only one or no candidates remain.\r\nFinally, print the outcome of the election: a single candidate winner or a tie.\r\nAn example interaction (processing the preferences above) might be\r\n<b><pre>  Vote count on ballot #1: candidates (sorted alphabetically) using only candidates in set = set[X,Y,Z]\r\n    X -> 1\r\n    Y -> 2\r\n    Z -> 2\r\n  \r\n  Vote count on ballot #1: candidates (sorted numerically) using only candidates in set = set[X,Y,Z]\r\n    Y -> 2\r\n    Z -> 2\r\n    X -> 1\r\n\r\n  Vote count on ballot #2: candidates (sorted alphabetically) using only candidates in set = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Vote count on ballot #2: candidates (sorted numerically) using only candidates in set = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\nElection winner is Y</pre></b>\r\nThe first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, \r\n  and <b>Z</b>.\r\nFor this ballot, the votes were counted and printed; candidate <b>X</b>\r\n  received the fewest number of votes so is eliminated from the next ballot.\r\nThe second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.\r\nFor this ballot, the votes were counted and printed; candidate <b>Z</b>\r\n  received the fewest number of votes so is eliminated from the next ballot.\r\nThere is only one candidate remaining so <b>Y</b> is declared the winner.\r\nAn alternative outcome prints\r\n<b>Tie among final candidates: cannot choose one unique winner</b>\r\n\r\n<h3>Functions and Program</h3>\r\nWrite the following functions and <b>main</b> program.\r\nI am providing line counts not as requirements, but to indicate the lengths of\r\n  well-written C++ code.\r\n<ul>\r\n<li><b>read_voter_preferences</b> has an (open) file parameter; it returns the\r\n       <b>Map</b> representing each voter and his/her preferences\r\n      (mine is 14 lines of well-formatted code).\r\n<p>\r\n<li><b>print_voter_preferences</b> has a <b>Map</b> of voter preferences as a\r\n         parameter and returns nothing;\r\n         it prints the title followed by the <b>Map</b> whose keys are in\r\n         alphabetical order\r\n       (mine is 7 lines of well-formatted code).\r\n<p>\r\n<li><b>print_tally</b> has a <b>std::string</b> title, a <b>Map</b> of\r\n         candidates and their number of votes, and a\r\n         function pointer as parameters and returns nothing; it\r\n         prints the title followed by the <b>Map</b> in the appropriate order\r\n         (specified  by the function pointer)\r\n       (mine is 7 lines of well-formatted code).\r\n<p>\r\n<li><b>evaluate_ballot</b> has a <b>Map</b> of voter preferences and a\r\n         <b>Set</b> of the remaining candidates as parameters; it returns\r\n         a tally: a <b>Map</b> whose keys are these candidates and whose values\r\n         are the number of votes they received on this ballot, based on the\r\n         description of <b>instant runoff voting</b>.\r\n       Remember to count only one vote per voter, for his/her highest ranked\r\n         candidate who is still in the election\r\n      (mine is 12 lines of well-formatted code).\r\n<p>\r\n<li><b>remaining_candidates</b> has a <b>Map</b> as a parameter whose keys are\r\n          candidates and whose values are the number of votes they received and\r\n          returns a set containing all those candidates remaining in the\r\n          election (the one(s) receiving the fewest number of votes are absent).\r\n       Note that if all the candidates receive the same number of votes, then\r\n         this function returns an empty <b>Set</b>\r\n       (mine is 11 lines of well-formatted code).\r\n<p>\r\n<li>Write a <b>main</b> function at the bottom of this file that calls these\r\n      functions to solve the problem\r\n    (mine is 34 lines of well-formatted code).\r\n   To simplify the interaction, you may prompt for the file name and specify\r\n      a default value (<b>votepref1.txt</b>): see my <b>safe_open</b>\r\n      function in <b>ics46goody.hpp</b> in the <b>courselib/src</b> folder.\r\n</ul>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<pre><b>  Enter the file name describing all the voter preferences[votepref1.txt]:\r\n\r\n  Preferences: voter -> queue[candidates in order]\r\n    A -> queue[X,Y,Z]:rear\r\n    B -> queue[Y,Z,X]:rear\r\n    C -> queue[Y,Z,X]:rear\r\n    D -> queue[Z,Y,X]:rear\r\n    E -> queue[Z,Y,X]:rear\r\n\r\n  Vote count on ballot #1: candidates (sorted alphabetically) using only candidates in set = set[X,Y,Z]\r\n    X -> 1\r\n    Y -> 2\r\n    Z -> 2\r\n  \r\n  Vote count on ballot #1: candidates (sorted numerically) using only candidates in set = set[X,Y,Z]\r\n    Y -> 2\r\n    Z -> 2\r\n    X -> 1\r\n\r\n  Vote count on ballot #2: candidates (sorted alphabetically) using only candidates in set = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Vote count on ballot #2: candidates (sorted numerically) using only candidates in set = set[Y,Z]\r\n    Y -> 3\r\n    Z -> 2\r\n\r\n  Election winner is Y</pre></b>\r\n<p>\r\nYou can also try processing the <b>votepref2.txt</b> file (which leads to\r\n  printing\r\n  <b>Tie among final candidates: cannot choose one unique winner</b>),\r\n  <b>votepref3.text</b>, and <b>votepref4.txt</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem 3 -->\r\n\r\n<a name=\"problem3\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>#3: Finite Automata<br>(14 pts)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li>Write a program that prompts the user to enter the name of\r\n       a file representing a finite automaton: indicating its <b>states</b> and\r\n       <b>transitions</b> (each transition out of a state specifies the\r\n       <b>input</b> and the new <b>state</b>).\r\n<li>Read the information in the file, storing it in a <b>Map</b>.\r\n<li>Print the finite automaton.\r\n<li>Prompt the user to enter the name of a file storing the start-state\r\n      and inputs to process (each line in the file contains this combination).\r\n<li>Repeatedly process these lines computing the results of the finite\r\n      automaton on each input, and then display a trace of the results.\r\n</ul>\r\nA <b>finite  automaton</b> (FA) is a machine that is sometimes called\r\n  Deterministic Finite Automaton (DFA).\r\nAn FA is described by its <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what\r\n  new <b>state</b> in the FA that input leads to.\r\nWe can illustrate a FA as a graph with labelled edges (see below).\r\n<p>\r\n\r\n<h3>Input and Output</h3>\r\nRead a file that describes a FA: each line contains a state and an\r\n  arbitrary number of input-&gt;new state <b>transitions</b>.\r\nBuild a <b>Map</b> such that each key is a <b>std::string</b> state and whose\r\n   associated value is another <b>Map</b> specifying of the transitions from\r\n   that state: this second <b>Map</b> has keys that are <b>std::string</b>\r\n   inputs and associated values that are <b>std::string</b> states.\r\nThe first token on each line is the <b>std::string</b> state and the remaining\r\n  tokens (always coming in pairs) are <b>std::string</b> inputs and states.\r\nAll tokens are separated by one semicolon character.\r\n<p>\r\n\r\nFor example, the input file <b>faparity.txt</b> contains the following lines\r\n  (which could appear in this order, or any other):\r\n<b><pre>  even;0;even;1;odd\r\n  odd;0;odd;1;even</pre></b>\r\nHere is a picture of the <b>parity</b> FA.\r\nIt graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)\r\n  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)\r\n  that always lead back to one of these two states.\r\n<p>\r\n\r\n<img src=\"images/parity.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>even</b> (meaning it has seen an even number of <b>1</b>\r\n  inputs so far) is a key in the main <b>Map</b>.\r\nIts value is a <b>Map</b> with two key/value pairs <b>0</b>/<b>even</b>\r\n  and <b>1</b>/<b>odd</b>.\r\nIt means that in the <b>even</b> state, if the input is a <b>0</b> the\r\n  FA stays in the <b>even</b> state; if the input is a <b>1</b> the\r\n  FA goes to the <b>odd</b> state.\r\nAnd similarly (the next line) means that for the <b>odd</b> state, if the input\r\n  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a\r\n  <b>1</b> the FA goes back to the <b>even</b> state.\r\nSo, seeing an input of <b>0</b> keeps the FA in the same state;\r\n  seeing an input of <b>1</b> flips the FA into the other state.\r\n<p>\r\n\r\nPrint the finite automaton, one state (and its transitions) per line;\r\n  the states are printed alphabetically.\r\n<p>\r\nFor example, the file above would produce:\r\n<b><pre>  The Description of the file entered for this Finite Automaton\r\n    even transitions: map[0->even,1->odd]\r\n    odd transitions: map[0->odd,1->even]</pre></b>\r\n<p>\r\nNote that there are multiple data files for this program: <b>faparity.txt</b>\r\n  and <b>fadivisibleby3.txt</b>; test/debug your program on \r\n  the first file; when you are done, test it on the last file.\r\nDraw the FA represented by each for to ensure that your code correctly\r\n  prints and computes with it.\r\n<p>\r\nRepeatedly process lines from a second input file, computing the results of the\r\n  finite automaton for a start-state and its inputs; then print out all the\r\n  results in a special form.\r\nEach line in the file contains a start-state followed by a sequence of inputs.\r\nThe start-state will be a state in the FA (is a key in the outer <b>Map</b>)\r\n  the inputs may specify legal or illegal transitions (may or may not be keys\r\n  in some inner <b>Map</b>).\r\n<p>\r\nFor example, the input file <b>fainputparity.txt</b> contains the following\r\n  three lines:\r\n<b><pre>  even;1;0;1;1;0;1\r\n  odd;1;0;1;1;0;1\r\n  even;1;0;1;1;0;x</pre></b>\r\nThe first line means, the start-state is <b>even</b> and the\r\n  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\nThe result of processing each line is to print the start-state, and then each\r\n  input and the new state it transitions to, and finally print the stop-state.\r\nFor the <b>parity</b> FA and the first line in this file, it should print\r\n<b><pre>Start state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\n  input = 1; new state = odd\r\n  input = 0; new state = odd\r\n  input = 1; new state = even\r\nStop state = even</pre></b>\r\n<p>\r\n\r\n<h3>Functions and Program</h3>\r\nWrite the following functions and <b>main</b> program.\r\nI am providing line counts not as requirements, but to indicate the lengths of\r\n  well-written C++ code.\r\n<ul>\r\n<li><b>read_fa</b> has an (open) file parameter; it returns the <b>Map</b>\r\n     representing the finite automaton\r\n     (mine is 17 lines  of well-formatted code).\r\n<p>\r\n<li><b>print_fa</b> has a <b>Map</b> parameter (representing the fa); it\r\n    returns nothing,  but it prints the fa in the appropriate form\r\n     (mine is 6 lines  of well-formatted code).\r\n<p>\r\n<li><b>process</b> has a <b>Map</b> parameter (representing the fa),\r\n    a <b>std::string</b> parameter (representing the start-state), and a\r\n    <b>Queue</b> parameter (representing a <b>Queue</b> of <b>std::string</b>\r\n    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of\r\n    <b>std::string</b> that show the input and resulting state after each\r\n    transition (the first value on the <b>Queue</b> has an input that is an\r\n    empty string and the start state).\r\n    For the example shown above, <b>process</b> returns the following\r\n    <b>Queue</b>.\r\n<b><pre>queue[pair[,even],pair[1,odd],pair[0,odd],pair[1,even],pair[1,odd],pair[0,odd],pair[1,even]]:rear</pre></b>\r\n    Finally, if an input is illegal (is not the key in some transition for the\r\n    current state), say\r\n    <b>\"x\"</b>, then <b>process</b> should terminate with the last\r\n    <b>pair</b> in the <b>Queue</b> indicating a problem: <b>(x, None)</b>\r\n   (mine is 13 lines  of well-formatted code).\r\n<p>\r\n<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by the\r\n    <b>process</b> function described above); it returns nothing, but it prints\r\n    the results of processing a fa on an input.\r\n    See how it prints the <b>Queue</b> shown above in the output further above.\r\n    Also see the <b>Sample Interaction</b> below to see how it prints\r\n    <i>input errors</i> (in the last example)\r\n   (mine is 13 lines  of well-formatted code).\r\n<p>\r\n<li>Write a <b>main</b> function at the bottom of this file that calls these\r\n      functions to solve the problem.\r\n      Note that the program loops over the lines in the second file\r\n       (mine is 23 lines  of well-formatted code).\r\n    To simplify the interaction, you may prompt for the file name and specify\r\n      a default value (<b>faparity.txt</b> and <b>fainputparity.txt</b>): see\r\n      my <b>safe_open</b> function in <b>ics46goody.hpp</b> in the\r\n      <b>courselib/src</b> folder.\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<b><pre>  Enter the file name describing this Finite Automaton[faparity.txt]:\r\n\r\n  The Description of the file entered for this Finite Automaton\r\n    even transitions: map[0->even,1->odd]\r\n    odd transitions: map[0->odd,1->even]\r\n\r\n  Enter the file name describing a sequence of start-states and all their inputs[fainputparity.txt]:\r\n  \r\n  Start tracing this FA in its start-state: even;1;0;1;1;0;1\r\n  Start state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n  Stop state = even\r\n  \r\n  Start tracing this FA in its start-state: odd;1;0;1;1;0;1\r\n  Start state = odd\r\n    Input = 1; new state = even\r\n    Input = 0; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 0; new state = even\r\n    Input = 1; new state = odd\r\n  Stop state = odd\r\n  \r\n  Start tracing this FA in its start-state: even;1;0;1;1;0;x\r\n  Start state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = 1; new state = even\r\n    Input = 1; new state = odd\r\n    Input = 0; new state = odd\r\n    Input = x; illegal input: simulation terminated\r\n  Stop state = None</b></pre>\r\n<p>\r\nYou can also try the <b>fadivisibleby3.txt</b> finite automaton file, which\r\n  determines whether an integer (sequence of digits) is divisible by 3: it is\r\n  if the finite automaton stops in state <b>rem0</b> (which stand for <b>has\r\n  remainder 0</b>).\r\nIts input file is <b>fainputdivisibleby3.txt</b>, which represents the \r\n  number <b>12,435,711</b>, which is divisible by <b>3</b>, followed by the\r\n  number <b>823</b>, which is not divisible by <b>3</b> (it has a remainder of\r\n  <b>1</b> when divided by <b>3</b>).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem 4 -->\r\n\r\n<a name=\"problem4\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>#4: Non-Deterministic FA<br>(10 pts)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<li> Write a program that solves for a Non-Deterministic Finite\r\n       Automaton the same problem that was solved for a Deterministic Finite\r\n       Automaton in Problem #3 (above).\r\n<p>\r\nA non-deterministic finite automaton (NDFA) is machine described by its\r\n  <b>states</b> and its <b>transitions</b>:\r\n  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what\r\n  <b>state</b> (or <b>states</b>: that what makes it non-deterministic) that\r\n  input leads to.\r\nWe can illustrate an NDFA as a graph with labelled edges (see below).\r\nThe critical difference is that an NDFA can have multiple edges with the same\r\n  label going to different states (we'll see how to handle such transitions\r\n  below).\r\n<p>\r\n\r\n<h3>Input and Output</h3>\r\nRead a file that describes an NDFA: each line contains a state and an\r\n  arbitrary number of input-&gt;state <b>transitions</b>.\r\nBuild a <b>Map</b> such that each key is a <b>std::string</b> state and whose\r\n   value is another <b>Map</b> specifying of the transitions from that state:\r\n   this second <b>Map</b> has keys that are <b>std::string</b> inputs and \r\n   values are <b>Sets</b> of <b>std::string</b> states: all the states a\r\n   particular input can lead to.\r\nThe first token on each line is the <b>std::string</b> state and the remaining\r\n  tokens (always coming in pairs) are <b>std::string</b> inputs and states:\r\nhere the same input can appear multiple times with different states following.\r\nAll tokens are separated by one semicolon character.\r\n<p>\r\n\r\nFor example, the input file <b>ndfaendin01.txt</b> contains the following lines\r\n  (which could appear in this order, or any other):\r\n<b><pre>  start;0;start;1;start;0;near\r\n  near;1;end\r\n  end</pre></b>\r\nHere is a picture of the <b>endin01</b> NDFA.\r\nIt graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,\r\n  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>\r\n  and <b>1</b>).\r\n<p>\r\n\r\n<img src=\"images/endin01.jpg\"></img>\r\n<p>\r\n\r\nHere, the state <b>start</b> is a key in the main <b>Map</b>.\r\nIts value is a <b>Map</b> with two key/value pairs <b>0</b> mapping to the\r\n  <b>Set</b> containing <b>start</b> and <b>near</b> and <b>1</b> mapping to\r\n  the <b>Set</b> containing just <b>start</b>.\r\nIt means that in the <b>start</b> state, if the input is a <b>0</b> the\r\n  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>\r\n  state; if the input is a <b>1</b> the NDFA must stay in the <b>start</b>\r\n  state.\r\nAnd similarly the next line means that in the <b>near</b> state, if the\r\n  input is a <b>1</b> the NDFA must go into the <b>end</b> state.\r\nThe last line means that the <b>end</b> state has no transitions out of it.\r\n<p>\r\n\r\nPrint the NDFA, one state (and its transitions) per line;\r\n  the states are printed alphabetically and the transition <b>Map</b>\r\n  for each state is printed in the form of a standard <b>Map</b>: a series in\r\n  the form <b>input -> set of states</b>.\r\nNote that the state <b>end</b> is a key in the main <b>Map</b>, whose\r\n  associated transitions are an empty <b>Map</b>.\r\n<p>\r\n\r\nFor example, the file above would produce:\r\n<b><pre>  The Description of the file entered for this Non-Deterministic Finite Automaton\r\n    end transitions: map[]\r\n    near transitions: map[1->set[end]]\r\n    start transitions: map[0->set[start,near],1->set[start]]</pre></b>\r\n<p>\r\nNote that there are multiple data files for this program:\r\n  <b>ndfaendin01.txt</b>, <b>ndfatrain.txt.txt</b>, and <b>ndfare.txt</b>;\r\n  test/debug your program on the first file; when you are done, test it on the\r\n  rest.\r\nDraw the NDFA represented by each for to ensure that your code correctly\r\n  prints and computes with it.\r\n<p>\r\nRepeatedly process lines from a second matching input file\r\n (<b>ndfainputendin01.txt</b> for the example above), computing the results of\r\n  the non-deterministic finite automaton for a start-state and its inputs; then\r\n  print out all the results in a special form.\r\nEach line in the file contains a start-state followed by a sequence of inputs.\r\nThe start-state will be a state in the NDFA (is a key in the outer <b>Map</b>)\r\n  the inputs specify transitions (which may or may not be keys in some inner\r\n  <b>Map</b>).\r\n<p>\r\nFor example, the input file <b>ndfainputendin01.txt</b> contains the following\r\n  two lines:\r\n<b><pre>  start;1;0;1;1;0;1\r\n  start;1;0;1;1;0;0</pre></b>\r\nFor example, the first line means, the start-state is <b>start</b> and the\r\n  inputs <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.\r\n<p>\r\n\r\nThe result of processing each line is to print the start-state, and then each\r\n  input and the new states (plural) it could transition to (the <b>could</b>\r\n  is what makes it non-deterministic), and finally print the stop-states.\r\nFor the <b>ndfaendin01</b> NDFA and the first line in this file, it should print\r\n<b><pre>  Start state = set[start]\r\n    Input = 1; new states possible = set[start]\r\n    Input = 0; new states possible = set[start,near]\r\n    Input = 1; new states possible = set[start,end]\r\n    Input = 1; new states possible = set[start]\r\n    Input = 0; new states possible = set[start,near]\r\n    Input = 1; new states possible = set[start,end]\r\n  Stop state(s) = set[start,end]</pre></b>\r\n<p>\r\n\r\nNote especially that in the <b>start</b> state, if the input is a <b>0</b>,\r\n  then the NDFA can either remain in the <b>start</b> state or go into the\r\n  <b>near</b> state.\r\nFor this program, we keep track of all states that the NDFA can be in,\r\n  using a <b>set</b> of <b>new possible states</b>.\r\nFor the next input, <b>1</b>, we can be either in the <b>start</b> state\r\n  (from the <b>start</b> state, an input of <b>1</b> allows us to stay in the\r\n  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state, an\r\n  input of <b>1</b> allows us to transition to the <b>end</b> state).\r\nThus, we keep track of the <b>set</b> of states the NDFA can be in, and the\r\n  new <b>set</b> of states the NDFA can be in after processing the next input\r\n  for each of these states.\r\nIn this example, because <b>end</b> is included in the stop-states, this\r\n  input does end in <b>01</b>.\r\n<p>\r\n<h3>Functions and Program</h3>\r\nWrite the following functions and <b>main</b> program.\r\nI am providing line counts not as requirements, but to indicate the lengths of\r\n  well-written C++ code.\r\n<ul>\r\n<li><b>read_ndfa</b> has an open (file) parameter; it returns the <b>Map</b>\r\n     representing the non-deterministic finite automaton; <b>hint</b>: I used\r\n     a <b>while</b> loop to read lines and a nested <b>for</b> loop to construct\r\n     the <b>Map</b> storing each input and the <b>Set</b> of states it can lead\r\n     to (mine is 17 lines of well-formatted code).\r\n<p>\r\n<li><b>print_ndfa</b> has a <b>Map</b> parameter (representing the NDFA); it\r\n    returns nothing,  but it prints the NDFA in the appropriate form\r\n     (mine is 6 lines of well-formatted code).\r\n<p>\r\n<li><b>process</b> has a <b>Map</b> parameter (representing the NDFA),\r\n    a <b>std::string</b> parameter (representing the start-state), and a\r\n    <b>Queue</b> parameter (representing the sequence of <b>std::string</b>\r\n    inputs); it returns a <b>Queue</b> that contains <b>pair</b>s of \r\n    inputs and the resulting states after each transition.\r\n    For the example shown above, <b>process</b> returns the following\r\n    <b>Queue</b>.\r\n<b><pre>  queue[pair[,set[start]],pair[1,set[start]],pair[0,set[start,near]],pair[1,set[start,end]],\r\n        pair[1,set[start]],pair[0,set[start,near]],pair[1,set[start,end]]]:rear</pre></b>\r\n    Finally, if an input is illegal (is not the key in some transition for the\r\n    current state), just ignore it\r\n   (mine is 13 lines of well-formatted code).\r\n<p>\r\n<li><b>interpret</b> has a <b>Queue</b> parameter (the result produced by\r\n    <b>process</b>; it returns nothing, but it prints the results of processing\r\n    an NDFA on an input.\r\n    See how it prints the <b>Queue</b> shown above in the output further above\r\n   (mine is 10 lines of well-formatted code).\r\n<p>    \r\n<li>Write a <b>main</b> function at the bottom of this file that calls these\r\n      functions to solve the problem.\r\n    Note that this function loops over the lines in the second file\r\n   (mine is 23 lines of well-formatted code).\r\n</ul>\r\n<p>\r\n\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should \"match\" this one (recall the order of values in sets is\r\n  not important).\r\n<b><pre>  Enter the file name describing this Non-Deterministic Finite Automaton: <i>ndfaendin01.txt</i>\r\n\r\n  The Description of the file entered for this Non-Deterministic Finite Automaton\r\n    end transitions: map[]\r\n    near transitions: map[1->set[end]]\r\n    start transitions: map[0->set[start,near],1->set[start]]\r\n\r\n  Enter the file name describing a sequence of start-states and all their input: <i>ndfainputendin01.txt</i>\r\n\r\n  Start tracing this NDFA in its start-state: start;1;0;1;1;0;1\r\n  Start state = set[start]\r\n    Input = 1; new states possible = set[start]\r\n    Input = 0; new states possible = set[start,near]\r\n    Input = 1; new states possible = set[start,end]\r\n    Input = 1; new states possible = set[start]\r\n    Input = 0; new states possible = set[start,near]\r\n    Input = 1; new states possible = set[start,end]\r\n  Stop state(s) = set[start,end]\r\n\r\n  Start tracing this NDFA in its start-state: start;1;0;1;1;0;0\r\n  Start state = set[start]\r\n    Input = 1; new states possible = set[start]\r\n    Input = 0; new states possible = set[start,near]\r\n    Input = 1; new states possible = set[start,end]\r\n    Input = 1; new states possible = set[start]\r\n    Input = 0; new states possible = set[start,near]\r\n    Input = 0; new states possible = set[start,near]\r\n  Stop state(s) = set[start,near]</pre></b>\r\n<p>\r\nThe <b>ndfatrain.txt</b> file is a non-deterministic finite automaton\r\n  that determines whether an train (sequence of characters representing\r\n  different kinds of cars) is a legal train according to Chapter Exercise #7\r\n  in the ENBF lecture from ICS-33..\r\nIts input file is <b>ndfainputtrain.txt</b>, whose first input represents a\r\n  legal train: ends when <b>done</b> is one possible stopping state; and second\r\n  input represents an illegal train.\r\n<p>\r\nThe <b>ndfare.txt</b> file is a non-deterministic finite automaton translation\r\n  of the regular expression <b>((a*|b)cd)+</b>. \r\nIts input file is <b>ndfainputre.txt</b>, whose first input represents a\r\n  matching string: ends when <b>last</b> as one possible stopping state; and\r\n  input second does not\r\n  match.\r\n</td>\r\n</tbody>\r\n</table>\r\n  \r\n\r\n<!-- Problem #5 New for Winter 2016\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>#5: Google Queries<br>(8 pts)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li> Write a program that prompts the user to enter the name of a file of text\r\n       representing a sequence of multiple-word (full) Google queries.\r\n<li>Read the file of text, storing its information special <b>prefix</b> and\r\n      <b>query</b> <b>Map</b>s.\r\n<li>Print the <b>prefix Map</b> and <b>query Map</b>.\r\n<li>Repeatedly prompt the user to enter any prefix query and the <b>top n</b> \r\n      full queries to print, then print the <b>n</b> most frequehnt full\r\n      queries with that prefix.\r\n</ul>\r\n<p>\r\n<h3>Background:</h3>\r\nWhen we type a word (or a few words) into Google's query box, it shows some of\r\n  the most frequently entered queries starting with those word(s).\r\nFor example, when I recently typed the word <b>uci</b> into Google, it showed\r\n  the following as the 3 most frequent queries starting with <b>uci</b>:\r\n<ul>\r\n<li><b>uci law</b>\r\n<li><b>uci medical center</b>\r\n<li><b>uci women's soccer</b>\r\n</ul>\r\nI could have clicked on one of these queries to select it, or continued typing\r\n  more words to specify my own (different) query.\r\n<p>\r\nHere we say <b>uci</b> is a <b>prefix</b>, which is the beginning of some\r\n  <b>full query</b>, like <b>uci medical center</b>.\r\n<p>\r\nGoogle represents a <b>full query</b> as a <b>queue</b> of <b>std::string</b>\r\n  (words).\r\nFor example, <b>queue[uci,medical,center]:rear</b> is a <b>full query</b>.\r\nGoogle also represents a <b>prefix</b> as a <b>queue</b> of <b>std::string</b>\r\n  (words).\r\nFor example, <b>queue[uci]:rear</b> is a one-word <b>prefix</b> and\r\n  <b>queue[uci,medical]:rear</b> is a two-word <b>prefix</b> of this\r\n  <b>full query</b>.\r\n<p>\r\nFrom any <b>full query</b> we can compute a <b>set</b> of all its\r\n  <b>prefix</b>es.\r\nFor example, the <b>full query</b> <b>queue[uci,medical,center]:rear</b>\r\n  would compute the <b>prefix set</b>\r\n  <b>set[queue[uci]:rear,queue[uci,medical]:rear,queue[uci,medical,center]:rear]</b>.\r\nThe <b>prefix set</b> includes a <b>queue</b> of the first word, \r\n  a <b>queue</b> of the first two words, ...\r\n  and finally a <b>queue</b> of all the words in the <b>full query</b>.\r\n<p>\r\nGoogle stores information (in maps) that allows it to predict the most\r\n  likely <b>full query</b> from any <b>prefix</b> the user enters in the\r\n  Google search box (as discussed in the example above).\r\nThe prediction is based on (1) knowing all the <b>full queries</b> for a\r\n  <b>prefix</b> and (2) knowing how many times each <b>full query</b> was\r\n  used.\r\nUsing this information, Google can show the user the most frequently\r\n  entered <b>full queries</b> for the <b>prefix</b> he/she typed.\r\n<p>\r\nGoogle stores two maps to accomplish this task.\r\n<ol>\r\n<li>Google stores a <b>prefix</b> map whose <b>key</b> is a\r\n  <b>prefix</b> (a <b>queue</b> of <b>std::string</b>) and whose <b>associated\r\n  value</b> is a <b>set</b> of <b>queue</b>: all the <b>full queries</b> that\r\n  have been entered for that <b>prefix</b>.\r\n<p>\r\n<li>Google stores a <b>query</b> map whose <b>key</b> is a\r\n  <b>full query</b> (again a <b>queue</b> of <b>std::string</b>) and whose\r\n  <b>associated value</b> is an <b>int</b>: the number of times (the frequency)\r\n  that that <b>full query</b> was used.\r\n</ol>\r\n<p>\r\nIn this program you will build these maps and then use them it to\r\n  predict a <b>full query</b> from a <b>prefix</b> entered by the user, and\r\n  update the maps for any new query.\r\n<p>\r\n<h3>Input and Output:</h3>\r\nAfter prompting the user for the file of full queries, read the file, building\r\n  the <b>prefix</b> and <b>query</b> mapss (we are dropping the word\r\n  <b>full</b> now).\r\n<p>\r\nFor a simple example, the file <b>googleq0.txt</b> contains the following\r\n  lines (in it, for simplicity and conciseness, we abbreviated\r\n  b = basketball, c = center, l = law, m = medical, s = soccer,  u = uci, and\r\n  w = women's).\r\n<b><pre>  u m c\r\n  u l\r\n  u w s\r\n  u l\r\n  u  s\r\n  u w b\r\n  u w b\r\n  u w b</pre></b>\r\n<p>\r\nThe program will first read this file and build the appropriate <b>prefix</b>\r\n  and <b>query</b> map; then it will print each map.\r\nThe <b>prefix</b> map should be sorted by keys, from the shortest to\r\n  longest prefix, with equal-length prefixes sorted in standard lexical order;\r\n  of course the associated sets may print their values in any order.\r\nThe <b>query</b> map should be sorted by associated values (integers),\r\n  from largest to smallest integer, with equal integers sorted by their keys in\r\n  standard lexical order.\r\n<p>\r\nFor example, the file above would produce the following output:\r\n<b><pre>  Prefix map:\r\n    queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n    queue[u,l]:rear -> set[queue[u,l]:rear]\r\n    queue[u,m]:rear -> set[queue[u,m,c]:rear]\r\n    queue[u,m,c]:rear -> set[queue[u,m,c]:rear]\r\n    queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n    queue[u,w,b]:rear -> set[queue[u,w,b]:rear]\r\n    queue[u,w,s]:rear -> set[queue[u,w,s]:rear]\r\n\r\n  Query map:\r\n    queue[u,w,b]:rear -> 3\r\n    queue[u,l]:rear -> 2\r\n    queue[u,w,s]:rear -> 2\r\n    queue[u,m,c]:rear -> 1</pre></b>\r\n<p>\r\nIn the <b>prefix</b> map <b>queue[u]:rear</b> appears before\r\n  <b>queue[u,l]:rearl</b> because it has fewer words; and\r\n  <b>queue[u,l]:rear</b> appears before <b>queue[u,w]:rear</b>\r\n  because in standard lexical order, when 2-queues have equal\r\n  first values, they are ordered by their second values, and <b>l</b> comes\r\n  before <b>w</b>.\r\n<p>\r\nIn the <b>query</b> map <b>queue[u,w,b]</b> appears before\r\n  <b>queue[u,l]:rear</b> because the first queues associated value\r\n  (<b>3</b>) is bigger than the second queue's (<b>2</b>); and\r\n  <b>queue[u,l]:rear</b> appears before <b>queue[u,w,s]:rear</b>\r\n  because when queues are associated with equal values (<b>2</b>), they are\r\n  ordered lexically, and <b>queue[u,l,...]:rear</b>\r\n  comes before  <b>queue[u,w,...)</b> (see the reasoning above).\r\n<p>\r\nNow, repeatedly prompt the user for any query prefix (and <b>n</b>, for the\r\n  <b>top n</b> to print) and print the <b>top n</b> full queries for the\r\n  entered prefix: print them in in a priority queue ordered from most to least\r\n  frequent full query (with ties printed using the standard lexical ordering;\r\n  the same ordering used when printing the Query map above).\r\nUsing the maps above the iteraction would be.\r\n<p>\r\n<pre><b>  Enter a prefix (or quit): u\r\n  Enter n (as in \"top n\" to print)[3]: 2\r\n    Top 2 (at most) full queries = priority_queue[pair[queue[u,l]:rear,2],pair[queue[u,w,b]:rear,3]]:highest]</b></pre>\r\nFinally, prompt the user to enter the full query, and update the maps and \r\n  reprint them.\r\n<pre><b>  Enter a full query (or quit): u w s\r\n\r\n  Prefix map:\r\n    queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n    queue[u,l]:rear -> set[queue[u,l]:rear]\r\n    queue[u,m]:rear -> set[queue[u,m,c]:rear]\r\n    queue[u,m,c]:rear -> set[queue[u,m,c]:rear]\r\n    queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n    queue[u,w,b]:rear -> set[queue[u,w,b]:rear]\r\n    queue[u,w,s]:rear -> set[queue[u,w,s]:rear]\r\n\r\n  Query map:\r\n    queue[u,w,b]:rear -> 3\r\n    queue[u,w,s]:rear -> 3\r\n    queue[u,l]:rear -> 2\r\n    queue[u,m,c]:rear -> 1</b></pre>\r\nHere, the prefix map stays the same (the full query already was entered\r\n  once; we could have entered a new full query, which would augment the prefix\r\n  dictionary), and the full query <b>query[u,w,s)</b> has its query-count\r\n  increased from <b>2</b> to <b>3</b>.\r\n<p>\r\n\r\n<h3>Functions and Program:</h3>\r\nWrite the following functions and script.\r\nI am providing line counts not as requirements, but to indicate the lengths of\r\n  well-written Pythonic code.\r\n<ul>\r\n<li><b>all_prefixes</b> has a <b>Queue</b> of <b>std::string</b>\r\n         (words) parameter; it returns a <b>Set</b> of <b>Queue</b> of\r\n         <b>std::string</b>: all the <b>prefixes</b> of the <b>full query</b>\r\n         argument.\r\n       For example, <b>all_prefixes(ArrayQueue({\"a\",\"b\",\"c\"))</b> returns\r\n         <b>set[queue[a],queue[a,b],queue[a,b,c]]</b>.\r\n       <b>Hints:</b> comprehension and slicing\r\n       (mine is 9 lines of well-formatted code).\r\n<p>\r\n<li><b>add_query</b> has a prefix map, query map, and full query\r\n         as parameters; it returns nothing, but it updates these two map based\r\n         on the full query.\r\n       It adds the new query's prefixes to the prefix map (each associated\r\n          with the full query) and increments the integer value associated with\r\n          that full query in the query map (or, if the full query is\r\n           new, associates that query with 1)\r\n       (mine is 5 lines of well-formatted code).\r\n<p>\r\n<li><b>read_queries</b> has an (open) file, prefix map, and a query map as\r\n         parameters; it returns nothing, but it updates these two map based on\r\n         reading and processing each full query in this file\r\n       (mine is 8 lines of well-formatted code).\r\n<p>\r\n<li><b>print_prefix</b> has a <b>Map</b> parameter;  it\r\n    returns nothing, but it prints the prefix map in the appropriate form\r\n   (mine is 7 lines of well-formatted code + the <b>prefix_gt</b> function).\r\n   Note: my <b>prefix_gt</b> function calls <b>word_queue_gt</b>.\r\n<p>\r\n<li><b>print_query</b> has a <b>Map</b> parameter; it\r\n    returns nothing, but it prints the query map in the appropriate form\r\n   (mine is 7 lines of well-formatted code + the <b>query_gt</b> function).\r\n   Note: my <b>query_gt</b> function also calls <b>word_queue_gt</b>.\r\n<p>\r\n<li><b>top_n</b> has a prefix (<b>queue</b> of <b>std::string</b>), <b>int</b>,\r\n        prefix map, and query map as parameters; it returns a\r\n        <b>PriorityQueue</b> of query pairs (<b>queue</b> of <b>std::str</b>\r\n        associated with <b>int</b>) whose length is the integer parameter,\r\n        containing the most frequent full queries with that\r\n        prefix; if the number of full queries with that prefix is less than\r\n         that integer parameter, return all the full queries.\r\n    If no full queries have this prefix, return the empty list.\r\n    Notes: The maps should not be changed.\r\n           If multiple full queries occur the same number of times, prefer\r\n      the full queries that come earlier in the standard lexical ordering: e.g.,\r\n      the same order they are printed in the query map\r\n   (mine is 11 lines of well-formatted code).\r\n<p>     \r\n<li>Write a <b>main</b> function at the bottom of this file that calls these\r\n      functions to solve the problem\r\n   (mine is 25 lines of well-formatted code).\r\n</ul>\r\n<h3>Sample Interaction:</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match the form of this one (the order of values in the sets\r\n  may vary).\r\n<pre><b>\r\nEnter query file name[googleq0.txt]: \r\n\r\nPrefix map:\r\n  queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n  queue[u,l]:rear -> set[queue[u,l]:rear]\r\n  queue[u,m]:rear -> set[queue[u,m,c]:rear]\r\n  queue[u,m,c]:rear -> set[queue[u,m,c]:rear]\r\n  queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n  queue[u,w,b]:rear -> set[queue[u,w,b]:rear]\r\n  queue[u,w,s]:rear -> set[queue[u,w,s]:rear]\r\n\r\nQuery map:\r\n  queue[u,w,b]:rear -> 3\r\n  queue[u,l]:rear -> 2\r\n  queue[u,w,s]:rear -> 2\r\n  queue[u,m,c]:rear -> 1\r\n\r\nEnter a prefix (or quit): <i>u</i>\r\nEnter n (as in \"top n\" to print)[3]: <i>2</i>\r\nTop 3 (at most) full queries = priority_queue[pair[queue[u,l]:rear,2],pair[queue[u,w,b]:rear,3]]:highest\r\n\r\nEnter a full query (or quit): <i>u w s</i>\r\n\r\nPrefix map:\r\n  queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n  queue[u,l]:rear -> set[queue[u,l]:rear]\r\n  queue[u,m]:rear -> set[queue[u,m,c]:rear]\r\n  queue[u,m,c]:rear -> set[queue[u,m,c]:rear]\r\n  queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n  queue[u,w,b]:rear -> set[queue[u,w,b]:rear]\r\n  queue[u,w,s]:rear -> set[queue[u,w,s]:rear]\r\n\r\nQuery map:\r\n  queue[u,w,b]:rear -> 3\r\n  queue[u,w,s]:rear -> 3\r\n  queue[u,l]:rear -> 2\r\n  queue[u,m,c]:rear -> 1\r\n\r\nEnter a prefix (or quit): <i>u w</i>\r\nEnter n (as in \"top n\" to print)[3]: <i>2</i>\r\n  Top 2 (at most) full queries = priority_queue[pair[queue[u,w,s]:rear,3],pair[queue[u,w,b]:rear,3]]:highest\r\n\r\nEnter a full query (or quit): <i>a b c</i>\r\n\r\nPrefix map:\r\n  queue[a]:rear -> set[queue[a,b,c]:rear]\r\n  queue[a,b]:rear -> set[queue[a,b,c]:rear]\r\n  queue[a,b,c]:rear -> set[queue[a,b,c]:rear]\r\n  queue[u]:rear -> set[queue[u,m,c]:rear,queue[u,l]:rear,queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n  queue[u,l]:rear -> set[queue[u,l]:rear]\r\n  queue[u,m]:rear -> set[queue[u,m,c]:rear]\r\n  queue[u,m,c]:rear -> set[queue[u,m,c]:rear]\r\n  queue[u,w]:rear -> set[queue[u,w,s]:rear,queue[u,w,b]:rear]\r\n  queue[u,w,b]:rear -> set[queue[u,w,b]:rear]\r\n  queue[u,w,s]:rear -> set[queue[u,w,s]:rear]\r\n\r\nQuery map:\r\n  queue[u,w,b]:rear -> 3\r\n  queue[u,w,s]:rear -> 3\r\n  queue[u,l]:rear -> 2\r\n  queue[a,b,c]:rear -> 1\r\n  queue[u,m,c]:rear -> 1\r\n\r\nEnter a prefix (or quit): <i>quit</i></b></pre>\r\n<p>\r\nYou can also try processing the <b>googleq1.txt</b> and <b>googleq2.txt</b>\r\n  files\r\n</td>\r\n</tbody>\r\n</table>\r\n---->\r\n\r\n<!-- Problem #5 -->\r\n\r\n<a name=\"problem5\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>#5: Word Generator<br>(8 pts)</b></td>\r\n<td width =\"80%\">\r\n<h3>Problem Summary:</h3>\r\n<ul>\r\n<li> Write a program that prompts the user to enter the <b>order statistic</b>\r\n  (a positive number) and the name of a file of text.\r\n<li>Read the file of text, storing a special <b>corpus</b> in a <b>Map</b>.\r\n<li>Print the <b>corpus Map</b>.\r\n<li>Prompt the user to enter the order statistic number of words,\r\n      and the number of random words to generate, then print the original words\r\n      followed by the words randomly generated from the <b>corpus</b>.\r\n</ul>\r\nYour program will \"learn\" the word pattern of an author (based on some\r\n  \"order statistic\" and reading a large sample of the author's writing) and\r\n  then generate random text following the author's word patterns.\r\n<p>\r\n<h3>Input and Output</h3>\r\nAfter prompting for the order statistic, read a file of words, building a\r\n  <b>Map</b>.\r\nHere the <b>Map</b>'s keys are <b>Queue</b>s of <b>n</b> words (<b>n</b>\r\n  is the order statistic</b>) and each key's value is a <b>Set</b> of all the\r\n  words in the text that ever follow these <b>n</b> words:\r\n  e.g., if <b>n</b> were <b>2</b>, the <b>Map</b> would contain a keys that are\r\n  <b>Queue</b>s of 2 words (for every pair of words appearing next to each\r\n  other in the text) and whose values are a <b>Set</b> of all the words\r\n  following the key (no matter where the pair occurs in the text; the <b>Set</b>\r\n  stores no duplicate words).\r\n<p>\r\nThe easiest way to process the words one at a time is to use an outer loop\r\n  reading lines of text and an inner loop scanning all the words when the line\r\n  is split using a space character.\r\nTo process a new word, if the <b>Queue</b> doesn't have <b>n</b> words, just\r\n  enqueue the word; if the <b>Queue</b> has <b>n</b> words, use it as a key and\r\n  put the new word in its associated <b>Set</b>, then dequeue the first word\r\n  and enqueue the new word (so the <b>Queue</b> will still contain <b>n</b>\r\n  words).\r\n<p>\r\nFor a simple example, the file <b>wginput1.txt</b> contains the following\r\n  lines (it could have all this information on one line or more lines):\r\n<b><pre>  a b c b a d c b a d\r\n  c a a b a a d</pre></b>\r\n  \r\n<p>\r\nPrint all the associations in the <b>Map</b>, one per line in standard lexical\r\n  order.\r\n<p>\r\nAfter printing all associations, print the size of the smallest and largest\r\n  <b>Set</b> that is a value in the <b>Map</b>.\r\nEach line contains an <b>n</b> word <b>Queue</b>, followed by the <b>Set</b>\r\n   of unique words that follow them in the text.\r\nIn standard lexical order, the keys appear in order relative to the first word \r\n  in the <b>Queue</b> (alphabetically); for all first words that are the same,\r\n  they appear in order relative to the second word in the <b>Queue</b>\r\n  (alphabetically); for all first and second words that are the same, they \r\n appear in order relative to the third word in the <b>Queue</b>; etc.\r\n  (see the example below, for an order statistic of 2).\r\n<p>\r\nFor example, the file above would produce:\r\n<b><pre>  Corpus contains all the following 8 Entry pairs\r\n    queue[a,a]:rear -> set[b,d]\r\n    queue[a,b]:rear -> set[c,a]\r\n    queue[a,d]:rear -> set[c]\r\n    queue[b,a]:rear -> set[d,a]\r\n    queue[b,c]:rear -> set[b]\r\n    queue[c,a]:rear -> set[a]\r\n    queue[c,b]:rear -> set[a]\r\n    queue[d,c]:rear -> set[b,a]\r\n  Corpus contains all the previous 8 Entry pairs\r\n  min/max of corpus set lengths = 1/2</pre></b>\r\n<p>\r\nFor example, <b>queue[a,d]:end</b> appears three times in the text above, twice\r\n  followed by <b>c</b> and once followed by nothing (at the end of the file);\r\n  <b>queue[a,b]:end</b> appears twice in the file above, first followed by\r\n  <b>c</b> and second followed by <b>a</b>.\r\n<p>\r\n\r\nPrompt the user for the words to start with (there are order statistic number\r\n  of them; they must be in some <b>Queue</b> that is a key in the\r\n  <b>corpus</b>) and the number of random words after that to generate.\r\nProduce the list of all words and print it. \r\n<p>\r\nA random 10 word list, after the words <b>a</b> and <b>d</b> might\r\n  print as\r\n<pre><b>    Random text = queue[a,d,c,a,a,b,a,d,c,b,a,d]:rear</b></pre>\r\nIn the result we start with <b>a d</b> (specified by the user), we\r\n  know only <b>c</b> can come next; then using <b>d c</b> we know that\r\n  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...\r\n<p>\r\n\r\n<h3>Functions and Program</h3>\r\nWrite the following functions and <b>main</b> program.\r\nI am providing line counts not as requirements, but to indicate the lengths of\r\n  well-written C++ code.\r\n<ul>\r\n<li><b>read_corpus</b> has an order statistic parameter and open (file)\r\n     parameter; it returns the <b>Map</b> representing the corpus of\r\n     words in a file\r\n    (mine is 17 lines of well-formatted code).\r\n<p>\r\n<li><b>print_corpus</b> has a <b>Map</b> parameter (representing the corpus);\r\n     it returns nothing, but it prints the corpus in the appropriate form\r\n     followed the min and max value <b>Set</b> sizes\r\n     (mine is 13 lines of well-formatted code + the <b>queue_gt</b> function).\r\n<p>\r\n<li><b>produce_text</b> has a <b>Map</b> parameter (representing the corpus),\r\n    a <b>Queue</b> parameter (representing the starting words), and an\r\n    <b>int</b> parameter (representing the number of random words to generate);\r\n    it returns a <b>Queue</b> that contains the starting words followed by\r\n    the generated words\r\n     (mine is 15 lines of well-formatted code).\r\n\r\n    <p>\r\n    <b>Hint</b>: use two <b>Queue</b>s of words, both starting out with the\r\n       starting words.\r\n    The first will always contain the current <b>n</b> words to be used as a\r\n      key in the <b>Map</b>); the second will contain all the generated words.\r\n    Generate a random next word from the <b>Map</b> using the\r\n      <b>random_in_set</b> function that I wrote in this file; then \r\n      drop the first word from the <b>Queue</b> and add the generated word, so\r\n      it remains a <b>Queue</b> of size <b>n</b>; repeat until you have\r\n      generated the required number of words.\r\n    <p>\r\n    <b>Warning</b>: you might have to stop prematurely if you generate the last\r\n      <b>n</b> words in the text, and if these words occur nowhere else.\r\n    That is because in this case, there is no random word to generate following\r\n      them; in this case add a <b>\"None\"</b> to the end of the <b>Queue</b>\r\n      of words and immediately return that <b>Queue</b>\r\n    (mine is 14 lines of well-formatted code).\r\n<p>\r\n<li>Write a <b>main</b> function at the bottom of this file that calls these\r\n      functions to solve the problem\r\n   (mine is 21 lines of well-formatted code).\r\n</ul>\r\n<h3>Sample Interaction</h3>\r\nThe program, as specified, will have the following interaction:\r\n  user-typed information appears in <i>italics</i>.\r\nYour output should match this one.\r\n<pre><b>  Enter &gt;=1 order statistic[2]: \r\n  Enter the file name to process[wginput1.txt]: \r\n\r\n  Corpus contains all the following 8 Entry pairs\r\n    queue[a,a]:rear -> set[b,d]\r\n    queue[a,b]:rear -> set[c,a]\r\n    queue[a,d]:rear -> set[c]\r\n    queue[b,a]:rear -> set[d,a]\r\n    queue[b,c]:rear -> set[b]\r\n    queue[c,a]:rear -> set[a]\r\n    queue[c,b]:rear -> set[a]\r\n    queue[d,c]:rear -> set[b,a]\r\n  Corpus contains all the previous 8 Entry pairs\r\n  min/max of corpus set lengths = 1/2\r\n\r\n  Enter 2 words to initiate random text\r\n  Enter word 1: <i>a</i>\r\n  Enter word 2: <i>d</i>\r\n  Enter # of more words to generate: <i>10</i>\r\n  Random text = queue[a,d,c,a,a,b,a,d,c,b,a,d]:rear</b></pre>\r\n<p>\r\nThe <b>wginput2.txt</b> file cannot be used to generate a large number of\r\n  random words for the reason explained in the <b>Warning</b> above.\r\n<p>\r\nWith the appropriate modification, we can use this same program to\r\n  read/generate music or DNA sequences or any other data made of repeated\r\n  symbols.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</tbody>\r\n</table>\r\n</html>\r\n", "encoding": "ascii"}