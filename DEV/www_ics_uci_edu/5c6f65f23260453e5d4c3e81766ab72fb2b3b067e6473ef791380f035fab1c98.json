{"url": "https://www.ics.uci.edu/~eppstein/261/w09-hw5.txt", "content": "1. Suppose we wish to build a data structure that stores a set of n\nthree-dimensional points and answers queries requesting the number of\npoints within an axis-parallel box. We are considering three multilevel\ndata structures for this problem: (i) an outer data structure in the\nform of a binary search tree on the x-coordinates of all the points,\neach node of which stores an inner data structure in the form of a\nkD-tree on the y and z coordinates of its descendant points, and (ii) an\nouter data structure in the form of a kD-tree on the x and y coordinates\nof all the points, each node of which stores an inner data structure in\nthe form of a binary search tree on the z coordinates of the points\nwithin its rectangle.\n\n(a) How much space would data structure (i) use, and what is its query\ntime?\n\n(b) How much space would data structure (ii) use, and what is its query\ntime?\n\n(c) Can fractional cascading be applied to either of the two data\nstructures? If so, what is the improved query time that would be\nobtained by using it?\n\n2. Suppose we wish to store a set of two-dimensional points, and answer\nqueries requesting the number of points within a specified axis-aligned\nright triangle. Show that a kD-tree may require Omega(n) time per query\nfor this problem.\n\n3. Suppose we wish to solve the problem of, given data points in the\nplane, listing all points contained in a query triangle.  We attempt to\nsolve it with the following data structure:\n\n- We partition the points into a set of nested convex hulls:\n  H_0 is the convex hull of the input, H_1 is the hull of the points\n  other than the ones already vertices H_0, and in general\n  H_i is the hull of the points other than the ones that are already\n  vertices of some hull H_j for j<i.\n\n- We store each convex hull separately, in a data structure that allows\n  us to perform binary searches (e.g. a sorted array of its vertices).\n  We do not use fractional cascading.\n\n- To answer a query for the points in triangle T, we apply the\n  following pseudocode:\n\n  def query(T):\n      for i in range(0, number of hulls):\n          for each of the three lines L_0, L_1, L_2 on the boundary of T:\n              use binary search to find the two points where L_j crosses H_i\n\t      (or discover that it doesn't cross H_i)\n\n          split the hull H_i into paths at the (at most six) crossing points\n          found above (or a single path if there are no crossing points)\n\n          for each path into which H_i is split:\n              if the first segment of the path is contained in T:\n                  output all vertices of H_i in the path\n\n          if none of L_0, L_1, and L_2 cross H_i and\n                  no vertices of H_i were output:\n              break\n\nExplain why this pseudocode does not correctly and efficiently answer\nthe range query.\n", "encoding": "ascii"}