{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/Neighbors.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Nearest neighbor closest pair algorithm\n\n#include \"Neighbors.h\"\n#include \"Error.h\"\n\n// Subroutine to find nearest neighbor of a given point\nvoid NeighborCP::FindNeighbor(point p)\n{\n\t// if no neighbors avail, set flag for UpdatePoint to find\n\tif (npoints == 1) {\n\t\tneighbors[p] = p;\n\t\treturn;\n\t}\n\n\t// find first point unequal to p itself\n\tint first_nbr = 0;\n\tif (p == points[first_nbr]) first_nbr = 1;\n\tneighbors[p] = points[first_nbr];\n\tnbr_dist[p] = dist(p, neighbors[p]);\n\n\t// now test whether each other point is closer\n\tfor (long i = first_nbr + 1; i < npoints; i++)\n\t{\n\t\tpoint q = points[i];\n\t\tif (q != p) {\n\t\t\tdouble d = dist(p,q);\n\t\t\tif (d < nbr_dist[p]) {\n\t\t\t\tnbr_dist[p] = d;\n\t\t\t\tneighbors[p] = q;\n\t\t\t}\n\t\t}\n\t}\n}\n\nNeighborCP::NeighborCP(long np, long mp, Distance & d)\n\t: BruteForceCP(np,mp,d),\n\t  neighbors(new point[mp]), nbr_dist(new double[mp])\n{\n\tif (neighbors == 0 || nbr_dist == 0)\n\t\terror(\"NeighborCP: unable to create neighbor arrays\");\n\t\n\t// Find all neighbors. We do this ourselves rather than calling\n\t// FindNeighbor to reduce the total number of distance calculations.\n\tlong i, j;\n\tfor (i = 0; i < np; i++) {\n\t\tneighbors[i] = i;\t// flag to say no nbr yet\n\t\tnbr_dist[i] = MAX_DISTANCE;\n\t}\n\tfor (i = 1; i < np; i++)\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tdouble d = dist(i,j);\n\t\t\tif (d < nbr_dist[i]) {\n\t\t\t\tnbr_dist[i] = d;\n\t\t\t\tneighbors[i] = j;\n\t\t\t}\n\t\t\tif (d < nbr_dist[j]) {\n\t\t\t\tnbr_dist[j] = d;\n\t\t\t\tneighbors[j] = i;\n\t\t\t}\n\t\t}\n}\n\n// Add a point and check if any neighbors need to be changed\nvoid NeighborCP::operator += (point p)\n{\n\tBruteForceCP::operator+= (p);\n\tUpdatePoint(p);\n}\n\n// Remove a point and update neighbors of points for which it had been nearest\nvoid NeighborCP::operator -= (point p)\n{\n\tBruteForceCP::operator-= (p);\n\tfor (long i = 0; i < npoints; i++)\n\t\tif (neighbors[points[i]] == p)\n\t\t\tFindNeighbor(points[i]);\n}\n\n// Find closest pair by scanning list of nearest neighbors\ndouble NeighborCP::operator () (point & a, point & b)\n{\n\tif (npoints < 2) error(\"NeighborCP: not enough points to form pair\");\n\tgPairs++;\n\tdouble d = nbr_dist[points[0]];\n\ta = points[0];\n\tb = neighbors[points[0]];\n\tfor (long i = 1; i < npoints; i++) {\n\t\tif (nbr_dist[points[i]] < d) {\n\t\t\td = nbr_dist[points[i]];\n\t\t\ta = points[i];\n\t\t\tb = neighbors[points[i]];\n\t\t}\n\t}\n\treturn d;\n}\n\n// All distances to point have changed, check if our structures are ok\n// Note that although we completely recompute the neighbors of p,\n// we don't explicitly call FindNeighbor, since that would double\n// the number of distance computations made by this routine.\nvoid NeighborCP::UpdatePoint(point p)\n{\n\tneighbors[p] = p;\t// flag for not yet found any\n\tnbr_dist[p] = MAX_DISTANCE;\n\tfor (long i = 0; i < npoints; i++) {\n\t\tpoint q = points[i];\n\t\tif (q != p) {\n\t\t\tdouble d = dist(p,q);\n\t\t\tif (d < nbr_dist[p]) {\n\t\t\t\tnbr_dist[p] = d;\n\t\t\t\tneighbors[p] = q;\n\t\t\t}\n\t\t\tif (d < nbr_dist[q]) {\n\t\t\t\tnbr_dist[q] = d;\n\t\t\t\tneighbors[q] = p;\n\t\t\t} else if (neighbors[q] == p && d > nbr_dist[q]) FindNeighbor(q);\n\t\t}\n\t}\n}\n\n// Single distance has changed, check if our structures are ok\nvoid NeighborCP::UpdateDistance(point p, point q)\n{\n\tdouble d = dist(p,q);\n\n\tif (d < nbr_dist[p]) {\n\t\tnbr_dist[p] = q;\n\t\tneighbors[p] = q;\n\t} else if (neighbors[p] == q && d > nbr_dist[p]) FindNeighbor(p);\n\n\tif (d < nbr_dist[q]) {\n\t\tnbr_dist[q] = p;\n\t\tneighbors[q] = p;\n\t} else if (neighbors[q] == p && d > nbr_dist[q]) FindNeighbor(q);\n}\n", "encoding": "ascii"}