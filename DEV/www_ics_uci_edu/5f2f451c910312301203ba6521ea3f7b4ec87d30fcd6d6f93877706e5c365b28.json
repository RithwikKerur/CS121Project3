{"url": "https://www.ics.uci.edu/~peymano/papers/iwpse98/", "content": "<!-- Published by Quadralay WebWorks HTML Lite 1.5.1 -->\r\r<html>\r\r\r\r<head>\r\r<meta http-equiv=\"Content-Type\"\r\rcontent=\"text/html; charset=iso-8859-1\">\r\r<meta name=\"GENERATOR\" content=\"Microsoft FrontPage 6.0\">\r\r<title>Decentralized Software Evolution</title>\r\r</head>\r\r\r\r<body bgcolor=\"#FFFFFF\">\r\r\r\r<p align=\"left\"><a href=\"http://www.ics.uci.edu/~peymano/\">Back\r\rto Peyman Oreizy's home page</a></p>\r\r\r\r<hr>\r\r\r\r<p align=\"left\"><em>Appeared at the Proceedings of the </em><a\r\rhref=\"http://kt-www.jaist.ac.jp:8000/icse98.html\"><em>International\r\rConference on the Principles of Software Evolution (IWPSE 1)</em></a>.\r\rKyoto, Japan. April 20-21, 1998.</p>\r\r\r\r<h1 align=\"center\">Decentralized Software Evolution</h1>\r\r\r\r<p align=\"center\"><a href=\"http://www.ics.uci.edu/~peymano/\">Peyman\r\rOreizy</a><br>\r\r<a href=\"../../\">http://www.ics.uci.edu/~peymano/</a></p>\r\r<div align=\"center\"><center>\r\r\r\r<address>\r\r    Information and Computer Science<br>\r\r    University of California, Irvine<br>\r\r    Irvine, CA 92697-3425 USA<br>\r\r    +1 949 824 8438<br>\r\r    <a href=\"mailto:peymano at ics.uci.edu\">peymano at ics.uci.edu</a><br>\r\r    \r\r</address>\r\r</center></div>\r\r\r\r<h2><a name=\"1025540\">Introduction</a></h2>\r\r\r\r<p><a name=\"1025541\">Developers frequently confront a dilemma\r\rthat may be characterized by the following:</a></p>\r\r\r\r<dl>\r\r    <dd><a name=\"1029259\">``90% of the functionality requested by\r\r        our customer is available in an existing off-the-shelf\r\r        application, but the missing 10% is vital to the\r\r        customer. Unfortunately, we cannot customize or adapt the\r\r        existing application to meet our customer's needs--we\r\r        have no choice but to buid a custom solution from\r\r        scratch.''</a></dd>\r\r</dl>\r\r\r\r<p><a name=\"1029260\">As a result, a relatively small change in\r\rfunctionality necessitates a disproportionately large amount of\r\reffort, and curtails the opportunity for software reuse. This\r\rundesirable outcome may have been avoided if the off-the-shelf\r\rapplication supported decentralized software evolution, which we\r\rdefine as the ability to evolve software independent of the\r\roriginal software vendor.</a></p>\r\r\r\r<p><a name=\"1025734\">Decentralized software evolution (hereafter\r\rabbreviated DSE) provides a means for third-party software\r\rvendors to customize existing applications for particular domains\r\rand customers. This capability benefits everyone involved: the\r\roriginal application vendor sells more product since\r\rcustomization constitutes use; the third-party developer delivers\r\ra product in less time and with lower cost by reusing software\r\rinstead of starting from scratch; and the customer receives a\r\rhigher quality product in less time and with lower cost.</a></p>\r\r\r\r<p><a name=\"1025472\">Although reliable, rapid, and cost effective\r\rsoftware evolution has been a principal concern of software\r\rresearch since the 1970's, results to date do not directly\r\raddress DSE. The principles and techniques of software\r\revolution--anticipation of change, separation of concerns,\r\rmodularity, information hiding [</a><a href=\"#1023859\">13</a>],\r\robject-oriented design [<a href=\"#1023015\">2</a>], mediator-based\r\rdesign [<a href=\"#997075\">17</a>], adaptive object-oriented\r\rdesign [<a href=\"#1023016\">10</a>], design patterns [<a\r\rhref=\"#1022342\">7</a>], aspect-oriented design [<a\r\rhref=\"#1023019\">9</a>], etc.--help design evolvable software\r\rsystems. Unfortunately, the flexibility attained using these\r\rtechniques is lost when the application is compiled for use. The\r\rcompilation process solidifies the plasticity of a design, making\r\rit exceedingly difficult to accommodate a change that would\r\rotherwise be easy to make. The objective of DSE is to preserve\r\rthe design's plasticity in the deployed system, thereby enabling\r\rthird-party evolution.</p>\r\r\r\r<p><a name=\"1026808\">The rest of the paper is organized as\r\rfollows. Section 2 characterizes DSE within the broader context\r\rof software evolution. Section 3 surveys existing techniques for\r\rsupporting DSE. Section 4 presents our approach to DSE, and\r\rsection 5 summarizes our experience in applying our approach to\r\rseveral example applications. Section 6 discusses some open\r\rissues.</a></p>\r\r\r\r<h2><a name=\"1024004\">Software Evolution</a></h2>\r\r\r\r<p>Table 1 categorizes common software evolution technologies\r\rbased on when they can be applied and by whom. Software can\r\reither be evolved by a centralized authority, such as the\r\rsoftware vendor (top row), or by a decentralized group, such as\r\rmultiple independent software vendors (bottom row). Software can\r\ralso be evolved during the design phase (left column), or after\r\rit has been deployed to customers (right column).</p>\r\r<div align=\"center\"><center>\r\r\r\r<table border=\"1\" cellpadding=\"6\" cellspacing=\"0\" width=\"75%\"\r\rbordercolor=\"#FFFFFF\">\r\r    <tr>\r\r        <td bordercolor=\"#FFFFFF\">&nbsp;</td>\r\r        <td width=\"15%\" bordercolor=\"#FFFFFF\">&nbsp;</td>\r\r        <td align=\"center\" colspan=\"2\" width=\"50%\"><strong>When</strong></td>\r\r    </tr>\r\r    <tr>\r\r        <td align=\"center\" bordercolor=\"#FFFFFF\">&nbsp;</td>\r\r        <td align=\"center\" width=\"15%\" bordercolor=\"#FFFFFF\">&nbsp;</td>\r\r        <td align=\"center\"><strong>Design-time evolution</strong></td>\r\r        <td align=\"center\"><strong>Post-deployment evolution</strong></td>\r\r    </tr>\r\r    <tr>\r\r        <td rowspan=\"2\" width=\"10%\"><strong>Who</strong></td>\r\r        <td width=\"15%\"><p align=\"center\"><strong>Centralized\r\r        authority</strong></p>\r\r        </td>\r\r        <td width=\"25%\" bordercolor=\"#000000\"><p align=\"center\">Design\r\r        notations, methods, and tools; process systems; group\r\r        communication and collaboration tools; configuration\r\r        management tools</p>\r\r        </td>\r\r        <td width=\"25%\" bordercolor=\"#000000\"><p align=\"center\">Release\r\r        management systems; software patch files</p>\r\r        </td>\r\r    </tr>\r\r    <tr>\r\r        <td width=\"15%\"><p align=\"center\"><strong>Decentralized\r\r        group</strong></p>\r\r        </td>\r\r        <td width=\"25%\" bordercolor=\"#000000\"><p align=\"center\">Same\r\r        as above with an emphasis on distributed development</p>\r\r        </td>\r\r        <td width=\"25%\" bordercolor=\"#000000\"><p align=\"center\">Software\r\r        plug-ins, scripting languages, developer APIs</p>\r\r        </td>\r\r    </tr>\r\r</table>\r\r</center></div>\r\r\r\r<p align=\"center\"><strong>Table 1</strong>: This 2x2 matrix\r\rcategorizes different techniques used to support software\r\revolution<br>\r\rbased on who can evolve the system and when evolution can take\r\rplace.</p>\r\r\r\r<p><a name=\"1024222\">Centralized, design-time evolution:</a></p>\r\r\r\r<dl>\r\r    <dd><a name=\"1024319\">A large majority of the available\r\r        techniques and tools support this category of software\r\r        evolution. For example, design notations and methods,\r\r        such as the Booch and Rumbaugh object-oriented\r\r        methodologies, provide guidelines for system design and\r\r        diagrammatic notations for design capture. Design tools,\r\r        such as Rational Rose, automate the diagramming process\r\r        and provide analysis support. Group communication and\r\r        collaboration tools, such as e-mail, revision control\r\r        tools, and configuration management systems, help teams\r\r        members coordinate and manage software changes.</a></dd>\r\r    <dt>&nbsp;</dt>\r\r    <dt><a name=\"1026054\">Decentralized, design-time evolution</a></dt>\r\r    <dd><a name=\"1026246\">Larger teams and geographic\r\r        distribution differentiate decentralized design-time\r\r        evolution from its centralized counterpart. The impact of\r\r        large teams on software engineering environments has been\r\r        discussed by Perry and Kaiser [</a><a href=\"#1023864\">14</a>].\r\r        They argue that as a project grows above approximately 20\r\r        people, the number and complexity of interactions\r\r        increases. As a consequence, additional rules and\r\r        mechanisms that enforce cooperation among personnel are\r\r        needed. Less well understood is the impact of geographic\r\r        distribution on software development. Fielding and Kaiser\r\r        [<a href=\"#1027767\">5</a>] describe the processes and\r\r        tools adopted by one particular globally distributed team\r\r        that develops the Apache Web server. They identify the\r\r        importance of e-mail communication, archival of e-mail\r\r        communication (as a means to support group memory), a\r\r        shared information space accessible by project members,\r\r        and coordination tools. Cutkosky et. al. [<a\r\r        href=\"#1026155\">4</a>] report similar experiences using\r\r        the Internet in the manufacturing domain.</dd>\r\r</dl>\r\r\r\r<dl>\r\r    <dt><a name=\"1026185\">Centralized, post-deployment evolution</a></dt>\r\r    <dd><a name=\"1024232\">Software vendors evolving (i.e.,\r\r        upgrading) their deployed applications is represented by\r\r        this category. Since evolution is done by a single\r\r        authority, change conflicts do not arise. As a result,\r\r        most technologies are concerned with the efficient\r\r        distribution of upgrades. The most common technology in\r\r        use today is the binary patch file, which encodes the\r\r        byte-level changes necessary to upgrade an application to\r\r        a subsequent release. More sophisticated tools, such as\r\r        Tivoli's TME/10 [</a><a href=\"#1026279\">20</a>] and\r\r        SoftwareDock [<a href=\"#1007962\">8</a>], use software\r\r        dependency information to guide software upgrades.</dd>\r\r</dl>\r\r\r\r<dl>\r\r    <dt><a name=\"1024239\">Decentralized, post-deployment\r\r        evolution</a></dt>\r\r    <dd><a name=\"1026333\">Multiple software vendors independently\r\r        evolving a deployed application is represented by this\r\r        category. The most popular techniques include software\r\r        plug-ins, which are used by Netscape's Communicator to\r\r        support new content types, and scripting languages. There\r\r        are a host of issues and consequences inherent in\r\r        supporting this type of evolution. For example,\r\r        configuration management becomes necessary if conflicts\r\r        between independently developed software add-ons can\r\r        occur. Since applications are evolved in-the-field,\r\r        anomalies may arise from unforeseen interactions between\r\r        independently developed add-ons. Consequentially,\r\r        application consistency must be verified whenever the\r\r        application is modified (i.e., when add-ons are installed\r\r        or removed). Software add-on vendors must also use\r\r        standard formats for packaging and distributing add-ons.\r\r        Furthermore, decentralized control over software\r\r        evolution complicates product support and documentation\r\r        since no single authority represents an application that\r\r        has been evolved by multiple vendors. End-user\r\r        installation of software add-ons necessitates that\r\r        configuration management and analysis be robust and\r\r        accessible to non-technical users. We focus on this class\r\r        of evolution in the remainder of the paper.</a></dd>\r\r</dl>\r\r\r\r<h2><a name=\"1026831\">Existing Techniques for Supporting\r\rDecentralized Software E</a>volution</h2>\r\r\r\r<p><a name=\"1026782\">The degree of flexibility afforded by\r\rdifferent approaches to DSE is depicted in </a>Figure 1.</p>\r\r<div align=\"center\"><center>\r\r\r\r<table border=\"0\" cellspacing=\"1\" width=\"100%\">\r\r    <tr>\r\r        <td width=\"100%\"><p align=\"center\"><img\r\r        src=\"evolvability.gif\" width=\"500\" height=\"260\"></p>\r\r        </td>\r\r    </tr>\r\r    <tr>\r\r        <td width=\"100%\"><p align=\"center\"><strong>Figure 1</strong>:\r\r        The trade-off between flexibility (on the left) and\r\r        application consistency (on the right) made by different\r\r        decentralized software evolution mechanisms.</p>\r\r        </td>\r\r    </tr>\r\r</table>\r\r</center></div>\r\r\r\r<p>At the extreme left of the spectrum, the software vendor\r\rdeploys the application's source code, enabling anyone with\r\rsufficient expertise to modify any aspect of the application's\r\rfunctionality. Although this is rare in the commercial software\r\rmarket, numerous free-ware applications adopt this approach,\r\rincluding the Linux OS, the Apache Web server, and the GNU tools\r\r(e.g., gcc, emacs). Netscape's Communicator is among the first\r\rcommercial products to distribute source code for independent\r\rextension. Although the types of changes that can be made are\r\runrestricted, it is extremely difficult to combine independently\r\rdeveloped add-ons. This is because determining whether or not two\r\rchanges conflict requires careful analysis of the source code and\r\rcannot be automated. The problem is analogous to merging several\r\rbranches of a software revision tree in a software configuration\r\rmanagement system.</p>\r\r\r\r<p><a name=\"1022708\">At the extreme right of the spectrum, the\r\rsoftware vendor deploys the application as a monolithic entity,\r\rwith a fixed set of user-selection options. A large majority of\r\rcommercial software applications adopt this approach because (1)\r\rapplication consistency may be assured since a single software\r\rvendor has exclusive control over its evolution, and (2) a\r\rsoftware vendor can protect their intellectual property rights by\r\rmaking it extraordinarily difficult for others to reverse\r\rengineer the application. </a></p>\r\r\r\r<p><a name=\"1022709\">Applications in between these two extremes\r\rsupport some form of software evolution by trading-off assured\r\rconsistency (right-end) for flexibility (left-end). These systems\r\renable end-users or third-party software vendors to customize or\r\rextend the application's functionality independent of the\r\roriginal application vendor. A relatively small but growing\r\rnumber of software applications lay between these two extremes.\r\rSome examples include Microsoft's Office Suite, Adobe Photoshop,\r\rand Qualcomm's Eudora. The most common techniques for supporting\r\rDSE are briefly described below.</a></p>\r\r\r\r<dl>\r\r    <dt><a name=\"1022844\">Application Programming Interfaces\r\r        (APIs)</a></dt>\r\r    <dd><a name=\"1022845\">An API is a set of functions that an\r\r        application provides for other applications. APIs are\r\r        commonly used as tool integration mechanisms since they\r\r        enable other applications to invoke the services of the\r\r        host application without user involvement. APIs provide a\r\r        limited subset of the operations necessary to support\r\r        evolution. For example, API-based software add-ons cannot\r\r        replace or remove existing functionality, or interpose\r\r        new functionality between existing parts. As a\r\r        consequence, the host application's predetermined API\r\r        circumscribes the class of possible changes.</a></dd>\r\r    <dt>&nbsp;</dt>\r\r    <dt><a name=\"1022716\">Software plug-ins</a></dt>\r\r    <dd><a name=\"1022717\">The plug-in mechanism provides a place\r\r        holder for third-party components. The host application\r\r        specifies the requirements and functional interface that\r\r        all plug-ins must adhere to, and provides a mechanism by\r\r        which new plug-ins register themselves with the host.\r\r        Netscape's Communicator, for example, registers plug-ins\r\r        by placing them in a special file system directory\r\r        queried on startup. The host application selects among\r\r        the plug-ins and invokes them as necessary. Plug-in based\r\r        software add-ons can only provide alternative\r\r        implementations for behaviors anticipated by the original\r\r        developers. The interposition and removal of\r\r        functionality is not supported since dependency\r\r        information between plug-ins cannot be determined.</a></dd>\r\r    <dt>&nbsp;</dt>\r\r    <dt><a name=\"1021986\">Scripting languages &amp; macros</a></dt>\r\r    <dd><a name=\"1022718\">A scripting language provides a\r\r        domain-specific language for specifying behavior using\r\r        language primitives and library functions. Scripting\r\r        language-based mechanisms provide essentially the same\r\r        flexibility as the API mechanism, except that the\r\r        scripting language provides domain-specific language\r\r        constructs that can facilitate the implementation of\r\r        add-ons, and a built-in compiler and interpreter that\r\r        lower the entry barrier for developing add-ons.</a></dd>\r\r    <dt>&nbsp;</dt>\r\r    <dt><a name=\"1024812\">Dynamic link libraries (DLLs)</a></dt>\r\r    <dd><a name=\"1025037\">Dynamic link libraries provide a\r\r        late-binding mechanism whereby an application can load\r\r        and link to an external software module during runtime.\r\r        Applications employ DLLs to reduce runtime memory use and\r\r        to share common functionality. A software add-on can\r\r        augment, replace, or remove functionality by masquerading\r\r        as an application DLL (e.g., by replacing the file\r\r        representing the DLL in the file system). Balzer's\r\r        instrumented connector technology [</a><a href=\"#1024998\">1</a>]\r\r        use this technique to alter Netscape's Communicator\r\r        browser to support browsing of virtual, encrypted file\r\r        systems. Although DLL-based software add-ons are unique\r\r        in that they can be used to evolve an application in a\r\r        manner unanticipated by its developers, they have two\r\r        limitations. One, DLL add-ons can only be use in place of\r\r        existing DLLs, which circumscribes the class of changes.\r\r        Two, unexpected side-effects may result if the add-on DLL\r\r        violates an unstated assumption between the application\r\r        and the DLL. </dd>\r\r</dl>\r\r\r\r<dl>\r\r    <dt><a name=\"1024822\">Component-based applications</a></dt>\r\r    <dd><a name=\"1024825\">Component-based applications built\r\r        using a component-object model, such as COM [</a><a\r\r        href=\"#1000156\">3</a>] or CORBA [<a href=\"#1000034\">11</a>],\r\r        are applications composed of separately compiled modules,\r\r        called components, that are linked to one another during\r\r        runtime. Since each application component exposes its\r\r        interface, component-based applications expose a richer,\r\r        more structured API, increasing the potential of\r\r        supporting unanticipated changes. But since existing\r\r        technologies do not try to separation application\r\r        functionality from component communication, components\r\r        tend to be riddled with hard-coded references to other\r\r        components. This makes component replacement, removal,\r\r        and interposition of behavior difficult.</dd>\r\r</dl>\r\r\r\r<p><a name=\"1027013\">All of the these techniques, except for\r\rsource code, generally preserve only a small portion of the\r\rdesign's flexibility in the deployed system. Not only does this\r\rrestrict the set of potential changes, but it precludes changes\r\runanticipated by the original developers. Composition of software\r\radd-ons is also poorly supported by existing techniques. Most\r\rexisting techniques circumvent the composition problem by\r\rpreventing interaction between add-ons. This is indeed the\r\rapproach advocated by Szyperski [</a><a href=\"#1022830\">18</a>].</p>\r\r\r\r<h2><a name=\"1027014\">Our Approach</a></h2>\r\r\r\r<p><a name=\"1028617\">Our approach to decentralized,\r\rpost-deployment software evolution overcomes many of the\r\rlimitations exhibited by previous approaches. Our approach is\r\rbased on evolving applications at the software\r\rarchitectural-level [</a><a href=\"#1023862\">15</a>,<a\r\rhref=\"#1008089\">16</a>]. Our approach to DSE is unique in\r\rfollowing ways:</p>\r\r\r\r<p><a name=\"1028789\">We augment the abstractions provided at the\r\rarchitectural level with stylist rules that further facilitate\r\rDSE. We require all components to communicate through connectors,\r\rwhich are preserved as explicit entities in the implementation\r\rand act as communication routers. Furthermore, connectors\r\rencapsulate and localize the binding decisions between\r\rcomponents, which makes it possible to change binding decisions\r\rwithout altering the components. </a></p>\r\r\r\r<p><a name=\"1029165\">We include the application's architectural\r\rmodel and a mechanism to maintain the consistency between this\r\rmodel and the implementation with the deployed system. The\r\rdeployed architectural model describes the interconnections\r\rbetween components and connectors, and their mappings to\r\rimplementation modules. The mapping enables changes specified in\r\rterms of the architectural model to effect corresponding changes\r\rin the implementation. </a></p>\r\r\r\r<p><a name=\"1029166\">We deploy an architecture evolution manager\r\r(AEM) with the application. The AEM maintains the correspondence\r\rbetween the architectural model and the implementation as changes\r\rare made. If a change violates application consistency, the AEM\r\rcan reject the change.</a></p>\r\r\r\r<p><a name=\"1028861\">Our approach enables software add-ons to\r\rleverage the architectural model's rich semantics to guide\r\rchanges. This avoids many of the accidental difficulties incurred\r\rby existing approaches. Since the application's entire\r\rarchitecture is exposed and remains malleable in the deployed\r\rsystem, the design's plasticity is preserved and made accessibly\r\rto third-party add-on vendors. This overcomes the limited scope\r\rof change exhibited by existing approaches. Software add-ons can\r\rinspect and modify the system's architectural model in order to\r\rachieve the necessary semantics. This, for example, greatly\r\rsimplifies the problem of interposing a new component between two\r\rexisting components since the architectural model can be queried\r\rto locate the affected components and connectors. As\r\rindependently developed software add-ons are installed and\r\rremoved, the architectural model can be analyzed to detect\r\rinconsistencies. The availability of the architectural model can\r\ralso be used to detect conflicts between independently developed\r\radd-ons. </a></p>\r\r\r\r<h2><a name=\"1022093\">Results to Date</a></h2>\r\r\r\r<p><a name=\"1029437\">We have implemented a prototype tool suite,\r\rcalled ArchStudio, that implements our approach for applications\r\rimplemented in the C2 architectural style [</a><a href=\"#1029595\">19</a>].\r\rArchStudio's conceptual architecture is depicted and briefly\r\rdescribed in Figure 2.</p>\r\r<div align=\"center\"><center>\r\r\r\r<table border=\"0\" cellspacing=\"1\" width=\"100%\">\r\r    <tr>\r\r        <td width=\"50%\"><p align=\"center\"><img\r\r        src=\"ArchStudio.gif\" width=\"500\" height=\"418\"></p>\r\r        </td>\r\r        <td width=\"50%\"><strong>Figure 2</strong>: A conceptual\r\r        architecture of the ArchStudio tool suite. Software\r\r        add-ons evolve an application by inspecting and changing\r\r        its architectural model. Changes may include the\r\r        addition, removal, or replacement of components and\r\r        connectors, or changes to the configuration of those\r\r        components and connectors. The Architecture Evolution\r\r        Manager is notified of changes and has the opportunity to\r\r        revoke changes that violate system integrity. The\r\r        Architecture Evolution Manager may utilize external\r\r        analysis tools to determine if changes are acceptable.\r\r        The lower portion of ArchStudio is deployed with each\r\r        application. When a user downloads a new software add-on\r\r        using their Web browser, the add-on&#146;s installation\r\r        script is located and executed.</td>\r\r    </tr>\r\r</table>\r\r</center></div>\r\r\r\r<p>We have used ArchStudio to implement two applications with\r\rseveral add-ons each. More details regarding ArchStudio and a\r\rsample application implemented using it are described in [<a\r\rhref=\"#1012327\">12</a>].</p>\r\r\r\r<p><a name=\"1029454\">We have implemented a simple end-user tool\r\rfor installing and removing software add-ons, called the\r\rExtension Wizard, that is also deployed with the application.\r\rEnd-users use a Web browser to display a list of downloadable\r\rsoftware add-ons, e.g., provided by the software vendor on their\r\rWeb site. When the user selects the file representing the add-on,\r\rthe Web browser downloads the file and invokes the Extension\r\rWizard. The software add-on file is a compressed archive\r\rcontaining new implementation modules and an installation script.\r\rThe Extension Wizard uncompresses the file, locates the\r\rinstallation script it contains, and executes it. The software\r\radd-on's installation script may query and modify the\r\rarchitectural model as necessary. The installation script an\r\rexception if the AEM detects a violation of application\r\rinvariants. If the installation succeeds, the Extension Wizard\r\rnotifies the end-user and provides an option to un-install the\r\radd-on.</a></p>\r\r\r\r<h2><a name=\"1021446\">C</a>onclusions</h2>\r\r\r\r<p><a name=\"1029579\">Our results to date are encouraging, but\r\rseveral difficult issues remain. A general framework for ensuring\r\rapplication consistency is needed. Our current architecture\r\revolution manager only enforces C2-style rules, which do not, by\r\rthemselves, guarantee that changes will leave the application in\r\ra consistent state. Some aspects of the style do facilitate this\r\rtype of in-the-field analysis. We are currently investigating the\r\rsuitability of graph grammars, architectural constraints, and\r\revent-based resource models for representing application\r\rinvariants. While these techniques hope to address software\r\rcompositionality, new techniques are needed to address the\r\rproblems of ``composing'' documentation and product support in a\r\rdecentralized environment.</a></p>\r\r\r\r<h2><a name=\"1025419\">R</a>eferences</h2>\r\r\r\r<ol>\r\r    <li><a name=\"1024998\">R. Balzer. Instrumenting, monitoring,\r\r        &amp; debugging software architectures.</a> <a\r\r        name=\"1024998\">http://www.isi.edu/software-sciences/papers/instrumenting-software-architectures.doc,\r\r        January 28, 1998</a>.</li>\r\r    <li><a name=\"1023015\">G. Booch. Object-oriented analysis and\r\r        design. Second edition. Benjamin/Cummings Publishing\r\r        Company, Inc. 1994.</a></li>\r\r    <li><a name=\"1000156\">K. Brockschmidt. Inside OLE 2.\r\r        Microsoft Press, 1994.</a></li>\r\r    <li><a name=\"1026155\">M. R. Cutkosky, J. M. Tenenbaum, J.\r\r        Glicksman. Madefast: Collaborative engineering over the\r\r        Internet. Communications of the ACM, vol. 39, no. 9,\r\r        September 1996.</a></li>\r\r    <li><a name=\"1027767\">R. Fielding, G. Kaiser. The Apache HTTP\r\r        server project. IEEE Internet Computing, July-August\r\r        1997.</a></li>\r\r    <li><a name=\"1022344\">Free Software Foundation. Categories of\r\r        free and non-free software.\r\r        http://www.gnu.org/philosophy/categories.html, January\r\r        28, 1998.</a></li>\r\r    <li><a name=\"1022342\">E. Gamma, R. Helm, R. Johnson, J.\r\r        Vlissides. Design Patterns. Addison-Wesley, 1995.</a></li>\r\r    <li><a name=\"1007962\">R. S. Hall, D. Heimbigner, A. van der\r\r        Hoek, A. L. Wolf. An architecture for post-development\r\r        configuration management in a wide-area network. 17th\r\r        International Conference on Distributed Computing\r\r        Systems, Baltimore, Maryland, May 1997. </a></li>\r\r    <li><a name=\"1023019\">G. Kiczales, J. Lamping, A. Mendhekar,\r\r        C. Maeda, C. Lopes, J. Loingtier, J. Irwin.\r\r        Aspect-oriented programming. PARC Technical Report,\r\r        SPL97-008 P9710042. February 1997. </a></li>\r\r    <li><a name=\"1023016\">K. J. Lieberherr. Adaptive\r\r        object-oriented software-the Demeter method. PWS\r\r        Publishing Company. 1996.</a></li>\r\r    <li><a name=\"1000034\">Object Management Group. The Common\r\r        Object Request Broker: Architecture and Specification,\r\r        Revision 2.0, July 1996.\r\r        http://www.omg.org/corba/corbiiop.htm</a></li>\r\r    <li><a name=\"1012327\">P. Oreizy, N. Medvidovic, R. N. Taylor.\r\r        Architecture-based runtime software evolution. To appear\r\r        International Conference on Software Engineering 1998,\r\r        Kyoto, Japan. April 1998.</a></li>\r\r    <li><a name=\"1023859\">D. L. Parnas. On the criteria to be\r\r        used in decomposing systems into modules. Communications\r\r        of ACM. vol. 15, no. 12, December 1972.</a></li>\r\r    <li><a name=\"1023864\">D. E. Perry, G. E. Kaiser. Models of\r\r        software development environments. IEEE Transactions on\r\r        Software Engineering, vol 17, no. 3. pp 283-295, March\r\r        1991.</a></li>\r\r    <li><a name=\"1023862\">D. E. Perry, A. L. Wolf, Foundations\r\r        for the study of software architecture. Software\r\r        Engineering Notes, vol 17, no 4, October 1992.</a></li>\r\r    <li><a name=\"1008089\">M. Shaw, D. Garlan. Software\r\r        Architecture: Perspectives on an Emerging Discipline,\r\r        Prentice-Hall, 1996.</a></li>\r\r    <li><a name=\"997075\">K. Sullivan, D. Notkin. Reconciling\r\r        environment integration and software evolution. ACM\r\r        Transactions on Software Engineering and Methodology. vol\r\r        1, no 3, July 1992.</a></li>\r\r    <li><a name=\"1022830\">C. Szyperski. Independently extensible\r\r        systems-software engineering potential and challenges.\r\r        Proceedings of the 19th Australasian Computer Science\r\r        Conference, Melbourne, Australia, January 31- February 2,\r\r        1996.</a></li>\r\r    <li><a name=\"1029595\">R. N. Taylor, N. Medvidovic, K. M.\r\r        Anderson, E. J. Whitehead, J. E. Robbins, K. A. Nies, P.\r\r        Oreizy, D. L. Dubrow. A Component- and message-based\r\r        architectural style for GUI software. IEEE Transactions\r\r        on Software Engineering, June 1996.</a></li>\r\r    <li><a name=\"1026279\">Tivoli Systems Inc. Applications\r\r        Management Specification. http://www.tivoli.com/</a></li>\r\r    <li><a name=\"1026281\">N. Wirth. Program development by\r\r        stepwise refinement. Communications of the ACM. vol. 14,\r\r        no. 4, April 1971.</a></li>\r\r</ol>\r\r\r\r<hr>\r\r</body>\r\r</html>\r\r\u00ff", "encoding": "ISO-8859-1"}