{"url": "https://www.ics.uci.edu/~ejw/authoring/dav_spec.txt", "content": "WEBDAV Working Group                               Y. Goland, Microsoft\nINTERNET-DRAFT                                     E. J. Whitehead, Jr.\n                                                            U.C. Irvine\n\n<draft-ietf-webdav-v1-spec-00>                         October 25, 1996\n\nExpires April, 1997\n\nAuthor's draft: v0.1\n\n  Extensions for Distributed Authoring and Versioning on the World Wide Web\n\nStatus of this Memo\n\nThis document is an Internet-Draft. Internet-Drafts are working documents of\nthe Internet Engineering Task Force (IETF), its areas, and its working\ngroups. Note that other groups may also distribute working documents as\nInternet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months and\nmay be updated, replaced, or made obsolete by other documents at any time.\nIt is inappropriate to use Internet-Drafts as reference material or to cite\nthem other than as \"work in progress\".\n\nTo learn the current status of any Internet-Draft, please check the\n\"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow\nDirectories on ftp.is.co.za (Africa), nic.nordu.net (Europe), munnari.oz.au\n(Pacific Rim), ds.internic.net (US East Coast), or ftp.isi.edu (US West\nCoast).\n\nDistribution of this document is unlimited. Please send comments to the WWW\nDistributed Authoring and Versioning (WEBDAV) working group at\n<w3c-dist-auth@w3.org>, which may be joined by sending a message with\nsubject \"subscribe\" to <w3c-dist-auth-request@w3.org>. Discussions of the\nWEBDAV working group are archived at\n<URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>. The HTTP\nworking group at <http-wg@cuckoo.hpl.hp.com> also discusses the HTTP\nprotocol. Discussions of the HTTP working group are archived at\n<URL:http://www.ics.uci.edu/pub/ietf/http/>. General discussions about HTTP\nand the applications which use HTTP should take place on the\n<www-talk@w3.org> mailing list.\n\nAbstract\n\nTBD\n\n1. Introduction\n\n1.1 Purpose\n\nThis specification defines extensions to the HTTP/1.1 [HTTP11] protocol, the\nURL [URL] specification, and defines subtypes of the Application content\ntype [RFC1521]. Together, these provide a means for augmenting existing\nfacilities for remote authoring with abilities for locking, versioning,\nrelationships, attributes, and listing and maniupulation of the URL name\nspace. Capbilities detailed in this specification meet the requirements for\nDistributed Authoring and Versioning, stated in [ref DA Reqt's][ref Vers.\nReqt's].\n\n1.2 Terminology\n\nUnless otherwise noted below, the use of terminology in this document is\nconsistent with the definitions of terms given in [HTTP11].\n\ncheck in\n     A Check In is a declaration that the client no longer intends to edit a\n     representation(s).\ncheck out\n     A Check Out is a declaration by a client that they intend to edit a\n     representation(s).\ncommand comments\n     Command Comments associate either a string or a URI with an HTTP\n     message.\ndestroy\n     To destroy a URI is to request that the URI and the associated resource\n     be permanently removed from storage. This differs from delete in that\n     some versioning systems handle delete as a request to no longer make\n     the specified URI updateable.\nhistory\n     The history of a URI is a list of all the versions of the URI along\n     with related information.\nmerge\n     A merge is the process whereby a resource represented by one URI is\n     combined with a resource represented by a second URI. Merges can occur\n     at the client or the server.\nno-modify lock\n     A no-modify lock prevents a locked resource from being altered until\n     all no-modify locks are released.\nnotify request\n     A notify request instructs the recipient to send update information\n     regarding the progress of a request.\nread lock\n     A read lock prevents anyone who does not posses a read lock on a\n     resource from reading that resource.\nserver diff\n     A server diff is a mechanism whereby the server compares two or more\n     representations, and sends the client a message containing a summary of\n     the differences between the entities.\nwrite lock\n     A write lock prevents anyone who does not possess a write lock on a\n     resource from altering that resource.\n\n1.3 Notational Conventions and Generic Grammar\n\nThis specification uses the Augmented BNF and Basic Rules as defined in\nSection 2 of [HTTP11].\n\n2. Attributes\n\nIt is often necessary to record meta data about a resource. The natural\nplace to store such meta data is in HTTP headers however this presents a\nproblem. HTTP headers, as defined in [HTTP11], are used either for content\ndescription or communication. While communication headers can be retrieved\nwith the Option method, content description headers can not. In addition\nneither of these headers were designed for remote setting and on-demand\nretrieval.\n\nWhat is needed is a third type of header, a header which provides\ninformation about the resource's nature, not its content or transmission\nstate. This type of header will be referred to as an attribute header.\n\nOne could add attribute headers to an HTTP message and declare that they\nmust be recorded and provided when a GET is executed, but it is expected\nthat resources will find themselves with a large number of attributes, each\nof which may consist of a large amount of data.\n\nUnderstanding that the headers can not be sent with every message it becomes\nnecessary to provide a means to discover what headers a resource has, to add\nnew headers, delete current headers, find out the value of a header, and so\non. In short, headers require the same maintenance as a resource.\n\nRather then inventing a raft of new methods, the current methods will be\nbent to our purposes. A specification is provided below for describing a\nheader in the context of the URI of the header\u00eds associated resource. So,\nwere a header named \"FileName\" to exist and be associated with the resource\nhttp://foo/bar, it would be uniquely referred to as\nhttp://foo/bar<FileName>. Headers may also have a hierarchy so the URI\nhttp://foo/bar<Author_FirstAuthor> would refer to the header \"FirstAuthor\"\nwhich is a child of the header \"Author.\" The \"_\" is used to denote hierarchy\nbecause it is legal to use within a token. Note that the name space for\nheaders is actually flat and the use of \"_\" to denote hierarchy is optional.\nIt is only meant to make it easier to group headers. The \"<...>\" enclosure\nwas chosen because it will not cause a conflict with any currently existing\nURIs.\n\n2.1 Attribute Syntax\n\nTo support requests for attributes the definition of a URI must be altered\nas follows:\n\nURI = ( absoluteURI | relativeURI ) [\"<\" Attribute \">\"] [\"#\" fragment]\nAttribute = field-name ; See section 4.2 of [HTTP11]\n\nValues for attribute headers are specified as the entity-body of a request.\nThis allows for content negotiation for attribute headers.\n\nThus attributes can now be used in any context where a normal URI would be\nused.\n\nWhen a resource is copied, moved, or otherwise manipulated, its attributes\nare equally effected. However servers make the final determination regarding\nthe state of any attribute header and may choose to not copy, move, etc. any\nsubset of headers when it performs the requested action on a resource.\n\nIn order to prevent name space collisions both headers and header prefixes\nshould be registered with a central authority. A header prefix is any legal\ntoken that may only be used when it is prefixed to another token. Thus\nNetscape could register the prefix NS and thus be the only organization\nallowed to create headers which begin with NS.\n\n2.2 Standard Attributes\n\nThe following attributes have their name and semantics defined by this\nspecification.\n\nAttributeDirectory\n     The attribute \"AttributeDirectory\" returns a list of all attribute\n     headers on a resource. To retrieve a list of attribute headers\n     associated with the URL http:\\\\foo\\bar one would send a GET request\n     with a request-URI of \\bar<AttributeDirectory>, where Host would equal\n     foo. The same logic applies to PUT, which would be used to set an\n     attribute's value.\nLink\n     This attribute header contains information about resources that are\n     associated with this resource. A SiteMap representation SHOULD be\n     available.\n     [TBD: Review the SiteMap format and figure out tag formats to define\n     source links.]\nLockInformation\n     See Lock Discovery, Section 3.2.\nNotifyRequest\n     See Notify Request, Section 6.\nSource\n     The exact contents of the resource as stored, without any processing by\n     the server (e.g. without processing of server-side includes).\n\n3. Lock/Unlock\n\nLocks come in three types, write, read, and no-modify. Logically a write\nlock and a read lock can co-exist on a single resource. This means that one\nset of clients can alter the resource and another set are the only ones\nallowed to read it. This may seem silly but is actually used in Orange book\ncompliant environments. A write lock and a no-modify lock can not be used\ntogether for obvious reasons. A read lock and a no-modify lock can be used\ntogether.\n\nLocks are assigned to a subset of the representations available for a\nresource. If the lock only applies to a single representation then the lock\nmay be further restricted to only a particular range of the representation.\nA content-range header is used for this purpose. The range may go off the\n\"end\" of the representation. Locks that exceed the end of a representation\ncontrol the ability to append to the representation.\n\nLocks may be taken out either in exclusive or shared mode. In shared mode\nanyone with proper access may take out a lock. In exclusive mode only the\nuser(s) who originally took out the lock may alter the lock. However a new\nuser can be added to an exclusive lock if the addition is performed by one\nof the lock\u00eds current owners.\n\nIf an entire resource is write locked and a lock owner deletes the resource\nthen the write lock remains. So long as the write lock remains the URI can\nnot be reused.\n\nIn order to provide for maximum flexibility and ease of administration, lock\ntokens will be used to track locks. When a lock is taken out a lock token\nwill be returned. A single lock token can represent any number of locks. In\nfuture lock requests the same token may have new locks added or old locks\nremoved from it. Lock tokens are not required to transferable between lock\nadministration resources.\n\nLocks also have time outs associated with them. If no time out value is\nassociated with a lock then the lock will never time out. Otherwise the lock\nwill expire if a number of seconds equal to the time out value passes\nwithout the resource being accessed by a lock owner. The time out value may\nbe altered, without effecting the rest of the lock, by submitting a lock\nrequest with no Lock Entries.\n\nFinally, locks may be taken out for multiple clients in a single request.\nThe Lock_Owners field allows for tokens to be used to identify multiple\nclients who are considered owners of the lock. A server SHOULD only allow a\nlock token to be used in a request if the requestor is an owner of that lock\ntoken.\n\n[TBD - We need an error message indicating that the server will not accept\ncertain lock combinations or accept overlapping locks. We also need an error\nstating that an unlock couldn't be executed because it did not exactly match\nwith a lock.]\n\nLocks will be implemented using POST. The request-URI will be the lock\nadministration resource. The entity-body will be of type application/lock.\n\n3.1 Definition of Content Type application/lock\n\nLOCK_BODY = Token_Status Time_Out Lock_Owners Lock_Request\nToken_Status = (Token_Field | \"No Token\")\nToken_Field = \"Lock Token\" \":\" LockToken\nTime_Out = \"Time Out\" \":\" (*DIGIT | \"Never\")\nLock_Request = (\"Unlock\" | Lock_Entries)\nLock_Entries = \"Lock Entries\" \":\" #(Lock_URI LockType ((\"Exclusive\" |\n\"Shared\") | \"Unlock\") Headers)\nLock_Owners = \"[\" *Lock_Owner \"]\"\nLock_Owner = token; This is some identifier used to list who owns the lock.\nLock_URI = \"URI\" URI\nLockToken = Any OCTET but LWS\nLockType = (\"Write\" | \"Read\" | \"No-Modify\" | \"Write\" \"Read\" | \"Read\"\n\"No-Modify\")\nHeaders = #message-header ; As defined in 4.2 of [1]\n\nThe Headers allows the lock to specify a subset of representations of a\nresource.\n\nExamples of type application/lock include:\n\nTime Out: Never\nLock Entries: URI http://www.microsoft.com/staff/yarong.html Write Exclusive\n[Yaron Goland <yarong@microsoft.com>]\n\nThis specifies a request for an exclusive write lock on\nhttp://www.microsoft.com/staff/yarong.html, held by Yarong Goland. This lock\nwill never automatically time out.\n\n3.2 Processing a Lock Request\n\n[TBD- Do we want to allow for multiple independent new lock declarations?\nWhat about multiple, independent, lock token extensions?]\n\nA lock request without a LockToken is a new lock request. All the requests\nin a lock must be granted or a 503 Service Unavailable must be returned. If\nthe lock is granted then the return body should be formated as:\n\nRETURN_LOCK_BODY = LockToken\n\nA lock request with a LockToken is a request to extend the lock represented\nby the lock token. The same rules as specified in the previous paragraph\napply.\n\nA lock request with Unlock specified for Lock_Request means that all locks\nassociated with this token should be removed.\n\nA lock_entries with Unlock specified means this particular lock should be\nremoved from the token.\n\nThe BNF allows for Unlocks to be specified without specifying a lock token.\nThis is not an error. This syntax allows authorized users to override locks\nthey do not have the token for.\n\nLock requests MUST be processed as an atomic action or the request must be\nrefused.\n\nWhen multiple resources are locked under a single token an operation will\nonly be allowed on any of the resources if the remaining locks in the token\ncan be guaranteed to exist for the life of the operation.\n\n3.3 Lock Discovery\n\nWhen a lock is taken out the system SHOULD record who owns the lock.\nOwnership information can be taken from the From header, from identification\nprovided by authentication, or from the LockOwners field.\n\nThis information SHOULD be available through the attribute header\n\"LockInformation\" which has the mime type application/LockInformation. The\nformat of the mime entity is:\n\nLOCKINFORMATION = #(Token_Field Time_Out Lock_Owners Lock_Entries)\n[Contact_Field]\nContact_Field = \"Contact\" \":\" token\n\nThe Contact_Field is used to provide contact information in case there is a\nproblem with a lock.\n\nAn example of a LockInformation attribute is:\n\nLockInformation:\nToken: a5dzq\nTime Out: Never\n[Yaron Goland <yarong@microsoft.com]\nLock Entries: URI http://www.microsoft.com/staff/yarong.html Write Exclusive\nContact: Lock Administrator <lockadmin@microsoft.com>\n\nThe exclusive write lock on http://www.microsoft.com/staff/yarong.html is\nheld by Yaron Goland, has token value a5dqz, and will never time out. If\nthere is a problem with a lock, the Lock Administrator should be contacted.\n\n4. Name Space Manipulation\n\n4.1 Copy\n\nA copy performs a byte-for-byte duplication of a resource, making it\navailable at both the original and new location in the URI namespace. There\nis no guarantee that the result of a GET on the URL of the resource copy\nwill be identical to a GET on the original resource. For example, copying a\nscript to a new location will often remove it from its intended environment,\nand cause it to either not work, or produce erroneous output. A copy MUST be\natomic.\n\nA copy is performed by sending a POST method to a resource which can perform\nthe copy. The entity body for the POST method is of content type\napplication/copy, defined in Section 4.1.1.\n\nBefore any copied resources are made available through the destination URIs,\nall copied resources must either be available or return a 503 Service\nUnavailable response code when referenced.\n\nIf the No Overwrite value is specified then that entry in the copy should\nnot occur if the destination URI already exists. If a resource is not copied\nbecause a \"No Overwrite\" flag was used and the resource exists then the\nrequest still succeeded.\n\n4.1.1 Definition of Content Type application/copy\n\nBODY = 1*(Source_URI Headers Destination_URI Headers Type)\nSource_URI = URI\nDestination_URI = URI\nType = \"Overwrite\" | \"No Overwrite\"\nHeaders = #message-header ; As defined in 4.2 of [HTTP11]\n\nExamples of content type application/copy include:\n\nhttp://www.ics.uci.edu/~ejw/hidden/draft.html\nAccept-Language: fr, en;q=0.7\nhttp://www.ics.uci.edu/~ejw/final_report.html\nOverwrite\n\nThis example specifies a copy of the French language version of\nhttp://www.ics.uci.edu/~ejw/hidden/draft.html if available, otherwise any\nEnglish version, into http://www.ics.uci.edu/~ejw/final_report.html,\noverwriting the contents of final_report.html if they exist.\n\nhttp://www.ics.uci.edu/pub/ietf/http/index.html\nRange: bytes=0-500\nhttp://www.ics.uci.edu/~ejw/working.html\nRange: bytes=0-500\nOverwrite\n\nThis example specifies a copy of the first 500 bytes of /pub/ietf/index.html\ninto /~ejw/working.html, overwriting the first 500 bytes of working.html if\nthey exist.\n\n4.2 Move\n\nA move causes the source resource to be accessible at the destination URI. A\nmove MUST be atomic. A move is performed by sending a POST method to a\nresource which can perform the move. The entity body of the POST method is\nof content type application/move, defined exactly the same as content type\napplication/copy, (Section 4.1.1).\n\nIn this case atomicity requires that before the resources are made available\nat the new location they must no longer be available at the old location.\nThe rest of the atomicity requirements are the same as for copy.\n\n4.3 Redirect\n\nRedirect is used to instruct a server to return one of the 3xx series codes.\nA Redirect request defines both the error code and the semantics of the\nentity-body.\n\nTo perform a redirect a POST should be performed with the content-type equal\nto application/redirect. The body of the mime type is defined as TBD. [The\nmime type will contain the URI being redirected, the code to be used, and\nthe semantics of the entity-body to be returned.]\n\n5. Relationships\n\nSection removed due to lack of consensus between authors.\n\n6. Notify Request Header (proposal, for comment)\n\nWhenever the NotifyRequest header is included in an HTTP request, the server\nshould send update information on the progress of a request.\n\nNotify_Request = \"NotifyRequest\" \":\"\n\nIt is common, in asynchronous environments, to provide a mechanism to\ndescribe the status of a request as it is processed. As we provide for more\nand more powerful methods, which have longer and longer processing times,\nmight we not want a similar feature for HTTP?\n\n7. URI Groups\n\nAny URI, which has a representation of content type application/uri_group,\nis defined to be a URI group. Content type application/uri_group will use\nthe SiteMap format. Members are listed, added, or removed from the group by\nperforming actions on application/uri_group.\n\nThe advantage of SiteMaps in this context is that they are designed to point\nto other SiteMaps. In this way a hierarchy can be built and when an\noperation is performed it will act recursively down the tree.\n\n8. Versioning (TBD)\n\nAcknowledgements\n\nRoy Fielding, Richard Taylor. Others, TBD.\n\nReferences\n\n[HTTP11] R. T. Fielding, J. Gettys, J. C. Mogul, H. F. Nielsen, and T.\nBerners-Lee. \"Hypertext Transfer Protocol -- HTTP/1.1\" Internet-Draft\ndraft-ietf-http-v11-spec-07.txt, expires February 12, 1997.\n\n[RFC1521] N. Borenstein, N. Freed. \"MIME (Multipurpose Internet Mail\nExtensions) Part One: Mechanisms for Specifying and Describing the Format of\nInternet Message Bodies.\" RFC 1521, Bellcore, Innsoft, September, 1993.\n\n[URL] T. Berners-Lee, L. Masinter, M. McCahill. \"Uniform Resource Locators\n(URL).\" RFC 1738, CERN, Xerox PARC, University of Minnesota, December, 1994.\n\n[2] R. Khare, \"HTTP/1.2 EXTENSION PROTOCOL (PEP)\" Internet-Draft\ndraft-ietf-http-pep-00.txt, expires August 19, 1996\n", "encoding": "ISO-8859-1"}