{"url": "https://www.ics.uci.edu/~ejw/authoring/depth/draft-ietf-webdav-depth-01.txt", "content": "INTERNET-DRAFT                                         Yaron Y. Goland\nExpires: April 1998                                       Saveen Reddy\n                                                 Microsoft Corporation\n                                                      November 6, 1997\n\n\n                         WebDAV Tree Operations\n                     draft-ietf-webdav-depth-01.txt\n\n\n1.   Status of this Memo\n\n        This document is an Internet-Draft.  Internet-Drafts are\n   working documents of the Internet Engineering Task Force (IETF), its\n   areas, and its working groups.  Note that other groups may also\n   distribute working documents as Internet-Drafts.\n\n   Internet-Drafts are draft documents valid for a maximum of six\n   months and may be updated, replaced, or obsoleted by other documents\n   at any time.  It is inappropriate to use Internet-Drafts as\n   reference material or to cite them other than as \"work in progress.\"\n\n   To view the entire list of current Internet-Drafts, please check the\n   \"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow\n   Directories on ftp.is.co.za (Africa), ftp.nordu.net (Europe),\n   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or\n   ftp.isi.edu (US West Coast).\n\n2.   Abstract\n\n   The WebDAV protocol specification [Goland et al., 1997] defines the\n   DELETE, COPY and MOVE methods. However these methods have a scope of\n   a single source resource. It is common for principals to wish to\n   perform a DELETE, COPY or MOVE on a collection and all its internal\n   members. This specification defines the DELETE-TREE, COPY-TREE and\n   MOVE-TREE methods that perform the equivalent of DELETE, COPY and\n   MOVE across a collection and all its progeny.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGoland & Reddy                                                [Page 1]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n3.   Contents\n\n   1. Status of this Memo.............................................1\n   2. Abstract........................................................1\n   3. Contents........................................................2\n   4. Problem Definition..............................................2\n   5. Proposed Solution...............................................3\n   6. Levels of Recursion.............................................3\n   7. Message Headers and Recursion...................................3\n   8. Lock Tokens and *-TREE Methods..................................4\n   9. DELETE-TREE Method..............................................4\n   10.COPY-TREE Method................................................6\n   11.MOVE-TREE Method................................................7\n   12.102 \"Processing\" Response Code..................................9\n   13.Status-URI Response Header......................................9\n   14.Author's Address...............................................10\n   15.Bibliography...................................................10\n\n4.   Problem Definition\n\n   HTTP is designed such that a single message causes a single action\n   on a single resource. This has proven to be a simple, interoperable,\n   robust mechanism for delivering methods. In addition, in a world\n   where the majority of requests are GETS, it is also a 'fair'\n   arbitrator of server resources. Specifically, as load increases each\n   client suffers degradation in service proportional to the number of\n   requests made.\n\n   However clients often wish to perform actions against all internal\n   members of a collection. Currently a client has no choice but to\n   execute each method individually on each member of the collection,\n   in other words, there is no way to instruct a server to recurse\n   through a namespace on behalf of a client.\n\n   In many cases forcing the client to perform their own recursive\n   calls is a desirable situation as it maintains the fairness of load\n   distribution. The average HTTP editing server, which handles mostly\n   GETs and PUTs with the occasional COPY or MOVE, is probably better\n   off using non-recursive operations.\n\n   However some servers routinely deal with operations on collection,\n   so routinely in fact that they have developed a number of\n   optimizations to allow them to quickly execute an operation against\n   a hierarchy.\n\n   A typical example is a copy on write system which can copy an entire\n   hierarchy by putting a single pointer into the server's internal\n   namespace and then tracking when one of the original resources is\n   changed, thus performing the copy only when required. These servers\n   are unable to take advantage of their optimizations because DAV does\n   not provide a way for a client to tell the server that it intends to\n   execute the copy against an entire hierarchy.\n\n\nGoland & Reddy                                                [Page 2]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n\n   In addition, in some circumstances, it is too expensive for clients\n   to handle recursion themselves. For example, a hand held unit with\n   limited memory, power, and bandwidth, would not be able to deal very\n   well with a simple operation such as deleting a collection. The hand\n   held unit would be required to execute a large number of methods and\n   potentially record a large number of index entries as it recurses\n   through the hierarchy. In such cases fairness takes second place to\n   access.\n\n   As such a means is needed for a client to efficiently indicate to a\n   server its desire to execute a single method against a hierarchy.\n\n5.   Proposed Solution\n\n   The proposed solution is the introduction of three new methods:\n   DELETE-TREE, COPY-TREE, and MOVE-TREE.\n\n   The three new methods are not the same as their root methods,\n   DELETE, COPY, and MOVE. For example, a MOVE on a collection has\n   different semantics then MOVE on a single resource.\n\n   Clients MUST NOT rely upon the three new methods executing on\n   members of their hierarchies in any particular order and the three\n   new methods are not atomic.\n\n   Upon executing the three new methods will perform as much of their\n   assigned task as possible and then return a response specifying what\n   they were able to accomplish and what they failed to do.\n\n   So, for example, an attempt to COPY a hierarchy may result in some\n   of the members being copied and some not.\n\n6.   Levels of Recursion\n\n   As currently defined, all three new methods apply to the full length\n   of the hierarchy. It has been suggested that the number of levels to\n   be recursed should be an option. However no compelling case has been\n   presented for why allowing the depth of recursion to be controlled\n   is a desirable feature. As such this specification errs on the side\n   of simplicity and declares that all three new methods apply to the\n   full hierarchy.\n\n7.   Message Headers and Recursion\n\n   Any headers on the three new methods MUST be applied to all\n   resources in the scope of the method. For example, an if-match\n   header will have its value applied against every resource in the\n   method's scope and will cause the method to fail if the header fails\n   to match properly.\n\n\n\n\nGoland & Reddy                                                [Page 3]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n   [Ed. Note: No, this isn't an error. Think about it, if you put an\n   'if-match: *' what are you after? I think that putting propagation\n   rules are just going to complicate things beyond reason. Look at the\n   typical case 'I only want to copy this collection if its membership\n   has changed or if the value of its members have changed.' The best\n   an e-tag could give you is detection of membership change, not if\n   the member's values have changed. I say leave well enough alone and\n   just propagate everything.]\n\n8.   Lock Tokens and *-TREE Methods\n\n   If a resource, source or destination, within scope of the *-TREE\n   method is locked in such a way as to prevent the successful\n   execution of the *-TREE method, then the lock token for that\n   resource MUST be submitted with the *-TREE request in the State-\n   Token request header.\n\n9.   DELETE-TREE Method\n\n9.1. Request\n\n   The DELETE-TREE method is only meaningful on a collection. If used\n   on a non-collection the DELETE-TREE MUST be treated as a DELETE.\n\n   DELETE-TREE instructs that the collection specified in the request-\n   URI, the records of its external member resources, and all its\n   internal member resources, are to be deleted.\n\n   If any member can not be deleted then all of the member's progeny\n   MUST NOT be deleted, so as to maintain the namespace.\n\n   Any headers included with DELETE-TREE MUST be applied in processing\n   every resource to be deleted. In this case, a header of special\n   interest is the DESTROY header which specifies the method to be used\n   to delete all resources in the scope of the DELETE-TREE.\n\n   When the DELETE-TREE method has completed processing it MUST return\n   a consistent namespace. Please refer to [Goland et al., 1997] for a\n   full definition of a consistent namespace.\n\n9.2. Response\n\n   The response SHOULD be a multi-status response that describes the\n   result of the DELETE-TREE on each effected resource.\n\n   [Editor's Note: The response to a TREE method could potentially be\n   huge, larger than a client may want or need to deal with. It has\n   been suggested that clients be given the ability to tell the server\n   they only want to get back a response code, not a response body.\n   Thoughts?]\n\n\n\n\n\nGoland & Reddy                                                [Page 4]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n9.3. Response Codes\n\n   415 Conflict - This can be used to indicate that some unspecified\n   problem has occurred which makes it impossible to delete a\n   particular resource. The most common scenario is that a new internal\n   member was added to a collection while a DELETE-TREE was running and\n   thus the collection can not be deleted.\n\n\n9.4. Example\n\n   DELETE-TREE  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destroy: <http://www.ietf.org/standards/dav/NoUndelete>\n\n\n   HTTP/1.1 207 Multi-Response\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"d\"?>\n   <d:multiresponse>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource1</d:href>\n          <d:href>http://www.foo.bar/container/resource2</d:href>\n          <d:status>HTTP/1.1 200 Success</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/</d:href>\n          <d:status>HTTP/1.1 418 Method Failure</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource3</d:href>\n          <d:status>HTTP/1.1 412 Precondition Failed</d:status>\n     </d:response>\n   </d:multiresponse>\n\n   In this example the attempt to delete\n   http://www.foo.bar/container/resource3 failed. Given that there is\n   only one precondition, one can figure out that the failure was\n   caused the inability of the system to meet the requirement of the\n   Destroy header. Normally however, the client will not know exactly\n   what precondition caused the failure.\n\n   The result is that container wasn't deleted because of the failure\n   to delete container/resource3.\n\n   [Ed-Note: To state the obvious, do we want to provide information on\n   which precondition actually failed? This is not the panacea it might\n   seem as the failure may have occurred for multiple reasons and\n   listing a bunch of headers may or may not be useful. Besides, the\n   reality is, nobody every pays attention to error codes. There are\n\n\n\nGoland & Reddy                                                [Page 5]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n   really only two error codes in the world \"It worked\" or \"Something\n   Went Wrong.\"]\n\n10.  COPY-TREE Method\n\n10.1.     Request\n\n   The COPY-TREE method is only meaningful on a collection. If used on\n   a non-collection the COPY-TREE MUST be treated as a COPY.\n\n   COPY-TREE instructs that the collection specified in the Request-\n   URI, the records of its external member resources, and all its\n   internal member resources, are to be copied to a location relative\n   to the Destination header.\n\n   Any headers included with COPY-TREE are to be applied in processing\n   every resource to be copied.\n\n   The exception to this rule is the Destination header. This header\n   only specifies the destination for the Request-URI. When applied to\n   members of the collection specified in the request-URI the value of\n   Destination is to be modified to reflect the current location in the\n   hierarchy. So, if the request-URI is \"a\" and the destination is \"b\"\n   then when a/c/d is processed it MUST use a destination of b/c/d.\n\n   When the COPY-TREE method has completed processing it MUST have\n   created a consistent namespace at the destination. Thus if it is not\n   possible to COPY a collection with internal members, the internal\n   members may still be copied but a collection will have to be created\n   at the destination to contain them.\n\n   Please refer to the definition of COPY in section XYZ of [Goland et\n   Al., 1997] for the rules on merging members and properties of source\n   collections with pre-existing collections at the destination.\n\n10.2.     Response\n\n   The response is a multi-status response that describes the result of\n   the COPY-TREE on each effected resource. The response is given for\n   the resource that was to be copied, not the resource that was\n   created as a result of the copy. In other words, each entry\n   indicates if the copy on the resource specified in the href\n   succeeded or failed and why.\n\n   The exception to this rule is for errors that occurred on the\n   destination. For example, if the destination was locked the response\n   would indicate the destination URL and a 416 \"Locked\" error.\n\n\n\n\n\n\n\n\nGoland & Reddy                                                [Page 6]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n10.3.     Example\n\n   COPY-TREE  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Enforce-Live-Properties: *\n\n   HTTP/1.1 207 Multiresponse\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"d\"?>\n   <d:multiresponse>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource1</d:href>\n          <d:href>http://www.foo.bar/container/resource2</d:href>\n          <d:href>http://www.foo.bar/container/</d:href>\n          <d:href>http://www.foo.bar/container/R2/D2</d:href>\n          <d:status>HTTP/1.1 201 Created</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/R2/</d:href>\n          <d:status>HTTP/1.1 415 Precondition Failed</d:status>\n     </d:response>\n   </d:multiresponse>\n\n   In this example most of the resources, along with the container,\n   were copied successfully. However the container R2 failed, most\n   likely due to a problem with enforcing live properties. R2's member\n   D3 was successfully copied. As a result a collection was created at\n   www.foo.bar/othercontainer/R2 to contain D2.\n\n11.  MOVE-TREE Method\n\n11.1.     Request\n\n   The MOVE-TREE method is only meaningful on a collection. If used on\n   a non-collection the MOVE-TREE MUST be treated as a MOVE.\n\n   MOVE-TREE instructs that the collection specified in the Request-\n   URI, the records of its external member resources, and all its\n   internal member resources, are to be moved to a location relative to\n   the Destination header.\n\n   Any headers included with MOVE-TREE are to be applied in processing\n   every resource to be moved.\n\n   The exception to this rule is the Destination header. The behavior\n   of this header is the same as given for COPY-TREE.\n\n\n\n\n\n\nGoland & Reddy                                                [Page 7]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n   When the MOVE-TREE method has completed processing it MUST have\n   created a consistent namespace on both the source and destination,\n   creating collections at the source or destination as necessary.\n\n   As specified in the definition of MOVE, a MOVE of a collection over\n   another collection causes the destination collection and all its\n   members to be deleted.\n\n11.2.     Response\n\n   The response is a multi-status response that describes the result of\n   the MOVE-TREE on each effected resource. The response is given for\n   the resource that was to be moved, not the resource that was created\n   as a result of the move. In other words, each entry indicates if the\n   move on the resource specified in the href succeeded or failed and\n   why.\n\n   The exception to this rule is for errors that occurred on the\n   destination. For example, if the destination was locked the response\n   would indicate the destination URL and a 416 \"Locked\" error.\n\n11.3.     Example\n\n   MOVE-TREE  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Enforce-Live-Properties: *\n   Overwrite: False\n   State-Token: <OpaqueLockToken:xxxx> <OpaqueLockToken:xxxx>\n\n\n   HTTP/1.1 207 Multiresponse\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?namespace href = \"http://www.ietf.org/standards/dav/\" As = \"D\"?>\n   <d:multiresponse>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource1</d:href>\n          <d:href>http://www.foo.bar/container/resource2</d:href>\n          <d:href>http://www.foo.bar/container/</d:href>\n          <d:href>http://www.foo.bar/container/C2/R2</d:href>\n          <d:status>HTTP/1.1 201 Created</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/C2</d:href>\n          <d:status>HTTP/1.1 418 Method Failure</d:status>\n     <d:response>\n          <d:href>http://www.foo.bar/othercontainer/C2</d:href>\n          <d:status>HTTP/1.1 416 Locked</d:status>\n     </d:response>\n   </d:multiresponse>\n\n\nGoland & Reddy                                                [Page 8]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n\n   In this example the client has submitted a number of lock tokens\n   with the request. A lock token will need to be submitted for every\n   resource, both source and destination, anywhere in the scope of the\n   method, that is locked. In this case the proper lock token was not\n   submitted for the destination http://www.foo.bar/othercontainer/C2.\n   This means that the resource continer/c2 could not be copied,\n   although its child container/C2/R2 could be copied.\n\n12.  102 \"Processing\" Response Code\n\n   The *-Tree methods can potentially take a long period of time to\n   process. In such cases the client may time-out the connection while\n   waiting for a response. To prevent this the server MAY return a 102\n   response code to indicate to the client that the server is still\n   processing the method.\n\n   If a method is taking longer than [INSERT NUMBER HERE] seconds to\n   process the server SHOULD return a 102 \"Processing\" response.\n\n13.  Status-URI Response Header\n\n   The Status-URI response header MAY be used with the 102 \"Processing\"\n   response code to inform the client as to the status of a method.\n\n   Status-URI = \"Status-URI\" \":\" *(Status-Code \"<\" URI \">\") ; Status-\n   Code is defined in 6.1.1 of [RFC2068]\n\n   The URIs listed in the header are source resources which have been\n   effected by the outstanding method. The status code indicates the\n   resolution of the method on the identified resource. So, for\n   example, if a COPY-TREE method is outstanding and a 102 \"Processing\"\n   response with a Status-URI response header is returned, the included\n   URIs will indicate resources that have had copy attempted on them\n   and what the result was. Note that including the URI does not\n   indicate the result of applying the method.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGoland & Reddy                                                [Page 9]\n\f\nINTERNET-DRAFT          WebDAV Tree Operations        November 6, 1997\n\n\n14.  Author's Address\n\n   Yaron Y. Goland\n   Saveen Reddy\n   Microsoft Corporation\n   1 Microsoft Way\n   Redmond, WA. 98053\n   USA\n\n   e-mail: {yarong, saveenr}@microsoft.com\n\n15.  Bibliography\n\n   [Goland et al., 1997] Y. Goland, E. J. Whitehead, Jr., Asad Faizi,\n   Stephen R. Carter, Del Jensen 'Extensions for Distributed Authoring\n   and Versioning on the World Wide Web -- WEBDAV', March 1997, <URL:\n   ftp://ftp.ietf.org/internet-drafts/draft-ietf-webdav-protocol-\n   04.txt>\n\n   [RFC2068] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-\n   Lee, 'Hypertext Transfer Protocol -- HTTP/1.1', RFC 2068, January\n   1997, <URL:ftp://ds.internic.net/rfc/rfc2068.txt>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGoland & Reddy                                               [Page 10]\n\f\n", "encoding": "ascii"}