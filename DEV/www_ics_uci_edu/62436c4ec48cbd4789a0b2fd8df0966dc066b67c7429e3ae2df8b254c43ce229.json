{"url": "https://www.ics.uci.edu/~eppstein/261/w18-hw2-soln.html", "content": "\n<!DOCTYPE html>\n<html>\n<head>\n<title>CompSci 261, Winter 2018, Homework 2</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n</head>\n<body>\n<h1>CompSci 261, Winter 2018, Homework 2</h1>\n<ol>\n\n<li><p>In the deletion algorithm for linear probing, we need to\nknow whether an index $i$ appears between $h(k)$ and $j$, where\n$h(k)$ is the starting index for key $k$ and all three of $i$,\n$h(k)$, and $j$ belong to the same block of occupied cells. Give\npseudocode or a formula for performing this betweenness test,\nthat correctly handles the case when the block of cells wraps\naround from the end of the hash table back to its start.</p>\n\n<p style=\"color:#bc1e47;background-color\"#fff\">Solution:\nif $j \\ge h(k)$ return $i \\ge h(k)$ and $i \\le j$,\nelse return $i \\ge h(k)$ or $i \\le j$.</p></li>\n\n<li><p>Recall that, for a linear probing hash table with load\nfactor at most $1/2$, the multiplicative Chernoff bound tells us\nthat the probability of seeing a block of exactly $B$ filled\ncells in one particular location in the hash array is at most\n$(e/4)^{B/2}$. Use this formula to give a bound on the expected\nnumber of blocks of filled cells of this length throughout the\nentire hash array. What is the largest value of $B$ for which\nyour bound on the expected number is at least $1$?  (Hint: How\nmany different blocks of length $B$ are there?)</p>\n\n<p style=\"color:#bc1e47;background-color\"#fff\">Solution: Let $n$ be the number of keys, so (with the given load factor) there are $2n$ cells in the hash table, and $2n$ places where a block of $B$ cells could start. By linearity of expectation, the expected number of filled cells of this length is at most $2n(e/4)^{B/2}$. To make this equal to 1, we need $B$ to be proportional to $\\log n$; more precisely, $B=2\\log_{4/e}(2n)$.</p></li>\n\n<li><p>The version of cuckoo hashing that we described in class\nuses two hash functions $h_1(k)$ and $h_2(k)$ that both\nmap a key $k$ to a position within a single array $A$ of\nkey/value pairs. Sometimes cuckoo hashing is instead implemented\nwith two different arrays $A_1$ and $A_2$, so that $h_1(k)$ maps\nkey $k$ to a position in array $A_1$ and $h_2(k)$ maps key $k$\nto a position in array $A_2$. Recall that one way for cuckoo\nhashing to fail is for three keys to all map to the same two\narray cells.</p>\n\n<p>Compute the probability that a given triple of keys all map\nto the same two array cells, for both kinds of cuckoo hash\ntable, when there are $n$ keys and a total of $2n$ array cells.\n(For the version of cuckoo hashing with two tables, you can\nassume that each of the two arrays has $n$ cells.) For which of\nthese two versions of cuckoo hashing is there a greater\nprobability of this type of failure, or are they both equal in\nthis respect?</p>\n\n<p style=\"color:#bc1e47;background-color\"#fff\">Solution: Let's call the three keys $x$, $y$, and $z$. With the single table of $2n$ cells, there is a $1/(2n)$ probability that $h_1(x)=h_2(x)$, and when this happens the probability that the four other hash values also land in the same place is $1/(2n)^4$. On the other hand, there is a $(2n-1)/(2n)$ probability that $h_1(x)\\ne h_2(x)$, and when this happens each other key has a $2/(2n)^2$ probability of landing in the same two places (possibly with the two hash functions swapped, but this still counts as a collision). So the total probability of a three-way collision is\n$$\\frac{1}{32n^5}+\\frac{2n-1}{8n^5}=\\frac{2n+3}{8n^5}\\approx \\frac{1}{4n^4}.$$\nWith two tables of $n$ cells, collisions only happen when $h_1(x)=h_1(y)=h_1(z)$ and $h_2(x)=h_2(y)=h_2(z)$; there is no possibility of the two functions being swapped.\nEach of $h_i(y)$ and $h_i(z)$ (for $i=1$ or $2$) has probability $1/n$ of equalling $h_i(x)$. So the calculation is much simpler, and the probability of a three-way collision is\n$$\\frac{1}{n^4}.$$\nSo triple collisions are much less likely (by nearly a factor of four) in the single-table solution as they are in the two-table solution.</p></li>\n\n<li><p>Recall that the load factor of a hash table is defined as\n$n/N$, where $n$ is the number of key-value pairs stored in the\ntable and $N$ is the number of cells in the hash array. If a\nsingle reference to an object can be stored in a single machine\nword, then a single key-value pair takes two machine words to\nstore, so the minimum amount of memory required for any\nstructure that lists all pairs would be $2n$, while an\nopen-addressing hash table would use $2N$ machine words. Thus,\nthe load factor also equals $2n/2N$, the ratio between the\nminimum amount of memory needed and the amount of memory\nactually used.</p>\n\n<p>Now, consider a hash chaining data structure, where we store\nthe key-value pairs within any cell of the hash table as a\nlinked list (a collection of objects that each have three\nreferences or pointers, for the key, value, and next object in\nthe list) and where each table cell stores a single reference or\npointer to the first object in its list. If this structure uses\n$M$ memory cells, define the \"effective load factor\" of this\nstructure to be $2n/M$, where $2n$ is again the minimum storage\nrequired for $n$ key-value pairs and $M$ is the storage actually\nused.</p>\n\n<p>Write a formula that translates the load factor $f$ of a hash\nchaining data structure to the effective load factor of the same\nstructure. What is the value of $f$ for which the effective load\nfactor is $1/2$?</p>\n\n<p style=\"color:#bc1e47;background-color\"#fff\">Solution: If there are $n$ keys, and the load factor is $f$, then there are $n/f$ cells in the array of the hash table (a single pointer each), and $n$ linked list objects (with three pointers each), for a total memory usage of $n(1/f+3)$ pointers. Therefore, the effective load factor is\n$$\\frac{2}{1/f+3}.$$\nTo get this effective load factor to be $1/2$, we need $f$ to be $1$.\nWhat this means is that, in order to use the same amount of memory as an open-addressing hash table with load factor $1/2$, a hash chaining data structure would have to use the higher load factor $1$. This is relevant if we want to compare the performance of different hashing algorithms with the same memory usage as each other. It wouldn't be fair to compare open addressing and hash chaining at the same (actual) load factors, because that comparison would give much more memory to the chaining algorithm than to the open addressing algorithm.</p></li>\n\n</ol>\n</body>\n</html>\n", "encoding": "ascii"}