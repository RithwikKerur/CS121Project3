{"url": "https://www.ics.uci.edu/~yamingy/cocktail.r", "content": "#  R implementation of the cocktail algorithm for D-optimal designs (approximate theory)\n#  \n#  output=cocktail(X, maxiter, small, alg)\n#  \n#  required input\n#    X: design matrix (n by m)\n#    (n: number of design points)\n#    (m: dimension of parameter)\n#  \n#  optional input \n#    maxiter: maximum number of iterations (default=1000)\n#    small: convergence threshold (default=1e-5)\n#    alg: choice of algorithm (see below; default=4)\n#  \n#  output: a list of \n#    i) weights (1 by n), ii) bounds on the log determinant, iii) iteration count, and \n#    iv) convergence status (1 means convergence and 0 otherwise) \n\ncocktail=function(X, maxiter=1000, small=1e-5, alg=4){ \n  if(!is.matrix(X)) \n    X=as.matrix(X)\n  n=dim(X)[1]\n  m=dim(X)[2]\n  if(n<m||m<2)\n    stop(\"Wrong input sizes\") \n  if(!any(alg==0:4)){\n    warning(\"Unknown algorithm chosen; default used instead\")\n    alg=4\n  } \n  if(alg==0)\n    print(\"Using the multiplicative algorithm only\")\n  if(alg==1)\n    print(\"Using the vertex exchange method (VEM)\")\n  if(alg==2)\n    print(\"Using both the vertex direction method (VDM) and the multiplicative algorithm\")\n  if(alg==3){\n    print(\"Using the cocktail algorithm:\") \n    print(\"VDM + nearest neighbor exchange + multiplicative algorithm\")\n    print(\"The neighborhood structure is pre-specified\")\n  }\n  if(alg==4){\n    print(\"Using the cocktail algorithm:\")\n    print(\"VDM + nearest neighbor exchange + multiplicative algorithm\")\n    print(\"The nearest neighbors are computed on the fly\")\n  } \n\n  # starting values  \n  if(alg==0)\n    w=rep(1, n)  \n  else{\n    w=rep(0, n)\n    w[sample(1:n, min(2*m, n))]=1\n  } \n  w=w/sum(w)  # weights should sum to one \n  index=1:n\n  supp=index[w>0]  # support points \n  Y=matrix(nrow=n, ncol=m)\n  for(j in 1:m)\n    Y[supp, j]=X[supp, j]*w[supp]\n  M=t(Y[supp, ])%*%X[supp, ]  # information matrix \n  deri=rep(0, n)\n\n  for(iter in 1:maxiter){\n    P=solve(M, t(X))\n    for(j in 1:n)\n      deri[j]=sum(X[j,]*P[,j])/m \n    max.d=max(deri)\n    if(max.d<1+small)  # testing convergence\n      break \n      \n    if(alg==1){  # VEM step\n      j2=max(index[max.d==deri]) \n      min.d=min(deri[w>0]) \n      j1=min(index[w>0&min.d==deri]) \n      d=X[c(j1, j2), ]%*%P[,c(j1, j2)] \n      stepsize=0.5*(d[1,1]-d[2,2])/(d[1,1]*d[2,2]-d[1,2]*d[2,1]+1e-200) \n      stepsize=max(min(stepsize, w[j2]), -w[j1]) \n      w[j1]=w[j1]+stepsize \n      w[j2]=w[j2]-stepsize \n      M=M+stepsize*X[j1,]%*%t(X[j1,])-stepsize*X[j2,]%*%t(X[j2,])\n    }\n\n    if(alg>=2){  # VDM step\n      j2=max(index[max.d==deri]) \n      stepsize=(max.d-1)/(m*max.d-1) \n      w=(1-stepsize)*w \n      w[j2]=w[j2]+stepsize \n      M=(1-stepsize)*M+stepsize*X[j2,]%*%t(X[j2,]) \n    }\n\n    if(alg>=3){  # nearest neighbor exchanges\n      supp=index[w>0] \n      for(j in 1:(length(supp)-1)){\n        j1=supp[j] \n        j2=supp[j+1] \n        if(alg==4){  # nearest neighbor computed on the fly\n          near=Inf \n          for(k in (j+1):length(supp)){\n            diff=sum(abs(X[j1,]-X[supp[k],]))\n            if(near>diff){\n              near=diff\n              j2=supp[k]\n            }\n          }\n        } \n        d=X[c(j1, j2), ]%*%solve(M, t(X[c(j1, j2), ])) \n        stepsize=0.5*(d[1,1]-d[2,2])/(d[1,1]*d[2,2]-d[1,2]*d[2,1]+1e-200)\n        stepsize=max(min(stepsize, w[j2]), -w[j1])\n        w[j1]=w[j1]+stepsize \n        w[j2]=w[j2]-stepsize \n        M=M+stepsize*X[j1,]%*%t(X[j1,])-stepsize*X[j2,]%*%t(X[j2,])\n      }\n    }\n\n    if(alg!=1){  # multiplicative step\n      if(alg==0)\n        w=w*deri \n      if(alg>=2){\n        supp=index[w>0]\n        P=solve(M, t(X[supp, ]))\n        for(j in 1:length(supp))\n          w[supp[j]]=w[supp[j]]*sum(X[supp[j],]*P[,j])/m\n      }\n      w[supp]=w[supp]/sum(w[supp])  # redundant (numerical safeguard)\n      for(j in 1:m)\n        Y[supp, j]=X[supp, j]*w[supp]\n      M=t(Y[supp, ])%*%X[supp, ]\n    }\n  }  # end for\n\n  if(iter==maxiter) \n    cat(\"No convergence in\", maxiter, \"iterations\\n\")\n  else \n    cat(\"Convergence in\", iter, \"iterations\\n\") \n  lower=determinant(M, logarithm=T)[[1]][1]\n  upper=lower+m*(max.d-1)\n  out=list(w, c(lower, upper), iter, iter!=maxiter) \n  names(out)=c(\"weights\", \"bound.criterion\", \"iteration.count\", \"converge\") \n  out \n}\n\n", "encoding": "ascii"}