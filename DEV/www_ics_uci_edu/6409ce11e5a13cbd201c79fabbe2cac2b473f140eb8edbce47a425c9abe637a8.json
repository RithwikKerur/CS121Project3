{"url": "https://www.ics.uci.edu/~vitus/gtool/", "content": "<HTML>\n<HEAD>\n<TITLE>GraphTool</TITLE>\n<!-- Revised August 1996 vitus@ics.uci.edu\n     Be sure to Keep Current these comments\n-->\n</HEAD>\n\n<BODY>\n\n<H1>GraphTool: A Tool for Interactive Design and Manipulation of Graphs and\nGraph Algorithms</H1>\n<HR>\n<P><B>GraphTool</B> is an interactive tool for editing graphs and visualizing\nthe execution and results of graph algorithms.\nIt runs under the X Windows environment and has full window/mouse interface.\nWhile the primary purpose of <B>GraphTool</B> is to provide a means for\nexperimentally investigating the performance of graph algorithms, it has other\nuseful features as well.\nIt provides features for printing graphs in a visually appealing format, which\nmakes it easier to prepare papers for publication.\nIt also provides a facility for \"animating\" algorithms, which means that it can\nbe used in computer assisted instruction (CAI) and for preparing video\npresentation of algorithms.\n<A HREF=\"#references\">Much more information</A> about <B>GraphTool</B> is\navailable.\n<A HREF=\"./xbt_gtool.zip\">A SUN OS 4.x version</A> of <B>GraphTool</B> is\navailable.\nIn addition to the executable <code>xbt_gtool</code>, there is a library,\n<code>graphtool.h</code> and <code>libgraphtool.a</code>, that handles many\ncommon functions used in algorithms.\nAlgorithms are made visible to <B>GraphTool</B> by adding an entry for them in\nthe <code>.graphrc</code> file.\nA sample <code>.graphrc</code> file, the source for its\n<A HREF=\"#algorithms\">algorithm entries</A>, and a <code>Makefile</code> have\nall been included.\n<A HREF=\"http://www.ics.uci.edu/~dillenco/graphtool/windows/graphtool.html\">\nGraphTool has also been ported to run under the Windows '95 environment\n</A>.</P>\n<HR>\n<H2><A NAME=\"algorithms\">Algorithm Entries</A></H2>\n<UL>\n<LI> Random vertices\n<LI> Voronoi diagram: compute Voronoi diagram, by first computing Delaunay\ntriangulation, using simple O(N**2) algorithm due to (I think) McLain, and then\ntaking dual.  This program also demonstrates how edge (node) colors become edge\nstyles (node patterns) in black and white.\n<LI> Eucl Shortest Paths: compute shortest (Euclidean path in an undirected\ngraph.\nAlgorithm used is such that triangle inequality need not hold\n(although in this case it does), but all weights must be positive.\n<LI> Delaunay Tri: compute Delaunay triangulation, using simple O(N**2)\nalgorithm due to (I think) McLain.\n<LI> Shortest Cycle: compute shortest weighted cycle in an undirected graph\nby: For each edge, remove that edge, find shortest path through remaining\ngraph, add on edge length.\nAlgorithm used is such that triangle inequality need not hold\n(although in this case it does), but all weights must be positive.\n<LI> Shortest Nonfacial Cycle: compute shortest weighted cycle in an\nundirected graph that is not the boundary of a face.\nAlgorithm used is such that triangle inequality need not hold\n(although in this case it does), but all weights must be positive.\n<LI> Display Faces and Weights: display each face and the sum of the weights\nof the vertices incident on the face.\nUseful for checking the validity of Rivin-Smith (inscribability) weightings.\n<LI> Display Min, Max weights, sums: compute facts about weights, including:\nmax edge weight, min edge weight, max face sum and min face sum\n<LI> flipdt: compute Delaunay triangulations by edge flipping.\nUse greedy (queuing) strategy, for now.\n<LI> sweeptri: compute plane-sweep (left-to-right) triangulation.\n<LI> bipartite: find a bipartite subgraph with many edges, using a greedy\nheuristic.\n<LI> Bipartite Matching: bipartite matching using Hopcroft-Karp algorithm.\nThe algorithm first colors the graph, then does the matching.\n<LI> Extreme Edges: compute longest and shortest edges\n<LI> Geometric MST: compute geometric minimum spanning tree, using dumb\nalgorithm.\n<LI> Hamiltonian Cycle: check for Hamiltonian cycle, using slightly improved\nbrute force algorithm.\n<LI> Total Edge Length: compute total edge length.\n<LI> Convex Hull: compute convex hull, using Jarvis March.\n<LI> Convex Layers: computer convex layers, by successive applications of\nJarvis March.\n<LI> Remove Edges and unmarked vertices: strip all edges and all white\nvertices, then color remaining vertices white.\n<LI> Remove thin edges: delete all edges with width = 1.\n</UL>\n<HR>\n<H2><A NAME=\"references\">References</A></H2>\n<OL>\n<LI><A HREF=\"../\">V. J. Leung</A>,\n<A HREF=\"/~dillenco/\">M. B. Dillencourt</A>, and A. L. Bliss,\n<A HREF=\"./inst.ps.Z\">\n<B>GraphTool</B>:\nA Tool for Interactive Design and Manipulation of Graphs and Graph Algorithms,\n</A>\nin N. Dean and G. E. Shannon, editors,\n<I>Computational Support for Discrete Mathematics</I>, 269-278.\n<A HREF=\"http://www.ams.org/\">American Mathematical Society</A>, 1994.\n</OL>\n<HR>\n<I>This information brought to you by\n<A HREF=\"mailto:vitus@ics.uci.edu\">vitus@ics.uci.edu</A>\n<br>\nCurrent as of 29 August 1997</I>\n</BODY>\n</HTML>\n", "encoding": "ascii"}