{"url": "https://www.ics.uci.edu/~ejw/authoring/minneapolis/dav/minutes.txt", "content": "Meeting Minutes\nWEBDAV WG\nMinneapolis IETF\nMarch 17, 1999\n\nThe WEBDAV working group met at the Minneapolis IETF, on March 17,\n1999, from 15:30 to 17:30.  The meeting was chaired by Jim Whitehead,\nand Yaron Goland recorded notes.  Approximately 55 people attended.\n\nThe meeting began with a brief review of the agenda (overview of\nDELTA-V BOF, issues from the Advanced Collections specification,\ncreating a property registry, moving access control forward). \n\nDELTA-V BOF PRESENTATION\n\nJim Amsden gave a brief presentation on the DELTA-V BOF, which was\nheld in the previous session.  The presentation gave an overview of\nthe scope of the effort proposed in the DELTA-V charter.\n\nJim's presentation began with a short history of why WebDAV was\ncreated. WebDAV, when it went to create document management features\nfound that versioning was critical and included it from the start. As\nWebDAV progressed it was found that versioning was very hard and that\nit required its own working group. DELTA-V is that proposed working\ngroup.\n\nThe protocol that is proposed for DELTA-V will contain the following\nfeatures:\n\n   Versioning - Ability for a resource to be checked into a version\n   controlled system where it has multiple revisions that are tracked\n   and can have multiple successor and predecessor relationships. The\n   server will maintain those relationships, report the revision\n   history, and control the write able access to these revisions using\n   check in/out operations.\n\n   Parallel Development - Provides more resource availability in a\n   multi-user environment. Multiple users can check-out the same\n   revisions of a resource and track who has those check-outs and to\n   merge them back into each other later on as appropriate.\n\n   Configuration Management - A means of to collecting a group of\n   consistent revisions of resources together. The protocol will\n   support creating configurations, putting revisions in them and\n   tracking them over time.\n\nJim Amsden finished by reporting that the first BOF was just\ncompleted, and seemed to be reasonable success. There is a mailing\nlist ietf-dav-versioning@w3.org, which is archived.\n\nADVANCED COLLECTIONS PROTOCOL\n\nAfter Jim Amsden's presentation, the floor was turned over to Judy\nSlein for discussion of issues from the Advanced Collections protocol\nspecification.\n\nThe first issue concerned what the default behavior should be for\ncertain methods like copy and lock when applied to references.  There\nare two types of references in the Advanced Collections protocol\nspecification: \n\n   Redirect - for servers that want to provide basic referencing\n   capabilities at minimal cost, the server never acts as a proxy\n   (i.e., the server does not forward methods along to the target\n   resources) but the disadvantage is that the reference is very\n   visible to clients, and clients have to take actions (based on the\n   returned 3xx status code) to resolve the reference.\n\n   Direct references - cheap for clients but expensive for\n   servers. The servers resolve these automatically and provide the\n   illusion that the client is working directly on the referenced\n   resource (a.k.a. target resource).\n\nThe general rule of thumb for default behavior is that when you apply\na method to a redirect reference you get a 302 response in the\nlocation header and that response gives you the URI of the target\nresource. The default behavior for direct reference is for the server\nto automatically apply the method to the target resource, itself.\nJudy stated that in the ideal, these default behaviors should be the\nrule for all methods, but there are some cases which make this not\npossible. During discussions on this issue, the spec. authors have\ndeveloped principles to deal with situations where the default\nbehaviors do not apply.  These discussions led to the realization that\nthere are four cases when determining the behavior of a method when\nreferences are present: Redirect references, Collections that contain\nredirect references, Direct references, Collections that contain\ndirect references.\n\nThe first rules the authors developed was to ensure that if a method\nis applied to a single direct reference and or if the same method is\napplied to a direct reference in a collection, the behavior of the\nmethod will be the same. The same logic applies for redirect\nreferences. So we really have two cases. We would like to be able to\ndo the same thing for redirect and direct references, either apply to\nthe target or not. But we haven't been able to do that.\n\nAt this point there some Q&A from the attendees.  One attendee asked\nwhy there are both direct and redirect references?  \n\nSome arguments from this discussion in favor of having both direct and\nredirect references:\n\n  - Redirect resources are easier for servers to implement than direct\n    references \n  - Security: the server may not want to perform an action on behalf\n    of the client because of the security implications (and hence\n    would either not want to implement direct references, or would\n    limit the target to be a resource on the same server (or\n    administrative domain) as the reference\n  - Redirect references can have a target which is not an http scheme\n    URL (e.g., ftp or gopher URLs), and it is unlikely that a server\n    would proxy HTTP commands (some of which do not have equivalents\n    in other protocols) to allow direct references to these URLs.\n  - Servers already provide a redirect capability, and creating a\n    redirect is performed by out-of-band mechanisms.  Redirect\n    references provide a mechanism for remotely authoring, via HTTP,\n    these redirects.  File systems often contain both kinds of\n    reference, both direct and redirect-style, and it would be useful\n    to be able to author both kinds of reference.\n\nArguments raised against having both kinds of reference:\n\n  - Direct references appear to have the same set of features as redirect\n    references, so why have both?\n  - If a client is redirected to the target resource (via a redirect\n    reference) once, that is more efficient than if a server constantly\n    forwards requests, as is the case with direct references.\n\nJudy closed discussion by noting the issue that the specification may\nnot necessarily need two different kinds of references. She also noted\nthat the specification was unlikely to change so fundamentally at this\npoint.\n\nJudy continued her presentation.  Judy observed that the specification\nauthors have developed a set of design principles which are not\northogonal, and must be traded off for some methods. The authors have\ndeveloped the following principles:\n\n- All references should be usable by down-level clients and the\n  default behavior should be what makes the most sense to a down-level\n  client.\n- The behavior of a method applied to a referential resource should be\n  consistent, whether it is applied to an individual references or a\n  reference encountered when processing a collection.\n- A server should never need to resolve a redirect reference and act as a proxy\n  (we never violated this). \n- Behavior should be consistent across all methods as far as possible.\n- We want to be consistent with WebDAV and HTTP semantics for\n  methods.\n\nUnfortunately, these principles lead to conflicting design choices for\nsome methods.\n\nApplying the principles is easy for the methods: GET, HEAD, OPTIONS,\nPUT, POST, MKCOL, MKREF, PROPPATCH, and PROPFIND. For a redirect\nreference you respond with a 302. For a direct redference you apply to\nthe target.\n\nThe more difficult methods are DELETE and MOVE.  For these, always\napply the method to the redirect reference resource itself, and also\napply the method to the direct reference resource. For COPY, LOCK and\nUNLOCK, the method is applied to the redirect reference resource,\nwhile for direct references, the method is applied to the target. \nThere is no consensus on the last three.\n\nJudy noted that for MOVE and DELETE, there appears to be consensus\nbecause their semantics are similar to those supported by file\nsystems. The rationale for applying them to the reference resource,\nrather than its target, is that MOVE and DELETE affect the membership\nof collections, and it would be undesirable if MOVE and DELETE,\nthrough secondary effects, modified the membership of the target\ncollections.  There was general agreement in the room on this point.\n\nCOPY FOR REFERENCES\n\nJudy went on the semantics of COPY.  For COPY, the expectation is that\nthe destination of a COPY should be a new resource, and operations on\nthat new resource do not affect the original resource. However, what\nis the expectation if you copy a collection with references? Is the\nexpectation the new collection will have copies of the references or\nof the targets? If you want to get 302 in all the same cases then you\nwant to copy the references. If you want to have safe resources to\nplay with then you want the targets to be copied.\n\nDiscussion on this topic then ensued. One thread of discussion\nconcerned wther the behavior of COPY on individual resources should be\nthe same as COPY on collections of resources.  Some attendees noted\nthat copying collections is a difficult, and option-laden activity in\noperating systems, and in programming languages (e.g. LISP has five\ndifferent copy operators based on various conditions).  Choices in\nprogramming languages haven't been encouraging: either they make one\nwrong choice, which leads to people creating many different types of\ncopy, or they choose one and tell everyone else to go away.  It was\nnoted that one source of underlying difficulty with COPY is that the\nterm copy has lots of different meanings for computers, and for paper\ntoo.\n\nLarry Masinter then proposed that, the safest thing is to perform the\nleast amount of work, and hence copy of a reference should always just\ncopy the reference resource, and not the target.  Of the two choices,\ncopy the reference or copy the target, copying the reference is the\nleast amount of work for the server.  Mark Day noted while the choices\nin the protocol should surprise the least number of people, it's not\nalways possible to avoid surprising a signifigant part of the\npopulation. We have to be ready to make an arbitrary choice because we\ncan't converge on the easy to use solution.  Larry Masinter then\nproposed that the protocol specification document indicate clearly\nthat copy is complicated, and that users will have different\nexpectations of what copy means.  There was general agreement in the\nroom for the \"do the least amount of work, but document the\ndifficulty\" approach.\n\nLOCK FOR REFERENCES\n\nDiscussion then moved onto LOCK.\n\nIt was noted that returning one 302 response for each reference in a\ncollection of redirect references would cause LOCK to fail (since it\nhas all-or-nothing semantics).  Hence, locking the reference is the\ndesired functionality for redirect references.  Direct references have\ntheir own set of problems.\n\nOne attendee noted that here are four possibile choices when locking a\ndirect reference. Either lock the target, lock the reference, lock\nboth, or lock neither. Neither is out.  Like copy you can make very\nreasonable cases for all, and like copy the choices seem very\narbitrary.  Locking the target makes a lot of sense except that you\ncould move or delete the reference. So if the target is locked and\nsomeone moves or deletes the reference, that might be\nsurprising to the client. Or it might not be. How often do you go and\ntry to move or delete something that someone has locked.\n\nOne person noted that the point of a lock is to protect the contents\nof the persistent state of the resource. Locking the target would at\nleast honor those semantics.  However, another person noted that a\nlock affects both the contents and the namespace, and a lock on a\nreference needs to protect against both namespace operations and\ncontent modification operations.\n\nA proposal was made that a lock on a direct reference should lock the\ntarget, but cause the reference to behave as if it were locked.  That\nis, MOVE and DELETE on the reference would fail if the target were\nlocked.  There was some disucssion on the impact this might have on\nthe No-passthrough header. There was a proposal that if the target of\na reference is locked then operations that are performed without the\nno passthrough header behave as if the reference is also locked.\nHowever if they are supplied with no passthrough then they do not.\nThe particular case is DELETE.  There is also a need to define how\nreferences behave when their target is locked.  Some, but not all\npeople on the room appeared to support this proposal.\n\nIMPACT OF REFERENCES ON URL RESOLUTION\n\nThe crux of this issue is, if you create a reference to a collection,\nare you forcing the server to create references to each member of that\ncollection? The answer of the specification authors is, no you are\nnot, because the server doesn't need all those additional references.\n\nAs an example, suppose there is a direct reference called BLAH to a\ntarget which is a collection called FOO, and FOO contains a member\ncalled BAR.  If a client performs a GET on BLAH/BAR, the specification\nauthors say BLAH/BAR is just an alternate URL, while Yaron Goland\ninsists that, from an HTTP perspective, BLAH is a resource, and so is\nBLAH/BAR.  But is it a direct reference? Are there operations which\ncan be peformed on FOO/BAR that cannot be applied to BLAH/BAR?\n\nFilesystems solve this problem by making both foo and blah pointer\nobjects, and ref-counting bar. UNIX prevents this by barring\nhard-links to a collection.\n\nOne attendee suggested that if BLAH is a direct reference to a\ncollection, it should only support operations on BLAH, not on URLs\nwhich are BLAH/x. However, this approach was considered, and rejected,\nin a authors' group teleconferences because there is an expectation\nthat references support this kind of namespace operation.\n\nLarry Masinter noted that it is bothersome that BLAH/BAR is not a\n*direct* reference, or at least behaves like one. You can discover its\ntarget, so it quacks like a reference. Only operations only on that\nname -- without no-passthrough -- behave in a little different way.\nJudy responded that even before references came along, you could\nalready have multiple URLs for the same resource -- this is the same.\n\nYaron stated that there may not be a problem here. However, this\nnamespace redirection action is sufficiently novel that it deserves to\nbe addressed in the specification more than it currently is.\n\nPROPERTY REGISTRY\n\nJim Whitehead then began discussion on having a registry for WebDAV\nproperties.  The discussion began with a brief overview of WebDAV\nproperties.  Properties are name/value pairs where each name is a URI,\nwhich could be a URL. A nice quality of names being URLs is that if\nyou want to define a new property for your use, then you can create a\nnew property, assign it a URL in a namespace you own, and you can have\na fresh name without running into any namespace collisions.\n\nOne attendee noted that a problem arises when concatenating namespaces\nand element names, beacuse the XML community defined namespaces which\ndon't end in seperators, and hence you can't deconstruct a namespace\nwith an element name appended.  However, other participants noted that\nWebDAV defines rules for concatenating a namespace and an element\nname, and noted that XML namespaces delegates to its users the\ndefinition of the namespace and element relationship.\n\nAlex Hopmann stated that it is useful to have rules on how you take\nthe on the wire names and how you expose those as a single\nidentifier. If you are talking about a property registry where the\nnames is a full URI then you need a rule for how they are separated\ninto a namespace and a property (element) name.\n\nJim Whitehead stated that he would note the issue, and moved on.  The\nvalue of a property is a sequence of well-formed XML. There are cases\nwhen it is desirable to register properties. The property may have wider\nutility than just your client or server, or people will get together\nto create properties that have wider use. You need to register the\nproperty name, the namespace.\n\nOne attendee asked whether it makes sense to register an entire\nnamespace, in order to assert that this is a namespace I am going to\nuse, and I want people to know.\n\nAttendees also noted that it would be good to register whether the\nproperty is live or dead, and that there should be a URL for getting\nmore (human readable) information about the properties.\n\nLarry Masinter stated, in his view, a property registry is almost\nuseless. What people do with properties is they build protocols out of\nthem. Properties rarely have an independent, separable semantics from\nother properties. People define a suite of properties and then\nimplement a protocol that goes along with it. The suite of properties\nmean something together. Registering properties without defining their\nrelationship is like defining a registry of HTTP headers without\ndefining their relationships. Actually... a registry of HTTP headers\nwould be useful, so I take it back, but it is hardly enough to\nunderstand what the HTTP headers are. A registry of XML elements\ndoesn't tell you the semantics of the constructions you build out of\nthem.  Defining a registry by defining the properties alone is\ninsufficient.\n\nLarry continued, stating that you need the whole schema. Dublin core\nkind of goes together. That is why it is a core. If you just took\nauthor out of Dublin Core and didn't take providence or authority,\nthey don't really hold independently without the set.\n\nThere was some discussion over the utility of using a single property\nfrom a schema.  Some participants felt that the author property from\nDublin Core was a good example of a property that should be widely\nreusable.  This discussion highlighted a fundamental difference in\nbelief about property reuse: some participants felt that individual\nproperties could be reused, with other felt that individual properties\ncould not be reused, but sets of properties (schemas) which hang\ntogether could be.\n\nAnother participant asked whether we see any reason why the success or\nusage of this registry should be a different experience from the\nregistries of directory attributes or MIB objects (experience with\nthese registries has been negative).  There was no answer to this.\n\nThere was a brief discussion on the proper forum for registering\nproperties.  Jim Amsden asked, if the document management community\nwants to get together and define properties to contain document life\ncycle information, what is the forum that this group would have to\npublish that schema of properties to share them, agree on them.  There\nwas a suggestion that they publish the schema as an Informational RFC.\nHowever, this was perceived as being too formal, and there was concern\nthat other companies would not find this document in the RFCs listing.\nThe web site www.webdav.org was suggested as the place to go to find\nthese pointers.  Other organizations might also provide an index.\n\nACCESS CONTROL\n\nWith time already expired, there was a brief discussion on how to move\naccess control forward.  Jim Whitehead noted that he has heard that\nthe authors are not able to drive forward with the ACL draft.\n\nThere was a suggestion from the participants that, since there is at\nmost one person at a time who is willing to push forward with this\nstuff, it isn't worth the interest of the IETF.  However, Jim\nW. countered by noting that everytime he meets someone implementing a\nWebDAV server their first criticism is \"where is the access control?\"\nSo the fact that no one is working on it here doesn't indicate that\nthere isn't a problem.\n\nJim Whitehead ended by calling for volunteers to work on the access\ncontrol protocol specification.\n\n*** Meeting Adjourned ***", "encoding": "ascii"}