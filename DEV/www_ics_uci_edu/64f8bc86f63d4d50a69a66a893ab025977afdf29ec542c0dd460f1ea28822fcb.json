{"url": "https://www.ics.uci.edu/~kay/courses/h22/hw/hw8.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Wednesday, March 12, 2003 6:41 AM\">\n<TITLE>Eighth Homework</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"D726EB6E\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 2, CS2, assignment, performance measurement\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"An assignment involving measuring and analyzing the performance of alternative search algorithms for ICS H22, an honors second-quarter course in computer science in Information and Computer Science, UC Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2000, 2003 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"Eighth_Homework_files/Sidebar_123.gif\" WIDTH=575 HEIGHT=77>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4> &#160; <A NAME=\"_14_30\"></A></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>This assignment is due on Wednesday, March\n12.  There&#39;s not much coding here except for the last part, which you\nmay do in pairs.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a) </B>Below is some code that implements\na finite-state machine.<A NAME=\"_14_234\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>final int Secret1 = 35;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>final int Secret2 = 127;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>final int Secret3 = 33;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>String[] stateList = {&quot;Init&quot;,\n&quot;GotFirst&quot;, &quot;GotSecond&quot;, &quot;Success&quot;);</TT></FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>int number;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>int count = 1;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>String state;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>void main()</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>{</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160; state = &quot;Init&quot;;   </TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160; while ((!state.equals(&quot;Success&quot;))\n&amp;&amp; (count &lt;= 3))</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160; {</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   number = getNext();</TT></FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   if (state.equals(&quot;Init&quot;))</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;    {</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;     if (number == Secret1)</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; state = &quot;GotFirst&quot;;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;     else state = &quot;Init&quot;;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;    }</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   else if (state.equals(&quot;GotFirst&quot;))</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;    {</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;     if (number == Secret2)</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; state = &quot;GotSecond&quot;;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;     else state = &quot;Init&quot;;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;    }</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   else if (state.equals(&quot;GotSecond&quot;))</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;    {</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;     if (number == Secret3)</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; state = &quot;Success&quot;;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;     else state = &quot;Init&quot;;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;    }</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   count++;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160; }</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160; </TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>if (state.equals(&quot;Success&quot;))</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   System.out.println(&quot;Input\naccepted.&quot;);</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>else</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;   System.out.println(&quot;Input\nrejected.&quot;);</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=2><TT>}</TT></FONT></P>\n<BR>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.1) </B>Draw the state transition diagram\nthat represents the FSA this program implements.  The input tokens here\nare whole integers, not individual characters.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a.2)</B> Describe in one brief English\nsentence what this FSA does.  Try to think of a simple, real-world, non-computer-related\nobject that this FSA models.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Intermezzo:</B>  State transition diagrams\nare one way to describe FSAs.  Another way (which is easier to represent\nin a computer) is a <B>transition table.</B>  A transition table has a row\nfor each state and a column for each input; the value at each position in\nthe table tells you what state to go to when you read a given input in a\ngiven state.  Below is a transition table for the program above:<A NAME=\"_14_1778\"></A></FONT>\n<TABLE BORDER=1 CELLSPACING=1 WIDTH=100% CELLPADDING=1>\n<COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=17%><COL WIDTH=31%>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Secret1</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Secret2</B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Secret3</B></FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>other</B></FONT><BR></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Init<A NAME=\"_14_1837\"></A></B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>GotFirst</TT></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT><BR></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>GotFirst<A NAME=\"_14_1878\"></A></B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>GotSecond</TT></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT><BR></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>GotSecond<A NAME=\"_14_1921\"></A></B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Success</TT></FONT></TD>\n<TD WIDTH=31% VALIGN=TOP>\n<FONT FACE=\"Courier\"><TT>Init</TT></FONT><BR></TD>\n</TR>\n<TR>\n<TD WIDTH=17% VALIGN=TOP>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Success<A NAME=\"_14_1960\"></A></B></FONT></TD>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=17% VALIGN=TOP>\n&#160;</TD>\n<TD WIDTH=31% VALIGN=TOP>\n<BR></TD>\n</TR>\n</TABLE>\n</P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>This table says just what the program and\nthe state transition diagram say:  If you&#39;re in </FONT><FONT FACE=\"Courier\"><TT>Init</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand you read </FONT><FONT FACE=\"Courier\"><TT>Secret1</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nyou go into state </FONT><FONT FACE=\"Courier\"><TT>GotFirst</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\nif you&#39;re in state </FONT><FONT FACE=\"Courier\"><TT>Init</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand you read anything else, you stay in </FONT><FONT FACE=\"Courier\"><TT>Init</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n If you&#39;re in state </FONT><FONT FACE=\"Courier\"><TT>GotFirst</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand you read </FONT><FONT FACE=\"Courier\"><TT>Secret2</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nyou go into state </FONT><FONT FACE=\"Courier\"><TT>GotSecond</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\nif you read anything else in state </FONT><FONT FACE=\"Courier\"><TT>GotFirst</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nyou go to state </FONT><FONT FACE=\"Courier\"><TT>Init</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n And finally, if you&#39;re in state </FONT><FONT FACE=\"Courier\"><TT>GotSecond</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand you read </FONT><FONT FACE=\"Courier\"><TT>Secret3</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nyou go to state </FONT><FONT FACE=\"Courier\" SIZE=2><TT>Success</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>;\notherwise, you go to </FONT><FONT FACE=\"Courier\"><TT>Init</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n In state </FONT><FONT FACE=\"Courier\"><TT>Success</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>\nthe machine stops, so you don&#39;t make any transitions out of that state;\nit&#39;s the accept state.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>As we noted, transition tables make FSAs easy\nto represent in a computer.  In fact, we can write a very simple but very\ngeneral FSA simulator according to the following pseudocode:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>initialize TransitionTable;\n<BR>\nstate </FONT><FONT FACE=\"Symbol\" SIZE=4><IMG SRC=\"Eighth_Homework_files/Symbol14_AC.gif\" WIDTH=17 HEIGHT=15 DESCENT=3 ALIGN=\"absbottom\" ALT=\"&#168;\"></FONT><FONT FACE=\"AGaramond\" SIZE=4>\ninitial state;\n<BR>\nwhile there are more tokens:\n<BR>\n&#160;&#160;  &#160; get a token;\n<BR>\n&#160;&#160;  &#160; state </FONT><FONT FACE=\"Symbol\" SIZE=4><IMG SRC=\"Eighth_Homework_files/Symbol14_AC.gif\" WIDTH=17 HEIGHT=15 DESCENT=3 ALIGN=\"absbottom\" ALT=\"&#168;\">\n</FONT><FONT FACE=\"AGaramond\" SIZE=4>TransitionTable[state][token];\n<BR>\nif state = accept state\n<BR>\n&#160;&#160;  &#160; then accept\n<BR>\n&#160;&#160;  &#160; else reject.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Because this code is so simple, it&#39;s the\npreferred way to implement FSAs in programs.  The only tricky part is finding\na data type that will represent the range of tokens and will at the same\ntime be acceptable as an array index in your programming language.  Scheme,\nfor example, handles symbolic names very easily.  But in the above Java\ncode, you can&#39;t have an array with four columns labeled 35, 127, 33,\nand &#39;other&#39;.  The cleanest way to deal with this is to have a routine\nthat would translate each token (or category of tokens) to its corresponding\ncolumn in the transition table--effectively a switch statement or sequence\nof if-statements that map the tokens (or token categories) to the range\n0..3.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Think about the task of extracting\nwords from a stream of text.  In Java, StringTokenizer does this for you,\nbut sometimes you need to specify &quot;words&quot; idiosyncratically (as\nwith the DVD information).  You can do this kind of input-parsing task much\nmore easily using state machines than by writing code directly.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.1)</B>  Draw a state transition diagram\nthat accepts words defined as follows:  a sequence of non-separator characters\nwhose end is marked by a separator.  Separators are symbols that separate\nEnglish words--space, comma, semicolon, colon, and so on.  Note that the\nhyphen (-), the apostrophe (&#39;), and the percent sign (%) are not separators:\n treat &quot;mother-in-law,&quot; &quot;don&#39;t,&quot; and &quot;23%&quot;\nas single words.   The end of the line is a separator, unless the last word\nof the line ends with a hyphen.  That way, if a word like mother-in-law\nis hyphenated across two lines, it will still count as one word.  (We will\nassume that in our input, only words that are always hyphenated will be\nhyphenated at the end of a line; that is, you should not expect normally-unhyphenated\nwords to be broken across two lines.)  Watch for multiple separators in\na row--for example, a comma followed by a space is two separators, but there\nis no word between them.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You could code up this FSA into a method called\n<A NAME=\"_14_5045\"></A></FONT><FONT FACE=\"Courier\"><TT>getNextWord</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nand call it to parse a stream of input.  Coding this isn&#39;t a required\npart of this assignment, though.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b.2)</B>  Write a transition table for\nthe state machine you drew in part <B>(b.1)</B>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)</B>  Now it&#39;s time to think about\nfinite-state machines and the DVD information fields defined in the Sixth\nHomework.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.1)</B>  Draw a state transition diagram\nthat accepts DVD information.  You should design your machine to accept\na single field--maybe a quoted string, maybe an integer, maybe a date--and\nto go back to the initial state when it encounters a comma (that isn&#39;t\nquoted, of course).  This makes processing quite simple so long as you&#39;re\nwilling to forego checking which field is of which type, or that you have\nthe correct number of fields.  (In coding, you could easily add actions\nfor some transitions that would maintain a field count.  It might also help\nto assume that there&#39;s an input token or character called EOS, for &quot;end\nof string,&quot; that your character-reading routine would return and that\nyour machine could check for.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.2)</B>  For extra credit, recode your\nDVD-parsing program to implement the FSA you designed above.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(d)</B>  (This part is optional, but don&#39;t\nstop here; subsequent parts of this homework are required.)  Available on\nthe web is a program called JFLAP, written at Duke University (</FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www.cs.duke.edu/~rodger/tools/jflaptmp/\">http://www.cs.duke.edu/~rodger/tools/jflaptmp/</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>).\n You can download this Java application and use it to build and test your\nown simple FSAs (as well as do other formal-language activities).  Other\nstate machine simulators are available on the web; you can find some of\nthem by using search strings like &quot;state machine applet&quot; or &quot;FSA\nanimation.&quot;  If you&#39;d like to work on building or enhancing tools\nlike these (especially to allow graphical construction of useful FSAs with\nregular expressions as the transitions), come talk to me some time.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e)</B>  The programming language Lisp\n(whose name is a contraction of the words &quot;LISt Processing&quot;) was\ninvented by John McCarthy in 1958.  It was such an advanced language for\nits time that existing machines could not run it efficiently, and its early\nuse was mostly limited to researchers in artificial intelligence.  Today,\nhowever, computers are thousands of times faster than they were in the 1950s,\nand Lisp&#39;s power is practical for a very wide range of programming tasks.\n Scheme and Common Lisp are two modern members of the Lisp family of programming\nlanguages.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>One of Scheme&#39;s attractions is that its\nsyntax is very simple.  Unlike Java, which has a few dozen different statements,\neach with its own grammar and punctuation rules, every program or expression\nin Scheme is just a list of words surrounded by parentheses.  This provides\na rich variety of expression because a &quot;word&quot; can be (a) any sequence\nof characters delimited (separated from other words) by white space, or\n(b) a parenthesized list of words nested within the outside list.  The following\nare all valid Scheme expressions (each is one line long except the last,\nwhich starts with the word <A NAME=\"_14_8087\"></A></FONT><FONT FACE=\"Courier\"><TT>define</TT></FONT><FONT FACE=\"AGaramond\" SIZE=4>):<A NAME=\"_14_8103\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>(Fee fie fo fum)\n<BR>\n(+ 3.14159 1776 -45 quantity)\n<BR>\n(equal? (+ 2 2) (+ 3 1))\n<BR>\n(define square\n<BR>\n&#160;&#160; (lambda (x)\n<BR>\n&#160;&#160;  &#160; (* x x)))</TT></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Novice Scheme programmers sometimes worry\nabout keeping all the parentheses balanced, but most Scheme systems have\n&quot;syntax-based&quot; text editors that automatically keep track of the\nparentheses, so that any time you type a right parenthesis it automatically\nflashes the left parenthesis that matches it.  That way you can see effortlessly\nwhat matches what.  (This idea has found its way into some program editors\nfor Java and other languages, where it&#39;s also useful.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Suppose you decide to write a syntax-based\neditor for Scheme, and as your first task you want to write some code that\nchecks whether the parentheses are balanced in a Scheme expression.  Astutely,\nyou start by designing a FSA.  To make it truly a <I>finite-</I>state machine,\nwe have to put an upper limit on the depth to which parentheses can be nested;\nthe example below shows the FSA for an upper limit of three-deep nesting.\n(In the diagram, &quot;other&quot; means an input symbol other than an open\nor close parenthesis.)</FONT></P>\n<BR>\n<P>\n<IMG SRC=\"Eighth_Homework_files/Picture_261.gif\" WIDTH=429 HEIGHT=144 ALT=\"\">\n</P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e.1) </B>After scanning the entire Scheme\nexpression, in what state should your machine be if the parentheses were\ncorrectly balanced?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e.2) </B>This FSA works fine in theory,\nbut for a realistic nesting depth of a few dozen, the diagram would be tediously\nrepetitious.  So you decide to simplify things and encapsulate the state\ninformation in a simple integer counter.  Then you can have a single state\non the page, and all the action happens in the transition steps, where you\nincrement the counter for each left parenthesis and decrement it for each\nright parenthesis.  (Having a variable may appear to violate the definition\nof a finite-state machine, all of whose information is encapsulated in a\nfinite number of states.  But since integer variables on computers (as opposed\nto integers in mathematics) always have a finite upper bound, we&#39;re\ntechnically safe.  If our machine used a stack to keep track of the unbalanced\nparentheses (which is what our integer counter is modeling), it would no\nlonger be an FSA--it would be a PDA (push-down automaton), which can accept\na broader class of languages.)  </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>The modified (augmented) machine appears below.</FONT></P>\n<BR>\n<P>\n<CENTER>\n<IMG SRC=\"Eighth_Homework_files/Sidebar_250.gif\" WIDTH=530 HEIGHT=304 HSPACE=6 VSPACE=6>\n</CENTER>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4>In the augmented machine, being in the stop\nstate is not enough to know that the Scheme program has balanced parentheses;\nthe value of the counter must be considered as well. What should the counter&#39;s\nvalue be if the machine accepts the Scheme source (that is, if the parentheses\nare correctly balanced)? What must have happened for the machine to end\nup in the error state?</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e.3) </B> Things are never quite as simple\nas they first seem.  Comments in Scheme programs start with a semicolon\nand extend to the end of the line.  Thus, the following is a valid Scheme\nexpression; everything to the right of the semicolon on each line is a comment.\n Of course the contents of comments are ignored when checking for balanced\nparentheses.<A NAME=\"_14_11113\"></A></FONT></P>\n<P>\n<FONT SIZE=1>&#160;&#160; <A NAME=\"_14_11118\"></A>\n<BR>\n</FONT><FONT FACE=\"Courier\"><TT>&#160;&#160; (define print-it    ;In this\nroutine we\n<BR>\n&#160;&#160;    (lambda (p) &#160;    ; a) accept a parameter,\n<BR>\n&#160;&#160;       (display p)   ; b) display it, and\n<BR>\n&#160;&#160;       (newline)))   ; c) hit carriage return</TT></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Draw a new FSA-like machine, similar to the\none above, to account for comments correctly; you will have to add more\nstates.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e.4)</B>  And there&#39;s one more wrinkle.\n Literal character strings in Scheme are enclosed in double-quote marks.\n As in Java, the contents of literal strings are ignored when analyzing\nthe syntax of the program.  The following three expressions are valid in\nScheme.<A NAME=\"_14_11694\"></A></FONT></P>\n<P>\n<FONT FACE=\"Courier\"><TT>(display &quot;Oh; really?&quot;)\n<BR>\n(list  &quot;a)&quot;  &quot;b)&quot;  &quot;c)&quot; )\n<BR>\n(let ((delims &quot;.,;:)((&quot;))) ; This has an extra '(' in quotes</TT></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Draw a new FSA-like machine to handle both\nstrings and comments correctly.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e.5)</B>  Write a transition table for\nthe state machine you designed in part <B>(e.4)</B>.  Note that some of\nthe transitions in some conditions will also increment or decrement the\ncount of parentheses.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(e.6)</B>  Test your FSA from part <B>(e.4)\n </B>thoroughly on paper--devise a thorough test plan and work each test\nthrough your FSA.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(f)</B>  A grammar is a set of rules that\ncan generate all the strings in a formal language.  In the right form, a\ngrammar for a programming language can be used with other software to produce\n<I>automatically</I> part of a compiler for that language.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Below is a grammar (in Backus-Naur Form, or\nBNF notation) that describes arithmetic expressions:</FONT></P>\n<P>\n<FONT FACE=\"Palatino\">&lt;expression&gt; ::=  &#160; &lt;real&gt; | &lt;variable&gt;\n| </FONT><FONT FACE=\"Courier\"><TT><B>(</B></TT></FONT><FONT FACE=\"Palatino\">\n&lt;expression&gt; </FONT><FONT FACE=\"Courier\"><TT><B>)</B></TT></FONT><FONT FACE=\"Palatino\">\n|\n<BR>\n&#160;&#160;  &lt;expression&gt; &lt;operator&gt; &lt;expression&gt; |\n<BR>\n&#160;&#160; </FONT><FONT FACE=\"Courier\"><TT><B>(</B></TT></FONT><FONT FACE=\"Palatino\">\n&lt;variable&gt;  </FONT><FONT FACE=\"Courier\"><TT><B>=</B></TT></FONT><FONT FACE=\"Palatino\">\n &lt;expression&gt; </FONT><FONT FACE=\"Courier\"><TT><B>)\n<BR>\n</B></TT></FONT><FONT FACE=\"Palatino\">&lt;real&gt; ::=  &#160; &lt;positive-real&gt;\n | </FONT><FONT FACE=\"Courier\"><TT><B>-</B></TT></FONT><FONT FACE=\"Palatino\">\n &lt;positive-real&gt;\n<BR>\n&lt;positive-real&gt; ::=  &#160; &lt;integer-part&gt;  | &lt;integer-part&gt;\n</FONT><FONT FACE=\"Courier\" SIZE=4><TT><B>.</B></TT></FONT><FONT FACE=\"Palatino\">\n&lt;integer-part&gt; \n<BR>\n&lt;integer-part&gt; ::=  &#160; &lt;digit&gt; | &lt;digit&gt; &lt;integer-part&gt;\n<BR>\n&lt;variable&gt; ::=  &#160; &lt;letter&gt;\n<BR>\n&lt;digit&gt; ::= </FONT><FONT FACE=\"Courier\"><TT> &#160; 0</TT></FONT><FONT FACE=\"Palatino\">\n| </FONT><FONT FACE=\"Courier\"><TT>1</TT></FONT><FONT FACE=\"Palatino\"> |\n</FONT><FONT FACE=\"Courier\"><TT>2</TT></FONT><FONT FACE=\"Palatino\"> | </FONT><FONT FACE=\"Courier\"><TT>3</TT></FONT><FONT FACE=\"Palatino\">\n| </FONT><FONT FACE=\"Courier\"><TT>4</TT></FONT><FONT FACE=\"Palatino\"> |\n</FONT><FONT FACE=\"Courier\"><TT>5</TT></FONT><FONT FACE=\"Palatino\"> | </FONT><FONT FACE=\"Courier\"><TT>6</TT></FONT><FONT FACE=\"Palatino\">\n| </FONT><FONT FACE=\"Courier\"><TT>7</TT></FONT><FONT FACE=\"Palatino\"> |\n</FONT><FONT FACE=\"Courier\"><TT>8</TT></FONT><FONT FACE=\"Palatino\"> | </FONT><FONT FACE=\"Courier\"><TT>9\n<BR>\n</TT></FONT><FONT FACE=\"Palatino\">&lt;letter&gt; ::=<FONT SIZE=2>     &#160;\n</FONT><FONT FACE=\"Courier\"><TT>a | b | c | d | e | f | g | h | i | j |\nk | l | m |\n<BR>\n&#160;&#160; n | o | p | q | r | s | t | u | v | w | x | y | z \n<BR>\n</TT></FONT><FONT FACE=\"Palatino\">&lt;operator&gt; ::= </FONT><FONT FACE=\"Courier\"><TT>\n&#160; +</TT></FONT><FONT FACE=\"Palatino\"> | </FONT><FONT FACE=\"Courier\"><TT>-</TT></FONT><FONT FACE=\"Palatino\">\n| </FONT><FONT FACE=\"Courier\"><TT>*</TT></FONT><FONT FACE=\"Palatino\"> |\n</FONT><FONT FACE=\"Courier\"><TT>/ | %</TT></FONT></P>\n<BR>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(f.1)</B>  Some of the following expressions\ncan be generated by this grammar; others can not.  Indicate which are the\nvalid expressions.  (The easiest way to do this might be to photocopy the\npage, or print it from the on-line version, and circle the valid expressions.)</FONT></P>\n<P>\n<CENTER>\n<IMG SRC=\"Eighth_Homework_files/Sidebar_225.gif\" WIDTH=546 HEIGHT=162 HSPACE=6 VSPACE=6 ALT=\"3\">\n</CENTER>\n</P>\n<BR><BR><BR><BR>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(f.2)</B>  Using the grammar, generate\nfour more expressions that aren&#39;t on the above list.  Each expression\nshould involve applying at least ten rules.  For each expression, show its\nderivation tree (with &lt;expression&gt; at the root and terminal symbols--i.e.,\nwithout angle brackets--at the leaves).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(f.3)</B>  Give three arithmetic expressions\nthat are syntactically valid in Java but are not generated by this grammar.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(f.4)</B>  Modify the grammar to allow\nmulti-letter variable names.  This requires changing only one of the existing\nrules.<A NAME=\"_14_14005\"></A></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(g)</B>  Write regular expressions to match\neach of the following patterns.  Note that these are natural language descriptions,\nso they will certainly be ambiguous; disambiguate them as you see fit and\nnote what decisions you made.  In some cases you may not be able to match\nthe described set perfectly; don&#39;t obsess over it.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>*  Comma-separated dollars-and-cents amounts\n(e.g., $1,234.56 and $17)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>*  Lines that are empty or all blanks.  (The\ncaret (&quot;</FONT><FONT FACE=\"Courier New\" SIZE=4>^</FONT><FONT FACE=\"AGaramond\" SIZE=4>&quot;)\nmatches the start of a line and the dollar sign matches the end of the line.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>*  Email addresses</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>*  URLs in HTML anchor tags (e.g., </FONT><FONT FACE=\"Courier New\" SIZE=4>&lt;A\nhref=&quot;http://www.ics.uci.edu/~kay&quot;&gt;</FONT><FONT FACE=\"AGaramond\" SIZE=4>)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>*  Lines containing exactly one integer (perhaps\nsurrounded by non-numeric characters)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h) </B>Write a program that generates\nrandom sentences according to a user-supplied grammar, as specified below.\n The final product doesn&#39;t require a lot of code, but it does require\ncareful, thoughtful design in advance.  You may do this assignment in pairs.\n Each member of a pair should turn in the (identical) program via Checkmate;\neach source code file should have a comment at the top that says something\nlike &quot;</FONT><FONT FACE=\"Courier New\">// Joint work of Carl Coder and\nPetra Programmer.</FONT><FONT FACE=\"AGaramond\" SIZE=4>&quot;</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.1)</B>  Get an idea of what this assignment\ncan do by trying out the applet at </FONT><FONT FACE=\"Courier New\"><A HREF=\"http://www-cs-faculty.stanford.edu/~zelenski/rsg/\">http://www-cs-faculty.stanford.edu/~zelenski/rsg/</A></FONT><FONT FACE=\"AGaramond\" SIZE=4>\n.  The &quot;Extension Request&quot; grammar (the default) is pretty funny;\nalso try out &quot;CS assignment,&quot; &quot;Programming bug,&quot; and\n&quot;Math expression,&quot; along with any others that strike your fancy.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.2)</B>  Follow the &quot;Directory of\nthe collected grammar files&quot; link at the bottom of the page.  Pick\ngrammars that you chose in part <B>(h.1)</B> (&quot;Math expression&quot;\nis the easiest to follow) and look at them to get an idea of your program&#39;s\ninput.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>A grammar file for input to your program contains\none or more rules of the following form:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>-- Each rule starts with a left brace &quot;{&quot;\non its own line and ends with a right brace &quot;}&quot; on its own line.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>-- After the opening brace, the first line\nof the rule is its left-hand side; this non-terminal is a string delimited\nby angle brackets.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>-- Subsequent lines of the rule are alternative\nproductions, different ways of rewriting the left-hand side.  Each production\nconsists of non-terminals (enclosed in angle brackets) and terminals (other\ncharacters) in any combination, ending with a semicolon.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>-- There may be lines of text outside of the\nbraces that delimit the rules; those lines are ignored by the program (and\nthus can serve as comments in the grammar).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You may assume that the grammar files take\nthis form; you do not have to check for errors. </FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.3)</B>  Write code to read grammar files\nand store the grammars.  Use a symbol table (either a hash table or a BST)\nkeyed on the non-terminals; the value of each entry in the table contains\nthe non-terminal&#39;s alternative productions.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.4)</B>  Now, write code to generate\nsentences from the grammar.  Each grammar contains one non-terminal symbol\nnamed </FONT><FONT FACE=\"Courier New\">&lt;start&gt;</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich (obviously enough) is the start symbol for each derivation.  As your\nprogram expands each non-terminal, it chooses at random one of the non-terminal&#39;s\nalternative productions, and so on recursively until every non-terminal\nis expanded.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You may assume that every non-terminal in\nthe grammar will appear on the left side of exactly one rule; you do not\nhave to check for undefined or multiply-defined non-terminals (though for\na bit of extra credit you may check for and handle those issues and a missing\nstart symbol).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Your output should include a hierarchical\ndescription of the derivation process as well as the final sentence, as\nshown in the following example.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Here is a simple grammar:</FONT></P>\n<BR>\n<P>\n<CENTER>\n<IMG SRC=\"Eighth_Homework_files/Sidebar_207.gif\" WIDTH=537 HEIGHT=145 HSPACE=6 VSPACE=6 ALT=\"{\">\n</CENTER>\n</P>\n<BR>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Here is the output, showing the final generated\nsentence at the bottom.  The first level of indentation shows the first\nproduction taken (</FONT><FONT FACE=\"Courier New\">This&#160;&lt;Y&gt;&#160;!</FONT><FONT FACE=\"AGaramond\" SIZE=4>),\nthe second level shows the expansion of </FONT><FONT FACE=\"Courier New\">&lt;Y&gt;</FONT><FONT FACE=\"AGaramond\" SIZE=4>\n(</FONT><FONT FACE=\"Courier New\">&lt;Z&gt;&#160;cool</FONT><FONT FACE=\"AGaramond\" SIZE=4>),\nand so on.<A NAME=\"_14_17927\"></A></FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&lt;start&gt;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&#160;&#160;&#160;This</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&#160;&#160;&#160;&lt;Y&gt;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&#160;&#160;&#160;&#160;&#160;&#160;&lt;Z&gt;</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is\nreally</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&#160;&#160;&#160;&#160;&#160;&#160;cool</TT></FONT></P>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>&#160;&#160;&#160;!</TT></FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Courier\" SIZE=4><TT>This is really cool !</TT></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.5)</B>  Design and build an interface.\n The simplest would be a console interface that prompts the user for the\nname of a grammar file and then generates a sentence from that grammar.\n Enhancements could include letting the user request new sentences repeatedly\nor specify a new grammar file.  Building an applet or GUI application is\nanother alternative.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.6)</B>  Make up a grammar for (a tiny\nsubset of) Java and see what kinds of programs it generates.  (You could\ncopy your random program output into a Java environment like DrJava, not\nto run it but to get it automatically formatted to make it readable.)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.7)</B>  Make up at least one other grammar\nof your choice and generate some sentences with it.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(h.8)</B>  On the last day of class, bring\na printed copy of your best, cleverest, or funniest grammar and some of\nthe sentences it generates; we can share them (anonymously if you like).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(i)</B>  The GUI you may have built as\nextra credit suggested by the Sixth Homework is due at the same time this\nassignment is due.<A NAME=\"_14_19049\"></A><B> </B></FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>What to turn in:</B>  For parts <B>(a)</B>\nthrough <B>(g)</B>, which involve so many diagrams and tables, you will\nprobably find it easiest to produce and submit your work on paper (clearly\nmarked with your name, of course) and turn it in during section.  Checkmate\nwill accept a Word document for those parts, but please use Checkmate for\nthose parts only if everything, including all the diagrams, is included\nin the electronic copy.  Of course you may use Word to produce a printed\ncopy onto which you draw some of your answers by hand, but we need everything\nin one place, not split between Checkmate and paper.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>For part <B>(h)</B>, turn in via Checkmate\nyour Java code, your grammar for (partial) Java, and the other grammars\nyou designed.</FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Helvetica\" SIZE=1>FSA exercises written by David G. Kay, Winter\n1991 (based on materials from 1990 and earlier).\n<BR>\nRevised by Joe Hummel, Norman Jacobson, Theresa Millette, Brian Pitterle,\nAlex Thornton, Rasheed Baqai, Li-Wei (Gary) Chen, and David G. Kay, 1992-1999\n<BR>\nRevised to include BNF grammars by David G. Kay, Spring 1999. \n<BR>\nRevised and consolidated by David G. Kay, Winter 2000; revised to add DVD\ninformation, Winter 2003.</FONT></P>\n<P>\n<FONT FACE=\"Helvetica\" SIZE=1>Random sentence generator original concept\nby Mike Cleron of Stanford University; modified by Allison Hansen, Julie\nZelenski, and others.\n<BR>\nRevised and adapted by David G. Kay, Winter 2000 and Winter 2003.</FONT></P>\n<BR>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}