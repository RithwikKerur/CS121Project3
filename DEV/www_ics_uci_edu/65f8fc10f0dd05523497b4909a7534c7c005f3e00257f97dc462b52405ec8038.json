{"url": "https://www.ics.uci.edu/~thornton/cs141/CodeExamples/HaskellExamples3.hs", "content": "-- HaskellExamples3.hs\r\n--\r\n-- CompSci 141 / CSE 141 / Informatics 101 Spring 2013\r\n-- Code Example\r\n--\r\n-- This module explores a couple of issues that we discussed in the third\r\n-- lecture on Haskell, including operations on functions such as the \".\"\r\n-- operator (function composition) and why infinite recursion works fine\r\n-- in Haskell.\r\n\r\nmodule HaskellExamples3 where\r\n\r\n\r\n-- To get things off the ground, let's start with a couple of utility functions,\r\n-- one that squares a number and another that doubles a number.  The type\r\n-- signatures of these functions both contain type variables (i.e., they're\r\n-- generic), but also include constraints on those type variables.  The\r\n-- signature \"Num a => a -> a\" indicates a function that takes some kind of\r\n-- argument and returns the same kind of argument, but one that can only be\r\n-- applied to types that are in the \"typeclass Num\", which means that they're\r\n-- numeric (which means, for example, that they can be added, multiplied,\r\n-- compared for ordering, etc.).\r\n\r\nsquare :: Num a => a -> a\r\nsquare n = n * n\r\n\r\n\r\ndouble :: Num a => a -> a\r\ndouble n = n * 2\r\n\r\n\r\n-- Previously, we've seen that you can write functions by defining a sequence of\r\n-- equations, each specifying what the function's result is, given patterns that\r\n-- describe its arguments.  So, for example, you might write a function that\r\n-- squares all of the elements of a list this way, using primitive recursion.\r\n\r\nsquareAll :: Num a => [a] -> [a]\r\nsquareAll []      = []\r\nsquareAll (n:ns)  = (n * n) : squareAll ns\r\n\r\n\r\n-- You might also use a higher-order function that encapsulates the same pattern\r\n-- of recursion, so you don't have to write it yourself.  A problem where you're\r\n-- transforming every element of a list -- so the result is the transformed\r\n-- version of each element of the original list -- is one that is best solved\r\n-- using \"map\".\r\n\r\nsquareAll2 :: Num a => [a] -> [a]\r\nsquareAll2 ns = map square ns\r\n\r\n-- This implementation is fairly direct: \"To square all the elements in a list\r\n-- 'ns', map the function square across the list 'ns'.\"  If you've written\r\n-- programs in languages like Java, C++, or Python before, the idea that you\r\n-- write functions by specifying names for the parameters doesn't seem alien;\r\n-- it's exactly what you do in those languages, too.\r\n--\r\n-- But there's another way to write functions in Haskell, too, one that embraces\r\n-- the idea that functions are \"first-class\" (i.e., they're data, just like\r\n-- integers and lists and characters are).  They're not special like they are\r\n-- in a lot of programming languages; they're just another kind of value that\r\n-- you can pass as a parameter, return as a result, or give a name to.\r\n--\r\n-- We've seen previously that Haskell allows you to define constants like this:\r\n\r\nminimumVotingAge :: Integer\r\nminimumVotingAge = 18\r\n\r\n\r\n-- You can also use that same technique to define functions.\r\n\r\nsquareAll3 :: Num a => [a] -> [a]\r\nsquareAll3 = map square\r\n\r\n-- This may not look like a function, because it's defined with an equation\r\n-- that doesn't specify any arguments, but if you break it down, you'll see\r\n-- that it actually is a function:\r\n--\r\n-- * squareAll3 is a constant.  We know this because it's being defined by\r\n--   an equation that has no arguments listed.  Constant values can have\r\n--   any type, including functions.\r\n-- * The type of squareAll3 is listed as \"A function that takes a list of\r\n--   integers and returns a list of integers.\"\r\n-- * \"map\" is a function that takes two arguments, a function and a list,\r\n--   and applies the function to every element of the list, returning a list\r\n--   of the results.\r\n-- * You can give \"map\" only one argument instead of two, because all\r\n--   multi-argument functions in Haskell can be partially applied.  If you\r\n--   supply only the first argument to a function expecting to arguments,\r\n--   you get back a function that takes only the second argument and then\r\n--   completes the task.\r\n-- * So \"map square\" returns a function that applies the function \"square\"\r\n--   to every element of a list.  The list can contain any type of element\r\n--   that \"square\" can take as a result, and will return a list containing\r\n--   whatever type of element \"square\" would return in that case.  \"square\"\r\n--   can take any kind of numeric type as its input, in which case it will\r\n--   give you the same type of output.  So, ultimately, the type of\r\n--   \"map square\" is \"Num a => [a] -> [a]\".\r\n\r\n\r\n-- Okay, so what if we want to take a list of numbers and transform every\r\n-- element by squaring it and *then* doubling it?  So, for example, the\r\n-- element 3 would be transformed to 18 (because squaring 3 gives 9, and\r\n-- doubling that gives 18).  We could certainly solve the problem by writing\r\n-- an equation that lists an argument and passes it to \"map\" explicitly.\r\n\r\nsquareAndThenDoubleAll :: Num a => [a] -> [a]\r\nsquareAndThenDoubleAll ns = map double (map square ns)\r\n\r\n\r\n-- But there is an alternative approach, one that continues embracing the\r\n-- idea that functions are first-class values.  Just like integers, functions\r\n-- can be passed to other functions as arguments.  In fact, just like integers,\r\n-- there are even operators that you can use on functions.  One such operator\r\n-- is the \".\" operator, which specifies \"function composition.\"  As in algebra,\r\n-- composing two functions means to generate a new function that takes input,\r\n-- passes it to one of the functions, then takes the output and passes it as\r\n-- input to another, with the overall output being the output of the latter\r\n-- function.  g(f(n)) in algebra works that way (n is passed to f, f's result\r\n-- is passed to g, g's result is the overall result).\r\n--\r\n-- Haskell functions can be composed this way.\r\n\r\nsquareAndThenDoubleAll2 :: Num a => [a] -> [a]\r\nsquareAndThenDoubleAll2 = map double . map square\r\n\r\n-- If we work through that, we can see what's going on.\r\n--\r\n-- * \"map square\", as we've seen, is a function that takes a list of numbers\r\n--   and squares them, returning a list of their squares.\r\n-- * Similarly, \"map double\" is a function that takes a list of numbers and\r\n--   doubles them, returning a list of their doubles.\r\n-- * Composing these functions with \".\" means to build a new function that\r\n--   does this:\r\n--    - Takes its input and passes it to the function on the right.\r\n--    - Takes the output of that function and passes it as input to the\r\n--      function on the left.\r\n--    - Returns the output of the function on the left.\r\n--   So, in this case, if we compose \"map double\" and \"map square\", we get\r\n--   a function that:\r\n--    - Takes a list of numbers and squares them.  (That's the \"map square\"\r\n--      part.)\r\n--    - Takes the resulting list of numbers and doubles them.  (That's the\r\n--      \"map double\" part.)\r\n--    - Returns the resulting list.\r\n\r\n\r\n-- Note, too, that we can use function composition differently to solve this\r\n-- same problem.  Instead of using two separate calls to \"map\", we could\r\n-- instead compose \"double\" and \"square\", which gives a function that squares\r\n-- and then doubles one number, and pass that to \"map\".\r\n\r\nsquareAndThenDoubleAll3 :: Num a => [a] -> [a]\r\nsquareAndThenDoubleAll3 = map (double . square)\r\n\r\n\r\n\r\n\r\n-- One other feature that sets Haskell apart from many programming languages is\r\n-- its insistence on lazy evaluation as a default.  In short, this means that\r\n-- Haskell doesn't evaluate an expression until its result is needed.  It\r\n-- doesn't evaluate any *part* of an expression until that part is needed in\r\n-- order to calculate a result.  While that may seem like a strange default, it\r\n-- leads to the ability to make some interesting design choices that seem\r\n-- nonsensical when you think of them from the point of view of languages like\r\n-- Java, which evaluate expressions eagerly.\r\n--\r\n-- As a first example, consider this constant definition of an infinitely-long\r\n-- list of 1's.\r\n\r\nones :: [Integer]\r\nones = 1 : ones\r\n\r\n-- What is ones?  It's a list whose first element is 1 and whose remaining\r\n-- elements are ... more ones!  How many more ones?  Infinitely many ones!\r\n--\r\n-- Of course, if you evaluate the expression \"ones\" in the interpreter, you\r\n-- get an answer that never stops until you interrupt it.\r\n--\r\n--   HaskellExamples3> ones\r\n--   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...\r\n--\r\n-- But that doesn't make \"ones\" useless.  It just means you have to use it\r\n-- carefully.  What makes \"ones\" generate an infinite list of 1's is when you\r\n-- *ask* it to generate one.  But if you only ask it to generate a finite number\r\n-- of 1's, that's exactly what you'll get.  Thanks to lazy evaluation, you'll\r\n-- only get back as many 1's as you ask for.\r\n--\r\n--   HaskellExamples3> head ones\r\n--   1\r\n--   HaskellExamples3> take 5 ones\r\n--   [1,1,1,1,1]\r\n\r\n\r\n-- You can also write functions that recurse infinitely, like this one that\r\n-- generates a never-ending sequence of the same element.  (I've named it\r\n-- \"repeat2\" because there is a \"repeat\" function in Haskell's standard\r\n-- library.)\r\n\r\nrepeat2 :: a -> [a]\r\nrepeat2 x = x : repeat2 x\r\n\r\n-- How we read that function is like this:\r\n--\r\n-- * repeat2 takes a value of some type and returns a list of values of the\r\n--   same type.  Given a value, it returns that value, followed by a repeated\r\n--   list of that same value.\r\n--\r\n-- This function is clearly recursive, as part of what it does is to call\r\n-- itself.  Oddly, though, it has no base case; it just seems to go on\r\n-- forever.  What stops the insanity, though, is lazy evaluation; it will\r\n-- only actually go as far as you ask it to.\r\n--\r\n--   HaskellExamples3> take 10 (repeat2 5)\r\n--   [5,5,5,5,5,5,5,5,5,5]\r\n--   HaskellExamples3> zip (repeat2 10) [\"A\", \"B\", \"C\"]\r\n--   [(10,\"A\"),(10,\"B\"),(10,\"C\")]\r\n--\r\n-- Why that can be handy is that it allows you to write simple definitions,\r\n-- like an ascending sequence of integers, without thinking in terms of base\r\n-- cases and boundaries; boundaries are established by how you use a function\r\n-- like this, not by the function itself.\r\n", "encoding": "ascii"}