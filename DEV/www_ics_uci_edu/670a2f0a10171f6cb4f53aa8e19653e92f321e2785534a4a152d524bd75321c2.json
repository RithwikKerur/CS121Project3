{"url": "https://www.ics.uci.edu/~ejw/versioning/arch/0066.html", "content": "<!-- received=\"Sun Jun 09 15:44:00 1996 PDT\" -->\n<!-- sent=\"Sun, 9 Jun 1996 15:43:38 PDT\" -->\n<!-- name=\"Larry Masinter\" -->\n<!-- email=\"masinter@parc.xerox.com\" -->\n<!-- subject=\"Re: what's doable in Web version control\" -->\n<!-- id=\"ade2642e48021004c54e@[128.195.21.209]\" -->\n<!-- inreplyto=\"what's doable in Web version control\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Re: what's doable in Web version control</title>\n<h1>Re: what's doable in Web version control</h1>\n<b>Larry Masinter</b> (<a href=\"mailto:masinter@parc.xerox.com\"><i>masinter@parc.xerox.com</i></a>)<br>\n<i>Sun, 9 Jun 1996 15:43:38 PDT</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#66\">[ date ]</a><a href=\"thread.html#66\">[ thread ]</a><a href=\"subject.html#66\">[ subject ]</a><a href=\"author.html#66\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0067.html\">David J. Fiander: \"First cut at Functional Requirements document\"</a>\n<li> <b>Previous message:</b> <a href=\"0065.html\">Daniel W. Connolly: \"Re: version management and relative links\"</a>\n<li> <b>Maybe in reply to:</b> <a href=\"0062.html\">Christopher Seiwald: \"what's doable in Web version control\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\n&gt;   It seems critical to me that we support what Jim called \"browsing\n&gt;   within a collection of entities\" and that we do so with without\n&gt;   requiring version-aware clients.  Why?  Because delivering versioned\n&gt;   content will be the most important product of our efforts, and our\n&gt;   plans can't rely on changing Netscape.\n\n&gt;    Of the various URL decoration proposals, only one satisfies this\n&gt;    dual requirement: having the version indicator embedded in the URL,\n&gt;    separated off by /'s.  With this, we can reuse the support already\n&gt;    in Web clients for handling relative URLs.\n\nActually, I think that none of them satisfy the requirements; the only\nthing that's close is the one that puts all of the version information\nat the beginning.\n\n&gt;   The only other possible solution, which is poor, is to have\n&gt;   version-aware servers support non version-aware clients by editing\n&gt;   the returned HTML on the fly, fixing up links with version info.\n&gt;   If anyone supports this solution, I'd like to hear it.\n\nI think this is the only thing that will actually work.\n\n\nRe PUT and all of the possibilities around it:\n\nI think all of the requirements laid on \"PUT\" can be accomplished with\n\"POST\", with some standards for the data that is posted. (E.g., a new\nmedia type. Call it 'multipart/update'.)\n\n&gt;    1)  SCM systems such as CVS rely on state information, stored\n&gt;       on the client, to know what version of what documents are\n&gt;       being edited (and thus what will be \"put\" back).  CVS's\n&gt;       state information is fairly trivial, and could be embedded\n&gt;       into the HTML documents being edited.  But that doesn't work\n&gt;       so well if the entities aren't HTML.  When the user PUTs a\n&gt;       GIF, how will a version-aware Web server based on CVS recover\n&gt;       the state necessary to check the GIF in?\n\n&gt;       SCM systems that store the state in the server, such as\n&gt;       ClearCase, don't have this same problem, I think.  But make\n&gt;       no mistake about it: these version-aware Web servers are\n&gt;       quite stateful.\n\nYes, multipart/update should contain information about the location,\nvariant, entitytag (for validation), and prior version that's being\nupdated.\n\n&gt;    2)  Other SCM systems have fairly heavyweight client\n&gt;       implementations themselves, with a fat protocol between the\n&gt;       client and server.  For example, it is unlikely that a\n&gt;       version-aware Web client would be able to carry out all the\n&gt;       machinations necessary to be a ClearCase view (i.e. a client).\n\nThe protocol itself (POST) doesn't have to be 'fat', as long as you\nget the body of the protocol (multipart/update) right.\n\n&gt;    3)  The picture is even less rosy with SCM systems that require\n&gt;       the client to have direct file access to the repository.  A\n&gt;       large chunk of the commercial SCM systems -- PVCS, MKS Source\n&gt;       Integrity, Continuus, Microsoft's SourceSafe -- are in this\n&gt;       boat.  I can't see any way they can be backend to a version-aware\n&gt;       Web server without the Web server having to act as proxy to\n&gt;       client workspaces maintained on the server.\n\nWell, the CGI that implements POST of a multipart/update will need to\nhave direct file access to the repository.\n\n&gt;    4)  Aside from architecture, the model varies wildly from one SCM\n&gt;       system to the next.  And as has been discussed, the lock-the-head\n&gt;       vs merge-into-trunk vs change-set models all need to be\n&gt;       accomodated.\n\nThese just change the data content of multipart/update in minor ways.\n\n&gt;       Going further, something that we (P3) support is atomic checkin\n&gt;       of multiple documents, because it allows you to move the repository\n&gt;       forward in whole chunks rather than a file-at-a-time.  Certainly\n&gt;       we think this is important for Web documents as well, and would\n&gt;       like to see multiple PUTs with a single COMMIT possible.\n\nWell, a single POST of a multipart/update can be performed atomicly.\n\n&gt; Version control.\n&gt;\n&gt;    All the wrinkles that make a simple PUT difficult are going to make\n&gt;    flowing full version control models over HTTP truly daunting.\n&gt;    It might be possible to come up with a limited set of operations that\n&gt;    make sense across all models, but the examples put forth so far --\n&gt;    compute the predecessor revision and show a version tree -- each only\n&gt;    make sense in a subset of the systems.\n\nMost 'control' options can be done with POST, and different data\ntypes. In fact, you probably could just use multipart/form-data.\n\n&gt; My flame-retardant personal opinion is that supporting GETs is well\n&gt; within the ability of this group, that PUTs will get mired for long\n&gt; enough that some defacto industry implementation will set the lead and\n&gt; thus simplify the range of models that need supporting, and that the\n&gt; rest of version control via HTTP will follow after that.  But I welcome\n&gt; contrary opinions, because in this case I'd be glad to be wrong.\n\nIt's hard to predict how things will go. There already are defacto\nimplementations. But it seems like most of the vendors are either\nprimarily client-only or server-only, so interoperability with others\nis pretty important.  Personally, I think the problems aren't really\nthat hard, so it's mainly a matter of will to agree. I've found that\nspeculation about this kind of stuff is pretty useless; let's just get\non with the problem/solution discussion. OK?\n\nLarry\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Next message:</b> <a href=\"0067.html\">David J. Fiander: \"First cut at Functional Requirements document\"</a>\n<li> <b>Previous message:</b> <a href=\"0065.html\">Daniel W. Connolly: \"Re: version management and relative links\"</a>\n<li> <b>Maybe in reply to:</b> <a href=\"0062.html\">Christopher Seiwald: \"what's doable in Web version control\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n", "encoding": "ascii"}