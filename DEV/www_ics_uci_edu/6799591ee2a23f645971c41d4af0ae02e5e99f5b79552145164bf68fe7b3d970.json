{"url": "https://www.ics.uci.edu/~thornton/ics45c/Notes/CourseIntroduction/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2019, Notes and Examples: Course Introduction</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"../../GradeCalculator\">Grade Calculator</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2019<br />\r\n   Notes and Examples: Course Introduction</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Course background and goals</p>\r\n\r\n<p>This course introduces you to programming in a language called C++, with the assumption that you're already familiar with at least one programming language, at a level roughly equivalent to what you might get in our first-year computer science sequence (ICS 31, 32, and 33).  If you did take our first-year sequence in recent years, you will have learned a fair amount about programming in Python; if you've taken your earlier coursework elsewhere, you may have learned any of a number of different programming languages.  Ultimately, what's important here isn't <i>which</i> language or languages you know already; what's important is that you've achieved at least some depth in any one language already, meaning that you have successfully written programs of more than just a trivial size (i.e., hundreds of lines long, as opposed to tens), that you understand how to break larger problems apart into smaller ones and implement solutions to the smaller ones separately, that you have written programs using a variety of that language's features, that you know how to distinguish between appropriate and inappropriate times to use those features, and that you've developed some ability to reason about a program, so you can diagnose a problem and fix it in a carefully-thought-out way when it doesn't do what you expected.  For all the praise and criticism given to individual programming languages, it's important to realize that you can write good or bad programs in just about any language.  If you've learned techniques for writing good programs in any language, you'll be prepared for this course, no matter what language you learned previously.</p>\r\n\r\n<p>C++ is a giant programming language with a rich history tracing back to the 1970s.  It has evolved substantially over the decades, which means that it is full of complexities (large and small), and often offers more than one way to solve the same problem.  Techniques and approaches have become popular and then fallen out of favor, with newer ones replacing them as the C++ community gains experience and discovers even better ways to organize their programs.  Because of the size and complexity of C++, it will not be my goal to teach the language in its entirety &mdash; something I wouldn't be able to do in a full academic year, much less the one quarter that we have.  Instead, our goal is to learn about what I think are the most important ideas that set programming in C++ apart from work you may have done in other languages, and the language features that let you gain experience with them, with an eye toward the things that make C++ useful for real-world programming and that are likeliest to expose you to new horizons that you may not have seen in the languages you've worked with in the past.</p>\r\n\r\n<p>It's entirely possible that you'll only have ever learned one language in the past, which makes this course doubly important: This may well be your first experience learning a programming language when you already know one, which is a surprisingly important thing to be able to do, and something I still find myself both needing and wanting to do periodically, no matter how much experience I have.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Learning a second programming language</p>\r\n\r\n<p>As we dive into C++ this quarter, you'll quickly observe that some parts of C++ bear a lot of similarity to the language you already know, while others are wildly different.  This is a blessing and a curse, as it turns out.  Seeing things that are familiar may make you &mdash; subconsciously or purposefully &mdash; gravitate toward the parts that are familiar and away from the parts that are new.  However, it's vital to catch yourself when you're doing that and think more carefully; when you learn any programming language, it's vital to understand the ideas, idioms, and tools provided by that language.  Just as you can't effectively speak or write a natural language like French simply by translating individual words from another like English, you similarly can't translate a Python program line-for-line into a good C++ program.  You might be able to barely communicate with someone by translating individual words, and you might be able to barely write a working C++ program by translating it directly from Python, but you'll have written a much better C++ program if you approach it the way a C++ programmer would.  You have to embrace what makes the language you're learning great and, in so doing, you might discover new techniques that you can bring back to the languages you already know.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Learning C++ as a second programming language</p>\r\n\r\n<p>Learning C++ is very likely to be a big departure from what you're accustomed to.  Compared to any other commonly-used programming language in the world, C++ is bigger, more complex, more nuanced, and more expressive.  It requires more attention to the underlying implementation details, while also providing you more control over those details than you might be used to &mdash; to use it effectively means you have to know more about what's going on \"under the hood.\"  There are more knobs to turn, which means more ways to control how your program runs.  But, on the other hand, there are more things to understand, more things you have to consider and control yourself, more ways to screw up, more care that you must take in designing your program to account for the additional complexity, and more difficulty in debugging when things go wrong (since a wider range of things can go wrong).</p>\r\n\r\n<p>The payoff in learning about C++ at this stage of your development, from my perspective, is at least threefold:</p>\r\n\r\n<ul>\r\n  <li>C++ is still the best (or, at least, most commonly-used) tool in the world for certain kinds of problems, where fine-grained control over performance is paramount, which means that it's an intensely practical thing to learn about.  While C++ does occupy a smaller niche than it once did, you can absolutely be employed writing C++ programs today, and that's likely to remain the case for at least the next few decades.</li>\r\n  <li>C++ makes visible a range of low-level detail that you might otherwise never experience, which can tune you into ways to make the programs you write <i>in any language</i> clearer, run faster, and use resources like memory more effectively.</li>\r\n  <li>C++ introduces a collection of language features that you'll almost certainly see in other languages you learn going forward, making subsequent attempts to learn new languages easier.  To this day, I still learn at least one new programming language &mdash; at some level of depth &mdash; every couple of years, and I don't expect that will change any time soon.</li>\r\n</ul>\r\n\r\n<p>In other words, learning C++ as a second programming language will make you a better programmer <i>in any language</i>, even if you never use C++ again.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Some historical perspective and the main design goals of C++</p>\r\n\r\n<p>While learning any new language, it's important that you understand its main design goals: What was it intended to be used for, and how was it intended to be used?  That's not to say that you can't sometimes find novel new uses for an existing language, but it really helps to understand why certain decisions were made, and sometimes even what alternatives were considered and rejected (and why).  This will help you to develop the ability to \"sense\" how a language feature is supposed to work when you first encounter it, or when you use it in a new way.</p>\r\n\r\n<p>C++ has a long history, dating back to the late 1970s, when work on designing and implementing what became C++ was begun by Bjarne Stroustrup.  C++ was conceived as an improvement on an already-existing language called C, with the very general goal &mdash; one which, at a fundamental level, hasn't changed very much in the years since &mdash; to enable people to write programs that use the available computing resources as efficiently as possible (and no less efficiently than C), but with a better set of tools built into the language to enable the programs to be written in a clearer way: an improved type system, better checking at compile-time for type-related (and other) issues, and improved facilities for data abstraction, object-oriented programming, and generic programming.</p>\r\n\r\n<p>In brief, some of the key design goals of C++ are:</p>\r\n\r\n<ul>\r\n  <li><i>Intended to be useful as a \"systems programming language,\"</i> in the way that C was (and is).  This means that it can be used effectively for implementing even the lowest reaches of a system (e.g., providing the ability to access hardware directly), while still being high-level enough to write application software.</li>\r\n  <li><i>Can be compiled down to bare machine code that makes the best use of available resources.</i>  It should be noted that, in some cases, platform-independence (i.e., the ability to write a program and have it work identically across different operating systems or different environments) was sacrificed to provide this.</li>\r\n  <li><i>Can be compiled reasonably efficiently on the machines of the day.</i>  One thing to understand is that this was intended to be true from the time C++ was first designed, which means at least some of what makes C++ seem clunky was actually a necessity when typical computers had only kilobytes of memory, megabytes of disk (maybe), and processors that were orders of magnitude slower than the ones available today.</li>\r\n  <li><i>Language features should impose zero cost on those who don't use them.</i>  C++ allows you (or forces you, depending on your point of view) to deal with some low-level chores yourself, such as allocating and deallocating memory, or deciding on the precise size of numeric variables.  Efficiency is offered as a default, sometimes at the cost of both safety and security.  Libraries can be used to automate many of these things, but the key is that those libraries are optional, so they don't impose a cost if you don't choose to bear that cost.</li>\r\n  <li><i>C++ code should be compatible with C code whenever possible.</i>  To facilitate the use of C++ in a world that was, at the time, quite dominated by C, one of the key goals was (more or less) C compatibility, meaning that it should almost always be the case that C programs given to a C++ compiler would still compile successfully, and that it should be possible to link code written partly in C and partly in C++ together into a single program.  While C and C++ have drifted apart some in the years since C++ was first designed, they still retain a substantial shared lineage, and most libraries written in C can be used effectively in C++ programs.</li>\r\n</ul>\r\n\r\n<p>Bearing this perspective in mind will make it easier to understand what lies ahead.  Many times, when you find yourself wondering \"Why was it designed this way?\", one or more of these design goals will be the answer.</p>\r\n\r\n<p>(If the philosophy of programming language design &mdash; understanding why languages are designed the way they are &mdash; is something you find interesting, check out a book titled <i>The Design and Evolution of C++</i> by Bjarne Stroustrup.  You might find that it makes more sense at the end of this quarter, since it assumes a certain amount of background in C++.  But it's a fascinating read.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Course organization and logistics</p>\r\n\r\n<p>This course web site describes the logistical details of how this course is going to be run.  Particularly, be sure that you read through the <a href=\"../../CourseReference.html\">Course Reference</a>, the <a href=\"../../ProjectGuide\">front page of the Project Guide</a>, and the early part of the <a href=\"../../ProjectGuide/Project0\">Project #0</a> write-up, so you will know how this course operates, and how you'll be doing and submitting your work.</p>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}