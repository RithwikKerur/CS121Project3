{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes991006.txt", "content": "WebDAV Advanced Collections Minutes October 6, 1999\n\nATTENDING: Judy Slein, Geoff Clemm, Tyson Chihaya, Jason Crawford, \nJim Whitehead, Chuck Fay\n\nACTION ITEMS\n\nGeoff: Resend to the design team earlier e-mail on new value for Overwrite.\n\nGeoff: Write up the proposal of a header containing the lock token as an\nalternative to protecting the lock request-URI, and send to mailing list.\n\nJudy: Revise specs by Friday COB.\n\nLOGISTICS\n\nJudy will send out revised specs Friday evening.  Next week's meeting\nwill be devoted to collection comments from the team.  We'll try to have\ndrafts to Internet-Drafts on Friday, October 15.\n\nISSUE 20: BIND ERROR CODES\n\nAgreed: We'll use new error codes for cycles not permitted and cross-server\nbinding not permitted.\n\nJim: Putting XML explanations in the response body is in effect creating \na subclass (suberror code).  We risk getting into a larger discussion \nabout the proper way to extend HTTP error codes.  We don't want to get into\nthat discussion. It's defensible to create new codes.  That's the \nextension mechanism that was defined by HTTP, and there are still lots\nof 5xx codes still available. \n\nNo objections.\n\nJudy: Do we have to coordinate with anyone to claim codes?\n\nJim: No. Just write it up. Check RFC 2616 for next available code.  Maybe\nstate in the IANA considerations section that we are claiming new codes,\neven though IANA hasn't been asked to administer HTTP status codes.\n\nISSUE 23: WHETHER TO SWITCH THE MEANING OF REQUEST-URI AND DESTINATION\nHEADER IN BIND REQUESTS\n\nAgreed: Request-URI will identify the resource, Destination header will\nidentify the collection and segment of the binding relationship being\ncreated.\n\nJudy: We had decided to make the switch to be consistent with MOVE and COPY.\nThen the Request-URI would identify the resource being bound, and the\nDestination header would identify the collection and segment.  But Jason\npointed out that there may be a problem with doing this.  Normally, the\nRequest-URI identifies the resource for which authentication is needed.\nThat won't be the case if we switch the meanings.\n\nJim: The HTTP philosophy is that you issue a request to an object, and the\nobject performs the method on your behalf. Normally you try to design your\nmethods so that they go to an existing object.  This model breaks down in \ncreation methods where the object doesn't exist.\n\nGeoff: COPY and MOVE have the same problem, both about authentication, and\nabout having the resource the method is really addressed to in the\nDestination header.  Let's just try to be consistent with MOVE and COPY.\n\nJason: The cross-server case is a concern for authentication.\n\nGeoff: It's already a concern for MOVE and COPY, so let's just be \nconsistent with them. \n\nWe'll stand by our previous decision.\n\nISSUE 22: WHETHER TO ALLOW BIND OF \"/\"\n\nAgreed: We will disallow BIND of \"/\".\n\nWe like Geoff's rationale from his mailnote.\n\nISSUE 11: SECTION 10 BINDINGS AND OTHER METHODS\n\nJudy: The problem is how to say anything specific enough to be useful\nand still allow bindings to dynamic resources.  Geoff proposed a solution.\n\nGeoff: Really we should just say that you can't create bindings to dynamic\nresources. \n\nJohn Stracke's case: I may want to be able to write a script once and place \nbindings to it in different places that behave differently according to \ntheir location.  In fact, I *have* written such a script.  On my personal \nsite, I don't have access to the logs, so I've placed index.cgi scripts in \nvarious directories that I want to monitor; they log the hit and return \na 302 to redirect to Index.html.  Since I didn't want to maintain N copies \nof the script, most of them are symlinks.  Since the 302 requires an \nabsolute URI, the script looks at the Request-URI to figure out where to \nredirect to.\n\nGeoff: It's too confusing to try to specify for dynamic resource, and it's \nworth losing the functionality of creating bindings to dynamic resources in\norder to be able to say something clear.\n\nGeoff: If the focus is on authoring, you want to author the script itself.\nSo stick with static resources.  Don't muddy the protocol by trying to\ndefine bindings to dynamic resources.\n\nJim: The current language is ok.\n\nGeoff: We want to say that a change made in one location must be visible \nat all locations.  Otherwise, you can't distinguish between creating a\nnew binding and doing a COPY.  There will be no guidance to the server, and\nno semantic utility in performing a BIND rather than a COPY.  We need to be\nable to determine by examining what's on the wire whether a BIND or a COPY\nwas performed.\n\nJim: Any attempt to define bindings too closely will be counterproductive.\nThe usefulness of HTTP has been largely in dynamic resources, so we don't \nwant to cut ourselves off from that.\n\nGeoff: Just wants to constrain the use of BIND to be only on static\nresources.  If we can't give a good definition of the behavior of bindings, \nsomebody would interpret it in unpredictable ways or ways we wouldn't want\n(for example, in a way indistinguishable from COPY).\n\nHow do we determine whether a resource is static or dynamic?  We could have\na property whose value tells you that, and BIND can only be used if the \nproperty is set to \"static\".\n\nJim: Doesn't agree that allowing bind to dynamic resources will lead to \nproblems.\n\nGeoff: What if somebody then says, I'll implement bind as copy? What could\nwe appeal to to say this is not allowed?\n\nJim: The definition of the behavior of PUT with bindings would prevent\nthat.\n\nJudy: But that's the definition some people have said is too strong.  It's\ninconsistent with John's example.\n\nGeoff: If the results of PUT can depend on the URL used to access the\nresource, we can't distinguish between COPY and BIND.  Wants to constrain\nwhat PUT can do.\n\nThe difference between COPY and BIND is clear.  COPY creates a new resource.\nBIND does not create a new resource.  It makes available a new URI for \nan existing resource.\n\nJim: Keep only last sentence of the paragraph about PUT: \"The change made\nby a PUT via one URI mapping MUST affect the resource that generates the GET\nresponse for all URI mappings to the same resource.\"\n\nGeoff: Then if you did implement BIND as COPY, it would not be discernible.\nThis is so weakly defined that it does not provide enough guidance to\na well-intentioned implementer.\n\nGeoff: The utility of being able to BIND to dynamic resource is not enough \nto offset loss of clarity.\n\nJim: The definition of CGI says that when you pass any method into a CGI\nscript, the script can interpret that method however it wants.  Then you\ncould have any implementation of PUT within the script. John's argument is \ncorrect.\n\nJudy: We could say explicit things for static resources, and let people \ninterpret them, extrapolate from them for dynamic resources.\n\nWe could say that the first PUT sentence \"If the Request-URI of a PUT\nidentifies an existing resource, then a PUT via one URI mapping to this\nresource MUST produce the same result as a PUT with the same headers and\nrequest entity body via any other URI mapping to the same resource\" applies \nonly to static resources, and the second applies to both static and dynamic.\n\nGeoff: Should we define a DAV:static property that you can look at to \ndetermine whether a resource is static or dynamic? Jim: No.\n\nWhat is the definition of static? If a request succeeds, you get the same \nresult every time, no matter which binding is used to access the resource.\n(A request might fail for some bindings, succeed for others, but the \nresource still be a static resource.)\n\nWe need to use \"static\" consistently throughout, and make clear what we had \nin mind.\n\nChuck: Prefers to delete the first sentence on PUT, and keep the second.\nOtherwise, we'll have problems trying to define static, and we'll be pushed\nto add a property, which is even worse.\n\nJim: Keep the first sentence, and say its only for static.  Hint at\na definition right there by giving examples of dynamic resources (CGI,\nactive server pages).\n\nJudy will draft this section based on this guidance.\n\nISSUE 15: WHETHER TO SIMPLIFY THE SEMANTICS OF REDIRECT REFERENCES\n\nAgreed: We will simplify the redirect references spec by getting rid of all\nspecial cases.  Redirect references will always respond with 302 by default.\n\nGeoff proposed having redirect references always respond with 302 by \ndefault -- no exceptions.\n\nJim: Let's just make sure we understand the implications.  Using Web Folders,\nif you did a COPY on a redirect reference, instead of getting a copy of the\nreference you would get an error (302).  Web Folders will not know how to\nhandle a 302, or if they do, they will not do anything special for 302 from\na redirect reference.\n\nWeb Folders don't know how to do depth operations, so they won't run into\nthe case where you encounter a redirect reference during depth processing.\n\nGoliath doesn't do depth operations yet, but we can expect it to be good\nabout extending as new functionality is defined.\n\nIn general, down-level clients will have problems with depth operations.  We\nhave to accept that.\n\nJim is ok with getting rid of special cases.\n\nWe will simplify the redirect references spec.\n\nISSUE 16: WHETHER TO MAKE DAV:orderingtype OPTIONAL\n\nAgreed: We will keep it required.\n\nJim: There's no big win in making it optional. \n\nGeoff: no preference\n\nHow would you know whether the collection just doesn't support ordering\nor does support it but is unordered?  You can find out whether it supports\nordering by doing OPTIONS.\n\nMaking it optional could lead to interoperability problems. [How? JS]\n\nWe'll keep DAV:orderingtype required.\n\nISSUE 17: CHANGING THE ORDERING SEMANTICS OF A COLLECTION\n\nAgreed: We will leave the Ordered header in MKCOL, add a way to change \nthe ordering semantics with ORDERPATCH, make DAV:orderingtype readonly.\n\nCurrently you would have to do a PROPPATCH on DAV:orderingtype, then\ndo an ORDERPATCH to change the order of members to conform to the new\nsemantics (for client-maintained orderings). Jim Amsden pointed out \nthat there is opportunity for something to go wrong between these 2\nsteps.  So maybe we should add an element to ORDERPATCH to allow\nthe semantics to be changed in the same operation where the order of\nmembers is updated.  (Then we should probably make DAV:orderingtype\nreadonly.)\n\nThis is a rare case.  Changes in ordering type will be infrequent.\n\nBut there might some day be an application where there would be frequent \nchanges in orderingtype and contention over it.\n\nAdding an element into orderpatch seems reasonable and low cost.\n\nDo we want to allow DAV:orderingtype to be modified thorugh PROPPATCH? \nNo, take away that ability if we provide a way to change the ordering\nsemantics in ORDERPATCH.\n\nWhat about MKCOL with the Ordered header?  Do we keep the Ordered header\nthere?  It does seem reasonable to submit an ordering semantics with\nMKCOL.  The collection will be empty at that point.  If you really need\natomicity when creating and ordering a collection, you can get that by\nlocking the parent of the collection, creating the ordered collection,\nadding members, and doing ORDERPATCH, then unlock.\n\nWe will leave the Ordered header in MKCOL, add a way to change the ordering\nsemantics with ORDERPATCH, make DAV:orderingtype readonly.\n\nISSUE 18: WHETHER TO REQUIRE THE Position HEADER WHEN ADDING MEMBERS TO\nAN ORDERED COLLECTION\n\nAgreed: The Position header remains optional.\n\nDoing this would prevent existing clients from interacting with an \nordered collection.\n\nIs it more important to maintain the ordering or to allow down-level clients\nto add collection members?  This will depend on the application.\n\nWe'll keep the current statement: The Position header is optional, and if\nit is not present for a collection with a client-maintained ordering, the\nserver must place the new member at the end of the ordering.\n\nISSUE 19: MOVE WITH MULTIPLE BINDINGS CAN CAUSE A RESOURCE TO \"SPLIT\"\n\nKevin described a scenario where it looks as if we get the wrong results.\nWhen you COPY a resource to a destination where there were multiple \nbindings to the same resource, you end up with one binding attached to\nthe new resource and the rest still attached to the original resource.\nThis is inconsistent with what people expect. COPY B3 to B2.\n\nBefore:\n\nB1     B2     B3\n\\      /      |\n \\    /       |\n  \\  /        |\n   R1         R2\n\nAfter:\n\nB1     B2     B3\n|      |      |\n|      |      |\nR1     R3     R2\n\nwhere R3 is a duplicate of R2.\n\n\nGeoff: We can use a new value of the Overwrite header to solve this problem.\nIn earlier e-mail he proposed a new value \"merge\".  (The name doesn't really\napply very well to this case.)\n\nThe current Overwrite semantics says that if the value is \"false\", the\noperation fails.  If the value is \"true\", the resource at the Destination\ngets deleted (that is, binding B2 is deleted), then the resource gets\nduplicated and a new binding B2 gets created to it.  So this is the scenario\nKevin describes, and it's inconsistent with the file system semantics\nthat people expect.\n\nWe can avoid changing RFC 2518 by adding a new value for Overwrite.\nThe semantics for this new value would be to leave the destination\nresource there, and do a PUT and PROPPATCH to it.  It would mean COPY = \nPUT + PROPPATCH.  Then both of the old bindings would point to the new\nresource.\n\nWould this new value of Overwrite apply only to COPY, or also to MOVE?\n\nNo one implements MOVE this way now, so it would give surprising results.\n\nThis wouldn't have any bad effects on the current behavior of Microsoft\nWeb Folders.\n\nDon't call it \"merge\".  Call it \"multiple-bindings\".  It states whether\nI want to affect all bindings or just one.\n\nGeoff: It determines more than that.  It affects which locks you need \nto have. If you do a copy with overwrite=t, you only need a lock on \nthe collection containing the destination.  If you do a copy with\noverwrite=merge, you will be doing a put and proppatch to the existing \nresource, and so need a lock on the resource rather than on its parent\ncollection.\n\nHow would you do depth copy with merge? You do put/proppatch recursively \n(and appropriate mkcol's).  You leave the existing hierarchy there.  (That's\nwhere the name \"merge\" came from.)\n\nJim: We need to write this up and think about it some more before adding to \nthe spec. Geoff will forward his earlier mail to the design team.\n\nSome use cases will want to affect one binding, others will want all bindings.\nSo we need a way to allow the client to specify which it wants.\n\nHOW TO HANDLE CONFLICTS WITH RFC 2518\n\nWhere we see things in the binding spec that conflict with RFC 2518, we\nshould say so explicitly.  In our specification, we should explicitly \nidentify the passages that need to be changed in RFC 2518.\n\nPROTECTING THE LOCK REQUEST-URI\n\nGeoff: Favors a new header whose value will be the lock token.  When you\ninclude this header in a request, then the Request-URI will be mapped\nas necessary to insure that the lock owner can continue to access the\nresource for the duration of the lock.  We could use the versioning header \nTarget-Selector for this. \n\nOnly down'level clients will have problems. (It won't help the MS Office\nclients.)\n\nIt's ok for a server to refuse to MOVE things if it can't protect the URL, \nor keep track of where the resource has moved.\n\nJim: Don't have a header. Just say that the server can refuse to move a\ncollection if one of its members is locked. If the server does allow \na move, then the client will discover that the resource has moved and\ncan do a propfind on lock token to locate it.\n\nJason: Making it optional doesn't sound good.  That results in too many code\npaths for a client.\n\nIt's worse to require the server to allow the move.\n\nGeoff: What we care about is that LOCK-GET-PUT works. That's the constraint, \nand otherwise we give servers freedom as to how they make it so.\n\nJim: The client does a MOVE and just gets success or failure.  That's no \ndifferent from today.  The path is already there.\n\nJason: The additional code path is for someone trying to access the resource\nafter it has moved.\n\nGeoff agrees, Jim can live with the header proposal.\n\nJason: Still prefers protecting the URI, and doesn't think it's that \ndifficult, but can live with the header proposal.\n\nWhat if the lock is on a parent? With a depth lock, someone moves a tree and \nyou are trying to access something in that tree.\n\nDo we want to require support for depth locks: jim strongly favors, geoff and\nchuck opposed, judy and jason not strong either way.\n\nDepth would add complexity to the proposal for a lock token header.  It's\nsimple for a single resource.\n\nThis could be an argument againstt the proposal or an argument against\ndepth locking.\n\nJim: What happens if the resource gets moved twice?\n\nGeoff: Once you have a target selector, it's bound to the resource forever.\n\nThis issue is related to versioning because they want a down-level client's\nlock to be interpreted as a checkout.  So the semantics of lock and checkout\nneed to be consistent.\n\nMaybe we can restrict the proposal to locks on individual resources.\n\nGeoff will write up his proposal of adding a header to contain the lock\ntoken, try to take into account how it would work with depth locking.\n\nWHETHER TO KEEP SECTION 8.1 OF THE BINDINGS SPEC\n\nAgreed: We keep the section.\n\nJudy suggests removing this section, which tries to show that our MOVE\nsemantics are equivalent to the definition of MOVE in RFC 2518.  It's\nbecoming clear that they are not equivalent, as we explore the problems\nof LOCK/MOVE.\n\nJim: The language on MOVE and bindings is useful.  We could take out the\nclaim that the MOVE semantics we give are consistent with RFC 2518.\n\nGeoff: on the fence\n\nJim: We didn't put this in to show equivalence with RFC 2518 semantics.  We\nput it in because we were thinking about cross-server MOVEs.\n\nBe sure we say that for cross-server MOVEs, if the resource is locked, \nthe server should feel free to fail the request.\n\nGeoff: The section is interesting, but people will think it's more \ncomplicated than it really is.\n\nPeople don't seem to find it troublesome so far.\n\nAgreed: We keep the section.\n\nIMPROVING THE TERMINOLOGY SECTION\n\nJim: People get hung up in terminology.  Start the terminology section\nwith a scenario with real URLs, creating new bindings and URI mappings.\nUse the terminology that will be defined. A scenario that creates a new\nbinding to a collection resource, and to a non-collection resource.", "encoding": "ascii"}