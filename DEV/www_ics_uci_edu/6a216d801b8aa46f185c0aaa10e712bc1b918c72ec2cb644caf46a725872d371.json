{"url": "https://www.ics.uci.edu/~thornton/ics33/CodeExamples/ImplementingContainersPart2/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\n\n<title>ICS 33 Summer 2013, Code Example: Implementing Containers (Part 2)</title>\n\n</head>\n\n<body>\n\n<div class=\"navbar\">\n\n<p>\nICS 33 Summer 2013 |\n<a href=\"../../index.html\">News</a> |\n<a href=\"../../CourseReference.html\">Course Reference</a> |\n<a href=\"../../Schedule.html\">Schedule</a> |\n<a href=\"../../ProjectGuide\">Project Guide</a> |\n<a href=\"../../CodeExamples\">Code Examples</a> |\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\n</p>\n\n<hr />\n\n</div>\n\n<div class=\"header\">\n\n<p>ICS 33 Summer 2013<br />\n   Code Example: Implementing Containers (Part 2)</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Background</p>\n\n<p class=\"subtitle\">The problem with duck typing</p>\n\n<p>Previously, we've seen that Python's type system uses a technique sometimes called <i>duck typing</i> to check whether an object is capable of carrying out some operation.  A Python program can be written that attempts to do anything you'd like &mdash; call any method, use any operator &mdash; to any object.  That program will actually be able to run, though it will fail when it reaches the point that an object is unable to support an operation it's been asked to do.  We've also previously seen the mechanism &mdash; how things are looked up in namespaces, how operators are translated into calls to special methods &mdash; that is used to determine whether an object can or can't perform a certain operation.</p>\n\n<p>Why this is called \"duck typing\" is because of the old saying that if something walks like a duck and quacks like a duck, it's probably a duck.  In Python, we can treat any object any way we'd like; we can call any method and pass it any parameters we'd like, and if the object has a method with the right name and that accepts the parameters we passed it, we're good to go.  For example, you can call <b>x.close()</b> on any object <b>x</b> that has a method called <b>close</b> that can take no parameters.  Whatever that method does, that's what will happen next.</p>\n\n<p>When you stop and think about that fact, you realize that Python offers a tremendous amount of flexibility.  But, if you think a little bit harder, you realize that this flexibility comes at a price.</p>\n\n<ul>\n  <li>If, somewhere in a large program, there is a circumstance where you ask an object to perform an operation it's incapable of &mdash; e.g., calling a method or using an operator not supported by its class &mdash; you'll never know about it <i>unless</i> you happen to reach that line of code in the problematic circumstances.  A simple misspelling of a method name or forgetting to pass in a parameter results in a run-time error, and run-time errors can be difficult to diagnose and fix, especially if they're ones that happen only intermittently.</li>\n  <li>If you want to write code that is capable of operating on many different types of objects &mdash; broadly, we call this <i>polymorphism</i> &mdash; you'll only be able to do it if all of these types expose the same functionality in the same way.</li>\n</ul>\n\n<p>The first of these problems can be largely mitigated by testing (e.g., a combination of unit testing and running your program while observing the results), and can be further mitigated by additional tools that analyze Python programs and try to assess whether they have these kinds of mistakes in them (though these tools, too, represent a tradeoff, as they can issue <i>false positives</i>, suspecting problems where there aren't any).</p>\n\n<p>The other problem is one that can only be solved cooperatively, where the same functionality offered by many classes is offered by all of the classes in the same way.  The only way to ensure that is an agreement amongst everyone writing those classes, whereby the same functionality is offered in the same way in all of them.  Someone needs to specify that agreement, and everyone else needs to agree to it.  Python does some of this for us, because a fair number of broad agreements are present in Python's specification.  For example, we've seen before how uses of various operators are translated into calls to special methods; by writing our classes according to those rules, we can allow objects of our classes to be compatible with those operators.</p>\n\n<p class=\"subtitle\">Protocols (interfaces) in Python</p>\n\n<p>In ICS 32, we saw that systems on the Internet &mdash; web servers, web browsers, mobile applications, etc. &mdash; have a similar problem.  If you want to write a program that communicates with another program across the Internet, it requires more than just connecting one program to another (a problem solved in the Python library by <i>sockets</i>).  Once you're connected, you have to know how to talk to the other program, what data you need to send to it in order to get the effect you're looking for.  For example, if you connect to a web server to download a web page, you need to know the appropriate way to say \"Hi, I'd like to download this web page, please.\"  And, furthermore, you'll have to understand how to interpret the result that's sent back.</p>\n\n<p>As we saw, <i>protocols</i> (like HTTP, which is the protocol that's used on the web) serve as the agreement between two programs communicating over a computer network.  A protocol specifies in detail what each program needs to send and what each program can expect to receive in response.  In short, it establishes the rules used for a particular kind of communication between two programs.</p>\n\n<p>A similar concept appears in the Python language.  Python defines <i>protocols</i> that establish rules about ways that objects can interact with one another.  If we want, for example, to build an object that can be used in a <b>for</b> loop (e.g., the object <b>x</b> in a loop <b>for i in x</b>), the expectation is that <b>x</b> is <i>iterable</i> (i.e., it can be iterated).  Python defines a protocol that specifies what it means for an object to be iterable &mdash; what methods it needs and how they're used for iteration &mdash; so if you want to write a class whose objects can be iterated, you need only follow that protocol.</p>\n\n<p>Generally speaking, a protocol describes a set of methods that a particular object will offer to accomplish some goal (e.g., be iterated, contain other objects, be usable in a <b>with</b> statement), as well as an indication of what effect those methods can be expected to have (i.e., what results they'll return, what side effects they cause) in different scenarios.</p>\n\n<p>(It should be noted that this same concept appears throughout the object-oriented programming community, not just in Python, though most object-oriented langauges refer to these agreements as <i>interfaces</i> rather than protocols.  Even amongst Python programmers, you'll see the term \"interfaces\" used, and you can think of it as being interchangeable with our use of the term \"protocol\" here.)</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Protocols offered by containers</p>\n\n<p>In the <a href=\"../ImplementingContainersPart1\">previous code example</a>, we saw that <i>containers</i> are, generally speaking, objects in Python that (appear to) contain other objects.  Many kinds of containers are built into Python, such as <b>list</b>, <b>tuple</b>, <b>set</b>, and <b>dict</b>, but you can build your own if the ones provided by Python are not suitable for the problem you're solving.  (We'll see an example of that later this quarter.)</p>\n\n<p>You've no doubt noticed that the four kinds of containers are similar in a lot of ways, even though they solve somewhat different problems.  Examples:</p>\n\n<ul>\n  <li>It is possible to ask any of these containers whether they contain a particular object, by using the <b>in</b> or <b>not in</b> operators on them.  It means something slightly different in some cases (e.g., dictionaries check whether a particular key is present), but it's something that all of these containers can do.</li>\n  <li>It is possible to iterate any of these containers in, for example, a <b>for</b> loop.  Again, the effect is a little different in some cases (e.g., dictionaries iterate only the keys), but, again, it's something that all of these containers can do.</li>\n  <li>It is possible to ask any of these containers for a length by passing them as a parameter to the built-in function <b>len</b>.</li>\n</ul>\n\n<p>Not surprisingly, protocols are at the root of all of these similarities.  And, more importantly, if we know these protocols, we can not only know what to expect of these objects simply by knowing which protocols they support, but we can also build our own classes that also implement the same protocols, making them compatible with code that can work with Python's built-in containers.</p>\n\n<p class=\"subtitle\">Containers</p>\n\n<p>In the <a href=\"../ImplementingContainersPart1\">previous code example</a>, we saw some examples of things that containers in Python are expected to be able to do, i.e., their protocol.</p>\n\n<ul>\n  <li>The method <b>def __len__(self)</b> determines their length.</li>\n  <li>The method <b>def __contains__(self, item)</b> returns <b>True</b> if the given item is a member of the container, <b>False</b> if not.</li>\n</ul>\n\n<p>Providing these three methods gives us an <i>immutable container</i>, meaning that we can see what's in it, but can't change it once it's constructed.  Ultimately, this is all that a container needs to support: \"Tell me whether this obejct is inside of you\" and \"How many objects are inside of you?\"  However, lots of containers do more than this, so there are additional special methods that are added.</p>\n\n<p>One example of additional functionality is the indexing functionality that we saw in the <a href=\"../ImplementingContainersPart1\">previous code example</a>, which requires only one additional method:</p>\n\n<ul>\n  <li>The method <b>def __getitem__(self, index)</b> allows you to retrieve a value at a particular index (or to retrieve a slice).</li>\n</ul>\n\n<p>But if we wanted something that behaves more like <b>list</b>, we'd expect to be able to change elements within it or to delete elements from it, giving us a <i>mutable container</i> instead.  These methods provide that functionality:</p>\n\n<ul>\n  <li>The method <b>def __setitem__(self, index, item)</b> changes the item at the given index to the given item.\n    <ul>\n      <li>This is what would be used if, for example, you said <b>x[y] = z</b>, with <b>y</b> being passed as the index and <b>z</b> as the item to be stored.</li>\n      <li>Note that this can also be used with slicing.  If you said <b>x[y:z:w] = v</b>, <b>slice(y, z, w)</b> would be passed as the index and <b>v</b> could be an \"iterable\" (which we'll see later) that specifies many elements to be stored instead of just one.</li>\n    </ul>\n  </li>\n  <li>The method <b>def __delitem__(self, index)</b> removes the item at the index from the container.\n    <ul>\n      <li>The statement <b>del x[y]</b> would be translated to <b>x.__delitem__(y)</b>.</li>\n      <li>The statement <b>del x[y:z:w]</b> would be translated to <b>x.__delitem__(slice(y, z, w))</b>.</li>\n    </ul>\n  </li>\n</ul>\n\n<p class=\"subtitle\">Sequences</p>\n\n<p>Some containers, in addition to just containing other objects, are thought of as containing a <i>sequence</i> of other objects, meaning that the objects are considered to appear in a particular order.  In Python, lists are sequences, because the order in which elements appear is relevant.  On the other hand, sets are not, because the order is not relevant; all that matters in a set is whether a particular item is in the set or not.</p>\n\n<p>One thing that sequences generally have is the indexing functionality described previously.  If the sequence is intended to be immutable, you'd write only a <b>__getitem__</b> method; if you needed to be able to mutate the sequence, you'd also need <b>__setitem__</b> and <b>__delitem__</b> methods, as well.</p>\n\n<p>A number of other methods are quite common in sequences:</p>\n\n<ul>\n  <li><b>def count(self, item)</b>, which specify how many times an item appears in the sequence</li>\n  <li><b>def index(self, item)</b>, which indicates the index of the first appearance of an item in the sequence.</li>\n  <li>A <b>+</b> operator (i.e., the special methods <b>__add__</b> and/or <b>__radd__</b>), which concatenates sequences together.</li>\n  <li>A <b>*</b> operator (i.e., the special methods <b>__mul__</b> and/or <b>__rmul__</b>), which creates multiple copies of a sequence concatenated together.</li>\n</ul>\n\n<p>Given the broad agreement about what constitutes a sequence &mdash; there is a <i>sequence protocol</i> in Python that defines this &mdash; it's possible to write a function that expects a sequence as a parameter.  If that function is passed a sequence &mdash; any kind of sequence, as long as it's one that follows the protocol &mdash; the \"right thing\" will happen.  For example, consider this function:</p>\n\n<blockquote><pre>\n<b>def</b> print_all(a_sequence):\n    <b>for</b> index <b>in</b> range(len(a_sequence)):\n        print(a_sequence[index])\n</pre></blockquote>\n\n<p>This function works on a surprisingly wide variety of types.  In fact, it will work for an object of any type that supports the operations that are being used:</p>\n\n<ul>\n  <li>The type would need a <b>__len__</b> special method, because we ask the object for its length.</li>\n  <li>The type would need a <b>__getitem__</b> special method, because we index the object.</li>\n</ul>\n\n<p>Given that the sequence protocol includes both <b>__len__</b> and <b>__getitem__</b>, we can conclude that any sequence can be passed to this function.  And if we wrote a new kind of sequence, it would automatically work with our <b>print_all</b> function without us having to change it, because anything that is a sequence is compatible with <b>print_all</b>.</p>\n\n<p>That, in a nutshell, is the value of protocols.  It allows us to write other code that makes the assumption that it's dealing with some object that implements the protocol, without having to know specifically what kind of object it is.  And thanks to the way that Python automatically calls the \"right version\" of a method based on the type of object it's called on, the code will work correctly for <i>every</i> kind of object that implements the protocol, including objects of classes we haven't even written yet.</p>\n\n<p class=\"subtitle\">Iterables and iterators</p>\n\n<p>We've discovered repeatedly in this course that Python has very little \"magic.\"  Operators like <b>+</b> or <b>&lt=</b> aren't magic; they just turn into calls to methods.  Classes aren't magic; they create a kind of object that can act as a blueprint for other objects.  Virtually every feature in Python has a story like this.</p>\n\n<p>Consider, then, the humble <b>for</b> loop.  Have you noticed how flexible it is?</p>\n\n<blockquote><pre>\n# iterating a list\n<b>for</b> item <b>in</b> [1, 2, 3, 4, 5]:\n    print(item)\n\n# iterating a range\n<b>for</b> value <b>in</b> range(1, 20, 3):\n    print(item)\n\n# iterating a set\n<b>for</b> item <b>in</b> {1, 2, 3}:\n    print(item)\n\n# iterating (the keys of) a dictionary\n<b>for</b> key <b>in</b> {'x': 3, 'y': 9}:\n    print(key)\n</pre></blockquote>\n\n<p>We saw previously that a <b>for</b> loop is even capable of iterating objects of our classes, as our InfiniteZeroes class from the <a href=\"../ImplementingContainersPart1/index.html\">previous code example</a> was also compatible with <b>for</b> loops.</p>\n\n<p>By now, our intuition should be telling us that there is a story here, too, that <b>for</b> loops are capable of iterating through all kinds of different objects &mdash; lists, ranges, sets, dictionaries, tuples, and even objects of our types &mdash; because those objects all have some kind of inherent similarity.  And if that's where your intuition is leading you, you're right!</p>\n\n<p>The story is that all of these kinds of objects are what we call <i>iterable</i> (i.e., they are able to be iterated).  That's actually a technical term in Python, the name of a protocol that can be implemented in a class if its objects should support iteration.  The <i>iterable protocol</i> is actually very simple; it includes only one method:</p>\n\n<ul>\n  <li><b>def __iter__(self)</b>, which returns another object called an <i>iterator</i> that will handle the details of performing the iteration.\n</ul>\n\n<p>Iterators form the \"glue\" between constructs like <b>for</b> loops and the obejcts they iterate.  An iterator hides of all of the details of how iteration is performed &mdash; remembering details like list indexes &mdash; while offering a standard way to say \"Give me the next item I haven't seen yet.\"  Iterators all obey the <i>iterator protocol</i>, which consists of two methods:</p>\n\n<ul>\n  <li><b>def __next__(self)</b>, which returns the next object not yet returned by the iterator, or raises StopIteration if there are no more objects to be returned.</li>\n  <li><b>def __iter__(self)</b>, which is an important detail: iterators are themselves iterable (e.g., you can use them in <b>for</b> loops), so iterators must have the <b>__iter__</b> method demanded by the iterator protocol, though they will generally always just say <b>return self</b>.  (In other words, if you ask an iterator \"Give me an iterator that iterates you,\" it'll just say \"I <i>am</i> an iterator!\" and return itself.)</li>\n</ul>\n\n<p>The built-in function <b>iter</b> is the standard way to ask an object for an iterator.  <b>iter(x)</b> is translated to <b>x.__iter__()</b> automatically.  Similarly, the built-in function <b>next</b> is the standard way to ask an iterator for its \"next\" object, with <b>next(x)</b> being translated to <b>x.__next__()</b> automatically.</p>\n\n<p>Here's a quick example of some of these concepts in action:</p>\n\n<blockquote><pre>\n&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; i = iter(x)\n&gt;&gt;&gt; next(i)\n1\n&gt;&gt;&gt; next(i)\n2\n&gt;&gt;&gt; next(i)\n3\n&gt;&gt;&gt; next(i)\n<i>Traceback (most recent call last)\n   ...\nStopIteration</i>\n</pre></blockquote>\n\n<p>We see in the example above that an iterator over the list <b>[1, 2, 3]</b> returns the items in the list, in the order they're stored, until there are no more items that haven't been returned, at which time it raises a StopIteration exception if you continue asking it for more items.</p>\n\n<p>So, what does this have to do with <b>for</b> loops?  This is the technique that is used to execute the loop <b>for i in x</b>.</p>\n\n<ul>\n  <li>Call <b>x.__iter__()</b>.  If this is successful, the loop uses the iterator to drive the loop: it asks the iterator for its \"next\" element repeatedly, assigning it temporarily into the variable <b>i</b> and executing the body of the loop once, until the iterator raises a StopIteration, at which point the <b>for</b> loop ends.</li>\n  <li>If <b>x.__iter__()</b> fails (because <b>x</b> is not iterable), all is not lost yet.  A <b>for</b> loop will then try to iterate the object by calling <b>x.__getitem__(0)</b>, then <b>x.__getitem__(1)</b>, and so on, running one loop iteration for each result, until an IndexError is raised, at which point the <b>for</b> loop ends.</li>\n  <li>If the call to <b>x.__getitem__(0)</b> fails (e.g., <b>x</b> does not have a <b>__getitem__</b> method), the <b>for</b> loop fails with a <b>TypeError</b>.</li>\n</ul>\n\n<p>In general, even though Python's built-in data structures like lists, sets, and dictionaries have radically different implementations, it's the concepts of \"iterable\" and \"iterator\" that allow code such as <b>for</b> loops to iterate through their items without having to know the details of those implementations.  (This is one of the most powerful and important concepts in software: hiding implementation details whenever possible.)</p>\n\n<p class=\"subtitle\">Reverse iteration</p>\n\n<p>It is also possible to <i>reverse-iterate</i> some objects, meaning that we receive their items in the reverse of the order an iterator would normally return them.  For example, when you reverse-iterate a list, you get the items back in the reverse of the order they appear in the list.</p>\n\n<p>The built-in function <b>reversed(x)</b> asks the object <b>x</b> for a <i>reverse iterator</i> (an iterator that returns the items in <b>x</b> in reverse order).  It is translated to <b>x.__reversed__()</b>, a method that, like <b>__iter__</b>, is expected to return an iterator (i.e., an object that implements the iterator protocol), but that returns the objects in reverse order.</p>\n\n<p class=\"subtitle\">The nitty-gritty details</p>\n\n<p>If you're interested in every detail of these protocols, they are documented in the Python Standard Library documentation <a href=\"http://docs.python.org/3.3/library/stdtypes.html\">here</a>.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">The complete code example</p>\n\n<p>In lecture, we took these ideas and used them to write our own implementation of Python's built-in <b>range</b> class.  While it generally isn't wise, as a practical matter, to rewrite functionality that's built into a language &mdash; <i>unless</i> we write it so that it's different in some substantial way that's important to us, like using less memory or running faster in some case than the built-in type does) &mdash; it can serve as a useful learning experience, as a way to understand enough about how it works so that we can (a) use it more effectively, and (b) build something similar but different.</p>\n\n<p>We called our implementation <b>MyRange</b>, to avoid a naming conflict with the built-in version, and we didn't make an attempt to support everything that the <b>range</b> class can do, but we hit the highlights.</p>\n\n<p>The example, along with some unit tests for it, are below.</p>\n\n<ul>\n  <li><a href=\"myrange.py\">myrange.py</a></li>\n  <li><a href=\"myrange_tests.py\">myrange_tests.py</a></li>\n</ul>\n\n</div>\n\n</body>\n</html>\n", "encoding": "ascii"}