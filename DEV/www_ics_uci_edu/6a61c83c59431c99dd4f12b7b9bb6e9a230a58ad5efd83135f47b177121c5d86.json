{"url": "https://www.ics.uci.edu/~ejw/authoring/draft-jensen-webdav-ext-01.txt", "content": "\n\n\n\n\n          WEBDAV Working Group                         Y. Goland, Microsoft\n          INTERNET-DRAFT                  E. J. Whitehead, Jr., U.C. Irvine\n          <draft-jensen-webdav-ext-01>                 Asad Faizi, Netscape\n                                                  Stephen R. Carter, Novell\n                                                         Del Jensen, Novell\n          Expires September 25, 1997                         March 26, 1997\n\n\n                 Extensions for Distributed Authoring and Versioning\n                                       on the\n                              World Wide Web -- WEBDAV\n\n\n          Status of this Memo\n\n          This document is an Internet-Draft. Internet-Drafts are working\n          documents of the Internet Engineering Task Force (IETF), its\n          areas, and its working groups. Note that other groups may also\n          distribute working documents as Internet-Drafts.\n\n          Internet-Drafts are draft documents valid for a maximum of six\n          months and may be updated, replaced, or made obsolete by other\n          documents at any time. It is inappropriate to use Internet-Drafts\n          as reference material or to cite them other than as \"work in\n          progress\".\n           \n          To learn the current status of any Internet-Draft, please check\n          the \"1id-abstracts.txt\" listing contained in the Internet-Drafts\n          Shadow Directories on ftp.is.co.za (Africa), nic.nordu.net\n          (Europe), munnari.oz.au (Pacific Rim), ds.internic.net (US East\n          Coast), or ftp.isi.edu (US West Coast). \n\n          Distribution of this document is unlimited. Please send comments\n          to the Distributed Authoring and Versioning (WEBDAV) working\n          group at <w3c-dist-auth@w3.org>, which may be joined by sending a\n          message with subject \"subscribe\" to\n                           <w3c-dist-auth-request@w3.org>.\n\n          Discussions of the WEBDAV working group are archived at\n           <URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\n          The HTTP working group at <http-wg@cuckoo.hpl.hp.com> discusses\n          the HTTP protocol. Discussions of the HTTP working group are\n          archived at\n                    <URL:http://www.ics.uci.edu/pub/ietf/http/>;\n          general discussions about HTTP and the applications which use\n          HTTP should take place on the <www-talk@w3.org> mailing list.\n\n\n\n\n\n          Goland, et al                                                   1\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          Abstract\n\n          WEBDAV (Web Distributed Authoring and Version control) specifies\n          a set of methods and content-types ancillary to HTTP/1.1 for the\n          management of resource meta-data, simple name space manipulation,\n          simple resource locking (collision avoidance) and resource\n          version control.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Goland, et al                                                   2\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n                                  Table of Contents\n\n\n          Status of this Memo ......................                      1\n          Abstract  ...........................                           2\n          1. Introduction ........................                        7\n               1.1 Purpose  .......................                       7\n               1.2 Terminology  .....................                     7\n               1.3 Notational Conventions and Generic Grammar   .....     9\n               1.4 Design Conventions ..................                  9\n          2. Links  ..........................                           11\n               2.1 Introduction ....................                     11\n               2.2 Link Types .....................                      11\n               2.3 LINK ........................                         11\n               2.3.1 Method Definition  ................                 11\n               2.3.2 Request Body ...................                    12\n               2.3.3 Response Body  ..................                   13\n               2.3.4 Error Conditions .................                  13\n               2.5 UNLINK .......................                        13\n               2.5.1 Method Definition  ................                 13\n               2.5.2 Request Body ...................                    13\n               2.5.3 Response Body  ..................                   14\n               2.5.4 Error Conditions .................                  14\n               2.6 LINKSEARCH .....................                      14\n               2.6.1 Method Definition  ................                 14\n               2.6.2 Request Body   ..................                   14\n               2.6.3 Response Body  ..................                   15\n               2.6.4 Error Conditions .................                  16\n               2.6.5 Response Codes   .................                  16\n               2.7 GETLINKS   .....................                      17\n               2.7.1 Method Definition  ................                 17\n               2.7.2 Request Body   ..................                   17\n               2.7.3 Response Body  ..................                   17\n               2.7.4 Response Codes   .................                  17\n               2.8 GETLINKVAL .....................                      17\n               2.8.1 Method Definition  ................                 17\n               2.8.2 Request Body   ..................                   17\n               2.8.3 Response Body  ..................                   17\n               2.8.4 Response Codes   .................                  18\n               2.9 SETLINKVAL .....................                      18\n               2.9.1 Method Definition  ................                 18\n               2.9.2 Request Body ...................                    18\n               2.9.3 Response Body  ..................                   18\n               2.9.4 Response Codes ..................                   18\n          3. Distributed Authoring and Versioning Link Schema .....      18\n               3.1 DAV.Versioning.History ...............                19\n               3.1.1 History Link Definition  .............              19\n               3.1.2 History Link Type  ................                 19\n               3.1.3 Destination Body .................                  19\n\n          Goland, et al                                                   3\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n               3.2 DAV.Versioning.CheckedOut  .............              20\n               3.3 DAV.Versioning.DefaultPublished.   .........          20\n               3.4 DAV.Versioning.NextVersion   ............             20\n               3.5 DAV.SupportedLinkTypes ...............                21\n               3.6 DAV.SupportedLinkSchemas ..............               21\n               3.7 DAV.Source .....................                      21\n          4. Locking  .........................                          21\n               4.1 Introduction ....................                     22\n               4.2 LOCK ........................                         23\n               4.2.1 Method Definition  ................                 23\n               4.2.2 Request Body ...................                    23\n               4.2.3 Response Body  ..................                   24\n               4.2.4 Error Conditions .................                  25\n               4.3 UNLOCK .......................                        25\n               4.3.1 Method Definition  ................                 25\n               4.3.2 Request Body ...................                    25\n               4.3.3 Response Body  ..................                   25\n               4.3.4 Error Conditions .................                  25\n               4.4 Lock Discovery   ..................                   25\n               4.4.1 Lock Discovery via GetLinkVal  ..........           26\n               4.4.2 Lock Discovery Destination Resource  .......        26\n          5. Name Space Manipulation  .................                  26\n               5.1 COPY ........................                         26\n               5.1.1 Method Definition  ................                 26\n               5.1.2 Request Body ...................                    27\n               5.1.3 Response Body  ..................                   28\n               5.1.4 Error Conditions .................                  28\n               5.2 MOVE ........................                         28\n               5.2.1 Method Definition  ................                 28\n               5.2.2 Request Body ...................                    29\n               5.2.3 Response Body  ..................                   30\n               5.2.4 Error Conditions .................                  30\n          6. URI Collections  .....................                      30\n               6.1 URI Collection Behavior  ..............               31\n               6.2 CREATECOLLECTION Method  ..............               32\n               6.2.1 Method Definition  ................                 32\n               6.2.2 Request Body ...................                    32\n               6.2.3 Response Body  ..................                   32\n               6.2.4 Response Codes ..................                   32\n               6.3 ADDRESOURCE  ....................                     32\n               6.3.1 Content Type Definition  .............              32\n               6.3.2 Request Body ...................                    33\n               6.3.3 Response Body  ..................                   33\n               6.4 REMOVERESOURCE ...................                    33\n               6.4 1 Method Definition  ................                 33\n               6.4.2 Request Body ...................                    33\n               6.4.3 Response Body  ..................                   33\n               6.5 PropagateLevel Header  ...............                33\n               6.5.1 Header Definition  ................                 33\n\n          Goland, et al                                                   4\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n               6.5.2 Request Body ...................                    34\n               6.5.3 Response Body  ..................                   34\n          7. Version Control  .....................                      34\n               7.1 Introduction ....................                     34\n               7.2 Versioning Data Model  ...............                35\n               7.3 CHECKOUT ......................                       36\n               7.3.1 Method Definition  ................                 36\n               7.3.2 Checkout Capability Discovery  ..........           37\n               7.3.3 Request Body ...................                    37\n               7.3.4 Response Body  ..................                   38\n               7.3.5 Error conditions .................                  39\n               7.4 CHECKIN  ......................                       40\n               7.4.1 Method Definition  ................                 40\n               7.4.2 Checkin Capability Discovery ...........            40\n               7.4.3 Request-Body ...................                    40\n               7.4.4 Response Body  ..................                   42\n               7.4.5 Error Conditions .................                  42\n               7.5 DIFF/MERGE .....................                      42\n               7.5.1 Introduction ...................                    42\n               7.5.2 SERVERMERGE  ...................                    43\n               7.5.2.1 Method Definition  ...............                43\n               7.5.2.2 Request Body ..................                   43\n               7.5.2.3 Response Body  .................                  43\n               7.5.2.4 Response Codes .................                  44\n               7.6 Command Comments   .................                  44\n               7.7 FREEZE (a.k.a. UNVERSION)  .............              44\n               7.7.1 Method Definition  ................                 44\n               7.7.2 Request Body   ..................                   44\n               7.7.3 Response .....................                      44\n               7.7.4 Error Conditions .................                  45\n          8. Ancillary Methods and Headers  ..............               45\n               8.1 MaxLength Header   .................                  45\n               8.1.1 Header Definition  ................                 45\n               8.1.2 Header Body  ...................                    45\n               8.2 If-Lock Header   ..................                   45\n               8.2.1 Header Definition  ................                 45\n               8.2.2 Header Body  ...................                    45\n               8.3 Command-Comments Header (CCMD) ...........            46\n               8.3.1 Header Definition  ................                 46\n               8.3.2 Header Body  ...................                    46\n               8.4 Overwrite Header ..................                   46\n               8.4.1 Header Definition  ................                 46\n               8.4.2 Header Body  ...................                    46\n          9. Required Features  ....................                     47\n          10. Acknowledgements  ....................                     47\n          11. References  .......................                        47\n          12. Authors' Addresses  ...................                    48\n          APPENDIX  ..........................                          A-1\n               A. Definition of LinkSearch Header ...........           A-1\n\n          Goland, et al                                                   5\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n               B. Definition of LinkPrefix Header ...........           A-1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Goland, et al                                                   6\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          1. Introduction \n\n          [Editor's Note: Method parameter and response packaging is still\n          being debated, as is use of Web Collections; the packaging given\n          in this document should not be considered final or settled.]\n\n\n          1.1 Purpose \n\n          The purpose of this document is to extend the HTTP 1.1 [HTTP11]\n          protocol to support features which satisfy the Distributed\n          Authoring and Versioning requirements set down in [INSERT\n          REFERENCE TO UNIFIED DAV REQUIREMENTS DRAFT].\n\n          1.2 Terminology\n\n          The following entries define how a term is used within this\n          document.\n          Unless otherwise noted, the use of terminology in this document\n          is consistent with the definitions of terms given in [HTTP11]. \n          Editor: Sections references need to be entered.\n          arbiter\n            A resource which performs actions on the behalf of other\n            resources.\n          attribute\n            An attribute is a name/value pair which contains meta-\n            information regarding a resource. See section x.x.\n          attribute set \n            An attribute set is a collection of attributes. See section\n            x.x.\n          set edit announcement\n            A set edit announcement is a declaration by a principal that\n            they intend to edit a resource. No action other than the\n            declaration is implied by a set edit announcement. See section\n            x.x.\n          remove edit announcement\n            A remove edit announcement is a declaration by a principal\n            that they no longer intend to edit a resource. See section\n            x.x.\n          check-out root\n            One or more versioned resources within a particular version\n            tree which are operated on by a CHECKOUT method. \n          command comments \n            Command Comments associate either a string or a URI with an\n            HTTP message. See section x.x.\n          copy \n            A copy performs a duplication of a resource, making it\n            available at both the original and new location in the URI\n            namespace. Due to contextual differences, it may not be\n\n          Goland, et al                                                   7\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n            possible to create an exact copy of a resource. A copy only\n            requires best effort on the part of the copy agent. See\n            section x.x.\n          collection\n            A group of URIs which are manipulated as a unit. See section\n            x.x.\n          destroy \n            To destroy a resource is to request that the resource be\n            permanently removed from storage. This differs from delete in\n            that some versioning systems handle delete as a request to no\n            longer make the specified resource available under the\n            specified URI. See section x.x.\n          diff \n            A diff is a mechanism whereby two or more resources are\n            compared and the differences enumerated. See section x.x.\n          history \n            A history lists the URIs of the versions of a resource along\n            with related information. See section x.x.\n          merge \n            A merge is the process whereby information from multiple\n            resources is folded into a single resource. Merges can occur\n            at the client or the server. See section x.x.\n          move \n            A move is logically an atomic action consisting of a copy\n            followed by a delete of the source resource. Please see the\n            definition of copy in this section. See section x.x.\n          no-modify lock \n            A no-modify lock prevents a locked resource from being edited\n            until all no-modify locks on the resource are released. See\n            section x.x.\n          notify request \n            A notify request instructs the recipient to send information\n            regarding the progress of a request. See section x.x.\n          principal \n            A principal is the source of a message. For example: persons,\n            computers, and programs. \n          read lock \n            A read lock prevents principals who do not posses a read lock\n            on a resource from reading that resource. See section x.x.\n          redirect\n            A redirect instructs a server to return one of the 3xx series\n            codes. See section x.x.\n          relationship \n            A relationship is a unidirectional typed link. See section\n            x.x.\n          shared mode \n            Shared mode modifies a lock request such that the lock may be\n            shared between multiple principals. See section x.x.\n          version identifier\n\n          Goland, et al                                                   8\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n            The identifier used to name a version of a resource. \n          working resource\n            The writeable resource created by some versioning engines as\n            the result of a CHECKOUT method invocation.\n          write lock \n            A write lock prevents principals who do not possess a write\n            lock on a resource from editing that resource. See section\n            x.x.\n\n          1.3 Notational Conventions and Generic Grammar \n\n          This specification uses the Augmented BNF and Basic Rules as\n          defined in Section 2 of [HTTP11]. \n\n          1.4 Design Conventions\n\n          The following design conventions have been adopted by the HTTP\n          Distributed Authoring and Versioning (DAV) group.\n\n               1.   Whenever reasonable new functionality will be expressed\n                    as new methods. When sensible the commands for such a\n                    method will be included in the message body of the\n                    request.\n\n               2.   This resolution was adopted in order to solve a debate\n                    about how to express new functions such as copy and\n                    diff. One group wished to use POST and MIME types to\n                    express new commands. Another group wished to use new\n                    methods and MIME types to express new commands. A third\n                    group wished to use new methods and new method headers\n                    to express new commands. The group settled on using new\n                    methods and MIME types to express new commands. The new\n                    methods would allow for quick parsing by proxies and\n                    servers but the MIME types would allow for flexibility\n                    in specifying the command. It was also felt that\n                    introducing method specific headers would violate the\n                    letter and spirit of the HTTP protocol.\n\n               3.   Methods should only perform a single action.\n\n               4.   The original design of many of the methods in this\n                    document allowed for multiple requests of the same type\n                    to be packaged together. So, for example, one could\n                    send a Copy method which specified that 1000 different\n                    URIs should be copied. It was decided that in the face\n                    of pipelining, compressed headers, and other\n                    innovations there was no need to add this level of\n                    complexity to the protocol. This decision was based\n                    upon the assumption that a new method or MIME type\n\n          Goland, et al                                                   9\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n                    would be introduced which would allow for any number of\n                    HTTP requests to be bundled together. It was further\n                    assumed that such a method or MIME type would carry\n                    with it the option to specify that the contents be\n                    processed atomically.\n\n               5.   URLs are opaque tokens and should be treated as such.\n\n               6.   It is often possible to decrease the number of trips to\n                    retrieve a particular piece of data by putting suffixes\n                    on URLs. However URLs are intended to be opaque tokens.\n                    The above design principal not prevent the use of\n                    suffixes but rather requires that the server indicates\n                    that a particular URL understands a particular type of\n                    suffix.\n\n               7.   Only addressable entities will be subject to the\n                    commands in this document.\n\n               8.   Response must be machine processable. Currently HTTP\n                    responses rely upon humans being available to view the\n                    response and take appropriate action. This level of\n                    error encoding is not sufficient for WEBDAV purposes\n                    where all actions and results of all actions must be\n                    fully machine processable. However, a corollary of this\n                    design principal is that response messages are not\n                    required to provide information about incorrect syntax,\n                    only to point out that incorrect syntax has been\n                    submitted. It is legitimate to assume that the client\n                    and server are both capable of generating proper\n                    syntax. However, this corollary in no way effects the\n                    general principal of being generous in the sorts of\n                    messages accepted.\n\n                    It is sometimes desirable to have a non-addressable\n                    entity. For example, an accept header may specify a\n                    content-language. The response may contain a\n                    representation in that language but may not contain a\n                    content-location header. In that case the\n                    representation of that resource in that language will\n                    not alterable with the commands given in this document.\n           \n\n          2. Links\n\n          2.1 Introduction\n\n          In [HTTP11] link and unlink methods were introduced. The idea was\n          to allow for two or more arbitrary resources to be associated\n\n          Goland, et al                                                  10\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          with each other. In essence, its purpose was to extend the\n          linking facilities available on the Web to all content types, not\n          just HTML.\n          This document proposes a link facility consisting of links which\n          are typed and unidirectional, containing an explicit source and\n          destination.\n\n          2.2 Link Types\n\n          Links are typed. These types explain the purpose and behavior of\n          a link. It is possible that multiple links defined on the same\n          resource may have the same type, e.g., a resource with multiple\n          authors.\n          A link type usually belongs to a link schema, such as the\n          \"LockInfo\" type which belongs to the \"DAV\" schema. By convention,\n          links which belong to a schema are specified as: schema \".\"\n          typename. Thus, the LockInfo type would be specified as\n          \"DAV.LockInfo\". This creates a type namespace which is less\n          susceptable to namespace collision than a single, flat namespace.\n          However, use of the \".\" to denote hierarchy is only a convention,\n          since types are properly considered to be opaque tokens.\n\n          2.3 LINK\n\n          2.3.1 Method Definition\n\n          The LINK method requests that a single typed unidirectional\n          hypertext link be created on the Request-URI. This link consists\n          of three fields, a source URI, a destination URI, and a type,\n          which is an opaque token. The source URI is the beginning of the\n          link, the destination URI is the endpoint of the link, and the\n          type describes the relationship between the source and\n          destination resources. A link may be interpreted as a binary\n          relationship between the source and destination resources, which\n          has the meaning, \"the destination resource contains information\n          of relation <type> to the source resource.\" A link may also be\n          interpreted as an attribute-value pair, where the attribute name\n          is the link type, and the value is pointed to by the destination\n          of the link.\n          The specification of the requested link is made in the message\n          body of the LINK request, which SHOULD be of content type\n          \"application/link\". The source URI of the link will typically\n          correspond to the Request-URI of the LINK request, but MUST not\n          be required to do so. Either the source URI or the destination\n          URI of the link MUST correspond to the Request-URI of the LINK\n          request. This ensures that the Request-URI is part of the link\n          being defined.\n          If the source URI is ommitted in the link specification, the\n          source URI defaults to the Request-URI. If the destination URI is\n\n          Goland, et al                                                  11\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          ommitted in the link specification, the destination URI defaults\n          to the Request-URI. \n          Some servers may automatically allocate part of their namespace\n          for link information of a specific type. For example, the\n          creation date of a resource at URL\n          <http://www.ics.uci.edu/resource.html> might be accessed from\n          <http://www.ics.uci.edu/resource.html?create_date>. In this case,\n          a user-agent would not want to specify the destination of a link\n          of type \"create_date,\" and instead would want the server to\n          automatically fill-in the correct destination URI. If the server\n          should specify the source or destination URI of a link, then the\n          key word \"SET\" is entered for the source or destination URI in\n          the link specification.\n\n          2.3.2 Request Body\n\n          The request body of a LINK method request is of content type\n          application/link, defined as:\n\n          Link = Version CRLF [ Source CRLF ] [ Destination CRLF ] Type\n          CRLF \n          Schema-Version = \"Schema-Version\" \":\" 1*Digit \".\" 1*Digit \n          Source = \"Source\" \":\" ( URI | \"SET\" ) \n          Destination = \"Destination\" \":\" ( URI | \"SET\" ) \n          Type = \"Type\" \":\" token\n          The Schema-Version field specifies the version of the\n          specification of the application/link media type. By definition,\n          the version of the application/link media type specified in this\n          document is \"1.0\".\n\n          Example\n\n          Source: http://www.ics.uci.edu/~ejw/reports/Q1.html \n          Destination: http://www.ics.uci.edu/~ejw/reports/Q1_author.html \n          Type: Author\n          This link states that the destination URI contains information\n          about the author of the source URI. It may also be interpreted as\n          the value of the author attribute of the source URI can be found\n          in the resource pointed to by the destination URI.\n\n\n\n          2.3.3 Response Body\n\n          The request body of a LINK method request is of content type\n          application/linkresult, defined as:\n\n          LinkResult = Version CRLF LinkSource CRLF LinkDestination CRLF\n          Type CRLF \n\n          Goland, et al                                                  12\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          LinkSource = \"Source\" \":\" URI \n          LinkDestination = \"Destination\" \":\" URI \n          Type = \"Type\" \":\" token\n\n          2.3.4 Error Conditions\n          a) there is a syntax error in the application/link message body\n          (e.g., missing field values, missing type value) \n\n          b) the source URI and the destination URI fields are both missing \n\n          c) Both the source URI and the destination URI are specified, and\n          neither match the Request-URI.\n          d) Unsupported Type - The server does not allow links of the\n          specified type to be created. \n\n          e) The server does not have room to store the requested link. \n\n          f) The server is unable to fulfill a request to automatically set\n          an endpoint of the link.\n          2.5 UNLINK\n\n          2.5.1 Method Definition\n\n          The UNLINK method requests the removal of any link defined on the\n          Request-URI which exactly matches the link specification in the\n          request message body, which must be of content type\n          application/unlink.\n\n          If there are any links which exactly match the link\n          specification, a description of the removed links is returned in\n          a response body of type application/unlinkresult.\n          2.5.2 Request Body\n\n          The request body of an UNLINK method request is of content type\n          application/unlink, defined as:\n\n          UnLink = Version CRLF Source CRLF Destination CRLF Type CRLF\n          Schema-Version = \"Schema-Version\" \":\" 1*Digit \".\" 1*Digit \n          LinkSource = \"Source\" \":\" URI \n          LinkDestination = \"Destination\" \":\" URI \n          Type = \"Type\" \":\" token\n          The Schema-Version field specifies the version of the\n          specification of the application/unlink media type. By\n          definition, the Schema-Version of the application/unlink media\n          type specified in this document is \"1.0\".\n\n\n\n\n\n          Goland, et al                                                  13\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          2.5.3 Response Body\n\n          The response body of an UNLINK method is of content type\n          application/unlinkresult, defined as:\n\n          UnLinkResult = Version CRLF 1*(LinkSource CRLF LinkDestination\n          CRLF Type CRLF)\n          Schema-Version = \"Schema-Version\" \":\" 1*Digit \".\" 1*Digit \n          LinkSource = \"Source\" \":\" URI \n          LinkDestination = \"Destination\" \":\" URI \n          Type = \"Type\" \":\" token\n          2.5.4 Error Conditions\n\n          a) there is a syntax error in the application/unlink message body\n          (e.g., missing fields, missing field values, missing type value) \n          b) Both the source URI and the destination URI are specified, and\n          neither match the Request-URI.\n\n          c) No links match the specification in the request message body. \n\n          2.6 LINKSEARCH\n\n          2.6.1 Method Definition \n          The LINKSEARCH method is used to search on the link tuple space.\n          The search occurs in the URI namespace. Search points and scope\n          define the area of name space to be searched. The search points\n          are URIs from which the search should start. The scope defines\n          the number of levels into the URI namespace the search should go\n          down. The search syntax is in prefix notation in order to ease\n          processing by the server.\n\n          2.6.2 Request Body \n\n          The Request-URI is the search arbiter, and it is the job of that\n          resource to process the request and return the results. \n          The media type is application/linksearch.\n\n          This syntax is adapted from [RFC1959] and [RFC1960]. \n\n          LinkSearchMethod = Schema-Version CRLF [SearchPoints] CRLF\n          SearchPattern CRLF Scope CRLF\n          SearchPoints = \"SearchPoints\" \":\" 1#URI \n          SearchPattern = \"SearchPattern\" \":\" 1*SearchOperations\n          SearchOperations = And | Or | Not | Item\n          And = \"&\" 2*SearchOperations\n          Or = \"|\" 2*SearchOperations\n          Not = \"!\" SearchOperations \n          Item = Operator CompareTo MatchPattern\n          Operator = \"=\" | \"!=\"\n\n          Goland, et al                                                  14\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          CompareTo = \"Source\" | \"Destination\" | \"Type\"\n          MatchPattern = 1*(token | \" *\") CRLF \n          Scope = \"Scope\" \":\" 1*Digit | \"Sub\" \n\n          The SearchPoints are URIs on which the search is to be performed.\n          If at least one URI is not listed in SearchPoints then the search\n          point becomes the request-URI. \n\n          The operator is equals \"=\" or not equals \"!=\". Source and\n          Destination equality are dependent upon the type of URIs. Please\n          refer to the definition of the referenced URI type to determine\n          equality rules. The server MUST NOT compare URIs with which it is\n          not familiar. Two types are equal if their tokens are octet for\n          octet equal. \n\n          The MatchPattern allows for wildcard matching. Inserting spaces\n          prevents the wildcard character to not be confused with\n          characters in the token. A wildcard character matches zero or\n          more characters. \n\n          The scope operator specifies how deep into the URI namespace the\n          search should go. A scope of 0 means the search is only on the\n          search point(s). A scope higher than zero means the search should\n          proceed scope levels down the URI namespace. A scope of \"sub\"\n          means the search should go all the way down to the leaves of the\n          namespace. \n\n          Redirects may only be followed if the new location is within the\n          defined search space. \n\n          2.6.3 Response Body\n\n          The response body will be of type text/html and contain a web\n          collection with type \"DAV/LinkSearchResponse\". That web\n          collection will itself contain a series of web collections that\n          have the following definition:\n\n          WC Attributes\n\n          Type = \"DAV/LinkResponse\"\n\n          WCDATA Entry\n\n          Entry = [OnSource] [OnDestination] Type\n          OnSource = [\"ON\"] \"Source\" \":\" URI CRLF\n          OnDestination = [\"ON\"] \"Destination\" \":\" URI CRLF\n          Type = \"Type\" \":\" token CRLF\n\n          Each DAV/LinkResponse indicates the source, destination, and type\n\n          Goland, et al                                                  15\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          of a link result. The \"ON\" tag indicates if the source and/or\n          destination is aware of the link's existence.\n\n          2.6.4 Error Conditions\n\n          Editor: these error conditions will be merged with the response\n          codes in the following section in a future rev. of the document.\n\n          URI Doesn't Exist (From Here on Down) (Incomplete) - \n\n          URI Access is Forbidden (From Here on Down) (Incomplete) - 403\n          Forbidden \n\n          URI Access is Not Allowed (From Here on Down) (Incomplete) - 401\n          Unauthorized \n\n          URI Not Found (From Here on Down) (Incomplete) - 404 Not Found \n\n          Arbiter does not Support Search on this URI (From Here on Down)\n          (Incomplete) - 406 Not Acceptable \n\n          URI does not Support Search (From Here on Down) (Incomplete) -\n          405 Method Not Allowed \n\n          URI has been redirected out of search space (Temporarily |\n          Permanently)(From Here on Down)(Incomplete) - 301 Moved\n          Permanently, 302 Moved Temporarily \n\n          Unknown URI Type in Comparison (Include URI) \n\n          2.6.5 Response Codes \n\n          202 Accepted - The request has been accepted and an appropriate\n          response generated. \n\n          203 Non-Authoritative Information - The request has been accepted\n          but the response may be based on outdated or non-authoritative\n          link information. \n\n          413 Request Entity Too Large - The results of the request are\n          larger than the server is willing to return. The request should\n          be made again using an appropriate range header. No body is\n          returned.\n\n           \n\n\n\n\n\n          Goland, et al                                                  16\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          2.7 GETLINKS \n\n          2.7.1 Method Definition \n\n          GETLINKS is a convenience method that takes a type and returns a\n          webmap containing link tuples whose source or destination equals\n          the Request-URI and whose type matches the submitted typed. \n\n          2.7.2 Request Body \n\n          The media type of the request body is application/GETLINKS.\n\n          GetLinksMethod = Schema-Version CRLF TaggedType CRLF\n          TaggedType = \"Type\" \":\" #type | \"All\"\n          2.7.3 Response Body \n\n          A text/html media type containing a web collection of type\n          DAV/GetLinksResponse that contains DAV/LinkResponse entries.\n          2.7.4 Response Codes \n\n          See the return codes for the LinkSearch method. \n\n           \n\n          2.8 GETLINKVAL\n          2.8.1 Method Definition \n\n          GetLinkVal is a convenience method that takes a type and returns\n          a message/multipart. The first entry in the message/multipart is\n          a Web Collection with link tuples whose source or destination\n          equal the Request-URI and whose type matches the submitted type.\n          The rest of the entries in the message/multipart are the result\n          of a GET submitted on the source or destination of the link that\n          does not equal the Request-URI. \n\n          2.8.2 Request Body \n          The request body for method GETLINKVAL is of content type\n          application/getlinkval, defined below:\n\n          GetLinkValMethod = Schema-Version CRLF TaggedType CRLF \n          2.8.3 Response Body\n\n          The response body is multipart/related. The first entry is of\n          type text/html containing a DAV/GetLinkValResponse Web Collection\n          containing DAV/LinkResponse web collections. Following the\n          text/html is a series of responses containing GET results.\n\n\n\n\n          Goland, et al                                                  17\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          2.8.4 Response Codes \n\n          See return codes for the LinkSearch method. \n          2.9 SETLINKVAL\n\n          2.9.1 Method Definition\n\n          SETLINKVAL is a convenience method that combines LINK and PUT. It\n          is used to create a link and to specify the contents of one end\n          of the link.\n\n          2.9.2 Request Body\n          The request body consists of a MIME multipart. The first entry is\n          the request body contained below which is of type\n          Application/SETLINKVAL. The second entry is the headers and body\n          of the information to be PUT.\n\n          SETLINKVAL = Schema-Version CRLF LINK CRLF PutDestination CRLF ;\n          LINK in Section 2.3.2\n          PutWhere = \"Put-Where\" \":\" \"Source\" | \"Destination\"\n\n          2.9.3 Response Body\n\n          A web collection that contains the results from LINK and PUT.\n\n          2.9.4 Response Codes\n\n          TBD.\n\n\n\n          3. Distributed Authoring and Versioning Link Schema\n\n          This section specifies only those link types which are absolutely\n          necessary to implement the functionality described in this\n          specification. Link types other than the ones described within\n          are possible, but must be defined in other documents. Since there\n          are many different possible relationships which can exist between\n          resources, there are many different link types which can exist to\n          describe these relationships. It is difficult, if not impossible\n          to enumerate and describe all of these relationships, especially\n          since the meaning of the same type may vary depending on usage\n          context. This specification has therefore chosen not to try and\n          enumerate all possible link types, instead providing a mechanism\n          for discovering which link types (DAV.SupportedLinkTypes), and\n          which sets of link types (DAV.SupportedLinkSchemas) are supported\n          on a resource.\n\n          A server is not required to support all of the DAV Link Types.\n\n          Goland, et al                                                  18\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          However, if a server supports a DAV Link Type, it SHOULD maintain\n          the consistency of that relationship by ensuring the contents of\n          the Destination URI are always up-to-date.\n\n          The DAV Link Types specified in this document form the \"DAV\" link\n          schema. \n\n          All DAV schema links have a source URI which is the resource\n          being described by the link. The destination URI alway points to\n          a resource whose content type, and contents are described below\n          for each DAV link type.\n\n          3.1 DAV.Versioning.History\n\n          3.1.1 History Link Definition\n\n          The history link returns information about the history of a\n          versioned document. This information is contained within a DAG\n          that describes the ancestors and children of various versions in\n          the tree. The history link MUST be defined on the tree handle and\n          SHOULD be defined on individual versions. Versions that do not\n          have a history link MUST have a tree link defined on them. \n\n          3.1.2 History Link Type\n\n          The history link has type DAV.Versioning.History.\n\n          3.1.3 Destination Body\n\n          The destination body of the history link is a text/html file\n          containing a series of web collections of type \"DAV/History\".\n\n          WC Tag Attributes:\n\n          Type = \"DAV/History\"\n          Name = VersionToken\n          WCAT Tag Attributes and/or WCDATA Entry:\n\n          Rel = (\"ParentEntry\" | \"ChildEntry\" | \"SiblingEntry\")\n          Version = Token\n          HREF = Pointer to a web collection w/more information\n          Rel = (\"Parent\" | \"Child\" | \"Sibling\")\n          Version = Token\n          HREF = Pointer to a parent, child, or sibling.\n          The Rel/Version/HREF triples above can be used with WCAT or\n          WCDATA. The *Entry links provide pointers to web collections with\n          more information about the family member. The version tag\n          provides the version of the relative being pointed to. The second\n          Rel/Version/HREF triple provides a pointer directly to the\n\n          Goland, et al                                                  19\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          versioned resource. All attributes defined on HCs MAY also be\n          used here to provide information such as creation date, author,\n          owner, etc.\n\n          3.2 DAV.Versioning.CheckedOut\n\n          A server MAY create a link of type DAV.Versioning.CheckedOut on\n          the check out root(s), the working resource, or both. The\n          destination resource of a DAV.Versioning.CheckedOut link is of\n          content type application/checkoutresult, which contains the same\n          information as the response body to the CHECKOUT method.\n          invocation which caused the creation of this link. An optional\n          Web Collection attribute, \"Principal\" may also be included, which\n          holds information about the principal(s) who initiated the check\n          out. \n\n          Principal\n\n          WC Attributes:\n\n                 Type = \"DAV/Identifier\"\n\n          WCDATA Attributes:\n\n                 ContactURI = \"URI\"\n\n          3.3 DAV.Versioning.DefaultPublished. \n\n          A server MAY create a link of type\n          DAV.Versioning.DefaultPublished on the version tree handle and\n          all members of the version tree pointed to by the handle. The\n          destination resource of a DAV.Versioning.DefaultPublished link is\n          a member of the version tree, and points to the version which has\n          been designated as being appropriate for display to non-editors.\n          The DAV.Versioning.DefaultPublished destination resource SHOULD\n          be returned to non-DAV aware clients who perform a GET on a\n          version tree handle.\n\n          3.4 DAV.Versioning.NextVersion \n\n          A server MAY create a link of type DAV.Versioning.NextVersion on\n          a versioned resource. The destination resource of a\n          DAV.Versioning.NextVersion link is the version that immediately\n          succeeds the source. A resource MAY have multiple\n          DAV.Versioning.NextVersion links.\n\n          3.5 DAV.SupportedLinkTypes\n\n          Destination resource content type: Web Collection \n\n          Goland, et al                                                  20\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          Synytax: TBD\n\n          The contents of the destination resource is a list of the link\n          types which the server will definitely allow to be created on the\n          source URI. The server may allow the creation of links with types\n          other than those contained in the destination resource, but this\n          is not guaranteed.\n\n          If a server supports a particular schema, then all link types in\n          the supported schema SHOULD be returned in the destination\n          resource of a SupportedLinkTypes link.\n\n          If a server implements the LINK method, it MUST also implement\n          the SupportedLinkTypes link.\n\n          3.6 DAV.SupportedLinkSchemas\n\n          Destination resource content type: Web Collection \n          Syntax: TBD\n\n          The contents of the destination resource is a list of link\n          schemas. If a link schema is listed, it means that the server\n          SHOULD allow the creation of links with types belonging to that\n          schema. The server may allow the creation of links with types\n          which do not belong to a schema listed in the destination\n          resource, but this is not guaranteed.\n\n          If a server implements the LINK method, it SHOULD also implement\n          the SupportedLinkSchemas link.\n\n          3.7 DAV.Source\n\n          Destination resource content type: varies\n          Syntax: TBD\n\n          The destination URI of a Source link is a location where a\n          user-agent may request the raw data for the source URI, without\n          any source processing by the server (e.g., server-side includes,\n          CGI processing).\n\n\n\n          4. Locking\n\n          4.1 Introduction\n\n          The mechanism for locking and unlocking a resource involves the\n          use of a \"lock token\" (LockToken) which is used to reference the\n          instantiation of the lock. Each lock token instantiates the\n\n          Goland, et al                                                  21\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          occurrence of a lock on one resource or a specified portion of a\n          resource (i.e., a lock on a range of a resource). The locking of\n          multiple resources will cause the instantiation of an equal\n          number of lock tokens. \n\n          Lock tokens represent a lock that is specific to the context of a\n          server and therefore can not be transferred to another server.\n          Nor is it allowable to transfer the LockToken to another \"client\n          space\" even if both are instantiated on the same server. A\n          \"client space\" is defined as the data space in the context of the\n          client obtaining the lock. More than one thread can be active in\n          a given \"client space.\" \n\n          A mechanism is provided to ensure that a method is executed only\n          if a lock is in place. This mechanism allows a lock header to be\n          included in the method request. The method will be executed only\n          if the LockToken is still valid. Multiple LockTokens may be\n          include in the lock header. Lock headers may reference any\n          LockToken allowing the submission of a method on a resource with\n          a LockToken that refers to another resource. \n\n          A lock may designate \"write exclusive\" on a given resource.\n          \"Write exclusive\" is currently the only type of lock supported. A\n          single range for the \"write exclusive\" lock may be defined and\n          overlapping ranges are never allowed. Thus a lock on the entire\n          resource would be exclusive of any and all range locks on the\n          same resource. Multiple range locks may be instantiated for a\n          given resource (even among multiple \"user spaces\"), but\n          overlapping ranges are not permitted. The following table\n          describes the allowable states: \n\n          Request  State     Result\n          full     full      denied\n          full     partial   denied\n          full     none      granted\n          partial  full      denied\n          partial  partial   granted*\n          partial  none      granted\n\n\n          * if no overlap \n\n          Once defined the definition of the lock range may not be\n          modified. The only mechanism supported is to release the lock and\n          instantiate a new lock with a defined range. \n\n          The size of a resource may not be changed within the defined\n          region of a lock range unless the range includes +n (n>0) octets\n          beyond the end of the resource (eof). By definition, locking a\n\n          Goland, et al                                                  22\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          range beyond the eof provides the owner with the ability to add\n          to the eof and therefore extend the resource. \n\n          If an entire resource is locked and the lock owner deletes the\n          resource then the write lock remains. Further actions on the\n          resource (e.g. PUT) are allowed because the LockToken is still\n          instantiated. \n\n          Each lock may have a time out associated with it. If no time out\n          value is associated with the lock then the lock will never time\n          out (implementors should have some mechanism for destroying a\n          lock at an administrative level). Otherwise the lock will expire\n          if the designated amount of time has elapsed without a method\n          being invoked on the resource by the lock owner. The time out\n          value may be modified without affecting the rest of the the lock\n          by submitting a lock request for the LockToken with no other\n          values associated with it other than a new time out value.\n\n          4.2 LOCK\n\n          4.2.1 Method Definition\n\n          [Ed. Note: Need description of LOCK method.]\n\n          The Request-URI of the LOCK method is the URI of the resource to\n          be locked.\n\n          4.2.2 Request Body\n\n          The lock request specifies the target of the lock, parameters of\n          the lock, and requests that a lock be set on the resource. \n\n          The request body of a LOCK method is of content type\n          application/lock, defined as:\n\n\n          LockBody = Schema-Version LockEntry CRLF TimeOut CRLF \n                     [LockRange CRLF] [LockOwner CRLF]\n          LockEntry = \"LockEntry\" \":\" LockWriteExclusive \n          LockWriteExclusive = \"write exclusive\" \n          TimeOut = \"TimeOutSeconds\" \":\" TimeOutVal \n          TimeOutVal = 1*digit | \"Infinite\" \n          LockRange = \"LockRange\" \":\" 1*digit \"-\" (1*digit | \"eof++\") \n          LockOwner = \"LockOwner\" \":\" URI\n          Example: \n\n          LOCK /users/johndoe/davspec.html HTTP/1.1\n          Content-Type: application/lock\n          Schema-Version: 1.0\n\n          Goland, et al                                                  23\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          LockEntry: write exclusive \n          TimeOut: 2400 \n          LockRange: 100-eof++ \n          LockOwner: mailto:johndoe@foo.com \n\n          4.2.3 Response Body\n          The response body of a LOCK method is of content type\n          application/LockResponse, defined below. The syntax of this\n          content type is that of a Web Collection.\n\n\n          ResourceLockResponse = WC_Open LockResponse WC_Close \n          WC_Open = \"<\"WC VERSION=<\">1.0<\"> TYPE=\"\n          (\"DAV/Lock\"|\"DAV/Unlock\") \n                    \"<\">NAME=<\">\" LockToken \"<\">>\" \n          LockToken = token\n\n          LockResponse = *WCAT LockData *WCAT \n          LockData = \"<WCDATA>\" LockURI LockBody LockGranted \"</WCDATA>\"\n                      ; LockBody production from Section 4.2.2\n\n          LockURI = \"ResourceLocked\" \":\" URI\n          LockGranted = \"LockGranted\" \":\" RFC1123-date [*digit]  ;*digit\n          for milliseconds\n          WC_Close = \"</WC>\" \n          Example:\n\n          This is a possible response body from the lock request example in\n          Section 4.2.2.\n\n          <WC VERSION=\"1.0\" TYPE=\"DAV/Lock\" NAME=\"LK_Xj5N75\">\n          <WCDATA>\n          ResourceLocked: http://www.foo.com/users/johndoe/davspec.html\n          Schema-Version: 1.0\n          LockEntry: write exclusive \n          TimeOut: 2400 \n          LockRange: 100-eof++ \n          LockOwner: mailto:johndoe@foo.com \n          LockGranted: Thu, 23 Jan 1997 15:11:27 GMT\n          </WCDATA>\n          </WC>\n          4.2.4 Error Conditions\n\n          Lock already owned: \n          Lock range overlaps: \n          Invalid range: \n          Resource not found: \n          Denied: \n          General Failure: \n\n          Goland, et al                                                  24\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n           \n\n          4.3 UNLOCK\n\n          4.3.1 Method Definition\n\n          [Ed. Note: Need description of Unlock method]\n\n          The Request-URI of the UNLOCK method specifies the URI of the\n          resource to be unlocked.\n\n          4.3.2 Request Body\n\n          The request body of an UNLOCK method is of content type\n          application/unlock, defined below:\n\n          UnlockRequest = Schema-Version UnLockToken\n          UnLockToken = \"UnLock-Token\" \":\" LockToken \n          4.3.3 Response Body\n\n          The response body of an UNLOCK method is of content type\n          application/UnlockResult, which is defined by the production\n          ResourceLockResponse, defined in Section 4.2.3.\n          4.3.4 Error Conditions\n\n          Lock not found: \n          Lock not owned: \n          Lock timed out: \n          Denied: \n          General Failure:\n\n           \n\n          4.4 Lock Discovery \n\n          [Ed. Note: \"LockInfo\" link and associated \"LockDiscovery\" WC\n          should be included in the section on DAV Link Schema links]\n\n          4.4.1 Lock Discovery via GetLinkVal\n\n          When a lock is taken out the system SHOULD record who owns the\n          lock. Ownership information can be taken from the From header,\n          from identification provided by authentication, or from the\n          LockOwners field. \n\n          Lock Discovery is enabled via a DAV Schema link of type\n          DAV.LockInfo. Lock Discovery is performed by using the GetLinkVal\n          method on links of this type.\n\n\n          Goland, et al                                                  25\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          The LockInfo Link is structured as:\n\n            src = URI of the resource\n            dest = URI of the lock discovery WC\n            type = \"LockInfo\" \n\n          4.4.2 Lock Discovery Destination Resource\n\n          The DAV.LockInfo destination resource is of content type\n          text/html, which uses the Web Collection syntax:\n\n          LockDiscoveryResponse = WC_Open LockResponse OtherFields WC_Close\n\n          WC_Open = \"<\"WC VERSION=<\">1.0<\"> TYPE=<\">DAV/LockDiscovery<\">\n                    NAME=<\">\" LockToken \"<\">>\"\n          LockResponse = *WCAT LockData *WCAT \n          LockData = \"<WCDATA>\" LockBody LockGranted \"</WCDATA>\" \n          LockGranted = RF1123-date [*digit] \n          OtherFields = (implementation specific) * \n          \"Owner\" \":\" 1*octet ** \n          WC_Close = \"</WC>\" \n          * not negotiable, safely dropped by client \n          ** if available \n\n           \n\n          5. Name Space Manipulation\n\n          5.1 COPY\n\n          5.1.1 Method Definition\n\n          This method requests the server to manipulate the mapping for the\n          resource in the namespace such that a new location (mapping) is\n          created for the Request-URI in the namespace, while maintaining\n          the existing location (mapping) in the namespace. The actual\n          implementation is left to the discretion of the server. The\n          presence of hyperlinks within a resource creates special problem\n          in Web resources. The fact that these hyperlinks could be either\n          absolute or relative create yet another level of complexity.\n\n          The Request-URL will be the URL for the source resource which\n          will be copied to the destination. In case of a versioned\n          resource, depending on the implementation, it may be either the\n          root of the version tree, in which case it may mean to copy the\n          whole tree or a specific version (depending on the value of\n          request-version), or it may be the version tree history. In case\n          of non-versioned resource, it will refer to the resourse itself.\n\n\n          Goland, et al                                                  26\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          The message body will contain the URL of the destination of the\n          COPY. The OVERWRITE header, as defined by this spec., defines the\n          behavior of the server if a resource already exists as referred\n          to by destination URL. If the value of the overwrite header is\n          true (default), then any existing resource referenced by the\n          destination URL will be overwritten. If the value of overwrite\n          header is false then the copy will fail when the URL of an\n          existing resource matches that of the destination URL. In case of\n          non-versioned collections, COPY can be used as one of the ways to\n          add to the collection.\n\n          5.1.2 Request Body\n\n          The information about the destination and the switch to determine\n          if the links need to copied as well, will be passed in the\n          message body which should be of the content type\n          \"application/copy\". Also defined in the body is a switch called\n          \"copylink\". If the value of this switch is set to true, then the\n          server should copy all the links that it deems pertinent. This\n          spec. leaves it to the discretion of the server to determine\n          which links are or are not appropriate in the context of copy.\n          When links are copied the following condition MUST be met: \n\n            The types of the links should be maintained across the copy. \n\n            If the source field of a link matches Request-URI, then the\n               source field of the link on the copy destination should be\n               destination URI. \n\n          The defination of the content type Application/Copy is as\n          follows:\n\n            copy = Schema-Version CRLF destination CRLF copylink CRLF\n            [request-version CRLF]\n            Schema-Version = 1*DIGIT \".\" 1*DIGIT\n            destination = \"destination\" \":\" URI\n            copylink = \"copylink\" \":\" value\n            value = \"true\" | \"false\"\n            request-version = \"Request-Version\" \":\" token\n          Note: COPY and Version Trees\n\n            The request-version token may be used to refer to a\n            versioned resource by its version ID, in which case the\n            Request-URI must point to the version tree handle. If the\n            Request-URI points to the version tree handle and the\n            request-version field is not provided, then the whole tree\n            will be copied to the new location.\n\n            The following rules apply when a versioned resource is\n\n          Goland, et al                                                  27\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n            invloved in a copy operation:\n\n               A versioned resource can be copied into a non-versioned\n                 space. \n\n               A versioned resource cannot be copied into another\n                 versioned resource. \n\n               A non-versioned resource cannot be copied into a\n                 versioned resource. \n\n          5.1.3 Response Body\n\n          The response body returns the status code back.\n\n          5.1.4 Error Conditions\n\n          The following status codes may be returned:\n\n          OK - The server has successfully copied the resource, and all the\n          links, if applicable, to the new location in the namespace.\n\n          Copy failed due to some internal error:\n\n            The source is missing\n            The desitination exists (and the overwrite switch is false)\n            One or more links (in case copylink switch is true) failed\n            to copy due to some internal error.\n\n\n\n          5.2 MOVE\n\n          5.2.1 Method Definition\n          This method requests the server to manipulate the\n          resource/namespace mapping; a new location (mapping) is created\n          for the Request-URI in the namespace, and the existing location\n          (mapping) in the namespace is removed. The actual implementation\n          is left to the discretion of the server.\n\n          Move can be considered as an atomic, logical operation combining\n          a COPY followed by a DELETE on the source URI. This means MOVE\n          inherits all the complexities of COPY operation, and add a few\n          more of its own due to the fact that it changes the resource\n          location in the namespace.\n\n          For instance: from the perspective of the client, a MOVE on a\n          resource may result in a REDIRECT to the new location namespace.\n          WEBDAV does not require a server to issue a redirect on \"moved\"\n\n          Goland, et al                                                  28\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          URIs in order to be compliant, but one might argue that some sort\n          of discovery for \"server capability\" be provided.\n\n          Also there is an issue of \"level of intelligence\" of move. One\n          argument is that due to the special nature of HTML media types,\n          move should automatically perform some link management on links\n          after a MOVE. While it is impossible to manage all links pointing\n          to a resource due to lack of control over all of the links\n          pointing to the resource, it is conceivable that links from a\n          resource, and links within a resource might be manageable. The\n          opposing argument to this is that allowing a move operation to\n          have side-effects which could modify the resource being moved -\n          or worse yet modify resources which were not being moved - can\n          have unexpected consequences. It is important to know the\n          consequences of an operation before executing the operation.\n          WEBDAV is silent on MOVE/link interaction issues, specifying a\n          simple MOVE with a discoverable list of links to be moved with\n          the resource. Beyond that WEBDAV does not make any recommendation\n          or suggestions about the actual implementation of the MOVE\n          operation.\n\n          In case of non-versioned collections, move can be used as one of\n          the ways to add to the collection.\n\n          5.2.2 Request Body\n\n          This section defines the content type application/move.\n          Move = Schema-Version CRLF destination CRLF movelink CRLF\n          [request-versionCRLF]\n          Schema-Version = 1*DIGIT \".\" 1*DIGIT\n          destination = \"destination\" \":\" URL\n          movelink = \"movelink\" \":\" value\n          value = \"true\" | \"false\"\n          request-version = \"Request-Version\" \":\" token\n\n          Note: COPY and Version Trees\n\n            The request-version token may be used to refer to a\n            versioned resource by its version ID, in which case the\n            Request-URI must point to the version tree handle. If the\n            Request-URI points to the version tree handle and the\n            request-version field is not provided, then the whole tree\n            will be moved to the new location.\n\n            The following are the rules that apply when a versioned\n            resource is invloved in a move operation:\n\n               A versioned resource can be moved into a non-versioned\n                 space. \n\n          Goland, et al                                                  29\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n               A versioned resource cannot be moved into another\n                 versioned resource. \n\n               A non-versioned resource cannot be moved into a versioned\n                 resource. \n\n          5.2.3 Response Body\n\n          The response body returns the status code.\n\n          5.2.4 Error Conditions\n\n          The following status codes may be returned:\n\n          OK - The server has successfully moved the resource, and all the\n          links, if applicable, to the new location in the namespace. \n\n          Move failed due to some internal error:\n\n            The source is missing \n\n            The desitination exists (in case overwrite switch is false) \n\n            One or more links (in case movelink switch is true) failed to\n               move due to some internal error. \n\n\n\n\n\n          6. URI Collections\n\n          6.1 URI Collection Behavior\n\n          According to The Random House College Dictionary - Revised\n          Edition, Collection is defined as \"2. Something that is\n          collected, as a group of objects...\" In the most generic sense a\n          URI Collection brings together a group of URIs and provides\n          information about them. This specification will not be defining\n          such a collection, mostly because it is a pretty idea with no\n          where to go. At least for now. In the future systems will be\n          available that will be able to make profitable use of a generic\n          collection. For now this specification defines the Hierarchical\n          Collection (HC). The HC is meant to walk, talk, and look just\n          like a directory in a file system. URIs are added to an HC as\n          either relative or absolute. All relative URIs in an HC are\n          relative to the Request-URI. This restriction is in place in\n          order to replicate normal file system behavior. Thus if the\n          collection is copy, moved, or otherwise manipulated within the\n\n          Goland, et al                                                  30\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          name space it will be possible to copy, move, etc. its component\n          parts. This behavior is referred to as propagation. The idea is\n          that a command executed on the collection can be propagated to\n          all the relative URIs. The PropagateLevel header controls\n          propagation behavior. This header specifies the number of levels\n          a command should be propagated. Absolute URIs are added as links\n          and thus commands are not propagated through them. Thus, if a\n          collection is copied, the COPY method will be executed on all the\n          relative URIs but not on the absolute URIs. Of course all the\n          absolute URI entries will still be members of the collection,\n          they simply won't have the COPY method executed on them. \n\n          Executing the MAKECOLLECTION method creates HCs. This is the same\n          as executing a MKDIR on a file system. If a MAKECOLLECTION is\n          executed on a Request-URI which is not itself a member of a\n          collection then either the system will automatically create all\n          the necessary collections or it will reject the method. Once the\n          collection is created any URI PUT under the collection's\n          namespace will \"magically\" appear inside the collection. Again,\n          this behavior mimics that of a normal file system. Adding a\n          relative URI directly to a collection will either be rejected or\n          cause a NULL file to appear. Removing a URI directly from a\n          collection will cause a link to disappear in the case of an\n          absolute URI or will cause the file to be deleted in the case of\n          a relative URI.\n\n          6.2 CREATECOLLECTION Method\n\n          6.2.1 Method Definition\n\n          The CREATECOLLECTION method indicates to the server that the\n          clients wishes a specified URI to act as a collection.\n\n          6.2.2 Request Body\n\n          The contents of message/collection identify what sort of\n          collection is being created. This document defines the\n          Hierarchical Collection (HC). A HC only supports a hierarchical\n          name space and is meant to replicate the behavior of a file\n          system directory.\n\n          A HC contains URIs. URIs may be entered as relative or absolute.\n          Relative URIs must be relative to the request-URI. A relative URI\n          is a propagate entry. If a PropagateLevel header is included with\n          a method executed on a HC then the method will be propagated\n          through all relative URIs. Absolute URI entries do not propagate.\n\n          MessageCollection = Version CRLF CollectionType CRLF\n          CollectionType = \"Collection Type\" \":\" (\"HC\" | Text)\n\n          Goland, et al                                                  31\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          6.2.3 Response Body\n\n          CREATECOLLECTIONERROR = WC_OPEN Type WC_CLOSE\n          ContentError = \"DAV/Error/CreateCollection\"\n          Type = \"Do Not Support Type\" \":\" (\"HC\" | Text)\n\n          6.2.4 Response Codes\n\n           \n\n          6.3 ADDRESOURCE\n\n          Editor: this section needs to incorporate the correct text from\n          Yaron.\n\n          6.3.1 Content Type Definition\n\n          This content type is used to add a link to a collection. In the\n          case of an HC most systems will not accept a relative URI.\n          Rather, to add a new entry to an HC, the resource should be\n          created using a PUT or similar method. If the server does accept\n          a relative URI for an HC then the result SHOULD be the creation\n          of an empty resource.\n\n          6.3.2 Request Body\n\n          AddResource = Version CRLF URIType CRLF URIEntry CRLF\n          URIType = \"Type\" \":\" (\"Relative\" | \"Absolute\")\n          URIEntry = \"URI\" \":\" (relativeURI | absoluteURI)\n\n          URIType indicates the type of URI while URIEntry indicates the\n          actual URI. URIType is included for negotiation purposes. If the\n          URI is relative then it is relative to the request-URI. The\n          productions relativeURI and absoluteURI are defined in section\n          3.2.1 of rfc2068.\n\n          6.3.3 Response Body\n\n          The content type of the response body is text/HTML and contains a\n          Web collection.\n\n           \n\n          6.4 REMOVERESOURCE\n\n          6.4 1 Method Definition\n\n          This content type is used to remove a URI from a collection. In\n          the case of an HC most systems will not accept a relative URI.\n\n          Goland, et al                                                  32\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          Rather, to delete an HC entry, the resource should be DELETEd or\n          DESTROYed. If the server does accept a relative URI for an HC\n          then the result SHOULD be the deletion of the resource.\n\n          6.4.2 Request Body\n\n          RemoveResource = AddResource\n\n          6.4.3 Response Body\n\n          The content type of the response body is text/HTML and contains a\n          Web collection.\n\n           \n\n          6.5 PropagateLevel Header\n\n          6.5.1 Header Definition\n\n          The PropagateLevel header controls how many levels a method will\n          be propagated down a collection. Zero means the method should\n          only be executed on the collection. Infinity means the method\n          should be propagated as far down as possible. A loop is\n          impossible with HCs because its name space is a tree and absolute\n          URIs do not propagate. Other collection types will have to define\n          their own mechanisms to detect and prevent loops.\n\n          6.5.2 Request Body\n\n          PropagateLevel = \"PropagateLevel\" \":\" (1*Digit | \"Infinity\")\n\n          6.5.3 Response Body\n\n          The following web collection can be included in any web\n          collection based body.\n\n          WC Attributes\n\n          Type = \"DAV/Error/Prop/FailedAt\"\n\n          WCDATA Entry\n\n          Entry = \"Propagation Mechanism Failed at\" \":\" *(Relative |\n          Absolute_URI CRLF)\n          Relative = \"Base\" \":\" Absolute_URI \"Relative\" \":\" *Relative_URI\n          CRLF\n\n           \n\n\n          Goland, et al                                                  33\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          7. Version Control\n\n          7.1 Introduction\n\n          This specification provides interface definitions which clients\n          may use to perform the common versioning operations check in,\n          check out, version history retrieval, and merge. A fundamental\n          assumption of this specification is that the semantics of\n          versioning operations are defined by the server, and may vary\n          from server to server, depending on the versioning engine\n          employed. As a consequence, this specification provides a common\n          interface for accessing the functionality of many different\n          versioning engines. \n\n          Since versioning functionality may vary from server to server, or\n          even in different namespaces on the same server, a discovery\n          mechanism is provided for clients to determine precisely what\n          effect a CHECKOUT or a CHECKIN method invocation will have on the\n          state of the server. A client may query the server for its\n          CHECKIN and CHECKOUT semantics by retrieving the destination\n          resource of the DAV.Discovery.CHECKOUT and DAV.Discovery.CHECKIN\n          links. It is expected that a client will query the value of the\n          DAV.Discovery.CHECKOUT link before performing a check out, and\n          the DAV.Discovery.CHECKIN link before performing a check in, so\n          it knows exactly what will occur when it issues the CHECKOUT or\n          CHECKIN request. \n\n          Similarly, the who and when of setting a version identifier\n          varies significantly: \n\n            1.      A version identifier MAY be specified by the client\n               upon check out. \n\n            2.      Upon check out, the server MAY accept the client\n               version identifier, or the server MAY assign a version\n               identifier, or the server MAY not assign any version\n               identifier. \n\n            3.      If the version identifier has not already been set, the\n               client MAY specify a version identifier upon check in. \n\n            4.      Upon check in, the server MAY accept the client version\n               identifier, otherwise the server MUST assign a version\n               identifier unless one has already been assigned (e.g.,\n               during check out).\n\n          7.2 Versioning Data Model\n\n          A version tree is a directed acyclic graph of versioned\n\n          Goland, et al                                                  34\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          resources. Arcs in the version graph indicate \"is-version-of\" (or\n          \"is-successor-of\") relationships. Each versioned resource is a\n          first-class resource, addressable by a URI. A version tree MUST\n          have a handle resource, known as the version tree handle, which\n          is used to refer to the version tree as a whole. The contents of\n          the handle resource MUST be a single URI (a pointer), which is\n          used by the versioning engine to identify the version tree as a\n          whole. The version handle resource MAY point to either the root\n          object of the version tree, or the history resource for the\n          version tree. \n\n          The version tree handle MUST have server generated links of type\n          DAV.Versioning.DefaultPublished, DAV.Discovery.CHECKIN, and\n          DAV.Discovery.CHECKOUT, and MAY have a server generated link of\n          type History. Each versioned resource MAY have server generated\n          links of the following types: DAV.Versioning.History,\n          DAV.Versioning.DefaultPublished, DAV.Versioning.NextVersion,\n          DAV.Discovery.CHECKOUT, DAV.Discovery.CHECKIN. \n\n            The destination resource of the DAV.Versioning.History link\n               SHOULD describe the version tree, and contain comment\n               information. \n\n            The destination of the DAV.Versioning.DefaultPublished link,\n               if this link exists, points to the version which should be\n               returned by default if a GET is performed on the version\n               tree handle URI by a DAV unaware client. \n\n            The destination URI of the each DAV.Versioning.NextVersion\n               link, if any such links exist, MUST point to a successor\n               resource in the version tree. \n\n            The destination resource of the DAV.Discovery.CHECKOUT link,\n               if this link exists, must contain information describing the\n               capabilities of the CHECKOUT method as implemented by the\n               server on the source resource. \n\n            The destination resource of the DAV.Discovery.CHECKIN link, if\n               this link exists, must contain information describing the\n               capabilities of the CHECKIN mtethod as implemented by the\n               server on the source resource. \n\n          Versioning is an orthogonal issue to content negotiation. Each\n          particular variant of a resource MAY be independently versioned,\n          and MAY have its own version tree. \n\n          TBD: A Figure showing a sample version tree (using text\n          characters)\n\n\n          Goland, et al                                                  35\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n           \n\n          7.3 CHECKOUT\n\n          7.3.1 Method Definition\n\n          A CHECKOUT is a declaration by a client that it might edit a\n          versioned resource. The CHECKOUT method is intended to map to the\n          notion of check out supported by the server's versioning engine.\n          The Request-URI of the check out method is a version tree handle,\n          which identifies the version tree on which the CHECKOUT will be\n          performed. \n\n          A server MAY create a working resource as the result of a check\n          out. If the server creates a working resource, it MUST return the\n          URI of this resource in the response body. \n\n          All of the activity which occurs during CHECKOUT method\n          invocation MUST be performed atomically. \n\n          7.3.2 Checkout Capability Discovery\n\n          Editor: this section will be subsumed by a more general method\n          discovery mechanism.\n\n          7.3.3 Request Body\n\n          The request body of the CHECKOUT method is of content type\n          application/checkout, defined as: \n\n          Checkout        = Schema-Version CRLF [Derived-From CRLF]\n          [Request-Version CRLF]\n                            [Request-Lock CRLF] [Request-Intent CRLF] \n                            [Request-Working-Loc CRLF] [Request-Visibility\n          CRLF]  \n          Schema-Version  = \"Schema-Version\" \":\" 1*DIGIT \".\" 1*DIGIT\n\n          Derived-From    = \"Derived-From\" \":\" #token\n\n          Request-Version = \"Request-Version\" \":\" token\n\n          Request-Lock    = \"Request-Lock\" \":\" \"Exclusive\" \"Write\"\n\n          Request-Intent  = \"Request-Intent\" \":\" (\"true\" | \"false\")\n\n          Request-Working-Loc = \"Request-Working-Loc\" \":\" (\"Client\" |\n          \"Server\")\n\n          Request-Visibility = \"Request-Visibility\" \":\" Visible-When\n\n          Goland, et al                                                  36\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          [Visible-Where]\n          Visible-When    = (\"Always\" | \"If_Locked\" | \"Never\") \n          Visible-Where   = (\"On_CheckOut_Root\" | \"On_Working\" | \"On_Both\")\n\n          The Schema-Version is the version number of the syntax\n          specification of the application/checkout content type. \n\n          Derived-From specifies the version identifier of the check-out\n          root(s) from which the working resource (if it exists) is\n          derived. If more than one version identifier is specified in the\n          Derived-From value, the working resource MAY be the result of a\n          merge of the specified versions, and the exact semantics of this\n          merge operation will vary across versioning engines. \n\n          Request-Version specifies a client's request to set the version\n          identifier of the working resource. The server MAY set the\n          version identifier of the working resource to this value. If this\n          field is omitted from the request message body, the server MAY\n          perform a check out from a default check out root (often the\n          latest version). \n\n          Request-Lock is used by the client to request a lock when a\n          server supports optional locking on check out.\n\n          Request-Intent is used by the client to request the server to\n          establish an intent to edit on check out. An intent to edit MAY\n          result in the association of authentication or user information\n          with either the check out root, or the working resource. \n\n          Request-Working-Loc is used by the client to request where the\n          working resource is located. If the client specifies \"Client,\"\n          then the server SHOULD not create a working resource on the\n          server. If the server does not create a working resource on the\n          server, the client SHOULD retrieve its working resource from the\n          check out root after successful completion of the CHECKOUT. If\n          the client specified \"Server,\" then the server SHOULD create a\n          working resource on the server.\n\n          Request-Visibility is used by the client to request whether to\n          create a DAV.Versioning.CheckedOut link, and the resource which\n          will store the link. Visible-When describes whether the\n          DAV.Versioning.CheckedOut link SHOULD always be created\n          (\"Always\"), SHOULD only be created if the check out performs a\n          lock (\"If_Locked\"), or SHOULD never be created (\"Never\").\n          Visible-Where describes where the link SHOULD be stored: on the\n          check out root (\"On_CheckOut_Root\"), on the working resource\n          (\"On_Working\"), or on both the check out root and the working\n          resource.\n\n\n          Goland, et al                                                  37\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          7.3.4 Response Body\n\n          The response body of a CHECKOUT method invocation is of content\n          type application/checkoutresult, defined as: \n\n          CheckoutResult     = WC-Open CheckoutResultData WC-Close\n\n          WC-Open            = \"<WC VERSION =<\">1.0<\"> TYPE\n          =<\">DAV/CheckoutResult<\">>\"\n\n          CheckoutResultData = *WCAT WCCheckoutData WCAT\n\n          WCAT               = {arbitrary, server-defined Web Collection\n          attributes}\n\n          WCCheckoutData     = \"<WCDATA>\" DerivedTree DerivedRoot [WorkURI]\n\n                               [WorkVersion] [Visibility]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Derived-Tree is the location of the version tree handle on which\n          the check out was performed. \n\n          Derived-Root is the location of the (possibly many) versioned\n          resources on which the check out operation was performed. \n\n          WorkURI is the location of the working resource generated by the\n          server on check out, if it exists. \n\n          WorkVersion is the version identifier of the working resource, if\n          it was set on check out. \n\n          Visibility is the location where the client can retrieve the\n          DAV.Versioning.CheckedOut link.\n\n\n\n\n          Goland, et al                                                  38\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          7.3.5 Error conditions\n\n          An error condition occurs if the following conditions hold: \n\n          If a client requests a version identifier on check out, but the\n          server:\n          a) cannot set a version identifier\n          b) refuses to set a version identifier \n\n          If a client requests a lock, but the server doesn't support\n          locking. \n\n          If the client requests an intent to edit, but the server doesn't\n          support intent to edit. \n\n          If the client doesn't specify a Derived-From version, and the\n          server has no default value. \n\n          Syntax error in the request body. If a client requests a feature\n          the server doesn't support then it has committed a syntax error\n          because the discovery told the client what the server supports.\n\n           \n\n          7.4 CHECKIN\n\n          7.4.1 Method Definition\n\n          A CHECKIN is a declaration by a client that it wishes to place a\n          resource under version control. The CHECKIN method is intended to\n          map to the notion of check in supported by the versioning engine.\n          The Request-URI for a CHECKIN method invocation is the version\n          tree handle of the version tree which is being operated on. \n\n          A check in SHOULD clear any server state which is set as a result\n          of a check out. For example, if a server locks a resource on\n          check out, it should remove the lock upon check in. \n\n          To place a resource under version control for the first time, a\n          check in is performed on the resource. In this case, the Request-\n          URI is the desired location of the version tree handle, and the\n          Working-URI or the check in body gives the contents of the\n          resource to be placed under version control. \n\n          All of the activity which occurs during CHECKIN method invocation\n          MUST be performed atomically. \n\n\n\n\n          Goland, et al                                                  39\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          7.4.2 Checkin Capability Discovery\n\n          Editor: this section will be subsumed by a more general purpose\n          discovery mechanism\n\n          7.4.3 Request-Body\n\n          The request body of a CHECKIN method invocation MUST be in one of\n          two forms: \n\n            1.      An entity of content type application/checkin \n\n            2.      An entity of content type multipart/related, with two\n               parts, an entity of content type application/checkin, and a\n               second entity, of any content type, containing a check in\n               body. \n\n          If the request-body is of content type multipart/related, the\n          checkin operation is defined to be a PUT of the checkin entity\n          body (into a server-dependent temporary resource), followed by a\n          CHECKIN. \n\n          The definition of content type application/checkin is: \n\n          CheckIn          = Schema-Version CRLF [Derived-From CRLF]\n\n                             [Working-Resource CRLF] [Request-Version CRLF] \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          The Schema-Version is the version number of the syntax\n          specification of the application/checkout content type. \n\n          Derived-From specifies the version identifier of the check-out\n          root(s) from which the working resource (if it exists) is\n          derived. If more than one version identifier is specified in the\n          Derived-From value, the checked-in resource MAY be entered as the\n          successor of the Derived-From resources. \n\n          Goland, et al                                                  40\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          Request-Version specifies a client's request to set the version\n          identifier of the check in resource. The server MAY set the\n          version identifier of the check in resource to this value. If\n          this field is omitted from the request message body, the server\n          MUST set the version identifier if it has not previously been\n          set. \n\n          Working-Resource specifies a URI or a version identifier of the\n          working resource which is to be checked-in. If the value is\n          \"BODY,\" the working resource is contained in the check in body.\n\n          Open issues: 1 - If a version has multiple parents the client\n          wants to know where the version links will go. If the system\n          supports multiple inheritance then that needs to be stated. If\n          the system only supports single inheritance then the client needs\n          to know, before hand, which version the new version will be\n          linked to. 2 - The syntax allows a client to specify different\n          derived-from resources on Check In then were listed on Check Out.\n          Somewhere there is a versioning system that doesn't allow this.\n          The client needs to know this fact before performing the check\n          out.\n\n          7.4.4 Response Body\n\n          There is no response body defined for the CHECKIN method. \n\n          7.4.5 Error Conditions\n\n          If the Derived-From token(s) do not exist, \n\n          If the working URI is not located on this server, or the server\n          is not authorized to retrieve the working URI. \n\n          If the PUT of the checkin entity body fails. \n\n          Syntax error in the request body. \n\n           \n\n          7.5 DIFF/MERGE\n\n          7.5.1 Introduction\n\n          The request-URI of the DIFF method is an arbiter. The arbiter\n          will compare the entries and return the differences between them.\n\n          The request-URI of the MERGE method is also an arbiter. The\n          arbiter will combine the entries and return the result.\n\n\n          Goland, et al                                                  41\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          The Application/Diff content-type works with the DIFF method. The\n          Application/Merge content-type works with the Merge method.\n\n          Application/Diff = Body\n          Application/Merge = Body\n          Body = 1#(\"URI\" \":\" URI | \"Entity\" \":\" entity-body) \n\n           \n\n          7.5.2 SERVERMERGE\n\n          7.5.2.1 Method Definition\n\n          The SERVERMERGE method requests that the server merge a number of\n          entities on behalf of the client. The request-URI is a server\n          side arbiter who performs the merge on behalf of the client.\n\n          7.5.2.2 Request Body\n\n          The request body may take on one of two possible formats. One\n          format is application/servermerge, which is defined below. The\n          second format is message/multipart related which will contain an\n          entry of type application/servermerge as well as entities for the\n          server to merge.\n\n          Type = application/servermerge\n\n          Merge = Schema-Version CRLF MergeType CRLF [MergeEntities CRLF] \n                  ReturnType CRLF [ReturnURI CRLF]\n          MergeType = \"Merge Types\" \":\" (\"URIs\" | \"Bodies\" | \"URIs\"\n          \"Bodies\")\n          MergeEntities = \"Merge Entries\" \":\" #URI\n          ReturnType = \"Return Result\" \":\" (\"URI\" | \"Body\")\n          ReturnURI = \"Return Location\" \":\" URI\n          MergeType specifies what mechanisms are being used to refer to\n          bodies to be merged. URIs means that a MergeEntities has been\n          included while Bodies indicates that one or more\n          message/multipart related have been included. ReturnType\n          specifies how the results are to be returned, either as part of\n          the response or recorded in a URI. ReturnURI specifies the URI\n          for the result to be recorded in if the user selects that return\n          mechanism. A server MAY support any combination of values for\n          MergeType and ReturnType. It MUST provide for discovery of\n          supported values.\n\n          7.5.2.3 Response Body\n\n          Only support # bodies to be merged\n\n\n          Goland, et al                                                  42\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          Can not resolve URI \n\n          Can not store in URI\n\n          Can not merge included types\n\n          Merge Failed\n\n          Merge Succeeded\n\n          7.5.2.4 Response Codes\n\n          [Will fold in from above.]\n\n           \n\n          7.6 Command Comments \n\n          Command comments are entity headers. \n\n          Command_Comment = \"Comment\" \":\" CommentVal\n          CommentVal = URI | comment \n\n          This is the standard comment facility used by versioning systems.\n          Servers that do not understand the header or do not wish to make\n          use of the information are free to ignore the information. No\n          specification is made regarding how this information is to be\n          retrieved. It is likely, however, that most systems will make the\n          command comments available through their history attribute. \n\n          7.7 FREEZE (a.k.a. UNVERSION) \n\n          Editor: this method should be viewed as proposed functionality.\n\n          7.7.1 Method Definition\n\n          This method request the server to freeze the version tree in the\n          current state, and copy the default published version outside of\n          versioning space so that it is accessible as an unversioned\n          resource to the client. After the version tree is frozen, the\n          clients will not be able to perform any operation except CHECKIN\n          at which time the tree will be taken out of the frozen state and\n          put back into the version space. The Request-URI is the URI of\n          the version tree handle.\n\n          7.7.2 Request Body \n\n          None.\n\n\n          Goland, et al                                                  43\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          7.7.3 Response\n\n          The response will only consist of the status code as returned by\n          the server.\n\n          7.7.4 Error Conditions\n\n          The error codes could any of the following: \n\n          OK - the server successfully froze the version tree and copied\n          the Default Published Version into non-version space. \n          FREEZE failed because the server could not freeze the tree. \n          FREEZE failed because the server could not copy the default\n          published version to unversioned space \n          FREEZE failed because the server could not determine the Default\n          Published Version \n          The source (tree) is missing \n\n\n\n          8. Ancillary Methods and Headers\n\n          8.1 MaxLength Header \n\n          8.1.1 Header Definition \n\n          The max length header requests that the server not return any\n          results greater than specified in the header. The header also\n          specifies if partial results are preferred to no results in the\n          case when the result entity is greater than allowed by the\n          header. \n\n          8.1.2 Header Body \n          MaxLengthHeader = \"MaxLength\" \":\" Size Partial CRLF\n          Size = \"Size\" \":\" Bytes-Unit 1*Digit\n          Partial = \"Partial\" \":\" (\"Acceptable\" | \"Not Acceptable\") \n\n           \n\n          8.2 If-Lock Header \n\n          8.2.1 Header Definition \n\n          The If-Lock header makes any request to which it has been\n          appended conditional on the lock(s) referred to by the included\n          token(s) still being active. This header can not be dropped. \n\n\n\n\n          Goland, et al                                                  44\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          8.2.2 Header Body \n          IfLockHeader = \"If-Lock\" \":\" #LockToken CRLF \n\n           \n\n          8.3 Command-Comments Header (CCMD)\n\n          8.3.1 Header Definition\n\n          Command-Comments (short form CCMD) is a request-header which is\n          used to transmit comment information on any HTTP request method\n          to the server. The server MAY provide persistent storage for the\n          comments. The server MAY log the comments. The server MAY ignore\n          the comments. \n\n          8.3.2 Header Body\n\n          The definition of the syntax of the Command-Comments header is as\n          follows: \n          CommandComments  = (\"CCMD\" | \"Command-Comments\") \":\"\n          LangTaggedString\n\n          LangTaggedString = Lang UTF-8   ; See RFC 2044 for UTF-8\n          definition\n          Lang             = \"(\" LangTag \")\"\n          LangTag          = 1*8ALPHA *(\"-\"1*8ALPHA)\n\n           \n\n          8.4 Overwrite Header\n\n          8.4.1 Header Definition\n\n          Overwrite is a request-header which specifies whether the\n          destination of the method should or should not be overwritten. \n\n          8.4.2 Header Body\n          Overwrite = \"Overwrite\" \":\" (\"Yes\" | \"No\")\n          If the value of Overwrite is \"Yes,\" a destination resource will\n          be replaced if it exists. If the value of Overwrite is \"No,\" the\n          server will not replace the destination resource if it exists. \n\n          This header may be applied to the PUT method, and thus modifies\n          the definition of PUT given in Section 9.6 of [HTTP/1.1].\n\n\n\n\n\n\n          Goland, et al                                                  45\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          9. Required Features\n\n          [Ed. Note: preliminary and incomplete]\n\n          Introduce the concept of Distributed Authoring compliance,\n          Versioning compliance, and totally optional features. Use the\n          list from presentation.\n\n\n\n          10. Acknowledgements\n\n          [Ed. Note: preliminary and incomplete]\n\n          Roy Fielding, Richard Taylor, Larry Masinter, Henry Sanders,\n          Judith Slein, Dan Connolly, David Durand, Henrik Nielsen, Paul\n          Leach. Kenji Ota, Kenji Takahashi. Jim Cunningham. Others, TBD.\n\n\n\n          11. References\n\n          [Ed. Note: preliminary and incomplete]\n\n          [HTTP11] R. T. Fielding, J. Gettys, J. C. Mogul, H. F. Nielsen,\n          and T. Berners-Lee. \"Hypertext Transfer Protocol -- HTTP/1.1\"\n          Internet-Draft draft-ietf-http-v11-spec-07.txt, expires February\n          12, 1997. \n\n          [ORANGE] DoD 5200.28-STD, \"Department of Defense Trusted Computer\n          System Evaluation Criteria\", December, 1985. \n\n          [RFC1521] N. Borenstein, N. Freed. \"MIME (Multipurpose Internet\n          Mail Extensions) Part One: Mechanisms for Specifying and\n          Describing the Format of Internet Message Bodies.\" RFC 1521,\n          Bellcore, Innsoft, September, 1993. \n\n          [URL] T. Berners-Lee, L. Masinter, M. McCahill. \"Uniform Resource\n          Locators (URL).\" RFC 1738, CERN, Xerox PARC, University of\n          Minnesota, December, 1994. \n\n          [RFC1959]\n\n          [RFC1960]\n\n          [WEBC] - References to web collections.\n\n\n\n\n          Goland, et al                                                  46\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          12. Authors' Addresses\n\n\n          Yaron Goland\n          Microsoft Corporation\n          One Microsoft Way\n          Bldg. 27N/3445\n          Redmond, WA 98052-6399\n          Fax (206) 936 7329\n          Email yarong@microsoft.com\n\n          E. J. Whitehead, Jr.\n          Dept. Of Information and Computer Science\n          University of California, Irvine\n          Irvine, CA 92697-3425\n          Email: ejw@ics.uci.edu\n\n          Asad Faizi\n          Netscape\n          Email: asad@netscape.com\n\n          Stephen R Carter\n          Novell\n          1555 N. Technology Way\n          M/S ORM F111\n          Orem, UT 84097-2399\n          Fax (801) 228 5176\n          Email srcarter@novell.com\n\n          Del Jensen\n          Novell\n          1555 N. Technology Way\n          M/S ORM F111\n          Orem, UT 84097-2399\n          Fax (801) 228 5176\n          Email srcarter@novell.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Goland, et al                                                  47\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n                                      APPENDIX\n\n          A. Definition of LinkSearch Header\n          [Editor: This is a proposed feature.]\n          The LinkSearch method can be expensive, especially when a number\n          of attributes must be retrieved over time.\n          A more economical mechanism is to append a search string to URL\n          using \"?\". However, the URL could be confused with any of a\n          number of search syntax's. The solution proposed by this document\n          is to create a new header called LinkSearch.\n          LinkSearch = \"LinkSearch\" \":\" HTTP_url ; See section 3.2.2 of\n          [HTTP11]\n          If the HTTP URL does not end in a \"/\" then a \"?\" may be appended\n          to it and the attribute search syntax defined below may be used\n          to search for attributes on that particular resource. If the URL\n          does end with a \"/\" then any resource whose name is a child of\n          the specified HTTP URL may be searched on directly.\n          To perform a search a string matching the following syntax should\n          be used.\n          LinkSearchSuffix = \"?\" Attribute\n          Attribute = token\n\n          So, if the LinkSearch value is http://foo/bar then a search on a\n          link type of author would be performed using\n          http://foo/bar?author. If the returned value is http://foo/bar/\n          then the author search may be performed on http://foo/bar/?author\n          and any of its children, such as http://foo/bar/doublebar?author.\n\n          By returning the LinkSearch header the server is agreeing to\n          manipulate the search URL as it would the URL of the resource it\n          resolves to. Thus it becomes the responsibility of the server to\n          resolve the search URL whenever it is included in a command.\n\n          If it is impossible to resolve the search request to a single\n          result then a 416 Not Unique error should be returned. This error\n          specifies that the URI was not resolvable to a unique resource.\n\n          If the search URI does not resolve to any attribute then any\n          request containing that URI should return a 404 Not Found error.\n\n          B. Definition of LinkPrefix Header\n\n          Editor: this is a proposed feature.\n\n          In some cases a server may have an arbiter which handles all\n          searches on resources. To allow for the use of the arbiter but\n          still gain the advantages of URL based searching the LinkPrefix\n          is introduced.\n\n          LinkPrefix = \"LinkPrefix\" \":\" HTTP_url\n\n          Goland, et al                                                 A-1\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV                March 26, 1997\n\n          To retrieve a particular attribute the following syntax should be\n          used:\n\n          LinkPrefixSuffix = \"?\" URL LinkSearchSuffix\n\n          Thus the returned URL has the URL to be searched on appended to\n          it followed by the actual search syntax as previously specified.\n          This allows for quick retrieval of attribute values but with the\n          benefit of processing requests at a single resource.\n\n          The URI returned by LinkPrefix has the same use semantics as the\n          URI returned by LinkSearch.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Goland, et al                                                 A-2\f\n", "encoding": "ascii"}