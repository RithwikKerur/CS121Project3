{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/CollSpec033.txt", "content": "WEBDAV Working Group                                     J. Slein, Xerox\nINTERNET DRAFT                                           J. Davis, Xerox\n<draft-ietf-webdav-collection-protocol-03.3>         E.J. Whitehead Jr.,\n                                                               UC Irvine         \n                                                      G. Clemm, Rational\n                                                         C. Fay, FileNet\n                                                 T. Chihaya, DataChannel\n                                                            May 14, 1999\nExpires November 14, 1999\n\n\t\t\tWebDAV Advanced Collections Protocol\n\nStatus of this Memo\n\nThis document is an Internet-Draft and is in full conformance with all \nprovisions of Section 10 of RFC2026. Internet-Drafts are working \ndocuments of the Internet Engineering Task Force (IETF), its areas, and \nits working groups. Note that other groups may also distribute working \ndocuments as Internet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months \nand may be updated, replaced, or obsoleted by other documents at any \ntime. It is inappropriate to use Internet-Drafts as reference material \nor to cite them other than as \"work in progress\".\n\nTo view the list Internet-Draft Shadow Directories, see \nhttp://www.ietf.org/shadow.html.\n\nDistribution of this document is unlimited. Please send comments to the \nDistributed Authoring and Versioning (WebDAV) working group at <w3c-\ndist-auth@w3.org>, which may be joined by sending a message with subject \n\"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\nDiscussions of the WEBDAV working group are archived at URL: \n<http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\nAbstract\n\nThe WebDAV Distributed Authoring Protocol provides basic support for \ncollections, offering the ability to create and list unordered \ncollections.  Many applications, however, need more powerful \ncollections, especially for resource sharing and collection ordering.\n\nThis specification defines HTTP methods, headers, and XML elements \nsupplemental to the WebDAV Distributed Authoring Protocol to support \nresource sharing and collection orderings.  Resource sharing is provided \nby bindings and redirect references.  Bindings create new mappings of \nURIs to resources, while redirect references respond to most requests \nwith an HTTP Redirection (i.e., a 302 status code).  An ordered \ncollection always returns a listing of its members in a specific order.  \nTogether, these capabilities are referred to as WebDAV Advanced \nCollections.\n\nTable of Contents\n\n1\tNotational Conventions......................................4\n2\tTerminology.................................................4\n\nSlein et al.                                                    Page 1\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n3\tIntroduction................................................5\n4\tShared Resources............................................6\n4.1\tOverview....................................................6\n4.2\tBindings....................................................9\n4.2.1\tBIND Method.................................................9\n4.2.2\tBindings to Collections.....................................9\n4.2.3\tURL Mappings Created by BIND...............................11\n4.2.4\tExample: Generating the Set of Mappings....................11\n4.2.5\tStatus Codes...............................................12\n4.2.6\tExample: BIND with an Absolute URL Ref-Target..............12\n4.2.7\tExample: BIND with a Relative URL Ref-Target...............12\n4.2.8\tDELETE and Bindings........................................13\n4.2.9\tCOPY and Bindings..........................................13\n4.2.10\tMOVE and Bindings..........................................14\n4.2.11\tLOCK and UNLOCK............................................15\n4.2.12\tOther Methods..............................................15\n4.3\tRedirect References........................................16\n4.3.1\tMKREF Method...............................................16\n4.3.2\tStatus Codes...............................................17\n4.3.3\tExample: MKREF.............................................17\n4.4\tListing the Redirect References in a Collection............17\n4.4.1\tExample: PROPFIND on a Collection with Redirect References.18\n4.4.2\tExample: PROPFIND with Passthrough: F on a Collection with \n        Redirect References........................................19\n4.5\tCopying Redirect References................................21\n4.5.1\tExample: COPY on a Redirect Reference......................22\n4.5.2\tExample: COPY on a Collection That Contains a Redirect \n        Reference..................................................22\n4.6\tDeleting and Moving Redirect References....................23\n4.7\tLocking Redirect References................................23\n4.7.1\tLOCK on Redirect References................................24\n4.7.2\tExample: LOCK on a Redirect Reference......................25\n4.7.3\tExample: LOCK on a Collection That Contains a Redirect \n        Reference, with Passthrough: T.............................25\n4.8\tOther WebDAV Operations on Redirect References.............27\n4.8.1\tExample: PROPPATCH on a Redirect Reference.................28\n4.9\tHTTP Operations on Redirect References.....................28\n4.9.1\tExample: GET on a Redirect Reference.......................29\n4.9.2\tExample: PUT on a Redirect Reference with \"Passthrough: F\".30\n4.10\tOperations on Targets of Redirect References...............30\n4.11\tDiscovering a Target's References..........................30\n4.12\tRelative URIs in Ref-Target and DAV:reftarget..............31\n4.12.1\tExample: Resolving a Relative URI in Ref-Target............32\n4.12.2\tExample: Resolving a Relative URI in DAV:reftarget.........32\n4.13\tRedirect References to Collections.........................33\n5\tOrdered Collections........................................34\n5.1\tOverview...................................................34\n5.2\tCreating an Ordered Collection.............................34\n5.2.1\tOverview...................................................34\n5.2.2\tExample: Creating an Ordered Collection....................35\n5.3\tSetting the Position of a Collection Member................35\n5.3.1\tOverview...................................................35\n5.3.2\tStatus Codes...............................................36\n5.3.3\tExamples: Setting the Position of a Collection Member......36\n5.4\tChanging the Semantics of a Collection Ordering............36\n\nSlein et al.                                                    Page 2\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n5.5\tChanging the Position of a Collection Member...............37\n5.5.1\tORDERPATCH Method..........................................37\n5.5.2\tStatus Codes...............................................37\n5.5.3\tExample: Changing the Positions of Collection Members in the \n        Ordering...................................................37\n5.5.4\tExample: Failure of an ORDERPATCH Request..................39\n6\tHeaders....................................................39\n6.1\tRef-Target Entity Header...................................39\n6.2\tResource-Type Entity Header................................39\n6.3\tRef-Integrity Request Header...............................39\n6.4\tPassthrough Request Header.................................40\n6.5\tOrdered Entity Header......................................40\n6.6\tPosition Request Header....................................41\n7\tStatus Codes...............................................41\n7.1\t506 Loop Detected..........................................41\n8\tProperties.................................................42\n8.1\treftarget Property.........................................42\n8.2\trefintegrity Property......................................42\n8.3\tlocation Property..........................................42\n8.4\treferences Property........................................43\n8.5\torderingtype Property......................................43\n9\tXML Elements...............................................43\n9.1\treference XML Element......................................43\n9.2\tweak XML Element...........................................43\n9.3\tunordered XML Element......................................44\n9.4\tcustom XML Element.........................................44\n9.5\torder XML Element..........................................44\n9.6\tordermember XML Element....................................44\n9.7\tposition XML Element.......................................44\n9.8\tfirst XML Element..........................................45\n9.9\tlast XML Element...........................................45\n9.10\tbefore XML Element.........................................45\n9.11\tafter XML Element..........................................45\n9.12\toptions XML Element........................................46\n9.13\trefintegrityoptions XML Element............................46\n9.14\torderingoptions XML Element................................46\n9.15\tdo-not-enforce XML Element.................................46\n10\tExtensions to the DAV:response XML Element for Multi-Status \n        Responses..................................................47\n11\tCapability Discovery.......................................47\n11.1\tCompliance Classes.........................................47\n11.2\tExample: Discovery of Compliance Classes...................47\n11.3\tAdditional Advanced Collections Capabilities...............48\n11.4\tExample: Discovery of Referential Integrity Options........48\n12\tDependencies on Other Specifications.......................49\n13\tSecurity Considerations....................................49\n13.1\tPrivacy Concerns...........................................49\n13.2\tRedirect Loops.............................................50\n13.3\tRedirect References, Bindings, and Denial of Service.......50\n13.4\tPrivate Locations May Be Revealed..........................50\n13.5\tDAV:references and Denial of Service.......................50\n13.6\tDAV:references and Malicious Deletion of Resources.........51\n13.7\tDenial of Service and DAV:orderingtype.....................51\n14\tInternationalization Considerations........................51\n15\tIANA Considerations........................................51\n\nSlein et al.                                                    Page 3\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n16\tCopyright..................................................52\n17\tIntellectual Property......................................52\n18\tAcknowledgements...........................................52\n19\tReferences.................................................52\n19.1\tNormative References.......................................52\n19.2\tInformational References...................................52\n20\tAuthors' Addresses.........................................53\n21\tAppendices.................................................53\n21.1\tAppendix 1: Extensions to the WebDAV Document Type Definition.53\n21.2\tAppendix 2: Design Choices Considered, But Not Adopted.....54\n21.3\tReference Scope............................................54\n21.3.1\tStrong References out of Scope.............................54\n21.3.2\tDirect References out of Scope.............................55\n\n1 Notational Conventions\n\nSince this document describes a set of extensions to the HTTP/1.1 \nprotocol, the augmented BNF used here to describe protocol elements is \nexactly the same as described in Section 2.1 of [HTTP].  Since this \naugmented BNF uses the basic production rules provided in Section 2.2 of \n[HTTP], these rules apply to this document as well.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this \ndocument are to be interpreted as described in [RFC2119].\n\n2 Terminology\n\nThe terminology used here follows and extends that in the WebDAV \nDistributed Authoring Protocol specification [WebDAV]. Definitions of \nthe terms resource, Uniform Resource Identifier (URI), and Uniform \nResource Locator (URL) are provided in [URI].\n\nMapping\n     An association between an absolute URL or URI and a resource. It \n     is possible for a resource to have zero, one, many, or even an \n     infinite number of mappings to URLs or URIs. Mapping a resource to \n     an \"http\" scheme URL makes it possible to submit HTTP protocol \n     requests to the resource using the URL.\n\nPath Segment\n     Informally, the characters found between slashes (\"/\") in a URL or \n     URI.  Formally, as defined in section 3.3 of [URI].\n\nBinding\n     An association between a single path segment and a resource.  \n     Because a binding is a member of a collection, a binding creates \n     one or more mappings to the resource.\n\nCollection\n     A resource that contains a set of bindings, termed member \n     bindings, which identify member resources.\n\nMember Binding\n     A binding that is a member of the set of bindings contained by a \n\nSlein et al.                                                    Page 4\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n     collection.\n\nReference\n     A mechanism for providing resource sharing, allowing a single \n     resource to be accessed from multiple locations in HTTP \n     namespaces.  The bindings and redirect references defined in this \n     specification are types of references.\n\nRedirect Reference\n     A resource whose purpose is to provide access to another resource, \n     and that requires client action before it can be resolved.  The \n     client is aware that this type of reference is mediating between \n     it and the target resource.\n\nOrdinary Resource\n     A resource that is not a reference to another resource\n\nTarget Resource\n     The resource referenced by a referential resource\n\nStrong Reference\n     A reference whose referential integrity is enforced by the server\n\nWeak Reference\n     A reference whose referential integrity is not enforced by the \n     server\n\nReferential Integrity\n     The integrity of a reference is preserved as long as it points to \n     the same resource it pointed to when it was created.  Its \n     integrity may be destroyed if the target resource is moved without \n     updating the reference to reflect its new location, or if the \n     target resource is deleted.\n\n3 Introduction\n\nThe simple collections that the WebDAV Distributed Authoring Protocol \nspecification supports are powerful enough to be widely useful.  They \nprovide for the hierarchical organization of resources, with mechanisms \nfor creating and deleting collections, copying and moving them, locking \nthem, adding members to them and removing members from them, and getting \nlistings of their members.  Delete, copy, move, list, and lock \noperations can be applied recursively, so that a client can operate on \nwhole hierarchies with a single request.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: shared resources and ordering.  This specification defines  \nextensions to [WebDAV] in both these areas.\n\nOrganizing resources into hierarchies places them into smaller \ngroupings, known as collections, which are more easily browsed and \nmanipulated than a flat namespace.  However, hierarchies require \ncategorization decisions that locate resources at a single location in \nthe hierarchy, a drawback when a resource has multiple valid categories. \n\nSlein et al.                                                    Page 5\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nFor example, in a hierarchy of vehicle descriptions containing \ncollections for cars and boats, a description of a combination car/boat \nvehicle could belong in either collection. Ideally, the description \nshould be accessible from both.\n\nHierarchies also make resource sharing more difficult, since resources \nthat have utility across many collections are still forced into a single \ncollection. For example, the mathematics department at one university \nmight create a collection of information on fractals that contains the \nURIs of some local resources, but also provides access to some resources \nat other universities.  For many reasons, it may be undesirable to make \nphysical copies of the shared resources on the local server - to \nconserve disk space, to respect copyright constraints, or to make any \nchanges in the shared resources visible automatically.  \n\nThis protocol provides two mechanisms for allowing resources to appear \nin multiple places in an http URL hierarchy, and for sharing resources: \nbindings and redirect references.\n\nThe WebDAV Distributed Authoring Protocol added to the Web the ability \nto navigate Web resources hierarchically, complementing existing \nhypertext navigation facilities. In hypertext navigation, links appear \nin a specific order in a document in conjunction with human language \ndescriptions. By contrast, hierarchical navigation has fewer mechanisms \nfor expressing the ordering of a set of resources and no ability to \nassociate a human language description with the resource except its URL, \na limited form of description.\n\nThere are many scenarios where it is useful to impose an ordering on a \ncollection, such as expressing a recommended access order, or a revision \nhistory order. Orderings may be based on property values, but they may \nbe completely independent of any properties on the resources identified \nby the collection's member bindings.  Orderings based on properties can \nbe obtained using a search protocol [DASL], but orderings not based on \nproperties need some other mechanism.  These orderings generally need to \nbe maintained by a human user.  The ordering protocol defined here \nfocuses on support for such human-maintained orderings, but also allows \nfor server-maintained orderings.\n\n4 Shared Resources\n\n4.1 Overview\n\nShared resources make the same resource accessible from multiple \nlocations in http URL namespaces.  This protocol provides two mechanisms \nfor sharing resources: bindings and redirect references.\n\nA mapping is an association between a URI or URL and a resource, which \nmakes it possible to submit requests to the resource using the URI as \nthe request-URI.  Since mappings already exist in [HTTP] and [WebDAV], \nthis specification merely provides a way for clients to add new mappings \nto existing resources using the binding mechanism.  Mappings are an \nappealing mechanism for resource sharing because: \n\no Once created, clients need do nothing special to use them.  They \n\nSlein et al.                                                    Page 6\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n  behave just like any other mapping, transparently applying operations \n  to the target resource.  \no Servers already provide mappings, so there is little extra work \n  involved in allowing clients to create them.\no The integrity of mappings is guaranteed.  MOVE and DELETE operations \n  cannot leave mappings in an inconsistent state.  \n\nA limitation of mappings is that a server would need proxy capabilities \nin order to support mappings to resources on another server.  In light \nof this complexity, support for cross-server bindings is OPTIONAL.\n\nThe membership of an advanced collection is a set of bindings, and these \nbindings are part of the state of the collection. Even though a binding \nis just an association between a path segment and a resource, a binding \ncreates one or more mappings of a URL or URI to a resource.  For \nexample, if the segment \"index.html\" is being bound to a resource in a \ncollection with URL \"http://www.foo.net/A/\", the binding creates a \nmapping of URL \"http://www.foo.net/A/index.html\" to the HTML resource. \nIf the parent collection is then bound to the segment \"B\", this creates \ntwo mappings, \"http://www.foo.net/B/\" to the collection resource, and \n\"http://www.foo.net/B/index.html\" to the HTML resource.  Both the \ncollection and the HTML resource are now accessible via two URLs apiece.\nFor a resource implemented by a computer, the relationship between a \nmapping, a resource, and the chunk of state represented by a resource is \nhighlighted in the following diagram:\n\n           URI 1   URI 2 ... URI N  \n             |       |        |\n             |       |        |      <------- Mappings\n             |       |        |\n          +---------------------+\n          |     Resource R      |\n          +---------------------+\n                     |\n                     |\n                     |\n         +------------------------+\n         | Chunk of State         |\n         | (e.g., a file,         |\n         |  or multiple files,    |\n         |  or an EEPROM memory,  |\n         |  or a database record, |\n         |  etc.)                 |\n         +------------------------+\n\nAs discussed in [URI], a resource is an abstraction that represents a \nchunk of state.  This resource can have multiple URIs/URLs mapped to it.\nA redirect reference is a resource whose purpose is to provide access to \nanother resource.  It redirects most requests on the reference to \nanother resource, thereby providing a form of mediated access to the \nother resource.  Since the HTTP 302 (Moved Temporarily) status code is \nused to redirect client requests on a redirect reference, from the \nclient\u2019s point of view redirect references are less convenient to use \nthan bindings.  Redirect references require action by the client before \nthey can be resolved.  Moreover, the server is not required to enforce \n\nSlein et al.                                                    Page 7\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nthe integrity of redirect references.  However, redirect references have \na number of advantages: \n\no They are simple for servers to implement.  Servers already provide \n  redirect resources in the form of 301/302 redirection control, and \n  the same mechanism can be used for redirect references.\no The same simple implementation works equally well for target \n  resources that reside on the same server and for target resources \n  that reside on a different server.  \no Redirect references have only limited security implications.  \no Since redirect references are resources, they can carry properties of \n  their own.\no It is possible to ask a server not to enforce referential integrity \n  for a redirect reference.  \n\nBecause a redirect reference is a new type of resource, and to \ndistinguish redirect references from ordinary resources, a new value of \nthe DAV:resourcetype property (defined in [WebDAV]), DAV:reference, is \ndefined in Section 8.1 below.  \n\nIf the client is aware that it is operating on a redirect reference, it \ncan resolve the reference by retrieving the reference's DAV:reftarget \nproperty (defined in Section 7.1 below), whose value is the URI of the \ntarget resource.  It can then submit requests to the target resource. \nEvery redirect reference MUST have the DAV:reftarget property.\n\nOtherwise, the client submits a request to the redirect reference.  For \nmost operations, the response is a 302 (Moved Temporarily), accompanied \nby the Resource-Type header (defined in Section 6.2 below) with the \nvalue \"DAV:reference\" and the Location header with the URI of the target \nresource.  The client can then resubmit the request to the URI of the \ntarget resource.  A few operations, for reasons that will be explained, \nare exceptions to this general behavior. These exceptional operations \nare applied to the reference itself and do not result in a 302 response.\n\nSince a redirect reference is a resource, it is possible to apply \nmethods to the reference as well as to its target.  The Passthrough \nrequest header (defined in Section 6.4 below) is provided so that \nreferencing-aware clients can control whether an operation is applied to \nthe redirect reference or to its target resource.  The Passthrough \nheader can be used with most requests to redirect references.  This \nheader is particularly useful with PROPFIND, to retrieve the reference's \nown properties.\n\nIdeally, non-referencing clients should be able to use both bindings and \nredirect references.  This goal is more difficult to meet for redirect \nreferences, since client action is required to resolve them.  The \nstrategy of having redirect references respond to most requests with a \n302 (Moved Temporarily), accompanied by the URI of the target resource \nin the Location header, fulfills this goal in most cases.\n\nAlthough strong references are not currently supported, a new property \ncalled DAV:refintegrity is defined in Section 7.2 in anticipation of \nfuture support for strong references.  DAV:refintegrity will allow \nclients to distinguish between weak and strong references.  All redirect \n\nSlein et al.                                                    Page 8\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nreferences MUST have this property.  Although the only value currently \ndefined for DAV:refintegrity is DAV:weak, other values may be defined in \nthe future, and servers MAY use extension values to identify their \npolicy for enforcing referential integrity for that reference.  Since \nservers are required to maintain the integrity of bindings and the \nsemantics for doing so are defined in Section 4.4, no discovery \nmechanism is needed for referential integrity on bindings.\n\n4.2 Bindings\n\n4.2.1 BIND Method\n\nThe BIND method creates a new binding between the resource identified by \nthe Ref-Target header (defined in Section 6.1) and the last path segment \nof the Request-URI.  The new binding is added to its parent collection, \nidentified by the Request-URI minus its trailing slash (if present) and \nfinal segment.\n\nIf the Request-URI ends in a slash (\"/\") (i.e., the Request-URI \nidentifies a collection), then the trailing slash is kept as part of the \nbinding name, and the resource identified by the Ref-Target header MUST \nbe a collection resource, or the request fails with a 409 (Conflict) \nstatus code. This ensures that URIs ending in a slash are always bound \nto collections.  If the Request-URI does not contain a path segment \n(i.e., it simply contains the scheme and authority parts, as defined in \nSection 3 of [URI]), the BIND operation MUST fail and report a 409 \n(Conflict) status code.\n\nSeveral headers defined in this specification are used in BIND requests:  \n\no The Ref-Target header (defined in Section 6.1) MUST be included in \n  every BIND request to identify the target resource of the new \n  binding.  \no The Position request header (defined in Section 6.6) MAY be used in \n  BIND requests to indicate where the new binding is to be placed in \n  its parent collections ordering.\n\nAfter successful processing of a BIND request, it MUST be possible for \nclients to use the request-URI to submit requests to the resource \nidentified by the Ref-Target header.\n\nBy default, if the Request-URI identifies an existing binding, it is \nreplaced by the new binding. This default binding replacement behavior \ncan be overridden using the Overwrite header defined in Section 9.6 of \n[WebDAV]. \n\n4.2.2 Bindings to Collections\n\nBIND can create a binding to a collection resource.  A collection \naccessed through such a binding behaves exactly as would a collection \naccessed through any other binding.  Bindings to collections can result \nin loops, which servers MUST detect when processing \"Depth: infinity\" \nrequests.  When a loop is detected, the server MUST respond with a 506 \n(Loop Detected) status code (defined in Section 7.1).\n\n\nSlein et al.                                                    Page 9\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nCreating a new binding to a collection makes it possible to access each \nresource identified by a member of that collection using a new URI, but \ndoes not result in the creation of a new binding for each of these \nresources.\n\nFor example, suppose a new binding COLL3/ is created for Collection C2.  \nIt immediately becomes possible to access Resource R2 using the URI \n/COLL3/x.gif and to access Resource R3 using the URI /COLL3/y.jpg, but \nno new bindings for these child resources were created.  This is because \nbindings are part of the state of a collection, and associate a URI that \nis *relative to that collection* with its target resource.  No change to \nthe bindings in Collection C2 is needed to make its children accessible \nusing /COLL3/x.gif and /COLL3/y.jpg.\n\n+--------------------------+\n|     Root Collection      |\n+--------------------------+\n             |\n             |\n             |\n+------------------------------------------------+\n| Root\u2019s State                                   |\n| (properties)                                   |\n|  bindings:                                     |\n|  coll1/                coll2/         COLL3/   |\n+------------------------------------------------+\n     |                      |            /           \n     |                      |           / \n     |                      |          / \n+----------------+   +------------------+   \n| Collection C1  |   | Collection C2    |   \n+----------------+   +------------------+   \n     |                      |            \n     |                      |           \n     |                      |            \n+----------------+   +------------------+   \n| C1\u2019s State     |   | C2\u2019s State       |   \n| (properties)   |   | (properties)     |   \n| bindings:      |   | bindings:        |   \n| a.html         |   | x.gif  y.jpg     |   \n+----------------+   +------------------+   \n     |                   |       \\                \n     |                   |        \\                \n     |                   |         \\               \n+-------------+   +-------------+   +-------------+\n| Resource R1 |   | Resource R2 |   | Resource R3 |\n+-------------+   +-------------+   +-------------+\n     |                   |                 |\n     |                   |                 |\n     |                   |                 |\n+-------------+   +-------------+   +-------------+\n| R2\u2019s State  |   | R3\u2019s State  |   | R4\u2019s State  |\n| (properties)|   | (properties)|   | (properties)|\n| file content|   | file content|   | file content|\n+-------------+   +-------------+   +-------------+\n\nSlein et al.                                                    Page 10\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\n\n4.2.3 URL Mappings Created by BIND\n\nThe set of mappings created by a successful BIND operation MUST be \ndetermined as follows:\n\n1. Start with an empty set of URLs, called U.\n2. Take the Request-URI and remove path segments (and associated \"/\" \ncharacters) until either (a) a non-WebDAV collection, or a non-WebDAV \nadvanced collection is found, or (b) the root, \"/\" is reached (i.e., no \ncharacters after the scheme and authority parts of the URL).  This is \nthe base URL B.\n3. Add B, and all possible domain name variants of B (i.e., all other \ndomain names which can be substituted for the domain name in B, and \nstill retrieve the resource mapped to B), to URL set U.\n4. Calculate the next path segment of the Request-URI, going from right \nto left, and call it S, which is bound to resource R. \n5. For each member of URL set U, called Um, remove Um, then for every \npossible binding to R, create a new URL by adding the binding's path \nsegment to Um, then add this new URL to U.\n6. If there is no further path segment, then U has the complete set of \nmappings. Otherwise, go back to step 4.\n\n4.2.4 Example: Generating the Set of Mappings\n\nAssume a server responds to two domain names, www.fuzz.com, and \nfuzz.com, and has a top level that is not WebDAV-aware, called A/.  \nBelow A/ is an advanced collection that is bound to both 1/ and one/. In \ncollection one/ there is a resource called index.html.\n\n>> Request:\n\nBIND /A/1/info.html HTTP/1.1\nHost: www.fuzz.com\nRef-Target: http://www.fuzz.com/A/one/index.html\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nThe set of all possible mappings to the resource identified by \nhttp://www.fuzz.com/A/one/index.html is calculated as follows:\n\n1. U is empty.\n2. The base URL, B, is http://www.fuzz.com/A/, since A/ is not WebDAV-\naware.\n3. Since there are two domain names for this server, the domain name \nvariations of B are added to U, making U contain: http://www.fuzz.com/A/ \nand http://fuzz.com/A/.\n4. (iteration 1) The next path segment of the Request-URI is 1/, which \nis bound to an advanced collection resource, R.\n5. (iteration 1) Since the advanced collection resource R is bound to 1/ \nand one/, the value of U after the operation is: \nhttp://www.fuzz.com/A/1/, http://www.fuzz.com/A/one/, \n\nSlein et al.                                                    Page 11\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nhttp://fuzz.com/A/1/, and http://fuzz.com/A/1/.\n6. Go back to step 4, since there is one more path segment in the \nRequest-URI.\n4. (iteration 2) The next path segment of the Request-URI is info.html, \nwhich is bound to an HTML resource, R.\n5. (iteration 2) Since the HTML resource is bound to info.html and \nindex.html, the value of U after the operation is: \nhttp://www.fuzz.com/A/1/index.html, http://www.fuzz.com/A/1/info.html, \nhttp://www.fuzz.com/A/one/index.html, \nhttp://www.fuzz.com/A/one/info.html, http://fuzz.com/A/1/index.html, \nhttp://fuzz.com/A/1/info.html, http://fuzz.com/A/one/index.html, \nhttp://fuzz.com/A/one/info.html.\n6. Since there are no further path segments in the Request-URI, U now \nhas the complete set of URL mappings for the resource identified by the \nRef-Target header.\n\n4.2.5 Status Codes\n\n201 (Created): The binding was successfully created.\n\n400 (Bad Request): The client set an invalid value for the Ref-Target or \nPosition header.\n\n409 (Conflict): Several conditions may produce this response.  The URI \nin the Ref-Target header is not mapped to a resource.  The request is \nattempting to create a binding in a collection that does not exist.  The \nrequest is attempting to position the binding in an unordered \ncollection. The request is attempting to re-bind the top-level \ncollection.\n\n412 (Precondition Failed): The Overwrite header is \"F\", and a binding \nalready exists for the request-URI.\n\n4.2.6 Example: BIND with an Absolute URL Ref-Target\n\n>> Request:\n\nBIND /~whitehead/dav/spec08.txt HTTP/1.1\nHost: www.ics.uci.edu\nRef-Target: http://www.ics.uci.edu/pub/i-d/draft-webdav-protocol-08.txt\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nThe server created a new binding, associating \"spec08.txt\" to the \nresource identified by the URL \"http://www.ics.uci.edu/pub/i-d/draft-\nwebdav-protocol-08.txt\".  Clients can now use the Request-URI, \n\"http://www.ics.uci.edu/~whitehead/dav/spec08.txt\", to submit requests \nto that resource.  In addition, the server added the binding \n\"spec08.txt\" to the list of member bindings of collection \n/~whitehead/dav/.\n\n4.2.7 Example: BIND with a Relative URL Ref-Target\n\n\nSlein et al.                                                    Page 12\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n>> Request:\n\nBIND /press/prlogo.gif HTTP/1.1\nHost: www.softcorp.com\nRef-Target: ../logos/\n\n>> Response: \n\nHTTP/1.1 409 Conflict\n\nThe client requested the server to create a binding between \"prlogo.gif\" \nand the resource identified by the URL \"http://www.softcorp.com/logos/\".  \nSince the Ref-Target does end in a slash, while the Request-URI does \nnot, the server failed the request, returning a 409 (Conflict) status \ncode.\n\n4.2.8 DELETE and Bindings\n\nThe DELETE method requests that the server remove the binding between \nthe resource identified by the Request-URI and the binding name, the \nlast path segment of the Request-URI (with trailing slash, if present). \nThe binding MUST be removed from its parent collection, identified by \nthe Request-URI minus its trailing slash (if present) and final segment. \nIf DELETE removes the last binding to a resource, the server MAY also \nreclaim system resources associated with the resource.\n\nSince DELETE as specified in [WebDAV] is not an atomic operation, it may \nhappen that parts of the hierarchy under the request-URI cannot be \ndeleted.  In this case, the response is as described in [WebDAV].\n\n[HTTP] states that \"the DELETE method requests that the origin server \ndelete the resource identified by the Request-URI.\" The definition of \nDELETE in this specification is consistent with the definition in \n[HTTP].  Because [HTTP] did not distinguish between bindings and \nresources, an HTTP/1.1 client would not be able to distinguish between a \nserver that deleted the resource together with all its bindings and a \nserver that deleted only the binding of the Request-URI.  Consequently, \nit is safe to interpret \"deleting the resource\" in [HTTP] as \"removing \nthe binding of the resource to the request-URI\". \n\nSection 8.6.1 of [WebDAV] states that during DELETE processing, a server \n\"MUST remove any URI for the resource identified by the Request-URI from \ncollections which contain it as a member.\"  Servers that support \nbindings SHOULD NOT follow this requirement.\n\n4.2.9 COPY and Bindings\n\nUpon successful completion of a COPY, a new binding is created between \nthe last path segment of the Destination header (including trailing \"/\", \nif present), and the destination resource. The new binding is added to \nits parent collection, identified by the Destination header minus its \ntrailing slash (if present) and final segment.\n\nA COPY with \"Depth: 0\" MUST NOT duplicate the bindings contained by the \ncollection.\n\nSlein et al.                                                    Page 13\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\nAs an example, suppose that a COPY is issued to URI 3 for resource R \nbelow (which is also mapped to URI 1 and URI 2), with the Destination \nheader set to URIX.  After successful completion of the COPY operation, \nresource R is duplicated to create resource R', and a new binding has \nbeen created which creates at least the mapping between URIX and the new \nresource (although other mappings may also have been created).\n\n URI 1   URI 2    URI 3                             URIX\n   |       |        |                                |\n   |       |        |      <---- Mappings ---->      |\n   |       |        |                                |\n+---------------------+                   +------------------------+\n|     Resource R      |                   |     Resource R\u2019        |\n+---------------------+                   +------------------------+\n           |                                         |\n           |                                         |\n           |                                         |\n+---------------------+                   +------------------------+\n| Chunk of State      |                   | Chunk of State         |\n| (e.g., file,        |                   | (e.g., file,           |\n|  or multiple files, |                   |  or multiple files,    |\n|  or EEPROM memory,  |                   |  or EEPROM memory,     |\n|  or database record,|                   |  or database record,   |\n|  etc.)              |                   |  etc.)                 |\n+---------------------+                   +------------------------+\n\n4.2.10 MOVE and Bindings\n\nThe MOVE method has the effect of creating a new binding to a resource \n(at the Destination), and removing an existing binding (at the Request-\nURI). The name of the new binding is the last path segment of the \nDestination header, and the new binding is added to its parent \ncollection, identified by the Destination header minus its trailing \nslash (if present) and final segment.  \n\nSince MOVE as specified in [WebDAV] is not an atomic operation, it may \nhappen that parts of the hierarchy under the request-URI can be moved.  \nIn this case, the response is as described in [WebDAV].\n\n4.2.10.1 Implementation Note \n\nIn some situations, particularly when the destination is on a different \nserver from the original resource, the server may implement MOVE by \nperforming a COPY, performing some consistency maintenance on bindings \nand properties, and then performing a DELETE. In the end, URIX, URI1, \nand URI2 will all be bound to the new resource, and R together with its \nbinding to URI3 will have been deleted.  This implementation is in \naccord with the definition of MOVE in [WebDAV], and is logically \nequivalent to the definition given above.\n\nThe consistency maintenance processing that is required for this \nimplementation is as follows:\n\nThe DAV:creationdate property of the new resource must have the same \n\nSlein et al.                                                    Page 14\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nvalue as the DAV:creationdate property of the old resource.\n\nThe DAV:getlastmodified property of the new resource must have the same \nvalue as the DAV:getlastmodified property of the old resource.\n\nAll URIs that were bound to the original resource except for the \nrequest-URI must be bound instead to the new resource.\n\nURI1     URI2 ---------------------------------    URIX\n  |                                            |     |\n   -----------------------------------------   |     |\n                                            |  |     |\n+---------------------+                   +------------------------+\n|     Resource R      |                   |     Resource R\u2019        |\n+---------------------+                   +------------------------+\n           |                                         |\n           |                                         |\n           |                                         |\n+---------------------+                   +------------------------+\n| Chunk of State      |                   | Chunk of State         |\n| (e.g., file,        |                   | (e.g., file,           |\n|  or multiple files, |                   |  or multiple files,    |\n|  or EEPROM memory,  |                   |  or EEPROM memory,     |\n|  or database record,|                   |  or database record,   |\n|  etc.)              |                   |  etc.)                 |\n+---------------------+                   +------------------------+\n\n4.2.11 LOCK and UNLOCK\n\nBindings do not affect the semantics of locks, as specified in [WebDAV]. \nSpecifically, the requirement in section 8.10.3 that, \"a LOCK request on \na resource MUST NOT succeed if it can not be honored by all the URIs \nthrough which the resource is accessible\" still holds.  The LOCK method \nlocks the resource, and a lock is visible via all mappings to that \nresource. Similarly, a successful UNLOCK issued via any mapping to a \nresource removes the lock from the resource, and this lock removal is \nvisible via all mappings.\n\n4.2.12 Other Methods\n\nA GET on URI3 MUST produce the same response as a GET on URI1 or URI2, \nas specified in [HTTP], returning an entity response for R.  \n\nA HEAD on URI3 MUST produce the same response as a HEAD on URI1 or URI2, \nas specified in [HTTP], returning the entity headers for R.\n\nA PUT on URI3 MUST produce the same result as a PUT on URI1 or URI2, as \nspecified in [HTTP]. By default it overwrites the state associated with \nR, affecting the GET entity response for all three URIs.\n\nA POST on URI3 MUST produce the same result as a POST on URI1 or URI2, \nas specified in [HTTP].  It may do anything, depending upon the nature \nof R. \n\nAn OPTIONS request on URI3 MUST produce the same description of R\u2019s \n\nSlein et al.                                                    Page 15\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\ncapabilities as an OPTIONS request on URI1 or URI2, as specified in \n[HTTP].\n\nA PROPFIND on URI3 MUST produce the same response as a PROPFIND on URI1 \nor URI2, as specified in [WebDAV]. It retrieves properties of R.  If R \nis a collection, the behavior is still as defined in [WebDAV]: The \nproperties of R and its member resources are returned, to the depth \nrequested.\n\nA PROPPATCH on URI3 MUST produce the same result as a PROPFIND on URI1 \nor URI2, as specified in [WebDAV].  It sets or deletes properties on R.\n\nA MKCOL on URI3 MUST produce the same result as a MKCOL on URI1 or URI2, \nas specified in [WebDAV].  It fails, since a resource is already bound \nto URI3.\n\nA MKREF on URI3 MUST produce the same result as a MKREF on URI1 or URI2, \nas specified in Section 4.5.1.  By default it overwrites R with a new \nredirect reference.\n\nAn ORDERPATCH on URI3 MUST produce the same result as an ORDERPATCH on \nURI1 or URI2, as specified in 5.5.1.  Assuming that R is a collection \nwith a client-maintained ordering, it modifies the ordering of R\u2019s \nmembers.\n\n4.3 Redirect References\n\n4.3.1 MKREF Method\nThe MKREF method creates a redirect reference resource identified by the \nRequest-URI, whose target is identified by the Ref-Target header. The \nRef-Integrity header (defined in Section 6.3) MUST be included in every \nMKREF request to indicate whether and how referential integrity should \nbe enforced for the new reference.\n\nThe MKREF method creates a new binding between the new redirect \nreference resource and the last path segment of the Request-URI.  The \nnew binding is added to its parent collection, identified by the \nRequest-URI minus its trailing slash (if present) and final segment.\n\nSeveral headers defined in this specification are used in MKREF \nrequests:  \n\no The Ref-Target header (defined in Section 6.1) MUST be included in \n  every MKREF request to identify the target resource of the new \n  reference.  \no The Ref-Integrity header (defined in Section 6.3) MUST be included in \n  every MKREF request to indicate whether and how referential integrity \n  should be enforced for the new reference.  \no The Position request header (defined in Section 6.6) MAY be used in \n  MKREF requests to indicate where the new reference is to be placed in \n  its parent collections ordering.\n\nMKREF requests MAY include an entity body.  This specification does not \ndefine the body, but allows it for extensibility. \n\n\nSlein et al.                                                    Page 16\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nBy default, if the Request-URI of the MKREF request identifies an \nexisting resource, the server MUST perform a delete operation on the \nexisting resource before performing the MKREF. The default behavior can \nbe overridden using the Overwrite header defined in Section 9.6 of \n[WebDAV].\n\n4.3.2 Status Codes\n\n201 (Created): The redirect reference resource was successfully created.\n\n400 (Bad Request): The client set an invalid value for the Ref-Target, \nRef-Integrity, or Position header.\n\n409 (Conflict): Several conditions may produce this response.  There may \nbe no resource at the location specified in Ref-Target, on a server that \nprohibits dangling references.  The request may be attempting to create \nthe reference in a collection that does not exist.  The request may be \nattempting to position the reference before or after a resource that is \nnot in the collection, or before or after itself.  The request may be \nattempting to position the reference in an unordered collection.\n\n412 (Precondition Failed): The Overwrite header is \"F\", and a resource \nalready exists at the request-URI.  Or the server does not support the \nspecified Ref-Integrity value for the request-URI.\n\n4.3.3 Example: MKREF\n\n>> Request:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHost: www.ics.uci.edu\nRef-Target: /i-d/draft-webdav-protocol-08.txt\nRef-Integrity: do-not-enforce\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  Its DAV:resourcetype property is \nset to DAV:reference.  Its DAV:reftarget property is set to the URI of \nits target resource.  Since the Ref-Integrity header asks the server not \nto enforce referential integrity for the new reference, the server sets \nits DAV:refintegrity property to the value of DAV:weak, indicating that \nthe server will not enforce referential integrity for the new reference. \n\n4.4 Listing the Redirect References in a Collection\n\nA URI of a redirect reference can be a member of a collection just as \nthe URI of an ordinary resource can.  A listing of the members of a \ncollection shows all of the URIs in the collection, whether they \nidentify redirect references or ordinary resources.  That is, a WebDAV \nPROPFIND request on a collection resource with Depth = 1 or infinity \nMUST return a response XML element for each URI in the collection, \n\nSlein et al.                                                    Page 17\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nwhether it identifies an ordinary resource or a referential resource.\n\nFor each redirect reference, the response element MUST contain a 302 \n(Moved Temporarily) status code unless a Passthrough header with the \nvalue \"F\" is included with the PROPFIND request.  The DAV:location and \nDAV:resourcetype properties MUST be included with the 302 status code, \nextending the syntax of the DAV:response element that was defined in \n[WebDAV] as described in Section 9 below.  A referencing-aware client \ncan tell from the DAV:resourcetype property that the collection contains \na redirect reference.  The DAV:location property contains the absolute \nURI of the target resource.  A referencing-aware client can either use \nthe URI value of the DAV:location property to retrieve the properties of \nthe target resource, or it can submit a PROPFIND to the redirect \nreference with \"Passthrough: F\" to retrieve its properties.  It is \nrecommended that future editors of [WebDAV] define the DAV:location \nproperty in [WebDAV], so that non-referencing clients will also be able \nto use the response to retrieve the properties of the target resource.\n\nIf Depth = infinity in the PROPFIND request, the server MUST NOT follow \nredirect references into any collections to which they may refer.\n\nThe Passthrough header (defined in Section 6.4) MAY be used with a \nPROPFIND request on a collection.  A value of \"F\" in the Passthrough \nheader indicates that the client wants to see the properties of the \nredirect references contained in the collection, not the properties of \ntheir target resources. \n\n4.4.1 Example: PROPFIND on a Collection with Redirect References\n\nSuppose a PROPFIND request with Depth = infinity is submitted to the \nfollowing collection, with the members shown here:\n\nhttp://www.svr.com/MyCollection/\n(ordinary resource) diary.html\n(redirect reference) nunavut\n\n>> Request:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV: \">\n   <D:prop xmlns:J=\"http://www.svr.com/jsprops/\">\n      <D:resourcetype/>\n      <J:keywords/>\n   </D:prop>\n</D:propfind>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\n\nSlein et al.                                                    Page 18\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\"\n               xmlns:J=\"http://www.svr.com/jsprops/\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n            <J:keywords>diary, interests, hobbies</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n            <J:keywords>diary, travel, family, history</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location> \n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:resourcetype>reference</D:resourcetype>\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nIn this example Depth = infinity, and the Passthrough header is not \nused.  The collection contains one URI that identifies a redirect \nreference.  The response element for the redirect reference has a status \nof 302 (Moved Temporarily), and includes a DAV:prop element with the \nDAV:location and DAV:resourcetype properties to allow clients to \nretrieve the properties of its target resource.  (The response element \nfor the redirect reference does not include the requested properties.  \nThe client can submit another PROPFIND request to the URI in the \nDAV:location property to retrieve those properties.) \n\n4.4.2 Example: PROPFIND with Passthrough: F on a Collection with \nRedirect References\n\nSuppose a PROPFIND request with Passthrough = F and Depth = infinity is \nsubmitted to the following collection, with the members shown here:\n\n/MyCollection/\n\nSlein et al.                                                    Page 19\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n(ordinary resource) diary.html\n(redirect reference) nunavut\n\n>> Request:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nPassthrough: F\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n<D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n\nSlein et al.                                                    Page 20\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n            <D:reftarget>\n               <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n            </D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nSince the Passthrough header has the value \"F\", the response shows the \nproperties of the redirect reference in the collection rather than the \nproperties of its target. The value of the Passthrough header also \nprevents a 302 response from being returned for the redirect reference.\n\n4.5 Copying Redirect References\n\nA client's intent in performing a COPY operation is to create a new \nresource that is similar to the original resource and behaves like the \noriginal resource, and that can be modified without affecting the \noriginal resource.  For a COPY request to a redirect reference, the \nexpectation would be a 302 response that the client could use to copy \nthe target resource.  This would yield an independent resource that \ncould be modified without affecting the original resource.  For COPY \nrequests to collections that contain redirect references, the situation \nis less clear.  There is tension between two expectations. On the one \nhand, the client may expect the new copy of the collection to behave \nlike the old one (which implies having references where the old one had \nreferences).  On the other hand, the client may expect that it will be \npossible to modify the members of the new collection without affecting \nthe members of the old collection (which implies having copies of the \ntargets where the original collection had references).\n\nFor a COPY request on an individual reference, the response MUST be a \n302 (Move Temporarily) status code, with the URI of the target resource \nin the Location header, and \"Resource-Type: reference\" to distinguish \nthe response from an ordinary HTTP redirect.  This is the normal \nbehavior for redirect references, allowing the client to resubmit the \nrequest to the target resource identified in the Location header.  This \nalso yields intuitively correct behavior for a COPY request to an \nindividual reference.  Reference-aware clients can use the Passthrough \nheader with the value \"F\" to copy the redirect reference itself.\n\nFor COPY on a collection containing redirect references, different \nsemantics may be desirable in different scenarios.  Consequently, we \nhave made a fairly arbitrary choice to take the simplest path.  When a \nCOPY request is submitted to a collection containing redirect \nreferences, the server MUST copy the redirect references to the new \ncollection rather than returning 302 status codes for them.  This will \nresult in a new collection that behaves like the old one, and avoids \nresponding with multiple 302 status codes, each of which the client \nwould have to process separately.  Reference-aware clients can force the \n\nSlein et al.                                                    Page 21\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nserver to respond with 302 status codes rather than copying the \nreferences by using the Passthrough header with the value \"T\".\n\n4.5.1 Example: COPY on a Redirect Reference\n\n>> Request:\n\nCOPY /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/tuva.html\n\n>> Response:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Asia/History/tuva.html\nResource-Type: reference\n\nIn this example, the request-URI identifies a redirect reference whose \ntarget resource is identified by \nhttp://www.svr.com/Asia/History/tuva.html.  In this case, the server \nresponded with a 302, and provided the URL of the target resource in the \nLocation header.  The Resource-Type header indicates to a reference-\naware client that this is not an HTTP 1.1 redirect, but a reference to \nthe resource identified by the Location header.  The client can now \nresubmit the COPY request to the target resource, producing the desired \nresult: a duplicate of the original target resource that can be modified \nindependently of the original.\n\n4.5.2 Example: COPY on a Collection That Contains a Redirect Reference\n\nSuppose a COPY request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n     (ordinary resource) diary.html\n     (redirect reference) nunavut with target /Someplace/nunavut.map\n\n>> Request:\n\nCOPY /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nIn this case, since /MyCollection/nunavut is a redirect reference, the \nreference itself, and not its target, was copied into the new \ncollection.  So the resulting collection is as follows:\n\n/OtherCollection/\n      (ordinary resource) diary.html\n      (redirect reference) nunavut \n\n\nSlein et al.                                                    Page 22\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n4.6 Deleting and Moving Redirect References\n\nThe DELETE method is used to delete redirect references. DELETE MUST \naffect the reference itself, and not its target.  Similarly, when a \nDELETE on a collection encounters a redirect reference in the subtree \nunder that collection, it MUST delete the reference, and not its target.\n\nA MOVE operation on a redirect reference MUST move the reference to a \ndifferent location, and MUST NOT change the location of its target. The \nDAV:reftarget property is unchanged after a MOVE.  Similarly, when a \nMOVE on a collection encounters a redirect reference in the subtree \nunder that collection, it MUST move the reference, and not its target.\n\nDELETE and MOVE differ from other methods in that they do not alter the \nresource that is being deleted or moved, but rather the collection that \ncontains its URI.  They change the membership of that collection.\n\nWhen a redirect reference is added to a collection, the aim is to make \nit look as if the target resource were a member of that collection.  \nWhen the reference is removed from that collection, the aim is to change \nthe membership of that collection.  Membership of the target in any \nother collections, either internally or by reference, should not be \naffected.  Consequently, DELETE and MOVE do not follow the normal rules \nof behavior for references.  Instead, they are always applied to the \nreference itself, not to its target, and they never result in 302 status \ncodes.\n\n*** Reference-aware clients MAY use the Passthrough header with the \nvalue \"T\" in DELETE and MOVE requests to cause a 302 response, which can \nthen be used to resubmit the request to the target resource. [This would \ncause 302s in multi-status responses for collections.]\n\n4.7 Locking Redirect References\n\nThe semantics of LOCK described here resulted from balancing a set of \nincompatible considerations:\n\no Ideally, a LOCK on a redirect reference should lock both the \n  reference and its target resource.  The owner of an exclusive write \n  lock, for example, would be surprised if anyone else could modify the \n  content of the target resource while he held the lock.  He would also \n  be surprised if anyone else could delete the reference to it, or \n  replace the reference with one pointing to a different target.\no Non-referencing clients should be able to use redirect references \n  without encountering surprising results.\no The basic characteristics of redirect references should be honored.  \n  Redirect references should be simple for servers to implement. In \n  particular, a server should never have to resolve a redirect \n  reference.  A server should not have to provide proxy capabilities in \n  order to implement redirect references.\no There should be consistency between the behavior of LOCK on a single \n  redirect reference and the behavior of LOCK on a collection that \n  contains redirect references.\no The behavior of all requests to redirect references should be as \n  consistent as possible. In the absence of a Passthrough header, all \n\nSlein et al.                                                    Page 23\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n  methods should return a 302 when sent to a redirect reference.\no LOCK semantics for redirect references should be consistent with the \n  LOCK semantics defined in [WebDAV].\n\nWe have compromised the intuitive locking behavior and support for non-\nreferencing clients in order to preserve various sorts of consistency. \n\n4.7.1 LOCK on Redirect References\n\nThe behavior of LOCK for redirect references was determined by what is \npossible for the case of locking collections that contain redirect \nreferences.  \n\nThe expected behavior for any operation on a redirect reference is that \na 302 (Moved Temporarily) response will be returned, unless the \nPassthrough header with a value of \"F\" is used.  However, this policy \nwould have unacceptable consequences when locking a collection that \ncontains redirect references.  Since [WebDAV] requires LOCK on a \ncollection to be an atomic operation, if a 302 response is received for \nany member of the collection, the entire LOCK must fail.  This would \nmake it impossible to lock any collection that contained a redirect \nreference. \n\nTo avoid this result, a LOCK with Depth > 0 on a collection MUST lock \nany redirect references it encounters, and not return 302 responses for \nthem, unless the Passthrough header with a value of \"T\" is used.  Use of \nthe Passthrough header with a value of \"T\" in a LOCK request on a \ncollection will cause the entire lock to fail if a redirect reference is \nencountered.\n\nThis gives part of the expected default lock behavior without forcing \nthe server to resolve the redirect reference or become a proxy server in \ncases where the target resides on a different server. \n\nThere will be no hint in any response code that there are redirect \nreferences whose targets need to be locked.  The client will most likely \nnot lock any targets until it attempts an operation on the target and \ngets a 302 response.  Non-referencing clients cannot lock the targets of \nthe redirect references and may never realize that the targets have not \nbeen locked.  \n\nClearly, a LOCK with Depth = infinity on a collection MUST NOT follow \nany redirect references whose targets are collections into the target \ncollections; it MUST NOT cause any members of those target collections \nto be locked.\n\nThe behavior of LOCK for individual redirect references is designed to \nbe consistent with LOCK behavior for collections that contain redirect \nreferences.  By default a LOCK on a redirect reference MUST lock only \nthe reference, not its target, and it MUST NOT return a 302 response.  A \nreference-aware client can use the Passthrough header with a value of \n\"T\" to get a 302 response with the URI of the target resource in the \nLocation header.\n\nUNLOCK behaves as specified in [WebDAV], unlocking all resources \n\nSlein et al.                                                    Page 24\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nincluded in the lock identified by the Lock-Token header.\n\n4.7.2 Example: LOCK on a Redirect Reference\n\n>> Request:\n\nLOCK /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\n>> Response:\n\nHTTP/1.1 200 OK\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:prop xmlns:D=\"DAV:\">\n   <D:lockdiscovery>\n      <D:activelock>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:locktype><D:write/></D:locktype>\n         <D:depth>0</D:depth>\n         <D:owner>\n            <D:href>http://www.svr.com/~jas/contact.html</D:href>\n         </D:owner>\n         <D:locktoken>\n            opaquelocktoken:e71dfae-5dec-22d6-fea5-00a0c91e6be4\n         </D:locktoken>\n      </D:activelock>\n   </D:lockdiscovery>\n</D:prop>\n\nThe request and response look exactly as specified in [WebDAV].  In this \nexample, the request-URI identifies a redirect reference, which was \nsuccessfully locked.  The target resource of the redirect reference is \nnot locked.\n\n4.7.3 Example: LOCK on a Collection That Contains a Redirect Reference, \nwith Passthrough: T\n\n\nSlein et al.                                                    Page 25\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nSuppose a LOCK request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n     (ordinary resource) diary.html\n     (redirect reference) nunavut\n\n>> Request:\n\nLOCK /MyCollection/ HTTP/1.1\nHost: www.svr.com\nPassthrough: T\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"Dav:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop><D:lockdiscovery/></D:prop>\n         <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location>\n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:resourcetype>reference</D:resourcetype>\n\nSlein et al.                                                    Page 26\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nThe \"Passthrough: T\" header caused the server to return a 302 response \ncode for the redirect reference in the collection.  Consequently, \nneither the collection nor any of its members were locked.  A \nreferencing-aware client can submit a separate LOCK request to the URI \nin the DAV:location property returned for the redirect reference, and \ncan resubmit the LOCK request with \"Passthrough: F\" to the collection.  \nAt that point both the reference and its target will be locked (as well \nas the collection and all its other members).\n\n4.8 Other WebDAV Operations on Redirect References\n\nAlthough non-referencing WebDAV clients cannot create referential \nresources, they should be able to use the references created by \nreference-aware WebDAV clients.  They should be able to follow any \nreferences to their targets.  To make this possible, a server that \nreceives a PROPFIND, PROPPATCH, MKCOL, MKREF, BIND, or ORDERPATCH \nrequest made via a redirect reference MUST return a 302 (Moved \nTemporarily) status code. The client and server MUST follow [HTTP] \nSection 10.3.3 \"302 Moved Temporarily,\" but with these additional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Resource-Type header.  This header \n  allows reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nA reference-aware WebDAV client can act on this response in one of two \nways.  It can, like a non-referencing client, resubmit the request to \nthe URI in the Location header in order to operate on the target \nresource.  Alternatively, it can resubmit the request to the URI of the \nredirect reference with the Passthrough header set to \"F\" in order to \noperate on the reference itself.  If the Passthrough header is present \nwith a value of \"F\", the request MUST be applied to the reference \nitself, and a 302 response MUST NOT be returned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, and if the client wants to \napply the method to the reference, it can save the round trip caused by \nthe 302 response by using \"Passthrough: F\" in its initial request to the \nURI.\n\nSince MKCOL fails when applied to existing resources, if the client \nattempts to resubmit the request to the target resource, the request \nMUST fail (unless the reference is a dangling reference).  Similarly, if \nthe client attempts to resubmit the request to the reference with \n\"Passthrough: F\", the request MUST fail.\n\nSince ORDERPATCH applies only to collections, an ORDERPATCH request with \na Passthrough header with the value \"F\" on a redirect reference MUST \nfail.\n\nSlein et al.                                                    Page 27\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\n4.8.1 Example: PROPPATCH on a Redirect Reference\n\nRequest:\n\nPROPPATCH /bar.html HTTP/1.1 \nHost: www.foo.com \nContent-Type: text/xml; charset=\"utf-8\" \nContent-Length: xxxx \n\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:propertyupdate xmlns:D=\"DAV:\"\n   xmlns:Z=\"http://www.w3.com/standards/z39.50/\">\n     <D:set>\n          <D:prop>\n               <Z:authors>\n                    <Z:Author>Jim Whitehead</Z:Author>\n                    <Z:Author>Roy Fielding</Z:Author>\n               </Z:authors>\n          </D:prop>\n     </D:set>\n     <D:remove>\n          <D:prop><Z:Copyright-Owner/></D:prop>\n     </D:remove>\n   </D:propertyupdate>\n\nResponse:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Internet/xxspec08.html\nResource-Type: reference\n\nSince /bar.html is a redirect reference and the Passthrough header is \nnot included in the request, the response is a 302 (Moved Temporarily).  \nThe Resource-Type header informs a reference-aware client that this is \nnot an ordinary HTTP 1.1 redirect, but is a redirect reference.  The URI \nof the target resource is provided in the Location header so that the \nclient can resubmit the request to the target resource.\n\n4.9 HTTP Operations on Redirect References\n\nAlthough existing HTTP clients cannot create referential resources, they \nshould be able to use collections created by reference-aware WebDAV \nclients.  They should be able to follow any references identified by \nURIs in those collections to their targets.  To enable existing HTTP \nclients to use GET, HEAD, PUT, POST, or OPTIONS via redirect references, \na server that receives any of these requests on a redirect reference \nMUST return a 302 (Moved Temporarily).  The client and server MUST \nfollow [HTTP] Section 10.3.3 \"302 Moved Temporarily,\" but with these \nadditional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Resource-Type header.  This header \n\nSlein et al.                                                    Page 28\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n  allows reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nReference-aware clients can act on a 302 response in either of two ways.  \nLike plain HTTP clients, they can resubmit the request to the URI in the \nLocation header (the URI of the target resource).  They may, however, \nwant to operate on the reference rather than on its target.  In this \ncase, they may resubmit the request to the URI of the reference and \ninclude the Passthrough header with the value \"F\" in the request.  If \nthe Passthrough header is present with a value of \"F\", the request MUST \nbe applied to the reference itself, and a 302 response MUST NOT be \nreturned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, and if the client wants to \napply the method to the reference, it can save the round trip caused by \nthe 302 response by using \"Passthrough: F\" in its initial request to the \nURI.\n\n\"Passthrough: F\" can be used with GET or HEAD to retrieve the entity \nheaders of a redirect reference.  When \"Passthrough: F\" is used with GET \nor HEAD, the referencing entity headers (Ref-Type and Ref-Target) MUST \nbe returned, along with all HTTP headers that make sense for references \n(at a minimum, Cache-Control, Age, ETag, Expires, and Last-Modified).  \n\n\"Passthrough: F\" can be used with PUT to replace the redirect reference \nwith an ordinary resource.  It can be used with OPTIONS to retrieve the \ncapabilities of a redirect reference.  \n\nClients MUST NOT, however, use \"Passthrough: F\" with POST. Since a \nreference cannot accept another entity as its subordinate, an attempt to \nPOST to a reference with \"Passthrough: F\" will also fail.  If a server \nreceives a POST request with \"Passthrough: F\" on a redirect reference, \nit MUST fail the request with a 400 (Bad Request) status code.\n\n4.9.1 Example: GET on a Redirect Reference\n\n>> Request:\n\nGET /bar.html HTTP/1.1\nHost: www.foo.com \n\n>> Response:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Internet/xxspec08.html\nResource-Type: reference\n\nSince /bar.html is a redirect reference and the Passthrough header is \nnot included in the request, the response is a 302 (Moved Temporarily).  \nThe Resource-Type header informs a reference-aware client that this is \nnot an ordinary HTTP 1.1 redirect, but is a redirect reference.  The URI \nof the target resource is provided in the Location header so that the \nclient can resubmit the request to the target resource.\n\n\nSlein et al.                                                    Page 29\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n4.9.2 Example: PUT on a Redirect Reference with \"Passthrough: F\"\n\n>> Request:\n\nPUT /bar.html HTTP/1.1 \nHost: www.foo.com\nPassthrough: F \nContent-Type: text/xml; charset=\"utf-8\" \nContent-Length: xxxx\n\n. . . some content . . .\n\n>> Response:\n\nHTTP/1.1 200 OK \n\nAlthough /bar.html is a redirect reference, the presence of the \n\"Passthrough: F\" header prevents a 302 response, and instead causes the \nrequest to be applied to the reference.  The result in this case is that \nthe reference is replaced by an ordinary resource having the content \nsubmitted with the request.\n\n4.10 Operations on Targets of Redirect References\n\nIn general, operations on targets of weak redirect references have no \neffect on the reference.  However, servers that choose to maintain the \nintegrity of redirect references are free to make changes to the state \nof redirect references when moving or deleting their targets.\n\nWhen moving a target resource, a server MAY insert an optional step into \nthe semantics of MOVE as defined in [WebDAV] for the purpose of \nmaintaining referential integrity.  Between the copy step and the delete \nstep of a MOVE, the server MAY perform an update step, which changes the \nDAV:reftarget property of any references to the target to reflect its \nnew location.\n\nWhen deleting a target resource, a server MAY perform any internal \noperations necessary to implement its policy on preserving referential \nintegrity.  For example, it might delete any redirect references to the \ndeleted target, or it might flag them as having a deleted target, or it \nmight replace redirect references with copies of the target.\n\n4.11 Discovering a Target's References\n\nAn OPTIONAL DAV:references property on the target resource provides a \nlist of referential resources whose DAV:reftarget property points to \nthat target resource. By retrieving this property, a client can discover \nthe URIs of the references that point to the target, and so can also \ndiscover the collections that contain those URIs as members.  As for all \nDAV: properties, this specification is silent as to how the \nDAV:references property is implemented on the server.\n\nThe DAV:references property is expected to be supported mainly by \nDocument Management Systems (DMSs) and other servers that will maintain \nthe property only for references within their own domain.  It is not in \n\nSlein et al.                                                    Page 30\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\ngeneral possible for a server to maintain the property for references on \nother servers.  If a reference on a different server points to the \ntarget, the server where the target is located is unlikely to know about \nthat reference.  This protocol provides no mechanism for one server to \nnotify another of the creation of a reference to one of its resources.  \nConsequently, the list of references in DAV:reftarget may be incomplete.\n\nRationale: A number of scenarios require clients to navigate from a \ntarget resource to the references that point to it, and to the \ncollections that contain the URIs of those references.  This capability \nis particularly important for DMSs, which may populate their collections \nentirely by reference.  Their clients may need to determine, for any \nobject in the DMS, what collections contain URIs that identify \nreferences to that object.  It is also important in other contexts.  For \nexample, some servers enforce referential integrity by refusing to \ndelete any resource that is referenced by other resources.  In such an \nenvironment, the client must be able to discover the references in order \nto delete them before attempting to delete the target.\n\nRisks: When deciding whether to support the DAV:references property, \nserver implementers / administrators should balance the benefits it \nprovides against the cost of maintaining the property and the security \nrisks enumerated in Sections 12.5 and 12.6.\n\n*** What to do about this section.  Have a separate DAV:bindings \nproperty?  Have the DAV:references property include both redirect \nreferences and bindings, but distinguish between them?  Part of the \nrationale (having to do with referential integrity) doesn\u2019t apply to \nbindings, but some applications will still want to know what bindings \nthere are to a given resource.  There is no other way to discover \nbindings to a resource, since bindings do not have the DAV:reftarget \nproperty.\n\n4.12 Relative URIs in Ref-Target and DAV:reftarget\n\nThe URI in a Ref-Target header MAY be a relative URI.  Similarly, the \nhref in a DAV:reftarget property MAY be a relative URI.  In both cases, \nthe base URI to be used for resolving the relative URI to absolute form \nis the URI of the redirect reference to which the Ref-Target header or \nDAV:reftarget property belongs.  \n\nIn the case of a Ref-Target header, the base URI is constructed as \nfollows: Its scheme component is \"http\", its authority component is the \nvalue of the Host header in the request, and its path component is the \nrequest-URI in the request.  See [URI] Section 5 for a discussion of \nrelative URI references and how to resolve them.\n\nThe DAV:reftarget property appears in the protocol only in the context \nof a Multi-Status response, in a response element that contains a single \nDAV:href element.  The value of this DAV:href element serves as the base \nURI for resolving a relative URI in DAV:reftarget.  The value of \nDAV:href may itself be relative, in which case it must be resolved first \nin order to serve as the base URI for the relative URI in DAV:reftarget.  \nIf the DAV:href element is relative, its base URI is constructed from \nthe scheme component \"http\", the value of the Host header in the \n\nSlein et al.                                                    Page 31\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nrequest, and the request-URI.\n\n4.12.1 Example: Resolving a Relative URI in Ref-Target\n\nRequest:\n\nMKREF /north/inuvik HTTP/1.1\nHost: www.somehost.edu\nRef-Target: mapcollection/inuvik.gif\nRef-Integrity: do-not-enforce\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this example, the base URI is http://www.somehost.edu/north/inuvik.  \nThen, following the rules in [URI] Section 5, the relative URI in Ref-\nTarget resolves to the absolute URI \nhttp://www.somehost.edu/north/mapcollection/inuvik.gif. \n\n4.12.2 Example: Resolving a Relative URI in DAV:reftarget\n\nRequest:\n\nPROPFIND /geog/ HTTP/1.1\nHost: www.xxsvr.com\nPassthrough: F\nDepth: 1\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1/0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>/geog/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n     </D:propstat>\n\nSlein et al.                                                    Page 32\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n     <D:propstat>\n         <D:prop><D:reftarget/></D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n     </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>/geog/stats.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n            <D:reftarget>statistics/population/1997.html</D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nIn this example, the relative URI statistics/population/1997.html is \nreturned as the value of reftarget for the reference identified by href \n/geog/stats.html.  The href is itself a relative URI, which resolves to \nhttp://www.xxsrv.com/geog/stats.html.  This is the base URI for \nresolving the relative URI in reftarget.  The absolute URI of reftarget \nis http://www.xxsrv.com/geog/statistics/population/1997.html.\n\n4.13 Redirect References to Collections\n\nIn a request-URI /segment1/segment2/segment3, any of the three segments \nmay identify a redirect reference.  (See [URI], Section 3.3, for \ndefinitions of \"path\" and \"segment\".)  It will not be possible to \nresolve such URIs unless certain constraints hold.  If any segment of \nthe path except the last identifies a reference, that reference MUST \nultimately resolve to a resource that behaves as a container.  (Examples \nare WebDAV collections, tar files, and some CGI scripts.)  The \nsucceeding segment of the path MUST resolve to a resource that is \nimmediately contained in that container.\n\nConsider request-URI /x/y/z.html.  Suppose that /x/ is a reference whose \ntarget is collection /a/, which contains reference y whose target is \ncollection /b/, which contains reference z.html whose target is \n/c/d.html.  \n\n/x/ -----> /a/\n           /a/y/ -----> /b/\n                        /b/z.html -----> /c/d.html\n\nIt is possible to resolve the request-URI because each segment of the \nURI's path satisfies the constraints stated above.  Except for the final \nsegment, each segment that is a reference resolves to a collection that \ncontains the next segment as an internal member.  The final segment, \nwhich is a reference, does have a target resource. \n\nThe client must follow up three separate 302 responses before finally \nreaching the target resource.  The server responds to the initial \nrequest with a 302 with Location: /a/y/z.html, and the client resubmits \nthe request to /a/y/z.html.  The server responds to this request with a \n\nSlein et al.                                                    Page 33\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n302 with Location: /b/z.html, and the client resubmits the request to \n/b/z.html.  The server responds to this request with a 302 with \nLocation: /c/d.html, and the client resubmits the request to /c/d.html.  \nThis final request succeeds.\n\nThe value of the Location header in a 302 response is as follows: The \nleftmost path segment of the request-URI that identifies a redirect \nreference, together with all path segments and separators to the left of \nit, is replaced by the value of the redirect reference\u2019s DAV:reftarget \nproperty.  The remainder of the request-URI is concatenated to this \npath.\n\n5 Ordered Collections\n\n5.1 Overview\n\nCollections on a compliant server may be ordered, but need not be.  It \nis up to the client to decide whether a given collection is ordered and, \nif so, to specify the semantics to be used for ordering its members.  If \na collection is ordered, each of its members must be in the ordering \nexactly once, and the ordering must not include any resource that is not \na member of the collection.  Only one ordering can be attached to any \ncollection.  Multiple orderings of the same resources can be achieved by \ncreating multiple collections referencing those resources, and attaching \na different ordering to each collection.\n\nThe server is responsible for enforcing these constraints on orderings.  \nThe server MUST remove a member URI from the ordering when it is removed \nfrom the collection. The server MUST add a member URI to the ordering \nwhen it is added to the collection.\n\nWhen responding to a PROPFIND on a collection, the server MUST order the \nresponse elements according to the ordering defined on the collection.\n\nOrderings may be client-maintained or server-maintained.  This protocol \nprovides support for both types of orderings.\n\n5.2 Creating an Ordered Collection\n\n5.2.1 Overview \n\nWhen a collection is created, the client MAY request that it be ordered \nand specify the semantics of the ordering by using the new Ordered \nheader (defined in Section 6.5) in the MKCOL request.   \n\nFor collections that are ordered, the client SHOULD identify the \nsemantics of the ordering with a URI in the Ordered header.  This URI \nmay identify a server-maintained ordering.  Clients can discover the \navailable server-maintained orderings using the mechanism defined in \nSection 10.3.  The URI may identify a semantics for a client-maintained \nordering, providing the information a human user or software package \nneeds to insert new collection members into the ordering intelligently.  \nAlthough the URI in the Ordered header MAY point to a resource that \ncontains a definition of the semantics of the ordering, clients are \ndiscouraged from accessing that resource, in order to avoid \n\nSlein et al.                                                    Page 34\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\noverburdening its server.  The client MAY set the header value to \nDAV:custom to indicate that the collection is ordered, but the semantics \nof the ordering are not being advertised.  If the client does not want \nthe collection to be ordered, it may omit the Ordered header, or use it \nwith the value DAV:unordered.\n\nIf the server does not recognize the value of the Ordered header as one \nof its server-maintained orderings, it MUST assume that a client-\nmaintained ordering is intended.  If the value of the Ordered header is \none of the server-maintained orderings that the server supports, it MUST \nmaintain the collection's ordering according to that ordering semantics \nas new members are added.\n\nEvery collection MUST have the new DAV:orderingtype property (defined in \nSection 7.5), which indicates whether the collection is ordered and, if \nso, identifies the semantics of the ordering.  The server sets the \ninitial value of this property based on the value of the Ordering header \nin the MKCOL request.\n\nIf the collection is ordered, the server MUST respond to PROPFIND \nrequests on the collection using the specified ordering. If the \ncollection is unordered, the client cannot depend on the repeatability \nof the ordering of results from a PROPFIND request.\n\n5.2.2 Example: Creating an Ordered Collection\n\nRequest:\n\nMKCOL /theNorth/ HTTP/1.1\nHost: www.server.org\nOrdered: http://www.server.org/orderings/compass.html\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this example, a new, ordered collection was created.  Its \nDAV:orderingtype property has as its value the URI from the Ordered \nheader.  In this case, the URI identifies the semantics governing a \nclient-maintained ordering.  As new members are added to the collection, \nclients or end users can use the semantics to determine where to \nposition the new members in the ordering. \n\n5.3 Setting the Position of a Collection Member\n\n5.3.1 Overview\n\nWhen a new member is added to a collection with a client-maintained \nordering (for example, with PUT, MKREF, or MKCOL), its position in the \nordering can be set with the new Position header (defined in Section \n6.6).  The Position header allows the client to specify that the member \nshould be first in the collection's ordering, last in the collection's \nordering, before some other collection member in the collection's \nordering, or after some other collection member in the collection's \nordering.\n\nSlein et al.                                                    Page 35\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\n5.3.2 Status Codes\n\nSome likely client errors and the corresponding response status codes \ninclude: \n409 (Conflict): The request may be attempting to position the collection \nmember before or after a URI that is not in the collection, or before or \nafter itself, or it may be attempting to position the collection member \nin an unordered collection or in a collection with a server-maintained \nordering.\n\n5.3.3 Examples: Setting the Position of a Collection Member\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: http://www.ics.uci.edu/i-d/draft-webdav-protocol-08.txt\nPosition: After <requirements.html>       \n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  The Position header in this \nexample caused the server to set its position in the ordering of the \n/~whitehead/dav/ collection immediately after requirements.html.\n\nRequest:\n\nMOVE /i-d/draft-webdav-protocol-08.txt HTTP/1.1\nHost: www.ics.uci.edu\nDestination: http://www.ics.uci.edu/~whitehead/dav/draft-webdav-\n     protocol-08.txt\nPosition: First\n\nResponse:\n\nHTTP/1.1 409 Conflict\n\nIn this case, the server returned a 409 Conflict status code because the \n/~whitehead/dav/ collection is an unordered collection.  Consequently, \nthe server was unable to satisfy the Position header.\n\n5.4 Changing the Semantics of a Collection Ordering\n\nAfter a collection has been created, a client can change its ordering \nsemantics, or change an ordered collection to an unordered collection or \nvice versa, by using PROPPATCH to change the value of its \nDAV:orderingtype property (defined in Section 7.5).  If the new value \nidentifies a client-maintained ordering, the client is then responsible \nfor updating the ordering of the collection members according to the new \nsemantics.  If it identifies a server-maintained ordering, the server \n\nSlein et al.                                                    Page 36\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nMUST reorder the collection according to the new semantics.  PROPPATCH \nis defined in [WebDAV], Section 7.2.\n\n5.5 Changing the Position of a Collection Member\n\n5.5.1 ORDERPATCH Method\n\nThe ORDERPATCH method alters the ordering of bindings in the collection \nidentified by the Request-URI, based on instructions in the order XML \nelement. The order XML element identifies the member URIs whose \npositions are to be changed, and describes their new positions in the \nordering.  Each new position can be specified as first in the ordering, \nlast in the ordering, before some other collection member in the \nordering, or after some other collection member in the ordering.  \n\nThe server MUST apply the changes in the order they appear in the order \nXML element.  The server MUST either apply all the changes or apply none \nof them.  If any error occurs during processing, all executed changes \nMUST be undone and a proper error result returned.\n\n5.5.2 Status Codes\n\nSince multiple changes can be requested in a single ORDERPATCH request, \nthe server MUST return a 207 (Multi-Status) response, as defined in \n[WebDAV].\n\nThe following are examples of response codes one would expect to be used \nin a 207 (Multi-Status) response for this method: \n\n200 (OK): The change in ordering was successfully made.\n409 (Conflict): An attempt was made to position the collection member \nbefore or after a URI that is not in the collection, or before or after \nitself, or an attempt was made to position the collection member in an \nunordered collection or in a collection with a server-maintained \nordering.\n\nA request to reposition a collection member to the same place in the \nordering is not an error. \n\n5.5.3 Example: Changing the Positions of Collection Members in the \nOrdering\n\nConsider a collection /coll-1/ with members ordered as follows:\n\nnunavut.map\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\nnunavut.desc\niqaluit.img\niqaluit.desc\n\n>> Request:\n\nSlein et al.                                                    Page 37\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\nORDERPATCH /coll-1/ HTTP/1.1\nHost: www.nunanet.com\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:order xmlns:d=\"DAV:\">\n   <d:ordermember>\n      <d:href>nunavut.desc</d:href>\n      <d:position> \n         <d:after>\n            <d:href>nunavut.map</d:href>\n         </d:after>\n      </d:position>\n   </d:ordermember>\n   <d:ordermember>\n      <d:href>iqaluit.img</d:href>\n      <d:position>\n         <d:last/>\n      </d:position>\n   </d:ordermember>\n</d:order>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/nunavut.desc</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/iqaluit.img</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n</d:multistatus>\n\nIf the href elements are relative URIs, as in this example, they are \ninterpreted relative to the collection that is being reordered.  In this \nexample, after the request has been processed, the collection's ordering \nis as follows:\n\nnunavut.map\nnunavut.desc\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\niqaluit.desc\n\nSlein et al.                                                    Page 38\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\niqaluit.img\n\n5.5.4 Example: Failure of an ORDERPATCH Request\n\nTo Be Supplied\n\n6 Headers\n\n6.1 Ref-Target Entity Header\n\nRef-Target = \"Ref-Target\" \":\" (absoluteURI | relativeURI)\n\nThe Ref-Target header is used with MKREF or BIND requests to identify \nthe target resource of the new redirect reference or binding being \ncreated.  For an example, see Section 4.5.3.\n\nTo comply with the rules specified in [HTTP] for responding to GET and \nHEAD requests, the Ref-Target entity header is also included in \nresponses to GET and HEAD that include the Passthrough header with the \nvalue \"F\".  (See Section 4.11.) \n\n6.2 Resource-Type Entity Header\n\nResource-Type = \"Resource-Type\" \":\" (\"DAV:reference\" | \n                                     ext-resource-type)\next-resource-type = quoted-URL \n\nThe Resource-Type header is defined primarily for use in 302 responses, \nto allow reference-aware clients to distinguish between HTTP 1.1 \nredirects and 302 responses for redirect references(see Sections 4.2, \n4.10, and 4.11).  The possible values of this header are DAV:reference, \nand ext-ref-type. The value ext-ref-type provides extensibility.  \n\nTo comply with the rules specified in [HTTP] for responding to GET and \nHEAD requests, the Ref-Type entity header is also included in responses \nto GET and HEAD that include the Passthrough header with the value \"F\" \n(see Section 4.11).  \n\n6.3 Ref-Integrity Request Header\n\nRef-Integrity = \"Ref-Integrity\" \":\" (\"DAV:do-not-enforce\" | \n                                      ext-ref-integrity)\next-ref-integrity = quoted-URL\n\nThe Ref-Integrity header is defined primarily to allow future support \nfor strong references.  It specifies whether and how the server should \nenforce referential integrity for a referential resource being created \nwith MKREF. \n\nThe value \"DAV:do-not-enforce\" means that the client wants the server \nnot to enforce referential integrity for the newly created reference.  A \nclient might use this value if, for example, it wanted to populate a \ncollection with references before their content was made available on \nthe Web.  If the server cannot honor a Ref-Integrity value of \"DAV:do-\nnot-enforce\" in a MKREF request, it MUST fail the request with status \n\nSlein et al.                                                    Page 39\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\ncode 412 (Precondition Failed).\n\nClients may use other values of the Ref-Integrity header, to specify the \ndesired policy for enforcing referential integrity.  Clients can \ndiscover the valid values for Ref-Integrity for a given request-URI by \nsubmitting an OPTIONS request to that URI and including the \nDAV:refintegrityoptions element in the request body (see Section 10).  \nIf a server receives an extension value that it does not understand, it \nMUST fail the request with status code 400 (Bad Request).\n\nIf the Ref-Integrity header is not present on a MKREF request, the \nserver MUST fail the request with status code 400 (Bad Request).\n\n6.4 Passthrough Request Header\n\nPassthrough = \"Passthrough\" \":\" (\"T\" | \"F\")\n\nThe optional Passthrough header can be used on any request to a redirect \nreference.  If the Passthrough header has the value \"F\", the request \nMUST be applied to the reference itself, and a 302 response MUST NOT be \nreturned.  If the Passthrough header has the value \"T\", a 302 response \nMUST be returned, with the URI of the target resource in the Location \nheader and the Resource-Type header with a value \"DAV:reference\".  \n\nIf the Passthrough header is used on a request to any other sort of \nresource besides a reference, the server SHOULD ignore it.  If the \nPassthrough header with the value \"F\" appears in a POST or ORDERPATCH \nrequest to a reference, the server MUST respond with a 400 (Bad \nRequest).\n\nBy default, PROPFIND operations on collections behave as if they \nincluded \"Passthrough: T\".  \"Passthrough: F\" can be used with PROPFIND \nrequests on collections with Depth = infinity.  When it is used in this \nway, the server MUST return the properties of any redirect references in \nthe collection, and not return 302 (Moved Temporarily) status codes for \nthem.  \n\nBy default, LOCK operations on collections with Depth = infinity behave \nas if they included \"Passthrough: F\".  If \"Passthrough: T\" is used with \na LOCK request on a collection with Depth = infinity, and a redirect \nreference is encountered during processing, the server MUST include a \n302 response code for the redirect reference.  Since [WebDAV] defines \nLOCK to be an atomic operation, if any redirect references are \nencountered, the entire LOCK operation fails. \n\nBy default, COPY operations on collections with Depth > 0 behave as if \nthey included \"Passthrough: F\". If \"Passthrough: T\" is used with a COPY \nrequest on a collection with Depth > 0, and a redirect reference is \nencountered during processing, the server MUST include a 302 response \ncode for the redirect reference.  As specified in [WebDAV], the server \nSHOULD complete as much of the COPY operation as it can while preserving \na consistent namespace.\n\n6.5 Ordered Entity Header\n\n\nSlein et al.                                                    Page 40\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nOrdered = \"Ordered\" \":\" (\"DAV:unordered\" | \"DAV:custom\" | absoluteURI)\n\nThe Ordered header may be used with MKCOL to request that the new \ncollection be ordered and to specify its ordering semantics.  A value of \n\"DAV:unordered\" indicates that the collection is not ordered. A value of \n\"DAV:custom\" indicates that the collection is to be ordered, but the \nsemantics of the ordering is not being advertised.  Any other \nabsoluteURI value indicates that the collection is ordered, and \nidentifies the semantics of the ordering.  The absoluteURI MAY point to \na resource that contains a definition of the semantics of the ordering.  \n\nIf the Ordered header is present on a MKCOL request, the server MUST set \nthe collection's DAV:orderingtype property to the value of the Ordered \nheader.  If the Ordered header is not present, the server MUST treat the \nrequest as if it had an Ordered header with the value \"DAV:unordered\".  \n\n6.6 Position Request Header\n\nPosition = \"Position\" \":\" (\"First\" | \"Last\" | \n                           ((\"Before\" | \"After\") Generic-Coded-url))\nGeneric-Coded-url = \"<\" (absoluteURI | relativeURI) \">\"\nabsoluteURI and relativeURI are defined in [URI].\n\nThe Position header may be used with any method that adds a member to a \ncollection with a client-maintained ordering, to tell the server where \nin the collection ordering to position the new member being added to the \ncollection.  It may be used for both ordinary and referential members.\n\nIf the Coded-url is a relative URL, it is interpreted relative to the \ncollection to which the new member is being added. \n\nThe server MUST insert the new member into the ordering at the location \nspecified in the Position header, if one is present (and if the \ncollection has a client-maintained ordering). \n\nIf the request is replacing an existing resource, and the Position \nheader is present, the server MUST remove the member from its previous \nposition, and then insert it at the requested position.\n\nIf the Position request header is not used when adding a member to a \ncollection with a client-maintained ordering, then:\n\nIf the request is replacing an existing resource, the server MUST \npreserve the present ordering.\n\nIf the request is adding a new member to the collection, the server MUST \nappend the new member to the end of the ordering.\n\nIf an attempt is made to use the Position header on a collection that is \nunordered or that has a server-maintained ordering, the server MUST fail \nthe request with a 409 (Conflict) status code.\n\n7 Status Codes\n\n7.1 506 Loop Detected\n\nSlein et al.                                                    Page 41\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\nThe 506 (Loop Detected) indicates that the server detected an infinite \nloop while processing a request with \"Depth: infinity\". \n\n8 Properties\n\n8.1 reftarget Property\n\nName:\t    reftarget\nNamespace:  DAV:\nPurpose:    A property of redirect references that provides an efficient \n            way for clients to discover the URI of the target resource.  \n            This is a read-only property, whose value can only be set by \n            using the Ref-Target header with a MKREF request.\nValue: \t    URI of the target resource.  This value MAY be a relative       \n            URI.  The reftarget property can occur in the entity bodies \n            of responses to PROPFIND requests.  It always occurs in the \n            context of a Multi-Status response, inside a DAV:response \n            element that has a single DAV:href element.  \n\n<!ELEMENT reftarget href>\n\n8.2 refintegrity Property\n \nName:\t    refintegrity\nNamespace:  DAV:\nPurpose:    A property of a redirect reference that indicates whether \n            and how the server enforces referential integrity for that \n            reference.  The refintegrity property is defined to allow \n            future support for strong references.  The only value \n            currently defined for refintegrity is weak, which means that \n            the server does not enforce referential integrity for the \n            reference.  A server may assign another value to identify \n            its policy for enforcing referential integrity for the \n            reference.  This is a read-only property, set based on the \n            value of the Ref-Integrity header in the MKREF request that \n            created the reference.\nValue:\t    weak or an extension value\n\n<!ELEMENT refintegrity (weak | #PCDATA)>\n\n8.3 location Property\n\nName:       location\nNamespace:  DAV:\nPurpose:    For use with 302 (Moved Temporarily) response codes in \n            Multi-Status responses.  It contains the absolute URI of the \n            temporary location of the resource.  In the context of \n            redirect references, this value is the absolute URI of the \n            target resource.  It is analogous to the Location header in \n            HTTP 302 responses defined in [HTTP] Section 10.3.3 \"302 \n            Moved Temporarily.\"  Including the location property in a \n            Multi-Status response requires an extension to the syntax of \n            the DAV:response element defined in [WebDAV], which is \n            defined in Section 9 below.  This property is not expected \n\nSlein et al.                                                    Page 42\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n            to be stored on the reference. It is modeled as a property \n            only so that it can be returned inside a DAV:prop element in \n            a Multi-Status response.\nValue:      href containing the absolute URI of the target resource.\n\n<!ELEMENT location href >\n\n8.4 references Property\n\nName:\t    references\nNamespace:  DAV:\nPurpose:    Enables clients to discover, for any target resource, what \n            references point to it and what collections contain it by \n            reference.  This is an optional property.  If present, it is \n            a read-only property, maintained by the server.\nValue:\t    List of the URIs of the references that point to the target \n            resource.\n\n<!ELEMENT references (href*)>\n\n8.5 orderingtype Property\n\nName:\t    orderingtype\nNamespace:  DAV:\nPurpose:    Indicates whether the collection is ordered and, if so, \n            uniquely identifies the semantics of the ordering being \n            used.  May also point to an explanation of the semantics in \n            human and / or machine-readable form.  At a minimum, this \n            allows human users who add members to the collection to \n            understand where to position them in the ordering.\nValue:\t    unordered for an unordered collection, or a URI that \n            uniquely identifies the semantics of the collection's \n            ordering.  The value custom indicates that the collection is \n            ordered, but the semantics are not being advertised. \n\n<!ELEMENT orderingtype (unordered | custom | href) >\n\n9 XML Elements\n\n9.1 reference XML Element\n\nName: \t    reference\nNamespace:  DAV:\nPurpose:    A new value of the DAV:resourcetype property that identifies \n            its resource as a referential resource.  \nValue:\t    EMPTY\n\n<!ELEMENT reference EMPTY >\n\n9.2 weak XML Element\n\nName:\t    weak\nNamespace:  DAV:\nPurpose:    A value of the DAV:refintegrity property.  It means that the \n            server does not enforce referential integrity for the \n\nSlein et al.                                                    Page 43\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n            reference to which the property belongs.\nValue: \t    EMPTY\n\n<!ELEMENT weak EMPTY >\n\n9.3 unordered XML Element\n\nName:\t    unordered\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is not ordered.  That is, the client cannot \n            depend on the repeatability of the ordering of results from \n            a PROPFIND request.\nValue:\t    EMPTY\n\n<!ELEMENT unordered EMPTY >\n\n9.4 custom XML Element\n\nName: \t    custom\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is ordered, but the semantics of the ordering \n            are not being advertised. \nValue: \t    EMPTY\n\n<!ELEMENT custom EMPTY >\n\n9.5 order XML Element\n        \nName: \t    order\nNamespace:  DAV:\nPurpose:    For use with the new ORDERPATCH method.  Describes a change \n            to be made in a collection ordering.\nValue: \t    A description of the new positions of collection members in \n            the collection's ordering.\n\n<!ELEMENT order (ordermember+) >\n\n9.6 ordermember XML Element\n \nName: \t    ordermember\nNamespace:  DAV:\nPurpose:    Occurs in the order XML Element, and describes the new \n            position of a single collection member in the collection's \n            ordering.\nValue: \t    An href containing a relative URI, and a description of its \n            new position in the ordering.  The href XML element is \n            defined in [WebDAV], Section 11.3.\n\n<!ELEMENT ordermember (href, position) >\n\n9.7 position XML Element\n\nName: \t    position\n\nSlein et al.                                                    Page 44\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nNamespace:  DAV:\nPurpose:    Occurs in the member XML element.  Describes the new \n            position in a collection's ordering of one of the \n            collection's members.\nValue: \t    The new position can be described as first in the \n            collection's ordering, last in the collection's ordering, \n            before some other member of the collection, or after some \n            other member of the collection.\n\n<!ELEMENT position (first | last | before | after)>\n\n9.8 first XML Element\n\nName: \t    first\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as first in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT first EMPTY >\n\n9.9 last XML Element\n\nName: \t    last\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as last in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT last EMPTY >\n\n9.10 before XML Element\n\nName: \t    before\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming before some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it precedes in the ordering\n\n<!ELEMENT before href >\n\n9.11 after XML Element\n\nName: \t    after\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming after some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it follows in the ordering\n\n<!ELEMENT after href >\n\n\nSlein et al.                                                    Page 45\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n9.12 options XML Element\n\nName:       options\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for more detailed     \n            information about capabilities than can be provided in the  \n            DAV: response header.  Used in OPTIONS responses to provide\n            that information.\nValue:      List of elements identifying or providing the additional \n            information desired.\n\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n\n9.13 refintegrityoptions XML Element\n\nName:       refintegrityoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list of referential       \n            enforcement policies that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n            This is the list of valid values for the Ref-Integrity \n            Header for that request-URI.\nValue:      EMPTY on requests.  On responses, it is the list of valid \n            values for Ref-Integrity.\n\n<!ELEMENT refintegrityoptions ( (#PCDATA)+ | EMPTY) >\n\n9.14 orderingoptions XML Element\n\nName:       orderingoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list server-    \n            maintained orderings that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n            These values can be used in the Ordered header or the \n            DAV:orderingtype property to request that a particular  \n            server-maintained ordering be applied to the collection.\nValue:      EMPTY on requests.  On responses, it is the list of server-\n            maintained orderings available for the request-URI.\n\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n\n9.15 do-not-enforce XML Element\n\nName:       do-not-enforce\nNamespace:  DAV:\nPurpose:    Used in responses to OPTIONS requests for \n            refintegrityoptions, to indicate that the server can honor \n            requests that referential integrity not be enforced for the \n            request-URI.  If it is included in an OPTIONS response, then \n            the client can use it as a value of the Ref-Integrity header \n            in a MKREF request to the same URI.\nValue:      EMPTY.\n\n<!ELEMENT do-not-enforce EMPTY >\n\nSlein et al.                                                    Page 46\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\n10 Extensions to the DAV:response XML Element for Multi-Status Responses\n\nAs described in Sections 4.6 and 4.9, the DAV:location property and the \nDAV:reftype property may be returned in the DAV:response element of a \n207 Multi-Status response, to allow clients to resubmit their requests \nto the target resource of a redirect reference.  \n\nWhenever these properties are included in a Multi-Status response, they \nwill be placed in a DAV:prop element associated with the href to which \nthey apply.  This structure provides a framework for future extensions \nby other standards that may need to include additional properties in \ntheir responses.\n\nConsequently, the definition of the DAV:response XML element changes to \nthe following:\n\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n11 Capability Discovery\n\n11.1 Compliance Classes\n\nThis specification defines OPTIONAL extensions to [WebDAV].  Since \nresource sharing and ordering are independent capabilities, a resource \nMAY support either, both, or neither of these capabilities.  A resource \nthat provides resource sharing MUST support both bindings and redirect \nreferences.  A response to an OPTIONS request MUST indicate which of \nthese capabilities the resource supports.\n\nThis specification defines three new methods: BIND and MKREF in support \nof shared resources, and ORDERPATCH in support of ordering.  The \nresponse MUST indicate which of these methods the resource allows.  In \naddition, the response MUST include the DAV header, as described in \nSections 9.1 and 15 of [WebDAV].  Two new compliance classes are defined \nhere for use with the DAV header: sharing and orderedcoll. \n\nWhen responding to an OPTIONS request, only a collection or a null \nresource can include orderedcoll in the value of the DAV header.  By \nincluding orderedcoll, the resource indicates that its immediate member \nURIs can be ordered.  It implies nothing about whether any collections \nidentified by its member URIs can be ordered.\n\nWhen responding to an OPTIONS request, any type of resource can include \nsharing in the value of the DAV header.  Including sharing indicates \nthat the server permits a redirect reference or a binding at the request \nURI.\n\n11.2 Example: Discovery of Compliance Classes\n\nRequest:\n\nOPTIONS /somecollection/ HTTP/1.1\nHOST: somehost.org\n\nSlein et al.                                                    Page 47\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF, ORDERPATCH\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF, ORDERPATCH\nDAV: 1, 2, sharing, orderedcoll\n\nThis response indicates that the resource /somecollection/ is level 1 \nand level 2 compliant, as defined in [WebDAV].  In addition, \n/somecollection/ supports ordering and is in a part of the server \nnamespace that allows creation of bindings and redirect references. \n\n11.3 Additional Advanced Collections Capabilities\n\nClients may need detailed information about specific areas of advanced \ncollections functionality.  This information can be requested by sending \nan OPTIONS request with an XML body that includes a DAV:options element.  \nThe DAV:options element contains a list of empty elements identifying \nthe information the client needs.\n\nAs described in Section 4.5, clients are required to include the Ref-\nIntegrity header in any MKREF request to specify the desired referential \nintegrity enforcement policy for the new reference.  The only value of \nRef-Integrity defined in this specification is DAV:do-not-enforce.  If \nthe client wants referential integrity to be enforced, it needs to know \nwhat other values of Ref-Integrity the server can support.  To discover \nwhat values can be used for a particular request-URI, the client \nincludes an empty DAV:refintegrityoptions element in the DAV:options \nelement.  The response will include a DAV:refintegrityoptions element \nwith the list of supported referential integrity enforcement policies.  \nServers MUST advertise the referential integrity enforcement policies \navailable at a URI using this mechanism.\n\nAs described in Section 5.2, servers may offer a set of server-\nmaintained orderings on collections.  Clients can discover the list of \nserver-maintained orderings available for the request-URI by including \nan empty DAV:orderingoptions element in the DAV:options element.  The \nresponse will include a DAV:orderingoptions element with the list of \nsupported server-maintained orderings.  Servers SHOULD advertise the \nserver-maintained orderings available using this mechanism.\n\n11.4 Example: Discovery of Referential Integrity Options\n\nRequest:\n\nOPTIONS /somecollection/fooref HTTP/1.1\nHOST: somehost.org\n\n<?xml version=\"1.0\" ?>\n\nSlein et al.                                                    Page 48\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n<D:options xmlns:D=\"DAV:\">\n  <D:refintegrityoptions/>\n</D:options>\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF\nDAV: 1, sharing\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:refintegrityoptions xmlns:X=\"Xerox:\">\n      <D:do-not-enforce/>\n      <X:block-deletes/>\n  </D:refintegrityoptions>\n</D:options>\n\nThis response indicates that the resource /somecollection/fooref is \nlevel 1 compliant, as defined in [WebDAV].  In addition, \n/somecollection/fooref is in a part of the server namespace that allows \ncreation of bindings and redirect references.  The client also asked for \na list of the values of Ref-Integrity that are supported for \n/somecollection/fooref.  The response indicates that the values DAV:do-\nnot-enforce and Xerox:block-deletes are supported.\n\n12 Dependencies on Other Specifications\n\nTBD\n\n13 Security Considerations\n\nThis section is provided to detail issues concerning security \nimplications of which WebDAV applications need to be aware. \n\nAll of the security considerations of HTTP/1.1 and the base WebDAV \nprotocol also apply to WebDAV collections.  In addition, referential \nresources and ordered collections introduce several new security \nconcerns and increase the risk of some existing threats.  These issues \nare detailed below.\n\n13.1 Privacy Concerns\n\nBy creating redirect references on a trusted server, it is possible for \na hostile agent to induce users to send private information to a target \non a different server.   This risk is mitigated somewhat, since clients \nare required to notify the user of the redirection for any request other \nthan GET or HEAD. (See [HTTP], Section 10.3.3 Moved Temporarily.)\n\n\nSlein et al.                                                    Page 49\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n13.2 Redirect Loops\n\nAlthough redirect loops were already possible in HTTP 1.1, the \nintroduction of the BIND and MKREF methods creates a new avenue for \nclients to create loops accidentally or maliciously.  If the referential \nresource and its target are on the same server, the server may be able \nto detect MKREF and BIND requests that would create loops. See also \n[HTTP], Section 10.3 \"Redirection 3xx.\"  Servers are required to detect \nloops caused by bindings to collections, during the processing of any \nrequests with \"Depth: infinity\".\n\n13.3 Redirect References, Bindings, and Denial of Service\n\nDenial of service attacks were already possible by posting URLs that \nwere intended for limited use at heavily used Web sites.  The \nintroduction of BIND and MKREF creates a new avenue for similar denial \nof service attacks.  Clients can now create bindings and redirect \nreferences with target resources at heavily used sites to target \nlocations that were not designed for heavy usage.\n\n13.4 Private Locations May Be Revealed\n\nThere are several ways that redirect references may reveal information \nabout directory structures.  First, the DAV:reftarget property of every \nredirect reference contains the URI of the target resource.  Anyone who \nhas access to the reference can discover the directory path that leads \nto the target resource.   The owner of the target resource may have \nwanted to limit knowledge of this directory structure.\n\nSufficiently powerful access control mechanisms can control this risk to \nsome extent.  Property-level access control could prevent users from \nexamining the DAV:reftarget property.  (The Ref-Target and Location \nheaders, which are returned in most responses to requests on redirect \nreferences, reveal the same information, however.)  In some \nenvironments, the owner of a resource might be able to use access \ncontrol to prevent others from creating references to that resource.\n\nSecond, although this specification does not require servers to maintain \nreferential integrity, it does not prevent them from doing so.  If a \nserver updates a redirect reference\u2019s DAV:reftarget property when its \ntarget resource is moved, there is the risk that a private location will \nbe revealed in the new value of DAV:reftarget.  Clients can avoid this \nrisk by doing a COPY followed by a DELETE rather than a MOVE.\n\nFinally, if backpointers are maintained on the target resource, the \nowners of redirect references and bindings face these same risks.  The \ndirectory structures where references or bindings are located are \nrevealed to anyone who has access to the DAV:references property on a \ntarget resource.  Moving a redirect reference may reveal its new \nlocation to anyone with access to DAV:references on its target resource.\n\n13.5 DAV:references and Denial of Service\n\nIf the server maintains the DAV:references property in response to \nreferences created in other administrative domains, it is exposed to \n\nSlein et al.                                                    Page 50\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\nhostile attempts to make it devote resources to adding references to the \nlist.\n\n13.6 DAV:references and Malicious Deletion of Resources\n\nServers that support the DAV:references property should insure that \nclients cannot create editable properties with the name DAV:references.  \nAn editable DAV:references property would constitute a security risk on \nservers that enforce referential integrity by deleting redirect \nreferences or bindings when their target is deleted.  These servers \ncould be tricked into deleting a resource by listing it in the \nDAV:references property of some target resource.\n\n13.7 Denial of Service and DAV:orderingtype\n\nThere may be some risk of denial of service at sites that are advertised \nin the DAV:orderingtype property of collections.  However, it is \nanticipated that widely-deployed applications will use hard-coded values \nfor frequently-used ordering semantics rather than looking up the \nsemantics at the location specified by DAV:orderingtype.  In addition, \nSection 5.2 discourages clients from looking up the semantics at that \nlocation.\n\n14 Internationalization Considerations\n\nThis specification follows the practices of [WebDAV] in encoding all \nhuman-readable content using XML [XML] and in the treatment of names.  \nConsequently, this specification complies with the IETF Character Set \nPolicy [Alvestrand].\n\nWebDAV applications MUST support the character set tagging, character \nset encoding, and the language tagging functionality of the XML \nspecification.  This constraint ensures that the human-readable content \nof this specification complies with [Alvestrand].\n\nAs in [WebDAV}, names in this specification fall into three categories: \nnames of protocol elements such as methods and headers, names of XML \nelements, and names of properties.  Naming of protocol elements follows \nthe precedent of HTTP, using English names encoded in USASCII for \nmethods and headers.  The names of XML elements used in this \nspecification are English names encoded in UTF-8.\n\nFor error reporting, [WebDAV] follows the convention of HTTP/1.1 status \ncodes, including with each status code a short, English description of \nthe code (e.g., 423 Locked).  Internationalized applications will ignore \nthis message, and display an appropriate message in the user's language \nand character set.\n \nFor rationales for these decisions and advice for application \nimplementors, see [WebDAV].\n\n15 IANA Considerations\n\nThis document uses the namespaces defined by [WebDAV] for properties and \nXML elements.  All other IANA considerations mentioned in [WebDAV] also \n\nSlein et al.                                                    Page 51\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\napply to this document.\n\n16 Copyright\n\nTo be supplied.\n\n17 Intellectual Property\n\nTo be supplied.\n\n18 Acknowledgements\n\nThis draft has benefited from thoughtful discussion by Jim Amsden, Steve \nCarter, Ken Coar, Ellis Cohen, Bruce Cragun, Jason Crawford, Spencer \nDawkins, Mark Day, Rajiv Dulepet, David Durand, Roy Fielding, Yaron \nGoland, Fred Hitt, Alex Hopmann, Marcus Jager, Chris Kaler, Manoj \nKasichainula, Rohit Khare, Daniel LaLiberte, Steve Martin, Larry \nMasinter, Jeff McAffer, Surendra Koduru Reddy, Max Rible, Sam Ruby, \nBradley Sergeant, Nick Shelness, John Stracke, John Tigue, John Turner, \nand others.\n\n19 References\n\n19.1 Normative References\n\n[URI] T. Berners-Lee, R. Fielding, L. Masinter, \"Uniform Resource \nIdentifiers (URI): Generic Syntax.\" RFC 2396. MIT/LCS, U.C. Irvine, \nXerox. August, 1998.\n\n[RFC2119] S. Bradner, \"Key words for use in RFCs to Indicate Requirement \nLevels.\"  RFC 2119, BCP 14.  Harvard University.  March, 1997.\n\n[XML] T. Bray, J. Paoli, C.M. Sperberg-McQueen, \"Extensible Markup \nLanguage (XML).\"  World Wide Web Consortium Recommendation REC-xml-\n19980210. http://www.w3.org/TR/1998/REC-xml-19980210.\n\n[HTTP] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-Lee, \n\"Hypertext Transfer Protocol -- HTTP/1.1.\" RFC 2068.  UC Irvine, DEC, \nMIT/LCS.  January, 1997.\n\n[WebDAV] Y. Y. Goland, E. J. Whitehead, Jr., A. Faizi, S. R. Carter, D. \nJensen, \"HTTP Extensions for Distributed Authoring - WebDAV.\" RFC 2518.  \nMicrosoft, U.C. Irvine, Netscape, Novell.  February, 1999.\n\n19.2 Informational References\n\n[DASL] Saveen Reddy, D. Jensen, Surendra Reddy, R. Henderson, J. Davis, \nA. Babich, \"DAV Searching & Locating.\" Draft-reddy-dasl-protocol-03. \nInternet Draft, work in progress. Microsoft, Novell, Oracle, Netscape, \nXerox, Filenet.  November, 1998.\n \n[CollReq] J. Slein, J. Davis, \"Requirements for Advanced Collection \nFunctionality in WebDAV.\" Draft-ietf-webdav-collection-reqts-02. \nInternet Draft, work in progress.  Xerox.  February, 1999.\n\n\nSlein et al.                                                    Page 52\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n20 Authors' Addresses\n\nJ. Slein\nXerox Corporation\n800 Phillips Road, 105-50C\nWebster, NY 14580\nEmail: jslein@crt.xerox.com\n\nJ. Davis\nCourseNet Systems\n170 Capp Street\nSan Francisco, CA 94110\nEmail: jrd3@alum.mit.edu\n\nT. Chihaya\nDataChannel, Inc.\n155 108th Ave. N.E., Suite 400\nBellevue, WA 98004\nEmail: Tyson@DataChannel.com\n\nG. Clemm\nRational Software Corporation\n20 Maguire Road\nLexington, MA 02173-3104\nEmail: gclemm@rational.com\n\nC. Fay\nFileNet Corporation\n3565 Harbor Boulevard\nCosta Mesa, CA 92626-1420\nEmail: cfay@filenet.com\n\nE. J. Whitehead, Jr.\nDept. of Information and Computer Science\nUniversity of California, Irvine\nIrvine, CA 92697-3425\nEmail: ejw@ics.uci.edu\n\n21 Appendices\n\n21.1 Appendix 1: Extensions to the WebDAV Document Type Definition\n\n<!--============= XML Elements from Section 8 =======================--\n><!ELEMENT reference EMPTY >\n<!ELEMENT weak EMPTY >\n<!ELEMENT unordered EMPTY >\n<!ELEMENT custom EMPTY >\n<!ELEMENT order (ordermember+) >\n<!ELEMENT ordermember (href, position) >\n<!ELEMENT position (first | last | before | after)>\n<!ELEMENT first EMPTY >\n<!ELEMENT last EMPTY >\n<!ELEMENT before href >\n<!ELEMENT after href >\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n\nSlein et al.                                                    Page 53\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\n<!ELEMENT refintegrityoptions ( (#PCDATA)+ | EMPTY) >\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n<!ELEMENT do-not-enforce EMPTY >\n<!--============= Property Elements from Section 7 ==================-->\n<!ELEMENT reftarget href>\n<!ELEMENT refintegrity (weak | #PCDATA)>\n<!ELEMENT location href>\n<!ELEMENT references (href*)>\n<!ELEMENT orderingtype (arbitrary | custom | href) >\n<!--====== Changes to the DAV:response Element from Section 9 ====-->\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n21.2 Appendix 2: Design Choices Considered, But Not Adopted\n\n21.3 Reference Scope\n\n[CollReq] states requirements for 4 different kinds of references: weak \nreferences, strong references, redirect references, and direct \nreferences.  This specification supports weak references and redirect \nreferences, and is designed so that it can be extended to support strong \nreferences in the future.  The bindings defined here provide many of the \nfeatures of direct references while avoiding some of their complexities.  \nDirect references can also be added in the future.\n\n21.3.1 Strong References out of Scope\n\nStrong references are references whose integrity is enforced by the \nserver; weak references are those whose integrity is not enforced by the \nserver.  Strong references and weak references are both useful in \ndifferent contexts.  Some applications cannot tolerate broken links.  A \nsoftware development application, for example, must be able to rely on \nthe integrity of references to component modules. Such applications must \nbe able to request strong references.  Other applications may want to \nreference target resources on multiple servers, where referential \nintegrity cannot be enforced, and may be less concerned about possible \nbroken references.  Weak references may even be required by some \napplications.  For example, it may be a common occurrence in some \napplications for content to be temporarily removed, so that references \nare temporarily left dangling.\n\nSeveral considerations led to the decision not to support strong \nreferences in the current specification.  First, there are many possible \npolicies that applications and services might use in enforcing \nreferential integrity.  Some examples are:\n\no Delete strong references when their targets are deleted.\no Decline to delete targets of strong references.\no Notify strong references when their targets have been deleted.\no Replace strong references with copies of their targets before \n  deleting the targets.\n\nThere appears to be no common practice in this area.  Moreover, some of \nthe policies have significant security risks.\n\n\nSlein et al.                                                    Page 54\n\fINTERNET-DRAFT            WebDAV Collections Protocol          May 1999\n\no Moving a target of strong references could be a security risk to the \n  owner of the target by revealing secret locations on the target's \n  server.\no A strong reference could be a security risk to the owner of the \n  reference by revealing secret locations on his server.\no The presence of strong references to resources on a server could make \n  it impossible to reclaim space on that server by moving or deleting \n  those target resources. \n\nThese considerations together led to the decision not to support strong \nreferences in the short term. \n\n21.3.2 Direct References out of Scope\n\nDirect references would have provided some features that bindings do \nnot.  For example, direct references are resources that can have \nproperties of their own.  In addition, direct references may be weak or \nstrong, and can support a variety of policies for enforcing referential \nintegrity.\n\nHowever, direct references raise a number of design issues that do not \narise for bindings.  It is unclear what the semantics of COPY, MOVE, and \nLOCK should be for direct references, whereas the semantics of all \noperations for bindings have already been defined by [HTTP] and \n[WebDAV].  In addition, behaviors would have to be defined for chains of \ndirect references and for dangling direct references, neither of which \ncan occur in the case of bindings. \n\nThese considerations led to the decision not to support direct \nreferences in the short term.\n\nExpires November 14, 1999\n\nSlein et al.                                                    Page 55\n\f", "encoding": "Windows-1252"}