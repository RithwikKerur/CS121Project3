{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/operatoroverloading1.txt", "content": "\t\t\tOperator Overloading I\r\n\r\n\r\nNow that we have reviewed the fundamentals of classes, we are going to cover\r\nsome new material about them: how we can write certain class methods that are\r\nused by Python in a special way: we typically don't call these methods directly,\r\nbut instead Python calls them automatically based on our use of []s, operators,\r\nkeywords, conversion functions, etc. All these special methods have their names\r\nwriten between double underscores (just like __init__ which is also one of\r\nthese special methods that we have seen how Python calls automatically). We can\r\ncall them by their double-underscore name (but more often than not, don't).\r\n\r\nMost of these methods (but not all) are invoked by Python operators (whose first\r\narguments are instances of the class that they are defined in) so we call this\r\ntechnique \"operator overloading\": it means overloading (giving more than one\r\nmeaning to) the standard operators, applying to objects constructed from\r\ndifferent programmer-defined classes (which really is an application of\r\n\"polymorphism\", which translates to \"many forms\": the same operators work on\r\nmany forms of data). Overloading has a good, not bad, connotation here. By\r\nstudying operator overloading, we will better understand how Python executes\r\nour programs, and be able to write classes that are more powerful, by\r\nexploiting our understanding of this mechanism.\r\n\r\nWhile learning this material, we illustrate each overloaded operator simply with\r\nmethods defined in a \"simple\" class, Vector. Later we will apply this technique\r\nto a bigger examples; but, a typical class has only some of its operators\r\noverloaded: not all operators are meaningfully overloaded for every class.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\n__init__\r\n\r\nThe example that we will use throughout this lecture is storing and manipulating\r\nVectors: a mathematical quantity that represents a point in N-dimensional space.\r\nWe will represent a Vector by a tuple of N coordinates; the length of the tuple\r\n(N, its number of coordinates) specifies the dimension of the space in which the\r\nvector resides: 2-dimesional, 3-dimensional, etc.\r\n\r\nWe'll start with __init__ because you have probably already written many of\r\nthese methods. Recall that when you \"call the class\" (write the class name\r\nfollowed by parentheses), you can supply it with some arguments. Python creates\r\nan object (something that has an empty namespace/__dict__) for the instance of \r\nthe class and then calls __init__ with self as the first parameter (a reference\r\nto the empty object it just created) followed by all the  other arguments in\r\nthe \"call of the class\".  So writing Vector(a,b,c) means that Python will call\r\nVector.__init__(self,*args) where self refers to the empty object Python just\r\ncreated and the *args combines all its matching positional arguments into a \r\nsingle tuple.\r\n\r\nclass Vector:\r\n    def __init__(self,*args):\r\n        self.coords = args\r\n\r\nNote that self.coords = ... establishes a new attribute name in the namespace\r\nof the constructed object and initializes it to the tuple args. In light of the\r\nlast lecture, I should have named this self/instance variable _coords or\r\n__coords (to indicate no programmer should access that attribute: e.g., not \r\nrebind it to a string!), but for simplicity's sake, I'll leave it as coords (I\r\ndo access that attribute outside the class methods, but only, for illustration\r\npurposes, as I do directly below).\r\n        \r\nLike the methods that we will discuss below, we don't call __init__ directly,\r\nbut Python does, automatically, when we \"call the Vector class\" to construct a\r\nnew object from that class.\r\n\r\nNote that we can also use __init__ another way in Python: we can call __init__\r\nexplicitly on any existing Vector object, to reinitialize its coords attribute.\r\n\r\nv = Vector(0,0)\r\nprint(v.coords)\r\n\r\nv.coords = (1,1)\r\nprint(v.coords)\r\n\r\nv.__init__(5,5,5,5,5)    # We can call __init__ explictly, like any other method\r\nprint(v.coords)\r\n\r\nprints\r\n  (0, 0)\r\n  (1, 1)\r\n  (5, 5, 5, 5, 5)\r\n\r\nWhen we discuss inheritance later in the quarter, we will see more examples of\r\nexplicit calls to the __init__ method.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n__len__\r\n\r\nWe can call the len function on any object. It translates into a call of the\r\nparameterless __len__ method on the object. The len function is defined, and\r\nautomatically imported from the builtins module, as approximately the following\r\ncode:\r\n\r\ndef len(x):\r\n    return x.__len__()\r\n\r\nNote that some objects (e.g., those of class/type int) do not define a __len__\r\nmethod, for example the int class. So, if we call len(1), Python raises an\r\nexception and reports:\r\n\r\n  TypeError: object of type 'int' has no len()\r\n\r\nThis is exactly because len(1) calls/returns 1.__len__() which FEOOP translates\r\ninto type(1).__len__(1) which is int.__len__(1) but the int class defines no\r\n__len__ method, so Python reports an error. It might actually be useful for the\r\nint class to define len for ints: maybe returning the number of digits (in base\r\n10) for that int. But in Python, len is not defined for ints.\r\n\r\nIn fact, Python requires that the len function always return an integer value,\r\nso a more accurate definition of len is\r\n\r\ndef len(x):\r\n    answer = x.__len__()\r\n    if type(answer) is not int:\r\n        raise TypeError(str(type_as_str(x))+' object cannot be interpreted as an integer')\r\n    return answer\r\n\r\nNote that str(type(1)) returns the string \"<class 'int'>\"; likewise\r\nstr(type(Vector(0,0)) returns the string \"<class '__main__.Vector'>\". The\r\nfunction type_as_str (defined in the goody module) slices this string [8,-2]\r\n(from 8 to one before 2nd to last), producing 'int' and '__main__.Vector',\r\nrespectively .\r\n\r\nThe following code extends our Vector class to illustrate this method. The len\r\nmethod returns the dimension of the vector: the number of values in the tuple\r\nused to represent the vector.\r\n\r\nclass Vector:\r\n    def __init__(self,*args):\r\n        self.coords = args\r\n\r\n    def __len__(self):\r\n        print('Calling __len__')\r\n        return len(self.coords)\r\n\r\n\r\nv = Vector(0,0)\r\nprint(len(v))\r\n\r\nThis script prints 'Calling __len__' and then 2.\r\n\r\nWhat do you think would happen if we changed the last statment in __len__ from\r\nreturn len(self.coords) to return len(self)? Check your intuition by running\r\nthis code and justifying the result it produces.\r\n\r\nGenerally we should not call dunder methods explicitly (not always, but\r\ngenerally; __init__ is an exception). For built-in types (like str) calling\r\nlen(s) is faster than calling x.__len__(); also, as we have just seen,\r\nsometimes len does extra processing not done by the dunder method it calls.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n__bool__\r\n\r\nWhenever Python needs to interpret some object as a boolean value, it calls the\r\nparameterless method __bool__ on the object. For example, if we write an \"if\"\r\nor \"while\" statement whose boolean test is just an object, Python attempts to\r\ncall the __bool__function on that object to determine whether its boolean\r\nequivalent represents True or False.\r\n\r\nUsing the definition of Vector above (defining just __init__ and __len__) and\r\nthe test function below\r\n\r\ndef test(x):\r\n    print('x\\'s boolean equivalent is ')\r\n    if x:\r\n        print(True)\r\n    else:\r\n        print(False)\r\n\r\nwhen we execute the script\r\n\r\nv = Vector(0,0)\r\ntest(v)\r\n\r\nv = Vector(2,2)\r\ntest(v)\r\n\r\nv = Vector()\r\ntest(v)\r\n\r\nit prints\r\n\r\n  Calling __len__\r\n  True\r\n  Calling __len__\r\n  True\r\n  Calling __len__\r\n  False\r\n\r\nThis leads to two questions:\r\n  1) How did it compute the boolean equivalent of a Vector?\r\n  2) Why is __len__being called?\r\n\r\nThe actual rule in Python for evaluating an object as if it were a boolean\r\nvalue is to first try to call __bool__ on the object (which cannot be done\r\nabove, because a __bool__ method is not defined for the Vector class yet) and\r\nreturn its result; if that method is not present, Python instead returns whether\r\nthe object's len is != 0. If there is no __len__ function Python just returns\r\nTrue (the mechanism to do this is actually related to inheritance, a topic we\r\nwill cover later in the quarter).\r\n\r\nThis rule explains why we can test str, list, tuple, set, and dict objects as\r\nbooleans: all define __len__, and if any is empty (len = 0) it represents\r\nFalse; if any is not empty, it represents True.  Also, the object None has a\r\nboolean value of False (the NoneType class specifies a __bool__ method that\r\nalways return False).\r\n\r\nSo, when v = Vector(0,0) or v = Vector(2,2), len(v) is 2 which is != 0, so it\r\nis treated as True. When v = Vector(), len(v) is 0 which is not != 0 so it is\r\ntreated as False.\r\n\r\nBut suppose that we want to interpret vectors as boolean values differently. We\r\nwill define Vector so that an instance is True if self.coords is not the\r\norigin, regardless of the vector's dimension: so, it is True if any of the\r\ncoordinates in self.coords is not 0.\r\n\r\nclass Vector:\r\n    def __init__(self,*args):\r\n        self.coords = args\r\n\r\n    def __len__(self):\r\n        print('Calling __len__')\r\n        return len(self.coords)\r\n\r\n    def __bool__(self):\r\n        print('Calling __bool__')\r\n        return any( v!=0 for v in self.coords )\r\n\r\nHere we call the any function applied to a tuple of bool values, created by a\r\ncomprehension, each specifying whether one coordinate in self.coords isn't zero.\r\n\r\nSo the boolean value for Vector(0,0) would return False, Vector() would return\r\nFalse too (because any(()) is False: there are no True values because there are\r\nno values! But Vector(2,2) would return True. All three of these exammples\r\nreturn their values because Python uses the __bool__ function supplied above,\r\nand doesn't have to (nor does it) call the len function to compute an answer.\r\n\r\nNote, if we wrote\r\n\r\n        return not all( v==0 for v in self.coords )\r\n\r\nwe would get the same results as above. Note that for Vector(), all(())returns \r\nTrue: not one value is False, because there are no values. This is how the all\r\nand any functions work with arguments containing no/0 values.\r\n\r\nAnother possible implementation of len would compute distance of the tip of the\r\nVector from the origin.\r\n\r\n    def __len__(self):\r\n        return math.sqrt( sum( v**2 for v in self.coords ) )\r\n\r\nIf we wrote the __len__ method this way, could omit the __bool__ method? Would\r\nPython then compute bool(x) by evaluating len(x) != 0; len(x) != 0 is True only\r\nwhen any of its coords are not equal to 0.\r\n\r\nUnfortunately, this __len__ returns a float value, not the require int, so we\r\ncannot use it in our class as a stand-in for __bool__.\r\n\r\nThere is no single \"right\" __len__ definition for Vector; as the implementors of\r\nthe Vector class we can define __len__ in almost any way that we want (subject\r\nto the constraint of returning an int).\r\n\r\nThe bool function also calls __bool__, but unlike the len function, it does not\r\nrequire a certain return type: we can write a __bool__ function that returns\r\nany type (see the \"Going really deep into and/or\" section below).\r\n\r\nFinally, if we write a class that defines neither __bool__ nor __len__ then the\r\nboolean equivalent of any object constructed from that class is always True.\r\n\r\n--------------------\r\n\r\nInterlude: Short-Circuit Logical Operators: and their real meanings\r\n\r\nThe operators and/or are called short-ciruit operators, because unlike other\r\noperators (which evaluate both of their operands before being applied), short-\r\ncircuit operators evaluate only their left operand first, and sometimes don't\r\nneed to evaluate their right operand: True or ... always evaluates to True and\r\nFalse and ... always evaluates to False. So if the \"or\" operator's left operand\r\nis True, it doesn't need to evaluate its right operand: the result is always\r\nTrue; and if the \"and\" operator's left operand is False, it doesn't need to\r\nevaluate its right operand: the result is always False.\r\n\r\nThis rule sometimes saves execution time (avoids the cost of evaluating the\r\nright argument), but it is more important for another reason (discussed below).\r\n\r\nIf the left operands of and/or is True/False it must evaluate the right operand\r\nin order to compute its result.\r\n\r\nSo, for example, if we wrote the following if/test (assume d is a dict)\r\n\r\n  if k in d.keys() and d[k] == 0:\r\n      ....\r\n\r\nPython would first evaluate the expression: k in d.keys(). When False it would\r\ndetermine that the value of the \"and\" operator is already known: it is False. It\r\nwould not have to evaluate d[k] == 0, which is a good thing, because evaluating\r\nd[k] would raise a KeyError exception, because k is not a key in d: just what\r\ni in d.keys() is checking. \r\n\r\nSo, while short-circuit operators can save a little time, that is not their\r\nmost important purpose; avoiding raising exceptions is the primary reason that\r\nand/or operators are short-circuit.\r\n\r\nEven without short-circuit operators, we could write this same statement as\r\n\r\n  if k in d.keys():\r\n      if d[k] == 0:\r\n          ....\r\n\r\nBut that requires nested if statements and is much more cumbersome to write. It\r\nis better to spend some time learning about and understanding short-circuit\r\nlogical operators now, and then be able to use them appropriately later, to\r\nwrite simpler and cleaner code.\r\n\r\n----------\r\nGoing really deep into and/or\r\n\r\nFinally, the exact meaning of and/or is a bit more subtle, and concerns the\r\nboolean interpretation of values (i.e., the __bool__ methods). Let's look at\r\n\"and\" first. If the boolean interpretation (computed by __bool__) of the left\r\noperand of \"and\" is False, we know that we don't have to evaluate the right\r\noperand. We said that the result is False, but realy the result is the actual\r\nvalue of left operand, not its boolean interpretation. So [] and ... evaluates\r\nto [] (a value whose boolean interpretation is False); likewise \"\" and ...\r\nevaluates to \"\" (a value whose boolean interpretation is False).\r\n\r\nLikewise if the boolean interpretation (computed by __bool__) of the left\r\noperand of \"or\" is True, we know that we don't have to evaluate the right\r\noperand. We said that the result is True, but realy the result is the actual\r\nvalue of left operand, not its boolean interpretation. So [1] or ... evaluates\r\nto [1] (a value whose boolean value is True); likewise \"abc\" or ... evaluates\r\nto \"abc\" (a value whose boolean interpretation is True).\r\n\r\nSimilarly, if the boolean interpretation of the left operand of \"or\" is False,\r\nwe need to evaluate the right operand to compute the result of \"or\", and the\r\nresult will be the value of just the right operand (not its boolean\r\ninterpretation): so (any value considered False) or [] evaluates to [], and\r\n(any value considered False) or [1] evaluates to [1]. Of course Python can\r\ndetermine if this value is interpreted as True or False, if it needs to.\r\n\r\nLikewise, if the boolean interpretation of the left operand of \"and\" is True, we\r\nneed to evaluate the right operand to compute the result of \"and\", and the\r\nresult will just be the value of the right operand (not its boolean\r\ninterpretation): so (any value considered True) and [] evaluates to [], and\r\n(any value considered True) and [1] evaluates to [1]. Of course Python can\r\ndetermine if this value is interpreted as True or False, if it is needs to.\r\n\r\nMost programmers use logical operators where boolean values are needed (like in\r\n\"if\" and \"while\" loops), so regardless of their strange results, we are\r\ninterested only in the boolean interpretation of the result (which correponds\r\nto our intution about and/or). But the reality in Python is a bit subtler, and\r\nsometimes programmers do rely on understanding the exact meaning of the and/or\r\noperators.\r\n\r\nSometimes programmers find interesting uses for these semantics. For example,\r\n\r\nSuppose last stores the last name of a person, and first their first name, but\r\nfor some people we don't know their first name (it is stored as either None or\r\n''). Suppose we want to call someone by their first name, but if we don't know\r\nit we want to call them by their last name prefaced by Mr. We could write\r\n\r\nif first != '' and first != None:\r\n    call_me = first\r\nelse:\r\n    call_me = 'Mr. ' + last\r\n\r\nIn fact, because both '' and None have False as their boolean value we can write\r\n\r\nif first:\r\n    call_me = first\r\nelse:\r\n    call_me = 'Mr. ' + last\r\n\r\nAnd if we really want to use our knowledge of Python we can write\r\n\r\ncall_me = first or 'Mr. ' + last\r\n\r\nNote that because of the \"or\" operator, if first is not equivalent to the\r\nboolean False, it will be assigned to call_me; if it is equivalent to the\r\nbloolean False, then 'Mr.'+last will be assigned to call_me. Some would argue\r\nthe single assignment is a bit cryptic: but you should know what it means in\r\nPython. Some would prefer call_me = (first if first != '' else 'Mr. '+last)\r\nwhich executes equivalently\r\n----------\r\n\r\nNote that \"not\" has only one operand, so there is no way to short-circuit it.\r\nAlso, note that \"not\" always returns a bool value (unlike what we learned\r\nabove). That is, not [] evaluates to True; not [1] evalutes to False.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n__repr__ and __str__ (and other conversion functions)\r\n\r\nPython can call two methods that should return string representations of an\r\nobject. The __str__ method is called when the conversion function str is called:\r\nso again, this is like len: Python translates str(x) into type(x).__str__(x).\r\n\r\nFor example, the print and format functions automatically calls str on all their\r\narguments. If there is no __str__ method in the argument's class, Python\r\ntries calling the __repr__ method as a backup to produce the string. If we call\r\nrepr(x) Python returns x.__repr__() for this method, similarly to what it does\r\nfor len(x) and str(x)). If there is no __repr__method, Python reverts to its\r\nstandard method for computing a string value for objects: a bracketed string \r\nwith the name of the object's class and the location of this object in memory\r\n(as a hexidecimal number). In the last lecture we saw that with x = C(),\r\nprint(x) prints like <__main__.C object at 0x02889C50>. When we cover\r\ninheritance, we will see more details about how this happens\r\n\r\nSo in the Vector class as it was defined above, without defining __repr__ or\r\n__str__, if we write\r\n\r\nv = Vector(0,0)\r\nprint(v)\r\n\r\nPython prints something like\r\n\r\n  <__main__.Vector object at 0x027CE470>\r\n\r\nThe convention for __repr__ is that it returns a string, which if passed as the\r\nargument to the eval function, would produce an object with the same state. So\r\nif v = Vector(0,0) the repr(v) should return 'Vector(0,0)'. For Vector, we\r\ncan define __repr__ as follows\r\n\r\n    def __repr__(self):\r\n        return 'Vector('+','.join(str(c) for c in self.coords)+')'\r\n\r\nor\r\n\r\n    def __repr__(self):\r\n        return 'Vector({})'.format(','.join(str(c) for c in self.coords))\r\n\r\nNote that join expects an iterable as its argument, and it expects each object\r\nproduced to be a string. So, we specify a tuple comprehension that uses the str\r\nconversion on every coordinate in self.coords.\r\n\r\nNow, if we executed the print code above, Python prints the following (there is\r\nstill no definition of __str__, so __repr__ is ultimately called by print),\r\nprinting a string value.\r\n\r\n  Vector(0,0)\r\n\r\nAnd sure enough, writing\r\n\r\nx = eval(repr(v))\r\nprint(type(x),x)\r\n\r\nwould print\r\n\r\n  <class '__main__.Vector'> Vector(0,0)\r\n\r\nHere x refers to a different object than v, whose\r\nstate is the same as v's state: x is v evaluates to False.\r\n\r\nIn fact, similar to the len function, Python requires that the str function\r\nalways return a str value, so a more accurate definition of str is\r\n\r\ndef str(x):\r\n    answer = x.__str__()\r\n    if type(answer) is not str:\r\n        raise TypeError('__str__ returned non-string (type '+type_as_str(answer)+'))\r\n    return answer\r\n\r\n__str__ should return a string that nicely formats interesting aspects (maybe\r\nall attribute names, maybe not) of the object. Some objects have more\r\nattribute names than those needed to construct the object. The __str__ below\r\njust returns the Vector as a list of its coordinates, prefaced by its dimension.\r\nSo if v = Vector(0,0) then str(v) returns '(2)[0,0]'\r\n\r\n    def __str__(self):\r\n        return '('+str(len(self))+')'+str(list(self.coords))      # using +\r\n       #return '({d}){c}'.format(d=len(self),c=list(self.coords)) # using format\r\n       #return f'({len(self)}){list(self.coords)}'                # using f string\r\n\r\nUnlike __repr__, Python there is no convention for the result that __str__ \r\nreturns (except that it must be a string), we can use our judgement as to how\r\nbest to show the string representation of objects. Typically we use __str__ for\r\ndebugging, when calling the print function, which automatically calls the str\r\nfunction on all its positional arugments.\r\n\r\nNote that print(repr('abc')) prints 'abc' (including the quotes); print('abc')\r\nor print(str('abc')) prints abc (no quotes); eval(\"'abc'\") is the string 'abc';\r\neval(\"abc\") is whatever object the name abc is bound to (and raises an exception\r\nif there is no binding for this attribute name). len(repr('abc')) is 5 (two\r\nquotes and 3 characters); len(str('abc')) is 3 (3 characters). When we call\r\nprint on a list (and other Python types), it shows the repr values of the list\r\ncontents: print(['a', 'b', 'c']) prints ['a', 'b', 'c'].\r\n\r\nFinally the other type coversion functions: int, float, complex, oct, hex, and\r\ntrunc call the Python methods __int__  __float__  __complex__  __oct__  __hex__\r\n__trunc__.\r\n\r\nSo, we could define\r\n\r\n    def __int__(self):\r\n        return len(self.coords))\r\n\r\nIf we did, and assumed v = Vector(0,0), then int(v) would return 2; if we\r\ndid not define any __int__ function, then calling int(v) would raise the\r\nfollowing exception: \r\n\r\n  TypeError: int() argument must be a string or a number, not 'Vector'\r\n\r\nThe actual int conversion function looks more like the following, because\r\nthe int function is required to return an int.\r\n\r\ndef int(x):\r\n    answer = x.__int__()\r\n    if type(answer) is not int:\r\n        raise TypeError('__int__ returned non-string (type '+type_as_str(answer)+'))\r\n    return answer\r\n\r\n------------------------------------------------------------------------------\r\n\r\nRelational operators: \r\n__lt__ (__gt__, __le__, __ge__, __eq__, __ne__): < (>, <=, >=, ==, and !=)\r\n\r\nIn this section, the overloaded operators that we discuss are really operators,\r\nand we overload their meaning to compute values on new classes/types.\r\n\r\nThe most important thing to know is that Python translates any occurrence of a\r\nrelational operator into a call on the appropriate method for its LEFT operand:\r\nx < y is translated to x.__lt__(y) which by the Fundamental Equation of Object\r\nOriented Programming (FEOOP) is translated into type(x).__lt__(x,y) or,\r\nassuming Vector is a class and x is of type Vector, Vector.__lt__(x,y).\r\n\r\nUnderstanding this translation and application of FEOOP is very important.\r\nUnderstanding this translation and application of FEOOP is very important.\r\nUnderstanding this translation and application of FEOOP is very important.\r\n\r\nPlease note that int is just a class in Python, so it translates 12 < x into\r\n12.__lt__(x) and then into type(12).__lt__(12,x) which is equivalent to\r\nint.__lt__(12,x). That is really what is happening in Python when we use the\r\n< operator: using < with an integer first/left argument calls the method __lt__\r\ndefined in the class the first/left object 12 is constructed from (and 12 is an\r\nint). If we wrote \"abc\" < x it would get translated to \"abc\".__lt__(x) and then\r\nby the FEOOP into str.__lt__(\"abc\",x).\r\n\r\nSo, the type of first/left operand of < determines which class calls its __lt__\r\nmethod. So < does NOT treat its left and right arguments symmetrically!\r\n\r\nWhen studying relational operators, we will first look at comparing objects from\r\nthe same class, and then we will extend our understanding to how Python compares\r\nobjects from different classes (which is a bit more subtle).\r\n\r\n--------------------\r\n1) Comparing objects from the same class:\r\n\r\nWe will start our discussion by defining these relational operators to work\r\nwhen comparing two objects from the Vector class. Later we will cover how to\r\nexpand them to compare Vectors against other types (any numeric type).\r\n\r\nIf we wrote\r\n\r\nx = Vector(0,0)\r\ny = Vector(2,2)\r\nprint(x < y)\r\n\r\nPython raises the exception:\r\n\r\n  TypeError: unorderable types: Vector() < Vector()\r\n\r\nLikewise, it raises the same exception for\r\n\r\nprint(x < 10)\r\n\r\nPython raises the exception:\r\n\r\n   TypeError: unorderable types: Vector() < int\r\n\r\nAnd finally, it raises the same exception for\r\n\r\nprint(10 < x)\r\n\r\nPython raises the exception:\r\n\r\n   TypeError: unorderable types: int < Vector()\r\n\r\nUnorderable here means that there is no way known to Python to determine whether\r\none Vector object is less than another Vector object, nor whether a Vector is\r\nless than an int, nor or whether an int is less than a Vector(). \r\n\r\nNote that the cause of the problem in the first two cases is that the Vector\r\nclass defines no __lt__ method. Python translate x < ... into x.__lt__(...) and\r\nthen into type(x).__lt__(x,...) which is equivalent to Vector.__lt__(x,...).\r\nBut there is no __lt__ method defined in the Vector class (yet).\r\n\r\nIn the third case the int method does define a __lt__ method, but it does not\r\nknow how to compare integers to Vectors. Vectors are a type defined by us, so\r\nthere is no way the int class, which has been built into the Python system, can\r\nknow about our Vector class nor how we want to compare them to ints. Python\r\ntranslates 10 < x into 10.__lt__(x) and then into type(10).__lt__(10,x) which\r\nis equivalent here to int.__lt__(10,x).\r\n\r\nSo, there is no built-in meaning for comparing an object of class/type Vector\r\nwith any object of any type. There is no Vector.__lt__ method. But, by defining\r\na __lt__ method in Vector, there is a method for Python to call when it needs\r\nto compute the < operator on two operands, whose left/first operand is an\r\ninstance of the Vector class.\r\n\r\nSo to start, let's add the following two definitions to the Vector class. Also\r\nassume that we have imported the math module (by import math). Here, distance\r\ncomputes the distance from the origin to the coordinate specified by the Vector;\r\nwe then implement \"less than\" such that one Vector is less than another if its\r\ndistance from the origin is smaller.\r\n\r\n    def distance(self):\r\n        return math.sqrt( sum( v**2 for v in self.coords ) )\r\n\r\n    def __lt__(self,right):\r\n        return self.distance() < right.distance()\r\n\r\nI named the second parameter here right because it is the value on the right-\r\nhand side of the < operator; it can be named anything (e.g., qq17), so long as\r\nthat same name is used for the second parameter in the body of the function.\r\n\r\nNotice the < operator in __lt__ is NOT RECURSIVE! Python calls the __lt__\r\nmethod above when comparing two objects constructed from the Vector class; but\r\ninside this method the < operator is called on two float value returned by the\r\nsqrt function in distance, so it calls the __lt__ method defined in the float\r\nclass:\r\n\r\n   self.distance() < right.distance()\r\n\r\nassuming self.distance() evaluates to self_dist_float and right.distance()\r\nevaluates to right_dist_float\r\n\r\n   self_dist_float < right_dist_float \r\n\r\n   self_dist_float.__lt__(right_dist_float)\r\n\r\n   type(self_dist_float).__lt__(self_dist_float , right_dist_float)\r\n\r\n   float.__lt__(self_dist_float , right_dist_float)\r\n\r\nSo, to compute this relational operator for Vectors, Python calls a __lt__\r\nmethod that computes the same relational operators on floats computed from the\r\nVectors. Thus, the < operator is overloaded to work for different types of\r\noperands.\r\n\r\nThe __lt__ method above would be recursive if its body were return self < right\r\n(causing inifinite recursion, a topic that we will cover in depth later).\r\n\r\nSo now, when evaluating x < y in the example below, the method call\r\nVector.__lt__ is found and it is called with arguments (x,y): as in\r\nVector.__lt__(x,y).\r\n\r\nx = Vector(0,0)\r\ny = Vector(2,2)\r\nprint(x < y)\r\n\r\nPython prints: True\r\n\r\nWhat if we changed the print to print(x > y) and executed the code? Would Python\r\nraise an exception because there is no __gt__ method defined in class Vector?\r\n\r\nIt turns out Python is able to compute the correct answer. How Python evaluates\r\n> in this case is a bit more complicated, but by knowing how we can gain extra\r\ninsight into how Python works and how we can make it work correctly for us.\r\n\r\nIt first tries to call Vector.__gt__(x,y) but an exception is raised internally\r\nbecause __gt__ is not defined in Vector. Mathematically, x > y is true exactly\r\nwhen y < x is true: so, Python tries to use the __lt__  method to compute the\r\n__gt__ method, with reversed operands: Vector.__gt__(x,y) is the same as\r\nVector.__lt__(y,x). So Python tries to evaluate y < x, which means\r\nVector.__lt__(y,x) which we defined above and successfully computes its answer:\r\nFalse.\r\n\r\nSo, we can let Python implicitly call __lt__ with the operands reversed, as\r\nabove, or we can explicitly implement __gt__ either directly (as we did for\r\n__lt__) or we can implement __gt__ by having it explicitly call __lt__ with the\r\narguments reversed. We can write either\r\n\r\n    def __gt__(self,right):\r\n        return self.distance() > right.distance()\r\n\r\n    def __gt__(self,right):\r\n        return right < self # or right.__lt__(self) or Vector.__lt__(right,self)\r\n\r\nSo there are a variety of implicit and explicit ways in which we can use the\r\n__gt__ method to compute the correct result. Finally, note that we can get the\r\nsame behavior by defining only __gt__, which Python will call with reversed\r\noperands if it needs to compute the __lt__ but that method is undefined.\r\n\r\nThus, Python can use __lt__ to compute __gt__ and __gt__ to compute __lt__ as\r\nneeded. So, writing one of these pairs allows Python to compute both relations.\r\n\r\nIn the next section we will compare Vectors to ints/floats and see why it is\r\nuseful to define both __lt__ and __gt__ explicitly.\r\n\r\nWhat if we changed the print to print(x <= y) and executed the code?\r\n\r\nPython again raises the exception:\r\n\r\n  TypeError: unorderable types: Vector() <= Vector()\r\n\r\nIn fact, the __le__ and __ge__ pair of methods are opposites, like __lt__ and\r\n__gt__. If we define the __le__ method, and Python needs to compute x >= y, it\r\nwill try the call to Vector.__le__(y,x), because x >= y is true exactly when\r\ny <= x is true. And if we define the __ge__ method and Python needs to compute\r\nx <= y it will translate the call to Vector.__ge__(y,x), because x <= y when\r\ny >= x.\r\n\r\nFinally, for the == operator, if we don't define an __eq__ method, Python\r\nsubstitutes the \"is\" operator (which always returns a boolean value); if we\r\ndon't define a __ne__ method Python calls __eq__ and negates the result. So\r\nunlike the other pairs, in this pair, an undefined __ne__ method calls __eq__\r\nbut an undefined __eq__ WILL NOT CALL __ne__, it uses the \"is\" operator. For\r\nexample, with neither __eq__ nor __ne__ defined\r\n\r\nx=Vector(0,0)\r\ny=Vector(0,0)\r\nz=x\r\n\r\nprint(x == y, x is y, x == z, x is z)\r\nprint(x != y, x is not y, x != z, x is not z)\r\n\r\nPrints\r\n\r\n  False False True True\r\n  True True False False\r\n\r\nHere  ==/is and !=/is not  produce the same results because we have not defined\r\nthe __eq__ nor __ne__ methods. So even though x and y represent the origin,\r\nx == y computes the same result as x is y, which is False because \"is\" is\r\ncomparing two different Vector objects (although each stores the same\r\ncoordinates).\r\n\r\n----\r\nis vs. == interlude\r\n\r\nRecall that the \"is\" operator is called the object-identity operator. It\r\nevaluates to True when its left operand refers to the SAME OBJECT as its right\r\noperand. In the pictures that we have been drawing, this means the left/right\r\nreferences (arrows) refer to the same object. When \"x is y\" is True,\r\nid(x)==id(y) and vice versa.\r\n\r\nThe == operator (when present) should compare objects by their state. It is\r\npossible that two different objects (objects for which \"is\" evaluates to False)\r\nstore the same state, so for them == should evaluate to True. This is the case\r\nfor the objects x and y shown above: they refer to different objects, but each\r\nof the objects referred to has the same state: the self.coord reference of each\r\nrefers to a tuple containing (0,0).\r\n----\r\n\r\nSo, if we define the __eq__ method as follows (True when the tuples are same\r\nregardless of identity)\r\n\r\n    def __eq__(self,right):\r\n        return self.coords == right.coords\r\n\r\nprint(x == y, x is y, x == z, x is z)\r\nprint(x != y, x is not y, x != z, x is not z)\r\n\r\nnow prints\r\n\r\n  True False True True\r\n  False True False False\r\n\r\nSo in summary, to get all six relational operators to work correctly for\r\ncomparing two objects of the same class, we can define all six or choose one of\r\n__lt__/__gt__, one of __le__/__ge__, and always __eq__ to define, and Python\r\nwill call one of these to compute the correct value for any of the undefined\r\nrelational operators.\r\n\r\nNote that although Python doesn't do it, we can implement all the relational\r\noperators using only < (or > or <= or >= we show only < below): although this\r\napproach might not be efficient in execution, the last 5 methods would be the\r\nsame in every class, all depending on the meaning of __lt__. In fact, here is\r\nthe equivalence (each proven by the law of trichotomy: x < y, x == y, or x > y)\r\n\r\nRelation |  < only + logical operators\r\n---------+------------------------------\r\n x <  y  |      x <  y\r\n x >  y\t |      y <  x\r\n x <= y\t | not (y < x)\r\n x >= y\t | not (x < y)\r\n x == y\t | not (x < y or y < x)\r\n x != y\t |      x < y or y < x,  or we could write not(x == y), using ==\r\n\r\nSo, we could write each of these operators as illustrated above and be able to\r\ncompare values from the Vector class in all possible ways. We will later see\r\nhow to use a mix-in via class inheritence to simplify this process. You can\r\nalso look in the functools module in Python's library for the total_ordering\r\ndecorator, which supplies the other operators so long as the class defines one\r\nof __lt__, __le__, __gt__, or __ge__ and also supplies the __eq__ method. But\r\nfor now, this is only of theoretical interest.\r\n\r\n--------------------\r\n\r\n2) Comparing objects from different classes/types:\r\n\r\nNow we will discuss what we must do if we also want Python to be able to compare\r\nobjects of different types: here, we compare objects from the Vector type with\r\nobjects of a numeric type (int or float). In the example below, again, assume x\r\nrefers to an object constructed from the Vector class.\r\n\r\nWriting the code print(x < 15) won't magically work. As you would suspect,\r\nthis will not end well, because Python raises the exception: \r\n\r\n  AttributeError: 'int' object has no attribute 'distance'\r\n\r\n(in the body of the __lt__ method). The current definition assumes that we can\r\ncall the distance function on the right parameter, which works if type(right)\r\nis Vector; but here it is an int. Now, maybe it makes NO sense to do such a\r\ncomparison, so raising this exception is as good as doing anything else; or,\r\nmaybe we should test whether type(right) in (int,float) and raise a different\r\nexception with a better message. The accepted exception to raise is TypeError,\r\nwhich with the correct string would produce the same result as if the method\r\nwere not defined (see below).\r\n\r\nBut if it makes sense to compare a Vector and an int/float, we can write more\r\ncode to fix the \"problem\", expressing how to compare Vectors to integers/floats.\r\nSuppose that we decide for __lt__ to compare the distance of the Vector value\r\nwith the int/float. For  these semantics, we can rewrite __lt__ as \r\n\r\n    def __lt__(self,right):\r\n        if type(right) is Vector:\r\n            return self.distance() < right.distance()\r\n        elif type(right) in (int,float):\r\n            return self.distance() < right\r\n        else:\r\n            return NotImplemented\r\n\r\nHere, if the type of right object is Vector, we do the standard comparison we\r\ndid before, but if the type is either int or float, we perform the necessary\r\ncall (on the distance method only for the Vector) before doing the standard\r\nnumeric comparison with the right, which we know is a numeric value. If\r\ntype(right) is neither Vector nor int nor float, we return the value\r\nNotImplemented, meaning trying to do the comparison is not valid (signalling\r\nPython to see if it can try to compute this relational operator another way).\r\n\r\nNow it is time to explore an interesting asymmetry when Python evaluates\r\nrelational operators, and how to avoid any possible problems.\r\n\r\n-----\r\n(1) If we extend __lt__ to cover a right argument that is an int (as we did\r\nabove) and do not define an explicit __gt__ method similarly, then Python will\r\ntry, but fail to compute print(x > 15) correctly: remember that Python would\r\nfirst translate this expression into x.__gt__(15) and then into\r\ntype(x).__gt__(x,15)  which is equivalent to Vector.__gt__(x,15); if\r\nVector.__gt__ is not defined, Python tries to compute x > 15 equivalently by\r\ncomputing 15 < x. But this expression won't work correctly, because Python will\r\ntranslate 15 < x into 15.__lt__(x) and then into type(15).__lt__(15,x)\r\nwhich is equivalent to int.__lt__(15,x); but the int class does not (and cannot\r\n-see the next paragraph) know how to compare an int object to a Vector object.\r\nPython would raise the exception: TypeError: unorderable types: int() > Vector()\r\n\r\n(2) If we define a __gt__ method (which WON'T work)\r\n\r\n    def __gt__(self,right):\r\n        return right < self # or right.__lt__(self) or Vector.__lt__(right,self)\r\n\r\nthen 15 < x would call int.__lt__(15,x) and fail to produce a result, so Python\r\nwould translate it to x > 15 and call Vector.__gt__(x,15), but that would be\r\ncomputed as 15 < x, which would get us back where we started and cause infinite\r\nrecursion. Technically, an exception is raised: RuntimeError: maximum recursion\r\ndepth exceeded.\r\n\r\n(3) If we define a __gt__ method (which WILL work)\r\n\r\n    def __gt__(self,right):\r\n        if type(right) is Vector:\r\n            return self.distance() > right.distance()\r\n        elif type(right) in (int,float):\r\n            return self.distance() > right\r\n        else:\r\n            return NotImplemented\r\n\r\nNow Python translates 15 < x into 15.__lt__(x) and into type(15).__lt__(15,x)\r\nwhich is equivalent to int.__lt__(15,x); but the __lt__ method defined in the\r\nint class returns NotImplemented or raises an exception when it tries to\r\nprocess the second argument: an object constructed from class Vector which the\r\nint class doesn't know about. But in this case, Python next tries to evaluate\r\n15 < x by evaluating x > 15, which translates into x.__gt__(15) and then into\r\ntype(x).__gt__(x,15) which is equivalent to Vector.__gt__(x,15), which now\r\ncomputes the correct answer (assuming we have defined __gt__ properly in the\r\nVector, as illustrated above).\r\n-----\r\n\r\nThe int/float classes are built into Python and were written BEFORE we wrote\r\nthe Vector class, so they know nothing about comparing ints/floats to objects\r\nconstructed from the Vector class. And, we cannot change the int/float class to\r\ncompare against objects constructed from the Vector class (because they are\r\nbuilt into Python, and need to run very efficiently, we cannot modify them as\r\nwe modified classes written in the previous lecture) . So, it is the Vector\r\nclass that must know how to compare ints/floats against objects constructed\r\nfrom the Vector class. Thus, if it makes sense to compare objects of the Vector\r\nclass against ints/floats (and objects of any other already defined classes) we\r\nmust define all 6 relational operators in class Vector, each one explicitly\r\nperforming its comparison.\r\n\r\nRecall that chained relational operators are translated into pairwise\r\ncomparisons joined implicitly by \"and\": e.g., a < b < c == d is translated into\r\na < b and b < c and c == d. Most programming languages don't define chained\r\nrelational operators, so programmers must to this translation themselves.\r\n\r\nFinally note that we can make a < b do whatever we want. We could make it print\r\nvalues, change the state of a or b, do whatever we can do with Python code.\r\n\r\nHere is where beginners might go wild by adding all sorts of strange meanings\r\nto using the < operator; but more experienced programmers will ensure that all\r\nrelational operators are pure accessors/queries and probably just return a bool\r\nvalue (not even one that just can be interpreted as a bool value using the\r\n__bool__ method) without making any state changes (mutation) in the arguments.\r\n\r\nWe can summarize the rule Python uses to determine how to compute x < y:\r\n\r\n  (1) Try to call x.__lt__(y), which is translated into type(x).__lt__(x,y)\r\n\r\n  (2) If this produces a result, that is the result of the comparison\r\n\r\n  (3) If there is no such __lt__ method, or calling it returns NotImplemented or\r\n        raises an exception, (which is handled by Python internally), then try\r\n        to compute y > x: call type(y).__gt__(y,x); if this produces a result,\r\n        that is the result of the expression\r\n \r\n  (4) If there is no such __gt__ method Python raises a TypeError; if there\r\n        is a method, but calling it returns NotImplemented or raises an\r\n        exception, Python propagates the exception (Python doesn't handle it\r\n        internally)\r\n\r\nFor the main example above, here is how Python does this process\r\n\r\n  1<v  \t    \t   \twhich is translated by Python to call a method\r\n  1.__lt__(v)\t\twhich by FEOOP is translated to\r\n  type(1).__lt__(1,v)\twhich Python translates to\r\n  int.__lt__(1,v)\twhich returns NotImplemented:\r\n                        (int doesn't know about Vector; so Python tries)\r\n  v.__gt__(1)\t\twhich by FEOOP is translated to\r\n  type(v).__gt__(v,1) \twhich Python translates to\r\n  Vector.__gt__(v,1)\twhich correctly computes the result for Vector and int\r\n\r\nYou should completely understand this example for the upcoming quiz and midterm.\r\n\r\nFinally, there is no requirement that relational operators return boolean\r\nvalues, but I would suggest always returning a boolean value.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nUnary arithmetic operators: + - ~ (and functions: abs round floor ceil trunc)\r\n\r\nContinuing with overloading operators, when Python recognizes a unary arithmetic\r\noperator (or a binary arithmetic operator, see the next section) it translates\r\nit into the appropriate method call for the class/type of its argument: for\r\nexample, it translates -x into x.__neg__() and then into type(x).__neg__(x)\r\nand if x is a Vector, finally into Vector.__neg__(x).\r\n\r\nSuppose that we wanted the __neg__ operator for Vector to return a Vector\r\nobject with all of its coords negated. Generally, as described above, __neg__\r\nSHOULD NOT MUTATE ITS OPERAND but should leave its operand unchanged and return\r\na new Vector object, whose state is initialized to the appropriate one. Here is\r\na __neg__ method with exactly these semantics. Note it returns a newly\r\nconstructed  object (of class Vector) with the appropriate contents,\r\n\r\n    def __neg__(self):\r\n        return Vector( *(-c for c in self.coords) )\r\n\r\nNotice the use of tuple comprehension to create the appropriate negated tuple,\r\nand the use of * to translate the n-tuple comprehension into n different\r\npositional arguments needed in the call to Vector's __init__. That is, calling\r\nf(1,*(2,3,4),5) is equivalent to calling f(1,2,3,4,5). Here is an example of the\r\ncode running\r\n\r\nv = Vector(1,-2,3)\r\nprint(v)\r\nprint(-v)\r\nprint(v)\r\n\r\nwhich produces the following results; note v's state before and after printing\r\n-v is the same: there is no mutation. Of course we could write v = -v which\r\nalso has no mutation, but the name v would be rebound to the object produced by\r\ncalling __neg__, so if we printed v again we would see a different result. \r\n\r\n  (3)[1, -2, 3]\r\n  (3)[-1, 2, -3]\r\n  (3)[1, -2, 3]     note that the object v refers to was not mutated by __neg__\r\n\r\nThere are two other unary arithmetic operators that we can overload: + and ~\r\nwhose methods go by the names __pos_ and __invert__. For Vectors, pos should\r\nreturn the same vector. Invert is a bit-wise operator, which we won't overload.\r\nSo writing ~v would raise an exception.\r\n\r\n    def __pos__(self):\r\n        return self\r\n\r\nNote that we could return a copy of self, return Vector(*self.coords) but\r\nbecause Vector is immutable we can share it safely, without the possibility of\r\nit changing (unless the programmer using Vector does somthing \"bad\" like\r\nv.coords.append(2)).\r\n\r\nIn addition, while discussing arithmetic here, the following unary functions \r\nabs, round, floor, ceil, trunc work by calling one of these special methods on\r\nits argument (much like len, described above): so abs(x) returns as its result\r\nx.__abs__(). Therefore, if we defined the following __abs__ method in the\r\nVector class, it returns an object constructed from the Vector class\r\n(containing the absolute values of all the coordinates)\r\n\r\n    def __abs__(self):\r\n        return Vector( *(abs(c) for c in self.coords) )\r\n\r\nthen running the script\r\n\r\nv = Vector(1,-2,3)\r\nprint(v)\r\nprint(abs(v))\r\nprint(v)\r\n\r\nwould print\r\n\r\n  (3)[1, -2, 3]\r\n  (3)[1, 2, 3]\r\n  (3)[1, -2, 3]     note that the object v refers to was not mutated by __abs__\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nBinary Arithmetic Operators: + - * / // % divmod ** << >> & | ^\r\n\r\nNow let's move from unary to binary arithmetic operators, where there are more\r\noperators and they are it bit harder to write correctly. We will start by\r\ndiscussing one method in particular __add__ and also discuss the need for\r\nanother related method __radd__. What we learn about these methods applies\r\nidentically to all the arithmetic operators, so we will not dicuss them in\r\ndetail here (generally we are concerned with the arithmetic operators\r\n+ - * / // % **: if you want you can read about the more obscure \"arithmetic\"\r\noperators on Python's documentation. See 6.7 and beyond.\r\n\r\nBinary arithmetic operators, like relational operators, are written in between\r\ntheir two operands. Python translates the call x + y into x.__add__(y) and then\r\nby FEOOP into type(x).__add__(x,y). As with the relational operators and unary\r\narithmetic operators, neither operand should be mutated, and the method should\r\nreturn a new object initialized with the correct state. Here is an example of\r\nthe + operator overloaded for Vector: to work correctly, the right operand must\r\nalso be of type Vector and both must have the same number of coordinates (len\r\nof the coords attribute) and the resulting Vector object has that common length,\r\nwith coordinates that are the pairwise sum of the coordinates in the two\r\nVectors. Later we will write code so that + adds Vectors and the values of the\r\nint/float numeric types as well.\r\n\r\n    def __add__(self,right):\r\n        if type(right) is not Vector:\r\n            return NotImplemented\r\n        assert len(self) == len(right), 'Vector.__add__: operand self('+str(self)+') has different dimension that operand right('+str(right)+')'\r\n        return Vector( *(c1+c2 for c1,c2 in zip(self.coords,right.coords)) )\r\n\r\nand an example of it running\r\n\r\nv1 = Vector(0,1)\r\nv2 = Vector(2,2)\r\nprint(v1+v2)\r\n\r\nwhich produces the result\r\n\r\n  (2)[2, 3]\r\n\r\nNote that we know that type(self) is Vector: that is why the __add__ method in\r\nthe Vector class is called. Note also that executing print(v1+1) raises and \r\nprints the exception\r\n\r\n  TypeError: unsupported operand type(s) for +: 'Vector' and 'int'\r\n  \r\n(Python translates returning NotImplemented into raising the TypeError\r\nexception)\r\n\r\nand if we define v3 = Vector(2,2,2), then print(v1+v3) results in the exception\r\n\r\n  AssertionError: Vector.__add__: operand self((2)[0, 0]) has different dimension that operand right((3)[2, 2, 2])\r\n\r\nNow recall that we allowed objects from class Vector to compare to int/float\r\nusing relational operators: let's also allow addition between Vectors and these\r\nnumeric types. We will defined adding a Vector and a numeric value to add that\r\nnumeric value to EACH COORDINATE in the Vector. As with the implementation of\r\nrelationial operators, we check types in the __add__ method. \r\n\r\n    def __add__(self,right):\r\n        if type(right) not in (Vector,int,float):\r\n            return NotImplemented\r\n        if type(right) in (int,float):\r\n            return Vector( *(c+right for c in self.coords) )\r\n        else:\r\n            assert len(self) == len(right), 'Vector.__add__: operand self('+str(self)+') has different dimension that operand right('+str(right)+')'\r\n            return Vector( *(c1+c2 for c1,c2 in zip(self.coords,right.coords)) )\r\n\r\nNote that the assertion about lengths is now moved into the else: it shouldn't\r\nbe checked when type(right) is an int or float. An an example of it running is\r\n\r\nv = Vector(0,0)\r\nprint(v+1)\r\nprint(v+1.)\r\n\r\nwhich produces the results\r\n\r\n(2)[1, 1]\r\n(2)[1., 1.]\r\n\r\nWe can write this code equivalently as follows, puting the Vector case first,\r\nthen the (int,Float) cases, and finally the error case. Either code is\r\nreasonable.\r\n\r\n    def __add__(self,right):\r\n        if type(right) is Vector:\r\n            assert len(self) == len(right), 'Vector.__add__: operand self('+str(self)+') has different dimension that operand right('+str(right)+')'\r\n            return Vector( *(c1+c2 for c1,c2 in zip(self.coords,right.coords)) )\r\n        elif type(right) in (int,float):\r\n            return Vector( *(c+right for c in self.coords) )\r\n        else:\r\n            return NotImplemented\r\n\r\nWhat if we also wanted to allow the expression 1+v? If we try to execute\r\nthis code, unsurprisingly Python responds by raising an exception:\r\n\r\n  TypeError: unsupported operand type(s) for +: 'int' and 'Vector'\r\n\r\nbecause Python calls int.__add__(1,v) and the int class has no clue about\r\nobjects of the Vector class (and we cannot change the int class to process\r\nVectors correctly).\r\n\r\nRecall that we covered this problem when discussing __lt__: because the class\r\nof the left operand was used there too, to call the method (sometimes called\r\n\"left-operand dispatch\"), we would have to change the definition of __lt__ in \r\nthe int class to know about class Vector, which we cannot do.\r\n\r\nThis problem was solved for relational operators by Python automatically\r\nreversing the operands and calling the __gt__ method: 1 < v always has the same\r\nvalue as v > 1, where the __gt__ method for v (defined in class Vector) can\r\ninclude code that checks whether its right operand it an int and process it\r\naccordingly.\r\n\r\nBut for binary arithmetic operators, Python cannot always find an equivalent\r\noperator to transpose the operands, so it uses a different mechanism to solve\r\nthis problem. For example, 1-v is not the same as v-1. \r\n\r\n-----\r\nThis is because in mathematics, although operators on some operands (ints and\r\nfloats with + and *) are COMMUTATIVE, they aren't always. Matrix multiplication\r\nis the first example of non-commutivity that mathematics students often see. For\r\nmatrices m1 and m2, m1*m2 does not produce the same value as m2*m1. Likewise\r\n+ as concatenation is not commutative on strings: 'ab' + 'cd' is not equal to\r\n'cd' + 'ab'. Because of non-commmutivity, Python solves this problem for\r\narithmetic operators by using a different mechanism than the one it uses for\r\nrelational operators.\r\n-----\r\n\r\nFor every binary arithmetic operator, Python also allows us to define a \"right\"\r\n(sometimes known as \"reversed\") version of it: where the method name is prefixed\r\nby an r: so __add__ has an related __radd__ method (\"right/reverse add\"). Here\r\nis how we could define __radd__ in the Vector class to successfully compute\r\nexpressions of the form int() + Vector().\r\n\r\n    def __radd__(self,left):\r\n        if type(left) not in (int,float):               # see note (1) below\r\n            return NotImplemented\r\n        return Vector( *(left+c for c in self.coords) ) # see note (2) below\r\n\r\nWhen Python evaluates 1+v, it translates it into 1.__add__(v) and then by FEEOP\r\ninto tries int.__add(1,v); it doing so returns NotImplmemented or raises an\r\nexception because the int class doesn't know how to operate on Vector operands.\r\nThen, Python translates the + into v.__radd_(1) and into type(v).__radd__(v,1)\r\nusing  \"right/reversed-operand dispatch\". This methods determines what to do if\r\nthe left operand is an int/float. In the method below, relating to the + \r\noperator, the self parameter is the right operand and the left parameter is the\r\nleft operand. We could rewrite the headers as def __add__(left,right) and\r\ndef __radd__(right,left) and replacing self appropriately in the method bodies.\r\n\r\nAn example of __radd__ running is\r\n\r\nv = Vector(0,0)\r\nprint(1+v)\r\n\r\nwhich produces the result\r\n\r\n(2)[1, 1]\r\n\r\nNote: Two interesting questions are, (1) why doesn't the __radd__ method need\r\nto also check whether type(left) is a Vector as does __add__, and (2) why\r\ndoes neither __add__'s nor __radd__'s body check whether self is a Vector.\r\n\r\n(1) If left were a Vector, then __radd__ would never be called, because the\r\nleft (Vector) argument would result in Python calling the equivalent of\r\nVector.__add__(left,self) which knows how to compute a Vector result, so it\r\nwould never call __radd__ when left is a Vector.\r\n\r\n(2) self must be a Vector because Python is calling __add__ or __radd__ in the\r\nVector class, so the other argument must be a Vector. That is, for Vector v,\r\nv+anything first gets translated to Vector.__add__(v,anything) so self here\r\nis a Vector; anything+v (if anything doesn't know how to add Vectors) gets\r\ntranslated into Vector.__radd__(v,anything) and again self here is a Vector.\r\n\r\n\r\nA Note on Commutivity to Simplify __radd__:\r\n\r\nFor arithmetic types/operators that are commutative (e.g., a+b == b+a, which is\r\ntrue for Vectors) we can write __radd__ by simply calling __add__ with the\r\narguments reversed: e.g., \r\n\r\n    def __radd__(self,left):\r\n        return self + left  # or self.__add__(left)\r\n\r\nSo 1+v is translated into 1.__add__(v) and then into int.__add(1,v) which fails,\r\nso is translated into v.__radd__(1) and into type(v).__radd__(v,1) and into\r\nVector.__radd__(v,1), which returns the result of Vector.__add__(v,1) which is\r\nv+1, which has the same value as 1+v because of commutivity.\r\n\r\nAgain, there are many mathematical structures where + and * are commutative,\r\nalthough  operators like - and / are typically not commutative. In fact, some\r\ninterpretations of + and/or * are not commmutative (e.g., multiplying matrices).\r\nSo, we must be careful to write the normal and right versions of all binary\r\narithmetic operarators correctly.\r\n\r\nWe now get a point where we can really test our understanding. Here is the rule\r\nPython uses to determine how to compute x + y:\r\n\r\n  (1) Try to call x.__add__(y), which is translated into type(x).__add__(x,y)\r\n\r\n  (2) If this produces a result, that is the result of the expression\r\n\r\n  (3) If there is no such __add__ method, or calling it returns NotImplemented\r\n        or raises an exception (which is handled by Python internally) then\r\n        call type(y).__radd__(y,x); if this produes a result, that is the\r\n        result of the expression\r\n\r\n  (4) If there is no such __radd__ method Python raises a TypeError; if there\r\n        is a method, but calling it returns NotImplemented or raises an\r\n        exception, Python propagates the exception (Python doesn't handle it\r\n        internally)\r\n\r\nFor the main example above, here is how Python sees this process\r\n\r\n  1+v  \t    \t   \twhich is translated by Python to call a method\r\n  1.__add__(v)\t\twhich by FEOOP is translated to\r\n  type(1).__add__(1,v)\twhich Python translates to\r\n  int.__add__(1,v)\twhich returns NotImplmented:\r\n                        int doesn't know about Vector; so Python tries\r\n  v.__radd__(1)\t\twhich by FEOOP is translated to\r\n  type(v).__radd__(v,1) which Python translates to\r\n  Vector.__radd__(v,1)\twhich correctly computes the result for Vector and int\r\n\r\nYou should completely understand this example for the upcoming quiz and midterm.\r\n\r\nWe have now explored (in about 150 lines of text and code) the relationship\r\nbetween the + operator and __add__ and __radd__ methods. Here is the complete\r\nlist of  operators and their related methods: + - * / // % divmod ** << >> & | ^\r\ntranslate to __add__  __sub__  __mul__  __truediv__  __floordiv__  __mod__\r\n __divmod__ __pow__ __lshift__  __rshift__  __and__  __or__  __xor__; also\r\nthere is a right form for each of these method: __radd__, __rsub__, __rmul__, \r\netc.\r\n\r\nOne final comment: for the binary arithmetic operator -, if one has defined\r\nunary - (__neg__) correctly, one can often implement the __sub__ method as\r\nself + -right, which uses the __neg__ and __add__ methods to compute\r\nsubtraction: again, this can be a bit inefficient, but it is very easy to code.\r\nIf efficiency is an issue, we can rewrite __sub__ more directly, to execute\r\nmore quickly.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIncrementing Arithmetic Delimiters: += -= *= /= //= %= **= <<= >>= &= |= ^=\r\n\r\nAgain in this section we will look at one incrementing arithmetic delimiter,\r\n+=. Technically this is not an operator, because we cannot compose bigger\r\nexpressions with it: += is more like = (a delimiter) than + (an operator). This\r\nsame discussion applies similarly to all the other delimiters. For every\r\narithmetic operator method, there is another method prefaced by i that we can\r\nwrite and Python will try to call (e.g. __add__ and __iadd__).\r\n\r\nRecall that the meaning of x += y is similar to x = x + (y). We parenthesize y\r\nin case it is an expression that contains any operators whose precedence is\r\nlower than +. When Python executes x += y, it tries to execute\r\nx = type(x).__iadd__(x,y): if that method is available and doesn't raise an\r\nexception, that is the result; if it cannot find that method or it raises an\r\nexception, Python executes the code x = x + (y), which also can fail if __add__\r\nis not defined for the types of x and y.\r\n\r\nHere is an example of the __iadd__ method for the Vector class, which works for\r\nincrementing objects of the Vector type/class by a Vector or an int. Note that\r\nPython automatically will bind x to the result returned by this method.\r\n\r\n    def __iadd__(self,right):\r\n        if type(right) not in (Vector,int,float):\r\n            return NotImplemented\r\n        if type(right) in (int,float):\r\n            return Vector(*(c+right for c in self.coords))\r\n        else:\r\n            assert len(self) == len(right), 'Vector.__add__: operand self('+str(self)+') has different dimension that operand right('+str(right)+')'\r\n            return Vector(*(c1+c2 for c1,c2 in zip(self.coords,right.coords)))\r\n\r\nBecause Vectors are immutable, this method goes through exactly the same code\r\nas executing x = x + y (computing a new Vector, with x losing its reference to\r\nits old Vector, so there is no point/advantage of writing it (same for the\r\nbuiltin str type). But what if x is mutable, like a list? The list class\r\nspecifies the following __iadd__\r\n\r\n    def __iadd__(self,right):\r\n        self.extend(right)\r\n        return self\r\n\r\nSo if x =[0] then x += [1,2] extends to the list x, and then x is rebound to the\r\nreturned reference to this list. So x is now bound to a list whose state is\r\n[0,1,2]. Although the result is the same as x = x + [1,2] the process is\r\ndifferent. In the case of x = x + [1,2], Python builds a completely new list\r\ncontaining all of x's values followed by 1 and 2. Then it binds x to refer to\r\nthis new list, throwing away the old list. In the implementation of __iadd__\r\nabove, it just mutates list x and rebinds x to this mutated list, which is\r\nfaster. Perform this experiment\r\n\r\nx = []\r\ny = x               # x and y share the same empty list\r\nx = x + [1,2]\r\nprint(x, y, x is y) # prints [1, 2] [] False\r\n\r\nand compare it to the results of this\r\n\r\nx = []\r\ny = x               # x and y share the same empty list\r\nx += [1,2]\r\nprint(x, y, x is y) # prints [1, 2] [1, 2] True\r\n\r\nCan you draw pictures for these two separate cases?\r\n\r\nSo for mutable objects, we might want to implement __iadd__ to produce an\r\nequivalent result more efficiently. If the object is immutable, or there is no\r\nfaster way to compute it, we can omit defining __iadd__ and let Python compute\r\nthe result using the __add__ method__.\r\n\r\nHere is the complete list of arithmetic incrementing delimiters and their\r\nrelated methods: += -= *= /= //= %= **= <<= >>= &= |= ^= translate to __iadd__\r\n __isub__  __imul__  __itruediv__  __ifloordiv__  __imod__  __idivmod__\r\n__ipow__  __lishift__  __irshift__  __iand__  __ior__  __ixor__.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nOther overloaded operators (coming up)\r\n\r\nIn the next lecture we will discuss container operators (including [index]),\r\nthe call operator (using ()), the context manager protocol, and managing simple\r\nattributes. Next week we will have a lengthy discussion about the intricacies of\r\nimplementing the iterator protocol (and the __iter__ and __next__ methods)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFYI, here is the entire Vector class with all the methods described above. We\r\ncan put this class in a script and experiment calling its methods.\r\n\r\nimport math\r\nfrom goody import type_as_str\r\n\r\nclass Vector:\r\n    def __init__(self,*args):\r\n        self.coords = args\r\n\r\n    def __len__(self):\r\n        return len(self.coords)\r\n\r\n    def __bool__(self):\r\n        return all( v==0 for v in self.coords )\r\n\r\n    def __repr__(self):\r\n        return 'Vector('+','.join(str(c) for c in self.coords)+')'\r\n\r\n    def __str__(self):\r\n        return '('+str(len(self))+')'+str(list(self.coords))      # using +\r\n       #return '({d}){c}'.format(d=len(self),c=list(self.coords)) # using format\r\n\r\n    def distance(self):\r\n        return math.sqrt( sum( v**2 for v in self.coords ) )\r\n\r\n    def __lt__(self,right):\r\n        if type(right) is Vector:\r\n            return self.distance() < right.distance()\r\n        elif type(right) in (int,float):\r\n            return self.distance() < right\r\n        else:\r\n            return NotImplemented\r\n\r\n    def __gt__(self,right):\r\n        if type(right) is Vector:\r\n            return self.distance() > right.distance()\r\n        elif type(right) in (int,float):\r\n            return self.distance() > right\r\n        else:\r\n            return NotImplemented\r\n\r\n    def __eq__(self,right):\r\n        return self.coords == right.coords\r\n    \r\n    def __le__(self,right):\r\n        return self < right or self == right\r\n\r\n    def __ge__(self,right):\r\n        return self > right or self == right\r\n\r\n    def __neg__(self):\r\n        return Vector( *(-c for c in self.coords) )\r\n\r\n    def __pos__(self):\r\n        return self\r\n\r\n    def __abs__(self):\r\n        return Vector( *(abs(c) for c in self.coords) )\r\n    \r\n    def __add__(self,right):\r\n        if type(right) not in (Vector,int,float):\r\n            return NotImplemented\r\n        if type(right) in (int,float):\r\n            return Vector( *(c+right for c in self.coords) )\r\n        else:\r\n            assert len(self) == len(right), 'Vector.__add__: operand self('+str(self)+') has different dimension that operand right('+str(right)+')'\r\n            return Vector( *(c1+c2 for c1,c2 in zip(self.coords,right.coords)) )\r\n    \r\n    def __radd__(self,left):\r\n        if type(left) not in (int,float): # see note below\r\n            return NotImplemented\r\n        return Vector( *(left+c for c in self.coords) )\r\n    \r\n#     def __iadd__(self,right):\r\n#         if type(right) not in (Vector,int,float):\r\n#             return NotImplemented\r\n#         if type(right) in (int,float):\r\n#             return Vector( *(c+right for c in self.coords))\r\n#         else:\r\n#             assert len(self) == len(right), 'Vector.__add__: operand self('+str(self)+') has different dimension that operand right('+str(right)+')'\r\n#             return Vector( *(c1+c2 for c1,c2 in zip(self.coords,right.coords)))\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n1a) Using your knowledge of the or operator, and the boolean interpretation of\r\nstring values, explain what the following statement\r\n\r\n   x = string1 or string2\r\n\r\nassigns to x in each of the following cases (of empty and non-empty strings)\r\n\r\n  string1  |  string2\r\n  ---------+----------\r\n    ''     |     'a'\r\n    ''     |     ''\r\n    'a'    |     ''\r\n    'a'    |     'b'\r\n\r\nRewrite this statement as an equivalent (a) conditional statement and\r\n(b) conditional expression.\r\n\r\n1b) Write a bool function that takes some object as an argument. If that\r\nobject is None, return False; if that object's class contains a __bool__ method,\r\ncall it to return a result; if not, if that object's class contains a __len__ \r\nmethod,, call it to return result (True if the len is not 0); otherwise return\r\nTrue. Hint: recall we can check whether a class object defines a method by\r\nchecking whether it is stored in the class object's __dict__.\r\n\r\n2) Assume that we define x = C(['0']) where the class C is defined by\r\n\r\nclass C:\r\n    def __init__(self,los):\r\n        self.los = los\r\n\r\n    def __lt__(self,right):\r\n        if type(right) is C:\r\n            return self.los < right.los\r\n        elif type(right) is int:\r\n            return self.los < [d for d in str(right)]\r\n        else:\r\n            return NotImplemented\r\n\r\n    def __gt__(self,right):\r\n        return right < self\r\n\r\nExplain in detail (as I did in this lecture) how Python attempts to evaluate\r\n12 < x and whether it succeeds or fails, and if it fails -hint: it fails- how\r\nand why it fails.\r\n\r\nAnswer the same question, if we replaced the defintion of __gt__ above by\r\n\r\n    def __gt__(self,right):\r\n        return C.__lt__(right,self)\r\n\r\n3) Assume that we define the class C below\r\n\r\nclass C:\r\n    def __init__(self,los):\r\n        self.los = los\r\n\r\n    def __add__(self,right):\r\n        if type(right) is C:\r\n            return C(self.los + right.los)\r\n        elif type(right) is int:\r\n            return C(self.los + [d for d in str(right)])\r\n        else:\r\n            return NotImplemented\r\n\r\nIn what cases can we guarantee that when __add__ is called, self is guaranteed\r\nto be an object constructed from class C? Explain how we can call this method\r\nwith a self object that is not constructed from class C.\r\n", "encoding": "ascii"}