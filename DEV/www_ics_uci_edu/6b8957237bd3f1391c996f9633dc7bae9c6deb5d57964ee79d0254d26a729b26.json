{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/11.fraccasc", "content": "further improvement: \"fractional cascading\"\n\nexample problem: four-sided range counting (points in rectangle)\n    static (no changes to data set allowed)\n\n    outer data structure: binary search tree on x-coordinates\n\tsearch finds O(log n) subtrees and O(log n) indiv points in x-range\n\n    inner data structure: for each subtree of outer structure,\n\tstore sorted list of points by y-coordinate\n\tsearch finds positions of start and end of y-range\n\tsubtract positions => count points\n\n    so total query time: O(log^2 n), total space: O(n log n)\n    can we do better?\n\nsimplified view of problem:\n\tgiven sequence of O(log n) sorted lists\n\t\twith total length = O(n)\n\tset up a data structure\n\tso we can find the predecessor of a query value q in each list\n\n    (the sequence = the subtrees found in the outer structure,\n\tactually different outer searches will give us different\n\tsequences, will deal with that complication later)\n\n\tsolution 1 (slow):\n\t\tbinary search in each list, time O(log^2 n)\n\n\tsolution 2 (spacy):\n\t\tmerge the lists; for each item in the merged list\n\t\tstore an array of O(log n) search results, one per input list\n\t\tquery: single binary search, O(log n)\n\t\tspace: O(n) items, O(log n) space each => O(n log n)\n\n\tsolution 3 (frac.casc):\n\t\tuse spacy solution in pairs,\n\t\t\twhere pair i combines\n\t\t\t\ti'th input list\n\t\t\t\tevery other pt in spacy solution for pair i+1\n\t\tpair 0 gives result[0], off-by-one in pair 1\n\t\tpair 1 gives result[1], off-by-one in pair 2\n\t\t...\n\n\ttime per query: O(log n) for pair 0, O(1) for each other => O(log n)\n\tspace: by induction at most 2n\n\t\tif k items in last list\n\t\t2(n-k/2) + k <= 2n\n\nBack to original application:\n\tfollow some two paths in the outer bst (left and right subtrees)\n\tbinary search y-sorted list for left subtrees of some\n\t\titems on right path, vice versa\n\n\tsuppose we could retrieve y-positions of q\n\t\tfor all left subtrees on any path in T\n\tthen ignore the ones we don't need, we get our answer\n\n\tfrac. casc.:\n\t\teach tree node stores three-way merge:\n\t\t\tthe items in that node's left subtree\n\t\t\thalf the items stored for the left subtree of\n\t\t\t\teach child\n\t\teach merged item stores predecessor in each merged input\n\n\ttime to query: O(log n) at root of outer bst, O(1) at each other node\n\t\ttotal O(log n) for four-way range counting\n\n\tspace: same (within constant factor) as uncascaded structure:\n\t\tO(n log n)\n\nMany related applications in nested structures e.g. involving segment\ntrees etc.\n\nWhen doesn't it work?\n\tWhen you need to look at path in binary search, not just\n\t\tget final position\n\t\t(e.g. 3d rectangular range counting, can't cascade middle)\n\n\tWhen sequence of binary searches do not use same key\n\tor can not be merged into single consistent order\n", "encoding": "ascii"}