{"url": "https://www.ics.uci.edu/~dan/class/267P/datasets/calgary/progl", "content": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; form.l -- screen forms handler\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare\n  (specials t)\n  (macros t))\n\n(eval-when (compile)\n  (load 'utilities)\n  (load 'constants)\n  (load 'zone)\n  (load 'look)\n  (load 'font)\n  (load 'text)\n  (load 'text-edit))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\tgeneric fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (field\t\t; generic field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'generic-field)\t\t; type = generic\n  (zone (make-zone))\t\t; bounding zone\n  (properties (list nil))\t; empty property list\n)\n\n(defvar field-properties\t; list of expected field properties\n  '(\"field-properties\"\n    fill-ground\t\t(solid pattern)\t\t; should we draw when highlit?\n    fill-colour\t\t(x_colour x_pattern)\t; what colour or pattern?\n    empty-ground \t(solid pattern)\t\t; should we draw when unlit?\n    empty-colour\t(x_colour x_pattern)\t; what colour or pattern?\n    border-colour\t(x_colour) ; should we draw border (and what colour?)\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-field (f)\t\t; draw field from scratch\n  (apply (concat 'draw- (field-type f))\t; construct draw function name\n\t (ncons f)))\t\t\t\t; then call it\n\n(defun init-field (f)\t\t; initialize a field\n  (apply (concat 'init- (field-type f))\t; construct init function name\n\t (ncons f)))\t\t\t\t; then call it\n\n(defun resize-field (f box)\t\t; resize a field\n  (apply\t\t\t\t; construct resize function name\n    (concat 'resize- (field-type f))\n    (list f box)))\t\t\t\t; then call it\n\n(defun toggle-field (f)\t\t; toggle a field\n  (apply (concat 'toggle- (field-type f)) ; construct toggle fcn name\n\t (ncons f)))\t\t\t\t; then call it\n\n(defun check-field (f p)\t; check if point is inside field excl.border\n  (cond ((point-in-box-interior p (zone-box (field-zone f)))\n\t (apply\t\t\t; if so, construct check function name\n\t   (concat 'check- (field-type f))\n\t   (list f p)))\t\t; then call it and return result\n\t(t nil)))\t\t; otherwise return nil\n\n(defun fill-field (f)\t\t; fill the field interior, if defined\n  (let ((b (get (field-properties f) 'fill-ground))\t; check if has one\n\t(c (get (field-properties f) 'fill-colour)))\n       (cond ((eq b 'solid)\t; solid background\n\t      (cond (c (clear-zone-interior (field-zone f) c))\n\t\t    (t (clear-zone-interior (field-zone f) W-CONTRAST))))\n\t     ((eq b 'pattern)\t; patterned background\n\t      (cond (c (pattern-zone-interior (field-zone f) c))\n\t\t    (t (pattern-zone-interior (field-zone f) W-PATTERN-1))))\n       )))\t\t\t; no background at all!\n\n(defun empty-field (f)\t\t; empty the field interior, if defined\n  (let ((b (get (field-properties f) 'empty-ground)) ; check if has one\n\t(c (get (field-properties f) 'empty-colour)))\n       (cond ((eq b 'solid)\t; solid background\n\t      (cond (c (clear-zone-interior (field-zone f) c))\n\t\t    (t (clear-zone-interior (field-zone f) W-BACKGROUND))))\n\t     ((eq b 'pattern)\t; patterned background\n\t      (cond (c (pattern-zone-interior (field-zone f) c))\n\t\t    (t (pattern-zone-interior (field-zone f) W-PATTERN-1))))\n       )))\t\t\t; no background at all!\n\n(defun draw-field-background (f)\t; just what it says\n  (let ((b (get (field-properties f) 'empty-ground)) ; check if has one\n\t(c (get (field-properties f) 'empty-colour)))\n       (cond ((eq b 'solid)\t; solid background\n\t      (cond (c (clear-zone (field-zone f) c))\n\t\t    (t (clear-zone (field-zone f) W-BACKGROUND))))\n\t     ((eq b 'pattern)\t; patterned background\n\t      (cond (c (pattern-zone (field-zone f) c))\n\t\t    (t (pattern-zone (field-zone f) W-PATTERN-1))))\n       )))\t\t\t; no background at all!\n\n(defun draw-field-border (f)\t\t; draw outline, if any\n  (let ((c (get (field-properties f) 'border-colour)))\n       (cond (c (draw-zone-outline (field-zone f) c)))\n  ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\taggregate fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (aggregate-field\t; aggregate field = form\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'aggregate-field)\t\t; type\n  (zone (make-zone))\t\t; bounding zone\n  (properties (list nil))\t; empty property list\n  subfields\t\t\t; list of subfields\n  selection\t\t\t; which subfield was last hit\n)\n  \n(defvar aggregate-field-properties\n  `(\"aggregate-field-properties\"\n    = ,field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-aggregate-field (f)\n  (draw-field-background f)\t\t\t; clear background, if any\n  (draw-field-border f)\t\t\t\t; draw border, if any\n  (mapc 'draw-field (aggregate-field-subfields f)) ; draw subfields\n  (w-flush (window-w (zone-window (field-zone f)))) t) ; flush it out\n\n(defun init-aggregate-field (f)\n  (mapc 'init-field (aggregate-field-subfields f))\n  (alter-aggregate-field f selection nil) t)\n\n(defun resize-aggregate-field (f box)\n  (alter-zone (field-zone f) box box))\n\n(defun check-aggregate-field (f p)\n  (do ((subfields (aggregate-field-subfields f)\t; go through subfields\n\t (cdr subfields))\n       (gotcha))\n      ((or (null subfields)\t\t\t\t; stop when no more\n\t   (setq gotcha (check-field (car subfields) p))) ; or when one is hit\n       (alter-aggregate-field f selection gotcha)\t; remember which one\n       gotcha)))\t\t\t\t\t; also return it\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\tremote fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; A remote field is a field which activates another field when hit.\n;;; Usually the remote field has some functional significance!\n\n(defstruct\n  (remote-field\t\t; remote field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'remote-field)\t\t; type = remote\n  (zone (make-zone))\t\t; bounding zone\n  (properties (list nil))\t; empty plist\n  (target)\t\t\t; the actual target field\n  (point)\t\t\t; x,y coords to pretend to use\n)\n\n(defvar remote-field-properties\n  `(\"remote-field-properties\"\n    = ,field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-remote-field (f) 't)\t; nothing to draw\n\n(defun init-remote-field (f) 't)\t; nothing to initialize\n\n(defun resize-remote-field (f box)\n  (alter-zone (field-zone f) box box))\n\n(defun check-remote-field (f p)\n  (check-field\n    (remote-field-target f)\n    (remote-field-point f)))\t\t; return result of checking target\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\tbutton fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (button-field\t\t; button field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'button-field)\t\t; type = button\n  (zone (make-zone))\t\t; bounding zone\n  (properties\n    (list nil\t\t\t; default properties\n\t  'fill-ground 'solid\n\t  'empty-ground 'solid\n\t  'border-colour W-CONTRAST\n    ))\n  (value nil)\t\t\t; value\n)\n\n(defvar button-field-properties\n  `(\"button-field-properties\"\n    = ,field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-button-field (f)\n  (draw-field-border f)\n  (cond ((button-field-value f)\n\t (fill-field f))\n\t(t (empty-field f))))\n\n(defun toggle-button-field (f)\n  (alter-button-field f value (not (button-field-value f)))\n  (clear-zone-interior (field-zone f) W-XOR))\n\n(defun init-button-field (f)\n  (alter-button-field f value nil))\t; turn it off\n\n(defun resize-button-field (f box)\n  (alter-zone (field-zone f) box box))\n\n(defun check-button-field (f p)\n  (toggle-button-field f) f)\t; if we get here it's a hit -> return self\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\tradio-button fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Named for the buttons on radios in which only one is \"in\" at a time.\n\n(defstruct\n  (radio-button-field\t\t; radio-button field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'radio-button-field)\t\t; type = radio-button\n  (zone (make-zone))\t\t; bounding zone\n  (properties (list nil))\t; empty plist\n  (subfields nil)\t\t; individual buttons\n  (selection nil)\t\t; which one last hit\n)\n\n(defvar radio-button-field-properties\n  `(\"radio-button-field-properties\"\n    = ,aggregate-field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-radio-button-field (f)\n  (draw-aggregate-field f))\n\n(defun init-radio-button-field (f)\n  (init-aggregate-field f))\n\n(defun resize-radio-button-field (f box)\n  (alter-zone (field-zone f) box box))\n\n(defun check-radio-button-field (f p)\n  (cond ((and (radio-button-field-selection f)\t; if button previously sel'd\n\t      (button-field-value\n\t\t(radio-button-field-selection f))) ; and it has a value\n\t (toggle-field\t\t\t\t; turn it off\n\t   (radio-button-field-selection f))))\n  (check-aggregate-field f p)\t\t\t; check individual buttons\n)\t\t; this will turn back on if same one sel'd, and return it\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\ttext fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (text-field\t\t; text field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'text-field)\t\t; type = text\n  (zone (make-zone))\t\t; bounding zone\n  (properties\n    (list nil\n\t  'fill-ground 'solid\n\t  'empty-ground 'solid\n\t  'border-colour W-CONTRAST\n\t  'x-offset 5\t\t; offset from left\n    ))\n  (value nil)\n  (text '||)\t\t\t; text of text\n)\n\n(defvar text-field-properties\n  `(\"text-field-properties\"\n    x-offset (x_pixels)\t\t; text offset from box ll, otherwise centred\n    y-offset (x_pixels)\t\t; text offset from box ll, otherwise centred\n    + ,button-field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-text-field (f)\n  (draw-button-field f)\n  (w-flush (window-w (zone-window (field-zone f)))) ; guarantee text on top\n  (draw-text (text-field-text f)))\n\n(defun redraw-text-field (f)\n  (empty-field f)\n  (w-flush (window-w (zone-window (field-zone f)))) ; guarantee text on top\n  (draw-text (text-field-text f)))\n\n(defun init-text-field (f)\t; position & position the text in the field\n  (let ((s (text-field-text f))\n\t(x-offset (get (field-properties f) 'x-offset))\t; x offset from ll\n\t(y-offset (get (field-properties f) 'y-offset))); y offset from ll\n       (alter-text s\n\t zone (make-zone\t\t\t; ensure it has a zone\n\t\twindow (zone-window (field-zone f))\n\t\tbox (box-interior (zone-box (field-zone f)))))\n       (format-text s)\t\t; ensure text delta calculated\n       (cond ((null x-offset)\t\t; x-offset specified?\n\t      (setq x-offset\t\t; nope! centre it left-right\n\t\t    (/ (- (x (box-size (zone-box (field-zone f))))\n\t\t\t  (x (text-delta s)))\n\t\t       2))))\n       (cond ((null y-offset)\t\t; y-offset specified?\n\t      (setq y-offset\t\t; nope! centre it up-down\n\t\t    (/ (- (y (box-size (zone-box (field-zone f))))\n\t\t\t  (font-x-height (look-font (text-look s))))\n\t\t       2))))\n       (alter-text s\t\t\t; now position the text\n\t offset (make-point x x-offset y y-offset))\n       ))\n\n(defun resize-text-field (f box)\t; position the text in the field\n  (alter-zone (field-zone f) box box)\n  (init-text-field f))\n\n(defun check-text-field (f p)\n  (input-text-field f) f)\t; if we get here it's a hit -> return self\n\n(defun input-text-field (f)\n  (alter-text (text-field-text f)\n    text '|| nn 0 kr 0 kl 0 delta (make-point x 0 y 0))\n  (draw-text-field f)\n  (edit-text-field f (ll (zone-box (text-zone (text-field-text f))))))\n\n(defun edit-text-field (f p)\t\t; edit in middle of text field\n  (edit-text (text-field-text f) p)\t; edit the text\n  (draw-field f))\t\t\t; redraw\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\tprompt fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (prompt-field\t\t; prompt field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'prompt-field)\t\t; type = prompt\n  (zone (make-zone))\t\t; bounding zone\n  (properties\n    (list nil 'x-offset 0))\t; put it exactly where spec indicates.\n  (value nil)\n  (text '||)\t\t\t; text of prompt\n)\n\n(defvar prompt-field-properties\n  `(\"prompt-field-properties\"\n    = ,text-field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-prompt-field (f)\n  (draw-text-field f))\n\n(defun init-prompt-field (f)\n  (init-text-field f))\n\n(defun resize-prompt-field (f box)\t; position the text in the field\n  (resize-text-field f box))\n\n(defun check-prompt-field (f p) f) ; just return self\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\ttext-button fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; A text-button is a button tied to a text.\n;;; When the button is pressed, the text is input from the keyboard.\n;;; Zone could same as either the button (activation by button only)\n;;; or include both button & text (should then be adjacent)\n\n(defstruct\n  (text-button-field\t\t; text-button field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'text-button-field)\t\t; type = text-button\n  (zone (make-zone))\t\t; bounding zone\n  (properties (list nil))\t; empty plist\n  (button)\t\t\t; button subfield\n  (text)\t\t\t; text subfield\n)\n\n(defvar text-button-field-properties\n  `(\"text-button-field-properties\"\n    = ,field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-text-button-field (f)\n  (draw-field (text-button-field-button f))\n  (draw-text-field (text-button-field-text f)))\n\n(defun init-text-button-field (f)\n  (init-field (text-button-field-button f))\n  (init-text-field (text-button-field-text f)))\n\n(defun resize-text-button-field (f box)\n  (alter-zone (field-zone f) box box))\n\n(defun toggle-text-button-field (f)\t; toggle only the button part\n  (cond ((button-field-value\t\t; and only if non-nil\n\t   (text-button-field-button f))\n\t (toggle-button-field (text-button-field-button f)))))\n\n(defun check-text-button-field (f p)\n  (cond ((check-field (text-button-field-button f) p)\n\t (input-text-field\t\t\t; input from scratch\n\t   (text-button-field-text f)))\t; get the data\n\t(t (toggle-button-field\t\t\t; must be pointing at text\n\t     (text-button-field-button f))\t; toggle only the button part\n\t   (edit-text-field\n\t     (text-button-field-text f) p))\t; edit the data\n  )\n  (toggle-button-field\t\t\t; toggle button back\n    (text-button-field-button f))\n  (alter-button-field (text-button-field-button f)\n    value nil)\t\t\t; keep aggregate from toggling again\n  f)\t\t\t\t\t; return self\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\tlabelled button fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (labelled-button-field ; labelled button field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'labelled-button-field)\t; type = labelled-button\n  (zone (make-zone))\t\t; bounding zone\n  (properties\n    (list nil\n\t  'fill-ground 'solid\n\t  'empty-ground 'solid\n\t  'border-colour W-CONTRAST\n    ))\n  (value nil)\t\t\t; value\n  (text '||)\t\t\t; label text\n)\n\n(defvar labelled-button-field-properties\n  `(\"labelled-button-field-properties\"\n    = ,text-field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-labelled-button-field (f)\n  (draw-text-field f))\n\n(defun init-labelled-button-field (f)\n  (init-text-field f))\n\n(defun resize-labelled-button-field (f box)\n  (resize-text-field f box))\n\n(defun check-labelled-button-field (f p)\n  (toggle-button-field f) f)\t; if we get here it's a hit -> return self\n\n(defun toggle-labelled-button-field (f)\n  (toggle-button-field f))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\texpanded-bitmap fields\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defstruct\n  (expanded-bitmap-field\t; expanded-bitmap field\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (type 'expanded-bitmap-field)\t; type = expanded-bitmap\n  (zone (make-zone))\t\t; bounding zone\n  (properties (list nil))\t; empty plist\n  (subfields nil)\t\t; individual bits\n  (selection nil)\t\t; which one last hit\n  (nrows 1)\n  (ncols 1)\n)\n\n(defvar expanded-bitmap-field-properties\n  `(\"expanded-bitmap-field-properties\"\n    = ,aggregate-field-properties\n   ))\t; can use this as real plist for online documentation\n\n(defun draw-expanded-bitmap-field (f)\n  (draw-aggregate-field f))\n\n(defun init-expanded-bitmap-field (f)\n  (let ((s (divide-points\t\t\t; calculate x,y dimensions\n\t     (box-size (zone-box (field-zone f)))\n\t     (make-point\n\t       x (expanded-bitmap-field-ncols f)\n\t       y (expanded-bitmap-field-nrows f)))))\n       (do ((z (field-zone f))\n\t    (r nil)\n\t    (x (x (ll (zone-box (field-zone f)))))\n\t    (y (y (ll (zone-box (field-zone f))))\n\t       (+ y dy))\n\t    (dx (x s))\n\t    (dy (y s))\n\t    (nc (expanded-bitmap-field-nrows f))\n\t    (nr (expanded-bitmap-field-nrows f))\n\t    (j 0 (1+ j)))\n\t   ((= j nr) (alter-aggregate-field f subfields (nreverse r)) 't)\n\t   (do ((x x (+ x dx))\n\t\t(p)\n\t\t(i 0 (1+ i)))\n\t       ((= i nc))\t\t\t; create a row of buttons\n\t       (setq p (make-point x x y y))\n\t       (setq r (xcons r (make-button-field zone (append z nil))))\n\t       (alter-zone (field-zone (car r))\n\t\t box (make-box ll p ur (add-points p s)))\n\t   ))))\n\n(defun resize-expanded-bitmap-field (f box)\n  (alter-zone (field-zone f) box box)\n  (let ((s (divide-points\t\t\t; calculate x,y dimensions\n\t     (box-size box)\n\t     (make-point\n\t       x (expanded-bitmap-field-ncols f)\n\t       y (expanded-bitmap-field-nrows f)))))\n       (do ((z (field-zone f))\n\t    (r (expanded-bitmap-field-subfields f))\n\t    (x (x (ll box)))\n\t    (y (y (ll box)) (+ y dy))\n\t    (dx (x s))\n\t    (dy (y s))\n\t    (nc (expanded-bitmap-field-nrows f))\n\t    (nr (expanded-bitmap-field-nrows f))\n\t    (j 0 (1+ j)))\n\t   ((= j nr) t)\n\t   (do ((x x (+ x dx))\n\t\t(p)\n\t\t(i 0 (1+ i)))\n\t       ((= i nc))\t\t\t; create a row of buttons\n\t       (setq p (make-point x x y y))\n\t       (resize-button-field (car r)\n\t\t (make-box ll p ur (add-points p s)))\n\t       (setq r (cdr r))\n\t   ))))\n\n(defun check-expanded-bitmap-field (f p)\n  (check-aggregate-field f p))\t; if we get here it's a hit -> check subfields\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; utilities.l\t\t\t\t\t\t\t\t;\n;;;\t\t\t\t\t\t\t\t\t;\n;;; These macros and functions are thought to be generally useful.\t;\n;;;\t\t\t\t\t\t\t\t\t;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\t\tMacros\t\t;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare\n  (macros t)\t\t; keep macros around after compiling\n  (localf pairify* pairifyq* split2* sublist*)\n  (special compiled-with-help))\n\n(defmacro copy-all-but-last (ls)\t; copy all but last member of list\n  `(let ((ls ,ls))\n\t(firstn (1- (length ls))\n\t  ls)))\n\n(defmacro all-but-last (ls)\t\t; destructive all-but-last\n  `(let ((ls ,ls))\n\t(cond ((cdr ls)\n\t       (rplacd (nthcdr (- (length ls) 2) ls) nil)\n\t       ls))))\n\n(def hex (macro (arglist)\t\t; hex to integer conversion\n\t\t`(car (hex-to-int ',(cdr arglist)))))\n\n;;; define properties on symbols for use by help routines\n\n(defmacro def-usage (fun usage returns group)\n  (cond (compiled-with-help\t; flag controls help generation\n\t  `(progn (putprop ,fun ,usage 'fcn-usage)\n\t\t  (putprop ,fun ,returns 'fcn-returns)\n\t\t  (putprop ,fun (nconc ,group (ncons ,fun)) 'fcn-group)))))\n(defvar compiled-with-help t)\t; unless otherwise notified\n\n;;; (letenv 'l_bind_plist g_expr1 ... g_exprn) -- pair-list form of \"let\"\n;;; Lambda-binds pairs of \"binding-objects\" (see description of let,let*),\n;;; at RUN TIME, then evaluates g_expr1 to g_exprn, returning g_exprn. eg:\n;;; (apply 'letenv '(letenv '(a 1 b (+ c d))\n;;;\t\t      (e)(f g)))\n;-> (eval (cons 'let (cons (pairify '(a 1 b (+ c d)))\n;;;\t\t\t   '((e) (f g)))))\n;-> (let ((a 1) (b (+ c d)))\n;;;\t (e) (f g))\n(def letenv\n  (macro (x)\n    `(eval (cons 'let\n\t     (cons\n\t       (pairify ,(cadr x))\t; plist of binding objects\n\t       ',(cddr x))))))\t\t; exprs to be eval'ed\n\n(def letenvq\t\t\t; letenv, quoted binding objects\n  (macro (x)\n    `(eval (cons 'let\n\t     (cons\n\t       (pairifyq ,(cadr x))\t; plist of binding objects\n\t       ',(cddr x))))))\t\t; exprs to be eval'ed\n\n(defmacro mergecar (L1 L2 cmpfn)\t; merge, comparing by car's\n  `(merge ,L1 ,L2 '(lambda (e1 e2)\t\t; (like sortcar)\n\t\t     (funcall ,cmpfn (car e1) (car e2)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\t\t\t\t\t\t\tFunctions\t;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; (all-but-last l_items)\t-- copy all but last list element\n\n;(defun all-but-last (ls)\n;  (cond ((cdr ls) (cons (car ls) (all-but-last (cdr ls))))))\n\n;;; (alphap sx_char)\n(defun alphap (char)\t\t\t; is char alphabetic?\n  (cond ((symbolp char)\n\t (setq char (car (exploden char)))))\n  (and (fixp char)\n       (or (and (>& char #.(1- #/A))\n\t\t(<& char #.(1+ #/Z)))\n\t   (and (>& char #.(1- #/a))\n\t\t(<& char #.(1+ #/z))))))\n\n;;; (alphanumericp sx_char)\n(defun alphanumericp (char)\t\t; is char alphabetic or numeric?\n  (cond ((symbolp char)\n\t (setq char (car (exploden char)))))\n  (and (fixp char)\n       (or (and (>& char #.(1- #/A))\n\t\t(<& char #.(1+ #/Z)))\n\t   (and (>& char #.(1- #/a))\n\t\t(<& char #.(1+ #/z)))\n\t   (and (>& char #.(1- #/0))\n\t\t(<& char #.(1+ #/9))))))\n\n;;; (assqonc 'g_key 'g_val 'l_al)\n;;; like   (cond ((assq key alist))\n;;;\t\t (t (cadr (rplacd (last alist)\n;;;\t\t\t    (ncons (cons key val))))))\n(defun assqonc (key val al)\t; tack (key.val) on end if not found\n  (do ((al al (cdr al)))\n      ((or (eq key (caar al))\n\t   (and (null (cdr al))\n\t\t(rplacd al (setq al (ncons (cons key val))))))\n       (car al))))\n\n;;; (cartesian l_xset l_yset)\n(defun cartesian (xset yset)\t\t; cartesian product of elements\n  (mapcan\n    '(lambda (x)\n       (mapcar\n\t '(lambda (y) (cons x y))\n\t yset))\n    xset))\n\n(defun concat-pairs (sb-list)\t; concat neighbouring symbol pairs\n  (do ((s1 (car sb-list) s2)\n       (s2 (cadr sb-list) (car sbs-left))\n       (sbs-left (cddr sb-list) (cdr sbs-left))\n       (result nil (cons (concat s1 s2) result)))\n      ((null s2) (nreverse result))))\n;;; (detach l)\n;;; Detaches (and throws away) first element of list (converse of attach)\n;;; keeping the same initial list cell.\n(defun detach (l)\n  (cond (l (rplacd l (cddr (rplaca l (cadr l)))))))\n\n;;; (distribute x_Q x_N)\n;;; returns list of the form: (1 1 1 0 0 0 0 1 1) or (3 2 2 2 3)\n;;; i.e. a list of length <N> containing quantity <Q> evenly distributed\n;;; with the excess <Q mod N> surrounding a \"core\" of <Q div N>'s\n;;; Useful (?) for padding spaces in line adjustment.\n;(defun distribute (Q N)\t; this one only does 1's and 0's\n;  (cond ((signp le Q) (duplicate N 0))\n;\t((eq Q 1) (pad 0 N '(1)))\n;\t(t (cons 1 (nconc\n;\t\t     (distribute (- Q 2) (- N 2))\n;\t\t     '(1))))))\n\n(defun distribute (Q N)\t\t; distribute quantity Q among N elements\n  (let ((tmp (Divide (abs Q) N)))\n       (setq tmp (distribute0 (cadr tmp) N (car tmp) (1+ (car tmp))))\n       (cond ((signp ge Q) tmp)\n\t     (t (mapcar 'minus tmp)))))\n\n(defun distribute0 (Q N X X1)\n  (cond ((signp le Q) (duplicate N X))\n\t((eq Q 1) (pad X N (ncons X1)))\n\t(t (cons X1 (nconc\n\t\t\t  (distribute0 (- Q 2) (- N 2) X X1)\n\t\t\t  (ncons X1))))))\n\n;;; (duplicate x_n g_object)\n;;; Returns list of n copies of object (nil if n <= 0)\n(defun duplicate (n object)\n  (do ((res nil (cons object res))\n       (i n (1- i)))\n      ((signp le i) res)))\n\n(defun e0 (in out)\t\t; simulate binary insertion procedure\n  (let ((lin (length in))\n\t(lout (length out)))\n       (cond ((> lin lout)\n\t      (e0\n\t\t(nthcdr lout in)\n\t\t(mapcan 'list out (firstn lout in))))\n\t     (t (nconc (mapcan 'list (firstn lin out) in)\n\t\t       (nthcdr lin out))))))\n\n(defun e (files)\t\t; determine file permutation for emacs insert\n  (let ((i (e0 (cdr (iota (length files))) '(0)))\n\t(f (append files nil)))\n       (mapc '(lambda (f-index f-name)\n\t\t(rplaca (nthcdr f-index f) f-name))\n\t     i files)\n       f))\n\n;;; (firstn x_n l_listarg)\n(defun firstn (n l)\t\t;  copy first <n> elements of list\n  (do ((n n (1- n))\n       (l l (cdr l))\n       (r nil))\n      ((not (plusp n)) (nreverse r))\t\t; <nil> if n=0 or -ve\n      (setq r (cons (car l) r))))\n\n;;; (iota x_n)\n;;; APL index generator (0,1,2,...,<n>-1)\n(defun iota (n)\n  (do ((i (1- n) (1- i))\n       (res nil))\n      ((minusp i) res)\n      (setq res (cons i res))))\n\n(defun hex-to-int (numlist)\t\t; eg. (hex-to-int '(12b3 120 8b))\n  (cond\n    (numlist\t\t\t; terminate recursion on null numlist\n      (cons\n\t(apply '+\n\t       (maplist\n\t\t '(lambda (digits)\n\t\t    (lsh\n\t\t      (get '(hex |0| 0 |1| 1 |2| 2 |3| 3\n\t\t\t\t |4| 4 |5| 5 |6| 6 |7| 7\n\t\t\t\t |8| 8 |9| 9  a 10  b 11\n\t\t\t\t  c 12  d 13  e 14  f 15)\n\t\t\t   (car digits))\n\t\t      (lsh (1- (length digits)) 2)))\n\t\t (explodec (car numlist))))\n\t(hex-to-int (cdr numlist))))))  \n\n;;; (lctouc g_expr)\n;;; Returns s-expression formed by translating lower-case alphabetic\n;;; characters in <expr> to their upper-case equivalents.\n;;; Operates by imploding the translated characters, in the case of a\n;;; symbol or string, or by recursively calling on members of a list.\n;;; Other object types are returned unchanged.\n(defun lctouc (expr)\n    (cond\n\t((dtpr expr) (mapcar 'uctolc expr))\n\t((or (symbolp expr) (stringp expr))\n\t (implode\n\t     (mapcar\n\t\t '(lambda (ch)\n\t\t      (cond ((alphap ch)\t\t; and-out lower-case bit\n\t\t\t     (boole 1 #.(1- (1- #/a)) ch)) (t ch)))\n\t\t (exploden expr))))\n\t(t expr)))\n\n;;; (log2 x_n)\n(defun log2 (n)\t\t\t; log base 2 (truncated)\n  (do ((n (lsh n -1) (lsh n -1))\n       (p 0 (1+ p)))\n      ((zerop n) p)))\n\n;;; (lowerp sx_char)\n(defun lowerp (char)\t\t; is char lower-case alphabetic?\n  (cond ((symbolp char)\n\t (setq char (car (exploden char)))))\n  (and (fixp char)\n       (or (and (> char #.(1- #/a))\n\t\t(< char #.(1+ #/z))))))\n\n;;; (numericp sx_char)\n;;; returns t if char is numeric, otherwise nil\n(defun numericp (char)\n  (cond ((symbolp char)(setq char (car (exploden char)))))\n  (and (fixp char)\n       (and (> char #.(1- #/0))\n\t    (< char #.(1+ #/9)))))\n\n;;; (pad g_item x_n l_list)\n;;; Returns <list> padded with copies of <item> to length <n>\n(defun pad (item n list)\n  (append list (duplicate (- n (length list)) item)))\n\n;;; (pairify l_items)\t; make a-list from alternating elements\n(defun pairify (pl)\n  (pairify* nil pl))\n(defun pairify* (rs pl)\t\t; tail-recursive local fun\n  (cond (pl (pairify* (cons (list (car pl) (cadr pl)) rs)\n\t\t       (cddr pl)))\n\t(t (nreverse rs))))\n\n;;; (pairifyq l_items)\t; make a-list from alternating elements\n(defun pairifyq (pl)\t; with each second element quoted\n  (pairifyq* nil pl))\n(defun pairifyq* (rs pl)\t\t; tail-recursive local fun\n  (cond (pl (pairifyq* (cons (list (car pl) (kwote (cadr pl))) rs)\n\t\t       (cddr pl)))\n\t(t (nreverse rs))))\n\n;;; (penultimate l_items)\t; cdr down to next-to-last list element\n(defun penultimate (ls)\t\n  (cond ((cddr ls) (penultimate (cdr ls)))\n\t(t ls)))\n\n;;; (split2 l_L)\n;;; Splits list <L> into two (new) second-level lists\n(defun split2* (L tc1 tc2)\n  (cond ((null L) (list (nreverse tc1) (nreverse tc2)))\n\t(t (split2* (cddr L)\n\t     (cons (car L) tc1)\n\t     (cons (cadr L) tc2)))))\n\n(defun split2 (L)\n  (split2* L nil nil))\n\n;;; (sublist L IL)\n;;; Splits list <L> (destructively) into (length IL) sub-lists.\n;;; IL is a list of starting indices, base zero, should be unique positive\n;;; fixnums in ascending order, and shouldn't exceed the length of L.\n;;; Each resulting sublist <i> begins with (nthcdr (nth <i> IL) L)\n(defun sublist (L IL)\n  (sublist* 0 nil (cons nil L) IL))\n(defun sublist* (I R L IL)\t\t; tail-recursion function\n  (cond ((and L IL)\n\t (cond\n\t   ((<& I (car IL))\n\t    (sublist* (1+ I) R (cdr L) IL))\n\t   (t (sublist* (1+ I)\n\t\t\t(cons (cdr L) R)\n\t\t\t(prog1 (cdr L) (rplacd L nil))\n\t\t\t(cdr IL)))))\n\t(t (nreverse R))))\n\n(defun try-fun (fun l-arg)\t; try function on each arg until non-nil\n  (cond ((funcall fun (car l-arg)))\n\t(l-arg (try-fun fun (cdr l-arg)))))\n\n;;; (uctolc g_expr)\n;;; Returns s-expression formed by translating upper-case alphabetic\n;;; characters in <expr> to their lower-case equivalents.\n;;; Operates by imploding the translated characters, in the case of a\n;;; symbol or string, or by recursively calling on members of a list.\n;;; Other object types are returned unchanged.\n(defun uctolc (expr)\n    (cond\n\t((dtpr expr) (mapcar 'uctolc expr))\n\t((or (symbolp expr) (stringp expr))\n\t (implode\n\t     (mapcar\n\t\t '(lambda (ch)\n\t\t      (cond ((alphap ch)\t\t; or-in lower-case bit\n\t\t\t     (boole 7 #.(1- #/a) ch)) (t ch)))\n\t\t (exploden expr))))\n\t(t expr)))\n\n;;; (unique a l) -- Scan <l> for an element <e> \"equal\" to <a>.\n;;; If found, return <e>. Otherwise nconc <a> onto <l>; return <a>.\n(defun unique (a l)\t\t\t; ensure unique in list\n  (car\n    (do ((cdr_ul l (cdr ul))\n\t (ul l cdr_ul))\n\t((null cdr_ul) (rplacd ul (ncons a)))\n\t(cond ((equal a (car cdr_ul)) (return cdr_ul))))))\n\n;;; (upperp sx_char)\n(defun upperp (char)\t\t; is char upper-case alphabetic?\n  (cond ((symbolp char)\n\t (setq char (car (exploden char)))))\n  (and (fixp char)\n       (or (and (> char #.(1- #/A))\n\t\t(< char #.(1+ #/Z))))))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; zone.l -- data structures and routines for concrete window zones\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; a \"point\" is a pair of integer x,y coordinates\n;;; a \"box\" is a pair of points defining lower left and upper right corners\n;;; a \"position\" is a point coupled with a window\n;;; a \"zone\" is a box coupled with a window\n;;; a \"window\" is a machine, integer window id and, for compatibility\n;;;\twith the toolbox, an integer toolbox window pointer\n;;; a \"machine\" is a name coupled with the j-process-id's of resident servers\n;;; The basic idea is to define a notion of a concrete position for a\n;;; display object, that can be incorporated into the object data structure.\n;;; Higher levels of software can use the objects without explicit reference\n;;; to server processes, windows and machines.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare\n  (specials t)\t\t\t; global vars not local to this file\n  (macros t))\t\t\t; compile macros as well\n\n(eval-when (compile)\t\t; trust  to higher level for eval & load\n  (load 'utilities)\t\t; utility functions\n  (load 'constants)\t\t; common constants for window toolbox\n;  (load 'shape)\t\t; arbitrarily shaped screen areas\n)\n\n(defstruct\n  (position\t\t; a concrete display position\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (window (make-window))\t; concrete window\n  (point (make-point))\t\t; actual x, y coordinates\n)\n\n(defstruct\n  (zone\t\t\t; a concrete display zone\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (window (make-window))\t; concrete window\n  (box (make-box))\t\t; bounding box of zone\n  (colour W-BACKGROUND)\t\t; colour (for scrolling etc)\n  shape\n)\n\n(defstruct\n  (window\t\t; concrete window\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (id 0)\t\t\t; integer window id\n  (machine (make-machine))\t; machine (workstation)\n  (w 0)\t\t\t\t; toolbox window structure pointer\n)\n\n(defstruct\n  (machine\t\t; machine (workstation)\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (name\t'unknown-machine)\t; machine name\n  (servers nil)\t\t\t; plist of server processes living there\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; manipulation routines\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun add-points (p q)\t\t; vector sum (x1+x2) (y1+y2)\n  (make-point\n    x (+ (x p) (x q))\n    y (+ (y p) (y q))))\n\n(defun subtract-points (p q)\t; vector subtract (x1-x2) (y1-y2)\n  (make-point\n    x (- (x p) (x q))\n    y (- (y p) (y q))))\n\n(defun multiply-points (p q)\t; vector multiply (x1*x2) (y1*y2)\n  (make-point\n    x (* (x p) (x q))\n    y (* (y p) (y q))))\n\n(defun divide-points (p q)\t; vector division (x1-x2) (y1-y2)\n  (make-point\n    x (/ (x p) (x q))\n    y (/ (y p) (y q))))\n\n(defun move-point (p q)\t\t; move point p to point q\n  (alter-point p\n    x (x q)\n    y (y q))\n  t)\t\t\t\t\t; return true\n\n(defun box-size (b)\t\t; size of box = ur - ll\n  (subtract-points (ur b) (ll b)))\n\n(defun box-interior (b)\t\t; return box just inside this box dimensions\n  (make-box\n    ll (add-points (ll b) '(1 1))\n    ur (subtract-points (ur b) '(1 1))))\n\n(defun move-box (b p)\t\t; move box b to point p (lower-left)\n  (let ((size (box-size b)))\n       (alter-box b\n\t ll p\n\t ur (add-points p size))\n       t))\t\t\t\t; return true\n\n(defun point-in-box (p b)\t; is point p in box b? (including boundary)\n  (and (>= (x p) (x (ll b)))\n       (<= (x p) (x (ur b)))\n       (>= (y p) (y (ll b)))\n       (<= (y p) (y (ur b)))\n  ))\n\n(defun point-in-box-interior (p b) ; is point p in box b? (excluding boundary)\n  (and (> (x p) (x (ll b)))\n       (< (x p) (x (ur b)))\n       (> (y p) (y (ll b)))\n       (< (y p) (y (ur b)))\n  ))\n\n(defun init-window (w)\t\t; fill in  \"window\" structure\n  (let\t\t\t\t; presuming window-w predefined\n    ((m (j-machine-name (w-get-manager (window-w w)))))\n    (alter-window w id (w-get-id (window-w w)))\n    (cond ((not (window-machine w))\n\t   (alter-window w machine (make-machine name m)))\n\t  (t (alter-machine (window-machine w) name m)))\n    (init-machine (window-machine w))\t; also fill in machine structure\n    t))\t\t\t\t; return true\n\n(defun init-machine (m)\t\t; fill in \"machine\" structure\n  (cond\t\t\t\t; presuming machine-name predefined\n    ((null (machine-servers m))\t\t; if no plist, make new one\n     (alter-machine m servers (ncons 'servers:))))\n  (mapc '(lambda (pname)\t\t; for each expected server name\n\t   (let\n\t     ((pid (j-search-machine-e jipc-error-code\n\t\t     (machine-name m)\n\t\t     pname)))\t\t; try to find one on that machine\n\t     (cond ((j-same-process pid J-NO-PROCESS)\n\t\t    (putprop (machine-servers m) nil pname)) ; failed! use nil\n\t\t   (t (putprop (machine-servers m) pid pname))))) ; success!\n\tEXPECTED-WORKSTATION-SERVERS)\t; global list of process names\n  t)\t\t\t\t\t; return true\n\n(defvar EXPECTED-WORKSTATION-SERVERS\t; global list of process names\n  '(window_manager creator savemem\n     text-composer))\t\t\t; usually want at least these\n\n(defun window-box (w)\t\t; box fills entire window\n  (let ((w-size (w-get-window-size (window-w w))))\n       (make-box\n\t ll (make-point x 0 y 0)\n\t ur (make-point x (car w-size) y (cadr w-size)))\n  ))\n\n(defun clear-zone (z colour)\t; clear zone (including boundaries)\n  (let ((b (box-size (zone-box z))))\n       (w-clear-rectangle (window-w (zone-window z))\n\t (x (ll (zone-box z))) (y (ll (zone-box z)))\n\t (1+ (x b)) (1+ (y b))\n\t colour)))\n\n(defun clear-zone-interior (z colour)\t; clear zone (excluding boundaries)\n  (let ((b (box-size (zone-box z))))\n       (w-clear-rectangle (window-w (zone-window z))\n\t (1+ (x (ll (zone-box z)))) (1+ (y (ll (zone-box z))))\n\t (1- (x b)) (1- (y b))\n\t colour)))\n\n(defun pattern-zone (z pattern)\t; pattern zone (including boundaries)\n  (let ((b (zone-box z)))\n       (w-pattern-rectangle (window-w (zone-window z))\n\t (x (ll b)) (y (ll b))\n\t (1+ (x (ur b))) (1+ (y (ur b))) pattern)\n  ))\n\n(defun pattern-zone-interior (z pattern) ; pattern zone (excluding boundaries)\n  (let ((b (box-size (zone-box z))))\n       (w-pattern-rectangle (window-w (zone-window z))\n\t (1+ (x (ll (zone-box z)))) (1+ (y (ll (zone-box z))))\n\t (1- (x b)) (1- (y b)) pattern)\n  ))\n\n(defun draw-zone-outline (z colour)\t; draw zone boundaries\n  (let* ((w (window-w (zone-window z)))\n\t (b (zone-box z))\n\t (ll (ll b))\n\t (ur (ur b)))\n\t(w-draw-vector w (x ll) (y ll) (x ll) (y ur) colour)\n\t(w-draw-vector w (x ll) (y ur) (x ur) (y ur) colour)\n\t(w-draw-vector w (x ur) (y ur) (x ur) (y ll) colour)\n\t(w-draw-vector w (x ur) (y ll) (x ll) (y ll) colour)\n  ))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; font.l -- font manipulation\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(eval-when (compile)\n  (load 'utilities)\n  (load 'constants))\n\n(defvar -installed-fonts nil)\t; list of installed fonts\n\n(defstruct\n  (font\t\t\t; font structure\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (name 'standard)\n  (size 8)\n  (body 8)\n  (cap-height 7)\n  (x-height 5)\n  (fixed-width 5)\n  (first 0)\n  (last 127)\n  glyph\t\t\t; the actual characters\n)\n\n(defstruct\n  (glyph\t\t\t; glyph structure\n    (:displace t)\n    (:list)\n    (:conc-name))\n  code\n  width\n  (bytes (byte-block 32))\t; the actual bitmap\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; \t\t\t\tfont manipulation routines\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun read-font (family size path)\n  (let ((p (infile path))\t\t; open file\n\t(x (new-vectori-long 2))\n\t(f nil))\n       (setq f (make-font\n\t\t name family\n\t\t size (tyi p)\n\t\t body (tyi p)\n\t\t cap-height (tyi p)\n\t\t x-height (tyi p)\n\t\t fixed-width (tyi p)\n\t\t first (prog1 (tyi p) (tyi p))\n\t\t last (prog1 (tyi p) (tyi p))))\n       (alter-font f glyph\n\t (do ((i (font-first f) (1+ i))\n\t      (r (ncons nil))\n\t      (g))\t   \n\t     ((> i (font-last f)) (car r))\n\t     (setq g (make-glyph code i))\t; allocate char\n\t     (do ((j 0 (1+ j)))\t\t\t; read bitmap\n\t\t ((> j 31))\n\t\t (vseti-byte (glyph-bytes g) j (tyi p)))\n\t     (alter-glyph g width (tyi p))\t; read width\n\t     (setq r (tconc r g))\n\t ))\n       (close p)\t\t\t; close file\n\n       (rplacd\t\t\t\t; install font\n\t (cond ((assoc (list (font-name f) (font-size f)) -installed-fonts))\n\t       (t (car (setq -installed-fonts\n\t\t\t     (cons (ncons (list (font-name f) (font-size f)))\n\t\t\t\t   -installed-fonts)))))\n\t f)\n       f))\t\t\t\t; return font\n\n(def-usage 'read-font '(|'st_family| |'x_size| |'st_path|)\n  'l_font-descriptor\n  (setq fcn-group (ncons \"Font Manipulation:\")))\n\n(defun install-font (f)\n  (cdr\n    (rplacd\t\t\t\t; install font\n      (cond ((assoc (list (font-name f) (font-size f)) -installed-fonts))\n\t    (t (car (setq -installed-fonts\n\t\t\t  (cons (ncons (list (font-name f) (font-size f)))\n\t\t\t\t-installed-fonts)))))\n      f)))\n\n(defun find-font (family size)\t; always \"finds\" one even if dummy\n  (cond ((cdr (assoc (list family size) -installed-fonts)))\n\t(t (install-font (make-font name family size size)))))\n\n(def-usage 'find-font\n  '(|'st_family| |'x_size|)\n  'l_font-descriptor\n  fcn-group)\n\n(defun create-font (driver font)\n  (j-send-se-list driver\n    (list 'make-font\n\t  (font-name font)\n\t  (font-size font)\n\t  (font-body font)\n\t  (font-cap-height font)\n\t  (font-x-height font)\n\t  (font-fixed-width font)\n\t  (font-first font)\n\t  (font-last font))))\n\n(defun download-glyph (driver font glyph)\n  (j-put-items\n    `((J-STRING set-glyph)\n       (J-STRING ,(font-name font))\n       (J-INT ,(font-size font))\n       (J-INT ,(glyph-code glyph))\n       (J-INT ,(glyph-width glyph))\n       (J-BLOCK ,(glyph-bytes glyph))))\n  (j-send driver))\n\n(defun download-font (driver font)\n  (do ((g (font-glyph font))\n       (font-size (font-size font)))\n      ((null g))\n      (j-put-items\n\t`((J-STRING set-glyph)\n\t  (J-STRING ,(font-name font))\n\t  (J-INT ,font-size)))\n      (do ((gg g (cdr gg)))\n\t  ((or (null gg) (j-put-items\n\t\t\t   `((J-INT ,(glyph-code (car gg)))\n\t\t\t     (J-INT ,(glyph-width (car gg)))\n\t\t\t     (J-BLOCK\n\t\t\t       ,(glyph-bytes (car gg))\n\t\t\t       ,(+ font-size font-size)))))\n\t   (setq g gg)))\t\t; when buffer full, save remainder\n      (j-send driver)\n      (cond ((eq J-STRING (j-next-item-type))\n\t     (j-gets j-comm-string 128)\t\t; skip past message string\n\t     (cond ((eq J-INT (j-next-item-type))(patom (j-geti))(terpr)))))\n  ))\n\n(def-usage 'download-font\n  '(|'x_process-id| |'l_font-descriptor|)\n  't\n  fcn-group)\n\n(defun read-create-download-font (driver family size path)\n  (let ((f (read-font family size path)))\n       (create-font driver f)\n       (download-font driver f)\n       f))\n\n(def-usage 'read-create-download-font\n  '(|'x_process-id| |'st_family| |'x_size| |'st_path|)\n  'l_font-descriptor\n  fcn-group)\n\n(defun font-depth (f)\n  (- (font-body f) (font-cap-height f)))\n\n(defun font-height (f)\n  (font-cap-height f))\n\n(defun get-font-list (sc) ; arg is string-composer or font-server pid\n  (j-send-se sc 'get-font-list)\n  (pairify (mapcar\n\t     '(lambda (x)\n\t\t(cond ((stringp (cadr x)) (concat (cadr x)))\n\t\t      (t (cadr x))))\n\t     (j-get-items))))\n\n(defun get-all-font-info (sc) ; arg is string-composer or font-server pid\n  (mapc '(lambda (f)\n\t   (rplacd (apply 'find-font f)\n\t     (cdr (progn\n\t\t    (j-send-se-list sc (cons 'get-font-info f))\n\t\t    (mapcar 'cadr (j-get-items))))))\n\t(get-font-list sc)))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; text.l -- fancy text strings\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare\n  (specials t)\n  (macros t))\n\n(eval-when (compile)\n  (load 'utilities)\n  (load 'constants)\n  (load 'zone)\n  (load 'font)\n  (load 'look))\n\n(defstruct\n  (text\t\t; text structure\n    (:displace t)\n    (:list)\n    (:conc-name))\n  (text '||)\t\t\t; the text to draw\n  (look (make-look))\t\t; what style to draw it in\n  (kl 0)\t\t\t; (starting) left kerning mask\n  (zone (make-zone))\t\t; specific window, clipping box\n  (offset (make-point))\t\t; offset of start point from zone ll\n  (kr 0)\t\t\t; (final) right kerning mask\n  (delta (make-point))\t\t; change in (x,y) relative to start point\n  (nn -1)\t\t\t; char count\n)\n\n;;; NOTE: clipping box of ((0 0) (-1 -1)) uses window boundaries\n\n(defun text-width (s)\t\t; presumes non-rotated\n  (x (text-delta s)))\n\n(defun text-box (s)\t\t; presumes non-rotated\n  (make-box\n    ll (subtract-points\n\t (text-start-point s)\n\t (make-point x 0 y (font-depth (look-font (text-look s)))))\n    ur (add-points\n\t (text-end-point s)\n\t (make-point x 0 y (font-height (look-font (text-look s)))))))\n\n(defun text-start-point (s)\n  (add-points\n    (ll (zone-box (text-zone s)))\n    (text-offset s)))\n\n(defun text-end-point (s)\n  (add-points\n    (text-start-point s)\n    (text-delta s)))\n\n(defun text-x (s)\t; x coord of start of text object\n  (+ (x (ll (zone-box (text-zone s))))\n     (x (text-offset s))))\n\n(defun text-y (s)\t; y coord of start of text object\n  (+ (y (ll (zone-box (text-zone s))))\n     (y (text-offset s))))\n\n(defun text-xx (s)\t; x coord of end of text object\n  (+ (x (ll (zone-box (text-zone s))))\n     (x (text-offset s))\n     (x (text-delta s))))\n\n(defun text-yy (s)\t; y coord of end of text object\n  (+ (y (ll (zone-box (text-zone s))))\n     (y (text-offset s))\n     (y (text-delta s))))\n\n(defun move-text (s p)\t; move s to new x,y\n  (alter-text s\n    offset (subtract-points p (ll (zone-box (text-zone s))))))\n\n(defun draw-text (s)\t\t; quietly draw text, clipping to zone box\n  (let (((x y) (text-start-point s))\n\t(l (text-look s)))\n       (j-put-items\n\t `((J-STRING compose)\n\t   (J-INT ,(window-id (zone-window (text-zone s))))\n\t   (J-STRING ,(text-text s))\n\t   (J-STRING ,(font-name (look-font l)))\n\t   (J-INT ,(font-size (look-font l)))\n\t   (J-INT ,(boole 7 (look-mode l) QUIET))\n\t   (J-INT ,(look-colour l))\n\t   (J-INT ,(look-gap l))\n\t   (J-INT ,(look-ul l))\n\t   (J-INT ,(text-kl s))\n\t   (J-INT ,x)\n\t   (J-INT ,y)\n\t   (J-INT ,(x (cond\n\t\t\t((zerop (boole 1 ROTATE-180 (look-mode l)))\n\t\t\t (ur (zone-box (text-zone s))))\n\t\t\t(t (ll (zone-box (text-zone s)))))))\n\t   (J-INT ,(y (cond\n\t\t\t((zerop (boole 1 ROTATE-90 (look-mode l)))\n\t\t\t (ur (zone-box (text-zone s))))\n\t\t\t(t (ll (zone-box (text-zone s)))))))\n\t   (J-INT ,(text-nn s))\n\t  ))\n       (j-send (get (machine-servers\n\t\t      (window-machine\n\t\t\t(zone-window\n\t\t\t  (text-zone s))))\n\t\t    'text-composer))\n  ))\n\n(defun undraw-text (s)\t; quietly undraw text, clipping to zone box\n  (let (((x y) (text-start-point s))\n\t(l (text-look s)))\n       (j-put-items\n\t `((J-STRING compose)\n\t   (J-INT ,(window-id (zone-window (text-zone s))))\n\t   (J-STRING ,(text-text s))\n\t   (J-STRING ,(font-name (look-font l)))\n\t   (J-INT ,(font-size (look-font l)))\n\t   (J-INT ,(boole 7 OVERSTRIKE QUIET (look-mode l)))\n\t   (J-INT ,(inverse-colour (look-colour l)))\n\t   (J-INT ,(look-gap l))\n\t   (J-INT ,(look-ul l))\n\t   (J-INT ,(text-kl s))\n\t   (J-INT ,x)\n\t   (J-INT ,y)\n\t   (J-INT ,(x (cond\n\t\t\t((zerop (boole 1 ROTATE-180 (look-mode l)))\n\t\t\t (ur (zone-box (text-zone s))))\n\t\t\t(t (ll (zone-box (text-zone s)))))))\n\t   (J-INT ,(y (cond\n\t\t\t((zerop (boole 1 ROTATE-90 (look-mode l)))\n\t\t\t (ur (zone-box (text-zone s))))\n\t\t\t(t (ll (zone-box (text-zone s)))))))\n\t   (J-INT ,(text-nn s))\n\t  ))\n       (j-send (get (machine-servers\n\t\t      (window-machine\n\t\t\t(zone-window\n\t\t\t  (text-zone s))))\n\t\t    'text-composer))\n  ))\n\n(defun format-text (s)\t; format text without drawing or clipping\n  (let ((memop (symbolp (text-text s)))\t; can only memoize symbols\n\t(k) (p) (q) (l (text-look s)))\n       (cond\n\t (memop\t\t\t\t\t; are we memoizing? yes!\n\t   (setq k (unique-look-id l))\t; key based on look\n\t   (setq p (get (text-text s) k))\t\t; alist found on plist\n\t   (setq q (assoc (text-kl s) p))))\t\t; entry based on kl\n       (cond\n\t (q (alter-text s\t\t\t; if info found\n\t      kr (cadr q)\t\t\t; record result\n\t      delta (caddr q)\t\t\t; then return\n\t      nn (cadddr q)))\n\t (t\t\t\t\t\t; otherwise compute data\n\t   (j-put-items\n\t     `((J-STRING compose)\n\t       (J-INT 0)\t\t\t; no window needed\n\t       (J-STRING ,(text-text s))\n\t       (J-STRING ,(font-name (look-font l)))\n\t       (J-INT ,(font-size (look-font l)))\n\t       (J-INT ,(boole 7 NO-DRAW (look-mode l)))\n\t       (J-INT ,(look-colour l))\n\t       (J-INT ,(look-gap l))\n\t       (J-INT ,(look-ul l))\n\t       (J-INT ,(text-kl s))\n\t       (J-INT 0)\t\t\t; starting point 0 0\n\t       (J-INT 0)\n\t       (J-INT -1)\t\t\t; no clipping\n\t       (J-INT -1)\n\t       (J-INT -1)\n\t      ))\n\t   (j-send (get (machine-servers\n\t\t\t  (window-machine\n\t\t\t    (zone-window\n\t\t\t      (text-zone s))))\n\t\t\t'text-composer))\n\t   (let ((kr (j-geti))\t\t\t; now record result\n\t\t (xx (j-geti))\n\t\t (yy (j-geti))\n\t\t (nn (j-geti)))\n\t\t(alter-text s\n\t\t  kr kr\n\t\t  delta (make-point x xx y yy)\n\t\t  nn nn)\n\t\t(cond (memop\t\t\t\t; memoize if req'd\n\t\t\t(cond (p (nconc p\n\t\t\t\t   (ncons (list (text-kl s) kr\n\t\t\t\t\t\t(text-delta s) nn))))\n\t\t\t      (t (putprop (text-text s)\n\t\t\t\t   (ncons (list (text-kl s) kr\n\t\t\t\t\t\t(text-delta s) nn))\n\t\t\t\t   k))))\n\t\t))\n\t ))\n       't))\t\t\t\t\t; always return t\n\n(defun scan-text (s p) ; scan text s for point p, return (kr delta nn)\n  (let (((x y) (text-start-point s))\t\t; inside: check text\n\t(l (text-look s)))\n       (j-put-items\n\t `((J-STRING compose)\n\t   (J-INT 0)\n\t   (J-STRING ,(text-text s))\n\t   (J-STRING ,(font-name (look-font l)))\n\t   (J-INT ,(font-size (look-font l)))\n\t   (J-INT ,(boole 7 NO-DRAW (look-mode l)))\n\t   (J-INT ,(look-colour l))\n\t   (J-INT ,(look-gap l))\n\t   (J-INT ,(look-ul l))\n\t   (J-INT ,(text-kl s))\n\t   (J-INT ,x)\n\t   (J-INT ,y)\n\t   (J-INT ,(x p))\n\t   (J-INT ,(y p))\n\t   (J-INT ,(text-nn s))\n\t  ))\n       (j-send (get (machine-servers\n\t\t      (window-machine\n\t\t\t(zone-window\n\t\t\t  (text-zone s))))\n\t\t    'text-composer))\n       (let ((kr (j-geti))\t\t\t; now record result\n\t     (xx (j-geti))\n\t     (yy (j-geti))\n\t     (nn (j-geti)))\n\t    (list kr (make-point x (- xx x) y (- yy y)) nn))\n  ))\n\n(defun format-draw-text (s)\t\t; draw it while formatting\n  (let ((memop (symbolp (text-text s)))\t; can only memoize symbols\n\t((x y) (text-start-point s))\n\t(k) (p) (q) (l (text-look s)))\n       (cond\n\t (memop\t\t\t\t\t; are we memoizing? yes!\n\t   (setq k (unique-look-id l))\t; key based on look\n\t   (setq p (get (text-text s) k))\t\t; alist found on plist\n\t   (setq q (assoc (text-kl s) p))))\t\t; entry based on kl\n       (cond\n\t (q (alter-text s\t\t\t; if info found\n\t      kr (cadr q)\t\t\t; record result\n\t      delta (caddr q)\n\t      nn (cadddr q))\n\t    (draw-text s))\t\t\t; draw it & return\n\t (t\t\t\t\t\t; otherwise compute data\n\t   (j-put-items\n\t     `((J-STRING compose)\n\t       (J-INT ,(window-id (zone-window (text-zone s))))\n\t       (J-STRING ,(text-text s))\n\t       (J-STRING ,(font-name (look-font l )))\n\t       (J-INT ,(font-size (look-font l)))\n\t       (J-INT ,(boole 4 (look-mode l) QUIET))\n\t       (J-INT ,(look-colour l))\n\t       (J-INT ,(look-gap l))\n\t       (J-INT ,(look-ul l))\n\t       (J-INT ,(text-kl s))\n\t       (J-INT ,x)\n\t       (J-INT ,y)\n\t       (J-INT ,(x (cond\n\t\t\t    ((zerop (boole 1 ROTATE-180 (look-mode l)))\n\t\t\t     (ur (zone-box (text-zone s))))\n\t\t\t    (t (ll (zone-box (text-zone s)))))))\n\t       (J-INT ,(y (cond\n\t\t\t    ((zerop (boole 1 ROTATE-90 (look-mode l)))\n\t\t\t     (ur (zone-box (text-zone s))))\n\t\t\t    (t (ll (zone-box (text-zone s)))))))\n\t       (J-INT -1)\t\t\t; format to end of text\n\t      ))\n\t   (j-send (get (machine-servers\n\t\t\t  (window-machine\n\t\t\t    (zone-window\n\t\t\t      (text-zone s))))\n\t\t\t'text-composer))\n\t   (let ((kr (j-geti))\t\t\t; now alter result data\n\t\t (xx (j-geti))\n\t\t (yy (j-geti))\n\t\t (nn (j-geti)))\n\t\t(cond ((neq nn (length (exploden (text-text s))))\n\t\t       (format-text s))\t; actually clipped! reformat\n\t\t      (t (alter-text s\n\t\t\t   kr kr\n\t\t\t   delta (make-point x (- xx x) y (- yy y))\n\t\t\t   nn nn)\n\t\t\t (cond\n\t\t\t   (memop\t\t; memoize if req'd\n\t\t\t     (cond (p (nconc p\n\t\t\t\t\t(ncons (list (text-kl s) kr\n\t\t\t\t\t\t     (text-delta s) nn))))\n\t\t\t\t   (t (putprop (text-text s)\n\t\t\t\t\t(ncons (list (text-kl s) kr\n\t\t\t\t\t\t     (text-delta s) nn))\n\t\t\t\t\tk))))\n\t\t\t ))\n\t\t))\n\t ))\n       't))\t\t\t\t\t; always return t\n\n(defun backspace-text (s n)\t; undraw last n characters, remove from text\n  (cond\t\t\t\t; this presumes s has valid delta,kr,nn\n    ((plusp (text-nn s))\t; proceed only if length > 0\n     (setq n (min n (text-nn s)))\t; can't delete more than nn chars\n     (let ((text (text-text s))\n\t   (l (text-look s)))\n\t  (alter-text s\t\t; keep all but last n chars\n\t    text (substring text 1 (- (text-nn s) n))\n\t    nn (- (text-nn s) n))\n\t  (format-text s)\t\t; reformat to find the new end\n\t  (j-put-items\n\t    `((J-STRING compose)\t; now undraw last character\n\t      (J-INT ,(window-id (zone-window (text-zone s))))\n\t      (J-STRING ,(substring text (- n))) ; undraw last n chars\n\t      (J-STRING ,(font-name (look-font l)))\n\t      (J-INT ,(font-size (look-font l)))\n\t      (J-INT ,(boole 7 QUIET OVERSTRIKE (look-mode l)))\n\t      (J-INT ,(inverse-colour (look-colour l)))\n\t      (J-INT ,(look-gap l))\n\t      (J-INT ,(look-ul l))\n\t      (J-INT ,(text-kr s))\n\t      (J-INT ,(text-xx s))\n\t      (J-INT ,(text-yy s))\n\t      (J-INT ,(x (cond\n\t\t\t   ((zerop (boole 1 ROTATE-180 (look-mode l)))\n\t\t\t    (ur (zone-box (text-zone s))))\n\t\t\t   (t (ll (zone-box (text-zone s)))))))\n\t      (J-INT ,(y (cond\n\t\t\t   ((zerop (boole 1 ROTATE-90 (look-mode l)))\n\t\t\t    (ur (zone-box (text-zone s))))\n\t\t\t   (t (ll (zone-box (text-zone s)))))))\n\t      (J-INT ,n)\n\t     ))\n\t  (j-send (get (machine-servers\n\t\t\t (window-machine\n\t\t\t   (zone-window\n\t\t\t     (text-zone s))))\n\t\t       'text-composer))\n\t  't))\t\t\t; return t if able to do it; nil if nn <= 0\n  ))\n\n(defun append-text (s c)\t; draw new char(s) & add to end of text\n  (cond ((fixp c)\t\t; this presumes s has valid delta,kr,nn\n\t (setq c (ascii c))))\n  (j-put-items\n    `((J-STRING compose)\t; draw new last character(s)\n      (J-INT ,(window-id (zone-window (text-zone s))))\n      (J-STRING ,c)\n      (J-STRING ,(font-name (look-font (text-look s))))\n      (J-INT ,(font-size (look-font (text-look s))))\n      (J-INT ,(boole 4 (look-mode (text-look s)) QUIET))\t; be noisy!\n      (J-INT ,(look-colour (text-look s)))\n      (J-INT ,(look-gap (text-look s)))\n      (J-INT ,(look-ul (text-look s)))\n      (J-INT ,(text-kr s))\t; this presumes s has valid delta,kr,nn\n      (J-INT ,(text-xx s))\n      (J-INT ,(text-yy s))\n\t       (J-INT ,(x (cond\n\t\t\t    ((zerop (boole 1 ROTATE-180 (look-mode l)))\n\t\t\t     (ur (zone-box (text-zone s))))\n\t\t\t    (t (ll (zone-box (text-zone s)))))))\n\t       (J-INT ,(y (cond\n\t\t\t    ((zerop (boole 1 ROTATE-90 (look-mode l)))\n\t\t\t     (ur (zone-box (text-zone s))))\n\t\t\t    (t (ll (zone-box (text-zone s)))))))\n      (J-INT -1)\n     ))\n  (j-send (get (machine-servers\n\t\t (window-machine\n\t\t   (zone-window\n\t\t     (text-zone s))))\n\t       'text-composer))\n  (let ((kr (j-geti))\n\t(xx (j-geti))\n\t(yy (j-geti))\n\t(nn (j-geti)))\n       (alter-text s\n\t text (concat (text-text s) c)\n\t kr kr\n\t delta (subtract-points\n\t\t (make-point x xx y yy)\n\t\t (text-start-point s))\n\t nn (+ (text-nn s) nn)))\n  't)\n\n(defun append-text-scroll (s c colour) ; draw and add new char(s)\n  (let ((w (window-id\t;  while scrolling zone box b in specified colour\n\t     (zone-window (text-zone s))))\n\t(b (zone-box (text-zone s)))\n\t(l (text-look s)))\n       (cond ((fixp c)\n\t      (setq c (ascii c)))) ; this presumes s has valid delta,kr,nn\n       (j-put-items\n\t `((J-STRING compose)\t; format new last character\n\t   (J-INT ,w)\n\t   (J-STRING ,c)\n\t   (J-STRING ,(font-name (look-font l)))\n\t   (J-INT ,(font-size (look-font l)))\n\t   (J-INT ,(boole 7 NO-DRAW (look-mode l)))\n\t   (J-INT ,(look-colour l))\n\t   (J-INT ,(look-gap l))\n\t   (J-INT ,(look-ul l))\n\t   (J-INT ,(text-kr s)) ; this presumes s has valid delta,kr,nn\n\t   (J-INT 0)\n\t   (J-INT 0)\n\t   (J-INT -1)\n\t   (J-INT -1)\n\t   (J-INT -1)\n\t  ))\n       (j-send (get (machine-servers\n\t\t      (window-machine\n\t\t\t(zone-window\n\t\t\t  (text-zone s))))\n\t\t    'text-composer))\n       (let ((kr (j-geti))\n\t     (xx (j-geti))\n\t     (yy (j-geti))\n\t     (nn (j-geti)))\n\t    (apply\n\t      'w-scroll-rectangle\n\t      (nconc\n\t\t(ncons (window-w (zone-window (text-zone s))))\n\t\t(let ((direction (boole 1 ROTATION\n\t\t\t\t\t(look-mode l))))\n\t\t     (cond\n\t\t       ((= direction ROTATE-0)\n\t\t\t(list (text-xx s)\n\t\t\t      (y (ll b))\n\t\t\t      (- (x (ur b)) (text-xx s) -1)\n\t\t\t      (- (y (ur b)) (y (ll b)) -1)\n\t\t\t      WM-RIGHT xx))\n\t\t       ((= direction ROTATE-90)\n\t\t\t(list (x (ll b))\n\t\t\t      (text-yy s)\n\t\t\t      (- (x (ur b)) (x (ll b)) -1)\n\t\t\t      (- (y (ur b)) (text-yy s) -1)\n\t\t\t      WM-UP yy))\n\t\t       ((= direction ROTATE-180)\n\t\t\t(list (x (ll b))\n\t\t\t      (y (ll b))\n\t\t\t      (- (text-xx s) (x (ll b)) -1)\n\t\t\t      (- (y (ur b)) (y (ll b)) -1)\n\t\t\t      WM-LEFT (- xx)))\n\t\t       ((= direction ROTATE-270)\n\t\t\t(list (x (ll b))\n\t\t\t      (y (ll b))\n\t\t\t      (- (x (ur b)) (x (ll b)) -1)\n\t\t\t      (- (text-yy s) (y (ll b)) -1)\n\t\t\t      WM-DOWN (- yy)))\n\t\t     ))\n\t\t(ncons colour)))\n\t    (w-flush (window-w (zone-window (text-zone s))))\n\t    (j-put-items\n\t      `((J-STRING compose)\t; draw new last character\n\t\t(J-INT ,w)\n\t\t(J-STRING ,c)\n\t\t(J-STRING ,(font-name (look-font l)))\n\t\t(J-INT ,(font-size (look-font l)))\n\t\t(J-INT ,(boole 7 (look-mode l) QUIET))\n\t\t(J-INT ,(look-colour l))\n\t\t(J-INT ,(look-gap l))\n\t\t(J-INT ,(look-ul l))\n\t\t(J-INT ,(text-kr s)) ; this presumes s has valid delta,kr,nn\n\t\t(J-INT ,(text-xx s))\n\t\t(J-INT ,(text-yy s))\n\t       (J-INT ,(x (cond\n\t\t\t    ((zerop (boole 1 ROTATE-180 (look-mode l)))\n\t\t\t     (ur (zone-box (text-zone s))))\n\t\t\t    (t (ll (zone-box (text-zone s)))))))\n\t       (J-INT ,(y (cond\n\t\t\t    ((zerop (boole 1 ROTATE-90 (look-mode l)))\n\t\t\t     (ur (zone-box (text-zone s))))\n\t\t\t    (t (ll (zone-box (text-zone s)))))))\n\t\t(J-INT -1)\n\t       ))\n\t    (j-send (get (machine-servers\n\t\t\t   (window-machine\n\t\t\t     (zone-window\n\t\t\t       (text-zone s))))\n\t\t\t 'text-composer))\n\t    (alter-text s\n\t      text (concat (text-text s) c)\n\t      kr kr\n\t      delta (add-points\n\t\t      (make-point x xx y yy)\n\t\t      (text-delta s))\n\t      nn (+ (text-nn s) nn))\n       )'t))\n\n(defun format-text-list (sl)\t\t\t; chain the text objects\n  (do ((s (car sl) (car sl))\t\t\t; so that xx,yy,kr of one\n       (sl (cdr sl) (cdr sl)))\t\t\t; used as x,y,kl of next\n      ((null sl) (format-text s) 't)\n      (format-text s)\n      (alter-text (car sl)\n\tkl (text-kr s))\n      (move-text (car sl) (text-end-point s))\n  ))\n\n(defun move-text-list (sl p)\t; move whole list of text objects\n  (do ((s (car sl) (car sl))\n       (sl (cdr sl) (cdr sl))\n       (p p (text-end-point s)))\n      ((null s) 't)\n      (move-text s p)\n  ))\n\n(defun compress-text-list (sl)\t\t; combine like-moded text objects\n  (do ((s (car sl) (car sl))\t\t\t; to reduce communication\n       (sl (cdr sl) (cdr sl))\n       (new-text nil)\n       (new-end-point (text-start-point s))\n       (new-s (append (car sl) nil))\t; top-level copy\n       (dx nil)\n       (gap (look-gap (text-look (car sl))))\n       (result nil))\n      ((null s) (alter-text new-s\n\t\t   text (apply 'concat (nreverse new-text))\n\t\t   nn -1)\n       (nreverse (cons new-s result)))\t\t; return new s-list\n      (setq dx (- (x (text-start-point s))\n\t\t  (x new-end-point)))\n      (cond ((and\t\t\t; check most likely diffs first\n\t       (or (eq dx 0) (>= dx (look-gap (text-look s))))\n\t       (= (y (text-start-point s)) (y new-end-point))\n\t       (eq (text-look s)\n\t\t   (text-look new-s))\n\t     )\t\t\t\t; presume kerning doesn't matter!\n\t     (cond ((plusp dx)\t\t; horizontal movement\n\t\t    (setq new-text\n\t\t\t  (cons\n\t\t\t    (implode\n\t\t\t      (do ((dx (- dx gap 4) (- dx gap 4))\n\t\t\t\t   (result nil))\n\t\t\t\t  ((minusp dx)\n\t\t\t\t   (do ((dx (+ dx 4 -1) (- dx gap 1)))\n\t\t\t\t       ((minusp dx)\n\t\t\t\t\t(cond ((eq dx -1)\n\t\t\t\t\t       (setq result\n\t\t\t\t\t\t     (cons 1 result)))))\n\t\t\t\t\t\t\t; 0-pixel space\n\t\t\t\t       (setq result (cons 2 result)))\n\t\t\t\t\t\t\t; 1-pixel space\n\t\t\t\t   result)\n\t\t\t\t  (setq result (cons 3 result))\n\t\t\t\t\t\t\t; 4-pixel space\n\t\t\t      ))\n\t\t\t    new-text))))\n\t     (setq new-text (cons (text-text s) new-text))\n\t     (setq new-end-point (text-end-point s))\n\t    )\n\t    (t (alter-text new-s\n\t\t text (apply 'concat (nreverse new-text))\n\t\t nn -1\n\t\t delta (subtract-points new-end-point\n\t\t\t (text-start-point new-s)))\n\t       (setq result (cons new-s result))\n\t       (setq new-s (append s nil)\n\t\t     new-text (ncons (text-text s)))\n\t       (setq\n\t\t new-end-point (text-start-point s)\n\t\t gap (look-gap (text-look s)))\n\t    )\n      )))\n\n(defun draw-text-list (sl)\n  (mapc '(lambda (x) (draw-text x)) sl) 't)\n\n(defun undraw-text-list (sl)\n  (mapc '(lambda (x) (undraw-text x)) sl) 't)\n\n(defun format-draw-text-list (slist) ; format all on same line\n  (do ((s (car slist) (car sl))\n       (sl (cdr slist) (cdr sl)))\n      ((null sl) (format-draw-text s))\t; format the last one\n      (format-draw-text s)\n      (move-text (car sl)\t; chain xx,yy,kr to next one's x,y,kl\n\t(text-end-point s))\n  ))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; text-edit.l -- rudimentary line editor for fancy character texts\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;\n;;; These routines provide a simple line editor with control keys reminiscent\n;;; of the default EMACS key bindings.\n;;;\n;;; The calling program presumably has obtained a \"point\" event, at\n;;; position \"p\".  The cursor will be placed on the nearest character,\n;;; and then input is accepted from the keyboard, until such time as a\n;;; <return> key is accepted, or a point event occurs outside the text\n;;; zone boundary, or until a non-key, non-point event occurs.  Another\n;;; point event within the text zone causes the cursor to be re-positioned.\n;;;\n;;; Editing operations currently supported are:\n;;;\tCTRL-A (ascii 1)\t; control A = beginning of line\n;;;\tCTRL-B (ascii 2)\t; control B = backward-character\n;;;\tCTRL-D (ascii 4)\t; control D = delete next char\n;;;\tCTRL-E (ascii 5)\t; control E = end of line\n;;;\tCTRL-F (ascii 6)\t; control F = forward-character\n;;;\tBACKSPACE (ascii 8)\t; BACKSPACE = delete previous char\n;;;\tCTRL-K (ascii 11)\t; control K = kill to end of line\n;;;\tCTRL-L (ascii 12)\t; control L = redraw text\n;;;\tRETURN (ascii 13)\t; RETURN = \"done\"\n;;;\tCTRL-T (ascii 20)\t; control T = transpose previous 2 chars\n;;;\tCTRL-Y (ascii 25)\t; control Y = \"yank\" recently killed text\n\n(declare\n  (specials t)\n  (macros t))\n\n(eval-when (compile)\n  (load 'utilities)\n  (load 'constants)\n  (load 'zone)\n  (load 'font)\n  (load 'look)\n  (load 'text))\n\n\n(eval-when (compile eval load)\n  (defvar BACKSPACE (ascii 8))\t; backspace char = delete previous char\n  (defvar RETURN (ascii 13))\t; carriage return = \"done\"\n  (defvar CTRL-A (ascii 1))\t; control A = beginning of line\n  (defvar CTRL-B (ascii 2))\t; control B = backward-character\n  (defvar CTRL-D (ascii 4))\t; control D = delete next char\n  (defvar CTRL-E (ascii 5))\t; control E = end of line\n  (defvar CTRL-F (ascii 6))\t; control F = forward-character\n  (defvar CTRL-K (ascii 11))\t; control K = kill to end of line\n  (defvar CTRL-L (ascii 12))\t; control L = redraw text\n  (defvar CTRL-T (ascii 20))\t; control T = transpose previous 2 chars\n  (defvar CTRL-Y (ascii 25))\t; control Y = \"yank\" recently killed text\n  (defvar TYPEAHEAD-THRESHOLD 5); can type at most 5 chars -> forced feedback\n)\n\n(defun edit-text (s p)\t; edit a text at point p\n  (cond\t\t\t\t\t; p outside zone => nil\n    ((not (point-in-box p (zone-box (text-zone s)))) nil)\n    (t\t\t\t\t\t; p inside zone => edit text\n      (let\n\t((w (window-w (zone-window (text-zone s))))\n\t (post (append s nil))\n\t (kill-text \"\"))\n\t(split-texts s post p)\t; split into left and right parts\n\t(draw-cursor-leading-text post)\t; highlight first char\n\t(skip-stroke-release-events w)\n\t(do ((e (w-get-next-event w)\t\t; get an event\n\t\t(w-get-next-event w))\t\t; then keep getting events\n\t     (l) (c))\t\t\t\t; character list, character\n\t    ((eq c '#.RETURN)\t\t; stop when <return> is received\n\t     (cond ((neq e WM-KEY)\t; if not caused by key, put event back\n\t\t    (w-put-back-event w)))\n\t     (combine-texts s post)\n\t     t)\t\t\t; just return 't\n\t    (cond\t\t\t; main loop\n\t      ((eq e WM-KEY)\n\t       (setq c (concat (car (w-get-key w))))\t; get the character\n\t       (cond\n\t\t ((eq c '#.BACKSPACE)\t\t; backspace char\n\t\t  (text-delete-previous-character s post))\n\t\t ((eq c '#.CTRL-A)\t\t\t; control A\n\t\t  (text-beginning-of-line s post))\n\t\t ((eq c '#.CTRL-B)\t\t\t; control B\n\t\t  (text-backward-character s post))\n\t\t ((eq c '#.CTRL-D)\t\t\t; control D\n\t\t  (text-delete-next-character s post))\n\t\t ((eq c '#.CTRL-E)\t\t\t; control E\n\t\t  (text-end-of-line s post))\n\t\t ((eq c '#.CTRL-F)\t\t\t; control F\n\t\t  (text-forward-character s post))\n\t\t ((eq c '#.CTRL-K)\t\t\t; control K\n\t\t  (text-kill-to-end-of-line s post))\n\t\t ((eq c '#.CTRL-L)\t\t\t; control L\n\t\t  (text-redraw-display s post))\n\t\t ((eq c '#.CTRL-T)\t\t\t; control T\n\t\t  (text-transpose-characters s post))\n\t\t ((eq c '#.CTRL-Y)\t\t\t; control Y\n\t\t  (text-yank-from-killbuffer s post))\n\t\t ((neq c '#.RETURN)\t\t\t; not <return>\n\t\t  (text-insert-character s post))\n\t\t (t (w-put-back-event w))\t; it's a <return>; put it back\n\t       ))\t\t\t; so loop control can get it again\n\t      ((eq e WM-POINT-DEPRESSED)\n\t       (setq p (w-get-point w))\n\t       (cond\t\t\t\t; check point in zone\n\t\t ((point-in-box p (zone-box (text-zone s)))\n\t\t  (draw-cursor-leading-text post)\t; un-highlight char\n\t\t  (combine-texts s post)\n\t\t  (split-texts s post p)\n\t\t  (draw-cursor-leading-text post)\t; highlight new char\n\t\t  (skip-stroke-release-events w))\n\t\t (t (w-put-back-event w)\t; outside zone => return\n\t\t    (setq c '#.RETURN))))\n\t      ((neq e WM-CANCEL)\t\t; an event we can't handle\n\t       (w-put-back-event w)\t\t; so put it back, then return\n\t       (setq c '#.RETURN))\n\t    )))\n    )))\n\n(defun input-typeahead-keys (w n brk-fcn l)\t; return keys typed ahead\n   (cond\t\t\t\t\t; brk-fcn tests text\n     ((or (zerop n)\t\t\t\t; already have max typeahead\n\t  (not (w-any-events w))) (nreverse l))\t; or there aren't any events\n     (t (let ((x (w-get-next-event w)))\t\t; there's an event\n\t     (cond\n\t       ((neq x WM-KEY)\n\t\t(w-put-back-event w) (nreverse l))\t; but not a keystroke\n\t       (t (setq x (car (w-get-key w)))\t\t; it's a keystroke\n\t\t  (cond\n\t\t    ((funcall brk-fcn x)\t\t; is it a break char?\n\t\t     (w-put-back-event w) (nreverse l))\t; it's a special char\n\t\t    (t (input-typeahead-keys\t\t; it's a regular char\n\t\t\t w (1- n) brk-fcn (cons x l)))\t; tail recur for rest\n\t\t  )))))))\n\n(defun split-texts (s post p)\t\t; split text s at point p\n  (let\t\t\t\t\t; yielding texts s and post\n    (((kr delta nn) (scan-text s p)))\t; scan for char pos'n\n    (alter-text post\t\t\t; text incl & after char pt'ed\n      text (cond ((substring (text-text s) (1+ nn)))\t; if it exists!\n\t\t (\"\"))\t\t\t; otherwise,nothing\n      offset (add-points (text-offset s) delta)\n      kl kr\n      delta (subtract-points (text-delta s) delta)\n      nn (- (text-nn s) nn))\n    (alter-text s kr kr delta delta nn nn\t; truncate text\n      text (cond ((substring (text-text s) 1 nn))\n\t\t (\"\")))\n  ))\n\n(defun skip-stroke-release-events (w)\n  (do ((e (w-get-next-event w)\n\t  (w-get-next-event w)))\n      ((neq e WM-POINT-STROKE)\t\t; get events until non-point-stroke\n       (cond ((neq e WM-POINT-RELEASED)\t; should be point-release\n\t      (w-put-back-event w))))\t; if not, put it back\n  ))\n\n(defun combine-texts (s post)\t; recombine texts\n  (alter-text s\n    text (concat (text-text s) (text-text post))\n    nn (+ (text-nn s) (text-nn post))\n    delta (add-points (text-delta s) (text-delta post))\n    kr (text-kr post))\n  (format-text s))\n\n(defun draw-cursor-leading-text (s)\t; highlight first char of text\n  (let ((c (append s nil)))\n       (alter-text c\t\t\t; get first char\n\t text (concat (cond ((substring (text-text c) 1 1))\t; if any\n\t\t\t    (t 'a))))\t; otherwise use a typical character\n       (format-text c)\n       (w-clear-rectangle\n\t (window-w (zone-window (text-zone c)))\n\t (text-x c)\n\t (y (ll (zone-box (text-zone c))))\n\t (min (x (text-delta c))\n\t      (- (x (ur (zone-box (text-zone c))))\n\t\t (text-x c) -1))\n\t (- (y (ur (zone-box (text-zone c))))\n\t    (y (ll (zone-box (text-zone c)))) -1)\n\t W-XOR)\n       (w-flush (window-w (zone-window (text-zone c))))\n       t))\n\n(defun text-delete-previous-character (s post)\n  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD\n\t     '(lambda (x)\t; break on first non-BS\n\t\t(not (equal x #.(get_pname BACKSPACE))))\n\t     (ncons '#.BACKSPACE))))\n       (alter-text s\n\t nn (max 0 (- (text-nn s) (length l))))\n       (alter-text s\n\t text (cond ((substring\n\t\t       (text-text s)\n\t\t       1 (text-nn s)))\n\t\t    (\"\")))\n       (format-text s)\n       (w-scroll-rectangle\n\t (window-w (zone-window (text-zone s)))\n\t (text-xx s)\n\t (y (ll (zone-box (text-zone s))))\n\t (- (x (ur (zone-box (text-zone s))))\n\t    (text-xx s) 1)\n\t (1+ (y (box-size (zone-box (text-zone s)))))\n\t WM-LEFT\n\t (- (x (text-start-point post))\n\t    (x (text-end-point s)))\n\t (zone-colour (text-zone s)))\n       (w-flush\n\t (window-w (zone-window (text-zone s))))\n       (move-text post (text-end-point s))\n       (alter-text post kl (text-kr s))))\n\n(defun text-beginning-of-line (s post)\n  (draw-cursor-leading-text post)\t; un-highlight first char\n  (alter-text post\n    text (concat (text-text s) (text-text post))\n    nn (+  (text-nn s) (text-nn post))\n    delta (add-points (text-delta s) (text-delta post))\n    kl 0\n    offset (text-offset s))\n  (alter-text s text \"\" nn 0 delta '(0 0) kr 0)\n  (draw-cursor-leading-text post))\t; highlight new first char\n\n(defun text-backward-character (s post)\n  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD\n\t     '(lambda (x)\t; break on first non-BS\n\t\t(not (equal x #.(get_pname CTRL-B))))\n\t     (ncons '#.CTRL-B))))\n       (draw-cursor-leading-text post)\t; un-highlight first char\n       (alter-text post\n\t text (get_pname (concat (substring (text-text s) (- (length l)))\n\t\t\t   (text-text post)))\n\t nn (1+ (text-nn post)))\n       (alter-text s\n\t text (substring (text-text s) 1 (- (text-nn s) (length l)))\n\t nn (- (text-nn s) (length l)))\n       (format-text s)\n       (alter-text post\n\t kl (text-kr s)\n\t offset (add-points (text-offset s) (text-delta s))\n\t delta (subtract-points\n\t\t (text-end-point post)\n\t\t (text-end-point s)))\n       (draw-cursor-leading-text post)\t; highlight new first char\n  ))\n\n(defun text-forward-character (s post)\n  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD\n\t     '(lambda (x)\t; break on first non-BS\n\t\t(not (equal x #.(get_pname CTRL-F))))\n\t     (ncons '#.CTRL-F))))\n       (draw-cursor-leading-text post)\t; un-highlight first char\n       (alter-text s\n\t text (get_pname (concat (text-text s)\n\t\t\t   (substring (text-text post) 1 (length l))))\n\t nn (+ (text-nn s) (length l)))\n       (format-text s)\n       (alter-text post\n\t text (substring (text-text post) (1+ (length l)))\n\t nn (- (text-nn post) (length l))\n\t kl (text-kr s)\n\t offset (add-points (text-offset s) (text-delta s))\n\t delta (subtract-points\n\t\t (text-end-point post)\n\t\t (text-end-point s)))\n       (draw-cursor-leading-text post)\t; highlight new first char\n  ))\n\n(defun text-end-of-line (s post)\n  (draw-cursor-leading-text post)\t; un-highlight first char\n  (alter-text s\n    text (concat (text-text s) (text-text post))\n    nn (+  (text-nn s) (text-nn post))\n    delta (add-points (text-delta s) (text-delta post))\n    kr (text-kr post))\n  (alter-text post\n    text \"\"\n    nn 0\n    offset (add-points (text-offset post) (text-delta post))\n    delta '(0 0)\n    kl (text-kr s))\n  (draw-cursor-leading-text post))\t; highlight new first char\n  \n(defun text-kill-to-end-of-line (s post)\n  (w-clear-rectangle\n    (window-w (zone-window (text-zone post)))\n    (text-x post)\n    (y (ll (zone-box (text-zone post))))\n    (- (x (ur (zone-box (text-zone post)))) (text-x post))\n    (1+ (y (box-size (zone-box (text-zone post)))))\n    (zone-colour (text-zone post)))\n  (setq kill-text (text-text post))\n  (alter-text post\n    text \"\"\n    nn 0\n    delta '(0 0)\n    kl (text-kr s))\n  (draw-cursor-leading-text post))\t; highlight new first char\n  \n(defun text-yank-from-killbuffer (s post)\n  (append-text-scroll s kill-text\n    (zone-colour (text-zone s)))\n  (move-text post (text-end-point s))\n  (alter-text post\n    kl (text-kr s)))\n\n(defun text-transpose-characters (s post)\n  (let ((tmp (append s nil)))\n       (alter-text tmp\n\t nn (- (text-nn tmp) 2))\n       (let (((kr delta nn) (scan-text tmp '(-1 -1)))) ; find 2nd prev char\n\t    (alter-text tmp\n\t      text (substring (text-text tmp) -2)\n\t      offset (add-points (text-offset tmp) delta)\n\t      kl kr)\n\t    (format-text tmp)\n\t    (w-clear-rectangle\n\t      (window-w (zone-window (text-zone tmp)))\n\t      (text-x tmp)\n\t      (y (ll (zone-box (text-zone tmp))))\n\t      (x (text-delta tmp))\n\t      (1+ (y (box-size (zone-box (text-zone tmp)))))\n\t      (zone-colour (text-zone tmp)))\n\t    (w-flush (window-w (zone-window (text-zone tmp))))\n\t    (alter-text tmp\n\t      text (get_pname (concat\n\t\t\t\t(substring (text-text tmp) 2 1)\n\t\t\t\t(substring (text-text tmp) 1 1))))\n\t    (format-draw-text tmp)\n\t    (alter-text s\n\t      text (get_pname\n\t\t     (concat\n\t\t       (substring (text-text s) 1 (- (text-nn s) 2))\n\t\t       (text-text tmp)))\n\t      kr (text-kr tmp))\n       )))\n\n(defun text-delete-next-character (s post)\n  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD\n\t     '(lambda (x)\t; break on first non-BS\n\t\t(not (equal x #.(get_pname CTRL-D))))\n\t     (ncons '#.CTRL-D))))\n       (alter-text post\n\t nn (length l))\n       (let (((kl delta nn)\t\t; scan for nn'th char position\n\t      (scan-text post '(-1 -1))))\n\t    (w-scroll-rectangle\n\t      (window-w (zone-window (text-zone post)))\n\t      (text-x post)\n\t      (y (ll (zone-box (text-zone post))))\n\t      (- (x (ur (zone-box (text-zone post))))\n\t\t (text-x post) 1)\n\t      (1+ (y (box-size (zone-box (text-zone post)))))\n\t      WM-LEFT\n\t      (x delta)\n\t      (zone-colour (text-zone post)))\n\t    (alter-text post\n\t      nn (max 0 (- (length (exploden (text-text post)))\n\t\t\t   (length l)))\n\t      kl kl)\n\t    (alter-text post\n\t      text (cond ((substring\n\t\t\t    (text-text post)\n\t\t\t    (- (text-nn post))))\n\t\t\t (\"\")))\n\t    (format-text post)\n\t    (draw-cursor-leading-text post)\n\t    (w-flush (window-w (zone-window (text-zone post))))\n       )))\n\n(defun text-insert-character (s post)\n  (let ((l (input-typeahead-keys w TYPEAHEAD-THRESHOLD\n\t     '(lambda (x)\t; break on first BS or CR\n\t\t(memq (concat x) '#.(list BACKSPACE RETURN)))\n\t     (ncons c))))\n       (append-text-scroll s (concatl l)\n\t (zone-colour (text-zone s)))\n       (move-text post (text-end-point s))\n       (alter-text post\n\t kl (text-kr s))))\n\n(defun text-redraw-display (s post)\n  (clear-zone (text-zone s) (zone-colour (text-zone s)))\n  (w-flush (window-w (zone-window (text-zone post))))\n  (format-draw-text s)\n  (alter-text post\n    kl (text-kr s)\n    offset (add-points (text-offset s) (text-delta s)))\n  (format-draw-text post)\n  (draw-cursor-leading-text post))\n", "encoding": "ascii"}