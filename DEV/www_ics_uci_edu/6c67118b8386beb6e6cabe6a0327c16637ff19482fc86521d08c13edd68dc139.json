{"url": "https://www.ics.uci.edu/~alspaugh/cls/shr/als/relation.als", "content": "//  Relations and logic\n\nabstract sig Dog { }\none sig Fido, Gruff, Hero //  A set of three dogs\nextends Dog {}\n\nabstract sig Person {\n  hasOneDog: Dog,\n  hasDogs: some Dog,\n  bestFriend: one Person\n}\none sig Ann, Bob, Chip //  A set of three people\nextends Person {}\n\n\npred show {}\nrun show\n\n// arrow product ->\nfun x: Person->Dog {\n  Ann->Fido +\n  Bob->Fido +\n  Chip->Gruff\n}\npred xInHasDogs {\n  x in hasDogs\n}\nrun xInHasDogs\n\n// dot join .\npred fidoInOne {\n  Fido in\n  Person.hasOneDog     //  Somebody has Fido as only dog.\n}\nrun fidoInOne\n\npred fidoInSome {\n  Fido in\n  Person.hasDogs       //  Somebody has Fido as one of their dogs\n}\nrun fidoInSome\n\n// dot join and quantifier\npred fidoInEvery {\n  all p:Person |\n  Fido in p.hasDogs    //  Everybody has Fido as one of their dogs\n}\nrun fidoInEvery\n\n// box join []\npred dogInEvery {\n  Dog in\n  hasOneDog[Person]    // fidoInOne, reversed (box)\n}\nrun dogInEvery\n\n// transpose ~\npred chipInEvery {\n  Chip in\n  Dog.~hasOneDog       //  Chip in transposed hasOneDog\n}\nrun chipInEvery\n\n// transitive closure ^\npred closing {\n  Bob not in Ann.bestFriend\n  and\n  Bob in Ann.^bestFriend\n}\nrun closing\n\n// domain restriction <:\n// range restriction :>\npred restrictions {\n  (Person <: iden :> Dog)\n  in hasOneDog         //  Restrictions on iden\n}\nrun restrictions\n\n// override ++\npred override [p:Person->Dog] {\n  p not in\n  (hasOneDog\n  ++\n  Ann->Gruff)          //  Overriding every tuple beginning with Ann\n}\nrun override\n\n", "encoding": "ascii"}