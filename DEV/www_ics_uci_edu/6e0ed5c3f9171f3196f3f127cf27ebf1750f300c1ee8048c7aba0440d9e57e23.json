{"url": "https://www.ics.uci.edu/~ejw/versioning/whitehead_proposal.html", "content": "<HTML>\n\n<HEAD>\n\n<TITLE>WWW Versioning Support</TITLE>\n\n<META NAME=\"GENERATOR\" CONTENT=\"Internet Assistant for Microsoft Word 2.0 beta 1\">\n</HEAD>\n\n<BODY>\n\n<P>\n<CENTER><B><FONT SIZE=5>WWW Versioning Support</FONT></B></CENTER>\n<P>\n<CENTER><I><B>Draft Proposal (v 0.1, April 16, 1996)</B></I></CENTER>\n<P>\n<CENTER><FONT FACE=\"Helvetica\">Jim Whitehead<BR>\n<BR>\n</FONT></CENTER>\n<P>\n<B>Abstract<BR>\n</B>\n<P>\nTBD<BR>\n\n<P>\n<B>1.  Introduction</B>\n<P>\n<B>1.1  Purpose<BR>\n</B>\n<P>\nThe World-Wide Web has demonstrated great utility as a mechanism\nfor allowing information entities to be published, then browsed\nby the global Internet community. However, the current publish/browse\nmodel only allows browsing of the most current revision of an\nentity; older versions of an entity become unaccessible after\nit is updated. The HTTP/1.1 specification extends the publish/browse\nmodel by allowing distributed <I>editing</I> of entities, affording\nuse of the World-Wide Web for distributed home editing of personal\nweb pages, tele-commuting, and distributed software development,\namong others.  As defined in HTTP/1.1, the &quot;PUT&quot; method\noverwrites the current contents of the destination Uniform Resource\nIdentifier (URI) or Uniform Resource Locator (URL).  This allows\nusers to overwrite each other's editing updates with successive\nPUT method invocations (the &quot;lost update&quot; problem),\nan unacceptable outcome during group work. <BR>\n\n<P>\nVersioning techniques alleviate both the loss of past revisions\nof an entity and the lost update problem.  Fundamental to all\nversioning approaches is the provision of storage for past states\nof a entitiy and methods for the retrieval of those past states;\ntogether, they preserve the history of an entity for later examination\nor use.  Versioning addresses the lost update problem by providing\na policy for the creation, locking, and editing of a new state\nof an entity.  <BR>\n\n<P>\nThis document describes a set of extensions to the World-Wide\nWeb which augment it with versioning capability.  Included in\nthis document are extensions to the HTTP/1.1 protocol to add methods\nspecific to versioning, new entity types to describe collections\nof versioned entities and derivation relationships between versions\nof the same entity, and URI/URL naming conventions for versioned\nentities.\n<P>\n<B>1.2  Desired Capabilites<BR>\n</B>\n<P>\nThe capabilities desired of versioning support for the World-Wide\nWeb are:\n<UL>\n<LI><I>Policy-neutral versioning</I>: the methods defined for\naccessing, modifing, and locking entities should allow multiple\nversioning policies to be built on top of them.  For example,\nlock-based policies, as employed by RCS, and merge-based policies,\nas implemented in CVS, should both be implementable.\n<LI><I>Retrieval of a stated version of an entity</I>: Any given\nrevision of an entity should be accessible, thus supporting links\nto stated revisions of entities.\n<LI><I>Writing to a given version of an entity</I>: Once changes\nhave been made to an entity, versioning policies often dictate\nthat the changes be written into a new, stated version of that\nentity.\n<LI><I>Parallel development support</I>: Since it frequently occurs\nthat multiple people edit the same entity simultaneously, this\ntype of activity must be supported.  User agents must be supplied\nwith enough information to inform their users when they are entering\na parallel development situation, and they must be supplied with\nthe versions of parallel entities so they can provide merge support\nfor the entity contents.  Futhermore, since it is currently beyond\nthe state of the art to provide merge support for certain entity\ntypes (e.g., MPEG video), it must be possible to disallow parallel\ndevelopment on these entity types.\n<LI><I>Browsing within a collection of entities</I>: Often multiple\nentities together form a logical grouping, for example, a collection\nof HTML and GIF entities which comprise online documentation for\na software product.  It is desirable to provide support for browsing\nwithin such a collection without requiring either the user or\nthe entities to explicitly name the destination entity version\nof each link traversal.\n<LI><I>Retrieval of derivation relationships between versions\nof an entity</I>: The ability to trace the development and ownership\nof an entity provides visibility into the development of that\nentity, and is frequently useful to the user.\n<LI><I>Visibility control</I>: Through the user agent, it should\nbe possible to control the external visibility of an entity. \nFor example, this is useful  for ensuring that working revisions\nof an entity are not accessible by the entire world.\n</UL>\n\n<P>\n<B>1.3 Types of Group Work Supported<BR>\n</B>\n<P>\nSingle, Parallel Asynchronous, not Parallel Synchronous\n<P>\n<B>2.0 Version Naming Conventions<BR>\n</B>\n<P>\nA version of a URI is explicitly specified by appending a parameter\ncalled &quot;v&quot; to the URI.  For example, version 3.0 of\nentity foo would be written foo;v=3.0.\n<P>\n<B>3.0 Extensions to HTTP/1.1<BR>\n</B>\n<P>\n(Note: IETF standard BNF is not consistently used throughout ...\nneeds some cleanup)\n<P>\n<B>3.1 New Methods<BR>\n</B>\n<P>\nThe new methods added to HTTP/1.1 to support versioning are:<BR>\n\n<P>\n&quot;FLAG&quot;\n<P>\n&quot;LOCK&quot;\n<P>\n&quot;UNLOCK&quot;\n<P>\n&quot;USE&quot;\n<P>\n<B>3.2 FLAG<BR>\n</B>\n<P>\nThe FLAG method operates on flags associated with the Request-URI.\n FLAG makes use of a new Request Header Field called &quot;Flag-Option&quot;.\n Valid values of Flag-Option are &quot;SET&quot; flag, &quot;CLEAR&quot;\nflag, and &quot;QUERY&quot;.  The FLAG method must be accompanied\nby a valid &quot;Authorization&quot; header field (ed: or the\nappropriate header field for identifying the end-user operating\nthe user-agent to the HTTP server).  The FLAG method always has\nan entity-body which contains a list of the active flags for the\nentity (including the effects of the requested Flag-Option), in\nthe form:<BR>\n<BR>\n\n<P>\nFor all users with flags set:\n<P>\n{user identification string}: {list of flags currently set for\nthe user}\n<P>\n<B>3.2.1 Flag-Option values<BR>\n</B>\n<P>\nThe &quot;SET&quot; Flag-Option sets the indicated flag to true.\n The &quot;CLEAR&quot; Flag-Option sets the indicated flag to\nfalse.  The &quot;QUERY&quot; Flag-Option has no effect on any\nflag (and hence only causes the return of the current list of\nflags).  A flag set on an entity (no version specified in the\nRequest-URI) applies to all versions of that entity.  A flag set\non a particular version of an entity (version specified in Request-URI)\napplies to only the indicated version of the entity.<BR>\n\n<P>\nWhen the Flag-Option is &quot;SET&quot;, the indicated flag will\nbe set, then automatically cleared after one week, unless the\n&quot;Auto-Timeout&quot; header is present, in which case the\nvalue it specifies will be employed.  An Auto-Timeout value of\n&quot;Never&quot; causes the flag to never automatically be cleared\nafter a preset interval. Re-setting the same flag on the Request-URI\nis legal, and causes the timeout value to be updated.\n<P>\n<B>3.2.2 Flag Naming Conventions<BR>\n</B>\n<P>\nThere are two flags with special names for the versioning context,\nthese being:<BR>\n\n<P>\n&quot;EDIT&quot;\n<P>\n&quot;LOCK&quot;<BR>\n\n<P>\nThe EDIT flag is for use by CVS-like versioning policies, and\nhas the meaning: this entity is currently being edited by the\nnamed user.  The LOCK flag is automatically set by the LOCK method,\nand indicates that the entity is locked.  User-agents should not\nuse other flags to duplicate the meaning of the EDIT and LOCK\nflags.\n<P>\n<B>3.3 LOCK<BR>\n</B>\n<P>\nThe &quot;LOCK&quot; method causes the Request-URI to have the\n&quot;PUT&quot; method denied for all users except the user requesting\nthe lock.  This method must be accompanied by a valid &quot;Authorization&quot;\nheader field.  If the Request-URI specifically names a version,\nthen the lock applies only to that version.  If the Request-URI\ndoes not name a version, then the lock applies to all versions.\n If a &quot;LOCK&quot; is attempted on all versions of the Request-URI\nand there is currently a lock on an individual version of the\nRequest-URI held by another user, a response with status code\n409 Conflict will be returned, with an entity body which states\nthat the Request-URI is already locked by another user(s), and\nnaming the other user(s). In the event a &quot;PUT&quot; is attempted\non a locked entity, a response with status code 409 Conflict will\nbe returned, with an entity body which states the Request-URI\nis locked.<BR>\n\n<P>\nThe &quot;LOCK&quot; method also causes the &quot;LOCK&quot; flag\nto be set on the Request-URI, however, the currently set flags\nare not returned in the entity-body.<BR>\n\n<P>\nWhen a LOCK is set, it will automatically be reset after one week,\nunless the &quot;Auto-Timeout&quot; header is present, in which\ncase the value it specifies will be employed.  An Auto-Timeout\nvalue of &quot;Never&quot; causes the lock to never automatically\nbe reset after a predetermined interval.  Re-locking the same\nRequest-URI is legal, and causes the timeout value to be updated.\n<BR>\n\n<P>\nThe LOCK method may also employ the new &quot;If-Not-Modified-Since&quot;\nheader field to specify that the lock will occur only if the entity\nhas not been modified since the time specified in this field.\n This ensures that a user does not take out a lock on an entity\nwhich has changes since they retrieved it.  Typically, the time\nspecified in the &quot;If-Not-Modified-Since&quot; field is the\ntime of the most recent retrieval of the entity being locked.\n<P>\n<B>3.4 UNLOCK</B>\n<P>\nThe &quot;UNLOCK&quot; method releases an existing lock, and clears\nthe LOCK flag on the Request-URI, and must be accompanied by a\nvalid &quot;Authorization&quot; field.  If the Request-URI does\nnot have a lock set by the requesting user, or if there is a lock\ncurrently held by another user, a response with status code 409\nConflict will be returned, with an entity body which explains\nthe cause of the conflict.\n<P>\n<B>3.5 USE<BR>\n</B>\n<P>\nThe &quot;USE&quot; method causes the server to always employ\nthe specified version of the Request-URI when the Request-URI\nis employed in a method without stating an explicit version. \nThis method allows a preferred version of an entity to be returned\nby the server in response to a GET or HEAD method.   It also allows\nthe version of a directory (container entity) to be prespecified\nfor all methods.<BR>\n\n<P>\n<B>4.0 Configurations<BR>\n</B>\n<P>\nBrowsing within a collection of entities (such as an older version\nof program documentation) may be accomplished using a configuration\nfile.  A configuration file contains a list of URI's (without\na version explicitly specified), and a corresponding URI with\nthe version specified.  The configuration file is used by the\nuser-agent as a filter: if a GET or HEAD method call is made against\none of the URI's without the version explicitly specified from\nthe active configuration file, the user-agent will substitute\nthe URI with the version explicitly stated. The configuration\nfile also contains an entry point designator, which specifies\na member of the configuration to be loaded after the configuration\nitself has finished loading (this is analogous to loading a description\nof a book, then loading the contents of the first chapter for\ndisplay).<BR>\n\n<P>\nNavigation within a configuration starts when the user-agent loads\na configuration file (MIME type: text/config) -- the user agent\nparses the file, determines the entry point URI, performs a GET\non it, then immediately starts using the configuration as a filter\nuntil the next configuration file is loaded, at which point only\nthe new configuration is active.\n<P>\n<B>4.1 Description of text/config type<BR>\n</B>\n<P>\nThe text/config (configuration file) type is just a simple mapping\nbetween URI's.  This basic wrapping information has been augmented\nwith HTML formatting codes so that the file can be displayed by\na user-agent which does understand the text/config type.  This\nallows limited browsing capability by using the configuration\nfile as a menu.<BR>\n\n<P>\nConfigFile = HTML-DTD\n<P>\n  HTML-Head\n<P>\n  Config-Banner\n<P>\n  Config-Entry-Point\n<P>\n  *(Config-Item)\n<P>\n  HTML-End<BR>\n\n<P>\nThe detailed BNF elaboration is TBD.<BR>\n\n<P>\nAn example configuration file is:</P>\n\n<CODE>\n&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;\n<BR>\n\n<P>\n&lt;HEAD&gt;\n<P>\n&lt;TITLE&gt;Configuration File: <I>name of configuration file</I>&lt;/TITLE&gt;\n<P>\n&lt;/HEAD&gt;<BR>\n\n<P>\n&lt;BODY&gt;\n<P>\n&lt;H3&gt;Configuration File<I>: name of configuration file</I>&lt;/H3&gt;\n<BR>\n\n<P>\n&lt;! Entry-point: http://www.ics.uci.edu/chimera/docs/intro.html;v=1.0\n&gt;<BR>\n<BR>\n<BR>\n<P>\n&lt;! http://www.ics.uci.edu/chimera/docs/intro.html &gt;\n<P>\n&lt;A HREF=&quot;http://www.ics.uci.edu/chimera/docs/intro.html;v=1.0&quot;&gt;\n<P>\nhttp://www.ics.uci.edu/chimera/docs/intro.html;v=1.0&lt;/A&gt;\n<BR>\n<BR>\n<BR>\n<P>\n&lt;! http://www.ics.uci.edu/chimera/docs/chapter1.html &gt;\n<P>\n&lt;A HREF=&quot;http://www.ics.uci.edu/chimera/docs/chapter1.html;v=1.4&quot;&gt;\n<P>\nhttp://www.ics.uci.edu/chimera/docs/chapter1.html;v=1.4&lt;/A&gt;\n<BR>\n</CODE>\n\n<P>\n...<BR>\n\n<P>\n&lt;/BODY&gt;<BR>\n\n<P>\n<B>5.0 Derivations File<BR>\n</B>\n<P>\nA TBD description of the file format which can be used to create\na history view of the entity.<BR>\n\n<P>\n<B>Appendix A  CVS Style Use Example<BR>\n</B>\n<P>\nAppendix A contains a description of an example use of the methods\ndescribed in this document for implementing the CVS-style of versioning\n(merge-based).<BR>\n\n<P>\nThe user starts by browsing through a series of pages.  Eventually\nthey find one they want to begin editing.</P>\n\n<TABLE BORDER=0 CELLPADDING=2>\n\n<TR>\n\n<TD>GET <I>entity</I> </TD><TD><P>Retrieves contents of page to be modified.</P></TD>\n</TR>\n<TR>\n<TD>FLAG <I>entity</I> (Flag-Option: SET EDIT) </TD><TD>\nNotifies server that editing is taking place.\nThe user agent receives back a list of flags already set on this\nentity, and notifies the user that they are entering a parallel\nwork situation if the EDIT flag is already set. If the LOCK\nflag is set, the user is informed of the LOCK (and they may\noptionally proceed at their own risk, knowing they have \nto coordinate the release of the lock before they can save\ntheir changes).</TD>\n</TR>\n</TABLE>\n\n<P>\nThe user now enters an &quot;edit-save-check&quot; cycle where\nthey perform their work, save it, then check that it actually\nlooks correct using a browser.  There are several possibilities\nfor where this work can be saved.  One option is to the user's\nlocal disk.  Another is to perform a PUT to a scratchpad area\non the HTTP server.</P>\n\n<P>\nIn the case the user decides to stop editing, the user-agent sends\na FLAG entity (Flag-Option: CLEAR EDIT), and performs a DELETE\nof all working copies on the server.</P>\n\n<P>\nWhen the user has finished editing and wants to do a final save\nof their changes, the user agent performs a:</P>\n\n<TABLE BORDER=0 CELLPADDING=2>\n\n<TR>\n<TD>\nPUT <I>new-entity-version</I> </TD><TD><P>Save the contents to the server\n</P></TD></TR>\n<TR>\n<TD>FLAG <I>entity </I> (Flag-Option: CLEAR EDIT)</TD><TD>\n<P>Inform the server that this user is not performing any more editing.\nThe user-agent checks the flag settings on this entity to see\nif merging is necessary. (Ed: I think we may need to look at derivation\ninformation to fully determine if merging is necessary.)</P></TD>\n</TR>\n</TABLE>\n\n<P>\nPerform merge, if needed.</P>\n\n<P>\n<B>Appendix B  RCS Style Use Example<BR>\n</B>\n<P>\nAppendix B contains a description of an example use of the methods\ndescribed in this document for implementing the RCS-style of versioning\n(lock-based).<BR>\n\n<P>\nThe user starts by browsing through a series of pages.  Eventually\nthey find one they want to begin editing.<BR>\n\n<TABLE BORDER=0 CELLPADDING=2>\n<TR>\n<TD>GET <I>entity</I> </TD><TD><P>Retrieval of the entity to\nbe edited </P></TD></TR>\n<TR>\n<TD>FLAG <I>entity</I> (Flag-Option: QUERY) </TD>\n<TD>Retrieve all flags currently set on the entity.\nThis allows the user-agent to check for other users editing\nthis entity using non-locking styles, and for the existence of\nactive locks on the entity.</TD>\n</TABLE>\n\n<P>\nAssuming there are no locks, or flags set...</P>\n\n<P>\nLOCK <I>entity</I>  (If-Not-Mofified-Since: <I>time of GET of\nentity</I>)<BR>\n\n<P>\nAssuming the lock was successful, the user now begins an edit-save-check\ncycle.</P>\n\n<P>\nIf they decide to abort their work, the user-agent issues an UNLOCK\n<I>entity</I>, and a DELETE of all working copies stored on the\nHTTP server.</P>\n\n<P>\nIf the user decides to perform their final save:</P>\n\n<TABLE BORDER=0 CELLPADDING=2>\n\n<TR>\n<TD>PUT <I>new-entity-version</I> </TD>\n<TD>Save the final version of the entity </TD>\n</TR>\n\n<TR>\n<TD>UNLOCK <I>entity</I> </TD><TD>Release the lock </TD>\n</TR>\n\n</TABLE>\n\n<P>\n<B>Appendix C  Issues that still need to be addressed<BR>\n</B>\n<P>\nIssues which have not yet been addressed by this document are:\n<BR>\n\n<UL>\n<LI>Visibility control by the end-user\n<LI>Access control by the end-user\n<LI>others? ...\n</UL>\n\n</BODY>\n\n</HTML>\n\n", "encoding": "ascii"}