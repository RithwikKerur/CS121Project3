{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/Main.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Main entry point.\n//\n// Determines\n//\t\thow many points to generate\n//\t\twhich point set generator to use\n//\t\twhich algorithm to call on that point set\n//\t\twhich closest pair data structure to use in the algorithm\n//\n// Then puts them all together and times the results.\n// The primitive user interface is hopefully more portable than a Mac dialog.\n\n#define MAX_LINE_LENGTH 1024\t\t// how big to make buf for tty input?\n\n#include \"AllClosestPairs.h\"\t\t// find all implementations of closest pairs\n#include \"AllPointSets.h\"\t\t\t// find all point set generators\n#include \"AllAlgorithms.h\"\t\t\t// find all applications of closest pairs\n#include \"Error.h\"\n#include \"Random.h\"\n#include <time.h>\n#include <iostream.h>\n\nunsigned long gDistances = 0;\nunsigned long gPairs = 0;\nunsigned long gInsertions = 0;\nunsigned long gDeletions = 0;\ndouble gTotalTime = 0.0;\ndouble gTimeSquare = 0.0;\nint gDimension = 0;\n\nint gNegating = 0;\n\nclock_t clock_value;\n\nvoid StartTiming()\n{\n\tclock_value = clock();\n}\n\nvoid EndTiming()\n{\n\tclock_value = clock() - clock_value;\n\tdouble DoubleTime = (double) clock_value / (double) CLOCKS_PER_SEC;\n\tgTotalTime += DoubleTime;\n\tgTimeSquare += DoubleTime*DoubleTime;\n}\n\nvoid ReportOperationCounts()\n{\n\tcout << \"\\n\" << gInsertions << \" point insertions.\\n\"\n\t\t\t\t << gDeletions << \" point deletions.\\n\"\n\t\t\t\t << gDistances << \" distance computations.\\n\"\n\t\t\t\t << gPairs << \" closest pair computations.\\n\"\n\t\t\t\t << \"Total (wall clock) time: \"\n\t\t\t\t << (double) clock_value / (double) CLOCKS_PER_SEC << \"s.\\n\";\n}\n\nchar * NextWord()\n{\n\tstatic char buffer[MAX_LINE_LENGTH];\n\tcin >> buffer;\n\tif (!cin.good()) error(\"unexpected input termination\");\n\treturn buffer;\n}\n\nunsigned long ReadNum(const char * prompt)\n{\n\tcout << prompt;\n\tchar * s = NextWord();\n\tlong retval = 0;\n\twhile (s != 0 && *s != 0) {\n\t\tif (*s < '0' || *s > '9') {\n\t\t\tcout << \"Unrecognized number format.\\n\\n\";\n\t\t\treturn ReadNum(prompt);\t\t\t\n\t\t}\n\t\tretval = (retval * 10) + *s++ - '0';\n\t}\n\treturn retval;\n}\n\nunsigned long ReadDimension()\n{\n\twhile (gDimension == 0) gDimension = ReadNum(\"Dimension: \");\n\treturn gDimension;\n}\n\nPointSet * FindPointSet(unsigned long np)\n{\n\tstatic char c = 0;\n\tif (c == 0) {\n\t\tcout << \"\\nChoose a point set generation method.\\n\"\n\t\t\t << \"  1 = points in R^d, L1 metric\\n\"\n\t\t\t << \"  2 = points in R^d, (squared) L2 metric\\n\"\n\t\t\t << \"  d = points in R^d, dot product\\n\"\n\t\t\t << \"  i = points in R^d, L(inf) metric\\n\"\n\t\t\t << \"  r = random distance matrix\\n\"\n\t\t\t << \"  s = points in generalized Sierpinski tetrahedron\\n\"\n\t\t\t << \"  t = two-adic non-archimedean metric\\n\"\n\t\t\t << \"Your choice: \";\n\t\tchar * s = NextWord();\n\t\tif (s != 0 && *s != 0 && s[1] == 0) c = s[0];\n\t}\n\tswitch(c) {\n\t\tcase '1':\n\t\t\treturn new VectorL1(np, ReadDimension());\n\n\t\tcase '2':\n\t\t\treturn new VectorL2(np, ReadDimension());\n\n\t\tcase 'd': case 'D':\n\t\t\treturn new VectorDot(np, ReadDimension());\n\n\t\tcase 'i': case 'I':\n\t\t\treturn new VectorLinf(np, ReadDimension());\n\n\t\tcase 'r': case 'R':\n\t\t\treturn new RandomDistance(np);\n\t\t\t\n\t\tcase 's': case 'S':\n\t\t\treturn new SierpinskiTetrahedron(np, ReadDimension());\n\n\t\tcase 't': case 'T':\n\t\t\treturn new TwoAdic(np);\n\n\t\tdefault:\n\t\t\tc = 0;\n\t\t\tcout << \"Unrecognized point set generation option.\\n\\n\";\n\t\t\treturn FindPointSet(np);\n\t}\n}\n\nClosestPairs * FindClosestPairs(unsigned long np, unsigned long mp, Distance & d)\n{\n\tstatic char c = 0;\n\tstatic unsigned long nconga;\n\tstatic int read_nconga = 0;\n\tif (c == 0) {\n\t\tcout << \"\\nChoose a closest pair data structure.\\n\"\n\t\t\t << \"  b = brute force\\n\"\n\t\t\t << \"  c = conga line\\n\"\n\t\t\t << \"  f = fastpair conga-neighbor hybrid\\n\"\n\t\t\t << \"  m = many-subset conga line\\n\"\n\t\t\t << \"  n = nearest neighbor heuristic\\n\"\n\t\t\t << \"  q = quadtree\\n\"\n\t\t\t << \"Your choice: \";\n\t\tchar * s = NextWord();\n\t\tif (s != 0 && *s != 0 && s[1] == 0) c = s[0];\n\t}\n\tswitch(c) {\n\t\tcase 'b': case 'B':\n\t\t\tStartTiming();\n\t\t\treturn new BruteForceCP(np, mp, d);\n\n\t\tcase 'c': case 'C':\n\t\t\tif (!read_nconga) {\n\t\t\t\tnconga = ReadNum(\"Number of subsets (zero for log_2(n)): \");\n\t\t\t\tread_nconga = 1;\n\t\t\t}\n\t\t\tStartTiming();\n\t\t\treturn new CongaLine(np, mp, d, nconga);\n\n\t\tcase 'f': case 'F':\n\t\t\tStartTiming();\n\t\t\treturn new FastPair(np, mp, d);\n\n\t\tcase 'm': case 'M':\n\t\t\tStartTiming();\n\t\t\treturn new MultiConga(np, mp, d);\n\n\t\tcase 'n': case 'N':\n\t\t\tStartTiming();\n\t\t\treturn new NeighborCP(np, mp, d);\n\n\t\tcase 'q': case 'Q':\n\t\t\tStartTiming();\n\t\t\treturn new QuadTreeCP(np, mp, d);\n\t\t\t\n\t\tdefault:\n\t\t\tcout << \"Unrecognized data structure option.\\n\\n\";\n\t\t\tc = 0;\n\t\t\treturn FindClosestPairs(np, mp, d);\n\t}\n}\n\nCPApplication * FindApplication()\n{\n\tstatic char c = 0;\n\tif (c == 0) {\n\t\tcout << \"\\nChoose a closest pair application.\\n\"\n\t\t\t << \"  g = greedy matching\\n\"\n\t\t\t << \"  h = hierarchical clustering\\n\"\n\t\t\t << \"  i = cheapest insertion tsp\\n\"\n\t\t\t << \"  m = multifragment tsp\\n\"\n\t\t\t << \"  r = ray-intersection diagram\\n\"\n\t\t\t << \"Use a minus sign (e.g. \\\"-g\\\") for maximization versions\\n\"\n\t\t\t << \"Your choice: \";\n\t\tchar * s = NextWord();\n\t\tif (s != 0 && *s == '-') {\n\t\t\tgNegating = 1;\n\t\t\ts++;\n\t\t} else gNegating = 0;\n\t\tif (s != 0 && *s != 0 && s[1] == 0) c = s[0];\n\t}\n\tswitch(c) {\n\t\tcase 'g': case 'G':\n\t\t\treturn GreedyMatching;\n\n\t\tcase 'h': case 'H':\n\t\t\treturn Cluster;\n\n\t\tcase 'i': case 'I':\n\t\t\treturn CheapestInsertion;\n\n\t\tcase 'm': case 'M':\n\t\t\treturn MultiFragment;\n\t\t\t\n\t\tcase 'r': case 'R':\n\t\t\treturn RayDiagram;\n\n\t\tdefault:\n\t\t\tcout << \"Unrecognized application option.\\n\\n\";\n\t\t\tc = 0;\n\t\t\treturn FindApplication();\n\t}\n}\n\nvoid main()\n{\n\tunsigned long seed = ReadNum(\"Random number seed: \");\n\tSeedRandom(seed);\n\tint num_iters = ReadNum(\"Number of iterations: \");\n\tunsigned long num_pts = ReadNum(\"Number of points: \");\n\twhile (num_pts == 0) {\n\t\tcout << \"Nonzero number of points expected.\\n\\n\";\n\t\tnum_pts = ReadNum(\"Number of points: \");\n\t}\n\tfor (int i = 0; i < num_iters; i++) {\n\t\tgInsertions = gDeletions = gPairs = gDistances = 0;\n\t\tCPApplication * app = FindApplication();\n\n\t\tPointSet * ps;\n\t\tif (app == RayDiagram) ps = new Tron(num_pts);\n\t\telse ps = FindPointSet(num_pts);\n\t\tif (gNegating) ps = new Negation(num_pts, *ps);\n\t\tif (app == MultiFragment) ps = new MultiFragmentDistance(num_pts, *ps);\n\t\telse if (app == CheapestInsertion)\n\t\t\tps = new CheapestInsDistance(num_pts, *ps);\n\n\t\tClosestPairs * p = FindClosestPairs(num_pts, num_pts, *ps);\n\t\t\n\t\t// do it!\n\t\tdouble total = (*app)(num_pts, *ps, *p);\n\t\tif (gNegating) total = -total;\n\t\tEndTiming();\n\t\tReportOperationCounts();\n\t\tcout << \"Total weight = \" << total << \".\\n\";\n\t\t\n\t\tdelete p;\n\t\tdelete ps;\n\t}\n\tif (num_iters > 1)\n\t\tcout << \"\\nAverage time = \" << gTotalTime / num_iters << \"s.\\n\"\n\t\t\t << \"Standard deviation = \"\n\t\t\t << sqrt((gTimeSquare - (gTotalTime*gTotalTime)/num_iters)\n\t\t\t \t\t / ((double) (num_iters - 1))) << \"s.\\n\";\n}", "encoding": "ascii"}