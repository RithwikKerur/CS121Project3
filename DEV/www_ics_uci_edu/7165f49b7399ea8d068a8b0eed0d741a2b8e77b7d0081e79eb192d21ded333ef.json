{"url": "https://www.ics.uci.edu/~ejw/authoring/versioning/dt_oct98/minutes.txt", "content": "WEBDAV\nVersioning and Variant Authoring Design Team\nOctober 1-2, 1998\nFileNet, Costa Mesa, California\n\n\nA meeting of the WebDAV Versioning and Variant Authoring Design Team meeting\nwas held October 1-2, 1998 at the offices of FileNet, in Costa Mesa,\nCalifornia.  In attendance were Jim Amsden, Alan Babich, Geoff Clemm, Bruce\nCragun, David Durand, Chuck Fay (1st day), Chris Kaler, Brad Sergeant, John\nStracke, Jim Whitehead.  Jim Whitehead chaired the meeting and recorded\nminutes.\n\nThe agenda for the meeting was:\n\nOctober 1:\n  * Discussion of versioning goals document, led by John Stracke (9AM - 5PM)\nOctober 2:\n  * Discussion of versioning protocol document, led by Chris Kaler (9AM -\n1PM)\n  * Discussion of variant authoring goals and protocol (1:30PM - 4:00PM)\n\nMany participants had early plane connections, and were not present for the\nvariant authoring discussion.  Alan Babich, David Durand, John Stracke, and\nJim Whitehead were the only participants in this discussion.\n\n** Day 1 **\n\nDiscussion of RFC 2291.\n\nSince the versioning goals document was written as a set of changes to the\nversioning-specific sections of RFC 2291, \"Requirements for a Distributed\nAuthoring and Versioning Protocol for the World Wide Web\", the meeting began\nwith a review of RFC 2291 to verify that these goals are still relevant.\n\nOne area of RFC 2291 which caused disagreement was the sentence in section\n5.9.1.3, which states, \"It is also possible for a single resource to\nparticipate in multiple version graphs.\"  The Design Team argeed there\nshould only be one version graph per versioned resource.  However, since\nthere are some scenarios (e.g. a subset of the graph, such as published\nrevisions, or only the last N revisions) where a user might only be given\nvisibility over part of the version graph, the capability to have multiple\nviews of a version graph was viewed as desirable by most, but not all\nparticipants.\n\nThe \"client proposes, server disposes\" model of a client submitting a\nversion identifier, and the server then stating whether it used the\nsubmitted id, as described in section 5.9.2.8 of RFC 2291, met with near\nuniversal disagreement from the Design Team. The Design Team agreed to\nstrike the first two sentences of 5.9.2.8.\n\nBut, since RFC 2291 is already a published RFC, and hence difficult to\nmodify, and since it is difficult to fully grasp the versioning goals since\nthey are located in two different documents at present, the Design Team\nagreed to merge the versioning section of RFC 2291 into the next revision of\nthe versioning goals document.  The versioning goals document will clearly\nstate which sections of RFC 2291 it is superceding.\n\nAt the end of the discussion of RFC 2291, there was some discussion on\nvariants, and whether the \"is-variant-of\" relationship should be a member of\nthe version graph, as is the case in draft-whitehead-versioning-00.  The\nDesign Team agreed that the version graph should not contain \"is-variant-of\"\nrelationships, and should concern itself only with versioning relationships.\nFurthermore, the Design Team agreed to separate variant authoring from\nversioning, and have a separate goals and protocol document for variant\nauthoring.\n\nDiscussion of Versioning Goals Document:\n\nThe first item of discussion in the versioning goals document was the\ndefinitions section. The Design Team agreed to change the term \"abstract\nversioned resource\" to \"versioned resource\". Brad, Geoff, and Chris took an\naction item to develop definitions of configuration set, configuration,\nworkspace, and change set.\n\nAfter discussing terminology, the Design Team focused on the goals.  After\nsome discussion, the Design Team agreed to drop goal 1, \"It must be possible\nfor the protocol defined to map reasonably well to most existing version\nrepositories.\"  While nobody on the design team disagreed with this goal, it\nwas felt that this was not a direct, functional goal, and that the goals\ndocument should be concerned with functional goals only.\n\nThe design team agreed with goal 2, \"Every revision of an abstract versioned\nresource must itself be a resource, with its own URI.\"\n\nThere was agreement on goals 3 (\"It should be possible for a client to\nspecify meaningful labels to apply to individual revisions, and to change\nthe revision to which a label refers.\"), with minor wordsmithing needed.\n\nThe Design Team agreed with goal 4 (\"The labels and revision IDs within a\nVgraph are names in a common namespace, in which each name must be\nunique.\"), except to note that the labels and revision IDs don't necessarily\nneed to be in the same namespace -- there can be a separate namespace for\nversion ids and labels.\n\nThere was significant debate over goal 5, \"Given a URI to the version graph,\nand an ID or label for a revision, it must be possible for a client to\nconstruct a URI which refers to that revision.\"  While the participants\nacknowledged that having correct operation of relative URIs for the current,\nand previous revisions of a versioned resource was a desirable goal, goal 5\nsounded too much like a solution, rather than a statement of a goal.\nFurthermore, there was discussion that since this approach uses URL string\noperations, it might encounter resistance within the working group.\n\n*** Ed note: I have no notes from discussion of goal 6.\n\nThere was agreement on goal 7, (\"The CM protocol must be an optional\nextension to the base versioning protocol\").\n\nDuring discussion of goal 8, (\"Revisions are immutable: once a revision has\nbeen checked into the repository, the revision can never be deleted; and its\ncontents and dead properties can never be changed.\") there was discussion\nabout separating the concepts of deletion and mutability.  Administrators\noften decide to delete older portions of revision trees to conserve space,\nand hence though the revisions are immutable once they're checked-in, they\nmay eventually be deleted.\n\nMutability of properties was also discussed.  The Design Team determined\nthat there are two types of properties, \"mutable\", can be changed after\ncheck-in, and \"immutible\", cannot be modified after check-in. These\ncategories are not guaranteed to correspond to \"live\" and \"dead\" properties.\nThere was general agreement that an access control property would be\nmutible. However, some live properties, like \"getcontentlength\", would be\nexpected to remain immutible, despite being live.  This implies there are\nsome properties which are \"bound\" in some sense to the body of the resource,\nand others which are not.\n\nBranching was discussed.  Some Design Team members stated that document\nmanagement systems typically do not presently support branching, and hence\nwould not be eager to implement branching.  As a result, the Design Team\nagreed to make branching an optional feature, but one that has full support\nwithin the protocol, since CM repositories find branching to be a vital,\nnon-optional feature.\n\nAfter discussing the items in the initial goals document, Jim Amsden brought\nup a list of goals which he felt should be in the goals document.  Jim\nAmsden agreed to send John Stracke a list of these goals for inclusion in\nthe next rev. of the goals.\n\nIn a separate discussion, the Design Team agreed to not have predecessor\nlinks come in from outside the versioned resource.\n\nJohn Stracke agreed to work towards having a new revision of the goals\ndocument by October 9.\n\nBefore adjourning for the day, there was discussion of the when the next\nDesign Team meeting should be held.  It was tentatively agreed to hold the\nnext meeting December 2-3, hosted by InterSolv.\n\n\n** Day 2 **\n\nChris Kaler led a discussion of his draft which merged together\ndraft-whitehead-webdav-versioning and draft-kaler-webdav-versioning, the\nSeptember 28, 1998 revision of \"Versioning and Variant Extensions to\nWebDAV.\"  Chris used a small set of slides to lead the discussion.  These\nslides are available on the Web at:\n\nhttp://www.ics.uci.edu/pub/ietf/webdav/versioning/dt_oct98/kaler/\n\nThere was discussion of support for downlevel clients (automatic\nversioning).  One view on this capability was that it definitely adds\ncomplexity to the protocol, and this might make automatic versioning not\nworthwhile.  There was agreement to continue investigating provision of\nversioning capabilities for downlevel clients.  However, this capability\nshould be re-examined once it is fully specified to ensure that the tradeoff\nbetween automatic versioning capability and added complexity is deemed\nworthwhile.\n\nNext, there was discussion on having an entry point in the HTTP URL\nnamespace which is mapped to a particular member of a versioned resource.\nSome viewpoints expressed were:\n - We should use existing referential members for this capability.\n - The semantics of referential members don't meet our needs to have a\nreference which can track a label, or point to the latest member of a line\nof descent.\n - This sounds like a Vportal.\n - There are scalability problems with the Vportal approach across a\nconfiguration, if each Vportal can individually point to a different part of\neach version graph (i.e., if some point to label X, others point to label Y,\nothers point to the latest on a line of descent, etc.)\n - A Vportal and a single element configuration sound like identical\nmechanisms to me.  Do we really want both?\n - But, what about keeping the separation between the versioning layer and\nthe configuration management layer?\n - It was noted that direct references might work if it was possible to set\nproperties on them.\nThere was no resolution to this discussion.\n\nGeoff Clemm agreed to write up a proposal for how the mapped version\nnamespace should be arranged.\n\nThere was a discussion on retrieving the version history via PROPFIND.  No\nagreement was recorded.\n\nThe Design Team agreed that the CHECKINOUT method needs to be broken up into\nseveral methods, to reflect a better separation of concerns.  At the least,\nmethods for CHECKIN, CHECKOUT, UNCHECKOUT all need to exist, and another\nmethod may need to be created to request enumerations of all checkouts\nactive on a versioned resource.\n\nThere was discussion on the semantics of checkout.  Some issues which were\nidentified are:\n - locking/reservation of a line of descent\n - the ability to specify a line of descent on checkout\n - auto-creation of a line of descent when branching occurs\n\nThe Design Team agreed that CHECKOUT needs the following parameters:\n - do not branch\n - force branch\n - creation of a branch, if it occurs, is OK\nThere was agreement that no MKBRANCH method is needed, that creation of a\nbranch is implicit in CHECKOUT.\n\nChris Kaler took an action item to start a thread on the mailing list\nconcerning the semantics of checkout, and also on how the semantics of lock\nand checkout/checkin interact.\n\nGeoff Clemm will collect the ClearCase experience with checkout and mail it\nto the list.\n\nMerging capability was discussed.  One approach discussed was having PUT\npass the version it is derived from, and hence at checkin time the server\nwill know which resource is the predecessor to the resource being\nchecked-in.  Another approach was to have a MERGE method, which could merge\ntwo (or more) resources. Another alternative was to allow PROPPATCH on a\nlive history property, similar to the semantics of the GRAPHOP proposal.\nThere was a long discussion on whether it should be possible to, after\ncheckin, delete merge arcs.  Some participants noted that, in practise,\npeople make mistakes and want to back-out their merge.  Others noted that it\nis possible to recover from a merge by creating new nodes and moving\nforward, but still leaving a record of the merge.  No agreement was reached\non this issue.\n\nThe Design Team agreed to create a separate, public, archived, mailing list\nexclusively for the discussion of versioning issues.  Jim Whitehead took an\naction item to create this list.\n\nThe Design Team agreed to have one more revision of the versioning protocol\ndocument before submitting it as the -00 revision of\ndraft-ietf-webdav-versioning.  Chris Kaler agreed to create this revision by\nNov. 2.\n\nAutomatic mapping of a configuration to HTTP URL space was discussed.  There\nwas general agreement that this type of capability should be included in the\nprotocol.  There was agreement in favor of using MKCOL to create this\nmapping.\nGeoff agreed to write up a proposal on automatic mapping of a configuration\nto HTTP URL space.\n\nThe Design Team agreed that the \"Base-Version\" header should be removed\nunless it is shown to be absolutely necessary.\n\nThe Design Team agreed to move section 3.2.5 capability (\"Checkin-Token --\nClients may desire the ability to track a set of changes as a unit.\") into\nthe section on configuration management.  A participant noted that this\ncapability is needed for change sets.\n\nOne participant noted that there are i18n problems with the current\nspecification of the Comments header, since there are no provisions for\nlabeling the charset or language, or for handling multi-octet character\nsets.\n\nThere was a discussion of the semantics of collections and containment.\n\nJim Amsden will create a document on how to describe a version history using\nXML.  He will consider RDF during this activity.\n\nJim Amsden also volunteered to edit the goals document during John Stracke's\nsabbatical.\n\nAt this point in the meeting, several participants left.  Alan Babich, David\nDurand, John Stracke, and Jim Whitehead continued on, discussing variants.\n\nVariants.\n\nThe Design Team began with a discussion of goals and definitions.\n\nThere was discussion of the terms \"rendition\", or \"internal variant\", and\n\"external variant\". An internal variant, or rendition, shares the properties\nof the resource, and is typically mechanically derived.  An example is a PDF\nrendition of a Word file.  In both cases, the title will be the same,\nalthough the length and content type are not.  In contrast, an external\nvariant is one where a human is typically involved in the creation of the\nresource, such as a translation of a Web page from German to French.  It was\nnoted that while some types of variants are typically thought of as being\nmechanically derived, such as different formats of a word processing\ndocument, there may be exceptions where their creation is human-directed.\nNo broad assumptions about which kinds of variant-creating transformations\nare always mechanically performed can be made, or should be embedded into\nthe protocol.\n\nGoals that emerged during the discussion are:\n\n* It should be possible to discover what kinds of mechanically derived\nvariants can be provided by the server, what kinds must be provided by the\nclient (or else that type of variant will not be present), and what kinds\nmay be provided by the client (e.g., where it is possible to manually\noverride a server-provided mechanical transformation).\n\n* It should be possible to stop automatic server generation of specified\nclasses of variants.\n\n* It should be possible to discover which variants can be read, and which\nones can be written.\n\n* A PUT on a \"variant control resource\" (i.e., a resource where, by\nsubmitting a GET with Accept* headers, content negotiation takes place),\nshould \"do the right redirect\", and store the body under the correct variant\nresource.\n\n* A PUT of a multipart/alternatives body to a variant control point should\ncause the server to burst out the multiple parts and store them at the\ncorrect variant resource.\n\n* It should be possible to set properties on variants independently.  As a\nconsequence, each variant has its own URI.\n\n* It should be possible to delete individual variants, at a specific point\nin (media-type, language, encoding, transfer) space.\n\n* It should be possible to request the server to package up all variants\ninto a multipart/alternatives for transfer to the client.\n\nThere was some discussion over whether the HTTP specification implies there\nis a single \"variant control point\" where content negotiation takes place,\nor whether every variant exists in a peer-to-peer relationship with every\nother variant, and content negotiation can take place at any variant.  There\nwas some agreement that there must be at least one control point, but there\ncan be many control points.  Control points don't have to be the URL where a\nspecific variant exists.\n\nThere was some discussion on whether it should be possible to perform\nvariant authoring on a collection.  There was agreement that this is\ndesirable, due to the \"home page authoring\" scenario, where a home page\nexists in multiple variants (languages).\n\nThere was a long discussion on how to reduce the combinatoric explosion\nwhich occurs when trying to enumerate all of the possible static and\nmechanically derived variants of a resource during discovery.  One technique\nwas to use HEAD with Accept* headers to discover the URL which can be\nauthored for that specific point in variant space.  A Not-Authorable header\ncould indicate the variant is not human-authorable.\n\nThere was some sentiment that variant authoring should be an optional set of\nfeatures (i.e., support of versioning would not necessarily imply support\nfor variant authoring), but no agreement on this issue was recorded.\n\nDavid Durand volunteered to edit the variant goals document.\nJohn Stracke volunteered, time permitting, to edit the variant authoring\nprotocol document.\n\n*** Meeting Adjourned ***\n", "encoding": "ascii"}