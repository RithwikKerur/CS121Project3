{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/TuplesAndLists/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Python Background Notes: Tuples and Lists</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Python Background Notes: Tuples and Lists</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The need for data structures</p>\r\n\r\n<p>A programming language needs <i>control structures</i>, which provide a way to organize the flow of control within a program &mdash; determining which statements happen in which sequence.  So far, we've seen a couple of those in Python: the <b>if</b> statement and two kinds of loops, along with the ability to both write and call functions.  These tools help to us to keep our code organized in a way that allows us to solve problems more easily, and also to read and understand those solutions more easily afterward.</p>\r\n\r\n<p>Similarly, we also have a need to organize data.  You can't get very far writing programs without <i>data structures</i>, which allow us to store and organize collections of many data items, instead of just a single one.  We've seen a couple of types of objects so far that could be classified as data structures:</p>\r\n\r\n<ul>\r\n  <li>A string is a collection of characters.  Some strings have no characters, some have a few, and some have many.  Because different strings have different numbers of characters, there's a good chance that a string really does actualy have to store the characters (i.e., longer strings require more memory than smaller ones).</li>\r\n  <li>A range acts as a collection of integers, arranged in a particular order.  Unlike strings, ranges can be calculated on the fly, because their values follow a definitive pattern, such as \"the numbers beginning with 0, ending with 10, in a step size of 2.\"  Nonetheless, we can treat it like a data structure, by indexing into it, by iterating through it with a <b>for</b> loop, and so on.</li>\r\n</ul>\r\n\r\n<p>But what if we need to arrange a kind of data that doesn't fit one of these two patterns?  Not everything can (or should) be reasonably stored and manipulated as a collection of characters.  And ranges are actually pretty limited &mdash; there's no range that contains the numbers <b>1</b>, <b>3</b>, <b>9</b>, and <b>27</b>, or that contains numbers that are in a seemingly-random order, like <b>4</b>, <b>2</b>, <b>6</b>, <b>5</b>, and <b>9</b>.  Once created, strings and ranges can't be modified; you can only build new ones that have different characteristics.  So there will certainly be problems in which we need to organize data in ways that neither strings nor ranges can do.  For that reason, we'll need more tools; luckily, Python has additional tools built in.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Tuples</p>\r\n\r\n<p>A <i>tuple</i> is a data structure that contains an immutable sequence of values, whose types can be any mixture you'd like.  When you would use a tuple is when you have a sequence where you know <i>before the program runs</i> exactly how many values you need, and <i>before the program runs</i> you can understand the meaning of each of them.  Tuples let you bring together related values and store them in a single object, but, conceptually, provide little else.  Still, sometimes that's exactly the problem you have, so it's quite useful to have a tool that's focused on solving it.</p>\r\n\r\n<p>One example is if you were storing information about points in two-dimensional space (i.e., Cartesian coordinates, as in algebra).  Each point in two-dimensional space is described by an <i>x</i>-coordinate and a <i>y</i>-coordinate.  No matter what point you're talking about, both coordinates always need to be there, and they always have the same meaning; by convention, we generally write the <i>x</i>-coordinate first, then the <i>y</i>-coordinate, so we're always able to read them back later and make sense out of them.</p>\r\n\r\n<p>If we wanted to store a point's coordinates, we could certainly use two variables to do it, but there would be design value in bringing them together.  A point, after all, is a kind of object that we might like to be able to store in a single variable, pass as a single argument to a function, or return as the result of a function.  A tuple provides one way to do all of these things.</p>\r\n\r\n<p>Creating a tuple is as simple as separating multiple expressions with commas, with or without parentheses surrounding them</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>1, 2</b>\r\n(1, 2)\r\n&gt;&gt;&gt; <b>('Boo', 11, 3.5)</b>\r\n('Boo', 11, 3.5)\r\n</pre></blockquote>\r\n\r\n<p>The parentheses are generally optional; it's the commas that make these into tuples.  (For the most part, I tend to like to include the parentheses, because I find that it sets tuples apart visually from other things.)  However, you do sometimes need the commas for the purposes of disambiguating syntax, because commas have other meanings in Python, too.  For example, commas are used to separate the arguments you pass to a function when you call it.  This leads to the following interesting (and perhaps surprising) result, when you try to determine the type of <b>1, 2</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>type(1, 2)</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;\r\n    type(1, 2)\r\nTypeError: type() takes 1 or 3 arguments\r\n</pre></blockquote>\r\n\r\n<p>The error message indicates that the built-in <b>type()</b> function can only be called with either one argument or three arguments.  (So far, we've only seen it used with one argument; the three-argument version is wildly different and is a very long story for another day.)  If what we want to do is determine the type of a single argument that is a tuple, we'll need to surround that tuple with parentheses, so Python knows that we don't want the comma to mean that we're passing two arguments to the function.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>type((1, 2))</b>\r\n&lt;class 'tuple'&gt;\r\n</pre></blockquote>\r\n\r\n<p>Tuples have a length that is determined at the time you create them, by virtue of the number of expressions you combined together with commas; once established, that length can't change.  The tuple <b>('a', 'b', 'c')</b> has a length of 3 and it always will.  As with other kinds of objects that have lengths, the built-in <b>len</b> function can tell you the length of a tuple.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>len((5, 6))</b>\r\n2\r\n</pre></blockquote>\r\n\r\n<p>Additionally, the values within a tuple can't change, either; once a collection of objects is combined into a tuple, that tuple will only ever contain those objects.</p>\r\n\r\n<p>Tuples can be indexed, just like ranges and strings can.  The elements of a tuple each have an index; they're numbered consecutively starting at 0.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>point = (5, 6)</b>\r\n&gt;&gt;&gt; <b>point[0]</b>\r\n5\r\n&gt;&gt;&gt; <b>point[1]</b>\r\n6\r\n</pre></blockquote>\r\n\r\n<p>Of course, because the values inside of tuples can't change, you won't be able to assign to these indices.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>point[1] = 3</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#7&gt;\", line 1, in &lt;module&gt;\r\n    point[1] = 3\r\nTypeError: 'tuple' object does not support item assignment\r\n</pre></blockquote>\r\n\r\n<p>Indexing into a tuple can be useful, but you may find that you'll be much better off introducing names for the elements, instead of just using indices everywhere.  Remembering things like \"Index 0 means the x-coordinate, while index 1 means the y-coordinate\" is just one more cognitive burden to carry; when programs get large, hundreds of little details like that start to add up, so we should be motivated to find a way for the meaning of our program to be self-evident.</p>\r\n\r\n<p class=\"subtitle\">Sequence assignment</p>\r\n\r\n<p>Python's assignment statement is more powerful than we've seen thus far.  Not only can it be used to assign a value into a single variable; it can additionally be used to to assign values into multiple variables.  <i>Sequence assignment</i> is the name given to this technique.</p>\r\n\r\n<p>Sequence assignment means to take a value that can be treated as a sequence, then \"unpack\" it and assign its elements to multiple variables.  This can be done with any kind of object in Python that can be treated as a sequence &mdash; strings, for example, also qualify &mdash; but the trick is that you have to have the correct number of variables on the left-hand side of the assignment.  For example, if there are two elements in the sequence on the right, you'd need exactly two variables on the left.  So, sequence assignment tends to be more useful with tuples than with other kinds of sequences, because tuples generally have a length that's encoded directly into your program, and that size can't change once it's been established.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>point = (5, 6)</b>\r\n&gt;&gt;&gt; <b>x, y = point</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n5\r\n&gt;&gt;&gt; <b>y</b>\r\n6\r\n</pre></blockquote>\r\n\r\n<p>Again, if the number of variables doesn't match the number of elements in the sequence, you'll see an error message.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x, y, z = point</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt;\r\n    x, y, z = point\r\nValueError: not enough values to unpack (expected 3, got 2)\r\n</pre></blockquote>\r\n\r\n<p>You can also create a tuple on the right-hand side of an assignment, then use it to sequence-assign multiple variables on the left-hand side, which leads to some interesting techniques, such as the following technique for swapping the values of two variables.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a = 12</b>\r\n&gt;&gt;&gt; <b>b = 9</b>\r\n&gt;&gt;&gt; <b>a, b = b, a</b>\r\n&gt;&gt;&gt; <b>a</b>\r\n9\r\n&gt;&gt;&gt; <b>b</b>\r\n12\r\n</pre></blockquote>\r\n\r\n<p>As mentioned above, you can use sequence assignment with objects of sequence types other than tuples, such as strings.  You're mostly going to want to avoid this technique, mainly because it's a dangerous one (i.e., you don't necessarily know how long a string will be if, for example, it originated from user input); if the number of variables on the left-hand side of the sequence assignment is different from the length of the string, you'll see an error message.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>name = 'Boo'</b>\r\n&gt;&gt;&gt; <b>a, b, c = name</b>\r\n&gt;&gt;&gt; <b>a</b>\r\n'B'\r\n&gt;&gt;&gt; <b>b</b>\r\n'o'\r\n&gt;&gt;&gt; <b>c</b>\r\n'o'\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Lists</p>\r\n\r\n<p>A <i>list</i> in Python is a sequence of objects that you expect may change over its lifetime.  New elements can be added, existing elements can be removed or rearranged, and so on.  Unlike tuples, you won't have to know the length of a list before the program runs, though you also won't be able to count on knowing what its length is.</p>\r\n\r\n<p>Syntactically, we write a literal list in Python using a sequence of expressions separated by commas and surrounded by square brackets.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x = [1, 2, 3, 4]</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 2, 3, 4]\r\n&gt;&gt;&gt; <b>type(x)</b>\r\n&lt;class 'list'&gt;\r\n</pre></blockquote>\r\n\r\n<p>Like many other objects that contain a collection of other objects within them, lists have a length, which is defined as the number of objects stored in the list; the built-in function <b>len</b> can tell us that length.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>len(x)</b>\r\n4\r\n</pre></blockquote>\r\n\r\n<p>Of course, lists can be empty, too.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>nothing = []</b>\r\n&gt;&gt;&gt; <b>len(nothing)</b>\r\n0\r\n</pre></blockquote>\r\n\r\n<p>The indexing operator that we've seen previously on ranges and tuples can also be used to retrieve the individual values from a list.  As with ranges and tuples, the indices are consecutive and begin at 0 (i.e., the index of a list's first element is 0, the index of its second element is 1, and so on).</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[2]</b>\r\n3\r\n&gt;&gt;&gt; <b>x[0]</b>\r\n1\r\n</pre></blockquote>\r\n\r\n<p>Unlike ranges and tuples, which are immutable &mdash; which means that they can't be changed once they're built &mdash; lists can be modified during their lifetime.  One way to do that is to assign to one of its indices.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 2, 3, 4]\r\n&gt;&gt;&gt; <b>x[1] = 9</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 9, 3, 4]\r\n</pre></blockquote>\r\n\r\n<p>Note, too, that indices are also numbered negatively, with -1 being the index of the last element, -2 being the index of the second-to-last element, and so on.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[-1] = 12</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 9, 3, 12]\r\n&gt;&gt;&gt; <b>x[-3]</b>\r\n9\r\n</pre></blockquote>\r\n\r\n<p>Adding a new element to the end of a list is most easily done by calling its <b>append</b> method.  Whatever argument you pass to <b>append</b> becomes the last element in the list.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x.append(15)</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 9, 3, 4, 15]\r\n&gt;&gt;&gt; <b>x.append([6, 7, 8])</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 9, 3, 4, 15, [6, 7, 8]]\r\n</pre></blockquote>\r\n\r\n<p>That last example above is an interesting one, as well, as it demonstrates two additional properties of lists:</p>\r\n\r\n<ul>\r\n  <li>Different elements of the same list can have different types.</li>\r\n  <li>Appending a list <b>b</b> to a list <b>a</b> means to make <b>b</b> be the last element of <b>a</b>.</li>\r\n</ul>\r\n\r\n<p>Note that the last of these can be worked around by using different tools.  There are two ways to <i>extend</i> a list instead of appending to it.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>y = [1, 2, 3]</b>\r\n&gt;&gt;&gt; <b>y.extend([4, 5, 6])</b>\r\n&gt;&gt;&gt; <b>y</b>\r\n[1, 2, 3, 4, 5, 6]\r\n&gt;&gt;&gt; <b>y += [7, 8, 9]</b>\r\n&gt;&gt;&gt; <b>y</b>\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n</pre></blockquote>\r\n\r\n<p>Elements can be removed from a list using the <b>del</b> operator in combination with the indexing syntax.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>del y[4]</b>\r\n&gt;&gt;&gt; <b>y</b>\r\n[1, 2, 3, 4, 6, 7, 8, 9]\r\n</pre></blockquote>\r\n\r\n<p>The built-in function <b>list</b> can take anything that can be treated as a sequence and builds a new list containing the elements of that sequence.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>list(range(0, 10))</b>\r\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n&gt;&gt;&gt; <b>list((1, 2, 3))</b>\r\n[1, 2, 3]\r\n&gt;&gt;&gt; <b>list([1, 2, 3, 4])</b>\r\n[1, 2, 3, 4]\r\n&gt;&gt;&gt; <b>list('Boo')</b>\r\n['B', 'o', 'o']\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Slicing</p>\r\n\r\n<p>Lists can also be <i>sliced</i>, which is to say that you can obtain a new list that contains a subsequence of what a list stores, while leaving the original list intact.  A slice of a list is described similarly to how we described ranges previously: by specifying a <i>start</i>, a <i>stop</i>, and a <i>step</i>, with these values indicating which indices should be included in the slice.  The start, stop, and step values are optional, falling back to defaults when they aren't specified.</p>\r\n\r\n<p>Let's start with the following list.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x = list(range(1, 11))</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n</pre></blockquote>\r\n\r\n<p>The simplest example of a slice is one that specifies both a start and a stop index.  In that case, the slice contains the indices beginning at the start (and including it), up to but <i>not</i> including the stop index.  So, for example, <b>x[3:7]</b> would include the indices 3, 4, 5, and 6, but not 7.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[3:7]</b>\r\n[4, 5, 6, 7]\r\n</pre></blockquote>\r\n\r\n<p>Negative indices can be used in either or both the start and stop positions.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[4:-2]</b>\r\n[5, 6, 7, 8]\r\n&gt;&gt;&gt; <b>x[-5:8]</b>\r\n[6, 7, 8]\r\n&gt;&gt;&gt; <b>x[-5:-1]</b>\r\n[6, 7, 8, 9]\r\n</pre></blockquote>\r\n\r\n<p>If the start index isn't specified, the default is 0; in other words, we always start a slice at the beginning of the list, if we don't say otherwise.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[:5]</b>    # the first five elements of x\r\n[1, 2, 3, 4, 5]\r\n</pre></blockquote>\r\n\r\n<p>If the stop index isn't specified, the default is the end of the list (inclusive); in other words, we always continuet through the end of the list unless we say otherwise.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[4:]</b>    # all but the first four elements of x\r\n[5, 6, 7, 8, 9, 10]\r\n</pre></blockquote>\r\n\r\n<p>If both the start and stop index are left as defaults, we've got a convenient (and well-known) syntax for copying a list.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[:]</b>\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n</pre></blockquote>\r\n\r\n<p>In every case we've seen so far, the step has been defaulted to 1, because we haven't said what it is.  That means we work our way forward through the list, without skipping any indices in between the start and the stop.  Adding an additional colon and a step value allows us to do something different, if we choose.  (Note in the examples below that the stop index is still <i>exclusive</i>; we don't include it in the result.)</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[2:9:3]</b>\r\n[3, 6, 9]\r\n&gt;&gt;&gt; <b>x[2:6:2]</b>\r\n[3, 5]\r\n</pre></blockquote>\r\n\r\n<p>A negative step can be indicated, as well, meaning that we want to build the slice by working our way backward through the list instead.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[6:2:-1]</b>\r\n[7, 6, 5, 4]\r\n&gt;&gt;&gt; <b>x[8:1:-2]</b>\r\n[9, 7, 5, 3]\r\n&gt;&gt;&gt; <b>x[::-1]</b>     # make a reversed copy of a list\r\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\r\n</pre></blockquote>\r\n\r\n<p>The step value can't be zero, though.  (If it could, you'd never get to the stop index; the slice would go on forever.)</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x[2:6:0]</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#37&gt;\", line 1, in &lt;module&gt;\r\n    x[2:6:0]\r\nValueError: slice step cannot be zero\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Choosing between tuples and lists</p>\r\n\r\n<p>Lists may seem like they provide a superset of the functionality of tuples, which might make you wonder why you would want tuples if they're less flexible.  The thing to realize is that lack of flexibility is actually a good thing.  When you have a problem for which tuples are a good fit, such as our <i>x</i>- and <i>y</i>-coordinate example above, anything that lists can do that tuples can't also do is something you wouldn't want.</p>\r\n\r\n<ul>\r\n  <li>You would never want to add a third coordinate, nor would you want to remove one of them; you always want two of them.</li>\r\n  <li>That tuples are immutable is a plus.  Because there are only two coordinates that make up each point, building a new tuple when you want to represent a new point is inexpensive.</li>\r\n</ul>\r\n\r\n<p>In a case like this, lists only provide the flexibility to do something wrong, which is to say something that is destined to introduce bugs into your program.  A necessary mentality for writing large programs is to replace the idea of being careful with effort spent making mistakes impossible instead.  The right tool for a job is the one that does <i>only</i> what you need and nothing more.</p>\r\n\r\n<p>On the other hand, if you need to store a collection of values that will change as a program runs &mdash; say, a collection of all of the users currently logged into an application, updated as users log in and out &mdash; you'll want something like a list.  Suddenly, the mutability is vital; the core of the problem is that the collection will change over time.</p>\r\n\r\n<p>Generally, as we learn about new data structures, we'll be thinking about the <i>shape</i> of the problem they solve.  When we recognize that we have a problem of a particular shape, we'll choose the data structure that best fits that shape.</p>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}