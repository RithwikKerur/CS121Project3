{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/trampoline.txt", "content": "\t        \tAnother Function Decorator \r\n               (for Computing Takl Recursive Functions)\r\n\r\nIn this optional lecture note, we show a function and various decorators for\r\nexecuting tail recursive functions written in a special form. All the code\r\nis contained in an accompanying Python project file containing three modules\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDirect Tail Recursion: First, a Functional\r\n\r\nIn the functional programming lecture we discussed tail recursion and showed\r\nhow the direct recursive list_sum function\r\n\r\ndef list_sum (l : [int]) -> int:\r\n    if l == []:\r\n        return 0\r\n    else:\r\n        return l[0] + list_sum(l[1:]) # 1st value + sum of all following values\r\n\r\ncould be rewritten with an accumulator to become tail recursive\r\n\r\ndef list_sum ( l : [int] ) -> int:\r\n\r\n    def sum_tail(alist : [int], acc : int) -> int:\r\n        if alist == []:\r\n            return acc\r\n        else:\r\n            return sum_tail( alist[1:], alist[0]+acc )\r\n\r\n    return sum_tail(l,0)\r\n\r\nand then how it could be simplified to be iterative, ultimately appearing as\r\n\r\ndef list_sum (l : [int]) -> int:\r\n    al,acc = l,0\t                # mirrors the initial call of sum_tail\r\n    while al != []:\r\n        al,acc = al[1:], al[0] + acc    # mirrors the recursive call to sum_tail\r\n    return acc\r\n\r\nMany functional programming languages automatically recognize and perform such\r\ntransformations, converting tail recursive functions into iterative ones (which\r\nuse less space and often executer faster). Python doesn't recognize nor perform\r\nsuch transformations automaticlly; but we can use a function decorator,\r\noperating on a special form of tail recursive functions, to iteratively execute\r\ntheir code.\r\n\r\nTo do so, we first translate the recursive function into a tail recursive one.\r\nWe will simplify what we wrote above, using a default value parameter to\r\naccount for the accumulator, and thus avoid the need for a nested function.\r\n\r\ndef list_sum (l : [int], acc : int = 0) -> int:\r\n    if l == []:\r\n        return acc\r\n    else:\r\n        return list_sum( l[1:], acc+l[0] )\r\n\r\nNow we translate each return into a special form: it does not return the\r\ncorrect value, but instead returns something a bit more a general: a tuple,\r\nwhose first value is a boolean telling whether it represents a base case; if it\r\ndoes, the second value is the value that the function returns; if it is not a\r\nbase case, the remaining values in the tuple are the arguments that would be\r\npassed to the recursive function call. Note, we don't call the function\r\nrecursively. Here is how we would rewrite list_sum into this special form.\r\n\r\ndef list_sum (l : [int], acc : int = 0) -> int:\r\n    if l == []:\r\n        return (True, acc)\t\t# Base case and value of function\r\n    else:\r\n        return (False, l[1:], acc+l[0]) # Recursive case and updated arguments\r\n\r\nIn this special form, calling this function doesn't compute the correct answer.\r\nInstead it returns information that can be used to compute the correct answer.\r\nSo, if the first value in the returned tuple is ...\r\n\r\n(1) True : the correct answer is the second value\r\n(2) False: the correct answer is a recursive call with updated arguments\r\n\r\nGiven tail recursive functions written in this special form, we can write a\r\nfunctional that evaluates tall recursive functions as follows.\r\n\r\ndef tail_recursive_executor(f,*args):\r\n    while True:\r\n        #print('calling',f.__name__,'with arguments:',*args)\r\n        base_case, *args = f(*args)  # parallel binding of two names\r\n        if base_case:\r\n            return args[0]\r\n\r\nWith list_sum and tal_recursive_execotor, we can execute the following call\r\n(note: we pass the function, list_sum, and it argument(s) [5, 3, 1, 4]\r\nseparately).\r\n\r\nprint(tail_recursive_executor(list_sum,[5, 3, 1, 4]))\r\n\r\nWith the print statement uncommented, this call produces the following trace\r\nand returned value. Note that no value for acc is initially passed to the call\r\nto list_sum, so no value is printed after the list in the first output (although\r\nit is defaulted to 0)\r\n\r\ncalling list_sum with arguments: [5, 3, 1, 4]\r\ncalling list_sum with arguments: [3, 1, 4] 5\r\ncalling list_sum with arguments: [1, 4] 8\r\ncalling list_sum with arguments: [4] 9\r\ncalling list_sum with arguments: [] 13\r\n13\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDirect Tail Recursion: A Decorator\r\n\r\nWe can improve on the functional: we can write a function decorator (here shown\r\nas a function; but it could also be written as a class) and use it to\r\naccomplish the same result more transparently.\r\n\r\n# Write the function decorator as a functional (the body of do_as_iterations is\r\n#   similar to the functional above)\r\n\r\ndef tail_recursive_executor(f):\r\n\r\n    def do_as_iteration(*args):\r\n        while True:\r\n            print('performing',f.__name__,'on',*args)\r\n            base_case, *args = f(*args)\r\n            if base_case:\r\n                return args[0]\r\n\r\n    return do_as_iteration\r\n\r\n# Use it to decorate an appropriately written tail-recursive function\r\n\r\n@tail_recursive_executor\r\ndef list_sum (l : [int], acc : int = 0) -> int:\r\n    if l == []:\r\n        return (True, acc)\r\n    else:\r\n        return (False, l[1:], acc+l[0])\r\n\r\n# Call the decorated function\r\n\r\nprint(list_sum([5, 3, 1, 4]))\r\n\r\nHere we rebind list_sum to the do_as_iteration function created and returned by\r\nthe tail_recursive_executor function (applied with @ as a decorator), which\r\nmeans that we can directly call list_sum (which is now bound to do_as_iteration)\r\nwith a list argument.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIndirect tail recursion: Generalizing the Special forma and Decorator\r\n\r\nUnfortunately, the code above works only with directly recursive functions.\r\nExamine the following mutually tail recursive functions. Hand simulate a call\r\non is_odd(5) to see how it computes its result. Basically n is even/odd exactly\r\nwhen n-1 is odd/even, both with the base case of 0 being/non-being even/odd\r\n\r\ndef is_even(n : int) -> bool:\r\n    if n == 0:\r\n        return True\r\n    else:\r\n        return is_odd(n-1)\r\n \r\ndef is_odd(n : int) -> bool:\r\n    if n == 0:\r\n        return False\r\n    else:\r\n        return is_even(n-1)\r\n\r\nNote that neither of these function require accumulators to be tail recursive.\r\n\r\nWith indirectly recursive functions, we have to generalize the special form\r\na bit (and likewise the tail_recursive_executor). In the new special form, the\r\ntuple returned should include (in the second position) what function to call\r\n(when it isn't the base case). So, for list_sum we would rewrite it as\r\n\r\ndef list_sum (l : [int], acc : int = 0) -> int:\r\n    if l == []:\r\n        return (True, acc)\r\n    else:\r\n        return (False, list_sum, (l[1:], acc+l[0]))\r\n\r\nFor is_even and is_odd we would rewrite them as\r\n\r\ndef is_even(n : int) -> bool:\r\n    if n == 0:\r\n        return (True, True\r\n    else:\r\n        return (False, is_odd, n-1)\r\n \r\ndef is_odd(n : int) -> bool:\r\n    if n == 0:\r\n        return (True, False)\r\n    else:\r\n        return (False, is_even, n-1)\r\n\r\nNow we must write the tail_recursive_executor to account for the extra function\r\ninformation in the special form. It is a more complex than the previous one,\r\nbecause the do_as_iteration function must store and use an attribute that refers\r\nto the function for which it was created to be equivalent.\r\n\r\ndef tail_recursive_executor(f):\r\n\r\n    def do_as_iteration(*args):\r\n        f = do_as_iteration.f     # Get special function for this call\r\n        while True:\r\n            print('calling',f.__name__,'with arguments: ',*args)\r\n            base_case, val_or_f, *args = f(*args)\r\n            if base_case:\r\n                return val_or_f\r\n            else:\r\n                f = val_or_f.f    # Get special function for recursive call\r\n                \r\n    do_as_iteration.f = f\r\n    \r\n    return do_as_iteration\r\n\r\nSo, if we write\r\n\r\n@tail_recursive_executor\r\ndef is_even(n : int) -> bool:\r\n    if n == 0:\r\n        return (True, True\r\n    else:\r\n        return (False, is_odd, n-1)\r\n \r\n@tail_recursive_executor\r\ndef is_odd(n : int) -> bool:\r\n    if n == 0:\r\n        return (True, False)\r\n    else:\r\n        return (False, is_even, n-1)\r\n\r\n\r\nis_even and is_odd each are bound to a different do_as_iteration function. And,\r\nis_even.f is bound to the is_even special form and is_odd.f is bound to the\r\nis_odd special form. It is these two special forms that are actually executed\r\nwhen inside each do_as_iteration (in the one line calling f(*args).\r\n\r\nCalling is_odd(5) with the print statement uncommented produces the following\r\ntrace and returned value.\r\n\r\ncalling is_odd with arguments: 5\r\ncalling is_even with arguments: 4\r\ncalling is_odd with arguments: 3\r\ncalling is_even with arguemnts: 2\r\ncalling is_odd with arguments: 1\r\ncalling is_even with arguments: 0\r\nTrue\r\n\r\nWe can also write this decorator as a class (with __init__ and __call__ methods)\r\nas follows:\r\n\r\nclass tail_recursive_executor:\r\n    def __init__(self,f):\r\n        self._f = f\r\n\r\n    def __call__(self,*args):\r\n        f = self\r\n        while True:\r\n            print('calling',f._f.__name__,'with arguments:',*args)\r\n            done, val_or_f, *args = f._f(*args)\r\n            if done:\r\n                return val_or_f\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTrampolines\r\n\r\nThe functional/decorators here implements something called trampolining.\r\nStandard tail recursive code (executing recursively) grows the call frame\r\ndownward until the base case, and then shrinks it while returning the answer.\r\nThink of that as one big jump down and bounce back.\r\n\r\nInstead, the functional/decorator code is a bunch of short bounces up and back\r\nas the tail_recursive_executor loops around (sometimes bouncing between\r\ndifferent mutually recursive functions).\r\n", "encoding": "ascii"}