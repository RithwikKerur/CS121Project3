{"url": "https://www.ics.uci.edu/~kay/pubs/bandwagons.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Tuesday, March 10, 1998 3:36 PM\">\n<TITLE>Bandwagons Considered Harmful</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"40E30DEB\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Curricular trends, first-year courses, curriculum design, academic decision-making\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"ACM SIGCSE Bulletin, December 1996.  Computer Science curricula should not be decided by hand-waving.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<FONT FACE=\"AGaramond\">This paper is also available in <A HREF=\"ftp://ftp.ics.uci.edu/pub/kay/bandwagons.ps\">PostScript</A>\nor <A HREF=\"ftp://ftp.ics.uci.edu/pub/kay/bandwagons.pdf\">PDF (Acrobat)</A>\nformat.</FONT></P>\n<P>\n<IMG SRC=\"bandwagons_and_balance_files/bandwagons_considered_har.gif\" WIDTH=503 HEIGHT=154 HSPACE=6 VSPACE=6 ALT=\"Bandwagons Considered Harmful, or\">\n<A NAME=\"_14_18\"></A><A NAME=\"_14_18\"></A></P>\n<BR>\n<P>\n<FONT SIZE=2>Key Words:  </FONT><FONT FACE=\"Times\" SIZE=2>Curricular trends,\nfirst-year courses, curriculum design, academic decision-making<A NAME=\"_14_117\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Abstract</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>The field of computer science changes rapidly,\nand this change occurs as well in the introductory curriculum.  Formerly\nadvanced topics filter down to the first year, and even to secondary school;\nsome topics disappear completely.  These changes are good--they indicate\na dynamic discipline and a still-emerging picture of the field&#39;s fundamental\nprinciples.  But we must not let our revolutionary zeal blind us to the\npedagogical need and conceptual value of time-tested material.  Many topics\nand approaches that are well understood and now unfashionable should retain\ntheir place in the introductory curriculum, where they serve as intellectual\nballast, foundation, and motivation for the more current and trendier content.\n We argue here for balance:  that radical change be tempered by an appreciation\nfor the place of long-standing approaches and underlying fundamentals. \nThose advocating curricular change must articulate their educational goals\nfully and consider explicitly what effect on those goals they expect the\nchange to have; they must not throw the baby out with the bathwater.<A NAME=\"_14_1233\"></A></FONT></P>\n<BR><BR>\n<P>\n<FONT SIZE=2>The Introductory Computer Science Curriculum Changes</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>The rapid development of computer science is by\nnow a clich&eacute;.  This rapidity occurs even in the introductory material;\nin what other discipline does the entire approach and content of the first\ncourse change so frequently?  We decide that some topics are less important\nor unimportant, and new tools and technologies let us cover other topics\nin less time than in the past.  This leaves room for more advanced material\nto filter down to introductory courses, though we might equally say that\nthe advanced material often pushes its way earlier in the curriculum, sometimes\nfaster than we can make room for it.  The law of &quot;Conservation of Curriculum&quot;\nstill applies:  For any new material we add to the introductory curriculum,\nsome old material--that once we thought important enough to cover--must\ngive way.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Former fundamentals do fade:  Few of us teach\nmachine-level programming in introductory courses.  Few spend weeks drilling\non number-base conversions or teach circuit theory to novices.  Yet once\nthese topics were staples of introductory courses, regarded as fundamental\nprerequisites to the high-level language programming and algorithm analysis\nthat most of us teach in the first course today.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>We also decide to start our coverage at higher\nabstraction levels.  We decide that some heretofore fundamental concepts\nhave become underlying details.  Historical perspective and maturing of\nthe discipline contribute to these changes, refining our view of what is\nfundamental.  We decide that binary search trees are fundamentally illustrative\nof certain concepts of algorithms and data organization, so they have made\ntheir way into the standard first-year curriculum, but B-trees and 2-3 trees\ntypically remain in the realm of more advanced courses.  </FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Better (or more accessible) textbooks allow us\nto cover more advanced material earlier:  Many alternatives now exist to\nKnuth</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_30\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>\nfor data structures, Jensen &amp; Wirth</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_28\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>\nfor Pascal, and even Abelson &amp; Sussman</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_27\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>\nfor programming, abstraction, and Scheme.  These early texts are justifiably\nregarded as classics, but a proliferation of other books eases the migration\nof their topics ever earlier in the curriculum.  Software tools as well\npromote this migration:  &quot;Student-oriented&quot; compilers like WATFOR\nand PL/C, syntax-directed editors like parenthesis-matchers for Lisp, and\nprogram synthesizers like the CMU Pascal Genie all handle details and rough\nedges, allowing the instructor to devote more time to new substance and\napproaches.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>As we add new material to our introductory courses,\nthough, how carefully do we consider what concepts and skills we now must\nde-emphasize or omit?  Changes in introductory curricula are made too often\nas a hasty attempt to jump on a current bandwagon, without thoughtful consideration\nof pedagogical goals and the value of the topics being supplanted.  The\nrisk of short-changing meaningful deliberations may be greatest at research\nuniversities, where faculty often receive little reward or respect for time\nand attention paid to issues of introductory education.<A NAME=\"_14_4344\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Introductory Curricula Today Are Diverse</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Great diversity exists in today&#39;s introductory\ncourses, on many different axes:  emphasis on mathematical formality vs.\nproduction of actual programs, experience-oriented &quot;closed&quot; labs\nvs. design-oriented &quot;open&quot; labs, breadth of computer science coverage\nvs. depth of analysis (or of programming experience), analysis of existing\n&quot;case studies&quot; vs. synthesis of new programs, direct applicability\nin the real world vs. conceptual simplicity in the choice of programming\nlanguage.  This is all to the good; certainly we don&#39;t know any single\nbest way to teach introductory computer science, and the exploration of\nnew approaches is much to be encouraged.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>But we must take great care that our enthusiasm\nfor novel approaches not lead us to omit something vital.  Going too far\ntowards the end of any of these scales implies the omission of other topics\nand experiences, which may turn out to be equally fundamental.<A NAME=\"_14_5304\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Curricular Debate Often Generates More Heat Than Light</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>An obstacle to reasoned curriculum development\nis the polarization that often arises between curricular innovators and\ntraditionalists.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Innovators often meet resistance to change.  Faced\nwith this resistance, one tends at times to overstate one&#39;s case, exaggerating\nthe harm of the status quo and demanding its complete reversal.  The introduction\nof structured programming grew from a letter of Dijkstra&#39;s</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_22\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>\ninto a raging controversy, with one camp regarding any use of a goto as\na mortal sin and the other resentful of any attempt to rein in their creative\nfreedom as programmers.  Even Knuth&#39;s moderating voice six years later</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_21\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>\ndid not mark the end of the controversy.  We computer scientists are not\nimmune to the human foible of regarding our own approach as the one best\nway and labeling as an idiot anyone who does not see things as we do.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>A position stated in stark, extreme, revolutionary\nterms is more likely to generate attention and interest--necessary prerequisites\nto approval and funding--than one articulated with more balance or one that\nembodies an evolutionary approach.  Sex, after all, sells, especially in\na discipline where true order-of-magnitude changes do occur with frequent\nregularity.  An example of this tendency towards exaggeration is Dijkstra&#39;s\nassertion that those who learn Basic as a first programming language are\nirreparably harmed as programmers.  In fact, knowledge is dangerous only\nwhen it is incomplete or incorrectly applied.  Many instructors assert that\nthey would rather have a complete novice than one who has programmed in\nBasic, but if Basic programmers were weaned onto a more powerful and conceptually\nstronger language after writing their first 25-line program, they would\nbe ahead of complete novices in understanding interactivity, imperative\nprogramming and control flow, variables, the need for precise syntax, and\nso on.  We do students a disservice by trying to protect them from &quot;dangerous&quot;\nknowledge, especially when they have already been exposed to it independently\nof us.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>The pendulum of fashion swings as wildly in computer\nscience education as elsewhere.  Pattis</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_20\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>,\nfor example, describes how the &quot;procedures early&quot; approach gathered\nsuch momentum that many courses and texts eventually came to cover procedures\nmuch earlier than a pedagogical justification for them existed.  He also\ndescribes the pendulum&#39;s reversal, which should provide some hope that\nequilibrium can eventually be attained, although the &quot;procedures early&quot;\nslogan still persists in textbooks&#39; titles, prefaces, and advertising.\n As scientists and educators we owe it to our students to exert whatever\nmoderation we can over our tendency to jump with both feet onto the newest,\nmost attractive bandwagon.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>As academic computer science matures, we must\ndevelop a respect for our pedagogical heritage and history, and not discard\nit willy-nilly as each attractive new concept comes along.  Fewer and fewer\nacademics&#39; careers span the entire development of the field, so few\nof us have a complete personal perspective of how our discipline emerged.\n We have passed the point where we can build a new curriculum from the ground\nup every time a new approach warrants consideration.<A NAME=\"_14_8572\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Innovations Have the Potential to Do More Harm Than Good</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>If we look at examples of four currently popular\ncurricular trends, we see strong arguments in favor of each (which their\nproponents justifiably emphasize).  But each also raises serious questions,\nwhich the trends&#39; proponents seldom address.  We argue here not against\ninnovation (nor against <I>these</I> innovations), but in favor of a more\ncareful, open, balanced debate, with less blatant advocacy and more reasoned\ndiscussion of the tradeoffs involved.  Proponents of change must not fear\nhonest dialogue.  We are educators, and we must educate our colleagues rather\nthan simply demanding that they share our vision on faith.<A NAME=\"_14_9261\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Example--De-Emphasis of Programming</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Introductory courses ten years ago focused largely\non the construction of programs--sometimes just on coding, sometimes on\nlarger design and abstraction issues, but always with a view towards writing\ncomplete programs to accomplish some task.  Today the pendulum is swinging\ntowards analysis and away from design.  Current trends towards formality,\ncase-study analysis, and structured, scheduled, analysis-oriented laboratory\nwork reduce the amount of from-the-ground-up design an introductory student\nwill carry out.  Nobody should dispute the need for analytical skills and\nformal reasoning, and we should welcome a retreat from purely synthesis-oriented\ncourses.  Nevertheless, we must not deprive the students of some program\ndesign experience in the introductory courses, for many reasons.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>First, design is an important part of the discipline;\nnobody would dispute that learning how to build software is a major part\nof an education in computer science.  Although synthesis may have overshadowed\nanalysis in the past, we must be careful not merely to reverse the imbalance.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Second, many of our introductory students come\nto us with many years&#39; experience programming.  We may find this experience\nto be haphazard and undisciplined, but that experience is probably what\nexcited them about computer science and brought them to us in the first\nplace.  By ignoring the programming process, we risk alienating these highly\nmotivated students, or giving them the impression that we have nothing to\nadd to their existing programming knowledge (an attitude all too many of\nthem come to us with already).</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Third, the experience of trying to design something\nlarge without adequate complexity management tools is indispensable motivation\nfor learning those tools.  If computer science is largely about complexity\nmanagement, people should learn by their own experience why those tools\n(be they good identifier names, source code indentation, modularity, data\nor procedural abstraction, or object-oriented programming) are essential.\n Programs of 40 lines (or even 240) fail to make the need for these techniques\nclear.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Fourth, we simply do not know how much coding\nexperience is necessary as a background to understanding broader issues.\n Nearly every reader of this paper, we expect, learned coding before algorithm\ndesign or analysis, wrote imperative programs before functional ones and\niterative programs before recursive ones, programmed in an Algol-like language\n(or Basic or assembler) before programming in functional or parallel or\nobject-oriented languages.  How much of that early experience provided us\nwith motivation, fundamental grounding, and necessary ways of thinking that\nhelped us learn and appreciate the later tools?  Can we be certain that\nabandoning this history will allow us to teach as effectively?  In particular,\ncan students appreciate abstraction if they don&#39;t know what they&#39;re\nabstracting from?  As C.A.R. Hoare put it, &quot;You can&#39;t teach beginning\nprogrammers top-down design because they don&#39;t know which way is up.&quot;\n We know that a certain amount of active experience is necessary for learning\ncomplex technical details; none of us learns spreadsheets or word processors\nsimply by reading the manual, nor do students write perfect first programs\nafter reading the text and hearing our lectures.  We don&#39;t know enough\nabout the role of experience in learning computer science concepts to eliminate\nthe programming portion of our courses entirely, no matter how sloppy, open-ended,\ndemanding on the students, difficult to evaluate, and resource-consumptive\nwe may find them.  </FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>The issue of programming in introductory courses\nis but one illustration of the risks we run in our rush to innovate:  We\nmay excise too much, undercutting some fundamentals that we educators have\ninternalized to the point that we regard them as trivial.  We disdain time\nspent on programming language syntax and we think that I/O details are uninteresting,\nbut such &quot;trivialities&quot; still require non-zero time for the novice\nto assimilate.<A NAME=\"_14_13343\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Example--Lisp as a First Language</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Another trend with the potential of short-changing\ntime-tested fundamentals (and a trend which the author has worked to advance--no\nreactionary Luddite he) is the teaching of Lisp dialects in introductory\ncourses.  A purely functional approach offers much in terms of elegance,\nprovability, parallelizability, and mathematical analysis.  But programmers\ndo use straight-line imperative sequencing, for example in interactive data\nentry, and a failure to acknowledge this and exercise it misses a strong\ntie-in with practical reality.  Students, after all, do not come to us pristine,\nunsullied, and devoid of real-world taint; confining them to the hothouse\nof pure functionality and interpreter-only interfaces fails to take advantage\nof their experience or allow them to make connections with the software\nthey see (and have written) outside of school. <A NAME=\"_14_14236\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Example--OOP as the Introductory Paradigm</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Yet another trend that might displace important\nmaterial is the introduction of object-oriented programming in introductory\ncourses.  The organizational benefits and practical applicability of the\nobject-oriented approach are undisputed, but students must still understand\ninput and output, variables and assignment, loops and conditionals, procedures\nand functions, arrays and records before they can write real object-oriented\nprograms.  What gives way to make time for classes and methods and inheritance?\n How do objects preclude the need to cover programming fundamentals?<A NAME=\"_14_14860\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Example--C++ as a First Language</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Even apart from its object orientation, C++ provides\na standardized language available on all major platforms, with a well-developed\nmechanism for enforcing modularity and the ability to create &quot;plug\nand play&quot; exercises that allow students to program &quot;real&quot;\nthings from the very beginning.  C++ is also used widely in industry, which\nfurther motivates students to learn it.  Yet its industrial-strength nature\nposes pedagogical problems.  One of the lessons of the 1960s was that big\nisn&#39;t beautiful in programming languages.  Languages like PL/I helped\nmotivate Wirth to swing the pendulum towards simplicity with Pascal.  This\nlesson is also one we learned in teaching computer science:  We want to\npare down the bells and whistles of the language we teach, so we can concentrate\non the underlying concepts rather than distinguishing between two dozen\nways of accomplishing the same task.  Will the very richness of C++, including\nas it does much of the baroque syntax of C, land us back in the business\nof defining manageable pedagogical subsets, as PL/C and PL/zero were for\nPL/I?</FONT></P>\n<BR>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Each of these trends has merit.  But those promoting\nthem must be prepared to consider and address the potential side effects\nand tradeoffs of their innovations.  The reader is encouraged to think back\non the curricular debates he or she has heard or read, whether on these\nfour example issues or on others.  Have the proponents tried to answer the\nhard questions, such as those raised above?  Or has the discourse been primarily\nhand-waving advocacy (&quot;This will work out great--you&#39;ll see!&quot;),\nbetter suited to the political stump or the revival tent than to scholarly\ndeliberation?<A NAME=\"_14_16565\"></A></FONT></P>\n<P>\n<FONT SIZE=2>Pedagogical Goals</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>The key to implementing well-considered change\nis to articulate carefully one&#39;s curricular goals and make a balanced\nanalysis of how any proposed change might affect them. </FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Discussions such as the panel &quot;Computer Science:\n The First Year Beyond Language Issues&quot; at the 1996 SIGCSE Conference</FONT><A HREF=\"bandwagons_and_balance_files/endnotes.html#_37\">Endnotes</A><FONT FACE=\"Times\" SIZE=2>\ncontribute greatly to this deliberation.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Below we present one framework for describing\nthese goals, but this framework should serve only as one possible starting\npoint for discussion; no single listing can be definitive.  The categories\nand criteria, not to mention the priority assigned to each, will of course\nvary from one institution to another, depending on size, faculty, student\nbody, available  resources, and so on.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>We start with a broader context--the goals of\na university computer science department:</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Do good research and publish it</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Get extramural funding for research programs</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Increase the department&#39;s national reputation</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Provide high-quality graduate and undergraduate\nprograms</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Fulfill obligations to the rest of the campus\n(e.g., courses for non-majors)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Maintain and improve the working environment for\nfaculty</FONT></LI>\n</UL>\n<BR>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Next we list some goals of a complete (four-year)\nundergraduate program:</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Provide well-trained graduates to industry</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Technical knowledge and skills</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Ability to adapt to changes</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Ability to communicate and work with others</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Provide well-schooled candidates to graduate schools</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Produce well-educated citizen decision makers</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Attract good students to the campus and the major</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Increase the number of students served</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Operate within constraints on finances and faculty\ntime</FONT></LI>\n</UL>\n<BR>\n<P>\n<FONT FACE=\"Times\" SIZE=2>Finally we enumerate the goals of a first-year\ncourse for computer science majors.  Students should:</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Be prepared for further course work</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Learn fundamental computer science principles</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Algorithms and data structures</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Analysis, design, and tradeoffs among them</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Abstraction and information hiding</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Exposure to the breadth of computer science as\na discipline</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Know computing concepts at an introductory level</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Data representation (bits and bytes)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Basic computer architecture:  processors, storage,\nI/O, and so on</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Characteristics of secondary storage and peripheral\ndevices</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Basic software engineering:  the process of developing\nsoftware</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Ethical, legal, and social issues surrounding\ncomputing</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Know how to use computing tools, such as</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Word processors and spreadsheets</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Network tools (Email, news, WWW)</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Develop programming skills</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Mechanics of entering and running code in some\nenvironment</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Programming &quot;in the small&quot;--single routines</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Algorithms:  insert into a list, find the maximum,\nlinear search, sorting, ...</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Data structures:  Array/table, queue, tree, ...</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Abstraction and information hiding</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Data and procedural abstraction</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Distinguishing interface from implementation</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Abstract data types/objects/classes</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Combining routines, using predefined &quot;API&quot;s</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Programming paradigms (especially OOP and functional)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Reading, understanding, debugging, and modifying\ncode</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Analyzing code&#39;s correctness and performance;\nmathematical tools</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Adaptability to new concepts, tools, skills, environments,\nparadigms, and languages</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Decide whether computer science is the field they\nwant to pursue</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Times\" SIZE=2>Receive placement or credit for prior academic\ncomputer science work (e.g., Advanced Placement Computer Science)</FONT></LI>\n</UL>\n<A NAME=\"_14_19887\"></A>\n<BR><BR>\n<P>\n<FONT SIZE=2>Conclusions</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>As noted above, specific goals and priorities\nvary from institution to institution.  The effect of any proposed change\non each goal is likewise subject to debate.  But it is exactly this sort\nof focused, reasoned deliberation that we should conduct when we consider\ncurricular change.</FONT></P>\n<P>\n<FONT FACE=\"Times\" SIZE=2>We need to explore new pedagogical avenues, but\nwe cannot abandon existing topics and approaches without thorough consideration\nof the intellectual and experiential underpinning they provide.  We cannot\nallow ourselves to become so enamored of our pet approaches that we fail\nto acknowledge existing alternatives, both old and new.  We cannot impose\nour own version of &quot;pedagogical correctness&quot; on our students.\n We owe them a balanced presentation in the introductory course, a solid\nfoundation on which their further education can build.</FONT></P>\n<P>\n<FONT SIZE=2><A HREF=\"http://www.ics.uci.edu/~kay/pubs/bandwagons_and_balance_files/endnotes.html#_28\">References</A></FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}