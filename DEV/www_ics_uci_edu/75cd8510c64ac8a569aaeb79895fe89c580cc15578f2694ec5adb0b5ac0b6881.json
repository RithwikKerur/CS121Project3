{"url": "https://www.ics.uci.edu/~fowlkes/software/nca/nca_demo/nca.cc", "content": "/*\r\n * simple code for computing the KL-divergence objective function and gradient\r\n * from \"Neighbourhood Components Analysis\" Goldberger et al, NIPS04\r\n *\r\n * charless fowlkes\r\n * fowlkes@cs.berkeley.edu\r\n * 2005-02-23\r\n *\r\n */\r\n\r\n#include <string.h>\r\n#include <math.h>\r\n#include <mex.h>\r\n\r\nvoid \r\nmexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])\r\n{\r\n    // check number of arguments\r\n    if (nlhs < 2) {\r\n        mexErrMsgTxt(\"Too few output arguments.\");\r\n    }\r\n    if (nlhs >= 3) {\r\n        mexErrMsgTxt(\"Too many output arguments.\");\r\n    }\r\n    if (nrhs < 4) {\r\n        mexErrMsgTxt(\"Too few input arguments.\");\r\n    }\r\n    if (nrhs >= 5) {\r\n        mexErrMsgTxt(\"Too many input arguments.\");\r\n    }\r\n\r\n    // get arguments\r\n    double* A = mxGetPr(prhs[0]);\r\n    int ID = mxGetN(prhs[0]);\r\n    int OD = mxGetM(prhs[0]);\r\n    double* X = mxGetPr(prhs[1]);\r\n    if (mxGetN(prhs[1]) != ID) { mexErrMsgTxt(\"data (X) dimension  does not match (A) input dimension\"); }\r\n    int N = mxGetM(prhs[1]);\r\n\r\n    double* Y = mxGetPr(prhs[2]);\r\n    int K = mxGetN(prhs[2]);\r\n    if (mxGetM(prhs[2]) != N) { mexErrMsgTxt(\"different #of class labels (Y) and point coordinates (X)\"); } \r\n\r\n    double* AXT = mxGetPr(prhs[3]);\r\n    if (mxGetN(prhs[3]) != N) { mexErrMsgTxt(\"AX has wrong # colums\"); } \r\n    if (mxGetM(prhs[3]) != OD) { mexErrMsgTxt(\"AX has wrong # rows\"); } \r\n\r\n    printf(\"pts=%d \",N);\r\n    printf(\"classes=%d \",K);\r\n    printf(\"indim=%d \",ID);\r\n    printf(\"outdim=%d \\n\",OD);\r\n\r\n    ////// set up output arguments\r\n    plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL); \r\n    //plhs[1] = mxCreateDoubleMatrix(1,ID*OD,mxREAL); \r\n    plhs[1] = mxCreateDoubleMatrix(ID,ID,mxREAL); \r\n    double* F = mxGetPr(plhs[0]);\r\n    double* M = mxGetPr(plhs[1]);\r\n\r\n    //compute exp(-D2)\r\n    double* ED2 = new double[N*N];\r\n    for (int i = 0; i < N; i++)\r\n    {\r\n      for (int j = 0; j < N; j++)\r\n      {\r\n        double d2 = 0;\r\n        for (int k = 0; k < OD; k++)\r\n        {\r\n          d2 = d2 + (AXT[i*OD+k] - AXT[j*OD+k])*(AXT[i*OD+k] - AXT[j*OD+k]) ;\r\n        }\r\n        ED2[i*N+j] = exp(-d2);\r\n      }\r\n    }\r\n\r\n    //compute softmax function P \r\n    double* P = new double[N*N];\r\n    for (int j = 0; j < N; j++)\r\n    {\r\n      for (int i = 0; i < N; i++)\r\n      {\r\n        if (i == j)\r\n        {\r\n          P[j*N+i] = 0;\r\n        }\r\n        else\r\n        {\r\n          double den = 0;\r\n          for (int k = 0; k < N; k++)\r\n          {\r\n            if (k != i)\r\n            {\r\n              den = den + ED2[i*N+k];\r\n            }\r\n          }\r\n          P[j*N+i] = ED2[j*N+i] / den;\r\n        }\r\n      }\r\n    }\r\n\r\n    //compute classification probability pi and total objective F\r\n    double* pi = new double[N];\r\n    F[0] = 0;\r\n    for (int i = 0; i < N; i++)\r\n    {\r\n      int ci = -1;\r\n      for (int k = 0; k < K; k++)\r\n      {\r\n        if (Y[k*N+i] != 0)\r\n        {\r\n          ci = k; \r\n        }\r\n      }\r\n      pi[i] = 0; //probability of drawing a neighbor in our same class\r\n      for (int j = 0; j < N; j++)\r\n      {\r\n        if (Y[ci*N+j] != 0)\r\n        {\r\n          pi[i] = pi[i] + P[j*N+i];\r\n        }\r\n      }\r\n      F[0] = F[0] + log(pi[i]);\r\n    }\r\n\r\n    //now compute the gradient\r\n    //double* M = new double[ID*ID];\r\n    memset(M,0,ID*ID*sizeof(double));\r\n    for (int i = 0; i < N; i++)\r\n    {\r\n      //add in first sum\r\n      for (int k = 0; k < N; k++)\r\n      {\r\n        for (int m = 0; m < ID; m++)\r\n        {\r\n          for (int n = 0; n < ID; n++)\r\n          {\r\n            M[m*ID+n] = M[m*ID+n] + P[k*N+i]*(X[m*N+i] - X[m*N+k])*(X[n*N+i] - X[n*N+k]);\r\n          }\r\n        }\r\n      }\r\n\r\n      //subtract off second sum (only over class of point i)\r\n      int ci = -1;\r\n      for (int k = 0; k < K; k++)\r\n      {\r\n        if (Y[k*N+i] != 0)\r\n        {\r\n          ci = k; \r\n        }\r\n      }\r\n      for (int j = 0; j < N; j++)\r\n      {\r\n        if (Y[ci*N+j] != 0)\r\n        {\r\n          for (int m = 0; m < ID; m++)\r\n          {\r\n            for (int n = 0; n < ID; n++)\r\n            {\r\n              M[m*ID+n] = M[m*ID+n] - (1/pi[i])*P[j*N+i]*(X[m*N+i] - X[m*N+j])*(X[n*N+i] - X[n*N+j]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n      \r\n    delete[] ED2;\r\n    delete[] P;\r\n    delete[] pi;\r\n}\r\n\r\n\r\n\r\n", "encoding": "ascii"}