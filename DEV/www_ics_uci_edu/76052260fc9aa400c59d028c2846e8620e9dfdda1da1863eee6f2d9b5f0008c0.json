{"url": "https://www.ics.uci.edu/~eppstein/180a/990114.html", "content": "<HTML>\n<HEAD>\n<TITLE>\nICS 180, January 14, 1999</TITLE>\n<META name=\"Owner\" value=\"eppstein\">\n<META name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</HEAD><BODY>\n<IMG SRC=\"icslogo2.gif\" WIDTH=472 HEIGHT=72 ALT=\"\"><P>\n<A HREF=\"index.html\">\n<H1>ICS 180A, Spring 1997:<BR>\nStrategy and board game programming</H1></A>\n\n<H2>Lecture notes for April 10, 1997<BR>\nEvaluation Functions</H2>\n\n<H3>General considerations</H3>\n\n<P>The evaluation function is where most of the game-specific knowledge \ngoes into your program. We start off with two basic assumptions:\n\n<P><OL>\n<LI>We can represent the quality of a position as a number.  For instance, \nthis number might be our estimate of the probability that we can win the \ngame; but most programs don't try to make the number mean anything so \nspecific, it's just a number.\n<P><LI>The quality we measure is or should be the same as the quality our \nopponent measures (so if we think we're in a good position, our opponent \nthinks he's in a bad position and vice versa).  This is unlikely to be \nreally true, but it's needed to make our search algorithms work well, and \nin practice it comes pretty close to the truth.\n</OL>\n\n<P>The evaluation can be more or less complicated, depending on how much \nknowledge you build in to it.  The more complicated it is, and the more \nknowledge it encodes, the slower it is likely to be. Typically, the \nperformance of a program (how well it plays) has been estimated as behaving \nlike the product of the knowledge and speed:\n<P><CENTER><IMG SRC=\"perfcurves.gif\"></CENTER>\n<P>So, if you have a fast dumb program you can often make it better by \nadding more knowledge and slowing it down a little.  But that same \nadditional knowledge and slowdown might actually make a smart slow program \nworse; there is a diminishing rate of return of performance to knowledge.\nSimilarly once you speed your program up past a certain point, there is a \ndiminishing improvement for adding more speed, and you would be better off \nbalancing speed and knowledge somewhere closer to the middle of the chart.\nThis balance point varies somewhat depending on what kind of opponent you \nexpect to face; speed works better for defeating other computers, while \nhuman opponents are very good at exploiting holes in your knowledge and \nare more easily defeated by knowledge-based programs.\n\n<H3>Implementation methods</H3>\n\n<P>There are two major types of evaluation function method.\nThe first, \"end-point evaluation\", is simply to evaluate each position \nindependently of each other position, using your favorite evaluation \nalgorithm.  This can give good results, but is slow, so some programmers \nhave resorted to the following trick, known as pre-computation, first order \nevaluation, or piece-square tables.\n\n<P>Before we begin a search for the best move from a position, we examine \ncarefully the position itself, and compute values to store in an array \nT[square,piece type].  The evaluation of any position found in the search \nwill then be simply the sum of the array values for the pieces in the \nposition.  We don't have to compute the sum from scratch at each step; \ninstead when moving a piece from one square to another update the score \nusing the formula\n<CENTER><PRE>\nscore += T[new square,piece] - T[old square,piece]\n</PRE></CENTER>\n\n<P>Examples of piece-square table values in chess: when a king is castled into \nthe corner of the board, the pawns in front of it are very useful in \ndefending against attacks. Their ability to defend becomes less as they \nmove forward.  So, if the king is in the corner in the starting position \nof the search, we might build piece-square tables for the pawns having the \nvalues\n<PRE>\n    ... 1   1   1   1\n    ... 1   1.1 1.1 1.1\n    ... 1   1.2 1.2 1.2\n</PRE>\non the three rows in front of the king, to encourage the pawns to stay \nclose to the king by giving them a greater value than their usual one point \nwhen they are nearby.\n\n<P>Unfortunately while piece-square tables are blindingly fast, and you can \nincorporate some interesting kinds of knowledge this way, piece-square \ntables are pretty stupid in general. They can't take into account \ninteractions between several moving pieces; those interactions have to be \napproximated by looking at where the pieces were when the piece-square \ntable was computed. So, for instance, if we search through a long sequence \nof moves, in which the king goes to a different part of the board, the \npiece-square table values above would be inaccurate because they would be \nmaking the pawns defend the place the king used to be, rather than \ndefending the king itself.\n\n<P>Programs that use piece-square tables often combine them with some \namount of end-point evaluation. Another strategy for making \npiece-square table methods more accurate is to delay building the tables \nuntil later in the search; e.g. if you are searching 9-move sequences, \nbuild the tables after sequences of 5 moves and use them for the remaining \n4-move search.  If you do that, though, you should be careful to make the \ntables resulting from one 5-move sequence be consistent with those from \nother sequences, so that the overall evaluation scores can be compared \nmeaningfully.  In class Dave O. suggested another possible improvement: \nmake incremental modifications to the piece-square tables, e.g. move the \nbonuses for pawns in front of kings when the kings move; this seems like a \ngood idea but I don't know whether it's been implemented or if so how well \nit worked.\n\n<H3>How to combine evaluation terms</H3>\n\nTypically, like the first-order evaluations above, an evaluation function \nis a sum of several terms, where each term is the result of a function that \nlooks for certain specific information in a position.  Why sums?  It's a \nrelatively simple way of combining information that works ok in practice.\n\n<P>My own feeling is that game programmers really should try more carefully \nto model their evaluation functions on probabilities:\ncombine terms to determine probabilities of winning soon (by carrying out \nsome kind of attack), in a moderate number of moves, or in an endgame (say \nby taking advantage of a passed pawn in chess),\nand combine the probabilities appropriately.\nIf the probability of winning soon for black is bs and for white is ws,\nif the probability of winning in a moderate number of moves (assuming no \nsooner win) is bm or wm, and if the probability of winning in an endgame is \nbe or we, then the overall probability of winning is\n<CENTER><PRE>\nbs + (1 - bs - ws) bm + (1 - bs - ws - bm - wm) be\n</PRE></CENTER>\nor\n<CENTER><PRE>\nws + (1 - bs - ws) wm + (1 - bs - ws - bm - wm) we.\n</PRE></CENTER>\nI think it might be a useful idea for an evaluation function to compute \nterms estimating these individual probabilities, and combine them with \nformulas like the ones above.  How well each probability is estimated could \nbe tested by comparing the program's estimates against the actual results \nin databases of games, and this would give a program the ability to do some \nrudimentary planning (judging whether to go for a certain attack based on \nhow likely it is to work).  But this is purely speculation, it hasn't been \ntested in a real program, and you won't go far wrong just using sums.\n\n<H3>What kinds of information go into evaluation functions?</H3>\n\nEvaluation functions typically combine terms encoding knowledge of \ndifferent types:\n\n<UL>\n<P><LI><B>Material</B>. The sum of point values in chess, the number of \npieces of each player on the board in e.g. go or othello. This is often \nuseful, but othello provides an interesting counterexample: the game is \nbased at the end on the material count, but for middle-game positions it \nis a pretty bad idea to base the evaluation on material, since often the \nplayer with the better position will actually have fewer pieces. For some \nother games such as go-moku material is irrelevant since it a function only \nof what move it is and not of how good the board position is.\n\n<P><LI><B>Space</B>. For some games, one can partition the board into \nregions controlled by one player, regions controlled by the other player, \nand regions still in dispute.  For instance, this is the main idea of go.  \nBut it also comes up in games including chess, in which one player's region \nconsists of the squares attacked or protected by his own pieces and not \nattacked or protected by the opponent's.  In Othello, if one player has a \nconnected group of pieces surrounding a corner, these pieces can never be \ntaken and form part of that player's territory.  The space evaluation is \nthen simply the sizes of these regions, or less simply the total importance \nof these regions if there's some way of saying that one square is more \nimportant than another.\n\n<P><LI><B>Mobility</B>. How many different moves does each player have \navailable? The idea is that if you have more choices of move, it's that \nmuch more likely that at least one of them will lead to a good position. \nThis works very well in othello. It's not so useful in chess (it's been \nused, but some chess programmers have taken it out of their programs \nbecause it doesn't seem to help the quality of the overall evaluation).\n\n<P><LI><B>Tempo</B>. This is closely related to mobility,\nand comes up in games like Othello and Connect-4 (and in certain chess\nendgames) where it can often be a\ndisadvantage to be forced to move.\nBut unlike mobility terms, often the parity of the number of available moves\n(whether it is odd or even) matters more than the total number.\n\n<P>For instance, consider the connect-4 position below:\n<P><CENTER><IMG SRC=\"990114.gif\" WIDTH=200 HEIGHT=171></CENTER>\nColumns 1, 3, 4, and 7 are filled up, so any move must be to columns 2,\n5, or 6.  Moves to column 6 are neutral -- either player can make\nthem without winning or losing.  Black controls column 2 --\nred can not play safely there,\nbecause that would let black win by getting four in a row.\nNeither player can move safely in column 4 because the\nother player would then immediately win.\nIf red plays next, then after three moves to column 6, black will be forced\nmove in column 2, giving up his control of that column,\nand three moves later black will have\nto move again in column 5 and red will win.\nBut if black is the one to play next, then three moves later\nred will be forced to make a losing move.\n\n<P>In connect-4 endgames such as this, the columns with an even number\nof spaces left are very unimportant.\nThe important quantity to measure is\nthe number of odd columns in which only one player can move.\nIf one player controls more odd columns, he or she is likely to win.\nIf the number of odd columns controlled by each player is equal,\nas in the board shown (red controls none of the columns, and black only\ncontrols an even column) then the important quantity is the number of\nodd neutral columns -- if this is odd then the next player to play will win,\nwhile if it's even the next player will lose.\nOf course, this simple analysis needs to be made more sophisticated to\nhandle positions in which\none player controls positions higher up in the columns.\n\n<P>In some other games such as Go, such strict parity rules are not\nimportant, but it still matters who has the <I>initiative</I> --\nthe player who can choose where to play, while the other player is forced\nto respond in the same area of the board.  Often it is a good idea to\nmake a sequence of moves that each take a small amount of space\nbut force your opponent to respond, before making a larger move\nthat takes more space but allows your opponent to take the initiative.\n\n<P><LI><B>Threats</B>. Is the opponent about to do something bad? Are you \nabout to do something good? E.g. in \nchess or go, are some pieces likely to be captured? In go-moku or \nconnect-4, does either player have some number of pieces lined up?  In \nchess or checkers is some pawn about to be queened or kinged? In othello, \nis one player about to take a corner?\nThis sort of term should vary according to the immediacy and strength of \nthe threat.\n\n<P><LI><B>Shape</B>. In go, connected groups of pieces are safe from \ncapture if they surround two separate regions of territory (called \n\"eyes\"). In chess, side-by-side pawns are generally much stronger than \npawns stacked on the same column. Shape-based terms are especially \nimportant because they measure long-term qualities of the position that do \nnot change much in a few moves and that won't be covered by the search.\n(Searching finds short-range tactics in an attempt to improve the overall \nevaluation, so the evaluation itself needs to include any more long-term \nfeatures that the search is trying to make happen.)\n\n<P><LI><B>Motifs</B>. Some particular patterns of pieces are common enough \nthat it's worth including special case terms to cover them.  In chess, for \nexample, a bishop can often capture a pawn on the outside column, only to \nbe trapped by moving another pawn forward. Once the bishop is trapped, it \nmay still take many moves for the opponent to maneuver a piece into \nposition to capture it, so the fact that it's trapped may not be obvious in \nthe computer's search routine.  Some programs have included special \nevaluation terms to warn the computer that taking that pawn might be a \nmistake.  In othello, it's sometimes useful to \"sacrifice\" one corner by \nplacing a stone next to the corner, so that when the opponent takes the \ncorner itself one can put another stone next to the corner in a way that \nwon't be taken, and that leads to the win of a different corner:\n<P><CENTER><PRE>\n    . . O @ @ @ @ .\n    . . @ @ @ @ O .\n    . @ @ @ @ @ . .\n</PRE>\nWhite has sacrificed the bottom-left corner.<BR>Once black plays bottom-left, \nwhite will play next to it and win the bottom-right corner.\n</CENTER>\n<P>It might be worthwhile to have special evaluation code to examine these \nsacrifices and determine to what extent they're worthwhile to make, or to \ninclude in the measure of quality of a position the vulnerability of \nedge-pieces to such a sacrifice.\n</UL>\n\n<HR>\n<A HREF=\"/~eppstein/\">David Eppstein,\n<A HREF=\"/\">Dept. Information & Computer Science</A>,\n<A HREF=\"http://www.uci.edu/\">UC Irvine</A>,\n<!--#flastmod file=\"990114.html\" -->.\n</BODY></HTML>\n", "encoding": "ascii"}