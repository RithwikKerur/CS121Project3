{"url": "https://www.ics.uci.edu/~eppstein/180a/970408.html", "content": "<HTML>\n<HEAD>\n<TITLE>\nICS 180, April 8, 1997</TITLE>\n<META name=\"Owner\" value=\"eppstein\">\n<META name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</HEAD><BODY>\n<IMG SRC=\"icslogo2.gif\" WIDTH=472 HEIGHT=72 ALT=\"\"><P>\n<A HREF=\"index.html\">\n<H1>ICS 180A, Spring 1997:<BR>\nStrategy and board game programming</H1></A>\n\n<H2>Lecture notes for April 8, 1997<BR>\nBoard representations</H2>\n\nIn order to operate, any\ngame program needs to be able to store and manipulate two kinds of objects: \ngame positions, and game moves. These representations need to allow the \nprogram to perform the following operations:\n<UL>\n<LI>Make a given move (not just when user requests, but as part of search)\n<LI>Undo a move (not just for user interface, needed in search)\n<LI>Display board to user\n<LI>Generate a list of all possible moves\n<LI>Evaluate a board position\n</UL>\nEverything except displaying the board must be fast since it happens in the \ninner loops of the search routine.\n(Board display can be slower since it doesn't happen often.)\n\n<P>The internal representation of moves should be very concise (since \nwe don't want to spend too much time generating long lists of moves) and quickly \ndecodable.  But (very important) it should also able to represent all \npossible moves!  E.g.  for chess, a typical computer move representation is \nto store the starting square and ending square of the piece being moved; \nfor instance the common beginning move of the king's pawn forward two \nsquares would be represented \"e2e4\" where e2 is the name for the initial \nposition of the pawn and e4 is the name for its final position.  The piece \nbeing captured (if any) does not need to be stored as part of the move \nsince it is determined by the final position.  In the \ncomputer, these positions can be represented as 6-bit values, so the whole \nmove could be stored internally as two bytes.  But (even though some \nprograms are based on it) this representation is not quite capable of \nrepresenting all moves!  In castling, two pieces move, a king and a rook, but we can handle \nthis as a special case in which we list only the king movement. More \nimportantly, if a pawn moves from the seventh rank to the eighth, it can be \nreplaced by any of four pieces: queen, rook, knight, and bishop. The \nrepresentation above doesn't allow us to specify which replacement is \nhappening. So when designing a move representation, one should be careful \nto make sure that it covers all the special cases that might happen in \nyour game.\n\n<P>The onternal representation of board can be less concise but should still not \nbe too huge.  It must represent all relevant information, not just all \nvisible information, but not including irrelevant information.  E.g.  in \nchess, we need to know the positions of pieces on the board (the obvious \nvisible information), but we also need to know some invisible information: \nwho's on move, whether either player can castle, whether an en passant \ncapture is possible, and how many moves it's been since the last capture or \npawn move.  We also need to know something about what positions have \noccurred in the past (because of triple repetition) but don't need to know \nthe entire list of past moves.\n\n<H3>Example of  Multiple Representation Possibilities: Chess</H3>\n\nThere are many possible ways of representing even something with as \nclearly defined a structure as a chessboard in a computer.  Here are some \nof the methods that have been used by chess programs.\n\n<P><B>Representation 1: 8x8 array of squares</B>.\nWithin each square, keep a value indicating which piece is present in the \nsquare\n(e.g. enum { empty, wK, wN, wB, wR, wQ, wP, bK, bN, bR, bQ, bP }).  \nAdvantages: (1) simple. (2) easy to compute material scores:\n<PRE>\n    for  (i=0;i&lt;8;i++)\n        for(j=0;j&lt;8;j++)\n            score += value[square[i,j]];\n</PRE>\nIt's a little messy but not really hard to compute possible moves; you can loop through the \nsquares finding pieces of appropriate color and branch according to piece \ntype:\n<PRE>\n    for  (i=0;i&lt;8;i++)\n        for(j=0;j&lt;8;j++)\n            switch (board[i,j]) {\n            case wP:\n                if (board[i+1,j] empty) generate move to (i+1,j)\n                if (i==2 &amp;&amp; board[i+1,j] empty &amp;&amp; board[i+2,j] empty)\n                    generate move to (i+2,j)\n                if (j &gt; 0 &amp;&amp; board[i+1,j-1] contains black piece)\n                    generate capture of (i+1,j-1)\n                if (j &lt; 7 &amp;&amp; board[i+1,j+1] contains black piece)\n                    generate capture of (i+1,j+1)\n                break;\n            ...\n            }\n</PRE>\nhowever there are various annoying boundary conditions to \ncheck (e.g. a pawn on rook-file shouldn't try to capture to one side) making \nthis code complicated and slower than necessary.\n\n<P><B>Representation 2: extended array</B>. 10x10, containing extra boundary squares \ncontaining a special \"boundary\" value added to the enum.  This simpifies \nsome of the cases (reduces number of conditions in the if-statements above) \nat the expense of a little space.\n\n<P><B>Representation 3: 0x88</B>.  The name of this representation comes \nfrom a trick for testing whether a square is a valid move involving the \nbinary representation of the number 136 (which in hexadecimal is 0x88).\nWe give each square of the board a number (a single byte), of \nwhich the high 4 bits are the row and the low 4 bits are the column:\n<PRE>\n    112 113 114 115 116 117 118 119\n    96  97  98  99  100 101 102 103\n    80  81  82  83  84  85  86  87\n    64  65  66  67  68  69  70  71\n    48  49  50  51  52  53  54  55\n    32  33  34  35  36  37  38  39\n    16  17  18  19  20  21  22  23\n    0   1   2   3   4   5   6   7\n</PRE>\nThen the square left of i is i-1, right is i+1, up is i+16, down is i-16 \netc.  Then represent the board as an \narray of 128 squares (of which 64 correspond to actual squares on the \nboard).  The advantages of this representation are (1) it speeds up the \nprogram a little by using only one index instead of two in the array \nreferences, and (2) you can test really \nquickly and easily whether a move stays on the board: i is a legal board position if \nand only if (i&amp;0x88)==0.  [Work it out, moving off the board either \noverflows the column giving i&amp;0x08 nonzero, or overflows the row giving \ni&0x80 nonzero.]  This is a pretty commonly used technique.\n\n<P><B>Representation 4: bitboards</B>.  I'll go into this in a lot more \nlength than the other representations because it's probably more \nunfamiliar, but I think it's also likely to work better.  Instead of having \nan array of squares, each containing a piece types, have an array of piece \ntypes, each of which stores a packed array of bits listing the squares \ncontaining that piece.  Since there are 64 possible squares, each of these \npacked arrays can be stored in a 64-bit number (two 32-bit words).  The big \nadvantage is that you can perform certain evaluation and move generation \noperations very quickly using bitwise Boolean operations.  Think of it as a \nway of getting your computer to do massively parallel computations by \npacking things into long words.  For example, in the following position:\n\n<P><CENTER><IMG SRC=\"970408.gif\"></CENTER>\n\n<P>The bitboard for the white pawns (call this 64-bit value \"wP\") would \nconsist of the bits\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 1 0 0 0\n    0 0 0 0 0 0 0 0\n    1 1 1 0 0 0 0 1\n    0 0 0 0 0 0 0 0\n</PRE>\nThen the bitboard squares occupied by black can be computed by a formula\n<PRE>\n    bOcc = bP | bN | bB | bR | bQ | bK\n</PRE>\n(where bP etc are bitboards for the different kinds of black pieces).\nSimilarly we can compute the white occupied squares, and or these two \nbitboards together to get all occupied squares.\nThe bitboard of possible white pawn one-square move destinations can then \nbe computed by a formula:\n<PRE>\n    single_pawn_moves = (wP &lt;&lt; 8) &amp; ~occupied\n</PRE>\nLet's look at this in slow motion.\nShifting wP by 8 produces a bitboard of positions one place in front of \neach pawn:\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 0 1 0 0\n    0 0 0 0 1 0 0 0\n    0 0 0 0 0 0 0 0\n    1 1 1 0 0 0 0 1\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n</PRE>\nThe negation of occupied gives a bitboard of empty squares:\n<PRE>\n    0 0 1 1 0 0 1 0\n    1 0 1 0 1 0 0 0\n    1 1 1 0 0 0 1 1\n    1 0 1 1 1 0 1 1\n    1 0 1 1 0 1 1 1\n    1 0 1 1 1 0 1 1\n    0 0 0 1 1 1 1 0\n    0 1 0 1 0 0 1 0\n</PRE>\nThe bitwise and of these two bitboards then gives the positions in front \nof a pawn, that are not already occupied:\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 1 0 0 0\n    0 0 0 0 0 0 0 0\n    1 0 1 0 0 0 0 1\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n</PRE>\nSimilarly you can find two-square pawn moves by taking the bitboard of \none-square moves, shifting it another 8 bits, anding it with the \nnon-occupied squares again, and anding it with a constant bitboard (shown \nbelow) of the \nsquares on the fourth row (the only row onto which pawns are allowed to \nmove two squares):\n<PRE>\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    1 1 1 1 1 1 1 1\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0\n</PRE>\nNote that this constant bitboard can be generated at compile time rather \nthan each time we want to generate moves.\nPawn captures are similar (shift by seven or nine, and with a constant to \neliminate captures off the left and right side of the board, and with bOcc).\n\n<P>The point of this technique is not that your code is simpler when you \nprogram with bitboards (it's a little more complicated) but that you \ngenerate the pawn moves all at once rather than one at a time.  Also, a lot \nof the intermediate expressions you need (such as bOcc) get used over and \nover, and only need to be computed once. So bitboards end up being very \nefficient, and I think would be even better for games other than chess in \nwhich there are fewer types of pieces.\n\n<P>One complication arises: it's often important to count the number of \nnonzero bits in a bitboard, or to find a nonzero bit (e.g. to turn the \nbitboard of possible pawn moves into an explicit list of moves).\nCounting can be done one byte at a time, looking up in a 256-entry table \nthe number of nonzero bits in each byte. There's a cute trick for finding \na single nonzero bit: x^(x-1) (where the uparrow is C notation for \nexclusive or) gives a binary number \n...000111... where the first one of x^(x-1) is the last nonzero bit of  x.  If you need to \nturn this into an actual bit, take the result modulo some carefully chosen \nnumber M (for which the numbers ...000111... are all different mod M), and \nlook the result up in a table.  As a simple example, the following code \nfinds the index of the last nonzero bit of a byte:\n<PRE>\n    int T = { -1, 0, 7, 1, 3, -1, 6, 2, 5, 4, -1, -1 };\n    int last_bit(unsigned char b) { return T[(b^(b-1)) % 11]; }\n</PRE>\n\n<H3>How to Undo?</H3>\n\nRemember we said our board representation needed to handle undo operations.\nThere are\ntwo possible methods: (1) Keep a stack in which each stack item holds a \nwhole board representation; to make a move push it on the stack and to undo \na move pop the stack. Probably this is too slow...\n(2) Keep a stack storing only the move itself together with enough extra \ninformation to undo the move and restore all the information in the board \nposition.  E.g. in chess you would need to store the identity of a \ncaptured piece (if any) and enough information to restore castling \nand en passant capturing privileges.\n\n<H3>Repetition Detection</H3>\n\nSome games e.g. Go, Chess have special rules about what happens when the \nsame position is repeated (in chess, third repetition of a position gives \nthe player making the repetition the right to declare a draw).  How to \ntell?  Short answer: make a hash function translating the position to a \nreasonably large number (we'll talk more about this later because this is \nalso very important for speeding up the search). Then keep a list of the \nhash codes for previous game positions and test if your position shows up \nin it.  Typical hash function: make 64*13 table of  large random numbers; \nwhen piece x is on position y, look up table[x,y] and add it to hash \nignoring overflow [Zobrist].  Note that, when making a move of a piece y\nfrom positions x to z, you can update the hash very quickly:\njust subtract table[x,y] and add table[z,y].\n\n<HR>\n<A HREF=\"/~eppstein/\">David Eppstein,\n<A HREF=\"/\">Dept. Information & Computer Science</A>,\n<A HREF=\"http://www.uci.edu/\">UC Irvine</A>,\n<!--#flastmod file=\"970408.html\" -->.\n</BODY></HTML>\n", "encoding": "ascii"}