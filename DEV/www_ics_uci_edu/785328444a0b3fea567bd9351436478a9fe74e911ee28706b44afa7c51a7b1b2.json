{"url": "https://www.ics.uci.edu/~eppstein/gina/schnyder/", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<html>\n<head>\n<meta name=\"generator\" content=\n\"HTML Tidy for Mac OS X (vers 1st May 2002), see www.w3.org\">\n<title>Schnyder's Grid-Embedding Algorithm</title>\n</head>\n<body bgcolor=\"#ffffff\" text=\"#000000\">\n<h1>ICS <a href=\"http://www.ics.uci.edu/~eppstein/163/\">163</a> and\n<a href=\"http://www.ics.uci.edu/~eppstein/265/\">265</a>: Graph\nAlgorithms</h1>\n\n<h2>Walter Schnyder's Grid-Embedding Algorithm</h2>\n\n<p>At the 1st ACM-SIAM Symp. on Discrete Algorithms, in 1990,\nWalter Schnyder presented a very nice algorithm for placing the\nvertices of a planar graph on a grid, so that the straight line\nsegments between the vertices form a planar drawing of the\ngraph.</p>\n\n<p>The input to Schnyder's algorithm is assumed to be a planar\ngraph, without any self-loops or multiple adjacencies, with the\ntopology of a planar layout already specified in terms of a\nclockwise ordering of the edges at each vertex, as results from\nHopcroft-Tarjan or other linear-time planar embedding algorithms.\nIn addition, each face of the layout, including the outer face, is\nassumed to be a triangle. If necessary, one can add edges to the\ngraph to subdivide the faces into triangles, using the following\nfact (which we will also need later):</p>\n\n<blockquote>\n<p><b>Lemma 1:</b> Let G be an outerplanar graph (planar graph in\nwhich some face f contains all the vertices). Then there is a\nvertex in G whose only neighbors are the two adjacent vertices in\nf.</p>\n\n<p>Proof: As we saw when discussing properties of planar graphs,\nthe weak dual of G (the graph formed from the planar dual by\nremoving the dual of f) is a tree. This tree has a leaf,\ncorresponding in G to a face l that shares all but one of its edges\nwith f. Since l has at least three vertices, the path of edges\nbetween l and f contains a vertex, which has as its neighbors only\nthe adjacent vertices on the path. This vertex satisfies the\nconditions of the lemma.</p>\n</blockquote>\n\n<p>So if any face is not a triangle, we can use the lemma (on the\ngraph of edges connecting the vertices of that face) to find a\nvertex that can be connected to all other vertices of the face,\nsubdividing the face into triangles, without adding any multiple\nadjacencies, as shown below. With some care, all faces can be\ntriangulated in this way in linear time.</p>\n\n<div align=\"center\"><img src=\"triangulate.png\" alt=\n\"triangulating the faces of a planar graph\"\nwidth=555 height=192></div>\n\n<p>One of the faces of the graph will be designated as external,\nand the rest as internal. An edge or vertex is internal if it does\nnot belong to the external face. Schnyder's method depends on two\nclosely related concepts in a triangulated planar graph: a normal\nlabelling and a realization. A normal labelling is an assignment of\nthe numbers 1-2-3 to the corners of each interior triangle, such\nthat each triangle has all three labels in clockwise order, and so\nthat the labels around each internal vertex form contiguous blocks\nof 1's, 2's, and 3's in clockwise order. A realization is an\nassignment of a direction to each internal edge, and a number 1-2-3\nto each internal edge, so that each internal vertex has exactly one\noutgoing edge with each of the three numbers, these edges appear in\nclockwise order, and between any two outgoing edges labeled\ni and j the incoming edges all have label 6-i-j. Below we see a\nnormal labelling and a realization of the same graph.</p>\n\n<div align=\"center\"><img src=\"normreal.png\" alt=\n\"normal labelling and realizer of a triangulation\"\nwidth=514 height=208></div>\n\n<p>Any internal edge in a normal labelling must have all three\nlabels at the adjacent triangle corners, two different label at one\nend and the same label twice at the other end. We can form a\nrealizer by orienting each edge toward the end with the doubled\nlabel and giving it that label. Conversely if we have a realizer we\ncan form a normal labelling by assigning the label 6-i-j to all\ncorners between the outgoing edges labeled i and j. If you check\nthe illustration above you will see that the normal labelling and\nrealizer are related to each other in this way. So the two concepts\nare equivalent and easily converted to each other.</p>\n\n<blockquote>\n<p><b>Lemma 2:</b> In any realizer, all edges at an external vertex\nare oriented towards that vertex, and have the same label.</p>\n\n<p>Proof: By <a href=\n\"http://www.ics.uci.edu/~eppstein/junkyard/euler/\">Euler's\nformula</a>, The number of internal vertices is n-3, and the number\nof internal edges is 3n-9. Each internal vertex has three outgoing\nedges, so the number of edges outgoing from internal vertices is\nalso 3n-9, and there are no edges left over to be outgoing from\nexternal vertices. Since all edges in the realizer are oriented\ntowards an external vertex, all corners at that vertex in the\ncorresponding normal labelling must have the same label, and so all\nedges in the realizer must have the same label as well.</p>\n</blockquote>\n\n<p>In any realizer, the path of edges around one of the outer\ncorners of the drawing starts and ends with an edge pointing\noutward, so there must be a vertex in the middle of the path where\nboth edges point away from that vertex. Contracting that vertex\ninto the outer corner produces a realizer of a graph with one fewer\nvertex.</p>\n\n<blockquote>\n<p><b>Lemma 3:</b> In any realizer, the edges with label i form a\nspanning tree of the internal vertices rooted at the external\nvertex with label i.</p>\n\n<p>Proof: by induction on the size of the graph, using the\ncontraction step described above to reduce to a smaller graph.</p>\n</blockquote>\n\n<p>Conversely, any planar triangulation has a vertex along this\npath that can be contracted into the outer corner without creating\nmultiple adjacencies (by Lemma 1, applied to the vertices of the\npath), and one can construct a realizer of the original graph by\nuncontracting a realizer of the contracted graph. This allows us to\ndevelop a linear time algorithm for normal labelling of a planar\ntriangulation, expressed below in pseudo-Python syntax:</p>\n\n<pre>\ndef normalLabel(G):\n\n    # set up data structures\n    stack = []\n    neighborCounts = {}\n    contractible = []\n    for v in the path of edges around external vertex 1:\n        neighborCount[v] = number of edges from v to other vertices in the path\n        if neighborCount[v] == 2:\n            contractible.push(v)\n            \n    # repeatedly contract\n    while graph has internal vertices left:\n        v = contractible.pop()\n        stack.push(v)\n        contract v into the external vertex\n        for w in the vertices added to v by the contraction:\n            adjust neighborCounts[neighbors of w]\n            move vertices into or out of contractible if count becomes ==2 or !=2\n        \n    # build graph back up by reversing contractions\n    while len(stack) &gt; 0:\n        uncontract(stack.pop())\n        label the two new uncontracted triangles\n</pre>\n\n<p>Finally, we are ready to define the grid embedding of the graph.\nSince the realizer of the graph has a spanning tree for each label,\nthere is a path of label-i edges from each vertex v to external\nvertex i. These three paths divide the graph into three\nregions:</p>\n\n<div align=\"center\"><img src=\"regions.png\" alt=\n\"division of triangulation into three regions by labeled paths from a vertex\"\nwidth=239 height=208></div>\n\n<p>We use the numbers of triangle in each region as\nthree-dimensional coordinates of v. Any set of coordinates (x,y,z)\nhas x+y+z=2n-5, so these coordinates all lie on a plane. Any\ntriangle in the graph is oriented correctly, since its corner\nlabeled i has the highest i'th coordinate of the three vertices in\nthe triangle. Since all triangles are oriented correctly, the\nlayout can't fold over itself and must be non-crossing. The layout\nof the example we've been using is shown below. Although the\ncoordinates are 3-dimensional, we can view them as <i>barycentric\ncoordinates</i> in a two-dimensional triangular grid: position\n(x,y,z) is x lines above the bottom edge of the triangle, y lines\nto the right of the left edge, and z lines to the left of the right\nedge. Alternatively, we can form a layout on a square grid by\ndropping the third coordinate.</p>\n\n<div align=\"center\"><img src=\"gridlayout.png\" alt=\n\"layout formed by using numbers of triangles in each region as\nbarycentric coordinates\" width=370 height=278></div>\n\n<p>Schnyder goes on to find a slightly compacter layout, by\ncounting vertices in each region (including the path bordering the\nregion on the clockwise side but not on the counterclockwise side).\nThe result is an embedding with positive integer coordinates in the\nplane x+y+z=n-2, or in two dimensions in an (n-2)x(n-2) grid, in\nlinear time.</p>\n</body>\n</html>\n\n", "encoding": "ascii"}