{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/15.integer-searching", "content": "Problem:\n    given a set of n integers\n    perform dictionary lookups, successor and predecessor queries\n    standard assumption: random access machine with word size w\n\tall integers are in the range 0 .. U=2^w-1\n\tinteger arithmetic operations take time O(1) each\n\t\t(some work here:\n\t\taddition, booleans vs multiplication, division\n\t\textra operations available on some hardware e.g. P4)\n\n\tbalanced binary search tree\n\t\tO(log n) per operation\n\n\thash table\n\t\tO(1) but can't do successor/predecessor\n\nvan emde Boaz flat trees 1977: O(log log U)\n\t(so good when wordsize small, less good for longer words)\n\nFredman and Willard fusion trees, STOC 1990\n    O(log n / log log n)\n\nexponential search trees\n\tAndersson, FOCS 1996\n\tBeame and Fich, STOC 1999\n\tAndersson and Thorup, STOC 2000\n    O(sqrt(log n / log log n))\n\t[tight due to lower bounds of Beame and Fich]\n\nvarious related methods e.g. for priority queues,\npriority queues with increasing minimum value (e.g. Dijkstra),\nrandomization...\n\n\nflat trees\n\tflat tree on words of length w:\n\t\tsplit each word into first half and second half (w/2 each)\n\t\tform flat tree on first halves\n\t\tfor each first half present in the input:\n\t\t\t- build recursive flat tree of second halves\n\t\t\t- store first and last words w/that first half\n\t\thash table H[first half] -> recursive flat tree\n\n\tto search for e.g. succ(x):\n\t\tfind first half of x\n\t\tif x in H and x is before last word in H[x]:\n\t\t\trecursively search flat tree H[x]\n\t\telse\n\t\t\tsearch flat tree of first halves\n\t\t\treturn first word having search result as first half\n\n\tspace:\n\t\tlinear\n\ttime:\n\t\tT(w) = O(1) + T(w/2) = O(log w) = O(log log U)\n\n\nFredman-Willard main idea:\n\tbuild search structures for very small numbers of items\n\tuse those to build up to larger #s of items\n\nso: suppose you have k w-bit integers\n    conceptually:\n\tbuild compressed trie\n\tsearch it in the following strange way:\n\t\tat each node, look at single bit of query word\n\t\t\tto determine whether to go left or right\n\t\t    (ignoring other bits along compressed edges)\n\t\tonce we reach a leaf,\n\t\t    find xor(leaf word, query)\n\t\t    to find position of 1st divergence from trie path\n\t\t    => position of successor\n\n    how to do this quickly:\n\tleaf = hash[T,query&MASK]\n\twhere T = description of compressed trie topology\n\tMASK = k nonzero bits in the words you care about\n\n\tffo(leaf,query) => various strategies:\n\t\tfloating point normalize\n\t\tmachine instruction\n\t\tanother hash table\n\n    with hash table of size n (shared hash table for all copies of data struc)\n\tcan handle k=(log n)^epsilon\n\tquery = O(1)\n\nB-tree, B=k=(log n)^epsilon\n\t=> query time O(log n / loglog n)\n\n\nExponential search trees etc --\n   combine ideas from both approaches\n", "encoding": "ascii"}