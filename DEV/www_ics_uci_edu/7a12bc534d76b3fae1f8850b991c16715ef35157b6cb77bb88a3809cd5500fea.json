{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes991215.txt", "content": "WebDAV Advanced Collections Minutes December 15, 1999\n\nATTENDING: Judy Slein, Jason Crawford, Geoff Clemm, Chuck Fay\n\nDISCLAIMER: All decisions made by the design team are subject to review by \nthe WebDAV mailing list.\n\nLOGISTICS:\n\nNo meeting next week.\n\nJudy will finish the specs and submit them to Internet-Drafts this week.\nJim can then decide how to handle last calls for them.\n\nTHE BINDING SPEC\n\nLOOPS\nAny second thoughts on loops?\nGeoff: Allow the server to fail creation of loop. \nThis will make life easier for systems like Oracle's, which don't want to\nbe forced to allow creation of loops.\nGeoff would oppose forbidding cycles.  It would be too hard for him to\nprevent them.\nSo we have to allow servers to fail BIND requests that create loops, but\nnot force them to.\n\nOur original motive in saying that the server MUST allow loops was to\ninsure that clients knew what to expect.  We want to use MUST unless there\nis good reason not to.  We think there is good reason in this case.\nFlexibility is needed here.\n\nAgreed: Servers MAY fail BIND requests that would create loops.\n\nWe will not add a special error code for this case, but just use 409\nConflict (Judy will check whether that's the best available code).  We\nwant to be sure server implementers understand that they are allowed to\nfail a BIND request that would create a cycle, but are not required to\ndo so.\n\nATOMICITY\n\nJason's most recent note to Lisa should help people understand what we\nmeant by DELETE is atomic.  It's not anything to do with transactions,\nbut just that the definition of DELETE has the result that it is a simple,\nsingle-step operation.  It's just removing a single binding, even in the\ncase of deleting a collection.\nIt's critical in an environment with multiple bindings to individual\nresources that bindings to resources further down the hierarchy survive\na DELETE on one of their parent collections. The example in Jason's note \nshows why.\nWe have to pick a single semantics for DELETE on a collection.  It's\neither removing the binding to the collection, or removing the binding\nto that collection and to each of its descendents in the hierarchy. \nJason's example shows why it has to be just removing the binding to the\ncollection.\n\nChuck: Atomicity doesn't extend to garbage collection, right? This was\nan issue for Eric.\nGeoff: He wanted to change the protocol so that garbage collection would\nbe easier for his server.  Our earlier decision to let servers fail BIND\nrequests that would create cycles should help him with that.\n\nChuck: It looked as if Eric's position was that destruction of the\nresource should be atomic with the delete.\nGeoff: He thinks delete also involves removing weak bindings. We can't ask\nall servers to behave as his does.\n\nChuck:  We are saying that DELETE on a collection removes the top level \nbinding, and it's not allowed to remove any bindings below that. \nGeoff: Right. We don't want a delete at one uURL to cause deletes at\nother URLs.\n\nChuck: Jason's suggestion that you could treat a DELETE on a collection\nas a MOVE to another part of the namespace (like recycle bin) is really\nan implementation suggestion. It's a way of implementing the DELETE we \nhave in mind.  There has been no response to that suggestion yet.\nGeoff: There is nothing odd about the implementation of NTFS that should \nmake this difficult. It's just a question of whether they are wedded to a \ndifferent definition of DELETE.\nLisa said Exchange could bend on the definition.  It would mean additional\nwork, not that it can't be done.\n\nAgreed: We will keep our current definition of DELETE for now.\n\nLOCK / UNLOCK\nAgreed: We will not mention LOCK or UNLOCK in the binding spec.\n\nORDERING SPEC\n\nINCOMPLETE SPECIFICATION OF AN ORDERING\nCurrently the spec doesn't say what should happen if a client changes\nthe ordering semantics with ORDERPATCH but doesn't include instructions\nfor positioning all the collection members.\n\nChuck: The server has no way of knowing whether the client might have set\nthe positions first, then in a separate request set the semantics.\n\nWe say that if a collection is ordered, every member must appear in the \nordering exactly once.\n\nWhat if a collection changes from unordered to ordered, but the client\ndoesn't completely specify the positions of the members?\n\nAgreed: When ORDERPATCH sets the semantics, if it does not set the \nposition of any member, the server assigns the member a position.\n\nTRAVERSAL RULES\nThe spec currently says that the server is free to use whatever\ntraversal algorithm it likes.  So long as the members of an ordered\ncollection appear relative to each other in the right order, any other\nURIs in the hierarchy can be interleaved with them in the response.\n\nThis is not friendly to clients.  For them, it would be best to require\nbreadth-first traversal so that all members of a single collection would\nbe consecutive.\n\nIt's better for servers.  For different servers, different traversal\norders may be more efficient.\n\nWhy isn't this already an issue in RFC 2518? Are any clients doing\nDepth: infinity PROPFIND requests? Shouldn't RFC 2518 take a position on\nthis? As it is, clients can't predict the traversal algorithm a server\nwill use.\n\nChuck: We could add a header on PROPFIND: depth-first, breadth-first \nthat applies only to ordered collections.  It the header is not present,\nthe server uses whatever traversal order it likes.  This header would\nbe optional for servers to support.\nAre there any other headers in WebDAV that are optional for servers to\nsupport? (Judy find out.)\n\nChuck: It's puzzling that since the default of PROPFIND is Depth: infinity\nwe haven't heard complaints from client developers.  Are they not doing\nDepth: infinity PROPFINDs? \n\nGeoff: Would be happy to say the traversal must be breadth-first, but\ncan imagine others not accepting this.\n\nIf no one has complained yet about RFC 2518, they probably won't complain\nhere.  Clients can do Depth: 1 PROPFINDS if they don't want to cope with\na variety of traversal algorithms.\n\nChuck: It really is an issue for RFC 2518.  Add to the RFC 2518 issue\nlist if anyone cares about it.\n\nAgreed: We leave it up to the server to decide.  A note to client\nimplementers can suggest that they do Depth: 1 PROPFINDs.\n\n418 VS. 409\nNo strong opinions.  We'll remove the 418 status code, and use 409\ninstead.\n\nDEPENDENCIES ON BINDING SPEC\nAgreed: We'll revert to the RFC 2518 terminology to avoid dependency on\nthe binding spec.\n", "encoding": "ascii"}