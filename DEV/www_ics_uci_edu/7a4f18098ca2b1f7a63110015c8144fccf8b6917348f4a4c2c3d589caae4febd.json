{"url": "https://www.ics.uci.edu/~ejw/http-future/whitehead/http_pos_paper.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<html>\n\n<head>\n<title>Lessons from WebDAV for the Next Generation Web Infrastructure</title>\n</head>\n\n<body>\n\n<h1 ALIGN=\"CENTER\">Lessons from WebDAV for the Next Generation Web Infrastructure</h1>\n\n<p align=\"center\"><I><b>E. James Whitehead, Jr.</b><br>\nDepartment of Information and Computer Science<br>\nUniversity of California, Irvine<br>\nejw@ics.uci.edu </i></p>\n\n<h2>Abstract</h2>\n\n<p>The Web Distributed Authoring and Versioning (WebDAV) working group of the Internet\nEngineering Task Force (IETF) has extended the HyperText Transfer Protocol (HTTP) to\nsupport remote collaborative authoring of network resources of any media type. This\nprocess of extending HTTP exposed several weaknesses of HTTP in the domain of\ncollaborative authoring, notably in parameter marshalling, support for multi-resource\noperations, support for operating on hierarchies of resources, and status reporting. The\nneed to have built-in locking support was also identified. This paper describes these\nshortcomings of HTTP, and collects this experience in the form of requirements for the\nnext generation Web infrastructure. </p>\n\n<h2>1. Introduction</h2>\n\n<p>Propelled by the desire to complete the original vision of the Web as a medium for\ncollaboration in addition to its better known roles of information dissemination, in 1996\nthe Web Distributed Authoring and Versioning (WebDAV) working group [WebDAV][Whitehead,\n1997] adopted the goal of making distributed web authoring tools broadly interoperable and\nbegan work on extending the HyperText Transfer Protocol (HTTP) [Fielding et\nal.,1997].&nbsp; The WebDAV distributed authoring protocol [Goland et al., 1998] provides\nfacilities for: \n\n<ul>\n  <li><b>Properties:</b> The ability to create, remove, and query information about\n    Web pages, such as their author, creation date, etc.</li>\n  <li><b>Collections:</b> The ability to create sets of related documents and to\n    retrieve a hierarchical membership listing, similar to a directory listing in a\n    filesystem.</li>\n  <li><b>Locking:</b> Prevention of overwrite conflicts, a simple mechanism for\n    concurrency control.</li>\n  <li><b>Namespace operations:</b> The ability to copy and move Web resources and\n    hierarchies of Web resources.</li>\n</ul>\n\n<p>The process of extending HTTP to support remote collaborative authoring exposed several\nshortcomings in HTTP, notably in parameter marshalling, support for multi-resource\noperations, support for operating on hierarchies of resources, and error reporting. The\nneed to have built-in locking support was also identified.&nbsp; This paper describes\nthese shortcomings of HTTP, and collects this experience in the form of requirements for\nthe next generation Web infrastructure. In many cases, these requirements are a\nreformulation of the requirements found in the WebDAV&nbsp; requirements document [Slein\net al.,1998].</p>\n\n<h2>2. Parameter Marshalling</h2>\n\n<p>HTTP 1.x provides two ways of encoding parameter information for a particular HTTP\nmethod request: request headers and the request body.&nbsp; Similarly, response headers\nand the response body are the two ways an HTTP server can pass results back to a client.\n&nbsp; HTTP 1.x predominantly uses headers to transport parameters in a request message,\nexceptions being the PUT method, where the request body contains the entity being\nuploaded, and the POST method, which often contains form data, but which can carry any\ninformation.</p>\n\n<p>The WebDAV property methods, PROPPATCH and PROPFIND, first uncovered the limitations of\nHTTP headers. Within WebDAV, a property is a name, value pair where the name is a URI,\nproviding a decentralized namespace, and the value is well-formed XML [Bray, Paoli,\nSperberg-McQueen, 1998] of any length. A WebDAV property value can be in any of the ISO\n10646 [ISO 10646] character set encodings supported by XML, since property values are\noften human-readable. The PROPPATCH method allows the client to set and remove multiple\nproperties with a single method invocations, while PROPFIND may retrieve all properties\nand values, named properties and their values, or only the names of all defined\nproperties.&nbsp; The problem raised by these two methods is how best to marshal the\ninformation in a PROPPATCH request or PROPFIND result. </p>\n\n<p>HTTP headers proved inadequate for marshaling PROPPATCH requests due to their poor\ninternationalization support, and inefficiency handling large header values.&nbsp; Since\nHTTP headers do not have any support for encoding ISO 10646 character set information,\nWebDAV would have needed to develop additional encoding strategies for the ISO 10646\ncharacter set encodings supported by XML. Once such an encoding technique was developed,\nthere would still be problems with encoding long-length properties into HTTP headers.\n&nbsp; Although in theory HTTP headers do not have bounded length, poor HTTP\nimplementations have effectively limited HTTP headers to short lengths, with headers under\n254 characters having best results.&nbsp; While HTTP headers can be split into multiple\nheaders with the same name, this is inefficient since the header name is repeated multiple\ntimes.</p>\n\n<p>Due to the limitations of HTTP headers, PROPPATCH marshals its request parameters into\nwell-formed XML, which is submitted in the request body. XML has strong\ninternationalization support with its built-in support for multiple character set\nencodings, and has no length limits on XML element (hence WebDAV property) values. By\nplacing the XML into the request body, the unlimited length of the request body matches\nthe unlimited length of a well-formed XML stream. Furthermore, XML is extensible, allowing\nnew elements to be added in the middle of an XML stream, supporting future addition of\nWebDAV, or third-party elements into XML protocol elements, or XML property values.</p>\n\n<p>Based on the experience with properties, WebDAV developed a design rule for where to\nencode parameter information.&nbsp; As a rule of thumb, parameters are encoded in XML and\nsubmitted in the request entity body when they have unbounded length, when they may be\nshown to a human user and hence require encoding in an ISO 10646 character set, or when\nthere is a high expectation the parameters will require significant future extension.\n&nbsp; Otherwise, parameters are encoded in HTTP headers.</p>\n\n<p>The WebDAV experience with parameter marshalling leads to the following requirements\nfor the next generation Web infrastructure.</p>\n\n<p><b>Internationalizable marshalling:</b> It must be possible to marshal data\nencoded in any ISO 10646 character set encoding.</p>\n\n<p><b>Unlimited length marshalling:</b> It must be possible to marshal data of\nany length.</p>\n\n<p><b>Extensible marshalling syntax: </b>It must be possible to add new data\nitems to a marshaled data stream without affecting existing applications.</p>\n\n<h2>3. Multi-resource Operations</h2>\n\n<p>WebDAV supports COPY and MOVE methods for use in manipulating the namespace of Web\nresources.&nbsp; With both COPY and MOVE, the method is sent to the source resource, and\nthe destination is specified by the Destination header. Though this seems simple and\nstraightforward, there are several lurking difficulties. First, when a method affects two\nresources, should the precondition headers If-[None]-Match and If-Modified-Since apply to\nthe source resource, the destination resource, or both? WebDAV chose to have these headers\nonly apply to the source resource, and not to the destination resource.&nbsp; However,\nsince there is a need to specify a precondition which affects the source and/or the\ndestination resource, WebDAV specifies a new precondition header called &quot;If&quot;\nwhich allows a precondition to be matched to a named resource, and hence can specify\npreconditions against the source or the destination.</p>\n\n<p>The underlying difficulty is HTTP's lack of support for multi-resource operations.\n&nbsp; HTTP assumes an operation will only affect one resource, and provides no facilities\nfor stating that some headers apply to one resource, while other headers apply to another.\n&nbsp; This leads to headers like the WebDAV &quot;Overwrite&quot; header which is\nexplicitly defined to control overwriting of the destination resource.&nbsp; As a result,\na MOVE or COPY can have some headers which apply just to the source (If-Match), to just\nthe destination (Overwrite), and to both the source and the destination (If).</p>\n\n<p>The WebDAV experience with multi-resource operations leads to the following\nrequirements:</p>\n\n<p><b>Multi-resource operations:</b> It must be possible to support operations\nwhich affect two or more resources.&nbsp; It must be possible to specify pairings of\nindividual parameters to individual resources.</p>\n\n<p><b>Multi-resource preconditions:</b> It must be possible to specify operation\npreconditions which operate over several resources.</p>\n\n<h2>4. Operations on Resource Hierarchies</h2>\n\n<p>One important efficiency optimization in the design of WebDAV is the ability to specify\ncopy, move, property retrieval, or locking over an entire hierarchy with a single method\ninvocation. Using the Depth header, the semantics of COPY, MOVE, PROPFIND, and LOCK can be\nmodified to affect only the requested resource, a depth of 0, or a requested collection\nand all of its children, and their children, etc., with a depth of infinity. PROPFIND\nalone supports Depth 1 semantics, specifying the retrieval of properties on a collection\nand its children, but not its children's children. </p>\n\n<p>The semantics of a depth infinity COPY, MOVE and PROPFIND are defined using a\npropagation model, with the initial method invocation being passed to a collection, which\nthen rewrites the Destination header before propagating the original method invocation\nwith all the original headers (excepting the rewritten Destination) and the original\nrequest body along to its children. By definition, the action of depth infinity COPY,\nMOVE, and PROPFIND operations are are best-effort, and non-atomic.&nbsp; Thus, an error in\nthe middle of a tree copy does not cause a complete rollback of the copy, nor does such an\nerror necessarily cause a halt to the copy operation. These semantics make it much easier\nto implement tree operations, as they do not require a transaction engine to be present in\nthe server to implement a rollback. </p>\n\n<p>Since the semantics for COPY, MOVE, and PROPFIND are non-transactional, it would be\npossible to achieve the same result as a depth infinity operation by sending a pipelined\nstream of COPY, MOVE, or PROPFIND requests, one for each individual resource in the\ncollection hierarchy. &nbsp; However, such an approach suffers from significant\nperformance penalties due to having to first retrieve the membership of the collection\nhierarchy, and the overhead of re-specifying essentially the same request once for each\nresource in the hierarchy. </p>\n\n<p>As an exception to the best-effort semantics for tree operations, tree locks have all\nor nothing semantics; either the entire tree is successfully locked, or the tree lock\nfails. Since the lock does not change the state of the body of the resource, it is easier\nto implement the rollback for locking. However, due to their all or nothing semantics,\ntree locks cannot be specified using a stream of pipelined individual requests. This\nability to specify all or nothing tree semantics provides one more reason, in addition to\nthe efficiency argument, for supporting operations which act on hierarchies of resources.</p>\n\n<p>As is the case for multi-resource operations, supporting hierarchy operations is\ndifficult because of the HTTP assumption that operations only affect a single\nresource.&nbsp; Like the multi-resource case, precondition operations are difficult to\nspecify for tree operations. There is a need to specify both a precondition which affects\nthe entire hierarchy, and a precondition which only affects individual resources in the\nhierarchy. For example, since a single resource deep in a hierarchy might be individually\nlocked, there is a need to pass a lock token to that resource for a tree move. A client\nmight also want to ensure the tree operation only takes place if all the resources are in\na state known to the client, requiring submission of multiple URI, entity-tag pairs.&nbsp;\nWebDAV supports both these precondition types with its If header.</p>\n\n<p>Hierarchy operations become more complex when they are combined with multi-resource\noperations, as with a tree copy and move, where there is a source hierarchy and a\ndestination hierarchy. Ideally it would be possible to specify parameters which affect\neither the entire source hierarchy or the entire destination hierarchy, and then also\nspecify individual exceptions to these parameters (e.g., overwrite all destinations,\nexcept for foo.html). However, since HTTP does not provide marshalling support for\nhierarchy operations, the best that can be accomplished using HTTP is to specify\nparameters which affect all resources, with no individual exceptions.</p>\n\n<p>WebDAV hierarchy operations suggest the following requirements for the next generation\nWeb infrastructure:</p>\n\n<p><b>Hierarchy support:</b> It must be possible to support operations which\noperate over a hierarchy of resources. Specifically, support is needed for operations\nwhich affect a collection and its children, and for operations which affect a collection,\nit's children, and it's children's children, etc.</p>\n\n<p><b>Marshalling support for hierarchies:</b> It must be possible to support\nparameter to hierarchy mappings, and parameter to resource mappings.</p>\n\n<p><b>Hierarchy preconditions: </b>It must be possible to specify preconditions\nwhich affect an entire hierarchy.</p>\n\n<h2>5. Status Reporting</h2>\n\n<p>WebDAV extended the HTTP object model by adding properties to each resource, and by\ndefining a collection resource type. Both of these extensions affect HTTP status\nreporting.&nbsp; By adding properties, status reports must now be capable of\ndistinguishing between status which describes the whole resource on which properties are\ndefined, and status which describes just a single property on a resource.</p>\n\n<p>By defining collections, and hierarchy operations which operate over collections,\nstatus reports must now be capable of reporting success and failure across multiple\nresources. Additionally, since it is possible to specify a depth infinity PROPFIND, status\nreports must be capable of distinguishing between property-scoped status and\nresource-scoped status within the same status response.</p>\n\n<p>Since HTTP only supports status reporting for a single resource, WebDAV created a\nmulti-status response to meet its status reports needs. With the multi-status response,\nresource-scope and property-scope status responses are wrapped inside an XML response\nbody.</p>\n\n<p>Support for multi-resource operations exacerbates an existing problem with HTTP error\nreporting when there are multiple, simultaneous error conditions. For example, in the case\nwhere a destination resource is locked, it is possible for a client to simultaneously not\nhave write access permission to the resource, and also not be the owner of the lock. In\nthis case, both a locked response and an access denied response are acceptable.\nAdditionally, since there is a source as well as a destination, the client could submit a\nprecondition against the source which might also fail, leading to situations where there\nare many simultaneous error conditions. At present, since only one error message may be\nreported even though many error conditions might exist, and since it is server-specific as\nto which error condition is reported first, it is difficult for a client to do anything\nintelligent with the error messages. The addition of error precedence rules would aid\nclient error processing.</p>\n\n<p>The requirements which emerge from a consideration of status reporting are:</p>\n\n<p><b>Property status:</b> It must be possible to report status with a single\nproperty scope.</p>\n\n<p><b>Hierarchy status: </b>It must be possible to report status from a\nhierarchy operation where the results of multiple individual operations are collected into\na single response.</p>\n\n<p><b>Combined scope:</b> It must be possible to report property-scoped and\nresource-scoped status in a single and hierarchy response.</p>\n\n<p><b>Precedence rules:</b> There must be rules for determining which status\nmessage to report in cases where multiple simultaneous status messages apply.</p>\n\n<h2>6. Built-in Lock Support</h2>\n\n<p>One of the conclusions of the WebDAV effort is that locking support must be a core\nfacility. Since locking was added to HTTP after the write operation, PUT, was defined, it\nis now possible to have situations where overwrite conflicts occur when a resource is\nsimultaneously being edited by a WebDAV and an HTTP (i.e., non-lock aware authoring\nclient). Consider the following scenario:</p>\n\n<p>Two clients A and B are interested in editing the resource 'index.html'. Client A is an\nHTTP client rather than a WebDAV client, and so does not know how to perform locking. To\nbegin, client A doesn't lock the document, but does a GET and begins editing. Later,\nclient B does LOCK, performs a GET and begins editing. Client B finishes editing before\nclient A, performs a PUT, then does an UNLOCK. Later, client A performs a PUT, overwriting\nand losing all of B's changes. </p>\n\n<p>There are several reasons why the WebDAV protocol itself cannot prevent this situation.\nFirst, it cannot force all clients to use locking because it must be compatible with HTTP\nclients that do not comprehend locking. Second, it cannot require servers to support\nlocking because of the variety of repository implementations, some of which rely on\nreservations and merging rather than on locking. Finally, being stateless, it cannot\nenforce a sequence of operations like LOCK / GET / PUT / UNLOCK. </p>\n\n<p>There are several techniques which can be applied to mitigate this problem: \n\n<ul>\n  <li>WebDAV servers that support locking can reduce the likelihood that clients will\n    accidentally overwrite each other's changes by requiring clients to lock resources before\n    modifying them. Such servers would effectively prevent HTTP 1.0 and HTTP 1.1 clients from\n    modifying resources. </li>\n  <li>WebDAV clients can be good citizens by using a lock / retrieve / write /unlock sequence\n    of operations (at least by default) whenever they interact with a WebDAV server that\n    supports locking. </li>\n  <li>HTTP 1.1 clients can be good citizens, avoiding overwriting other clients' changes, by\n    using entity tags in If-Match headers with any requests that would modify resources. </li>\n</ul>\n\n<p>The WebDAV experience with locking leads to the following requirement:</p>\n\n<p><b>Core overwrite prevention:</b> Facilities for the prevention of overwrite\nconflicts must be an integral part of the protocol. All authoring clients must make use of\nthe overwrite prevention facilities.</p>\n\n<h2>7. Conclusion</h2>\n\n<p>By extending the HTTP data model with properties and collections, by supporting\noperations with a source and a destination, and by supporting operations which operate on\nan hierarchy of resources, WebDAV exposed several shortcomings in HTTP's support for\nremote collaborative authoring.&nbsp; This paper has discussed these shortcomings in the\nareas of parameter marshalling, precondition support, and status reporting for single\nproperties, single resources, multiple resources, and hierarchies of resources. The need\nfor core support of overwrite prevention was also identified. In order to concisely convey\nthe experience gained from the WebDAV project, the paper has listed requirements for the\nnext generation Web infrastructure.</p>\n\n<h2>References</h2>\n\n<p><b>[Bray, Paoli, Sperberg-McQueen, 1998]</b> T. Bray, J. Paoli, C. M.\nSperberg-McQueen, &quot;Extensible Markup Language (XML).&quot; World Wide Web Consortium\nRecommendation REC-xml-19980210. http://www.w3.org/TR/1998/REC-xml-19980210.</p>\n\n<p><b>[Fielding et al., 1997]</b> R. Fielding, J. Gettys, J. Mogul, H. Frystyk,\nT. Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1.&quot; RFC 2068. U.C.\nIrvine, DEC, MIT/LCS. January, 1997. </p>\n\n<p><b>[Goland et al., 1998] </b>Y. Y. Goland, E. J. Whitehead, Jr., A. Faizi,\nS.R. Carter, D. Jensen, &quot;Extensions for Distributed Authoring on the World Wide Web\n-- WEBDAV.&quot; draft-ietf-webdav-protocol-08, Internet-Draft, work-in-progress.\nMicrosoft, U.C. Irvine, Netscape, Novell. April, 1998.</p>\n\n<p><b>[ISO 10646]</b> ISO (International Organization for Standardization).\nISO/IEC 10646-1993 (E). Information technology -- Universal Multiple-Octet Coded Character\nSet (UCS) -- Part 1: Architecture and Basic Multilingual Plane. [Geneva]: International\nOrganization for Standardization, 1993 (plus amendments AM 1 through AM 7). </p>\n\n<p><b>[Slein et al., 1998]</b> J. A. Slein, F. Vitali, E. J. Whitehead, Jr., D.\nDurand, &quot;Requirements for Distributed Authoring and Versioning Protocol for the World\nWide Web.&quot; RFC 2291. Xerox, Univ. of Bologna, U.C. Irvine, Boston Univ. February,\n1998.</p>\n\n<p><b>[WebDAV]</b> WebDAV Home Page. <a\nhref=\"http://www.ics.uci.edu/pub/ietf/webdav/\">http://www.ics.uci.edu/pub/ietf/webdav/</a></p>\n\n<p><b>[Whitehead, 1997]</b> E. J. Whitehead, Jr. &quot;World Wide Web\nDistributed Authoring and Versioning (WEBDAV) -- An Introduction.&quot; ACM StandardView,\nVol 5., No. 1, March 1997, p. 3-8.</p>\n</body>\n</html>\n", "encoding": "ascii"}