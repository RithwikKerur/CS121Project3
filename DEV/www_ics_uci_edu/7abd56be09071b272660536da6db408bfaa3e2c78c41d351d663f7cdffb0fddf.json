{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_3.html#SEC37", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Project 1--Threads</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Project 1--Threads\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Project 1--Threads\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC25\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_2.html#SEC15\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_4.html#SEC42\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> 3. Project 1: Threads </H1>\n<!--docid::SEC25::-->\n<P>\n\nIn this assignment, we give you a minimally functional thread system.\nYour job is to extend the functionality of this system to gain a\nbetter understanding of synchronization problems.\n</P>\n<P>\n\nYou will be working primarily in the <Q><TT>threads</TT></Q> directory for\nthis assignment, with some work in the <Q><TT>devices</TT></Q> directory on the\nside.  Compilation should be done in the <Q><TT>threads</TT></Q> directory.\n</P>\n<P>\n\nBefore you read the description of this project, you should read all of\nthe following sections: <A HREF=\"pintos_1.html#SEC1\">1. Introduction</A>, <A HREF=\"pintos_9.html#SEC148\">C. Coding Standards</A>,\n<A HREF=\"pintos_11.html#SEC155\">E. Debugging Tools</A>, and <A HREF=\"pintos_12.html#SEC168\">F. Development Tools</A>.  You should at least\nskim the material from <A HREF=\"pintos_7.html#SEC101\">A.1 Loading</A> through <A HREF=\"pintos_7.html#SEC121\">A.5 Memory Allocation</A>, especially <A HREF=\"pintos_7.html#SEC110\">A.3 Synchronization</A>.  To complete this project\nyou will also need to read <A HREF=\"pintos_8.html#SEC141\">B. 4.4<ACRONYM>BSD</ACRONYM> Scheduler</A>.\n</P>\n<P>\n\n<A NAME=\"Project 1 Background\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC26\"></A>\n<H2> 3.1 Background </H2>\n<!--docid::SEC26::-->\n<P>\n\n<A NAME=\"Understanding Threads\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC27\"></A>\n<H3> 3.1.1 Understanding Threads </H3>\n<!--docid::SEC27::-->\n<P>\n\nThe first step is to read and understand the code for the initial thread\nsystem.\nPintos already implements thread creation and thread completion,\na simple scheduler to switch between threads, and synchronization\nprimitives (semaphores, locks, condition variables, and optimization\nbarriers).\n</P>\n<P>\n\nSome of this code might seem slightly mysterious.  If\nyou haven't already compiled and run the base system, as described in\nthe introduction (see section <A HREF=\"pintos_1.html#SEC1\">1. Introduction</A>), you should do so now.  You\ncan read through parts of the source code to see what's going\non.  If you like, you can add calls to <CODE>printf()</CODE> almost\nanywhere, then recompile and run to see what happens and in what\norder.  You can also run the kernel in a debugger and set breakpoints\nat interesting spots, single-step through code and examine data, and\nso on.\n</P>\n<P>\n\nWhen a thread is created, you are creating a new context to be\nscheduled.  You provide a function to be run in this context as an\nargument to <CODE>thread_create()</CODE>.  The first time the thread is\nscheduled and runs, it starts from the beginning of that function\nand executes in that context.  When the function returns, the thread\nterminates.  Each thread, therefore, acts like a mini-program running\ninside Pintos, with the function passed to <CODE>thread_create()</CODE>\nacting like <CODE>main()</CODE>.\n</P>\n<P>\n\nAt any given time, exactly one thread runs and the rest, if any,\nbecome inactive.  The scheduler decides which thread to\nrun next.  (If no thread is ready to run\nat any given time, then the special &quot;idle&quot; thread, implemented in\n<CODE>idle()</CODE>, runs.)\nSynchronization primitives can force context switches when one\nthread needs to wait for another thread to do something.\n</P>\n<P>\n\nThe mechanics of a context switch are\nin <Q><TT>threads/switch.S</TT></Q>, which is 80<VAR>x</VAR>86\nassembly code.  (You don't have to understand it.)  It saves the\nstate of the currently running thread and restores the state of the\nthread we're switching to.\n</P>\n<P>\n\nUsing the GDB debugger, slowly trace through a context\nswitch to see what happens (see section <A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A>).  You can set a\nbreakpoint on <CODE>schedule()</CODE> to start out, and then\nsingle-step from there.<A NAME=\"DOCF1\" HREF=\"pintos_fot.html#FOOT1\">(1)</A>  Be sure\nto keep track of each thread's address\nand state, and what procedures are on the call stack for each thread.\nYou will notice that when one thread calls <CODE>switch_threads()</CODE>,\nanother thread starts running, and the first thing the new thread does\nis to return from <CODE>switch_threads()</CODE>.  You will understand the thread\nsystem once you understand why and how the <CODE>switch_threads()</CODE> that\ngets called is different from the <CODE>switch_threads()</CODE> that returns.\nSee section <A HREF=\"pintos_7.html#SEC109\">A.2.3 Thread Switching</A>, for more information.\n</P>\n<P>\n\n<STRONG>Warning</STRONG>: In Pintos, each thread is assigned a small,\nfixed-size execution stack just under 4 kB in size.  The kernel\ntries to detect stack overflow, but it cannot do so perfectly.  You\nmay cause bizarre problems, such as mysterious kernel panics, if you\ndeclare large data structures as non-static local variables,\ne.g. <Q><SAMP>int buf[1000];</SAMP></Q>.  Alternatives to stack allocation include\nthe page allocator and the block allocator (see section <A HREF=\"pintos_7.html#SEC121\">A.5 Memory Allocation</A>).\n</P>\n<P>\n\n<A NAME=\"Project 1 Source Files\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC28\"></A>\n<H3> 3.1.2 Source Files </H3>\n<!--docid::SEC28::-->\n<P>\n\nHere is a brief overview of the files in the <Q><TT>threads</TT></Q>\ndirectory.  You will not need to modify most of this code, but the\nhope is that presenting this overview will give you a start on what\ncode to look at.\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>loader.S</TT></Q>\n<DD><DT><Q><TT>loader.h</TT></Q>\n<DD>The kernel loader.  Assembles to 512 bytes of code and data that the\nPC BIOS loads into memory and which in turn finds the kernel on disk,\nloads it into memory, and jumps to <CODE>start()</CODE> in <Q><TT>start.S</TT></Q>.\nSee section <A HREF=\"pintos_7.html#SEC102\">A.1.1 The Loader</A>, for details.  You should not need to look at\nthis code or modify it.\n<P>\n\n</P>\n<DT><Q><TT>start.S</TT></Q>\n<DD>Does basic setup needed for memory protection and 32-bit\noperation on 80<VAR>x</VAR>86 CPUs.  Unlike the loader, this code is\nactually part of the kernel.  See section <A HREF=\"pintos_7.html#SEC103\">A.1.2 Low-Level Kernel Initialization</A>,\nfor details.\n<P>\n\n</P>\n<DT><Q><TT>kernel.lds.S</TT></Q>\n<DD>The linker script used to link the kernel.  Sets the load address of\nthe kernel and arranges for <Q><TT>start.S</TT></Q> to be near the beginning\nof the kernel image.  See section <A HREF=\"pintos_7.html#SEC102\">A.1.1 The Loader</A>, for details. Again, you\nshould not need to look at this code\nor modify it, but it's here in case you're curious.\n<P>\n\n</P>\n<DT><Q><TT>init.c</TT></Q>\n<DD><DT><Q><TT>init.h</TT></Q>\n<DD>Kernel initialization, including <CODE>main()</CODE>, the kernel's &quot;main\nprogram.&quot;  You should look over <CODE>main()</CODE> at least to see what\ngets initialized.  You might want to add your own initialization code\nhere.  See section <A HREF=\"pintos_7.html#SEC104\">A.1.3 High-Level Kernel Initialization</A>, for details.\n<P>\n\n</P>\n<DT><Q><TT>thread.c</TT></Q>\n<DD><DT><Q><TT>thread.h</TT></Q>\n<DD>Basic thread support.  Much of your work will take place in these files.\n<Q><TT>thread.h</TT></Q> defines <CODE>struct thread</CODE>, which you are likely to modify\nin all four projects.  See <A HREF=\"pintos_7.html#SEC107\">A.2.1 <CODE>struct thread</CODE></A> and <A HREF=\"pintos_7.html#SEC106\">A.2 Threads</A> for\nmore information.\n<P>\n\n</P>\n<DT><Q><TT>switch.S</TT></Q>\n<DD><DT><Q><TT>switch.h</TT></Q>\n<DD>Assembly language routine for switching threads.  Already discussed\nabove.  See section <A HREF=\"pintos_7.html#SEC108\">A.2.2 Thread Functions</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>palloc.c</TT></Q>\n<DD><DT><Q><TT>palloc.h</TT></Q>\n<DD>Page allocator, which hands out system memory in multiples of 4 kB\npages.  See section <A HREF=\"pintos_7.html#SEC122\">A.5.1 Page Allocator</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>malloc.c</TT></Q>\n<DD><DT><Q><TT>malloc.h</TT></Q>\n<DD>A simple implementation of <CODE>malloc()</CODE> and <CODE>free()</CODE> for\nthe kernel.  See section <A HREF=\"pintos_7.html#SEC123\">A.5.2 Block Allocator</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>interrupt.c</TT></Q>\n<DD><DT><Q><TT>interrupt.h</TT></Q>\n<DD>Basic interrupt handling and functions for turning interrupts on and\noff.  See section <A HREF=\"pintos_7.html#SEC117\">A.4 Interrupt Handling</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>intr-stubs.S</TT></Q>\n<DD><DT><Q><TT>intr-stubs.h</TT></Q>\n<DD>Assembly code for low-level interrupt handling.  See section <A HREF=\"pintos_7.html#SEC118\">A.4.1 Interrupt Infrastructure</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>synch.c</TT></Q>\n<DD><DT><Q><TT>synch.h</TT></Q>\n<DD>Basic synchronization primitives: semaphores, locks, condition\nvariables, and optimization barriers.  You will need to use these for\nsynchronization in all\nfour projects.  See section <A HREF=\"pintos_7.html#SEC110\">A.3 Synchronization</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>io.h</TT></Q>\n<DD>Functions for I/O port access.  This is mostly used by source code in\nthe <Q><TT>devices</TT></Q> directory that you won't have to touch.\n<P>\n\n</P>\n<DT><Q><TT>vaddr.h</TT></Q>\n<DD><DT><Q><TT>pte.h</TT></Q>\n<DD>Functions and macros for working with virtual addresses and page table\nentries.  These will be more important to you in project 3.  For now,\nyou can ignore them.\n<P>\n\n</P>\n<DT><Q><TT>flags.h</TT></Q>\n<DD>Macros that define a few bits in the 80<VAR>x</VAR>86 &quot;flags&quot; register.\nProbably of no interest.  See [ <A HREF=\"pintos_14.html#IA32-v1\">IA32-v1</A>], section 3.4.3, &quot;EFLAGS\nRegister,&quot; for more information.\n</DL>\n<P>\n\n<A NAME=\"devices code\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC29\"></A>\n<H4> 3.1.2.1 <Q><TT>devices</TT></Q> code </H4>\n<!--docid::SEC29::-->\n<P>\n\nThe basic threaded kernel also includes these files in the\n<Q><TT>devices</TT></Q> directory:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>timer.c</TT></Q>\n<DD><DT><Q><TT>timer.h</TT></Q>\n<DD>System timer that ticks, by default, 100 times per second.  You will\nmodify this code in this project.\n<P>\n\n</P>\n<DT><Q><TT>vga.c</TT></Q>\n<DD><DT><Q><TT>vga.h</TT></Q>\n<DD>VGA display driver.  Responsible for writing text to the screen.\nYou should have no need to look at this code.  <CODE>printf()</CODE>\ncalls into the VGA display driver for you, so there's little reason to\ncall this code yourself.\n<P>\n\n</P>\n<DT><Q><TT>serial.c</TT></Q>\n<DD><DT><Q><TT>serial.h</TT></Q>\n<DD>Serial port driver.  Again, <CODE>printf()</CODE> calls this code for you,\nso you don't need to do so yourself.\nIt handles serial input by passing it to the input layer (see below).\n<P>\n\n</P>\n<DT><Q><TT>block.c</TT></Q>\n<DD><DT><Q><TT>block.h</TT></Q>\n<DD>An abstraction layer for <EM>block devices</EM>, that is, random-access,\ndisk-like devices that are organized as arrays of fixed-size blocks.\nOut of the box, Pintos supports two types of block devices: IDE disks\nand partitions.  Block devices, regardless of type, won't actually be\nused until project 2.\n<P>\n\n</P>\n<DT><Q><TT>ide.c</TT></Q>\n<DD><DT><Q><TT>ide.h</TT></Q>\n<DD>Supports reading and writing sectors on up to 4 IDE disks.\n<P>\n\n</P>\n<DT><Q><TT>partition.c</TT></Q>\n<DD><DT><Q><TT>partition.h</TT></Q>\n<DD>Understands the structure of partitions on disks, allowing a single\ndisk to be carved up into multiple regions (partitions) for\nindependent use.\n<P>\n\n</P>\n<DT><Q><TT>kbd.c</TT></Q>\n<DD><DT><Q><TT>kbd.h</TT></Q>\n<DD>Keyboard driver.  Handles keystrokes passing them to the input layer\n(see below).\n<P>\n\n</P>\n<DT><Q><TT>input.c</TT></Q>\n<DD><DT><Q><TT>input.h</TT></Q>\n<DD>Input layer.  Queues input characters passed along by the keyboard or\nserial drivers.\n<P>\n\n</P>\n<DT><Q><TT>intq.c</TT></Q>\n<DD><DT><Q><TT>intq.h</TT></Q>\n<DD>Interrupt queue, for managing a circular queue that both kernel\nthreads and interrupt handlers want to access.  Used by the keyboard\nand serial drivers.\n<P>\n\n</P>\n<DT><Q><TT>rtc.c</TT></Q>\n<DD><DT><Q><TT>rtc.h</TT></Q>\n<DD>Real-time clock driver, to enable the kernel to determine the current\ndate and time.  By default, this is only used by <Q><TT>thread/init.c</TT></Q>\nto choose an initial seed for the random number generator.\n<P>\n\n</P>\n<DT><Q><TT>speaker.c</TT></Q>\n<DD><DT><Q><TT>speaker.h</TT></Q>\n<DD>Driver that can produce tones on the PC speaker.\n<P>\n\n</P>\n<DT><Q><TT>pit.c</TT></Q>\n<DD><DT><Q><TT>pit.h</TT></Q>\n<DD>Code to configure the 8254 Programmable Interrupt Timer.  This code is\nused by both <Q><TT>devices/timer.c</TT></Q> and <Q><TT>devices/speaker.c</TT></Q>\nbecause each device uses one of the PIT's output channel.\n</DL>\n<P>\n\n<A NAME=\"lib files\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC30\"></A>\n<H4> 3.1.2.2 <Q><TT>lib</TT></Q> files </H4>\n<!--docid::SEC30::-->\n<P>\n\nFinally, <Q><TT>lib</TT></Q> and <Q><TT>lib/kernel</TT></Q> contain useful library\nroutines.  (<Q><TT>lib/user</TT></Q> will be used by user programs, starting in\nproject 2, but it is not part of the kernel.)  Here's a few more\ndetails:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>ctype.h</TT></Q>\n<DD><DT><Q><TT>inttypes.h</TT></Q>\n<DD><DT><Q><TT>limits.h</TT></Q>\n<DD><DT><Q><TT>stdarg.h</TT></Q>\n<DD><DT><Q><TT>stdbool.h</TT></Q>\n<DD><DT><Q><TT>stddef.h</TT></Q>\n<DD><DT><Q><TT>stdint.h</TT></Q>\n<DD><DT><Q><TT>stdio.c</TT></Q>\n<DD><DT><Q><TT>stdio.h</TT></Q>\n<DD><DT><Q><TT>stdlib.c</TT></Q>\n<DD><DT><Q><TT>stdlib.h</TT></Q>\n<DD><DT><Q><TT>string.c</TT></Q>\n<DD><DT><Q><TT>string.h</TT></Q>\n<DD>A subset of the standard C library.  See section <A HREF=\"pintos_9.html#SEC150\">C.2 C99</A>, for\ninformation\non a few recently introduced pieces of the C library that you might\nnot have encountered before.  See section <A HREF=\"pintos_9.html#SEC151\">C.3 Unsafe String Functions</A>, for\ninformation on what's been intentionally left out for safety.\n<P>\n\n</P>\n<DT><Q><TT>debug.c</TT></Q>\n<DD><DT><Q><TT>debug.h</TT></Q>\n<DD>Functions and macros to aid debugging.  See section <A HREF=\"pintos_11.html#SEC155\">E. Debugging Tools</A>, for\nmore information.\n<P>\n\n</P>\n<DT><Q><TT>random.c</TT></Q>\n<DD><DT><Q><TT>random.h</TT></Q>\n<DD>Pseudo-random number generator.  The actual sequence of random values\nwill not vary from one Pintos run to another, unless you do one of\nthree things: specify a new random seed value on the <Q><SAMP>-rs</SAMP></Q>\nkernel command-line option on each run, or use a simulator other than\nBochs, or specify the <Q><SAMP>-r</SAMP></Q> option to <CODE>pintos</CODE>.\n<P>\n\n</P>\n<DT><Q><TT>round.h</TT></Q>\n<DD>Macros for rounding.\n<P>\n\n</P>\n<DT><Q><TT>syscall-nr.h</TT></Q>\n<DD>System call numbers.  Not used until project 2.\n<P>\n\n</P>\n<DT><Q><TT>kernel/list.c</TT></Q>\n<DD><DT><Q><TT>kernel/list.h</TT></Q>\n<DD>Doubly linked list implementation.  Used all over the Pintos code, and\nyou'll probably want to use it a few places yourself in project 1.\n<P>\n\n</P>\n<DT><Q><TT>kernel/bitmap.c</TT></Q>\n<DD><DT><Q><TT>kernel/bitmap.h</TT></Q>\n<DD>Bitmap implementation.  You can use this in your code if you like, but\nyou probably won't have any need for it in project 1.\n<P>\n\n</P>\n<DT><Q><TT>kernel/hash.c</TT></Q>\n<DD><DT><Q><TT>kernel/hash.h</TT></Q>\n<DD>Hash table implementation.  Likely to come in handy for project 3.\n<P>\n\n</P>\n<DT><Q><TT>kernel/console.c</TT></Q>\n<DD><DT><Q><TT>kernel/console.h</TT></Q>\n<DD><DT><Q><TT>kernel/stdio.h</TT></Q>\n<DD>Implements <CODE>printf()</CODE> and a few other functions.\n</DL>\n<P>\n\n<A NAME=\"Project 1 Synchronization\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC31\"></A>\n<H3> 3.1.3 Synchronization </H3>\n<!--docid::SEC31::-->\n<P>\n\nProper synchronization is an important part of the solutions to these\nproblems.  Any synchronization problem can be easily solved by turning\ninterrupts off: while interrupts are off, there is no concurrency, so\nthere's no possibility for race conditions.  Therefore, it's tempting to\nsolve all synchronization problems this way, but <STRONG>don't</STRONG>.\nInstead, use semaphores, locks, and condition variables to solve the\nbulk of your synchronization problems.  Read the tour section on\nsynchronization (see section <A HREF=\"pintos_7.html#SEC110\">A.3 Synchronization</A>) or the comments in\n<Q><TT>threads/synch.c</TT></Q> if you're unsure what synchronization primitives\nmay be used in what situations.\n</P>\n<P>\n\nIn the Pintos projects, the only class of problem best solved by\ndisabling interrupts is coordinating data shared between a kernel thread\nand an interrupt handler.  Because interrupt handlers can't sleep, they\ncan't acquire locks.  This means that data shared between kernel threads\nand an interrupt handler must be protected within a kernel thread by\nturning off interrupts.\n</P>\n<P>\n\nThis project only requires accessing a little bit of thread state from\ninterrupt handlers.  For the alarm clock, the timer interrupt needs to\nwake up sleeping threads.  In the advanced scheduler, the timer\ninterrupt needs to access a few global and per-thread variables.  When\nyou access these variables from kernel threads, you will need to disable\ninterrupts to prevent the timer interrupt from interfering.\n</P>\n<P>\n\nWhen you do turn off interrupts, take care to do so for the least amount\nof code possible, or you can end up losing important things such as\ntimer ticks or input events.  Turning off interrupts also increases the\ninterrupt handling latency, which can make a machine feel sluggish if\ntaken too far.\n</P>\n<P>\n\nThe synchronization primitives themselves in <Q><TT>synch.c</TT></Q> are\nimplemented by disabling interrupts.  You may need to increase the\namount of code that runs with interrupts disabled here, but you should\nstill try to keep it to a minimum.\n</P>\n<P>\n\nDisabling interrupts can be useful for debugging, if you want to make\nsure that a section of code is not interrupted.  You should remove\ndebugging code before turning in your project.  (Don't just comment it\nout, because that can make the code difficult to read.)\n</P>\n<P>\n\nThere should be no busy waiting in your submission.  A tight loop that\ncalls <CODE>thread_yield()</CODE> is one form of busy waiting.\n</P>\n<P>\n\n<A NAME=\"Development Suggestions\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC32\"></A>\n<H3> 3.1.4 Development Suggestions </H3>\n<!--docid::SEC32::-->\n<P>\n\nIn the past, many groups divided the assignment into pieces, then each\ngroup member worked on his or her piece until just before the\ndeadline, at which time the group reconvened to combine their code and\nsubmit.  <STRONG>This is a bad idea.  We do not recommend this\napproach.</STRONG>  Groups that do this often find that two changes conflict\nwith each other, requiring lots of last-minute debugging.  Some groups\nwho have done this have turned in code that did not even compile or\nboot, much less pass any tests.\n</P>\n<P>\n\nInstead, we recommend integrating your team's changes early and often,\nusing a source code control system such as Git (see section <A HREF=\"pintos_12.html#SEC171\">F.3 Git</A>).\nThis is less likely to produce surprises, because everyone can see\neveryone else's code as it is written, instead of just when it is\nfinished.  These systems also make it possible to review changes and,\nwhen a change introduces a bug, drop back to working versions of code.\n</P>\n<P>\n\nYou should expect to run into bugs that you simply don't understand\nwhile working on this and subsequent projects.  When you do,\nreread the appendix on debugging tools, which is filled with\nuseful debugging tips that should help you to get back up to speed\n(see section <A HREF=\"pintos_11.html#SEC155\">E. Debugging Tools</A>).  Be sure to read the section on backtraces\n(see section <A HREF=\"pintos_11.html#SEC159\">E.4 Backtraces</A>), which will help you to get the most out of every\nkernel panic or assertion failure.\n</P>\n<P>\n\n<A NAME=\"Project 1 Requirements\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC33\"></A>\n<H2> 3.2 Requirements </H2>\n<!--docid::SEC33::-->\n<P>\n\n<A NAME=\"Project 1 Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC34\"></A>\n<H3> 3.2.1 Design Document </H3>\n<!--docid::SEC34::-->\n<P>\n\nBefore you turn in your project, you must copy <A HREF=\"threads.tmpl\">the\nproject 1 design document template</A> into your source tree under the name\n<Q><TT>pintos/src/threads/DESIGNDOC</TT></Q> and fill it in.  We recommend that\nyou read the design document template before you start working on the\nproject.  See section <A HREF=\"pintos_10.html#SEC152\">D. Project Documentation</A>, for a sample design document\nthat goes along with a fictitious project.\n</P>\n<P>\n\n<A NAME=\"Alarm Clock\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC35\"></A>\n<H3> 3.2.2 Alarm Clock </H3>\n<!--docid::SEC35::-->\n<P>\n\nReimplement <CODE>timer_sleep()</CODE>, defined in <Q><TT>devices/timer.c</TT></Q>.\nAlthough a working implementation is provided, it &quot;busy waits,&quot; that\nis, it spins in a loop checking the current time and calling\n<CODE>thread_yield()</CODE> until enough time has gone by.  Reimplement it to\navoid busy waiting.\n</P>\n<P>\n\n<A NAME=\"IDX1\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>timer_sleep</B> (int64_t <VAR>ticks</VAR>)\n<DD>Suspends execution of the calling thread until time has advanced by at\nleast <VAR>x</VAR> timer ticks.  Unless the system is otherwise idle, the\nthread need not wake up after exactly <VAR>x</VAR> ticks.  Just put it on\nthe ready queue after they have waited for the right amount of time.\n<P>\n\n<CODE>timer_sleep()</CODE> is useful for threads that operate in real-time,\ne.g. for blinking the cursor once per second.\n</P>\n<P>\n\nThe argument to <CODE>timer_sleep()</CODE> is expressed in timer ticks, not in\nmilliseconds or any another unit.  There are <CODE>TIMER_FREQ</CODE> timer\nticks per second, where <CODE>TIMER_FREQ</CODE> is a macro defined in\n<CODE>devices/timer.h</CODE>.  The default value is 100.  We don't recommend\nchanging this value, because any change is likely to cause many of\nthe tests to fail.\n</P>\n</DL>\n<P>\n\nSeparate functions <CODE>timer_msleep()</CODE>, <CODE>timer_usleep()</CODE>, and\n<CODE>timer_nsleep()</CODE> do exist for sleeping a specific number of\nmilliseconds, microseconds, or nanoseconds, respectively, but these will\ncall <CODE>timer_sleep()</CODE> automatically when necessary.  You do not need\nto modify them.\n</P>\n<P>\n\nIf your delays seem too short or too long, reread the explanation of the\n<Q><SAMP>-r</SAMP></Q> option to <CODE>pintos</CODE> (see section <A HREF=\"pintos_1.html#SEC6\">1.1.4 Debugging versus Testing</A>).\n</P>\n<P>\n\nThe alarm clock implementation is not needed for later projects,\nalthough it could be useful for project 4.\n</P>\n<P>\n\n<A NAME=\"Priority Scheduling\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC36\"></A>\n<H3> 3.2.3 Priority Scheduling </H3>\n<!--docid::SEC36::-->\n<P>\n\nImplement priority scheduling in Pintos.\nWhen a thread is added to the ready list that has a higher priority\nthan the currently running thread, the current thread should\nimmediately yield the processor to the new thread.  Similarly, when\nthreads are waiting for a lock, semaphore, or condition variable, the\nhighest priority waiting thread should be awakened first.  A thread\nmay raise or lower its own priority at any time, but lowering its\npriority such that it no longer has the highest priority must cause it\nto immediately yield the CPU.\n</P>\n<P>\n\nThread priorities range from <CODE>PRI_MIN</CODE> (0) to <CODE>PRI_MAX</CODE> (63).\nLower numbers correspond to lower priorities, so that priority 0\nis the lowest priority and priority 63 is the highest.\nThe initial thread priority is passed as an argument to\n<CODE>thread_create()</CODE>.  If there's no reason to choose another\npriority, use <CODE>PRI_DEFAULT</CODE> (31).  The <CODE>PRI_</CODE> macros are\ndefined in <Q><TT>threads/thread.h</TT></Q>, and you should not change their\nvalues.\n</P>\n<P>\n\nOne issue with priority scheduling is &quot;priority inversion&quot;.  Consider\nhigh, medium, and low priority threads <VAR>H</VAR>, <VAR>M</VAR>, and <VAR>L</VAR>,\nrespectively.  If <VAR>H</VAR> needs to wait for <VAR>L</VAR> (for instance, for a\nlock held by <VAR>L</VAR>), and <VAR>M</VAR> is on the ready list, then <VAR>H</VAR>\nwill never get the CPU because the low priority thread will not get any\nCPU time.  A partial fix for this problem is for <VAR>H</VAR> to &quot;donate&quot;\nits priority to <VAR>L</VAR> while <VAR>L</VAR> is holding the lock, then recall\nthe donation once <VAR>L</VAR> releases (and thus <VAR>H</VAR> acquires) the lock.\n</P>\n<P>\n\nImplement priority donation.  You will need to account for all different\nsituations in which priority donation is required.  Be sure to handle\nmultiple donations, in which multiple priorities are donated to a single\nthread.  You must also handle nested donation: if <VAR>H</VAR> is waiting on\na lock that <VAR>M</VAR> holds and <VAR>M</VAR> is waiting on a lock that <VAR>L</VAR>\nholds, then both <VAR>M</VAR> and <VAR>L</VAR> should be boosted to <VAR>H</VAR>'s\npriority.  If necessary, you may impose a reasonable limit on depth of\nnested priority donation, such as 8 levels.\n</P>\n<P>\n\nYou must implement priority donation for locks.  You need not\nimplement priority donation for the other Pintos synchronization\nconstructs.  You do need to implement priority scheduling in all\ncases.\n</P>\n<P>\n\nFinally, implement the following functions that allow a thread to\nexamine and modify its own priority.  Skeletons for these functions are\nprovided in <Q><TT>threads/thread.c</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX2\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_set_priority</B> (int <VAR>new_priority</VAR>)\n<DD>Sets the current thread's priority to <VAR>new_priority</VAR>.  If the\ncurrent thread no longer has the highest priority, yields.\n</DL>\n<P>\n\n<A NAME=\"IDX3\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> int <B>thread_get_priority</B> (void)\n<DD>Returns the current thread's priority.  In the presence of priority\ndonation, returns the higher (donated) priority.\n</DL>\n<P>\n\nYou need not provide any interface to allow a thread to directly modify\nother threads' priorities.\n</P>\n<P>\n\nThe priority scheduler is not used in any later project.\n</P>\n<P>\n\n<A NAME=\"Advanced Scheduler\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC37\"></A>\n<H3> 3.2.4 Advanced Scheduler </H3>\n<!--docid::SEC37::-->\n<P>\n\nImplement a multilevel feedback queue scheduler similar to the\n4.4<ACRONYM>BSD</ACRONYM> scheduler to\nreduce the average response time for running jobs on your system.\nSee section <A HREF=\"pintos_8.html#SEC141\">B. 4.4<ACRONYM>BSD</ACRONYM> Scheduler</A>, for detailed requirements.\n</P>\n<P>\n\nLike the priority scheduler, the advanced scheduler chooses the thread\nto run based on priorities.  However, the advanced scheduler does not do\npriority donation.  Thus, we recommend that you have the priority\nscheduler working, except possibly for priority donation, before you\nstart work on the advanced scheduler.\n</P>\n<P>\n\nYou must write your code to allow us to choose a scheduling algorithm\npolicy at Pintos startup time.  By default, the priority scheduler\nmust be active, but we must be able to choose the 4.4<ACRONYM>BSD</ACRONYM>\nscheduler\nwith the <Q><SAMP>-mlfqs</SAMP></Q> kernel option.  Passing this\noption sets <CODE>thread_mlfqs</CODE>, declared in <Q><TT>threads/thread.h</TT></Q>, to\ntrue when the options are parsed by <CODE>parse_options()</CODE>, which happens\nearly in <CODE>main()</CODE>.\n</P>\n<P>\n\nWhen the 4.4<ACRONYM>BSD</ACRONYM> scheduler is enabled, threads no longer\ndirectly control their own priorities.  The <VAR>priority</VAR> argument to\n<CODE>thread_create()</CODE> should be ignored, as well as any calls to\n<CODE>thread_set_priority()</CODE>, and <CODE>thread_get_priority()</CODE> should return\nthe thread's current priority as set by the scheduler.\n</P>\n<P>\n\nThe advanced scheduler is not used in any later project.\n</P>\n<P>\n\n<A NAME=\"Project 1 FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC38\"></A>\n<H2> 3.3 FAQ </H2>\n<!--docid::SEC38::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>How much code will I need to write?</B>\n<DD><P>\n\nHere's a summary of our reference solution, produced by the\n<CODE>diffstat</CODE> program.  The final row gives total lines inserted\nand deleted; a changed line counts as both an insertion and a deletion.\n</P>\n<P>\n\nThe reference solution represents just one possible solution.  Many\nother solutions are also possible and many of those differ greatly from\nthe reference solution.  Some excellent solutions may not modify all the\nfiles modified by the reference solution, and some may modify files not\nmodified by the reference solution.\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre> devices/timer.c       |   42 +++++-\n threads/fixed-point.h |  120 ++++++++++++++++++\n threads/synch.c       |   88 ++++++++++++-\n threads/thread.c      |  196 ++++++++++++++++++++++++++----\n threads/thread.h      |   23 +++\n 5 files changed, 440 insertions(+), 29 deletions(-)\n</pre></td></tr></table><P>\n\n<Q><TT>fixed-point.h</TT></Q> is a new file added by the reference solution.\n</P>\n<P>\n\n</P>\n<DT><B>How do I update the <Q><TT>Makefile</TT></Q>s when I add a new source file?</B>\n<DD><P>\n\n<A NAME=\"Adding Source Files\"></A>\nTo add a <Q><TT>.c</TT></Q> file, edit the top-level <Q><TT>Makefile.build</TT></Q>.\nAdd the new file to variable <Q><SAMP><VAR>dir</VAR>_SRC</SAMP></Q>, where\n<VAR>dir</VAR> is the directory where you added the file.  For this\nproject, that means you should add it to <CODE>threads_SRC</CODE> or\n<CODE>devices_SRC</CODE>.  Then run <CODE>make</CODE>.  If your new file\ndoesn't get\ncompiled, run <CODE>make clean</CODE> and then try again.\n</P>\n<P>\n\nWhen you modify the top-level <Q><TT>Makefile.build</TT></Q> and re-run\n<CODE>make</CODE>, the modified\nversion should be automatically copied to\n<Q><TT>threads/build/Makefile</TT></Q>.  The converse is\nnot true, so any changes will be lost the next time you run <CODE>make\nclean</CODE> from the <Q><TT>threads</TT></Q> directory.  Unless your changes are\ntruly temporary, you should prefer to edit <Q><TT>Makefile.build</TT></Q>.\n</P>\n<P>\n\nA new <Q><TT>.h</TT></Q> file does not require editing the <Q><TT>Makefile</TT></Q>s.\n</P>\n<P>\n\n</P>\n<DT><B>What does <CODE>warning: no previous prototype for `<VAR>func</VAR>'</CODE> mean?</B>\n<DD><P>\n\nIt means that you defined a non-<CODE>static</CODE> function without\npreceding it by a prototype.  Because non-<CODE>static</CODE> functions are\nintended for use by other <Q><TT>.c</TT></Q> files, for safety they should be\nprototyped in a header file included before their definition.  To fix\nthe problem, add a prototype in a header file that you include, or, if\nthe function isn't actually used by other <Q><TT>.c</TT></Q> files, make it\n<CODE>static</CODE>.\n</P>\n<P>\n\n</P>\n<DT><B>What is the interval between timer interrupts?</B>\n<DD><P>\n\nTimer interrupts occur <CODE>TIMER_FREQ</CODE> times per second.  You can\nadjust this value by editing <Q><TT>devices/timer.h</TT></Q>.  The default is\n100 Hz.\n</P>\n<P>\n\nWe don't recommend changing this value, because any changes are likely\nto cause many of the tests to fail.\n</P>\n<P>\n\n</P>\n<DT><B>How long is a time slice?</B>\n<DD><P>\n\nThere are <CODE>TIME_SLICE</CODE> ticks per time slice.  This macro is\ndeclared in <Q><TT>threads/thread.c</TT></Q>.  The default is 4 ticks.\n</P>\n<P>\n\nWe don't recommend changing this value, because any changes are likely\nto cause many of the tests to fail.\n</P>\n<P>\n\n</P>\n<DT><B>How do I run the tests?</B>\n<DD><P>\n\nSee section <A HREF=\"pintos_1.html#SEC8\">1.2.1 Testing</A>.\n</P>\n<P>\n\n</P>\n<DT><B>Why do I get a test failure in <CODE>pass()</CODE>?</B>\n<DD><P>\n\n<A NAME=\"The pass function fails\"></A>\nYou are probably looking at a backtrace that looks something like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>0xc0108810: debug_panic (lib/kernel/debug.c:32)\n0xc010a99f: pass (tests/threads/tests.c:93)\n0xc010bdd3: test_mlfqs_load_1 (...threads/mlfqs-load-1.c:33)\n0xc010a8cf: run_test (tests/threads/tests.c:51)\n0xc0100452: run_task (threads/init.c:283)\n0xc0100536: run_actions (threads/init.c:333)\n0xc01000bb: main (threads/init.c:137)\n</pre></td></tr></table><P>\n\nThis is just confusing output from the <CODE>backtrace</CODE> program.  It\ndoes not actually mean that <CODE>pass()</CODE> called <CODE>debug_panic()</CODE>.  In\nfact, <CODE>fail()</CODE> called <CODE>debug_panic()</CODE> (via the <CODE>PANIC()</CODE>\nmacro).  GCC knows that <CODE>debug_panic()</CODE> does not return, because it\nis declared <CODE>NO_RETURN</CODE> (see section <A HREF=\"pintos_11.html#SEC158\">E.3 Function and Parameter Attributes</A>), so it doesn't include any code in <CODE>fail()</CODE> to take\ncontrol when <CODE>debug_panic()</CODE> returns.  This means that the return\naddress on the stack looks like it is at the beginning of the function\nthat happens to follow <CODE>fail()</CODE> in memory, which in this case happens\nto be <CODE>pass()</CODE>.\n</P>\n<P>\n\nSee section <A HREF=\"pintos_11.html#SEC159\">E.4 Backtraces</A>, for more information.\n</P>\n<P>\n\n</P>\n<DT><B>How do interrupts get re-enabled in the new thread following <CODE>schedule()</CODE>?</B>\n<DD><P>\n\nEvery path into <CODE>schedule()</CODE> disables interrupts.  They eventually\nget re-enabled by the next thread to be scheduled.  Consider the\npossibilities: the new thread is running in <CODE>switch_thread()</CODE> (but\nsee below), which is called by <CODE>schedule()</CODE>, which is called by one\nof a few possible functions:\n</P>\n<P>\n\n<UL>\n<LI>\n<CODE>thread_exit()</CODE>, but we'll never switch back into such a thread, so\nit's uninteresting.\n<P>\n\n</P>\n<LI>\n<CODE>thread_yield()</CODE>, which immediately restores the interrupt level upon\nreturn from <CODE>schedule()</CODE>.\n<P>\n\n</P>\n<LI>\n<CODE>thread_block()</CODE>, which is called from multiple places:\n<P>\n\n<UL>\n<LI>\n<CODE>sema_down()</CODE>, which restores the interrupt level before returning.\n<P>\n\n</P>\n<LI>\n<CODE>idle()</CODE>, which enables interrupts with an explicit assembly STI\ninstruction.\n<P>\n\n</P>\n<LI>\n<CODE>wait()</CODE> in <Q><TT>devices/intq.c</TT></Q>, whose callers are responsible for\nre-enabling interrupts.\n</UL>\n</UL>\n<P>\n\nThere is a special case when a newly created thread runs for the first\ntime.  Such a thread calls <CODE>intr_enable()</CODE> as the first action in\n<CODE>kernel_thread()</CODE>, which is at the bottom of the call stack for every\nkernel thread but the first.\n</DL>\n<P>\n\n<A NAME=\"Alarm Clock FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC39\"></A>\n<H3> 3.3.1 Alarm Clock FAQ </H3>\n<!--docid::SEC39::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>Do I need to account for timer values overflowing?</B>\n<DD><P>\n\nDon't worry about the possibility of timer values overflowing.  Timer\nvalues are expressed as signed 64-bit numbers, which at 100 ticks per\nsecond should be good for almost 2,924,712,087 years.  By then, we\nexpect Pintos to have been phased out of the Computer Science curriculum.\n</DL>\n<P>\n\n<A NAME=\"Priority Scheduling FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC40\"></A>\n<H3> 3.3.2 Priority Scheduling FAQ </H3>\n<!--docid::SEC40::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>Doesn't priority scheduling lead to starvation?</B>\n<DD><P>\n\nYes, strict priority scheduling can lead to starvation\nbecause a thread will not run if any higher-priority thread is runnable.\nThe advanced scheduler introduces a mechanism for dynamically\nchanging thread priorities.\n</P>\n<P>\n\nStrict priority scheduling is valuable in real-time systems because it\noffers the programmer more control over which jobs get processing\ntime.  High priorities are generally reserved for time-critical\ntasks. It's not &quot;fair,&quot; but it addresses other concerns not\napplicable to a general-purpose operating system.\n</P>\n<P>\n\n</P>\n<DT><B>What thread should run after a lock has been released?</B>\n<DD><P>\n\nWhen a lock is released, the highest priority thread waiting for that\nlock should be unblocked and put on the list of ready threads.  The\nscheduler should then run the highest priority thread on the ready\nlist.\n</P>\n<P>\n\n</P>\n<DT><B>If the highest-priority thread yields, does it continue running?</B>\n<DD><P>\n\nYes.  If there is a single highest-priority thread, it continues\nrunning until it blocks or finishes, even if it calls\n<CODE>thread_yield()</CODE>.\nIf multiple threads have the same highest priority,\n<CODE>thread_yield()</CODE> should switch among them in &quot;round robin&quot; order.\n</P>\n<P>\n\n</P>\n<DT><B>What happens to the priority of a donating thread?</B>\n<DD><P>\n\nPriority donation only changes the priority of the donee\nthread.  The donor thread's priority is unchanged.  \nPriority donation is not additive: if thread <VAR>A</VAR> (with priority 5) donates\nto thread <VAR>B</VAR> (with priority 3), then <VAR>B</VAR>'s new priority is 5, not 8.\n</P>\n<P>\n\n</P>\n<DT><B>Can a thread's priority change while it is on the ready queue?</B>\n<DD><P>\n\nYes.  Consider a ready, low-priority thread <VAR>L</VAR> that holds a lock.\nHigh-priority thread <VAR>H</VAR> attempts to acquire the lock and blocks,\nthereby donating its priority to ready thread <VAR>L</VAR>.\n</P>\n<P>\n\n</P>\n<DT><B>Can a thread's priority change while it is blocked?</B>\n<DD><P>\n\nYes.  While a thread that has acquired lock <VAR>L</VAR> is blocked for any\nreason, its priority can increase by priority donation if a\nhigher-priority thread attempts to acquire <VAR>L</VAR>.  This case is\nchecked by the <CODE>priority-donate-sema</CODE> test.\n</P>\n<P>\n\n</P>\n<DT><B>Can a thread added to the ready list preempt the processor?</B>\n<DD><P>\n\nYes.  If a thread added to the ready list has higher priority than the\nrunning thread, the correct behavior is to immediately yield the\nprocessor.  It is not acceptable to wait for the next timer interrupt.\nThe highest priority thread should run as soon as it is runnable,\npreempting whatever thread is currently running.\n</P>\n<P>\n\n</P>\n<DT><B>How does <CODE>thread_set_priority()</CODE> affect a thread receiving donations?</B>\n<DD><P>\n\nIt sets the thread's base priority.  The thread's effective priority\nbecomes the higher of the newly set priority or the highest donated\npriority.  When the donations are released, the thread's priority\nbecomes the one set through the function call.  This behavior is checked\nby the <CODE>priority-donate-lower</CODE> test.\n</P>\n<P>\n\n</P>\n<DT><B>Doubled test names in output make them fail.</B>\n<DD><P>\n\nSuppose you are seeing output in which some test names are doubled,\nlike this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>(alarm-priority) begin\n(alarm-priority) (alarm-priority) Thread priority 30 woke up.\nThread priority 29 woke up.\n(alarm-priority) Thread priority 28 woke up.\n</pre></td></tr></table><P>\n\nWhat is happening is that output from two threads is being\ninterleaved.  That is, one thread is printing <CODE>&quot;(alarm-priority)\nThread priority 29 woke up.\\n&quot;</CODE> and another thread is printing\n<CODE>&quot;(alarm-priority) Thread priority 30 woke up.\\n&quot;</CODE>, but the first\nthread is being preempted by the second in the middle of its output.\n</P>\n<P>\n\nThis problem indicates a bug in your priority scheduler.  After all, a\nthread with priority 29 should not be able to run while a thread with\npriority 30 has work to do.\n</P>\n<P>\n\nNormally, the implementation of the <CODE>printf()</CODE> function in the\nPintos kernel attempts to prevent such interleaved output by acquiring\na console lock during the duration of the <CODE>printf</CODE> call and\nreleasing it afterwards.  However, the output of the test name,\ne.g., <CODE>(alarm-priority)</CODE>, and the message following it is output\nusing two calls to <CODE>printf</CODE>, resulting in the console lock being\nacquired and released twice.\n</DL>\n<P>\n\n<A NAME=\"Advanced Scheduler FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC41\"></A>\n<H3> 3.3.3 Advanced Scheduler FAQ </H3>\n<!--docid::SEC41::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>How does priority donation interact with the advanced scheduler?</B>\n<DD><P>\n\nIt doesn't have to.  We won't test priority donation and the advanced\nscheduler at the same time.\n</P>\n<P>\n\n</P>\n<DT><B>Can I use one queue instead of 64 queues?</B>\n<DD><P>\n\nYes.  In general, your implementation may differ from the description,\nas long as its behavior is the same.\n</P>\n<P>\n\n</P>\n<DT><B>Some scheduler tests fail and I don't understand why.  Help!</B>\n<DD><P>\n\nIf your implementation mysteriously fails some of the advanced\nscheduler tests, try the following:\n</P>\n<P>\n\n<UL>\n<LI>\nRead the source files for the tests that you're failing, to make sure\nthat you understand what's going on.  Each one has a comment at the\ntop that explains its purpose and expected results.\n<P>\n\n</P>\n<LI>\nDouble-check your fixed-point arithmetic routines and your use of them\nin the scheduler routines.\n<P>\n\n</P>\n<LI>\nConsider how much work your implementation does in the timer\ninterrupt.  If the timer interrupt handler takes too long, then it\nwill take away most of a timer tick from the thread that the timer\ninterrupt preempted.  When it returns control to that thread, it\ntherefore won't get to do much work before the next timer interrupt\narrives.  That thread will therefore get blamed for a lot more CPU\ntime than it actually got a chance to use.  This raises the\ninterrupted thread's recent CPU count, thereby lowering its priority.\nIt can cause scheduling decisions to change.  It also raises the load\naverage.\n</UL>\n</DL>\n<A NAME=\"Project 2--User Programs\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_3.html#SEC25\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_4.html#SEC42\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}