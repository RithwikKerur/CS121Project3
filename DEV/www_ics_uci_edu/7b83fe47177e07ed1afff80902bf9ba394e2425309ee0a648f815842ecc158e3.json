{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/interfaces/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Interfaces</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Interfaces</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture, we will take another big step (like our understanding of\r\n    <b>Object</b>) towards generalizing our understanding of Java classes,\r\n    through the use of <b>interfaces</b>.\r\n  This step will ultimately lead to us learning about class inheritance, class\r\n    hierarchies, abstract classes (and abstract methods), and other advanced\r\n    topics concerning classes.\r\n  But, we will start small; we will show how interfaces can be used to\r\n    generalize the concept of <i>type</i>: at present we know only that\r\n    primitive types and classes can serve as types for local variables,\r\n    parameter variables, and fields in classes.\r\n  We also know that a variable of the type <b>Object</b> can store a reference\r\n    to any object constructed from a class.\r\n  <p>\r\n  An interface specifies a constraint on a class: any class that implements an\r\n    interface must satisfy its constraints by defining all the methods\r\n    specified in the interface.\r\n  To understand all the material in this lecture about interfaces, we must\r\n    learn how the four facets of interfaces interconnect.\r\n  <ol>\r\n    <li>How to define an interface: each looks like a class defining only\r\n          method headers (not bodies): no constructors nor fields.\r\n    <li>How to write a class that <b>implements</b> an interface.\r\n    <li>How to write a method that specifies the type of a parameter using\r\n          the name of the interface.\r\n        This includes what arguments -references to objects- can be passed to\r\n          such a parameter and how the parameter can be used inside the method:\r\n          to call any methods specified in the interface.\r\n    <li>How to call such a method, by constructing an object from some class\r\n          that implements the interface type.\r\n  </ol>\r\n  Technically, interfaces are types that some classes implement.\r\n  <p>\r\n  To illustrate all these points concretely, we will first examine two simple\r\n     but powerful methods (both are <b>public static</b>) whose parameter types\r\n     are specified by interfaces: one rejects bad values entered by the user in\r\n     prompts; the other approximates the definite integral of any univariate\r\n     function.\r\n  Along with these methods we discuss the necessary interfaces, a few classes\r\n    that implement these interfaces, and a driver application that ties all\r\n    these facets together.\r\n  Please download, unzip, run and examine the entire\r\n    <a href=\"../../programs/interfacedemo.zip\">Interface Demonstration</a>\r\n    application.\r\n  <p>\r\n  Next we will examine the <b>Comparator</b> interface, which is defined in\r\n    the standard Java library.\r\n  We will use this interface (whose central method specifies <b>Object</b>\r\n    parameters) along with the <b>sort</b> method defined in the <b>Arrays</b>\r\n    class (also in the standard Java library) to learn how to sort any array:\r\n    in the process, we will use lots of casting.\r\n  Please download, unzip, run and examine the entire\r\n    <a href=\"../../programs/sortingwithinterfaces.zip\">\r\n      Sorting (with Interfaces) Demonstration</a>\r\n    application.\r\n  <p>\r\n  Each facet of interfaces is simple to undertand by itself: together they\r\n    provide a powerful programming tool.\r\n  We will discuss these four facets thrice: once for the prompting method,\r\n    once for the integration  method, and once for the sorting method.\r\n  Because these facets are so interrelated, it is useful to view everything\r\n    more than once.\r\n  Like many advanced Java features, the ability to discuss them technically is\r\n    critical.\r\n  Once you can connect up the words, connecting up the concepts (and actually\r\n    writing the Java code) becomes much simpler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Specifying Interfaces -->\r\n\r\n<a name=\"SpecifyingInterfaces\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Facet 1:<br>Specifying Interfaces</b></td>\r\n<td width =\"80%\">\r\n  An interface specifies a <b>type</b> by specifying the prototypes of what\r\n    methods must be defined in any class implementing that interface.\r\n  For this reason, interfaces look a lot like class definitions; but, they \r\n    cannot specify any constructors and typically do not specify any fields\r\n    (fields are allowed, with all sorts of special constraints, so we will\r\n     delay  studying them).\r\n  In fact, each method specification itself is a just a header followed by a\r\n    semi-colon (not the body of the header: interfaces specify WHAT methods\r\n    must be available but not HOW they are implemented).\r\n  Each is like a prototype (but with parameter names).\r\n  <p>\r\n  Interfaces are often very small; the classes implementing them are also as\r\n    small, or they may define some other methods (as well as constructors and\r\n    fields) not specified in the interface.\r\n  So, for example, the <b>DecisionInt</b> interface (shown below and in the\r\n    Interface Demonstration) is simply specified as\r\n<pre><b>  public interface DecisionInt {\r\n    public boolean isOK(int x);\r\n  }</b></pre>\r\n  First, notice that the word <b>interface</b> appears before the name\r\n    <b>DecisionInt</b> (we have seen <b>class</b> used similarly).\r\n  Any class implementing the <b>DecisionInt</b> interface must define a method\r\n    named <b>isOK</b> with its prototype; one <b>int</b> parameter returning\r\n     a <b>boolean</b> result.\r\n   All methods defined in an interface are implicitly <b>public</b> whether or\r\n    not they include that access modifier; for this reason, some programmers\r\n    never bother to write <b>public</b>, while I always write it for emphasis.\r\n  <p>\r\n We will see a variety of classes that each implement this interface, with a\r\n     different meaning for each <b>isOK</b> method (some allowing the user to\r\n     enter only positive numbers, even numbers, prime numbers, or numbers in a\r\n     certain range).\r\n  Then we will see a method that prompts the user for an integer, and calls\r\n    <b>isOK</b> (on some object constructed from a class that implements this \r\n    interface) to decide whether the entered value is to be accepted or\r\n    rejected; if rejected, the user is reprompted to enter an \"OK\" values.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Implementing Interfaces -->\r\n\r\n<a name=\"ImplementingInterfaces\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Facet 2:<br>Classes Implementing Interfaces</b></td>\r\n<td width =\"80%\">\r\n  Classes implement interfaces by (a) explicitly specifying that they do, and\r\n    by  (b) implementing whatever methods are required by the interface.\r\n  For example, using the <b>isOK</b> interface specified above, we can define\r\n    the <b>IsEven</b> class as\r\n <pre><b>  public class IsEven implements DecisionInt {\r\n    public boolean isOK(int x)\r\n    {return x%2 == 0;}\r\n  }</b></pre>\r\n  Notice the first line in this example: it defines the class name, and then\r\n    using the keyword <b>implements</b> specifies an interface that it\r\n    implements (more complicated classes can implement multiple interfaces).\r\n  Sure enough, this class does supply the required <b>isOK</b> method, having\r\n    the correct prototype.\r\n  This <b>isOK</b> method just returns <b>true</b> when its parameter is an\r\n    even number.\r\n  <p>\r\n  Notice that this class includes no constructor.\r\n  Recall that in such cases, Java automatically supplies a constructor, \r\n    written as\r\n  <pre><b>  public IsEven ()\r\n  {}</b></pre>\r\n  Such a constructor takes no parameters and performs no actions (and obviously\r\n    initializes no instance variables: <b>IsEven</b> defines none).\r\n  We could have written exactly this code for the constructor inside the class,\r\n    but in classes like this one, most programmers let Java supply this\r\n    constructor automatically.\r\n  Likewise, it is simple to define classes whose <b>isOK</b> methods allows\r\n    only positive or prime numbers; their bodies would perform different\r\n    computations.\r\n  <p>\r\n  For a more interesting second example, here is another class that implements\r\n    the <b>DecisionInt</b> interface.\r\n  <pre><b>  public class IsBetween implements DecisionInt {\r\n\r\n    public IsBetween(int low, int high) {\r\n      if (low > high)\r\n        throw new IllegalArgumentException\r\n          (\"IsBetween Constructor: low(\"+low+\") not <= high(\"+high+\")\");\r\n    \r\n      this.low  = low;\r\n      this.high = high;\r\n    }\r\n\r\n    public boolean isOK(int x)\r\n    {return low <= x && x <= high;}\r\n \r\n    private int low;\r\n    private int high; \r\n}</b></pre>\r\n  This class specifies two instance variables, and a constructor that checks\r\n    for legal values (<b>low</b> must be no bigger than <b>high</b>) before\r\n    storing its parameters into these instance\r\n   variables.\r\n  Instead of throwing an exception when the parameters are out of order, we\r\n    could just fix them, and  write this constructor as\r\n  <pre><b>  public IsBetween (int bound1, int bound2) {\r\n    low  = Math.min(bound1,bound2);\r\n    high = Math.max(bound1,bound2);\r\n  }</b></pre>\r\n  But, I'm not a big fan to automatically fixing such problems: better to\r\n    throw an exception and let someone know about the problem.\r\n  <p>\r\n  In either case, once an object is constructed and correctly stores these two\r\n    values, the <b>isOK</b> method determines whether its supplied parameter\r\n    is between them.\r\n  Of course, this class correctly implements the <b>DecisionInt</b> interface\r\n    with its <b>isOK</b> method.\r\n  What makes this class more interesting than <b>IsEven</b> is that it must\r\n    store instance variables, and therefore uses a constructor to initialize\r\n    them correctly.\r\n  The <b>isOK</b> method in <b>InBetween</b> compares its single parameter to\r\n    these instance variables; its prototype looks just like all the other\r\n    <b>isOK</b> methods (it just is more complex on the inside).\r\n  <p>\r\n  Note that if a class specifies that it implements some interface, the Java\r\n    compiler checks whether all the methods specified in the interface are\r\n    actually defined in the class (with their correct prototypes).\r\n  If not, the Java compiler detects and reports an error.\r\n  <p>\r\n  Finally, one class can implement many different interfaces (just as one\r\n    method can throw many different exceptions), as long as it defines all\r\n    the methods specified in each interface that it claims to implement.\r\n  We will see this more advanced feature used later in the course.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Interfaces as Types -->\r\n\r\n<a name=\"InterfacesAsTypes\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Facet 3:<br>Interfaces as Types in Methods</b></td>\r\n<td width =\"80%\">\r\n  Interfaces are types.\r\n  We can use the names of interfaces to declare variables: local and parameter\r\n    variables in methods, and instance variables in classes.\r\n  This simple statement leads to some extremely interesting and deep ideas in\r\n    object-oriented programming.\r\n  What can we do with a variable whose type is declared by the name of an\r\n    interface?\r\n  <ul>\r\n    <li>We can store into it a reference to an object constructed from any \r\n          class that says that it implements the interface.\r\n    <li>We can use it to call any of the methods specified in the interface.\r\n        The actual method called is the one defined in the object that such a\r\n          variable refers to.\r\n  </ul>\r\n  So, both of the following declaratins, and their pictures, make sense.\r\n <p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/decisionint.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\n  This picture illustrates a situation that we have seen only once before,\r\n    when dealing with the type <b>Object</b>: the type of the variable is\r\n    COMPATIBLE, but NOT IDENTICAL to the type of the constructed object to\r\n    which it refers!\r\n  But unlike the <b>Object</b> type, which can store ANY reference, a variable\r\n    using an interface type can store REFERENCES ONLY TO OBJECTS CONSTRUCTED \r\n    FROM A CLASS THAT IMPLEMENTS THAT INTERFACE.\r\n  Because the <b>IsEven</b> and <b>IsBetween</b> classes each implement the\r\n     <b>DecisionInt</b> interface, we can make variables declared from the\r\n    <b>DecisionInt</b> interface/type refer to objects constructed from either\r\n    of these classes.\r\n  <p>\r\n  Once we have variables like <b>d1</b> and <b>d2</b>, which refer to objects \r\n    constructed from classes implementing an interface, we can use them to\r\n    call any method specified in the interface.\r\n  So, in these case, we can use each to call only a method named <b>isOK</b>.\r\n  Which <b>isOK</b> method is called depends entirely on the class of object\r\n     that the variable refers to.\r\n  <p>\r\n  Given the above variable declarations, calling <b>d1.isOK(3)</b> would\r\n    return <b>false</b>; it calls the <b>isOK</b> method declared in\r\n     <b>IsEven</b>, the class of the object that <b>d1</b> refers to.\r\n  Likewise calling <b>d2.isOK(3)</b> would return <b>true</b>; it calls the\r\n    <b>isOK</b> method declared in <b>IsBetween</b>, the class of the object\r\n    that <b>d2</b> refers to -and this object stores <b>1</b> and <b>5</b> for\r\n    its bounds.\r\n  <p>\r\n  Generally, a variable specifying an interface type knows WHAT method names it\r\n    can call (those specified in the interface) but not HOW these methods will\r\n    compute their result (that depends on what object was constructed to store\r\n    in such a variable.\r\n  This rule echoes what we know about the <b>Object</b> type too.\r\n  <ul>\r\n    <li>\r\n      Which methods a variable is allowed (by the compiler) to call depends\r\n        solely on its type.\r\n      Any variable declared with the <b>DecisionInt</b> type can call only the\r\n        <b>isOK</b> method.\r\n    <li>\r\n      Which method is actually called depends on the object the variable\r\n        refers to.\r\n      Both <b>d1</b> and <b>d2</b> are declared to be of the same type:\r\n        <b>DecisionInt</b>.\r\n      Which method is called by each depends on the class of the object the\r\n        variable refers to: <b>IsEven</b> in the first case and\r\n        <b>IsBetween</b> in the second.\r\n  </ul>\r\n  This distinction between the type of the variable and the class of the object\r\n    that it refers to is a critical first step in our eventual understanding of\r\n    class inheritance hierarchies.\r\n  <p>\r\n  Now, let's examine another useful prompting method; one that has a\r\n   <b>DecisionInt</b> parameter.\r\n  We will define this <b>forInt</b> method in a class named\r\n    <b>AdvancedPrompt</b>.\r\n  It actually specifies three parameters: a message to prompt the user,\r\n    a reference to an object constructed from some class that implements the\r\n    <b>DecisionType</b> interface, and another message -an \"error\" message.\r\n<pre><b>  public class AdvancedPrompt {\r\n\r\n    public static int forInt (String      message,\r\n                              DecisionInt check,\r\n                              String      errorMessage) {\r\n      for(;;) {\r\n          int answer = Prompt.forInt(message);\r\n          if (check.isOK(answer))\r\n            return answer;\r\n          System.out.println(errorMessage);\r\n      }\r\n    }\r\n\r\n  }</b></pre>\r\n  This method first prompts the user for an <b>int</b> value using the standard\r\n    <b>Prompt.forInt</b> method, storing its result in <b>answer</b> (all\r\n    possible problems with the user entering non-integer values are  handled by\r\n    <b>Prompt.forInt</b>).\r\n  It then uses <b>answer</b> as a parameter to the <b>isOK</b> method of the\r\n     object to which <b>check</b> refers; if the <b>isOK</b> method called\r\n     returns <b>true</b>, then this method returns <b>answer</b>; if not, then\r\n     this method prints an error message and repeats the prompt-check loop.\r\n  <p>\r\n  Notice that the only use of the <b>check</b> parameter inside the method is a\r\n    call to its <b>isOK</b> method.\r\n  Because we know that <b>check</b> refers to an object from some class\r\n    implementing the <b>DecisionInt</b> interface (the compiler doesn't allow\r\n    any arguments not constructed from such a class), we know that the object\r\n    it refers to will contain an <b>isOK</b> method.\r\n  <p>\r\n  So, we have written a very general method.\r\n  It accepts/rejects the information entered by users; its action depends on\r\n    whatever object is passed as an argument to the <b>check</b> parameter.\r\n  There might be hundreds of different criteria we want to use for different\r\n    prompts, but we can alway use this method, along with a class that\r\n    implements the criteria we want.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Calling Methods with Interface Parameters -->\r\n\r\n<a name=\"CallingMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Facet 4:<br>Calling Methods with Interface Parameters</b></td>\r\n<td width =\"80%\">\r\n  We can now complete the example, by showing how to call the\r\n    <b>AdvancedPrompt.forInt</b> method.\r\n  Given the declarations above, we can write\r\n  <pre><b>int even = AdvancedPrompt.forInt(\"Enter even\",\r\n                                  d1,\r\n                                  \"...not divisible by two\");</b></pre>\r\n  which could have the following interaction in the console:\r\n  <pre><b>Enter even: 3\r\n...not divisible by two\r\nEnter even: 4</b></pre>\r\n  at which point the value <b>4</b> is stored into the variable <b>even</b>.\r\n  <p>\r\n  Likewise, we can use <b>d2</b> instead of <b>d1</b> and write\r\n  <pre><b>int selection = AdvancedPrompt.forInt(\"Enter selection\",\r\n                                       d2,\r\n                                       \"...not in range [1..5]\");</b></pre>\r\n  which could have the following interaction in the console:\r\n  <pre><b>Enter selection: 7\r\n...not in range [1..5]\r\nEnter selection: 4</b></pre>\r\n  at which point the value <b>4</b> is stored into the variable\r\n  <b>selection</b>.\r\n  <p>\r\n  In fact, we do not even need to store an object in a variable before calling\r\n    <b>AdvancedPrompt.forInt</b>!\r\n  We could directly write\r\n  <pre><b>int selection = AdvancedPrompt.forInt(\"Enter selection\",\r\n                                       new IsBetween(1,5),\r\n                                       \"...not in range [1..5]\");</b></pre>\r\n  Here, the second argument is an expression that evaluates to a reference to\r\n    an object constructed from the class <b>IsBetween</b>; its value is copied\r\n    into the <b>check</b> parameter in the method.\r\n  Here is a call frame illustrating everything (assuming the user enter 4, the\r\n     method returns 4).\r\n  <p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/callframe.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  <p>\r\n  What have we accomplished with these four facets of interfaces?\r\n  Primarily, we have separated the <b>AdvancePrompt.forInt</b> method from the\r\n    method(s) that determines whether to accept/reject the value entered by the\r\n    user (the <b>isOK</b> method, in whatever object we pass to \r\n    this method, controls the semantics of choosing).\r\n  In the process, we have also specified the <b>DecisionInt</b> interface, as\r\n    what interconnects these methods.\r\n  <p>\r\n  If we want a new way to filter prompts, all we must do is plug an object from\r\n     a new class into machinery that we have created: write a class that\r\n     implements the <b>DecisionInt</b> interface, and construct an instance of\r\n     that class to pass as a parameter to <b>AdvancedPrompt.forInt</b>.\r\n  Thus, this mechanism provides a general structure for solving\r\n    yet-unspeciried problems of differentiating good or bad input values.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Integration -->\r\n\r\n<a name=\"Integration\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>All Four Facets:<br>Integration</b></td>\r\n<td width =\"80%\">\r\n  Let's solve another completely different and general problem using\r\n    interfaces.\r\n  Suppose that we want to be able to write a method that allows us to\r\n    approximate the area under a curve.\r\n  We can do this by repeated summing the areas of small rectangles under the\r\n     curve.\r\n  Each rectangle's height corresponds to a value of the function <b>F(...)</b>;\r\n    each rectangle's width is the constant <b>h</b>.\r\n  So, to compute the area under the curve from <b>a</b> to <b>b</b>, we compute\r\n    <b>F(a)h + F(a+h)h + F(a+2h)h + F(a+3h)h + ... F(b-h)h</b>, as illustrated in the\r\n  following picture.\r\n (This is not the best way to approximate this area, but it is the simplest.)\r\n<p>\r\n </tbody>\r\n</table>\r\n   <img src=\"images/integral.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Let's examine the four facets of interfaces to solve this problem.\r\n  First, we must specify the interface, which supplies a method to compute the\r\n    value of  a function of one variable: a univariate function.\r\n  We don't know how this will be done (just as we didn't know how a method\r\n    would compute whether to accept/reject a value), but we know what the\r\n    prototype of the method must be.\r\n  So we can write this interface simply (as simply as <b>DecisionInt</b>)\r\n  <pre><b>  public interface Univariate {\r\n    public double evaluate (double x);\r\n  }</b></pre>\r\n  <p>\r\n  Second, we must write a class that implements this interface.\r\n  As an example, let's write a class that can easily represent all quadratic\r\n    forms:\r\n    <b>ax<sup>2</sup>+bx+c</b>.\r\n<pre><b>  public class Quadratic implements Univariate {\r\n  \r\n    public Quadratic (double a, double b, double c) {\r\n      this.a = a;\r\n      this.b = b;\r\n      this.c = c;\r\n    }\r\n  \r\n    public double evaluate (double x)\r\n    {return a*x*x + b*x + c;}\r\n  \r\n    private double a,b,c;\r\n  }</b></pre>\r\n  Third, we must write a method that approximates the integral for an\r\n    arbitrary univariate function.\r\n  We will call such a method <b>integrate</b> and define it in the\r\n    <b>AdvancedMath</b> class  as follows\r\n<pre><b>  public class AdvancedMath {\r\n\r\n    public static double integrate (Univariate f,\r\n                                    double low, double high,\r\n                                    double step)              {\r\n      double sum = 0.;\r\n      for(double x = low; x &lt; high; x+=step) \r\n        sum += f.evaluate(x) * step;\r\n      return sum;\r\n    }\r\n  }</b></pre>\r\n  Note that we use the parameter <b>f</b> just once in this code, calling its\r\n    <b>evaluate</b> method for all the different values of <b>x</b> generated\r\n    by the <b>for</b> loop (so it does get called many times when the method\r\n    executes: once for each rectangle).\r\n  Note too that this <b>for</b> loop uses <b>double</b> values: a legal, but\r\n    not frequent choice.\r\n  <p>\r\n  Finally, let's combine all this information to write a call that approximates\r\n    the area under the curve <b>2x<sup>2</sup>-3x+5</b> between <b>1</b> and\r\n    <b>3.5</b> using a step-width/h of <b>.01</b>.\r\n  We can do this in one line.\r\n  <pre><b>double area = \r\n  AdvancedMath.integrate(new Quadratic(2.,-3.,5.), 1., 3.5, .01);</b></pre>\r\n  <p>\r\n  We can also define many other methods in the <b>AdvancedMath</b> class that\r\n    operate on univariate functions: finding 0s, computing maxima/minima,\r\n    approximating derivatives, etc.\r\n  We can also define many other classes that implement the <b>Univariate</b>\r\n    interface: cubics, exponentials, trigononmetric functions, and combinations\r\n    of all these.\r\n  Then, we can mix and match these as necessary: say, use the <b>findZero</b>\r\n    method on an object constructed from the <b>Cubic</b> class.\r\n  The more we build these libraries, the more likely we are to find debugged\r\n    classes that we can use directly from them in our new applications.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Comparator and Sorting -->\r\n\r\n<a name=\"Sorting\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Comparator Interface and the sort method in Arrays</b></td>\r\n<td width =\"80%\">\r\n  The standard Java library contains an interface named <b>Comparator</b>,\r\n    defined in the <b>java.util</b> package.\r\n  Find the Javadoc for this interface and scan its documentation.\r\n  Notice that in the <b>All Classes</b> pane -interfaces appear here\r\n    too- its name appears italicized as <b><i>Comparator</i></b>.\r\n  In fact, the names of all interfaces appear here italicized, so you can\r\n    quickly tell whether an identifier names a class or an interface (these\r\n    are the only two possibilities).\r\n  The <b>Comparator</b> interface is defined by\r\n  <pre><b>  public interface Comparator {\r\n    public int compare (Object o1, Object o2);\r\n  }</b></pre>\r\n  Classes implementing this interface use <b>compare</b> to perform a\r\n    trichotomous comparison of two arguments: telling whether the\r\n    first parameter is (a) less than (returning any negative number) the\r\n    second parameter, (b) equal to (returning <b>0</b>) the second parameter,\r\n    or (c) greater than (returning any positive number) the second parameter.\r\n  <p>\r\n  Interfaces are general, allowing lots of different class to implement them.\r\n  In addition, this interface uses the type <b>Object</b> for parameters in\r\n    the <b>compare</b> methods.\r\n  This is a tipoff that this interface is very general and very useful!\r\n  <p>\r\n  Let's first write a class implementing the <b>Comparator</b> interface for\r\n    objects constructed from the <b>Integer</b> wrapper class.\r\n  Then we will see how to use objects constructed from this class in a sorting\r\n    method in the standard Java library.\r\n  <pre><b>  public class IntegerComparator implements Comparator {\r\n    public int compare (Object o1, Object o2) {\r\n      Integer i1 = (Integer)o1;\r\n      Integer i2 = (Integer)o2;\r\n      return i1.compareTo(i2);\r\n    }\r\n  }</b></pre>\r\n  Notice that the <b>compare</b> method first casts both parameters\r\n    and stores their references into <b>Integer</b> local variables; if\r\n    either cast fails, Java will automatically throw\r\n    a <b>ClassCastException</b>: because at least one value is not an\r\n    <b>Integer</b>, therefore they cannot be compared as expected.\r\n  Then it calls the <b>compareTo</b> method on the first <b>Integer</b>, using\r\n    the second as an argument.\r\n  This method conveniently is defined in the <b>Integer</b> wrapper class\r\n   (look it up) to compute the trichotomous result easily: it returns exactly\r\n   the value that we want <b>compare</b> to return!\r\n In fact, because the non-<b>static</b> <b>compareTo</b> method has the\r\n     prototype  <b>int compareTo(Object)</b> we could simplify the body of\r\n     <b>compare</b> to just <b>return ((Integer)o1).compareTo(i2);</b> because\r\n     <b>compareTo</b> will by itself cast its argument to be an <b>Integer</b>.\r\n  (Why can't we write just <b>return o1.compareTo(o2);</b>?)\r\n  <p>\r\n  Finally, Java will automatically write the constructor\r\n    <b><pre>  public IntegerComparator()\r\n  {}</pre></b>\r\n  Now, let's see how to use an object constructed from the \r\n   <b>IntegerComparator</b> class.\r\n  Examine the <b>sort</b> method in the <b>Arrays</b> class, which\r\n    is defined in the <b>java.lang</b> package.\r\n  It is a highly overloaded method.\r\n  The prototype that we are most interested in is\r\n  <b><pre>  public static void sort(Object[] a, Comparator c)</pre></b>\r\n  First, note that this method is <b>static</b>; as in the <b>Math</b> and\r\n    <b>Prompt</b> classes,  all the methods here are <b>static</b>.\r\n  When called, it will efficiently sort any <b>Object[]</b> (<b>Object</b>\r\n    array) using the ordering specified by a class implementing\r\n    <b>Comparator</b>.\r\n  It actually permutes the values in the parameter array <b>a</b> such that it\r\n    has the postcondition\r\n  <ul>\r\n    <li><b>a</b> stores all its original values, as many times as they\r\n          originally occurred (e.g., there might be duplicates, etc.)\r\n    <li>these values are ordered in the array such that\r\n  <b><pre>  c.compare(a[0],a[1]) <= 0</b> and<b>\r\n  c.compare(a[1],a[2]) <= 0</b> and<b>\r\n  ....\r\n  c.compare(a[a.length-2],a[a.length-1]) <= 0</pre></b>\r\n  </ul>\r\n  That is, it sorts  <b>Object[] a</b> according to <b>Comparator c</b>.\r\n  <p>\r\n  So, if Java executed the code\r\n<b><pre>\r\n  //Declare arrays\r\n  int[]     temp = new int[]{3,7,4,1,10,2,8,5,9,6};\r\n  Integer[] x    = new Integer[temp.length];\r\n\r\n  //Fill wrapper array x with values from temp\r\n  for (int i=0; i&lt;temp.length; i++)\r\n    x[i] = new Integer(temp[i]);\r\n\r\n  //Sort wrapper array\r\n  Arrays.sort(x,new IntegerComparator());\r\n\r\n  //Print wrapper array\r\n  for (int i=0; i&lt;x.length; i++)\r\n    System.out.println(x[i]+\" \");</pre></b>\r\n  Then it would print <b>1 2 3 4 5 6 7 8 9 10</b>: sorting the\r\n    array in ascending order (technically, non-descending order because\r\n    a value can be followed by another one that is equal to it).\r\n  <p>\r\n  How hard would it be to sort the array in the other direction:\r\n    from biggest to smallest.\r\n  We could just replace the call\r\n<b><pre>  Arrays.sort(x,new IntegerComparator());</pre></b>\r\n  by\r\n<b><pre>  Arrays.sort(x,new ReverseIntegerComparator());</pre></b>\r\n    and define\r\n  <pre><b>  public class ReverseIntegerComparator implements Comparator {\r\n    public int compare (Object o1, Object o2) {\r\n      Integer i1 = (Integer)o1;\r\n      Integer i2 = (Integer)o2;\r\n      return -i1.compareTo(i2);   //Notice negation!\r\n    }\r\n  }</b></pre>\r\n  By negating the original returned result\r\n    <ul>\r\n      <li>if <b>i1</b> normally compares less than <b>i2</b> (returns a\r\n            negative value, meaning <b>i1</b> should occur in the array before\r\n            <b>i2</b>) the result this  method returns will be positive\r\n            (indicating that <b>i1</b> is considered greater than <b>i2</b> and\r\n            belong after it in the array)\r\n      <li>if <b>i1</b> compares equal to <b>i2</b> (returns <b>0</b>,\r\n            </b>-0</b> is returned, the same as <b>0</b>\r\n      <li>if <b>i1</b> normally compares greater than <b>i2</b> (returns a\r\n            positive value, meaning <b>i1</b> should occur in the array after\r\n            <b>i2</b>) the result this  method returns will be negative\r\n            (indicating that <b>i1</b> is considered less than <b>i2</b> and\r\n            belong after it in the array)\r\n   </ul>\r\n  Remember that the smaller values, according to the comparator, appear\r\n    towards the front of a sorted array.\r\n  <p>\r\n  In fact, we can write a class with the following amazing property:\r\n    its constructor will take any <b>Comparator</b> and produce an\r\n    object that is also implements <b>Comparator</b>, but one whose\r\n    <b>compare</b> method returns the opposite result of the <b>Comparator</b>\r\n    passed to its constructor.\r\n  With this class in our library (<b>ReverseAComparator</b> is in fact in the\r\n    course library), we can instead of the above write\r\n<b><pre>  Arrays.sort(x,new ReverseAComparator(new IntegerComparator()));</pre></b>\r\n  We can use an object constructed from <b>ReverseAComparator</b> whenever we\r\n    want to reverse any comparator that we have already written, no matter what\r\n    types the comparator is comparing!\r\n  It stores the object it is constructed with and calls its <b>compare</b>\r\n    method, negating the result, whenever its <b>compare</b> method is called.\r\n  We can define this class as follows: it isn't long and therefore it should\r\n     be easy to understand.\r\n   But, I'll admit, understanding is tortuous; it is much easier to understand\r\n     how to use this class than to understand how it works; or put another\r\n     way, we can easily use it without caring how it works: the pinnacle for\r\n     useful tool.\r\n   It is also beautiful.\r\n  <pre><b>  public class ReverseAComparator implements Comparator {\r\n\r\n    public ReverseAComparator(Comparator c)\r\n    {realComparator = c;}\r\n\r\n    public int compare (Object o1, Object o2)\r\n    {return -realComparator.compare(o1,o2);}\r\n\r\n    private final Comparator realComparator;\r\n  }</b></pre>\r\n  This class uses a <b>decorator</b> pattern: it produces an object\r\n    on which we can call the same methods as the object that it was \r\n    constructed with: it decorates the original object.\r\n   I vastly prefer to write and debug a general class and use it multiple\r\n     times than write multiple classes.\r\n   Decorators capture exactly this desire.\r\n  <p>\r\n  As a final example of a class that implements <b>Comparator</b>, imagine that\r\n    we have declared <b>DiceEnsemble[] ds;</b> and stored into it a reference\r\n    to an array object filled with references to <b>DiceEnsemble</b>) objects.\r\n  Now, suppose that we wanted to sort these ensembles, so that the fewer times\r\n    they were  rolled, the early they appear in the sorted array.\r\n  Here is the class needed by <b>Arrays.sort</b>:\r\n  <pre><b>  public class RolledComparator implements Comparator {\r\n    public int compare (Object o1, Object o2) {\r\n      DiceEnsemble d1 = (DiceEnsemble)o1;\r\n      DiceEnsemble d2 = (DiceEnsemble)o2;\r\n      return d1.getRollCount() - d2.getRollCount();\r\n    }\r\n  }</b></pre>\r\n  Notice how simple this class is to write; it looks just like the\r\n    other classes we wrote implementing the <b>Comparator</b> interface.\r\n  Thus, we should consider it simple to use <b>Arrays.sort</b> to sort\r\n    any array, using any ordering criteria; all we need to do is to write a\r\n    simple class implementing the <b>Comparator</b> interface that establishes\r\n    the ordering, and call <b>Arrays.sort</b> with it and the array to sort.\r\n  So, it would also be simple to sort a <b>DiceEnsemble[]</b>, either in\r\n    increasing or decreasing order, the number of times each ensemble was\r\n    rolled, by the number of dice in each ensemble, by the sum of the pips\r\n    showing in each ensemble, etc.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Loose Ends -->\r\n\r\n<a name=\"LooseEnds\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Loose Ends</b></td>\r\n<td width =\"80%\">\r\n  In this section we will discuss a few loose ends about interfaces.\r\n  First, what happens if a class does not specify that it implements an\r\n    interface (doesn't use that keyword in its definition) but actually \r\n    defines all the methods that the interface specifies?\r\n  Can we construct an object from this class and store it in a variable whose\r\n    type is the interface?\r\n  The answer is no.\r\n  <p>\r\n  More concretely, if we define (notice, no <b>implements DecisionInt</b>)\r\n  <pre><b>  public class IsPositive {\r\n    public boolean isOK(int x)\r\n    {return x > 0;}\r\n  }</b></pre>\r\n  then we CANNOT write \r\n  <pre><b>  int answer = AdvancedPrompt.forInt(\"Enter Positive\",\r\n                                      new IsPositive(),\r\n                                      \"...bad choice\");</b></pre>\r\n  The Java compiler believes that an object constructed from the class\r\n    <b>IsPositive</b> cannot be passed to a parameter whose type is specified\r\n    by <b>DecisionInt</b>.\r\n  So, when it comes to interfaces, it does not matter whether or not a class\r\n    implements the specifications in an interface: it does matter whether or\r\n    not its definitions says that it implements the interface.\r\n  Of course, if it says it does, but really doesn't, the Java compiler will\r\n    detect and report an error when it tries to compile that class.\r\n  <p>\r\n  Second, what happens if we have a variable whose type is specified by an\r\n    interface, and we try to use it to call a method that is not specified\r\n    in the interface.\r\n  Whether or not the object that it refers to has such a method, the Java\r\n     compiler will detect and  report an error.\r\n  The only methods that the Java compiler allows to be called on a variable\r\n    whose type is an interface, are those methods specified in the interface.\r\n  Again, this is very important for our future study of Java.\r\n  <p>\r\n  Third, even if we leave off <b>public</b> when specifying an interface, it\r\n    is declared <b>public</b> by default (the same holds for all its method\r\n    specifications).\r\n  The whole purpose of an interface is to specify methods that a class must\r\n    define, that we can call: so they can be only <b>public</b>.\r\n  <p>\r\n  Fourth, can we construct an object from an interface?\r\n  Again, the answer is no.\r\n  If we tried, the Java compiler would detect and report an error.\r\n  So, writing <b>DecisionInt d = new DecisionInt();</b> is MEANINGLESS\r\n    to Java and NOT ALLOWED.\r\n  Thus, the declare/constuct pattern that we've seen does not work for\r\n    interfaces (but see below for how we can use an interface to\r\n    construct an object from an anonymous class)!\r\n  <p>\r\n  Finally, in reality interfaces can also specify <b>public static</b> fields.\r\n  Although doing so it legal, it is not often done.\r\n  In fact, even if the fields are not specified with these access modifiers,\r\n    they are automatically applied by Java.\r\n  <p>\r\n  One more generalization.\r\n  We can use the names of interfaces in <b>instanceof</b> and class casting.\r\n  If <b><i>x</i></b> is the name of a reference variable and\r\n     <b><i>I</i></b> is the name of an interface, Java's returns true for\r\n     <b><i>x</i> instanceof <i>I</i></b> if <b><i>x</i></b> refers to an object\r\n     constructed from any class that implements <b><i>I</i></b>.\r\n  If we cast <b>(<i>I</i>)<i>x</i></b>, Java treats the resulting reference as\r\n    if it refers to an object constructed from any class that implements\r\n    <b><i>I</i></b>; thus, we can call any methods specified in <b><i>I</i></b>\r\n    on the casted reference, or store it in a variable whose type is specified \r\n    by <b><i>I</i></b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n\r\n<!-- Anonymous Classes  -->\r\n\r\n<a name=\"Anonymous\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Anonymous Classes</b></td>\r\n<td width =\"80%\">\r\n  Sometimes we want to construct just one object from a class that\r\n    implements an interface; and often, that class is very small: it\r\n    defines few members because interfaces are often small.\r\n  If that class has no constructor too, Java allows us to construct an object\r\n    from it anonymously, by using the name of the interface directly.\r\n  <p>\r\n  Now, Java allows us to construct an object from an anonymous class by\r\n    directly using an interface.\r\n  For example, we can call\r\n  <b><pre>  Arrays.sort(x, new Comparator() {\r\n                  public int compare(Object o1, Object o2)\r\n                  {return ((Integer)o1).compareTo(o2);}\r\n                 });</pre></b>\r\n  Here, for the second argument, Java constructs an object from an anonymous\r\n    class, using the <b>Comparator</b> interface.\r\n  The anonymous class implements this interface by defining <b>compare</b>,\r\n    the one required method (not inherited).\r\n  Note that we don't need to cast the argument to <b>compareTo</b> because\r\n    the parameter specifies <b>Object</b>.\r\n  Writing this is the  equivalent of writing\r\n  <b><pre>  public class <i>SomeName</i> implements Comparator {\r\n    public int compare(Object o1, Object o2)\r\n    {return ((Integer)o1).compareTo(o2);}\r\n  }\r\n\r\n  Arrays.sort(x, new <i>SomeName</i>());</pre></b>\r\n  Sometimes programmers construct objects from anonymous classes when they\r\n    don't want to go to the \"bother\" of definining a class; technically in\r\n    Java, every class should be placed in its own file (with the same name\r\n    as the name of the class), which requires even more work.\r\n  We will find it convenient to use anonymous classes sporadically.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Write a class named <b>IsSquare</b> that implements the <b>DecisionInt</b>\r\n      interface, whose <b>isOK</b> method returns <b>true</b>\r\n      when its parameter is a perfect square.\r\n    Hint: use casting, <b>Math.sqrt</b> and one (or more) relational operators.\r\n<p>\r\n<li>Write a class named <b>Contraction</b> that implements the\r\n      <b>Univariate</b> interface, whose <b>evaluate</b> method computes the\r\n      formula <b>Math.sqrt(1. - v<sup>2</sup>/c<sup>2</sup>)</b> where <b>c</b>\r\n      represent the speed of light (assume it is <b>2.99x10<sup>8</sup></b>\r\n      meters per second)\r\n<p>\r\n<li>If we construct the object <b>new IsBetween(5,5)</b>, for what values\r\n      (if any) will its <b>isOK</b> method return <b>true</b>?\r\n<p>\r\n<li>Rewrite the <b>integrate</b> method to use the trapezoid rule: the height\r\n      of the rectangle for the interval[x,x+h] is [f(x)+f(x+h)]/2.\r\n    Write a version that computes f(x) only once for each value of x.\r\n<p>\r\n<li>Read the Javadoc of the <b>Point</b> class, which store <b>int</b> x,y\r\n      coordinates.\r\n    Assume that we declare <b>Point[] ps;</b> and store in it a reference to\r\n      an array object filled with <b>Point</b> objects.\r\n    Write a class named <b>OriginDistance</b> that implements the\r\n      <b>Comparator</b> interface.\r\n    By calling <b>Arrays.sort(ps, new OriginDistance());</b> the <b>Point</b>s \r\n      in the array should be sorted from closest-to-the-origin (coordinate 0,0)\r\n      to farthest away from the origin.\r\n<p>\r\n<li>Read the previous problem.\r\n    But this time, generalize the class you are to write.\r\n    Call it <b>DistanceFrom</b> and allow passing its constructor a\r\n      <b>Point</b> object.\r\n    The <b>Point</b>s in the array become sorted based on how close they\r\n      are to the specified point (closer ones appear earlier in the array).\r\n    For example, calling\r\n      <b><pre>  Arrays.sort(ps, new DistanceFrom(new Point(0,0)));</pre></b>\r\n      would produce the same result as in the previous problem.\r\n<p>\r\n<li>Assume that we declare\r\n  <b><pre>\r\n  Comparator c1 = new IntegerComparator();\r\n  Comparator c2 = new ReverseAComparator(new ReverseAComparator(c1));</pre></b>\r\n  Will <b>c1.compare(x,y)</b> ever return a different result from\r\n             <b>c2.compare(x,y)</b>? If so, for what value(s); if not, why?\r\n<p>\r\n<li>Assume that the postconditon of sorting <b>Object[] a</b> by\r\n      <b>Comparator</b> c was only\r\n<b><pre>  c.compare(a[0],a[1]) <= 0</b> and<b>\r\n  c.compare(a[1],a[2]) <= 0</b> and<b>\r\n  ....\r\n  c.compare(a[a.length-2],a[a.length-1]) <= 0</pre></b>\r\n  (constrast this with the actual, two part postcondition above)\r\n  Describe how <b>sort</b> could work to satisfy this postcondition, but\r\n    not satisfy our intuitive understanding of sorting.\r\n<p>\r\n<li>Why can't we write a constructor for an anonymous class?\r\n    How can we still use an anonymous class when calling\r\n      <b>AdvancedPrompt.forInt</b> when trying to accept values only\r\n      in a specified range (as in the <b>IsBetween</b> class)?\r\n    Hint: What other way, besides a constructor, can we use to initialized\r\n      instance variables.\r\n<p>\r\n<li>Write a class named <b>NegateADecision</b> that implements the\r\n    <b>DecisionInt</b> interface, and performs the equivalent purpose\r\n    as <b>ReverseAComparator</b>.\r\n<p>\r\n<li>Which is Java's rule for automatically writing the constructor\r\n  <b><pre>  public class <i>Name</i>()\r\n  {}</pre></b>\r\n  <ol>\r\n    <li>It is automatically written if NO PARAMETERLESS CONSTRUCTOR is \r\n           defined in the class.\r\n    <li>It is automatically written if NO CONSTRUCTOR is \r\n           defined in the class.\r\n  </ol>\r\n<p>\r\n<li>If an interface specifies\r\n<b><pre>  public boolean isOK(int x);</pre></b>\r\nis it legal or not for Java to write a method implementing that interface\r\n  with a different parameter name? e.g.,\r\n<b><pre>  public boolean isOK(int i);</pre></b>\r\n<p>\r\n<li>Without using the negate operator, rewrite the line\r\n<b>return -realComparator.compare(o1,o2);</b> in a different way to\r\n    return the correct result (I can describe the change in 4 words).\r\n   Argue which way is simpler to understand.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}