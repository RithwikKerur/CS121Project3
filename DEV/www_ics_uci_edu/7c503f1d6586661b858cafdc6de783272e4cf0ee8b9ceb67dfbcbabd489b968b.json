{"url": "https://www.ics.uci.edu/~dvk/code/RelDC.html", "content": "<html>\r\n<HEAD>\r\n<TITLE>Source Code | \"RelDC Engine\"</TITLE>\r\n<META NAME=\"description\"\r\n CONTENT = \"RelDC Source Code, RelDC, Entity Resolution, Data Cleaning\">\r\n<META NAME=\"keywords\"\r\n CONTENT = \"RelDC Source Code, RelDC, Entity Resolution, Data Cleaning\">\r\n\r\n<style type=\"text/css\">\r\ntable.sample {\r\n    border-width: 1px;\r\n    border-spacing: ;\r\n    border-style: solid;\r\n    border-color: grey;\r\n    border-collapse: collapse;\r\n    background-color: ;\r\n\r\n}\r\ntable.sample th {\r\n    border-width: 0px;\r\n    padding: 10px;\r\n    border-style: none;\r\n    border-color: blue;\r\n    background-color: #faf0e6;\r\n    -moz-border-radius: ;\r\n\r\n}\r\ntable.sample td {\r\n    border-width: 0px;\r\n    padding: 40px;\r\n    border-style: none;\r\n    border-color: blue;\r\n    background-color: ##f5f5f5;\r\n    -moz-border-radius: ;\r\n    font-family: Arial,Helvetica;\r\n    font-size: 11pt;\r\n}\r\n\r\nh2 {\r\nfont-family: \"Arial,Helvetica\";\r\ncolor: #818501;\r\n}\r\n\r\nh3 {\r\nfont-family: \"Arial,Helvetica\";\r\ncolor: #818501;\r\nfont-size: 16pt;\r\n}\r\n\r\nh4 {\r\nfont-family: \"Arial,Helvetica\";\r\nfont-weight: normal;\r\ncolor: #818501;\r\nfont-size: 14pt;\r\n}\r\n\r\nfont {\r\nfont-family: Arial,Helvetica;\r\nfont-size: 11pt;\r\n}\r\n</style>\r\n\r\n</HEAD>\r\n\r\n<body text=\"#000000\" vlink=\"#4f4f4f\" alink=\"#818501\" link=\"#818501\" bgcolor=\"#ffffff\">\r\n\r\n<p align=\"center\">\r\n        <TABLE width=\"800\" border=\"0\" bgcolor=\"#f5f5f5\" cellspacing=\"10\" ID=\"Table1\" class=\"sample\">\r\n        <TBODY>\r\n        <TR>\r\n        <TD>\r\n\r\n<H3>\"RelDC Engine\" Source Code</H3>\r\n\r\n<font color=\"grey\">Last updated: 2/14/2013</font> \r\n\r\n<H4>Introduction</H4>\r\n</center>\r\n\r\n<p align =justify >\r\n<b>RelDC</b> is an Entity Resolution algorithm that leverages <b>relationships</b> for disambiguation. The traditional approach for entity resolution uses \"features\" associated with a reference/record/object to find references that co-refer, that is, refer to the same object. For some domains using features only could be sufficient to get high quality. For others, using \"features\" only are not enough and much higher disambiguation quality could be achieved by using additional sources of information.<BR> \r\n<BR>\r\nIn our larger <A href=\"http://sherlock.ics.uci.edu\">Project SHERLOCK @ UCI</A> we have studied which other sources and types of information could be used, in addition to just features, to better disambiguate among references. This information could be present in the dataset being cleaned itself (e.g., deeper context, long chains of inter-object relationships) or can be obtained from external data sources, including ontologies, encyclopedias, and the Web.<BR>\r\n<BR>\r\nAs part of Project SHERLOCK @ UCI, we have pioneered a novel entity resolution methodology called Relationship-Based Data Cleaning (<b>RelDC</b>). RelDC relies upon the observation that many real-world datasets are <EM>relational</EM> in nature\r\nand contain not only information about entities (and their \"features\") but also relationships among them, knowledge of which can be used to disambiguate among representations more effectively. RelDC is a principled, domain-independent framework that\r\nexploits the <EM>entity-relationship graph</EM> of the dataset, and specifically\r\nrelationships, for high-quality entity resolution that is self-tuning and requires minimal\r\nintervention by analysts.<BR>\r\n<BR>\r\nThe source code below is what we internally call <b>\"RelDC Engine\"</b>. It is a bare bones implementation of the iterative and most basic version of RelDC.\r\nThe main purposes of the code were:\r\n<ul>\r\n<li>It has allowed us to build more advanced algorithms on top of it, by extending the RelDC Engine code.</li>\r\n\r\n<li>To show that using relationships only (the code largely ignores \"features\", except for blocking) can result in a major quality improvement for certain domains.</li>\r\n\r\n<li>To show that a very efficient implementation of RelDC is possible. This is since the RelDC algorithm contains a part that is difficult to scale: discovering all paths between many pairs of nodes in a large entity-relationship graph. One of the key values of RelDC Engine code is that it contains algorithms that solve this problem efficiently for you. That is why we have used it as an \"engine\" to drive our other approaches.</li>\r\n</ul>\r\n\r\nHence, RelDC Engine code can be very useful to those who want to build other entity-resolution techniques that leverage relationships.\r\n\r\n\r\n</p>\r\n\r\n<H4>How to Cite</H4>\r\nWhen using our \"RelDC Engine\" code please cite it as:<br/>\r\n<br/>\r\n<ol>\r\n\t<LI>\r\n      <B>Domain-independent data cleaning via analysis of entity-relationship graph.</B><BR>\r\n      Dmitri V. Kalashnikov and Sharad Mehrotra.<BR>\r\n      In <EM>ACM Transactions on Database Systems <font color=blue>(ACM TODS)</font></EM>, 31(2):716-767, June 2006<BR>\r\n      [<A href=\"http://www.ics.uci.edu/~dvk/pub/TODS06_dvk.html\">Download Paper</A>]<BR>\r\n      <BR>\r\n\r\n <LI>\r\n      <B>Exploiting relationships for domain-independent data cleaning.</B><BR>\r\n      Dmitri V. Kalashnikov, Sharad Mehrotra, and Zhaoqi Chen.<BR>\r\n      In <EM>Proc. of SIAM International Conference on Data Mining (<font color=blue>SIAM Data Mining</font>)</EM>,\r\n      April 21-23, 2005.<BR>\r\n      [<A href=\"http://www.ics.uci.edu/~dvk/pub/SDM05_dvk.html\">Download Paper</A>]<BR>\r\n</ol>\r\n<br/>\r\nThe above publications describe RelDC engine in detail. BibTeX entries for these publications are:\r\n\r\n<pre>@article{TODS06::dvk,\r\n   author    = {Dmitri V.\\ Kalashnikov and Sharad Mehrotra},\r\n   title     = {Domain-independent data cleaning via \r\n                analysis of entity-relationship graph},\r\n   journal   = {{ACM Transactions on Database Systems (ACM TODS)}},\r\n   volume    = 31, number = 2, pages = {716--767}, month = jun, year = 2006\r\n}\r\n</pre>\r\n\r\n<pre>@inproceedings{SDM05::dvk,\r\n   author    = {Dmitri V. Kalashnikov and Sharad Mehrotra and Zhaoqi Chen},                 \r\n   title     = {Exploiting relationships for domain-independent data cleaning},\r\n   booktitle = {SIAM International Conference on Data Mining (SIAM SDM)},\r\n   year      = {2005}, month = {April 21--23}, address = {Newport Beach, CA, USA}\r\n} \r\n</pre>\r\n\r\n<H4>Downloading Code</H4>\r\n<list>\r\n\t<li>RelDC code can de downloaded from here: \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/RelDC_code.zip\">RelDC_code.zip</A>] \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/License.txt\">License</A>] \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/RelDC_data.zip\">RelDC_data.zip</A>]</li>\r\n\t<li>RelDC is implemented in C++</li>\r\n\t<li>The code is designed for UNIX in general</li> \r\n\t<li>The code has been tested under Solaris, Linux, and Mac OS X</li>\r\n\t<li>GCC 4.7 has been used to compile the code.</li> \r\n\t<li>Code generated by GCC is faster than that by the default compiler in Mac OS X. Please use the latest GCC to compile the code.</li>\r\n</list>\r\n\r\n<H4>Compiling Code</H4>\r\n<list>\r\n\t<li>Unzip <tt>RelDC_code.zip</tt> file. The code will be inside <tt>RelDC-Gen</tt> folder. The main file is <tt>main.cpp</tt>.</li>\r\n\t<li>Unzip the sample datasets file. The resulting folder is <tt>datasets</tt>.</li> \r\n\t<li>Edit <tt>RelDC-Gen\\config\\Config.xml</tt> file to set/adjust the desired parameters for the program.</li>\r\n\t<li>Edit <tt>./mak</tt> batch file: change the path of GCC's C++ compiler (<tt>g++</tt>) to where it is located in your system.</li>  \r\n\t<li>To compile, run <tt>./mak</tt> inside <tt>RelDC-Gen</tt> folder.</li>\r\n\t<li>Compilation will produce executable file called <tt>./run</tt>.</li>\r\n\r\n            \r\n<H4>Running Code</H4>\r\n            \r\n<tt>./run</tt>\r\n\r\n            \r\n<!--<H4>Options</H4>\r\n            <table width=\"100%\">\r\n                <tr height=40>\r\n                    <td width=\"25%\"><tt>eps</tt></td>\r\n                    <td width=\"75%\">The value of &epsilon; to use in the &epsilon;-join.</td>\r\n                </tr>\r\n                <tr height=40>\r\n                    <td width=\"25%\"><tt>A_sz</tt></td>\r\n                    <td width=\"75%\">Cardinilaity |A| of dataset A, in thousands. E.g., specifying 68 corresponds to |A| = 68,000.</td>\r\n                </tr>\r\n                <tr height=40>\r\n                    <td width=\"25%\"><tt>B_sz</tt></td>\r\n                    <td width=\"75%\">Cardinilaity |B| of dataset B, in thousands. E.g., specifying 25 corresponds to |B| = 25,000.</td>\r\n                </tr>\r\n                \r\n                <tr height=40>\r\n                    <td width=\"25%\"><tt>skew</tt></td>\r\n                    <td width=\"75%\">Parameter <tt>skew</tt> can be set to 0, 2, or 3 to mean:<font size=4><br><br></font>\r\n                        <tt>0</tt> - uniform: the code will generate uniform A and B d-dimensional datasets.<br>\r\n                        <tt>2</tt> - from file: the code will load d-dimensional data from the file specified in <tt>const.h</tt>.<br>\r\n                        <tt>3</tt> - uniform self-join: the code will generate uniform A, and then join it with itself.\r\n                    </td>\r\n                </tr>\r\n                <tr height=40>\r\n                    <td width=\"25%\"><tt>num_thread</tt></td>\r\n                    <td width=\"75%\">The number of parallel threads of execution to use. The best number typically corresponds to the level of parallelism the machine has. It also can be determined experimentally, once per machine, by increasing it starting from 1 and observing for which value the performance is the best.</td>\r\n                </tr>\r\n            </table>\r\n            \r\n            \r\n\r\n<H4>Examples</H4>\r\n1) Performing an &epsilon;-join on uniform datasets A and B, for &epsilon; = 0.1 and where |A| = 68,000 and |B| = 25,000 and the number of threads is 8. The dimensionality d of the generated data in A and B will be determinied by <tt>NUM_DIM</tt> varible from <tt>const.h</tt> file.<br>\r\n<br>\r\n<tt>./index 0.1 68 25 0 8</tt><br>\r\n            <br>\r\n            <br>\r\n<br>\r\n2) Performing an self-join of uniform datasets A, for &epsilon; = 0.2 and where |A| = 45,000 and the number of threads is 4. The dimensionality d of the generated data in A will be determinied by <tt>NUM_DIM</tt> varible from <tt>const.h</tt> file.<br>\r\n<br>\r\n<tt>./index 0.2 45 45 3 4</tt><br>\r\n            <br>\r\n            <br>\r\n<br>\r\n3) Performing an self-join of a real dataset ColorHist, for &epsilon; = 0.1 whose cardiniality is 68,000 using 8 threads. In <tt>const.h</tt>, variables <tt>NUM_DIM</tt> and <tt>DATA_FILE</tt> should be set to 32 and to the path of <tt>ColorHist.txt</tt>, respectively and the code should be recompiled.<br>\r\n<br>\r\n<tt>./index 0.1 68 68 2 8</tt><br>\r\n            \r\n\r\n-->\r\n            \r\n            \r\n<IMG SRC=\"https://students.ics.uci.edu/~dvk/fig.cgi?RelDC_code\" width=1 height=1>\r\n</p>\r\n<BR>\r\n<BR>\r\n<A href=\"http://www.ics.uci.edu/~dvk/index.html\">Back to Kalashnikov's homepage</A>\r\n<BR>\r\n<BR>\r\n<center><font face=\"Arial,Helvetica\" style=\"font-SIZE: 8pt\" color=\"gray\"> Copyright &copy; 2013 Dmitri V. Kalashnikov. All Rights Reserved.</font></center>\r\n</html> ", "encoding": "ascii"}