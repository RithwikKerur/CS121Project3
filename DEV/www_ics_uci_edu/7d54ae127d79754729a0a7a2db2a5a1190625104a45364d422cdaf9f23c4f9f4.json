{"url": "https://www.ics.uci.edu/~ejw/authoring/draft-goland-http-webdav-00.txt", "content": "\n\n\n\n\n\n          WEBDAV Working Group                         Y. Goland, Microsoft\r          INTERNET-DRAFT                       E. J. Whitehead, U.C. Irvine\r          <draft-goland-http-webdav-00.txt>              A. Faizi, Netscape\r                                                          D. Jensen, Novell\r          Expires May 25, 1997                            November 26, 1996\n\n                                   Extensions for\r                        Distributed Authoring and Versioning\r                                on the World Wide Web\n\n          Status of this Memo\n          This document is an Internet-Draft. Internet-Drafts are working\r          documents of the Internet Engineering Task Force (IETF), its\r          areas, and its working groups. Note that other groups may also\r          distribute working documents as Internet-Drafts. \r          Internet-Drafts are draft documents valid for a maximum of six\r          months and may be updated, replaced, or made obsolete by other\r          documents at any time. It is inappropriate to use Internet-Drafts\r          as reference material or to cite them other than as \"work in\r          progress\".\r           \r          To learn the current status of any Internet-Draft, please check\r          the \"1id-abstracts.txt\" listing contained in the Internet-Drafts\r          Shadow Directories on ftp.is.co.za (Africa), nic.nordu.net\r          (Europe), munnari.oz.au (Pacific Rim), ds.internic.net (US East\r          Coast), or ftp.isi.edu (US West Coast).\r           \r          Distribution of this document is unlimited. Please send comments\r          to the WWW Distributed Authoring and Versioning (WEBDAV) working\r          group at <w3c-dist-auth@w3.org>, which may be joined by sending a\r          message with subject \"subscribe\" to\r          <w3c-dist-auth-request@w3.org>. Discussions of the WEBDAV working\r          group are archived at\r          <URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n          The HTTP working group at <http-wg@cuckoo.hpl.hp.com> also\r          discusses the HTTP protocol. Discussions of the HTTP working\r          group are archived at\r          <URL:http://www.ics.uci.edu/pub/ietf/http/>. General discussions\r          about HTTP and the applications which use HTTP should take place\r          on the <www-talk@w3.org> mailing list.\n\n          Abstract\n          WEBDAV is a set of application-level protocol methods and types\n\n          Goland, et al                                                   1\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          which provide core functionality for distributed authoring and\r          version control.  It is intended to mediate client/server\r          transactions providing support for effecting Distributed Editing,\r          managing and using Meta Data, manipulating Namespaces, and\r          effecting Version Control.\n          WEBDAV is not a stand-alone protocol.  Rather, it is an extension\r          of HTTP/1.1 [HTTP11], and as such strives to conform (where\r          possible and reasonable) with those attributes which characterize\r          the essential nature of HTTP/1.1; namely, to be generic,\r          stateless, and object-oriented.  The WEBDAV strategy is to\n               1.   Implement methods where possible (object-oriented),\n               2.   Leverage links (as defined in [HTTP11]).\n\n          1. Introduction \n          1.1 Purpose \n          The purpose of this document is to extend the HTTP 1.1 [HTTP11]\r          protocol to support features which satisfy the Distributed\r          Authoring and Versioning requirements set down in [draft-durand-\r          http-webdav-??].\n          1.2 Terminology\n          Unless otherwise noted, the use of terminology in this document\r          is consistent with the definitions of terms given in [HTTP11].\r           \r          arbiter\r                A resource which performs actions on the behalf of other\r                resources.\n          attribute\r                An attribute is a name/value pair which contains\r                meta-information regarding a resource. See section 2,\r                Attributes.\n          attribute set \r                An attribute set is a collection of attributes. See\r                section 2.4, Standard Attributes.\n          set edit announcement\r                A set edit announcement is a declaration by a principal\r                that they intend to edit a resource. No action other than\n\n          Goland, et al                                                   2\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n                the declaration is implied by a set edit announcement. See\r                section 8.1, Set Edit Announcement/Remove Edit\r                Announcement.\n          remove edit announcement\r                A remove edit announcement is a declaration by a principal\r                that they no longer intend to edit a resource. See section\r                8.1, Set Edit Announcement/Remove Edit Announcement\n          command comments \r                Command Comments associate either a string or a URI with\r                an HTTP message. See section 9.1, Command Comments.\n          copy \r                A copy performs a duplication of a resource, making it\r                available at both the original and new location in the URI\r                namespace. Due to contextual differences, it may not be\r                possible to create an exact copy of a resource. A copy\r                only requires best effort on the part of the copy agent.\r                See section 4.1, Copy.\n          collection\r                A group of URIs which are manipulated as a unit. Please\r                see section 7, URI Collections.\n          destroy \r                To destroy a resource is to request that the resource be\r                permanently removed from storage. This differs from delete\r                in that some versioning systems handle delete as a request\r                to no longer make the specified resource available under\r                the specified URI. See section 4.2, Destroy.\n          diff \r                A diff is a mechanism whereby two or more resources are\r                compared and the differences enumerated. See section 8.2,\r                Diff. \n          history \r                A history lists the URIs of the versions of a resource\r                along with related information. See section 9.2, History.\n          merge \r                A merge is the process whereby information from multiple\r                resources is folded into a single resource. Merges can\r                occur at the client or the server. See section 8.3, Merge.\n          move \n\n          Goland, et al                                                   3\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n                A move is logically an atomic action consisting of a copy\r                followed by a delete of the source resource. See the\r                definition of copy in this section.  Also see section 4.4,\r                Move.\n          no-modify lock \r                A no-modify lock prevents a locked resource from being\r                edited until all no-modify locks on the resource are\r                released. See section 3, Lock.\n          notify request \r                A notify request instructs the recipient to send\r                information regarding the progress of a request. See\r                section 6.1, Notify Request.\n          principal \r                A principal is the source of a message. For example:\r                persons, computers, and programs.\r           \r          read lock \r                A read lock prevents principals who do not posses a read\r                lock on a resource from reading that resource. See section\r                3, Lock.\n          redirect\r                A redirect instructs a server to return one of the 3xx\r                series codes. See section 4.5, Redirect.\n          relationship \r                A relationship is a unidirectional typed link. See section\r                5, Relationships.\n          shared mode \r                Shared mode modifies a lock request such that the lock may\r                be shared between multiple principals. See section 3,\r                Lock.\n          write lock \r                A write lock prevents principals who do not possess a\r                write lock on a resource from editing that resource. See\r                section 3, Lock.\n          1.3 Notational Conventions and Generic Grammar \n          This specification uses the Augmented BNF and Basic Rules as\r          defined in Section 2 of [HTTP11]. \n\n\n          Goland, et al                                                   4\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          1.4 Design Conventions\n          The following design conventions have been adopted by the HTTP\r          Distributed Authoring and Versioning (DAV) group.\n         1. Whenever reasonable new functionality will be expressed as new\r            methods. When sensible the commands for such a method will be\r            included in the message body of the request.\n          This resolution was adopted in order to solve a debate about how\r          to express new functions such as copy and diff. One group wished\r          to use POST and MIME types to express new commands. Another group\r          wished to use new methods and MIME types to express new commands.\r          A third group wished to use new methods and new method headers to\r          express new commands. The group settled on using new methods and\r          MIME types to express new commands. The new methods would allow\r          for quick parsing by proxies and servers but the MIME types would\r          allow for flexibility in specifying the command. It was also felt\r          that introducing method specific headers would violate the letter\r          and spirit of the HTTP protocol.\n         2. Methods should only perform a single action.\n          The original design of many of the methods in this document\r          allowed for multiple requests of the same type to be packaged\r          together. So, for example, one could send a Copy method which\r          specified that 1000 different URIs should be copied. It was\r          decided that in the face of pipelining, compressed headers, and\r          other innovations there was no need to add this level of\r          complexity to the protocol. This decision was based upon the\r          assumption that a new method or MIME type would be introduced\r          which would allow for any number of HTTP requests to be bundled\r          together. It was further assumed that such a method or MIME type\r          would carry with it the option to specify that the contents be\r          processed atomically.\n         3. URLs are opaque tokens and should be treated as such.\n          It is often possible to decrease the number of trips to retrieve\r          a particular piece of data by putting suffixes on URLs. However\r          URLs are intended to be opaque tokens. The above design principal\r          not prevent the use of suffixes but rather requires that the\r          server indicates that a particular URL understands a particular\r          type of suffix.\n         4. Only addressable entities will be subject to the commands in\r            this document.\n\n          Goland, et al                                                   5\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n\n          It is sometimes desirable to have a non-addressable entity. For\r          example, an accept header may specify a content-language. The\r          response may contain a representation in that language but may\r          not contain a content-location header. In that case the\r          representation of that resource in that language will not\r          alterable with the commands given in this document.\n         5. This document will only specify client to server communication.\n          Some of the actions possible in this document require server to\r          server communication in order to be effectively implemented. For\r          example, atomically locking two resources that reside on two\r          different servers. This document will not specify such\r          interactions. Rather this document will specify how such requests\r          are made by a client of a server.\n\n          2. Message/Multipart\n          [TBD. Specify a mechanism for bundling a bunch of HTTP messages\r          together.  Should contain a switch to indicate if the messages\r          must all be executed atomically or rejected. Also need to define\r          a message/multipart response type so we can bundle together all\r          the responses. Must stipulate that there will be a single\r          response for the multipart message itself and then a bunch of sub\r          responses for everything contained in the multipart. \r          Explain the idea that if you combine a bunch of methods\r          atomically it is possible to define semantics for that particular\r          combination and order. Example: a notify followed by a lock\r          followed by a GET all wrapped in an atomic package means CheckOut\r          with all the connotations.]\n\n          3. Links\n          3.1 Introduction\n          In [HTTP11] link and unlink methods were introduced. The idea was\r          to allow for two or more arbitrary resources to be associated\r          with each other. In essence to recreate the link facility already\r          existing in HTML.\n          This document proposes a more powerful link facility which\r          specifies that links are typed and directional.\n          3.2 Link Types\n\n          Goland, et al                                                   6\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          Links are typed. These types explain the purpose and behavior of\r          a link. When a server allows a link of a particular type to be\r          created it is accepting a contract, it is saying that it\r          understands the type of link being created and is willing to\r          enforce its semantics.\n          Link types should be thought of as inheritable objects. It is\r          completely reasonable to create a new type of link by specifying\r          that it inherits the features of one or more links.\n          3.3 Definition of Link/Unlink Methods\n          The link method creates or modifies a link.\n          The unlink method removes links.\n          The request-URI is the resource which should record the link.\n          3.4 Definition of Content Type Message/Link\n          A message/link MIME type contains a request to create a single\r          undirectional link. If a link type is defined so as to require a\r          bidirectional link then message/multipart with an atomic\r          indication can be used to create both directions of the link.\n          Link = [(Source | Destination)] Type\r          Type = Text\r          Source = \"Source\" \":\" URI\r          Destination = \"Destination\" \":\" URI\r          Which ever URI is included in the content-type, the request-URI\r          is the other end of the link.\r          If a source or destination is not included then the request-URI\r          is both.\n\n          3.5 Definition of Content Type Message/LinkResult\n          It is often the case that a resource is created solely to act as\r          the source or destination of a link. It is also often the case\r          that because of the underlying implementation a server can only\r          accept certain kinds of links if the source or destination exists\r          within a certain namespace. Rather than requiring negotiation on\r          this issue the message/link syntax allows for a link to be\r          requested without specifying either the source or destination.\r          The response body, as specified below, will then return a URI\r          which the link has been connected to. The client may then set the\r          URI to an appropriate value. Note, however, that the URI may not\n\n          Goland, et al                                                   7\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          necessarily be empty. It is possible, for consistency reasons,\r          that the arbiter may put a default or other value at the URI.\r          LinkResult = Type Source Destination\n          3.6 Definition of Content Type Message/Unlink\n          Unlink = Type Source Destination\n          3.7 Definition of Content Type Message/UnlinkResult\n          UnlinkResult = Type Source Destination\n          3.8 Definition of LinkSearch Method\n          The LinkSearch method is used to search on the link type name\r          space. The request URI is a LinkSearch arbiter that will perform\r          the search on behalf of the client.\n          This syntax is adapted from [RFC1959] and [RFC1960]. However the\r          substring syntax has been greatly simplified as many servers will\r          not be willing to support the more complex syntax. [TBD - Does\r          the group agree with this assessment? Note: have also removed the\r          \"~=\" operator as link names are not necessarily in any particular\r          language so approximate is meaningless.]\n          A pure prefix format has been chosen to simplify the server side\r          processing. Given the already expensive nature of a search the\r          choice seems appropriate.\n          LinkSearchMethod = [\"ReturnValue\"] CRLF URI CRLF SearchFilter\r          CRLF ReturnValues CRLF Scope CRLF\r          SearchFilter = FilterList CRLF\r          FilterList = And | Or | Not | Item\r          And = \"&\" FilterList 1*FilterList\r          Or = \"|\" FilterList 1*FilterList\r          Not = \"!\" FilterList\r          Item = Simple | Present | Substring\r          Simple = EqualityOperator Type MatchPattern\r          EqualityOperator = \"=\" | \">\" | \">=\" | \"<\" | \"<=\" | \"!=\"\r          MatchPattern = token\r          Present = \"=*\" AttributeName\r          SubString = [\"*\"] token [\"*\"]\r          ReturnValues = 1#Attribute CRLF\r          Scope = \"base\" | \"one\" | \"sub\"\n          The ReturnValue switch specifies that when possible the result\r          should include the value of the link destination rather than its\n\n          Goland, et al                                                   8\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          URL. In such a case the search result should be combined with the\r          results of a GET on the destination into a message/multipart. If\r          the search resolves to more than one result then the results of\r          the request are dependent upon the result format.\r           \r          Equality is based on an octet by octet matching.\n          The scope operator has three values, base, one, and sub. Base\r          means to only search the specified URI. One means to search the\r          URI and one level down the tree rooted at the URI. Sub means to\r          search the URI and the entire URI name space rooted at that URI.\n          3.9 Definition of LinkSearch Header\n          The LinkSearch method can be expensive, especially when a number\r          of attributes must be retrieved over time.\n          A more economical mechanism is to append a search string to URL\r          using \"?\". However, the URL could be confused with any of a\r          number of search syntax's. The solution proposed by this document\r          is to create a new header called LinkSearch.\n          LinkSearch = \"LinkSearch\" \":\" HTTP_url ; See section 3.2.2 of\r          [HTTP11]\n          If the HTTP URL does not end in a \"/\" then a \"?\" may be appended\r          to it and the attribute search syntax defined below may be used\r          to search for attributes on that particular resource. If the URL\r          does end with a \"/\" then any resource whose name is a child of\r          the specified HTTP URL may be searched on directly.\r          To perform a search a string matching the following syntax should\r          be used.\n          LinkSearchSuffix = \"?\" Attribute\r          Attribute = token\n          So, if the LinkSearch value is http://foo/bar then a search on a\r          link type of author would be performed using\r          http://foo/bar?author. If the returned value is http://foo/bar/\r          then the author search may be performed on http://foo/bar/?author\r          and any of its children, such as http://foo/bar/doublebar?author.\r          By returning the LinkSearch header the server is agreeing to\r          manipulate the search URL as it would the URL of the resource it\r          resolves to. Thus it becomes the responsibility of the server to\r          resolve the search URL whenever it is included in a command.\r          If it is impossible to resolve the search request to a single\r          result then a 416 Not Unique error should be returned. This error\n\n          Goland, et al                                                   9\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          specifies that the URI was not resolvable to a unique resource.\r          If the search URI does not resolve to any attribute then any\r          request containing that URI should return a 404 Not Found error.\n          3.10 Definition of LinkPrefix Header\n          In some cases a server may have an arbiter which handles all\r          searches on resources. To allow for the use of the arbiter but\r          still gain the advantages of URL based searching the LinkPrefix\r          is introduced.\n          LinkPrefix = \"LinkPrefix\" \":\" HTTP_url\n          To retrieve a particular attribute the following syntax should be\r          used:\n          LinkPrefixSuffix = \"?\" URL LinkSearchSuffix\n          Thus the returned URL has the URL to be searched on appended to\r          it followed by the actual search syntax as previously specified.\r          This allows for quick retrieval of attribute values but with the\r          benefit of processing requests at a single resource.\r          The URI returned by LinkPrefix has the same use semantics as the\r          URI returned by LinkSearch.\n\n          4. Attributes \n          [TBD - Explain that attributes sometimes use Destination to\r          record their value and sometimes use Type. Specifically we can\r          have attributes whose value is their type by having the\r          destination pointing to the source.]\r          [TBD - Also give a template for how attributes are specified.\r          Specifying their type description and the contents of the\r          destination.]\n          The following attributes have their name and semantics defined by\r          this specification.\r           \r          [TBD - Currently only brief descriptions are included.  Decide\r          which ones should survive and provide MIME types and other\r          information.] \n          AttributeSet \r                This attribute returns a list of the attribute sets\r                currently being used to describe the resource. Support of\r                an attribute set does not indicate that all of its\n\n          Goland, et al                                                  10\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n                attributes are being used. For a list of all attributes in\r                use, the AttributeDirectory attribute should be retrieved.\r                For example, if some attributes from the Dublin Core were\r                being used to describe a resource, AttributeSet might\r                contain the value \"Dublin\", or \"DC\". The tag used to\r                denote attributes defined in this specification is\r                \"RFCxxxx\". \n          IntentToEdit \r                This attribute header returns a SiteMap containing a list\r                of principals who have performed a Set Intent to Edit.\n          DirectoryName \r                This attribute returns a name suitable for presentation in\r                a directory. The attribute embeds content headers to\r                indicate language, character set, etc.\n          History \r                See History, section 9.2.\n          Link \r                Contains information about resources that are related to\r                this resource. A SiteMap representation SHOULD be available.\r                [TBD: Review the SiteMap format and figure out tag formats\r                to define source links.]\n          Link.Version \r                See Version, Section 9.3.\n          LockInformation \r                See Lock Discovery, Section 3.2.\n          Modifiable (weak form of access control query) \r                Indicates if the principal can modify the resource.\n          NotifyRequest \r                See Notify Request, Section 6.\n          Source \r                The URI of the resource as stored, without any processing\r                by the server (e.g. without processing of server-side\r                includes).\n          Version \r                See Version, Section 9.3.\n\n\n\n          Goland, et al                                                  11\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          5. Relationships - [Note: preliminary and incomplete]\n          [TBD - Relationship should be a set of links. Should probably use\r          the idea of atomic mime types to create both directions of a link\r          simultaneously or to create a n-ary link. N-ary links will\r          probably need some sort of token. What if many different parent\r          child relationships? They can't all use the same damn name.\r          Containers may be the real solution to n-ary links. Of course,\r          container section incomplete]\n          A relationship specifies how two or more resources are related.\r          Examples of relationships include \"author-of,\" \"table of\r          contents,\" and \"specifies.\" A relationship can exist within a\r          resource, and between mutliple resources. These resources may be\r          of any media type, and a relationship can exist between resources\r          of differing media type.\n          When considering relationships which exist between resources, due\r          to the distribution of resources across the Web, it is often the\r          case that the relationship spans multiple servers. As a result,\r          instead of being stored once, between resources, the endpoints of\r          a relationship must be stored on individual resources. For the\r          purposes of this specification, a relationship is defined to be a\r          set of relationship endpoints.\n          To create a multiway (or n-ary) relationship, a client must\r          individually create each endpoint of the relationship, specifying\r          at each endpoint which other relationship endpoints (usually on\r          other resources) are part of the relationship.\r           \r          A hypertext link is a relationship which a client has made\r          available to the user interface so a user can jump to the other\r          endpoints of the relationship using the hypertext\r          point-click-and-traverse user interface style.\n          A link is always a relationship, but a relationship is not always\r          a hypertext link. \n          To request the creation of a relationship endpoint, a POST\r          message with entity body of content-type application/relationship\r          should be issued to the administration resource for\r          relationships. \n          5.1 Definition of Content Type Application/Relationship \n          REL/BODY = Relationship-request | Relationship-response\r          Relationship-request = 1*( Rel-action Rel-token Rel-spec )\n\n          Goland, et al                                                  12\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          Relationship-response = 1*( Rel-action Rel-token Rel-spec\r          Rel-response ) \r          Rel-spec = Rel-URI Link ; Link is defined in Section 19.6.2.4 of\r          [HTTP11]\r          Rel-URI = \"URI\" \":\" URI\r          Rel-action = \"Add\" | \"Remove\" | \"Modify\"\r          Rel-token = *1(\"RToken\" \":\" rtoken) ; Specifying token for an Add\r          request is optional\r          Rel-status = Status-Code SP Reason-Phrase ; As defined in [HTTP11]\r          rtoken = token \n          The ability to specify relationship endpoints on resources of any\r          content type is mostly provided by the Link entity header field\r          defined in 19.6.2.4 of [HTTP11]. The Link entity header field is\r          used in this specification, with minor additions which add the\r          ability to specify that another endpoint belongs to this\r          relationship. This capability is provided by an additional\r          link-param field, called peer. The contents of a peer field are a\r          sequence of (URI, relationship token) tuples, which list the\r          opposite endpoints of the relationship. The relationship token\r          MUST uniquely identify a relationship endpoint on a particular\r          resource, but does not have to be globally unique across all\r          resources. \n          ( \"peer\" \"=\" 1# \"(\" <\"> URI <\"> \",\" rtoken \")\" )\n          An example of content type application/relationship is: \n          Add\r          URI: http://www.ics.uci.edu/authoring/meeting/intro.html\r          RToken: 1\r          Link: <http://www.ics.uci.edu/authoring/meeting/agenda.html>;\r          rel=\"Child\";\r          peer=(\"http://www.ics.uci.edu/authoring/meeting/agenda.html, 2) \r          Add \r          URI: http://www.ics.uci.edu/authoring/meeting/agenda.html\r          RToken: 2\r          Link: <http://www.ics.uci.edu/authoring/meeting/intro.html>;\r          rel=\"Parent\";\r          peer=(\"http://www.ics.uci.edu/authoring/meeting/intro.html\", 1) \n          This defines a binary parent-child relationship between\r          intro.html and agenda.html. From this example, it may seem that\r          having the URI in the peer field is redundant. For binary\r          relationships, this is indeed the case. However, the URI is\r          required for multiway relationships, where more than one peer\r          link needs to be specified in a peer parameter. \n\n          Goland, et al                                                  13\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n\n          6. Lock/Unlock \n          [Note:\r          a) I'd like to see more discussion about the semantics of the\r          transitions from exclusive to shared (and vice-versa) locking\r          modes.\r          b) There needs to be more discussion about sub-document locking,\r          and the interactions between a sub-document lock and full\r          document lock, and the compatibilities of these cases. For\r          example, an exclusive sub-document write lock is compatible with\r          a full document shared write lock, but a shared sub-document\r          write lock is not compatible with an exclusive full document\r          write lock (on the same document, of course).\r          c) There needs to be some discussion on which headers have\r          defined semantics when included in a lock request. For example,\r          \"Max-Forwards:\" does not make sense in this context. May other\r          header fields might make sense, but would have slightly different\r          semantics than defined in HTTP/1.1.]\n          In order to provide for maximum flexibility and ease of\r          administration, lock tokens will be used to track locks. When a\r          lock is taken out a lock token will be returned. A single lock\r          token can represent any number of locks. In future lock requests\r          the same token may have new locks added or old locks removed from\r          it. Lock tokens are not required to be transferable between lock\r          administration resources. \n          A lock has three possible types: read, write and no-modify. The\r          following table specifies the legal combinations of locks on the\r          same resource or, in the case of content-range, the same range of\r          a lock.\n                           Read            Write           No-Modify\r          Read             Legal if        Legal           Legal\r                           Shared\n          Write            Legal           Legal if        Illegal\r                                           Shared\n          No-Modify        Legal           Illegal         Legal if\r                                                           Shared\n          A lock may be assigned to a range of a resource. The range may go\r          off the \"end\" of the representation. Locks that exceed the end of\r          a representation control the ability to append to the\r          representation. \n\n          Goland, et al                                                  14\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          A lock may be taken out either in exclusive or shared mode. In\r          shared mode anyone with proper access may take out a lock. In\r          exclusive mode only the principal who originally took out the\r          lock may edit the lock. However a new principal can be added to\r          an exclusive lock if the holder of the lock token performs the\r          addition. \n          If an entire resource is write locked and a lock owner deletes\r          the resource then the write lock remains. Thus new information\r          can be added to the now deleted resource using a PUT.\r           \r          Locks have time outs associated with them. If no time out value\r          is associated with a lock then the lock will never time out.\r          Otherwise the lock will expire if a number of seconds equal to\r          the time out value passes without the resource being accessed by\r          a lock owner. The time out value may be edited, without affecting\r          the rest of the lock, by submitting a lock request with no Lock\r          Entries.\r           \r          [TBD - Need an error message indicating that the server will not\r          accept certain lock combinations or accept overlapping locks.\r          Also need an error stating that an unlock couldn't be executed\r          because it did not exactly match with a lock.] \n          Locks will be implemented using the LOCK method. The request-URI\r          is the resource to be locked. The entity-body type message/lock\r          is also defined in this document. The response type\r          message/lockresponse is also defined.\n          6.1 Definition of Content Type Message/Lock \n          LockBody = Token_Status Time_Out Lock_Owners Lock_Entry\r          Token_Status = (Token_Field | \"No Token\")\r          Token_Field = \"Lock Token\" \":\" LockToken\r          LockToken = Any OCTET but LWS\r          Time_Out = \"Time Out\" \":\" (*DIGIT | \"Never\")\r          Lock_Owners = \"Lock Owner\" \":\" Lock_Owner\r          Lock_Owner = quoted-string\r          Lock_Entry = \"Lock Entry\" \":\" LockEffect\r          LockType CRLF\r          LockEffect = (\"Write\" | \"Read\" | \"No-Modify\")\r          LockType = ((\"Exclusive\" |\"Shared\") | \"Unlock\")\n          Examples of type application/lock include: \n          No Token\r          Time Out: Never\n\n          Goland, et al                                                  15\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          Lock Owner: \"Yaron Goland yarong@microsoft.com\"\r          Lock Entries: http://www.microsoft.com/staff/yarong.html Write\r          Exclusive \r          This specifies a request for an exclusive write lock on\r          http://www.microsoft.com/staff/yarong.html, held by Yaron Goland.\r          This lock will never time out. \n          6.2 Definition of Content Type Message/LockResponse\n          LockResponse = 1#Description [LockBody]\r          Description = quoted-string\n          6.3 Processing a Lock Request \n          A lock request without a LockToken is a new lock request. If the\r          request is successful then the response will include a lock\r          token. \n          A lock request with a LockToken is a request to extend the lock\r          represented by the lock token. \n          A lock request with Unlock specified for Lock_Request means that\r          all locks associated with this token should be removed. \n          A lock entry with Unlock means this particular lock should be\r          removed from the token. \n          The BNF allows unlocks to be specified without specifying a lock\r          token. This is not an error. This syntax allows authorized\r          principals to override locks. \n          Lock requests MUST be processed as an atomic action or the\r          request must be refused. \n          When multiple resources are locked under a single token an\r          operation will only be allowed on any of the resources if the\r          remaining locks in the token can be guaranteed to exist for the\r          life of the operation. \n          6.4 Lock Discovery \n          [TBD - Needs sanity check.]\r          When a lock is taken out the system SHOULD record who owns the\r          lock. Ownership information can be taken from the From header,\r          from identification provided by authentication, or from the\r          LockOwners field.  This information SHOULD be available through\r          the attribute \"LockInformation\" which has the mime type\n\n          Goland, et al                                                  16\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          application/LockInformation.  The format of the mime entity-body\r          is: \n          LOCKINFORMATION = #(Token_Field Time_Out Lock_Owners\r          Lock_Entries) [Contact_Field]\r          Contact_Field = \"Contact\" \":\" token \n          The Contact_Field is used to provide contact information in case\r          there is a problem with a lock. \n          An example of a LockInformation attribute is: \n          LockInformation:\r          Token: a5dzq \r          Time Out: Never \r          [Yaron Goland <yarong@microsoft.com]\r          Lock Entries: URI http://www.microsoft.com/staff/yarong.html\r          Write Exclusive\r          Contact: Lock Administrator <lockadmin@microsoft.com> \n          The exclusive write lock on\r          http://www.microsoft.com/staff/yarong.html is held by Yaron\r          Goland, has token value a5dqz, and will never time out. If there\r          is a problem with a lock, the Lock Administrator should be\r          contacted. \n\n          7. Name Space Manipulation\n          7.1 Definition of Copy Method\n          A copy performs a byte-for-byte duplication of a resource, making\r          it available at both the original and new location in the URI\r          namespace.  There is no guarantee that the result of a GET on the\r          URL of the resource copy will be identical to a GET on the\r          original resource.  For example, copying a script to a new\r          location will often remove it from its intended environment, and\r          cause it to either not work, or produce erroneous output.  A copy\r          MUST be atomic.\r           \r          Before any copied resources are made available through the\r          destination, all copied resources must either be available or\r          return a 503 Service Unavailable response code when referenced. \r          A copy is preformed by the COPY method. The request-URI is the\r          destination of the copy. The content-type Message/Copy may be\r          used as a message body.\n\n\n          Goland, et al                                                  17\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          MessageCopy = Source_URI Type\r          Type = \"Overwrite\" | \"No Overwrite\"\n          If the No Overwrite value is specified then that the copy should\r          not occur if the destination URI already exists. If a resource is\r          not copied because a \"No Overwrite\" flag was used then a 416\r          Destination Exists.\n          7.2 Definition of Move Method\n          A move is logically a copy followed by a delete of the source\r          resource.  A move MUST be atomic. The MOVE method's syntax is\r          identical to the COPY method except the content-type is called\r          Message/Move.  In this case atomicity requires that before the\r          resources are made available at the new location they must no\r          longer be available at the old location. The rest of the\r          atomicity requirements are the same as for copy.\n          7.3 Definition of Destroy Method\n          To destroy a resource is permanently remove a resource from\r          storage. To delete a resource is to request that the resource no\r          longer be made available for editing. Destory differs from delete\r          in that a versioning system may allow a deleted resource to be\r          visible, but not editable, while a destroy causes the resource,\r          and all knowledge about the resource to be removed from the\r          server.  A destroy is performed by the DESTROY method. The\r          request-URI of the DESTROY method is the resource to be\r          destroyed.\n          7.3 Definition of Undelete Method\n          An undelete undoes the action of a delete, making a deleted\r          resource available for editing.  An undelete is performed by\r          executing the UNDELETE method.  The request-URI is the resource\r          to be undeleted. \n\n          8. URI Collections\n          8.1 Introduction\n          A collection is a resource used to contain other resources.\r          Resources are added to a collection using the POST method and are\r          removed from a collection using the RemoveResource method. A\r          collection is created by performing a PUT method with a\r          content-type of message/collection.\n\n          Goland, et al                                                  18\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          8.2 Definition of Content Type Message/Collection\n          MessageCollection = \"FSC\" | text\n          The contents of message/collection identifies what sort of\r          collection is being created. This document defines the collection\r          type \"FSC\" which standards for File System Collection.\n          8.3 Definition of Content Type Message/AddResource\n          To add a resource to a collection a POST on the resource should\r          have the content-type Message/AddResource.\n          AddResource = (\"Propagate\" | \"Symbolic\") URI\n          A resource may be added to a collection in one of two states,\r          Propagate or Symbolic. If added with Propagate then any name\r          space manipulation methods executed on the collection will also\r          be executed on the member resource. If added with Symbolic then\r          methods executed on the collection will not be executed on the\r          resource.\n          8.4 Definition of Content Type Message/RemoveResource\n          The RemoveResource method's request-URI is the URI of the\r          collection. The content-type Message/RemoveResource may be used\r          with the RemoveResource method.\n          RemovedResource = URI\n          8.5 Results of Methods on Collections of Type \"FSC\"\n          A GET will return a listing of the contents of the collection.\r          The WebCollection [WebC] content-type SHOULD be used as the\r          default return type.\n          A PUT MUST result in 405 Method Not Allowed.\n          A DELETE or UNDELETE will be directly executed on the collection\r          and all propagate members.\n          A COPY/MOVE will be propagated to all propagate members. A POST\r          will be performed on the COPY/MOVE destination for all the\r          symbolic members. If a propagate member is a child of the\r          collection's name space then the destination of the COPY/MOVE\r          will be extended for that member. So if the collection is at\r          http://foo/bar, the destination is http://place and a propagate\n\n          Goland, et al                                                  19\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          member is http://foo/bar/thunk then the destination for the\r          member will be http://place/thunk. If the propagate member is not\r          a child of the collection's name space then the member's name\r          should be appended to the collection's destination. So using the\r          previous example if the propagate member's URL is\r          http://blah/blah then its destination will be\r          http://place/blah/blah.\n\n          9. Notification\n          9.1 Notify Request\n          The Notify Request request-header is used to request that the\r          server send a stream of \"102 Process\" messages containing updates\r          of the request's status. \n          Notify_Request = \"NotifyRequest\" \":\" CRLF\n          9.2 Resource Event Notification \n          As features such as WebCheck and URLMinder demonstrate, there is\r          a strong interest in receiving notification when a resource\r          changes. What is lacking is a standard means to register interest\r          in receiving notification regarding a resource. \r          To solve this problem the Notification link type is introduced.\n          Type = \"Notification\" [On_Event]\r          On_Event = #token\n          The request-URI MUST be the destination. The source in the\r          Message/Link will be the resource to notify when the specified\r          event occurs. If no event is specified then the source will be\r          notified at the destination's discretion.\r          [TBD - Define On_Event for all known methods as well as their\r          responses.]\n\n          10. Version Features\n          [NOTES:\r          IF YOU GET A VARIANT AND THEN VERSION IT YOU ARE NOT GUARANTEED\r          TO GET THE SAME RESULT IF YOU VERSION A RESOURCE AND THEN GET A\r          VARIANT. IT IS UP TO THE SERVER TO KEEP TRACK OF THESE THINGS.\r          WE NEED TO MAKE SURE THAT VERSIONING DEGRADES NICELY. SO IF A\r          CLIENT OR SERVER DOESN'T SUPPORT SOMETHIN WE CAN STILL GET SOME\r          THINGS DONE.\n\n          Goland, et al                                                  20\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          WE NEED A SERVER VERSION DISCOVERY MECHANISM. SOME WAY TO FIGURE\r          OUT WHAT THE SERVER SUPPORTS. ]\n          10.1 Definition of Edit Announcement Link Type\n          A set edit announcement is a means to notify other principals of\r          an intent to edit the specified resource. This method should only\r          cause the link to come into existence. No other actions is\r          intended or implied.\n          Type = \"Edit Announcement\" (\"Exclusive\" | \"Shared\")\n          The \"Exclusive\" and \"Shared\" keywords indicate if a Set Edit\r          Announcement is exclusive or shared on the specified resource. If\r          exclusive then only a single Set Edit Announcement will be\r          accepted on the resource.\n          The request-URI of the LINK method is the resource the Set Edit\r          Announcement is placed on, the destination. The Source is the URL\r          of the principal to identify as having placed the announcement.\r          UNLINK is used to remove an edit announcement.\n          10.2 Definition of the Merge Method\n          The Merge method provides the result of a merge. It specifies\r          what resources have been merged and then provides either the\r          merge result or a URI that provides the merge result.\r          The request-URI is the resource that wants the merge result.\n          Application/Merge = Sources entity-body \r          Sources = 1#(\"URI\" \":\" URI | \"Entity\" \":\" <\"> encoded-entity-body\r          <\">)\r          encoded-entity-body = <Any OCTET but <\"> which must be encoded.>\n          10.3 Definition of the DIFF Method\n          The request-URI of the DIFF method is the resource against which\r          specified resources will be compared. The actual meaning of a\r          DIFF depends upon the return type.\n          [TBD - Throw in VTML as a return type.]\n          Application/Diff = Sources \n          10.4 Definition of the Rollback Method\n          The RollBack method causes the last method executed on a resource\n\n          Goland, et al                                                  21\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          to be undone.\n          [TBD - Define the error messages.]\n          10.5 Command Comments \n          Command comments are entity headers. \n          Command_Comment = \"Comment\" \":\" CommentVal\r          CommentVal = URI | comment \n          This is the standard comment facility used by versioning systems.\r          Servers that do not understand the header or do not wish to make\r          use of the information are free to ignore the information. No\r          specification is made regarding how this information is to be\r          retrieved. It is likely, however, that most systems will make the\r          command comments available through their history attribute. \n          10.6 History \n          History is an attribute header that returns a WebMap containing\r          the history of the document. \n          Type = \"History\"\n          [TBD - Define the object tags for a standard history.]\n          10.7 Definition of the Version Link\n          Version links indicate versioning relationships.\n          Type = \"Version\" [Version]\r          Version = Token\n          The version token refers to the version of the destination.\r          If the destination equals the source then the type gives the\r          version of the current resource.\r          If the Version is left out of a request then the requestor asks\r          that the server assign a version.\r           \r          If a Version link's destination is not included then the link is\r          a request to create a new version of the source. A successful\r          response should include the version of the new resource along\r          with a destination value pointing to the new resource. The new\r          resource will not be frozen until a PUT is performed on it.\r          However, if the new version is locked then it will not be frozen\r          until the locks are removed.  Thus, a Version Link without a\n\n          Goland, et al                                                  22\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          version token and a destination is a request to create a new\r          version with a server defined version token.\n          A newly created version, which has yet to have a PUT performed on\r          it, can not be frozen. An unfrozen resource, which is\r          write-locked, may not be frozen until all write-locks are\r          removed.\n          10.8 Version Management Issues\n          The following examples demonstrate how to create new versions\r          under various circumstances and how to control when those new\r          versions become frozen.\n          10.8.1 Creating the First Version of a Resource\n          If a server only accepts versioned resources then a new resource\r          will automatically be versioned when it is PUT. The version\r          number will be recorded in a looped version link. In order to\r          prevent freezing, the URL should be write locked before the first\r          PUT is performed.\n          If the system does not automatically version resources then once\r          a resource has been PUT a self-looping Version Link must be\r          placed upon it to create a new version.\n          10.8.2 Adding a New Version of a Resource\n          Assume the existence of a versioned resource A. To create a child\r          of A, called B, one can create a Version Link with an unspecified\r          destination. If the method is successful, the server will return\r          a destination and a version token in the result.\n          Another mechanism to create B is to PUT B to some URL and then\r          attach a version link between the B and A. However servers are\r          not required to support this functionality.\n          10.8.3 Version Conflicts\n          If a version has not been frozen then multiple principals may\r          make alternations to it. The simplest model is a free for all\r          when changes may overwrite each other.  However most systems\r          prefer a more complicated model which depends upon Merges.\r           \r          A principal may perform a GET followed by a MERGE. The MERGE body\r          should include the content-location from the GET response, as a\r          merge source. The server may respond with a 409 Conflict if the\n\n          Goland, et al                                                  23\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          resource has altered since the MERGE was performed. If so, the\r          process repeats again.\n          Another means to update an unfrozen version is to just PUT the\r          new data. If a conflict occurs then a 409 Conflict will be\r          returned which should be followed up by a MERGE.\n          10.8.4 Multiple Children\n          Anytime a Version LINK is executed on a resource without a\r          destination a new version of the resource will be created. This\r          may have unintended consequences. If principals X and Y both wish\r          to create a new version of A and both place Version LINKs without\r          destinations on A, two separate new versions will be created. The\r          version tree will branch. To prevent this unintended branching it\r          is important to check for preexisting Version links. However this\r          branch prevention mechanism can still cause problems because it\r          is not atomic.\n          There are two possible answers to this problem. Some systems do\r          not allow for non-linear trees. As soon as a new version \"B\" is\r          created from a base version \"A\" any further attempts to create\r          new versions from \"A\" will point to \"B\". Other systems do allow\r          branches. The only way for these systems to ensure that all\r          principals will find out about \"B\" is to write-lock \"A\" and then\r          create \"B\". Once confirmation has been received that \"B\" is\r          created the write-lock can be released on \"A\".\n          [TBD - The last part now specifies that write-locks will lock the\r          ability to add links. This makes sense as links belong to the\r          resource. The destination of a link doesn't belong to the\r          resource but the link information itself, the\r          source/destination/type triple does.]\n          10.8.6 Versions vs. Variants\n          It is up to the server to maintain consistency amongst version\r          numbers. However this does not require the server to guarantee\r          that if a client requests a variant of a resource followed by a\r          specific version that the client will get the same result\r          performing the operations in the reverse order.\n          10.9 Server Versioning Negotiation\n          version LINK/lock - to create a new \n\n\n\n          Goland, et al                                                  24\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          11. Access Control [Note: preliminary and incomplete]\n          When I speak of access control I mean the ability to associate a\r          set of allowable actions to be performed on a resource by a\r          representation as defined under a specified security protocol.\r          Actions are HTTP methods with specified associated tags.\r          Resources are a URI or a URI which references a group of URIs.\r          Entities are defined by the particular security protocol being\r          referenced. The versioning standard should include how to specify\r          actions and resources but should only define an extension\r          mechanism for defining entities. It would be prudent to include\r          in an appendix a syntax for the definition of entities under\r          commonly used HTTP authentication methods such as the\r          Authentication tag.\n          Note that a server is not required to accept access control\r          suggestions. Each server has its own rules for how actions,\r          resources and entities should be divided and is free to enforce\r          those views. However error message should be used to inform the\r          principal of the server's policies.\r           \r          In addition means must be provided to discover what actions,\r          resources, and entities are available. However this information\r          should also be under access control. It would seem logical to\r          provide support in HTML for specifying access control features so\r          that a server could provide principals who wish to set access\r          controls with an HTML page whose formatting will help the\r          principal assign access controls in a matter consistent with the\r          server's policies.\r           \r          As access controls are the primary means for deciding how to\r          share information it is critical that we define a standard or\r          each versioning and distributed authoring package will define its\r          own. This would not be such a bad fate if only one or two people\r          on a site needed to assign access privileges. However everyone\r          who owns a resource needs to set the access privileges for that\r          resource and if resources are to be shared across systems then\r          principals who use different versioning and distributed authoring\r          packages need to be able to control access to resources on other\r          systems. This interoperable world is only feasible if methods to\r          define access controls are standardized.\r           \r          We should probably do access control through a method and header\r          specification associated with security tokens which can either be\r          groups or principals. We may want to push the URI kludge even\r          further and identify principals via URIs. \n\n\n          Goland, et al                                                  25\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          [Required Features - RAW\n          Introduce the concept of Distributed Authoring compliance,\r          Versioning compliance, and totally optional features. Use the\r          list from the presentation.]\n\n          12. Acknowledgements\n          Roy Fielding, Richard Taylor, Larry Masinter, Henry Sanders,\r          Judith Slein, Dan Connolly, David Durand, Henrik Nielsen, Paul\r          Leach. Others, TBD. \n\n          13. References\n          [HTTP11] R. T. Fielding, J. Gettys, J. C. Mogul, H. F. Nielsen,\r          and T. Berners-Lee. \"Hypertext Transfer Protocol -- HTTP/1.1\"\r          Internet-Draft draft-ietf-http-v11-spec-07.txt, expires February\r          12, 1997. \r          [ORANGE] DoD 5200.28-STD, \"Department of Defense Trusted Computer\r          System Evaluation Criteria\", December, 1985. \r          [RFC1521] N. Borenstein, N. Freed. \"MIME (Multipurpose Internet\r          Mail Extensions) Part One: Mechanisms for Specifying and\r          Describing the Format of Internet Message Bodies.\" RFC 1521,\r          Bellcore, Innsoft, September, 1993. \r          [URL] T. Berners-Lee, L. Masinter, M. McCahill. \"Uniform Resource\r          Locators (URL).\" RFC 1738, CERN, Xerox PARC, University of\r          Minnesota, December, 1994. \r          [RFC1959]\r          [RFC1960]\r          [WEBC] - References to web collections.\r          [VTML]\n\n          14. Authors' Addresses\n          Yaron Goland\r          Microsoft Corporation\r          One Microsoft Way\r          Bldg. 27N/3445\r          Redmond, WA 98052-6399\r          Fax: 206 936 7329\r          Email: yarong@microsoft.com\n          Jim Whitehead\r          Dept. Of Information and Computer Science\n\n          Goland, et al                                                  26\r\f\n\n\n\n\n\n          INTERNET-DRAFT               WEBDAV             November 26, 1996\n          University of California, Irvine\r          Irvine, CA 92697-3425\r          Email: ejw@ics.uci.edu\n          Asad Faizi\r          Netscape\r          Email: asad@netscape.com\n          Del Jensen\r          Novell\r          1555 N. Technology Way\r          M/S ORM-F111\r          Orem, UT 84097-2399\r          Fax: 801 228 5176\r          Email: dcjensen@novell.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Goland, et al                                                  27\r\f\r", "encoding": "ascii"}