{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/17.unionfind", "content": "Union find problem:\n\tmaintain partition of some elements into sets\n\teach set has \"id\" by which it can be identified\n\toperations:\n\t    - add new element in its own set\n\t    - find id of set containing given element: find(x)\n\t\t- test if two elements are in same set (find(x)==find(y))\n\t\t- test if element belongs to set (find(x)==setid)\n\t    - merge two sets: union(x,y)\n\nApplications:\n    - Prim's minimum spanning tree algorithm\n\n\tfor each edge (u,v) in G, in sorted order by weight\n\t\tif u and v are in different components\n\t\t\tadd (u,v) to T and merge their components\n\n\tpartition into sets = connected components of partial tree\n\ttest if in different components = find\n\tadd and merge = union\n\n\tnote in general more finds than unions\n\n    - \"Blossom contraction\" method for finding maximum matchings\n\tin arbitrary graphs (see e.g. web site for Python impl)\n\n    - Image segmentation (scan image in preferred pixel or quadtree\n\torder, find connected components, instead of DFS or BFS\n\torders with messier memory access patterns)\n\n    - Offline LCA:\n\tgiven T, set of LCA queries, answer all queries\n\t    depth first traversal of tree\n\t    at each step, maintain set of off-path descs of each path node\n\t    handle query lca(u,v) when visiting second of two vertices\n\nAnalysis parameters\n\tn elements per set\n\tso < n unions\n\n\tm finds (possibly m >> n)\n\n\nSolution 1: fast queries\n    each node stores id of the set containing it\n    union: change stored ids in one of two sets\n\n    so also need list of objects in each set\n\n    find = O(1) time\n    how to make unions efficient?\n\tunion by size:\n\t    change ids in the smaller of the two sets\n\t    node id changes => node becomes member of set >=2*size\n\t\tso <= log_2 n changes per node\n\n    amortized time: O(m + n log n)\n\n\nSolution 2: fast finds\n    store each set in the partition as a rooted tree\n\tid of set = tree root (one of the elements in the set)\n\n    find(x): trace path from x to its root\n    union(x,y): add tree edge from find(x) to find(y)\n\n    so we want the tree to be short\n    union by size again: add edge from find(x)->find(y) or vice versa,\n\tsmaller subtree root to larger subtree root\n    then, each step up tree doubles size of subtree\n\t=> path lengths <= log_2 n\n\n    amortized time: O(m log n)\n\nFurther improvement: path compression\n\n    union changes sets\n    find is just a query\n\n    but what if (like splay) we allow finds to change the trees?\n\n    when we find a long path from node to root,\n\tdon't want to repeat all that work again\n\t\t=> change all parent pointers along path to point to root\n\nPath compression analysis\n\n    define rank(x) = log_2 # descs(x)\n\tin tree formed by performing all unions but no path compressions\n\tso at most n/2^r nodes have rank r\n\n    time for m unions on n items can be split into three parts:\n\tfind steps from one high rank element to another (HH)\n\tfind steps from one low rank element to another (LL)\n\tfind steps from low to high rank and union steps (LH+X)\n\n    also note that each element has at most one find that includes\n    both LL and HH steps (after that all LL ancestor edges are compressed out)\n\n    Let\n\tm_0 = # finds that have HH steps\n        n_i = # elements in i'th group of low-rank items\n\tm_i = # finds in i'th group of low-rank items that have no HH steps\n\t\t(i > 0)\n    so sum m_i = m, sum n_i = n, n_i < 2^r\n\n    Then\n\t#(LH+X) = O(m+n)\t(obvious, one per update or query)\n\t#(HH) = T(m_0,n/2^r)\n\t#(LL in group i) = T(m_i + n_i, n_i)  (m_i + one LLHH find per item)\n\n    It will turn out that smaller groups of low-rank items only make\n    the algorithm run faster, so in the worst case we can assume n_i = 2^r\n\n    Putting this together into a recurrence describing the total time:\n\tT(m,n) = O(m + n) + T(m_0, n/2^r) + sum T(m_i + 2^r, 2^r)\n\n    example of playing with this recurrence:\n\n\tstart from\n\tT(m,n) = O(m + n log n) (total # compresses per item <= depth)\n\n\t    substitute in recurrence, using r = log log n\n\t    second term becomes linear\n\t    =>  T(m,n) = O(m + n) + sum T(m_i,log n) = O(m log^* n)\n\n        log^*(n) = min_i i{2^(2^(2^...)) >= n\n\n        very slowly growing\n\n    actual solution to the recurrence:\n\tT(m,n) = O(m alpha(m,n))\n    where\n\tA(1,j) = 2j\n\tA(j,1) = 2\n\tA(i,j) = A(i-1,A(i,j-1)) for i,j>1\n\n\t2   4   6   8  10  12  14  16\n\t2   4   8  16  32  64 128 256\n\t2   4  16 2^16...\n\n\talpha(m,n) = min { i >= 1 | A(i,floor(m/n)) >= m }\n\n\tincredibly slowly growing...\n\nSo union find takes very close to constant time per operation\n    but not constant!\n    can find sequences of operations causing it to take\n    Omega(m alpha(m,n)) time\n\n    more, Omega(m alpha(m,n)) is lower bound in natural models of computation\n", "encoding": "ascii"}