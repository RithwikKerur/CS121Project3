{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/arrays1d/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>1-d Arrays, The <b>Object</b> class, and Simple Collections</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>1-d Arrays, The <b>Object</b> class, and Simple Collections</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture, we will discuss a powerful aggregate data structure: arrays.\r\n  Arrays allow us to store collections of arbitrary-sized sequences of values\r\n    (both primitive types and references to objects), and easily access and\r\n    manipulate all these values.\r\n  We will learn how to declare arrays, picture them, and perform operations\r\n    on arrays (mostly by looping, and performing operations on the individual\r\n    values in the arrays).\r\n  We will examine how arrays can be used as instance variables in classes.\r\n  <p>\r\n  Once we have learned the basic array material, we will discuss wrapper\r\n    classes and the <b>Object</b> class.\r\n  Putting all this information together, we will learn how to represent two\r\n    simple, general, and powerful collection classes (stack and queue) with\r\n    expandable arrays stored as instance variables.\r\n  We will follow-up on this material later in the semester, with a systematic\r\n    study of even more powerful Java collection classes.\r\n  <p>\r\n  Arrays are very similar to objects from a special class, and we will\r\n    exploit this similarity throughout our discussion of arrays.\r\n  There is also a strong connection between arrays (which are indexed by a\r\n    sequence of integers) and <b>for</b> loops (which easily generate a\r\n    sequence of such integers).\r\n  Finally, there is also a connection between files and arrays: often the\r\n    information stored in a file (easily processed sequentially) is read and\r\n    stored into an array (where it can be easily and efficiently processed -and\r\n    reprocessed- either sequentially or randomly).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Declaring Arrays -->\r\n\r\n<a name=\"DeclaringArrays\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Declaring<br>(and initializing)<br>Arrays</b></td>\r\n<td width =\"80%\">\r\n  We declare and initialize array variables like other class variables, but by\r\n    specifying the type and constructor in a special form: for 1-dimensional\r\n    (1-d) arrays, the type is specified as any Java type (primitive or\r\n    reference) followed by <b>[]</b>; the constructor uses that same type,\r\n    with an <b>int</b> value (computed by a literal or more general expression)\r\n    inside the brackets.\r\n  The value computed from this expression specifies the length of the array:\r\n    how many values it contains.\r\n  Once we construct an array object, its length may not change: there is\r\n    no mutator for that operation.\r\n  So, for example, we can declare and initialize an array variable storing a\r\n    reference to an object containing 5 <b>int</b>s by the declaration\r\n  <pre><b>  int[] a = new int[5];</b></pre>\r\n  This variable, and the object it refers to, are illustrated in the following\r\n    picture.\r\n  <p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/intarray.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Pronounce <b>[]</b> as \"array\"; so <b>int[]</b> is pronounces as \"int array\".\r\n  Array objects are labelled by their array type; they contain two major parts:\r\n    a sequence of indexed boxes and a special box named <b>length</b>.\r\n  Notice four important facts about arrays illustrated by this picture.\r\n  <ul>\r\n    <li>\r\n      An array is a <b>homogeneous</b> data structure: each of its indexed\r\n        members is labelled by (and stores) the same type (here <b>int</b>).\r\n      Constrast this with the other classes that we have discussed, which are\r\n        <b>heterogeneous</b>: each of their instance variables can store a\r\n        different type.\r\n      We can declare arrays to store sequences of either primitive or reference\r\n        types.\r\n      Because this is an <b>int[]</b>, each box in the sequence stores an\r\n        <b>int</b> value, and is so labelled.\r\n      Each box in the sequence is also labelled by its index (<b>0</b>,\r\n        <b>1</b>, <b>2</b>, etc.) which is always an <b>int</b> no matter what\r\n        type is stored inside each box.\r\n    <p>\r\n    <li>\r\n      The indexes are numbered from <b>0</b> to one less than the length of the\r\n        array (here the maximum index is <b>4</b>, which is one less than the\r\n        length of the array, which is <b>5</b>).\r\n      This decision, while elegant from a mathematical perspective, is a\r\n        disaster from a psychological perspective: most humans start counting\r\n        at <b>1</b>, not <b>0</b>, and most of us expect the length of the\r\n        array to be the same as the index of the last box in the array.\r\n      But C, C++, and Java all start the indexes of their arrays at <b>0</b>,\r\n        so, we must overcome human nature when we use arrays in programming.\r\n    <p>\r\n    <li>\r\n      Each array object defines a <b>public final int length</b> instance\r\n        variable that stores the length of the array.\r\n      Its value is specified when the array object is constructed, and is\r\n        unchangeable after that: because <b>length</b> has the <b>final</b>\r\n        access modifier, we CANNOT attempt to change its value.\r\n      But, we can directly access (i.e., not through an accessor) the value\r\n        stored in this field.\r\n      In this example, we could write <b>a.length</b> in our code: it is an\r\n        expression that evaluates to <b>5</b>.\r\n      In fact, we can always specify the highest legal index in the array\r\n        object by the expression <b>a.length-1</b>.\r\n      So given a reference to an array, we can always determine its length,\r\n        and from it the highest index.\r\n    <p>\r\n    <li>\r\n       Like all instance variables, ALL INDEXED MEMBERS ARE AUTOMATICALLY\r\n         INITIALIZED when the array object is constructed.\r\n       Java initializes them as it initializes all instance variables: for the\r\n         primitive types, it uses <b>0</b> for <b>int</b>, <b>0.</b> for\r\n         <b>double</b>, <b>false</b> for <b>boolean</b>, and the null character\r\n         for <b>char</b>; for all reference types it uses <b>null</b>\r\n         (meaning that they do not refer to any object).\r\n       Here all the indexed members are initialized to <b>0</b>.\r\n  </ul>\r\n  <p>\r\n  We must use only non-negative lengths when we construct arrays objects\r\n    (a length of <b>0</b> is allowed, and does have some interesting uses).\r\n  If we specify a negative value, the special constructor for arrays throws the\r\n     <b>NegativeArraysSizeException</b>.\r\n  <p>\r\n  We can also construct an array by declaring all the values that it must\r\n    contain; in such a case, the length of the array is automatically inferred\r\n    from the number of values.\r\n  So, for example, we can declare and initialize an array variable storing a\r\n    reference to an object containing the five <b>int</b> values 4, 2, 0, 1,\r\n    and 3 (in that order) by the declaration\r\n  <pre><b>  int[] a = new int[]{4, 2, 0, 1, 3};</b></pre>\r\n  If you think about <b>int[]</b> as the class name and <b>{4,2,0,1,3}</b> as\r\n    the parameters to the constructor for an object from that class, this\r\n    syntax is reasonable.\r\n  Of course, we cannot take this similarity too far, because constructors\r\n    always have a set number of parameters, while any number of arguments\r\n    are allowed between these braces.\r\n  The types of all the values in the braces must be compatible with the\r\n    type of the array used in the constructor.\r\n  <p>\r\n  We illustrate the result of executing this declaration by the following\r\n    picture.\r\n  <p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/intarray2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Accessing Arrays-->\r\n\r\n<a name=\"AccessingArrays\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Accessing Arrays by their Indexed Members</b></td>\r\n<td width =\"80%\">\r\n  We can access any individual member stored in an array object by using\r\n  <ul>\r\n    <li>the variable that refers to the array object,\r\n    <li>and the index of the member that we want to access\r\n         (written as an expression inside brackets).\r\n  </ul>\r\n  So, if we declare <b>int[] a = new int[]{4, 2, 0, 1, 3};</b> then we  can\r\n    write <b>System.out.println( a[0] );</b> Java would print the value stored\r\n    in index <b>0</b> in array <b>a</b>, which is <b>4</b>.\r\n  We pronounce <b>a[0]</b> as \"a at index 0\" or just \"a sub 0\" (similar to the\r\n    subscript in mathematical notation: think of the sequence \r\n    <b>a<sub>0</sub></b>, <b>a<sub>1</sub></b>, <b>a<sub>2</sub></b>, etc.)\r\n  Likewise, we can write\r\n  <pre><b>  if (a[2] == 0)\r\n    ...some statement</b></pre>\r\n  which checks to see whether or not zero was stored in the array object\r\n    referred to by  <b>a</b>, at index <b>2</b>. \r\n <p>\r\n  Note that <b>a</b> is of type <b>int[]</b> (pronounced <i>int array</i>);\r\n    any access to a member stored in an index of <b>a</b> is of type\r\n    <b>int</b>.\r\n  Generally, if <b>a</b> is of type <b>T[]</b> (pronounced <i>t array</i>),\r\n    then any access to a member stored in an index of <b>a</b> is of type\r\n    <b>T</b>.\r\n  <p>\r\n  The golden rule of arrays says, <i>\"Do unto any array member as you would do\r\n    unto a variable of the same type\"</i>.\r\n  So wherever we can use an <b>int</b> variable, we can use an <b>int[]</b>\r\n    member.\r\n  Thus, we can write <b>a[2] = 8;</b>, using <b>a[2]</b> on the left side of\r\n    the <b>=</b> state-change operator (changing the value stored in index\r\n    <b>2</b> from <b>0</b> to <b>8</b>).\r\n  We can even write <b>a[2]++;</b>, which increments the value stored in index\r\n    <b>2</b> of the array.\r\n  So, when you ask yourself the question, \"Can I use access an array member and\r\n    use it here?\", the question simplifies to, \"Can I use a variable (of the \r\n    same type) here?\"\r\n  <p>\r\n  In fact, the value written inside the brackets can be any expression that\r\n    evaluates to an <b>int</b>; we will see how variables and more complicated\r\n    expressions are used for  indexing arrays later in this lecture.\r\n  For now, note that writing <b>a[a.length-1] = 0;</b> stores <b>0</b> in the\r\n    last index of the array object. \r\n  <p>\r\n  Note that when accessing a member in an array, if the value computed for the\r\n    index is less than 0, or greater than OR EQUAL TO the length of the array,\r\n    then trying to access the member at that index causes Java to throw the\r\n    <b>ArrayIndexOutOfBoundsException</b> which contains a message showing what\r\n    index was attempted to be accessed.\r\n  So, writing <b>a[a.length] = 0;</b> throws this exception, since the index\r\n    <b>5</b> is not in the array object.\r\n  <p>\r\n  Finally, here is a picture that shows how to declare a variable refering to\r\n    an array object, but this time the array object stores a <b>String</b> in\r\n    each index.\r\n  After this declaration are three expression statements that intialize these\r\n    indexes with new <b>String</b> objects.\r\n<p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/stringarray.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Although indexes are always integers, the values stored at each index \r\n    depends on the type used to declare/construct the array.\r\n  In this example, each index stores a reference to a <b>String</b> object.\r\n  Finally, using what we learned above, we could have declared and intialized\r\n    this variable and its array object in just one declaration: by either\r\n</tbody>\r\n</table>\r\n  <pre><b>String[] s = new String[]{new String(\"ABC\"), new String(\"LMN\"), new String(\"XYZ\")};</b></pre>\r\n  <pre><b>String[] s = new String[]{\"ABC\", \"LMN\", \"XYZ\"};</b></pre>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The second, more simple, declaration is correct because of the special\r\n   property of <b>String</b> literals that they construct their own objects.\r\n  <p>\r\n  Note that because of the golden rule, we can use <b>s[0]</b> just like any\r\n    variable of type <b>String</b>; therefore, we can write the expression\r\n    <b>s[0].length()</b> which returns 3 (the length of the <b>String</b>\r\n    object referred to in index <b>0</b> in the <b>String</b> array <b>s</b>).\r\n  So generally, when arrays store references to objects in their indexed\r\n    members, we can call an appropriate method (based on the type of the\r\n    reference) on any member in the array.\r\n  Here we can call any <b>String</b> method on any object stored in this array.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Processing Arrays -->\r\n\r\n<a name=\"ProcessingArrays\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Processing Arrays</b></td>\r\n<td width =\"80%\">\r\n  Most code that processes an array does so by iterating through it: looking at\r\n    the value stored in each indexed member in the array object.\r\n  Typically, a <b>for</b> loop is used to generate all the indexes for the\r\n    array object.\r\n  Study the following code carefully; although short, it contains all the\r\n    fundamentals that you need to understand for writing array processing code.\r\n  This code computes the sum of all the values in an <b>int[]</b>.\r\n  <pre><b>  int sum = 0;\r\n  for (int i=0; i&lt;a.length; i++)\r\n    sum += a[i];\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n  Below is a (non-compact) trace table that illustrates the hand simlation of\r\n    this code.\r\n  Notice how the same statement <b>sum += a[i];</b> is repeatedly executed,\r\n    but it has a slightly different meaning every time, because the value\r\n    stored in <b>i</b> changes, so the indexed member being added to <b>sum</b>\r\n    is always different.\r\n  <p>\r\n  <img src=\"images/sumtrace.gif\"></image>\r\n  <p>\r\n  Notice the <b>for</b>'s continuation test: <b>i&lt;a.length</b>.\r\n  When the length is <b>5</b> (as in this example), the final <b>i</b> for\r\n    which the body is executed is <b>4</b>(the highest index in the array);\r\n    when <b>i</b> increments to <b>5</b>, the test is <b>false</b> for the\r\n    first time, so the body is not executed, and instead the loop is\r\n    terminated.\r\n  We can write this test as <b>i&lt;=a.length-1</b>, which has the same meaning,\r\n    but few \"real\" programmers write the test this way.\r\n  <p>\r\n  The following code prints on one line, separated by spaces, all the values\r\n    stored in an array.\r\n  After all the values are printed (and the loop terminates), it ends the line.\r\n  Notice that the same <b>for</b> loop code is used (this time to examine and\r\n    print, not add together) every member stored in the array object; only the\r\n    body of the loop (telling Java what to do with each indexed member) is\r\n    different.\r\n  <pre><b>  for (int i=0; i&lt;a.length; i++)\r\n    System.out.print(a[i]+\" \");\r\n  System.out.println();</b></pre>\r\n  <p>\r\n  Below, a more interesting version of this loop prints a comma-separated list\r\n     of values stored in the array: the last one is not followed by a comma,\r\n     but by a new line.\r\n  The <b>String</b> to catenate is decided by a conditional expression.\r\n  <pre><b>  for (int i=0; i&lt;a.length; i++)\r\n    System.out.print( a[i]+(i&lt;a.length-1?\",\":\"\\n\") );</b></pre>\r\n  <p>\r\n  The following code prompts the user to fill in each value in an array.\r\n  Notice that the same <b>for</b> loop code is used (this time to store into\r\n    every indexed member in the array object); again, only the body of the\r\n    loop is different.\r\n  <pre><b>  for (int i=0; i&lt;a.length; i++)\r\n    a[i] = Prompt.forInt(\"Enter value for a[\"+i+\"]\");</b></pre>\r\n  <p>\r\n  The following code computes and prints the maximum value stored in an array.\r\n  Because the original maximum value comes from index <b>0</b> in the array\r\n    (the first value stored in the array), the <b>for</b> loop starts at index\r\n    <b>1</b> (the second value stored in the array).\r\n  <pre><b>  int max = a[0];\r\n  for (int i=1; i&lt;a.length; i++)\r\n    if (a[i]>max)\r\n      max = a[i];\r\n  System.out.println(\"Max = \" + max);</b></pre>\r\n  We also could have also written this code as follows, initializing\r\n    <b>max</b> to <b>Integer.MIN_VALUE</b> and starting the <b>for</b> loop at\r\n    index <b>0</b>, guaranteeing <b>a[0]</b>'s value will be stored into\r\n    <b>max</b> during the first loop iteration.\r\n  <pre><b>  int max = Integer.MIN_VALUE;\r\n  for (int i=0; i&lt;a.length; i++)\r\n    if (a[i]>max)\r\n      max = a[i];\r\n  System.out.println(\"Max = \" + max);</b></pre>\r\n  <p>\r\n  Examine the Javadoc for the <b>Integer</b> class to learn about this\r\n    <b>public static final int</b> value.\r\n  Then, hand simulate this second loop to understand why/how it works.\r\n  In fact, we could replace the <b>if</b> statement by either\r\n    <b>max = Math.max(max,a[i]);</b> or \r\n    <b>max = (a[i]>max ? a[i] : max);</b> and compute the same result,\r\n    although I prefer the <b>if</b> statement.\r\n  <p>\r\n  Finally, the following code loads all the information from a file into an\r\n    array.\r\n  We often perform this operation early in a proagram, and then process the\r\n    information in the array one or more times, beause it is easier to\r\n    manipulate the information in an array than a file.\r\n  To work, the file must first store the length of the array needed; it is read\r\n    first and used to construct an array object exactly the right size to\r\n    store all the remaining values.\r\n  Then, we must read the remaining values from the file individually, and\r\n    store them into the array.\r\n  <pre><b>  TypedBufferReader tbr = \r\n    new TypedBufferReader(\"Enter file to load in array\");\r\n  String[] s = new String[tbr.readInt()];\r\n  for (int i=0; i&lt;a.length; i++)\r\n    a[i] = tbr.readString();\r\n  tbr.close();</b></pre>\r\n  Note that we have omitted a <b>try</b>/<b>catch</b> block for catching\r\n    exceptions: we are assuming that the file contains all correct data, and\r\n    we never try to read past the last data value in the file.\r\n  Of course, writing this code in a block allows us to decide how to handle\r\n     exceptions (wrong type of data, not enough data, etc).\r\n  <p>\r\n  The <a href=\"../../programs/arraydemo.zip\">Array Demonstration</a>\r\n    application contains all the code described in this section (and more).\r\n  Please download, unzip, run, and examine this code (it is discussed again\r\n    in the secion illustrating how arrays appear in the Eclipse debugger).\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Strings as Arrays -->\r\n\r\n<a name=\"StringsAsArrays\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Strings As Arrays</b></td>\r\n<td width =\"80%\">\r\n  A brief observation.\r\n  The <b>String</b> reference type also has \"array-like\" properties:\r\n    a <b>String</b> is a sequence of characters and you can access the\r\n    individual <b>char</b>s in a <b>String</b>.\r\n  There are a few relevant differences to know (also check out this material\r\n    in Sun's Javadoc for the <b>String</b> class).\r\n  Assume that we declare <b>String s = \"ABC\";</b>\r\n  <ul>\r\n    <li>Unlike arrays, <b>String</b>s employ a <b>public int length</b> method\r\n          (not a <b>public</b> instance variable) for accessing the length of\r\n          the <b>String</b>.\r\n        Thus we must write something like <b>s.length()</b> (which returns\r\n          <b>3</b>); this inconsistency is foolish.\r\n    <li>Unlike arrays, <b>String</b>s employ a <b>charAt</b> method (not\r\n          <b>[]</b>) for accessing the <b>char</b> at a specified index in the\r\n          <b>String</b> (e.g., <b>s.charAt(0)</b>, which is <b>'A'</b>.\r\n        Because this class is immutable, there is no way to change the\r\n          character stored at an index.\r\n    <li>Unlike arrays, when accessing an illegal index in a <b>String</b> (with\r\n           <b>charAt</b>), Java throws <b>StringIndexOutOfBoundsException</b>\r\n           (not <b>ArrayIndexOutOfBoundsException</b>).\r\n  </ul>\r\n  We often think about processing the members in a <b>String</b> using the same\r\n    techniques (a <b>for</b> loop) as when processing members in an array.\r\n  For example, here is a typical loop for processing all the characters a\r\n    <b>String</b>: it adds up the ASCII values of all the characters.\r\n    <pre><b>  String s = Prompt.forString(\"Enter Name\");\r\n  int asciiCharSum = 0;\r\n  for (int i=0; i&lt;s.length(); i++)\r\n     asciiCharSum += s.charAt(i);  //Implicit conversion char->int\r\n  System.out.println(s +\"'s ASCII sum = \" + asciiCharSum);</b></pre>\r\n  Hand simulate this code with the input <b>HOLYBIBLE</b> or <b>al gore</b>.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Array Methods -->\r\n\r\n<a name=\"ArrayMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Array Methods</b></td>\r\n<td width =\"80%\">\r\n  It is often convenient to move array processing operations into methods.\r\n  In this section, we will show how to write <b>public static</b> methods\r\n    that process arrays (we can put such methods in our application, or in\r\n    a library class); then we will exame non-<b>static</b> methods for\r\n    processing arrays that are stored as instance variables.\r\n  <p>\r\n  The first method finds and returns the lowest index that stores the\r\n    <b>String</b> value specified by the second parameter.\r\n  Note the form of the parameter variable for the array: it is the same as\r\n    declaring a local variable of the <b>String[]</b> type.\r\n  <pre><b>  public static int findLowestIndexOf(String[] a, String value) {\r\n    for (int i=0; i&lt;a.length; i++)\r\n      if (a[i].equals(value))\r\n        return i;\r\n\r\n    return -1;\r\n  }</b></pre>\r\n  Here the code immediately returns the value stored in <b>i</b> if it finds an\r\n    <b>i</b> such that <b>a[i]</b> stores the same (<b>.equals</b>)\r\n    <b>String</b> as <b>value</b>; there is no reason to search any further.\r\n  By standard convention, returning <b>-1</b> means <b>value</b> was not found\r\n    in <b>a</b> (since <b>-1</b> is NEVER a legal index in an array).\r\n  This method returns <b>-1</b> only after it discovers that no member in the\r\n    array store <b>value</b>.\r\n  Note the use of two <b>return</b> statements, which I believe simplify this\r\n    code (don't agree? try writing this method with only one <b>return</b> and\r\n    show it to me if it is simpler).\r\n  <p>\r\n  The next method returns whether every member in the array stores 0.\r\n  It has a similar test/return structure as <b>findLowestIndexOf</b>.\r\n  <pre><b>  public static boolean all0(int[] a) {\r\n    for (int i=0; i&lt;a.length; i++)\r\n      if (a[i] != 0)\r\n        return false;\r\n\r\n    return true;\r\n  }</b></pre>\r\n  Here the code immediately returns <b>false</b> as soon as it finds a non-0\r\n     member in the array (there is no reason to search any further).\r\n  This method returns <b>true</b> only after it discovers that every member\r\n    in the array does store a <b>0</b>.\r\n  <p>\r\n  I often see beginners write such code as follows.\r\n  This code is more complicated and slower than the code above: it is terrible.\r\n  If you want to be a programmer, avoid overly complicated and slow code.\r\n  <pre><b>  public static boolean all0(int[] a) {\r\n    int count0s = 0;                     //terrible code\r\n    for (int i=0; i&lt;a.length; i++)       //terrible code\r\n      if (a[i] == 0)                     //terrible code\r\n        count0s++;                       //terrible code\r\n                                         //terrible code\r\n    if (count0s == a.length)             //terrible code\r\n      return true;                       //terrible code\r\n    else                                 //terrible code\r\n      return false;                      //terrible code\r\n  }</b></pre>\r\n  <p>\r\n  The next method determines whether an array is stored in increasing order\r\n    (technically, non-decreasing order, because we ensure only that a\r\n    subsequent value is no smaller than -at least as big as- the preceeding\r\n    one).\r\n  Note the interesting <b>for</b> loop bounds, and the interesting use of the \r\n    index in the body of the loop.\r\n  If an array stores N values, we must compare N-1 pairs of values to compute\r\n    this answer.\r\n  For the first iteration, we are comparing <b>a[0]>a[1]</b>; for the last\r\n    iteration we care comparing <b>a[a.length-2] > a[a.length-1]</b>, which\r\n    is comparing the next-to highest index with the highest one in the array.\r\n   <pre><b>  public static boolean increasing(int[] a) {\r\n    for (int i=0; i&lt;a.length-1; i++)\r\n      if (a[i] > a[i+1])\r\n        return false;\r\n\r\n    return true;\r\n  }</b></pre>\r\n  Here the code immediately returns <b>false</b> as soon as it finds a member \r\n    in the array that is followed by a smaller value (there is no reason to\r\n    search any further).\r\n  This method returns <b>true</b> only after it discovers that every member\r\n    (but the last) in the array is followed by a value that is at least as big.\r\n  <p>\r\n  The following three-parameter method swaps the values in positions\r\n    <b>i</b> and <b>j</b> in array <b>a</b>.\r\n   <pre><b>  public static void swap(int i, int j, int[] a) {\r\n    int temp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = temp;\r\n  }</b></pre>\r\n  We can illustrate an example of a call to this method using the following\r\n    call frame.\r\n<p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/swapframe.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Notice that this method changes the state of the array object whose\r\n    reference it is passed.\r\n  The argument <b>x</b> still refers to the same object (the method cannot\r\n    change what object it refers to), but the state of that object has been\r\n    changed inside the method.\r\n<p>\r\n  Finally, here is an interesting method: interesting because it returns\r\n    a new array object.\r\n  The <b>lengthAtLeast</b> method takes a <b>String[]</b> as a parameter and\r\n     returns another <b>String[]</b> as a result: the returned result contains\r\n     only those  <b>String</b>s from the parameter array that are at least\r\n     <b>n</b> characters long (specified by the second parameter).\r\n  <pre><b>  public static String[] lengthAtLeast(String[] a, int n) {\r\n    int answerLength = 0;\r\n    for (int i=0; i&lt;a.length; i++)\r\n      if (a[i].length() > n)\r\n        answerLength++;\r\n\r\n    String[] answer  = new String[answerLength];\r\n    int      answerI = 0;\r\n    for (int i=0; i&lt;a.length; i++)\r\n      if (a[i].length() > n)\r\n        answer[answerI++] = a[i];  //Note the different values used for indexes\r\n\r\n    return answer;\r\n  }</b></pre>\r\n  This method works by first determining how many values must be returned.\r\n  Then it declares an array with exactly that length.\r\n  Next it fills the array with the required values: notice how the\r\n    postfix <b>++</b> operator returns as a result the original value\r\n    of <b>answerI</b> but also increments it for the next interation.\r\n  Finally the method returns the new array it constructed and filled.\r\n  <p>\r\n  Assume that we declare\r\n   <b><pre> String[] s = new String[]{\"a\", \"ab\", \"abc\", abcd\", \"abcde\"}</pre></b>\r\n  We can then write <b>String[] special = lengthAtLeast(s,3);</b> or even\r\n    <b>s = lengthAtLeast(s,3);</b> if we never need to access the original\r\n    array object (making <b>s</b> now refer to the one <b>lengthAtLeast</b>\r\n    constructed.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Array Instance Variables-->\r\n\r\n<a name=\"ArrayInstances\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Arrays Instance Variables</b></td>\r\n<td width =\"80%\">\r\n  We can also write classes that define arrays for their instance variables,\r\n    constructors that intialize them, and methods that process these intialized\r\n    instance variables.\r\n  In fact, the <b>DiceEnsemble</b> class (not <b>SimpleDiceEnsemble</b>)\r\n    does extactly this.\r\n  It defines just three instance variables:\r\n  <b><pre>  private int   sidesPerDie;\r\n  private int   rollCount;\r\n  private int[] pips;</pre></b>\r\n  Here, the <b>pips</b> array stores the number of pips showing on each of\r\n    the dice in the ensemble.\r\n  Recall from our original pictures (which will now make more sense, because\r\n    we know about array objects)\r\n    that we illustrated the declaration of\r\n    <b><pre>  DiceEnsemble d1 = new DiceEnsemble(2,6);</pre></b>\r\n  by\r\n<p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/diceobject.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The constructor for this class reinitializes <b>sidesPerDie</b> and\r\n    <b>pips</b> (<b>rollCount</b> is declared to store <b>0</b>).\r\n  <b><pre>  public DiceEnsemble (int numberOfDice, int sidesPerDie)\r\n    throws IllegalArgumentException {\r\n    if (numberOfDice < 1)\r\n      throw new IllegalArgumentException\r\n        (\"DiceEnsemble constructor: Number of dice (\"+numberOfDice+\") < 1\"); \r\n    if (sidesPerDie < 1)\r\n      throw new IllegalArgumentException\r\n        (\"DiceEnsemble constructor: Sides per die (\"+sidesPerDie+\") < 1\"); \r\n\r\n    this.sidesPerDie  = sidesPerDie;\r\n    this.pips         = new int[numberOfDice];\r\n    //No name conflict for pips; we could write: pips = new int[numberOfDice]\r\n  }</pre></b>\r\n    which reinitializes the instance variable <b>sidesPerDie</b> with the\r\n      value of the second parameter and\r\n    reinitializes the instance variable <b>pips</b> (by using the first\r\n      parameter) to refer to an array that is exactly the right length to\r\n      contain values for each of the dice in the ensemble.\r\n  Once these instance variables are initialized, the <b>getNumberOfDice</b>\r\n    method becomes just\r\n  <b><pre>  public int getNumberOfDice ()\r\n  {return pips.length;}</pre></b>\r\n  So, there is no need to use another instance variable to store the number\r\n    of dice; that information is already stored in -and can be accessed via-\r\n     the <b>public final int length</b> instance variable of the <b>pips</b>\r\n     array.\r\n  <p>\r\n  Likewise, the <b>roll</b> mutator/command becomes simply needs to \r\n    increment <b>rollCount</b> and fill in every member in the array to which\r\n    <b>pip</b> refers with new and random pip values for the dice.\r\n  <b><pre>  public DiceEnsemble roll () {\r\n    rollCount++;\r\n    for (int i=0; i&lt;pips.length; i++)\r\n      pips[i]  = (int)Math.round(Math.random()*sidesPerDie + .5); \r\n    return this;\r\n  }</pre></b>\r\n  Many other methods use the <b>pip</b> array to compute their results.\r\n  After <b>roll</b> has stored new pips, the <b>getPipSum</b> method\r\n    becomes just\r\n  <b><pre>  public int getPipSum ()\r\n    throws IllegalStateException {\r\n    if (rollCount == 0)\r\n      throw new IllegalStateException\r\n        (\"getPipSum called, but dice not rolled\");\r\n\r\n    int pipSum = 0;\r\n    for (int i=0; i&lt;pips.length; i++)\r\n      pipSum += pips[i];\r\n    return pipSum;\r\n  }</pre></b>\r\n  which adds up all the values in the <b>pips</b> array.\r\n  Notice that this method declares a local variable <b>pipSum</b>.\r\n  Why is this not declared as an instance variable?\r\n  Because this information is used only while the method is executing;\r\n    after that, its values can be forgotten, therefore there is no need\r\n    to store it as an instance variable.\r\n  Generally, if a variable can be declared locally instead of as an\r\n    instance variables, that is to be preferred.\r\n  <p>\r\n  Finally, the <b>getPips</b> method is also simple, but a bit subtle.\r\n  <b><pre>  public int getPips (int dieIndex)\r\n     throws IllegalStateException, IllegalArgumentException {\r\n    if (rollCount == 0)\r\n      throw new IllegalStateException\r\n       (\"getPip called, but dice not rolled\");\r\n\r\n    if (dieIndex < 1 || dieIndex > pips.length)\r\n      throw new IllegalStateException\r\n        (\"getPip called, but dieIndex(\"+dieIndex+\r\n         \") is not in the range [1,\"+pips.length+\"]\");\r\n\r\n    return pips[dieIndex-1];\r\n  }</b></pre>\r\n  It first checks for either no rolls or a <b>dieIndex</b> that is not legal;\r\n    it is not in the range <b>[1..number of dice]</b>; in either case, it\r\n    throws an exception.\r\n  Otherwise it returns the pips showing on the die specified by\r\n    <b>dieIndex</b>: die <b>1</b> is stored in array index <b>0</b>,\r\n    die <b>2</b> is stored in array index <b>1</b>, etc.; which is\r\n    why the subtraction occurs in the index calculation.\r\n  <p>\r\n  So, it is easy to declare array instance variables in classes, initialize \r\n    them in constructors, and manipulate them in non-<b>static</b> methods.\r\n  I recommend that you examine how the other methods in the <b>DiceEnsemble</b>\r\n   class work with the <b>pips</b> array instance variable.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Arrays and the Debugger-->\r\n\r\n<a name=\"Debugger\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Arrays and the Debugger</b></td>\r\n<td width =\"80%\">\r\n  The Eclipse debugger easily displays arrays in the <b>Variables</b> pane.\r\n  Recall that the disclosure box in the debugger allows us to observe each\r\n    instance variable in an object; for arrays it displays each index and the\r\n    indexed member stored in the array.\r\n  Surprisingly, the debugger doesn't display the <b>length</b> instance\r\n    variable, but we can infer its value from the index of the last member\r\n    shown.\r\n  <p>\r\n  As with any object, the array's indexed members are available by clicking on\r\n    the disclosure box (plus sign); doing so changes the contents of this box\r\n    (to minus sign) and discloses the indexes and their members in the array.\r\n  Of course, if the array members themselves refer to objects, they too\r\n    will have their own disclosure boxes, which we can click to disclose\r\n    further information about these objects.\r\n  <p>\r\n  The sample program declares\r\n  <pre><b>  int   howBig = Prompt.forInt(\"Enter length for the array\");\r\n  int[] a      = new int[howBig];</b></pre>\r\n  If we enter <b>5</b> at the prompt, the <b>Variables</b> pane in the\r\n    debugger shows\r\n  <p>\r\n  <img src=\"images/debug1.gif\"></image>\r\n  <p>\r\n  Note that <b>a</b> is not yet shown, because it has not been declared.\r\n  After <b>a</b>'s declaration is executed, the debugger shows\r\n  <p>\r\n  <img src=\"images/debug2.gif\"></image>\r\n  <p>\r\n  Now <b>a</b> appears; its value shows as <b>int[5]</b>, which means a five\r\n    element <b>int</b> array.\r\n  Ignor the <b>id</b> part of the value.\r\n  If we click the disclosure box (plus sign), it changes into a minus sign,\r\n    and discloses all the indexes and their members in the array.\r\n  <p>\r\n  <img src=\"images/debug3.gif\"></image>\r\n  <p>\r\n  Here all the array values are shown to store zero initially, because that\r\n    is the default for <b>int</b> instance variables, and the members of arrays\r\n    are much like these.\r\n  After prompting the user for a new value to store in each index (I entered\r\n    <b>3</b>, <b>8</b>, <b>12</b>, <b>-5</b>, <b>7</b>), the debugger shows\r\n  <p>\r\n  <img src=\"images/debug4.gif\"></image>\r\n  <p>\r\n  These values are all highlighted in yellow, because I set a breakpoint after\r\n    the entire input loop, executing it completely before the debugger stops.\r\n  Run the <a href=\"../../programs/arraydemo.zip\">Array Demonstration</a>\r\n    application and familiarize yourself with the operation of the debugger\r\n    for programs declaring arrays.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Arrays and Classes -->\r\n\r\n<a name=\"ArraysAndClasses\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Arrays and Classes for Modeling Data</b></td>\r\n<td width =\"80%\">\r\n  Finally, arrays and classes act together synergistically.\r\n  A class is a heterogeneous data type: it defines any number of instance\r\n    variables, each declared with its own individual name to store a different\r\n    type of value.\r\n  An array is a homogeneous data type: it defines one name storing an arbitrary\r\n    number of indexed values, all declared to store the same type of value.\r\n  <p>\r\n  Combinations of arrays and classes have all the descriptive power that we\r\n    need to model almost any kind of information in the computer.\r\n  As the semester progresses, we will see more sophisticated uses of arrays and\r\n    classes combined: e.g., an array where each of its members is an object\r\n    from a class (and inside each object in the class is an instance variable\r\n    in which an array of other values is stored).\r\n  <p>\r\n  Before continuing with our discussion of arrays as instance variables in\r\n    collection classes, we take short detour to discuss four related topics:\r\n    wrapper classes, the <b>Object</b> class, the <b>instanceof</b> operator,\r\n    and reference casting.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Wrapper Classes -->\r\n\r\n<a name=\"Wrapper\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Wrapper Classes</b></td>\r\n<td width =\"80%\">\r\n  Java provides four <b>wrapper classes</b>, one for each of the four\r\n    primitive types in Java.\r\n  Their names are <b>Integer</b>, <b>Double</b>, <b>Character</b>, and\r\n    <b>Boolean</b> (note the standard capitalization for class names).\r\n  All these classes are defined in the <b>java.lang</b> package.\r\n  The main purpose of each wrapper class is to be able represent a primitive\r\n    value as an object: one that contains just that primitive value as its\r\n    state.\r\n  Each class has a constructor whose parameter is a primtive; each has a\r\n    method that returns the value of the primitive stored in the constructed\r\n    object (<b>intValue</b>, <b>doubleValue</b>, <b>charValue</b>, and\r\n     <b>booleanValue</b> name these methods respectively).\r\n  Objects of these classes are immutable, so once an object is constructed the\r\n    primitive it stores never changes.\r\n  Examine the Javadoc pages for these wrapper classes; observe their many\r\n    constructors and methods (all accessors/queries).\r\n  <p>\r\n  So, for example, we can define <b>Integer x = new Integer(10);</b>\r\n    the variables <b>x</b> now stores a reference to an object constructed\r\n    from the <b>Integer</b> class whose state is <b>10</b>.\r\n  We cannot write <b>x+1</b> because <b>x</b> is not an <b>int</b> but is\r\n    an <b>Integer</b>, and there is no prototype for <b>+</b> that adds\r\n    an <b>Integer</b> to an <b>int</b>.\r\n  But, we can write <b>x.intValue() + 1</b> because the <b>intValue</b> method\r\n    returns an <b>int</b>: the one stored in the object <b>x</b> refers to.\r\n  <p>\r\n  Because wrapper classes are immutable, there is no way to increment the\r\n    primitive value that is stored in the object <b>x</b> refers to.\r\n  But, we could write <b>x = new Integer(x.intValue()+1)</b> whose execution\r\n    is illustrated below.\r\n  <p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/incinteger.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  After executing this statement, the value in the object <b>x</b> refers to\r\n    is one bigger: but instead of changing the state of the original object,\r\n    <b>x</b> now refers to a different one.\r\n  When we discuss increasing the length of an array, we will see a similar\r\n    solution.\r\n  <p>\r\n  Wrapper classes also define various other useful information (and sometimes,\r\n    quite a lot).\r\n  For example, we have seen that the <b>Integer</b> class stores the\r\n    <b>static final int</b> values <b>MIN_VALUE</b> and <b>MAX_VALUE</b>;\r\n    it also stores the <b>static int</b> method <b>parseInt</b>): e.g.,\r\n    <b>int i = Integer.parseInt(\"123\");</b>\r\n  <p>  \r\n  From what we know of Java so far, there is no reason to use wrapper classes!\r\n  But, we are about to explore two simple but general collections, stack and\r\n    queue, which can store only references to objects, and not primitives.\r\n  In this context, if we want to store a primitive value in such collections,\r\n    we must first wrap it in an object (using a constructor of the appropriate\r\n    wrapper class), and store a reference to that object in the collection.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- The Object Class -->\r\n\r\n<a name=\"Object\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Object Class</b></td>\r\n<td width =\"80%\">\r\n  The <b>Object</b> class in Java is a very special class.\r\n  When we learn about inheritance hierarchies, we will see that this class is\r\n    special because it is at the root of the inheritance hierarchy: every\r\n    class in Java is an extension/specialization of the <b>Object</b> class.\r\n  (You can see this trivially if you look at the Javadoc for any other class:\r\n    it will always show <b>java.lang.Object</b> as the first class in\r\n    the hierarchy.)\r\n  This class is defined in the <b>java.lang</b> package.\r\n  For now, though, we will concentrate on just two salient facts about the\r\n    <b>Object</b> class, discussed below.\r\n  <p>\r\n  We can specify <b>Object</b> as the type of a variable: this includes local\r\n     variables, parameter variables, instance variables -and now, even the\r\n     type stored as the indexed members in array variables.\r\n  If we declare a variable to be of the <b>Object</b> type...\r\n  <ol>\r\n    <li>The variable can store a reference to an object constructed from any\r\n          class.\r\n      <li>The only methods that we can call on the variable are those methods\r\n          defined in the <b>Object</b> class.\r\n  </ol>\r\n  We have always spoken of a reference variable storing a reference to a\r\n    object constructed from a <b>compatible</b> class: up to now, this has\r\n    always meant \"constructed from the same class\": e.g., Java ALLOWS\r\n    <b>Timer t = new Timer();</b> but DOES NOT ALLOW\r\n    <b>Timer t = new Rational(1,2);</b>\r\n  Now, we see from the rule above that a variable declared to be of type\r\n    <b>Object</b> can store any reference, because any reference is\r\n    compatible with <b>Object</b>.\r\n  <p>\r\n  So, Java ALLOWS <b>Object o = new Object();</b> and\r\n    <b>Object o = new Timer();</b> and\r\n    <b>Object o = new Rational(1,2);</b>\r\n  Note, though, that we still cannot store a value of a primitive type\r\n    in such a variable: e.g., Java DOES NOT ALLOW\r\n    <b>Object o = 10;</b> because it must store a reference value, not a\r\n    primitive value.\r\n  But remember that we can use wrapper classes to achieve an equivalent result:\r\n    e.g., Java allows <b>Object o = new Integer(10);</b>\r\n  <p>\r\n  The <b>Object</b> class defines only about a dozen methods, of which\r\n    <b>toString</b> is the only one that we have studied.\r\n  Thus, Java allows calling <b>o.toString()</b> regardless of which\r\n    ALLOWABLE declaration above we use.\r\n  Regardless of what kind of object the reference in an <b>Object</b>\r\n    variable refers to, we can call only <b>Object</b> methods on it.\r\n  So, even if we wrote <b>Object o = new Integer(10);</b> Java DOES NOT ALLOW\r\n    calling <b>o.intValue()</b> because <b>intValue</b> is not a method defined\r\n    in the <b>Object</b> class.\r\n  <p>\r\n  Thus, using the type <b>Object</b> gives us power in one dimension but \r\n    restricts power in another.\r\n  It is powerful because variables of this type can store (generic) references\r\n    to any objects.\r\n  But, it restricts us from calling all but a few methods on these variables.\r\n  This balance of power will be explored throughout the rest of this lecture\r\n    and addressed later, as the basis of inheritance hierarchies and\r\n    polymorphic behavior.\r\n  <p>\r\n  There is an important distinction between the declared type of a variable\r\n    and the class of the object to which it refers.\r\n  There was no distinction before, because the type of a variable and\r\n    the class of the object to which it refers were always the same.\r\n  What seems like a small leak in this rule will turn into a mighty river\r\n    as we discuss interfaces and inheritance hierarchies.\r\n<!---\r\n  Examine the following code\r\n  <b><pre>  Object o;\r\n  if (Math.random() < .5)\r\n    o = new Rational(1,2);\r\n  else\r\n    o = new Integer(10);\r\n  ...code using o</pre></b>\r\n  We know after the <b>if</b> statement that <b>o</b> refers to an object\r\n    constructed from either the <b>Raional</b> or <b>Integer</b> class.\r\n  What methods should we be able to call on <b>o</b>? The methods defined in\r\n    <b>Rational</b>? The methods defined in  <b>Integer</b>?\r\n  Java (and we) cannot tell, because a random number determines what object\r\n    reference is stored in <b>o</b>.\r\n  Because of inheritance (both classes inherit from <b>Object</b>), the only\r\n    methods thate we can guarantee are callable are those defined in the\r\n    <b>Object</b> class.\r\n--->\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- instanceof -->\r\n\r\n<a name=\"Instanceof\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The instanceof operator</b></td>\r\n<td width =\"80%\">\r\n  We have learned that variables declared of type <b>Object</b> can store\r\n    references to objects constructed from any class.\r\n  Java provides a way for us to check whether a reference refers to an\r\n    instance of a specified class.\r\n  The <b>instanceof</b> operator (one of two operators in the Java that are\r\n    also keywords) performs this operation, returning a <b>boolean</b> result.\r\n  Its form of use is <b>x instanceof Integer</b>; it is a binary infix\r\n     operator whose second operand is the name of a class.\r\n  <p>\r\n  When we learn about reference casting below, we will see statements like\r\n  <b><pre>  if (x instanceof Integer)\r\n  ...do something with x knowing it is a reference to an Integer</pre></b>\r\n  Finally, Java considers <b>null</b> to not be an instance of any class (it\r\n     refers to no instance of a class).\r\n  So <b>null instanceof <i>C</i></b> returns <b>false</b> for any class\r\n    <b><i>C</i></b>.\r\n  Lets summarize our current understanding of the <b>instanceof</b> operator.\r\n  If <b>r instanceof <i>C</i></b> returns <b>true</b> it means that\r\n    <b>r</b> stores a non-<b>null</b> reference to an object constructed from\r\n    class <b><i>C</i></b>; if it returns <b>false</b> it means that either\r\n    <b>r</b> stores <b>null</b> or it stores a reference to an object\r\n     constructed from a class other than <b><i>C</i></b>.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Reference Casting -->\r\n\r\n<a name=\"Casting\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Reference Casting</b></td>\r\n<td width =\"80%\">\r\n  We have learned that we can store any reference into an <b>Object</b>\r\n    variable.\r\n  But once we do so, we can use the <b>Object</b> variable to call only\r\n    methods defined in the <b>Object</b> class.\r\n  We will now learn how to tell Java to treat a reference stored in an\r\n    <b>Object</b> variable just like a reference to the class that the object\r\n    it refers to was really constructed from (gulp! reread the previous\r\n     sentence, it it tortuous).\r\n  This allows us to use <b>Object</b> variables to call all the methods defined\r\n    in that class of the object to which it refers..\r\n  We will discuss this asymmetry in this lecture, and explore it further and\r\n    deeper in the lectures on inheritance.\r\n  <p>\r\n  Assume that we define <b>Object o = new Integer(10);</b>\r\n  Java DOES NOT ALLOW us to call <b>o.intValue()</b>; it would detect\r\n    and report such an error at compile time.\r\n  But Java DOES ALLOW us to call <b>((Integer)o).intValue()</b>.\r\n  Here we are using reference casting to cast <b>o</b> to be a\r\n    reference to an object of type <b>Integer</b> (which it is) and then we\r\n    are calling the <b>intValue</b> method on that casted reference.\r\n  In casting, we always write the type that we are casting TO in parentheses;\r\n    here we are casting <b>o</b> to be of type <b>Integer</b>.\r\n  We need the other (outer) parentheses because casting has a lower precedence\r\n    than member selection (the dot operator), and we want to cast first.\r\n  <p>\r\n  When we cast an <b>Object</b> reference to another class, we are telling the\r\n    Java compiler to act as though that reference really refers to an object\r\n    from that class.\r\n  Afterward, the Java compiler allows us to use the casted reference to call\r\n    any methods defined in that class.\r\n  When Java actually runs our code (after the program compiles correctly) it\r\n    checks each cast: if Java discovers that the cast won't work  -that the\r\n    reference doesn't really refer to an object from the specified\r\n    class- then it throws the <b>ClassCastException</b> before trying to call\r\n    the method.\r\n  Java checks the cast by automatically using the <b>instanceof</b>\r\n    operator: if the cast <b>(Integer)o</b> appears in our code, Java first\r\n    checks <b>o instanceof Integer</b>, throwing an exception if this\r\n    expression evaluates to <b>false</b>.\r\n  (technically, if <b>o</b> stores <b>null</b> Java throws the\r\n    <b>NullPointerException</b> before even checking <b>instanceof</b>.)\r\n  <p>\r\n  Thus, even given the declaration <b>Object o = new Integer(10);</b> we\r\n    could write <b>((Double)o).doubleValue()</b> in our code.\r\n  Because <b>o</b> is casted to a <b>Double</b>, the Java compiler allows\r\n    us to call the <b>doubleValue()</b> method on it.\r\n  But, whent the program runs, this cast will throw the\r\n    <b>ClassCastException</b> because the cast fails: when Java checks\r\n    <b>o instanceof Double</b> this expression evaluates to <b>false</b>.\r\n  <p>\r\n  Thus, we separate our understanding of casting into <b>Compile Time</b> and\r\n     <b>Run Time</b> components.\r\n  Assume that we write the cast <b>(<i>C</i>)o</b> in our code.\r\n  <ul>\r\n    <li><b>Compile time</b>: Java allows <b>o</b> to be treated as if it \r\n             refers to an object from class <b><i>C</i></b>.\r\n           Specifically, we can call any methods defined from class\r\n             <b><i>C</i></b> on it.\r\n    <li><b>Run time</b>: Java checks the cast to make sure it is correct: that\r\n             the casted reference really does refer to an object from class\r\n             <b><i>C</i></b>\r\n           If it does, the code continues executing; if it doesn't, Java throws\r\n             <b>ClassCastException</b>.\r\n  </ul>\r\n  So, a cast is a promise that Java believes while it is compiling the program,\r\n    but also checks while running the program.\r\n  It is an excellent example of Reagan's statement about arms reduction\r\n    treaties with the former Soviet Union: Trust but verify.\r\n  <p>  \r\n  We can explicitly use the <b>instanceof</b> operator to ensure that our\r\n    code will never throw <b>ClassCastException</b>.\r\n  We can write code like\r\n  <b><pre>  if (o instanceof Integer) {\r\n    Integer i = (Integer)o;\r\n    ...use of i; e.g., i.intValue()\r\n  }</pre></b>\r\n  In this code, the cast cannot fail beause the block containing the cast is\r\n    executed only when the <b>if</b>'s test, <b>o instanceof Integer</b>,\r\n    evaluates to <b>true</b>.\r\n  <p>\r\n  Pragmatically, casting is most often performed by itself in a variable\r\n    declaration, as illustrated above.\r\n  As an example, most classes include an <b>equals</b> method that allows\r\n    comparison with a reference to any object.\r\n  For example, the <b>Rational</b> class should include an <b>equals</b>\r\n    method defined by\r\n<b><pre>  public boolean equals(Object other)\r\n  {\r\n    if ( !(other instanceof Rational) )   //From a different class?\r\n      return false;\r\n    if (other == this)                    //Is the same object?\r\n      return true;                        //  no need to check fields!\r\n\r\n    //Cast is guaranteed to work: other is instanceof Rational\r\n    Rational otherRational = (Rational)other;\r\n\r\n    //Check State (both fields)\r\n    return this.numerator   == otherRational.numerator &&\r\n           this.denominator == otherRational.denominator;\r\n  }</pre></b>\r\n  Most <b>equals</b> methods follow the same three-part strategy:\r\n  <ol>\r\n    <li>If the parameter is not a reference to an object of the correct type,\r\n          it returns <b>false</b>.\r\n    <li>If the parameter is <b>==</b> to <b>this</b>, then we are comparing\r\n          an object to itself, in which case it returns <b>true</b>\r\n          immediately, without checking the state of the object; we know that\r\n          any object stores the same state as itself.\r\n    <li>Otherwise, it legal to cast the parameter and store it in a local\r\n          variable of the correct type; once that is done, the states of\r\n          <b>this</b> object and the other one are compared.\r\n  </ol>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Collection Classes -->\r\n\r\n<a name=\"Collection\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Collection Classes: An Introduction</b></td>\r\n<td width =\"80%\">\r\n  Collection classes manage collections of values.\r\n  They include methods to add values to the collection, remove values from the\r\n    collection, and inquire about values in the collection.\r\n  We use arrays to store these values, and unlike our previous discussion\r\n    the arrays are not always filled.\r\n  Generally, a collection class can be represented by two instances variables:\r\n    one refers an array storing all the values in the collection; the other\r\n    is an <b>int</b> that keeps track of how many indexed members in the array\r\n    are actually being used.\r\n  <p>\r\n  In the rest of this lecture we will discuss two simple and well-known\r\n    collection classes: stack and queue.\r\n  These classes are useful in many programs that model real-world data and\r\n    processes.\r\n  Their definitions will heavily rely on the <b>Object</b> type: both in\r\n     methods and for array instance variables.\r\n  Such collections can be used, unchanged, in any programs that we write.\r\n  This kind of generality and reusability is the holy grail of effective\r\n    class design.\r\n  <p>\r\n  The stack and queue collections are straightforwad to implement.\r\n  The straightforward implementation of the stack collection (which implements\r\n    a last-in/first-out ordering) is efficient.\r\n  But, the straightforward implementation of the queue collection (which\r\n    implemements a first-in/first-out ordering) is not efficient; later in\r\n    the semester we will examine a second, more complicated but efficient\r\n    implementation of queues. \r\n  A fundamental component of both implementations is a <b>doubleLength</b>\r\n     method to increase the length of the array storing the collection.\r\n  <p>\r\n  The <b>SimpleStack</b> and <b>SimpleQueue</b> classes that we cover in \r\n    this lecture (along with a simple driver application for each), are\r\n    available online.\r\n  You can download, unzip, run, and examine all this code in the\r\n    <a href=\"../../programs/simplestackdemo.zip\">\r\n      SimpleStack Demonstration</a> and\r\n    <a href=\"../../programs/simplequeuedemo.zip\">\r\n      SimpleQueue Demonstration</a>\r\n     applications.\r\n  <p>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Stacks and LIFO -->\r\n\r\n<a name=\"Stack\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Stacks and LIFO </b></td>\r\n<td width =\"80%\">\r\n  We can visualize a stack as a vertical array, whose indexes increase as the\r\n    array goes upward.\r\n  The biggest index that stores a non-<b>null</b> reference is known as the\r\n    <b>top</b> of the stack.\r\n  Each <b>SimpleStack</b> object stores two instance variables: a reference to\r\n     such an array and a value <b>top</b>.\r\n  References are both added (pushed on) and removed (popped off) near the top \r\n   of the stack; this means that we characterize a stack as Last-In/First-Out:\r\n    the last reference added to (pushed on) the stack is the first one removed\r\n    (popped off).\r\n  Such a stack is declared and initialized simply by\r\n     <b>SimpleStack x = new SimpleStack();</b>\r\n  The following picture shows a stack onto which three strings have been\r\n     pushed.\r\n  <p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/stack.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Notice that <b>stack</b> is declared to be of type <b>Object[]</b>\r\n    so each indexed member can store a reference to any object.\r\n  Also, we represent <b>null</b> by a slash (<b>/</b>), as appears in array\r\n    index 3 in the picture above; we will continue to use this graphical\r\n    notation throughout the rest of the course for <b>null</b> references.\r\n  <p>\r\n  The <b>SimpleStack</b> collection class consists of definitions (elided here,\r\n     but fully shown in the discussion below) for the following constructors,\r\n     methods, and fields.\r\n  <pre><b>  //Constructors\r\n  public SimpleStack (int initialSize) throws IllegalArgumentException {...}\r\n  public SimpleStack () {...}\r\n\r\n  //Mutators/Commands\r\n  public void    makeEmpty () {...}\r\n  public void    push      (Object o) {...}\r\n  public Object  pop       () throws IllegalStateException {...}\r\n  \r\n  //Accessors/Queries\r\n  public Object  peek      () throws IllegalStateException {...}\r\n  public boolean isEmpty   () {...}\r\n  public int     getSize   () {...}\r\n  public String  toString  () {...}\r\n\r\n  //Private (helper) methods\r\n  private void doubleLength() {...}\r\n  \r\n  //Fields (instance variables)\r\n  private Object[] stack;\r\n  private int      top = -1;</b></pre>\r\n  Let's explore in detail the implementation of each constructor and method,\r\n    in terms of how they manipulate the instance variables.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Length Doubling -->\r\n\r\n<a name=\"LengthDoubling\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Length Doubling</b></td>\r\n<td width =\"80%\">\r\n  Before looking at all the <b>public</b> constructors and methods, we \r\n    will examine the <b>private doubleLength</b> method, which is called\r\n    only in <b>push</b>\r\n  As we push more values onto a stack, the array storing these values must get\r\n    bigger.\r\n  Although the length of an array object cannot be changed once it has been\r\n    constructed, the <b>doubleLength</b> method does the equivalent by\r\n    constructing a new, bigger object; we used much the same approach to\r\n    \"increment\" a variable refering to an immutable <b>Integer</b> object.\r\n  Thes code for length doubling is quite simple, but subtle.\r\n  <b><pre>  private void doubleLength ()\r\n  {\r\n    Object[] temp = new Object[stack.length*2];\r\n    for (int i=0; i&lt;stack.length; i++)\r\n      temp[i] = stack[i];\r\n    stack = temp;\r\n  }</pre></b>\r\n  This method is called only when the array object that <b>stack</b> refers to\r\n    is filled with references.\r\n  It works in three steps:\r\n  <ol>\r\n    <li>It declares the local variable <b>temp</b> and initializes it to refer\r\n          to a newly constructed array object whose length is twice as big as\r\n          the length of the array <b>stack</b> refers to.\r\n        Initially, all indexed members store <b>null</b>.\r\n    <li>It copies all the non-<b>null</b> references from <b>stack</b> to\r\n          <b>temp</b> in order (from <b>0</b> up to <b>top</b>).\r\n    <li>It makes <b>stack</b> refer to the new object.\r\n  </ol>\r\n  Thus, for all intents and purposes, we have doubled the length of\r\n    <b>stack</b>: it now refers to an array that stores the same values, but\r\n    whose length (for storing new values) is twice as long.\r\n  The picture below illustrates how this method executes.\r\n<p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/doublelength.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Notice that <b>top</b> remains unchnaged at <b>1</b> because there are\r\n    still only two references stored in the array (at indexed members\r\n    <b>0</b> and <b>1</b>).\r\n  The instance variable <b>stack</b> no longer refers to the old array object,\r\n    so eventually Java will recycle this object.\r\n  <p>\r\n  Another, similar way to write this method (maybe a bit clearer than\r\n    using <b>temp</b>) is\r\n  <b><pre>  private void doubleLength ()\r\n  {\r\n    Object[] old = stack;\r\n    stack = new Object[stack.length*2];\r\n    for (int i=0; i&lt;old.length; i++)\r\n      stack[i] = old[i];\r\n  }</pre></b>\r\n  <p>\r\n  Although this class doesn't define it, I have written the <b>trimLength</b>\r\n    method below.\r\n  This method shrinks the array to be just big enough to store all the\r\n    current references in <b>stack</b>.\r\n  Here, the first line constructs a \"just big enough\" array and then the\r\n    <b>for</b> loop copies all the references into it.\r\n  <b><pre>  private void trimLength()\r\n  {\r\n    Object[] temp = new Object[top+1];\r\n    for (int i=0; i&lt;=top; i++)\r\n      temp[i] = stack[i];\r\n    stack = temp;\r\n  }</pre></b>\r\n  We could likewise implement this method with <b>old</b> instead of\r\n    <b>temp</b>.\r\n  Note that we could include an <b>if</b> to immediately return if \r\n    <b>stack.length</b> were equal to <b>top+1</b>, but his code,\r\n    while redundant, works.\r\n  If we called <b>x.trimLength()</b> the actions in the picture above would be\r\n    reversed.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Stack Implementation -->\r\n\r\n<a name=\"StackImplementation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Stack Implementation</b></td>\r\n<td width =\"80%\">\r\n  We will now explore all the <b>public</b> constructors and methods in this\r\n    class.\r\n  You are invited to hand simulate this code and draw the relevant pictures\r\n    to help you better understand it.\r\n  We start with the definition of the general constructor.\r\n  <b><pre>  public SimpleStack (int initialSize)\r\n    throws IllegalArgumentException\r\n  {\r\n    if (initialSize < 1)\r\n      throw new IllegalArgumentException\r\n        (\"SimpleStack Constructor: initialSize(\"+initialSize+\") < 1\");\r\n\r\n    stack = new Object[initialSize];\r\n  }</pre></b>\r\n  Basically, this constructor verifies the <b>initialSize</b> parameter\r\n    and then uses it to construct an array that can contain that many\r\n    references.\r\n  Recall that when arrays of references are constructed, all indexed members\r\n    store <b>null</b>.\r\n  Observe that <b>top</b> is declared to store <b>-1</b> initially, and no\r\n    change is made to it here.\r\n  We say that the stack is empty if it is in this state.\r\n  In fact, it is a class invariant that there are always <b>top+1</b> values\r\n    stored in the stack; so at constuction there are <b>0</b> values stored.\r\n  Another explanation for this intial value will emerge when\r\n    we study the code for the <b>push</b> method.\r\n  <p>\r\n  The second constructor has no parameter and constructs an array with\r\n    enough room for just one value.\r\n  It is written simply as\r\n  <b><pre>  public SimpleStack ()\r\n  {this(1);}</pre></b>\r\n  Unless we know  something special about how many values we will push on\r\n    a stack, we will often use this simpler constructor.\r\n  <p>\r\n  The <b>makeEmpty</b> method removes all references from the stack and \r\n    reinitializes <b>top</b> to <b>-1</b>; so, after this method call the\r\n    stack is again empty.\r\n  We define this method, a mutator/command, by\r\n  <b><pre>  public void makeEmpty ()\r\n  {\r\n    for (int i=0; i&lt;=top; i++)\r\n      stack[i] = null;\r\n    top = -1;\r\n  }</pre></b>\r\n  To understand this method, hand simulate it in the state illustrated in the\r\n    picture above.\r\n  Note that all indexed members greater than <b>top</b> already store\r\n    <b>null</b>.\r\n  <p>\r\n  The <b>push</b> method, a mutator/command, adds a reference on top of the\r\n    stack; the reference in its parameter <b>o</b> is stored one beyond the\r\n    old top of the stack, and becomes the new top of the stack.\r\n  It first checks to see if there is no more room in the array; if so, it\r\n    doubles the length of the array as described above.\r\n  Then it always increments <b>top</b> and stores the reference <b>o</b> at\r\n    this new index in the array (there will always be room to store it).\r\n<b><pre>  public void push (Object o)\r\n  {\r\n    if ( getSize() == stack.length)\r\n      doubleLength();\r\n        \r\n    top++;\r\n    stack[top] = o;        //or just stack[++top] = o;\r\n  }</pre></b>\r\n  Notice that a newly constructed <b>SimpleStack</b> stores <b>-1</b> in \r\n    <b>top</b>; the first time that this method is called it increments that\r\n    value to <b>0</b> and then stores the parameter into the array at index\r\n    <b>0</b>.\r\n  Notice that the <b>if</b> calls <b>getSize</b> to check whether there is \r\n    not enough room for the new reference on the stack (we can worry about the\r\n    details of this method later).\r\n  Finally, notice that the semantics of the prefix operator <b>++</b> allows us\r\n    to perform both state changes in a single statements:\r\n    <b>stack[++top] = o;</b>\r\n  <p>\r\n  Because its parameter type is <b>Object</b>, we can call <b>push</b>\r\n    with any argument that refers to an object.\r\n  In fact, we can easily push different classes of objects onto the same stack,\r\n    as illustrated below.\r\n<p>\r\n</tbody>\r\n</table>\r\n   <img src=\"images/stack2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The <b>pop</b> method, a mutator/command and accessor/queury, returns a\r\n    reference to the object\r\n    currently at the top of the stack, and it also removes that reference from\r\n    the stack (replacing it by <b>null</b>); the value underneath it becomes\r\n    the new top of the stack.\r\n  Of course, if the stack is empty when this method is called, it throws\r\n    <b>IllegalStateException</b> (the stack is in an illegal state to perform\r\n    the <b>pop</b> operation).\r\n  This code is written as\r\n  <b><pre>  public Object pop () throws IllegalStateException\r\n  {\r\n    if ( isEmpty() )\r\n      throw new IllegalStateException\r\n        (\"SimpleStack pop: Stack is empty\");\r\n    \r\n    Object answer = stack[top];\r\n    stack[top] = null;\r\n    top--;                       //or just stack[top--] = null;\r\n    return answer;\r\n  }</b></pre>\r\n  Notice how the reference at the top of the stack is stored in the local\r\n    variable <b>answer</b>; then the old indexed member is set to <b>null</b>\r\n    and <b>top</b> is decremented; then the stored <b>answer</b> is returned.\r\n  Notice that the <b>if</b> calls <b>isEmpty</b> to check whether there is no\r\n    value on the stack to be popped (we can worry about the details of this\r\n    method later).\r\n  Finally, notice that the semantics of the postfix operator <b>--</b> allows\r\n    us to perform both state changes in a single statement:\r\n    <b>stack[top--] = null;</b>\r\n  <p>\r\n  Notice that the <b>pop</b> method returns a reference of type <b>Object</b>.\r\n  Recall that this means that the reference returned can refer to an object\r\n    from any class.\r\n  Obviously we can write <b>Object o = x.pop();</b> to store this reference,\r\n    but we cannot do anything interesting with <b>o</b> (only call methods\r\n    on it that are defined in the <b>Object</b> class).\r\n  But, if we know the reference is to a <b>String</b> object, we can instead\r\n    write <b>String s = (String)x.pop();</b>\r\n  The cast here is mandatory, otherwise the Java compiler will detect and\r\n    report an error.\r\n  Recall that the member selector operator (the dot) has precedence over the\r\n    cast; in this statement we want to apply the cast last, so we need no \r\n    extra grouping parentheses.\r\n  <p>\r\n  Finally, note the asymmetry: we can call <b>push</b> without casting\r\n    (any argument reference stored to an <b>Object</b> parameter works); but\r\n     when we call <b>pop</b>, we must cast the reference to do anything useful\r\n     with it.\r\n  Another way of saying this: putting a reference in a stack hides its type;\r\n    when taking a reference out of a stack its type must be restored with a \r\n    cast.\r\n  Of course, we can check its type with the <b>instanceof</b> operator.\r\n  <p>\r\n  Similarly, the <b>peek</b>, an accessor/query, returns the reference\r\n     currently at the top of the stack (like <b>pop</b>) but it DOES NOT\r\n     remove it (unlike <b>pop</b>).\r\n  <b><pre>  public Object peek () throws IllegalStateException\r\n  {\r\n    if ( isEmpty() )\r\n      throw new IllegalStateException(\"SimpleStack pop: Stack is empty\");\r\n    \r\n    return stack[top];\r\n  }</b></pre>\r\n  The <b>isEmpty</b> accessory/query, used in <b>pop</b> and <b>peek</b>, \r\n    returns whether or not the stack is empty.\r\n  It is written simply as\r\n  <b><pre>  public boolean isEmpty ()\r\n  {return top == -1;}</pre></b>\r\n  Recall that in an empty stack, <b>top</b> stores <b>-1</b>.\r\n  Another way to implement this method would be <b>return getSize() == 0;</b>\r\n  <p>\r\n  The <b>getSize</b> accessory/query, returns the number of references on the\r\n    stack.\r\n  It is written simply as\r\n  <b><pre>  public int getSize ()\r\n  {return top+1;}</pre></b>\r\n  Recall that in an empty stack, <b>top</b> stores <b>-1</b>; in this case\r\n    the value <b>getSize</b> returns is <b>0</b>.\r\n  Recall that there is a class invariant that states there are always\r\n    <b>top+1</b> values stored in the stack.\r\n  <p>\r\n  Finally, the <b>toString</b> method returns the value of <b>top</b>, the\r\n    <b>length</b> of the <b>stack</b> array, and the <b>String</b> values\r\n    of all the references in the stack.\r\n  It uses lots of catenation to get the job done.\r\n  <b><pre>  public String toString ()\r\n  {\r\n    String answer = \"SimpleStack[top=\"+top+\"/length=\"+stack.length;\r\n    for (int i=0; i<=top; i++)\r\n      answer += \";stack[\"+i+\"]=\"+stack[i];\r\n    answer +=  \"]\";\r\n    \r\n    return answer;\r\n  }</pre></b>\r\n  <p>\r\n  In summary:\r\n  Each <b>SimpleStack</b> stores the <b>stack</b> array (storing the references\r\n    in the stack) and <b>top</b> (storing the index of the last reference).\r\n  Generally, <b>push</b> increments <b>top</b> by 1 and <b>pop</b> decrements\r\n     <b>top</b> by 1.\r\n  So that the first <b>push</b> (or any <b>push</b> on an empty stack) stores\r\n    its reference in index <b>0</b>.\r\n  The number of references in the stack is always <b>top+1</b>; an empty stack\r\n    stores <b>0</b> references so <b>top</b> in an empty stack must be\r\n    <b>-1</b>.\r\n  The size of the array is doubled when necessary (and it never shrinks).\r\n  <p>\r\n  Stacks are famous in Computer Science, because method calls are implements\r\n     via stacks.\r\n  When a method is called, it call frame (or the computer equivalent) is pushed\r\n    onto the call stack.\r\n  This is the same call stack that appears in a pane in the debugger (although\r\n    it grows from the top downward).\r\n  Each call to a method pushes that method onto the call stack; each return\r\n    from a method pops that method off the call stack (returning to execute\r\n     code at the new method on top of the call stack -the one that called the\r\n     method that just returned).\r\n  In fact, stacks are so common in computing (see the next section too) most\r\n    computers have special instructions that push/pop a value onto/from a \r\n    hardware stack.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Stack Application: RPN and Stacks -->\r\n\r\n<a name=\"StackApplication\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Stack Application: RPN and Stacks</b></td>\r\n<td width =\"80%\">\r\n  We should now all masters of writing formulas as expressions in Java, and\r\n    analyzing such expressions: we know about the precedence of operators,\r\n    parentheses to override precedence, and left to right (or right to left)\r\n    associativity.\r\n  But now we ask the question, \"Is that the simplest way to write expressions\".\r\n  The answer is no.\r\n  In this section we shall discuss a simpler notation for writing expressions,\r\n    and its relationship to stacks (which we use to evaluate such expressions\r\n    easily).\r\n  <p>\r\n  The notation that we will learn to write expressions is called Reverse Polish\r\n     Notation (RPN).\r\n  The original Polish Notation was invented by a group of famous Polish\r\n    logicians in the late 1930s.\r\n  They wanted to prove things about expressions, and therefore wanted to invent\r\n    the simplest rules possible to write arbitrary expressions.\r\n  This group was wiped out in World War II, and the notation was rediscovered\r\n    in the 1960s and used in the LISP programming language; many calculators\r\n    also use RPN (as well as the programming language Forth).\r\n  In Polish Notation, operators always appear before their operands; in RPN,\r\n    operators always appear after their operands.\r\n  <p>\r\n  RPN is very simple: it has no operator precedence, no associativity rules,\r\n    and no parentheses to override precedence and associativity rules!\r\n  We evaluate an RPN expression (using oval diagrams) in a very straighforward\r\n    manner, scanning it from left to right (we will ignore types here, and\r\n    concetrate on values).\r\n  <ol>\r\n    <li>If the next token is a number, circle it, and write its value below.\r\n    <li>If the next token is an operator, use one big circle to enclose the\r\n          operator and its operands (for binary operators, the two previous \r\n          circles, however big they are), apply the operator to these operands,\r\n          and write the resulting value below the big circle.\r\n  </ol>\r\n  Here are some examples that illustrate Java expressions and their equivalent\r\n     RPN.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr align=\"left\">\r\n  <th>Java</th><th>RPN</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr align=\"left\"><td><pre><b>1 + 2 * 3</b></pre></td><td><pre><b>1 2 3 * +</b></pre></td>\r\n  <tr align=\"left\"><td><pre><b>(1 + 2) * 3</b></pre></td><td><pre><b>1 2 + 3 *</b></pre></td>\r\n  <tr align=\"left\"><td><pre><b>(1 + 2) * ((3 + 4) * (5 + 6))</b></pre></td><td><pre><b>1 2 + 3 4 + 5 6 + * *</b></pre></td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note that one property of Java and RPN expressions is that the\r\n    <i>operands</i> appear in the same order; the earlier an <i>operator</i> is\r\n    applied in the Java expression (using all the complicated rules) the\r\n    earlier it appears in RPN.\r\n  Here is a picture illustrating the evaluation process for expressions written\r\n     in RPN.\r\n<p>\r\n</table>\r\n   <img src=\"images/circling.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  We can use a stack to evaluate an expression written in RPN simply.\r\n  We translate the circling rules into \r\n  <ol>\r\n    <li>If the next token is a number, push it on the stack.\r\n    <li>If the next token is an operator, pop the top two numbers off the\r\n          stack, apply the operator to these values, and push the result value\r\n          back on the stack.\r\n  </ol>\r\n  We can translate this algorithm to use a <b>StringTokenizer</b> to get\r\n    all the tokens and a <b>SimpleStack</b> (always containing objects from\r\n    the <b>Integer</b> wrapper class) to perform the computation.\r\n  For example, if the operator were a plus, then we translate the second\r\n   rule into the following code (note the casting).\r\n  <b><pre>  Integer operand2 = (Integer)x.pop();\r\n  Integer operand1 = (Integer)x.pop();\r\n  x.push ( new Integer (operand1.intValue() * operand2.intValue()) );</pre></b>\r\n  For non-commutative operators (<b>-</b> and <b>/</b>) we must realize the\r\n    the second/right operand is on the top of the stack and the first/left\r\n    operand is underneath it.\r\n  <p>\r\n  Here is a picture illustrating the evaluation process of the largest\r\n    expression.\r\n<p>\r\n</table>\r\n   <img src=\"images/stacking.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The <a href=\"../../programs/rpncalculator.zip\">RPN Calculator</a>\r\n    project uses the <b>StringTokenizer</b> and <b>SimpleStack</b> classes\r\n    to implement the calculator.\r\n  In fact, this project also contains two other application programs.\r\n  The first uses the <b>BigInteger</b> class instead of the <b>Integer</b>\r\n     wrapper class\r\n  The second allows relational and logical operators as well, pushing/popping\r\n    references to both the <b>Integer</b> and <b>Boolean</b> wrapper classes.\r\n  The operator determines how to cast the references popped off: <b>Boolean</b>\r\n   for the operators <b>!</b>, <b>&&</b>, and <b>||</b>; <b>Integer</b> for the\r\n   arithmetic and relation operators.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Queues and FIFO -->\r\n\r\n<a name=\"Queue\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Queues and FIFO </b></td>\r\n<td width =\"80%\">\r\n  We can visualize a queue as a horizontal array, whose indexes increase as the\r\n     array goes rightward.\r\n  The biggest index that stores a non-<b>null</b> reference is known as the\r\n     <b>rear</b> of the queue.\r\n  Each <b>SimpleQueue</b> object stores two instance variables: a reference to\r\n     such an array and a value <b>rear</b>.\r\n  References are added (enqueued) at the rear of the queue and removed\r\n    (dequeued) from the front of the queue (always index <b>0</b>); this means\r\n    that we characterize a queue as First-In/First-Out: the first reference\r\n    added to the queue is also the first one removed.\r\n  <p>\r\n  Thus, a queue implements a \"fair\" line, where the first person getting into\r\n    the line is the first person leaving the line to be served (with the others\r\n    getting in line behind him/her).\r\n  In fact, in England, people \"queue up\" to stand in a \"queue\" (just as we\r\n    \"line up\" to stand in a \"line\").\r\n  Such a queue is declared and initialized simply by\r\n     <b>SimpleQueue x = new SimpleQueue();</b>\r\n  The following picture shows a queue into which three strings have been\r\n    enqueued.\r\n</table>\r\n   <img src=\"images/queue.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Notice that <b>q</b> is declared to be of type <b>Object[]</b>\r\n    so each indexed member can store a reference to any object.\r\n  Also, we represent <b>null</b> by a slash (<b>/</b>), as appears in array\r\n    index 3 in the picture above; we will continue to use this graphically\r\n    notation throughout the rest of the course.\r\n  <p>\r\n  If we call <b>dequeue</b> to return and remove the first value, the new\r\n    picture becomes\r\n</table>\r\n   <img src=\"images/queue2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n\r\n  The <b>SimpleQueue</b> collection class consists of definitions (elided here,\r\n     but fully shown in the discussion below) for the following constructors,\r\n     methods and fields.\r\n  <pre><b>  public SimpleQueue (int initialSize) throws IllegalArgumentException {...}\r\n  public SimpleQueue () {...}\r\n\r\n  //Mutators/Commands\r\n  public void    makeEmpty () {...}\r\n  public void    enqueue   (Object o) {...}\r\n  public Object  dequeue   () throws IllegalStateException {...}\r\n  \r\n  //Accessors/Queries\r\n  public Object  peek      () throws IllegalStateException {...}\r\n  public boolean isEmpty   () {...}\r\n  public int     getSize   () {...}\r\n  public String  toString  () {...}\r\n \r\n  //Private (helper) methods\r\n  private void doubleLength() {...}\r\n  \r\n  //Fields (instance variables)\r\n  private Object[] q;\r\n  private int      rear = -1;</b></pre>\r\n  Let's explore in detail the implementation of each constructor and method,\r\n    in terms of how they manipulate the instance variables.\r\n  The <b>doubleLength</b> method in this class is almost identical to the\r\n    one we discussed in <b>SimpleStack</b>, but it refers to the instance\r\n    variable <b>q</b>.\r\n  Again, this method is called only when the array object that <b>q</b> refers\r\n    to is filled with non-<b>null</b> references.\r\n\r\n  <b><pre>  private void doubleLength ()\r\n  {\r\n    Object[] temp = new Object[q.length*2];\r\n    for (int i=0; i&lt;q.length; i++)\r\n      temp[i] = q[i];\r\n    q = temp;\r\n  }</b></pre>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Queue Implementation -->\r\n\r\n<a name=\"QueueImplementation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Queue Implementation</b></td>\r\n<td width =\"80%\">\r\n  We now will explore all the <b>public</b> constructors and methods in this\r\n    class.\r\n  You are invited to hand simulate this code and draw the relevant pictures\r\n    to help you better understand it.\r\n  Most of these definitions are similar to those in the <b>SimpleStack</b>\r\n    class; <b>pop</b> and <b>dequeue</b> are most different, implementing\r\n    the last-in/first-out and first-in/first-out difference.\r\n  So, make sure you read the description of this method carefully.\r\n  We start with the definition of the general constructor.\r\n  <b><pre>  public SimpleQueue (int initialSize)\r\n    throws IllegalArgumentException\r\n  {\r\n    if (initialSize < 1)\r\n      throw new IllegalArgumentException\r\n         (\"SimpleQueue Constructor: initialSize(\"+initialSize+\") < 1\");\r\n\r\n    q = new Object[initialSize];\r\n  }</pre></b>\r\n  Basically, this constructor verifies the <b>initialSize</b> parameter\r\n    and then uses it to construct an array that can contain that many\r\n    references.\r\n  Recall that when arrays of references are constructed, all indexed members\r\n    store <b>null</b>.\r\n  Observe that <b>rear</b> is declared to store <b>-1</b> initially, and no\r\n    change is made to it here.\r\n  We say that the queue is empty if it is in this state.\r\n  In fact, it is a class invariant that there are always <b>rear+1</b> values\r\n    stored in the queue; so at constuction there are <b>0</b> values stored.\r\n  Another explanation for this intial value will emerge when\r\n    we study the code for the <b>enqueue</b> method.\r\n  <p>\r\n  The second constructor has no parameter and constructs an array with\r\n    enough room for just one value.\r\n  It is written simply as\r\n  <b><pre>  public SimpleQueue ()\r\n  {this(1);}</pre></b>\r\n  Unless we know  something special about how many values we will enequeue in\r\n    a queue, we will often use this simpler constructor.\r\n  <p>\r\n  <p>\r\n  The <b>makeEmpty</b> method removes all references from the queue and \r\n    reinitializes <b>rear</b> to <b>-1</b>; so, after this method call the\r\n    queue is again empty.\r\n  We define this method, a mutator/command, by\r\n  <b><pre>  public void makeEmpty ()\r\n  {\r\n    for (int i=0; i&lt;=rear; i++)\r\n      q[i] = null;\r\n    rear = -1;\r\n  }</pre></b>\r\n  To understand this method, hand simulate it in the state illustrated in the\r\n    picture above.\r\n  Note that all indexed members greater than <b>rear</b> already store\r\n    <b>null</b>.\r\n  <p>\r\n  The <b>enqueue</b> method, a mutator/command, adds a reference to the rear of\r\n    the queue; the reference in its parameter <b>o</b> is stored one beyond the\r\n    old rear of the queue, and becomes the new rear of the queue.\r\n  It first checks to see if there is no more room in the array; if so, it\r\n    doubles the length of the array as described above.\r\n  Then it always increments <b>rear</b> and stores the reference <b>o</b> at\r\n    this new index in the array (there will always be room to store it).\r\n<b><pre>  public void enqueue (Object o)\r\n  {\r\n    if ( getSize() == q.length)\r\n      doubleLength();\r\n        \r\n    rear++;\r\n    q[rear] = o;        //or just q[++rear] = o;\r\n  }</pre></b>\r\n  Notice that a newly constructed <b>SimpleQueue</b> stores <b>-1</b> in \r\n    <b>rear</b>; the first time that this method is called it increments that\r\n    value to <b>0</b> and then stores the parameter into the array at index\r\n    <b>0</b>.\r\n  Notice that the <b>if</b> calls <b>getSize</b> to check whether there is \r\n    not enough room for the new reference in the queue (we can worry about the\r\n    details of this method later).\r\n  Finally, notice that the semantics of the prefix operator <b>++</b> allows\r\n    us to perform both state changes in a single statements:\r\n    <b>q[++rear] = o;</b>\r\n  <p>\r\n  Because its parameter type is <b>Object</b>, we can call\r\n    <b>enqueue</b> with any argument that refers to an object.\r\n  <p>\r\n  The <b>dequeue</b> method, a mutator/command and accessor/queury, returns a\r\n    reference to the object currently at the front of the queue, and it also\r\n    removes that reference from the queue by shifting all remaining values\r\n    in the array left (towards the front) by one index position; this leaves\r\n    duplicate references in <b>q[rear-1]</b> and <b>q[rear]</b>, so the last\r\n    one is replaced by <b>null</b>).\r\n  Of course, if the queue is empty when this method is called, it throws\r\n    <b>IllegalStateException</b> (the queuen is in an illegal state to perform\r\n    the <b>dequeue</b> operation).\r\n  This code is written as\r\n  <b><pre>    public Object dequeue () throws IllegalStateException\r\n  {\r\n    if ( isEmpty() )\r\n      throw new IllegalStateException\r\n        (\"SimpleQueue dequeue: queue is empty\");\r\n    \r\n    Object answer = q[0];\r\n    \r\n    //Shift all remaining values (q[1..rear]) left by 1 index, into\r\n    //  positions  q[0..rear-1]\r\n    for (int i=0; i&lt;rear; i++)\r\n      q[i] = q[i+1];\r\n   \r\n    //Remove duplicate in q[rear]; it has been copied into\r\n    //  q[rear-1] too \r\n    q[rear] = null;\r\n    rear--;                 //or just q[rear--] = null;\r\n    return answer;\r\n  }</b></pre>\r\n  Notice that the <b>if</b> calls <b>isEmpty</b> to check whether there is no\r\n    value on the queue to be dequeued (we can worry about the details of this\r\n    method later).\r\n  Finally, note that the semantics of the postfix operator <b>--</b> allows us\r\n    to perform both state changes in a single statement:\r\n    <b>q[rear--] = null;</b>\r\n  <p>\r\n  This method is much different than the <b>pop</b> method for stacks, because\r\n    it requires a <b>for</b> loo to examine every value in the array (as do the\r\n    <b>makeEmpty</b> and <b>toString</b> methods in both classes).\r\n  Thus, the amount of time that it takes to <b>dequeue</b> a value is\r\n    dependent on the number of values already stored in the queue.\r\n  This inefficiency can be eliminated by a more complicated class that \r\n    implements a queue: we will discuss it later in the semester.\r\n  <p>\r\n  Similarly, the <b>peek</b>, an accessor/query, returns the reference\r\n     currently at the front of the queue (like <b>dequeue</b>) but it DOES NOT\r\n     remove it (unlike <b>dequeue</b>).\r\n  <b><pre>  public Object peek ()\r\n    throws IllegalStateException\r\n  {\r\n    if ( isEmpty() )\r\n      throw new IllegalStateException\r\n        (\"SimpleQueue peek: queue is empty\");\r\n    \r\n    return q[0];  \r\n  }</b></pre>\r\n  The <b>isEmpty</b> accessory/query, used in <b>dequeue</b> and <b>peek</b>, \r\n    returns whether or not the queue is empty.\r\n  It is written simply as\r\n  <b><pre>  public boolean isEmpty ()\r\n  {return rear == -1;}</pre></b>\r\n  Recall that in an empty queue, <b>rear</b> stores <b>-1</b>.\r\n  Another way to implement this method would be <b>return getSize() == 0</b>.\r\n  <p>\r\n  The <b>getSize</b> accessory/query, returns the number of references on the\r\n    queue.\r\n  It is written simply as\r\n  <b><pre>  public int getSize ()\r\n  {return rear+1;}</pre></b>\r\n  Recall that in an empty queue, <b>rear</b> stores <b>-1</b>; in this case\r\n    the value <b>getSize</b> returns is <b>0</b>.\r\n  Recall that there is a class invariant that states there are always\r\n    <b>rear+1</b> values stored in the queue.\r\n  <p>\r\n  Finally, the <b>toString</b> method returns the value of <b>rear</b>, the\r\n    <b>length</b> of the <b>q</b> array, and the <b>String</b> values\r\n    of all the references in the queue.\r\n  It uses lots of catenation to get the job done.\r\n  <b><pre>  public String toString ()\r\n  {\r\n    String answer = \"SimpleQueue[rear=\"+rear+\"/length=\"+q.length;\r\n    for (int i=0; i<=rear; i++)\r\n      answer += \";q[\"+i+\"]=\"+q[i];\r\n    answer +=  \"]\";\r\n    \r\n    return answer;\r\n  }</pre></b>\r\n  <p>\r\n  In summary:\r\n  Each <b>SimpleQueue</b> stores the <b>q</b> array (storing the references\r\n    in the queue) and <b>rear</b> (storing the index of the last reference).\r\n  Generally, <b>enequeue</b> increments <b>rear</b> by 1 and <b>dequeue</b>\r\n     decrements <b>rear</b> by 1.\r\n  So that the first <b>enqueue</b> (or any <b>enqueue</b> on an empty queue)\r\n     stores its reference in index <b>0</b>.\r\n  The number of references in the queue is always <b>rear+1</b>; an empty queue\r\n    stores <b>0</b> references so <b>rear</b> in an empty queue must be\r\n    <b>-1</b>.\r\n  The size of the array is doubled when necessary (and it never shrinks).\r\n  <p>\r\n  A typical use of queues is in simulating systems where entities move from one\r\n    part of the system to another, in a fixed order.\r\n  For example, we might want to simulate a supermarket by getting data on when\r\n    a customer enters, how long the customer shops in the store, how many items\r\n    the customer buys, and how long it takes the customer to checkout (once\r\n    he/she reaches the front of the checkout line).\r\n  The only remaining piece of information missing is how long the customer\r\n    waits in the checkout line.\r\n  We can use queues (operating on this data) to simulate a variety of cash\r\n    register configurations: some registers may restrict the number of items\r\n    checked through.\r\n  Then we can determine whether certain configurations are better than others\r\n    (in terms of customer throughput). \r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Length Doubling Performance  -->\r\n\r\n<a name=\"Performance\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Length Doubling: Performance Analysis</b></td>\r\n<td width =\"80%\">\r\n  Before finishing this lecture, we should do a short performance analysis of\r\n    why doubling the length of an expanding stack/queue is a good strategy\r\n    (say, compared to expanding it by increasing its length just by one).\r\n  If we always expand the length of the array by one -the amount needed to\r\n    store the new value, we would still be required to copy all the values\r\n    each time we construct a new array.\r\n  But, if we double the length of the array, we can put many new values into it\r\n     without having to expand it and copy values.\r\n  <p>\r\n  For the analysis below, assume that a program reads from a file and pushes\r\n    each value onto the top of a stack.\r\n  For example, if we are reading 1,024 (2<sup>10</sup>) values from a file and\r\n    pushing them onto the top of a stack; further assume that the stack is \r\n    initially constructed to refer to an array of length 1.\r\n  <p>\r\n  If we expand the length by just one, we will have to call the expand method\r\n    999 times.\r\n  The first time requires copying 1 value, the next time 2 values, the next \r\n    time 3 values, ... and the final time 1023 values.\r\n  The total amount of copying is 1+2+...+1023 which is 523,776 copying\r\n    operations!\r\n  The general formula for 1+2+...+n is n(n+1)/2; os the number of copying\r\n    operations grows as the square of the number of values we push.\r\n  <p>\r\n  Now let's analyze the doubling approach. \r\n  The first time requires copying 1 value, the next time 2 values, the next\r\n    time 4 values, and the final time 512 values (when increasing the array\r\n    from length 512 to length 1024).\r\n  The total amount of copying is 1+2+4+8+16+32+64+128+256+512 which is only\r\n    1,023 copying operations (over 500 times fewer than the previous method):\r\n    so, if this method takes .1 second, the previous method almost takes a\r\n    minute!\r\n  If n is some power of 2, the formula for 1+2+4+...+n is 2n-1.\r\n  <p>\r\n  Thus, to push n values onto the top of a stack we must double the array only\r\n    about Log<sub>2</sub>(n) times; note that logarithm (base 2) is a very\r\n    slowly growing function: Log<sub>2</sub>(1,000) is 10;\r\n    Log<sub>2</sub>(1,000,000) is 20; and Log<sub>2</sub>(1,000,000,000) is 30.\r\n  <p>\r\n  Of course, in the first approach, the array is always exactly the right size.\r\n  With the second approach, we would have to call some kind of <b>trim</b>\r\n    method to reduce it to exactly the right size.\r\n  This would require copying every value again.\r\n  In the previous example, it would require a total of 2,047 copy operations\r\n    (still over 250 times faster than the first method).\r\n  The exact formula is n+2<sup>Log<sub>2</sub>(n)+1</sup> -1.\r\n  <p>\r\n  The bigger the data file, the more efficient the doubling method is.\r\n  For 1,000,000 values, the first method requires about 500,000,000,000\r\n   (500 billion) copy operations; the doubling method requires only about\r\n    3,000,000 (three millon) copy operations: that makes it 166,666 times\r\n    faster).\r\n  <p>\r\n  When we formally study the Analysis of Algorithms we will perform more\r\n    analyses like these for methods defined in collection classes.\r\n </tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Write a method namd <b>countOccurence</b> that counts and returns how\r\n      often a value (specified by an <b>int</b> parameter) occurs in an array\r\n      (specified by an <b>int[]</b> parameter).\r\n<p>\r\n<li>Explain why the following code does not always compute the correct result;\r\n    under what circumstances does it compute the correct result?\r\n<pre><b>  public static boolean all0(int[] a)\r\n{\r\n  for (int i=0; i&lt;a.length; i++)\r\n    if (a[i] != 0)\r\n      return false;\r\n    else\r\n      return true;\r\n}</b></pre>\r\n\r\n<p>\r\n<li>What happens to array <b>a</b> if <b>swap</b> is called with the same value\r\n      for <b>i</b> and <b>j</b>: e.g.,<b>swap(3,3,a);</b>?\r\n<p>\r\n<li>Write a method name <b>reverse</b> which reverses the order of it\r\n      <b>int</b> array parameter (calling <b>reverse</b> twice results in the\r\n      original array ordering).\r\n<p>\r\n<li>Write a method name <b>circularShiftLeft</b> which shifts every value in\r\n     its <b>int[]</b> parameter to the left by one index, placing the value at\r\n     index <b>0</b> into the last index.\r\n<p>\r\n<li>Write a method name <b>circularShiftRight</b> which shifts every value in\r\n     its <b>int[]</b> parameter to the right by one index, placing the value at\r\n     the last index into index <b>0</b>.\r\n<p>\r\n<li>Write a <b>swap</b> method for arrays of <b>String</b>.\r\n    Draw a method call and its call frame to illustrate what happens when the\r\n     first and last index values are swapped (<b>swap(0,s.length-1,s)</b>).\r\n<p>\r\n<li>After class one day, a very clever student <!--, (Avi Gavlovski)--->\r\n      showed me the following code as an alternative to the <b>increasing</b>\r\n      method discussed above.\r\n    He asserted that it worked correctly.\r\n    Note that this code inverts the loop continuation and <b>if</b> test.\r\n    I blanched, because the <b>for</b> loop looks very different from the ones\r\n      that I am used to analyzing; but then I went ahead and analyzed the code\r\n      (by rapidly doing some hand simulations in my brain).\r\n    Does this code always, sometimes, or never work correctly?\r\n    Hint, try some hand simulation on normal and boundary cases. \r\n    If it only works sometimes, for which arrays does it produce correct and\r\n      incorrect answers.\r\n   <pre><b>  public static boolean increasing(int[] a)\r\n  {\r\n    for (int i=0; a[i]<=a[i+1]; i++)\r\n      if (i+1 == a.length-1)\r\n        return true;\r\n\r\n    return false;\r\n  }</b></pre>\r\n<p>\r\n<li>Assume we declare <b>SimpleStack s = new SimpleStack();</b>.\r\n    Does Java allow us to write, <b>s.push(null);</b>\r\n    If it is not allowed, explain why not; if it is allowed, explain what\r\n      happens.\r\n<p>\r\n<li>Assume we declare <b>SimpleStack s = new SimpleStack();</b> and push some\r\n      values onto the stack.\r\n    Does Java allow us to write, <b>System.out.println( s.pop() );</b>\r\n    If it is not allowed, explain why not; if it is allowed, explain what\r\n      happens.\r\n<p>\r\n<li>Assume we declare <b>SimpleStack s = new SimpleStack();</b> and push some\r\n      values onto the stack.\r\n    <ul>\r\n    <li> Explain why we cannot use the following cascaded method calls to\r\n           empty the stack and push two values onto it:\r\n           <b>s.makeEmpty().push(\"a\").push(\"b\");</b>\r\n         What changes could we make to these methods to allow such a cascaded\r\n           method call.\r\n    <li> Explain why we cannot use the following cascaded method calls to\r\n           retrieve the value under the top of the stack:\r\n           <b>Object o = s.pop().pop();</b>\r\n    </ul>\r\n<p>\r\n<li>Explain why the following implementation of the <b>pop</b> method\r\n    works correctly; notice that it use a <b>try</b>-<b>finally</b>\r\n    combination with no local variable <b>answer</b>.\r\n\r\n  <b><pre>  public Object pop () throws IllegalStateException\r\n  {\r\n    if ( isEmpty() )\r\n      throw new IllegalStateException\r\n        (\"SimpleStack pop: Stack is empty\");\r\n    \r\n    try{\r\n      return stack[top];\r\n    }finally{\r\n      stack[top] = null;\r\n      top--;                       //or just stack[top--] = null;\r\n    }\r\n  }</b></pre>\r\n<p>\r\n<li>Copying the form of the <b>equals</b> method in the <b>Rational</b> class\r\n      (see the bottom of the <a href=\"#Casting\">Reference Casting</a> section),\r\n    write an <b>equals</b> method for <b>SimpleStack</b> or <b>SimpleQueue</b>\r\n    Include all state criteria that you think is relevant.\r\n<p>\r\n<li>How could we change the <b>SimpleQueue</b> class to disallow enqueueing\r\n     <b>null</b> references, either by not modifying the array and returning\r\n     immediately, or by throwing an <b>IllegalArgumentException</b>.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}