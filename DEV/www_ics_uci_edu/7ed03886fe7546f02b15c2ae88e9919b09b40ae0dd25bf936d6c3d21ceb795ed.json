{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/modelinmvc/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Model Classes in the MVC Pattern</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Model Classes in the MVC Pattern</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will learn little new Java, but we will explore the\r\n    various classes that make up a pattern for writing applications controlled\r\n    by Graphic User Interfaces (GUIs).\r\n  The pattern is named Model-View-Controller (MVC), and it consists of writing\r\n    an application as three main classes, with each implementing one aspect of\r\n    the GUI.\r\n  Objects constructed from these three classes coordinate their behavior to\r\n    accomplish the goal of the application.\r\n  <p>\r\n  In this lecture we will focus on writing Model classes and discuss two simple\r\n    GUI applications: the first allows the user to experiment with combining\r\n    various strengths of the colors Red, Green, and Blue, when designing\r\n    backgrounds for HTML pages; the second uses an array to simulate any\r\n    number of balls bouncing in a bounded box.\r\n  You can download the <a href=\"../../programs/colorcalculator.zip\">\r\n     Color Calculator</a> and\r\n     <a href=\"../../programs/bouncingballs.zip\">\r\n     BouncingBalls</a>\r\n     GUI applications, unzip and run them, and examine any or all of their\r\n     classes; again, we will focus on ther Model classes in these\r\n     applications.\r\n  <p>\r\n  In upcoming programming assignments, I will supply the View and Controller\r\n    classes, and you will write a Model class that interacts with them.\r\n  Later in the semester, we will return to these programs to examine their\r\n    View and Controller classes in detail. \r\n  In the last assignment for the semester, I will supply the Model class and\r\n    you will write the View and Controller classes for a program.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- The MVC Patterns -->\r\n\r\n<a name=\"mvcPattern\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The MVC Pattern</b></td>\r\n<td width =\"80%\">\r\n  Programming patterns are good ideas (something bigger than code) that can be\r\n     used over and over again in programming projects.\r\n  The MVC pattern is a good way to think about writing all GUI applications:\r\n    it separates the application into three main classes that interact with \r\n    each other to coordinate the entire application.\r\n  <ul>\r\n    <li><b>Model</b>: This class is the bridge between the control and the\r\n          view.\r\n        The user activates a control, which calls a method in the model to tell\r\n           it to change state; after it does so, it notifies the view that its\r\n           state has changed (at which point the view calls other methods in\r\n           the model that supply it with the information it displays).\r\n        The model initiates no actions: it accepts commands from the controller\r\n           and processes them.\r\n        One can use the same model with many different view/controller classes:\r\n          one might allow the user a much easier way to interact with the\r\n          application.\r\n    <p>\r\n    <li><b>View</b>: This class coordinates the appearance of the GUI.\r\n        It decides where all the controls and displays go (labels, text fields,\r\n           buttons, etc.)\r\n        When notified by the model that the model has changed its state, the\r\n          view redisplays itself by calling methods in the model that return\r\n          all the information that the view must display.\r\n        A view class is typically long and boring from a programming\r\n           perspective, because it contains lots of specifics about how the GUI\r\n           looks (things like fonts, sizes, foreground/background colors, and\r\n           the placement of its components requires lots of details).\r\n        Writing one involves understanding lots of classes from the standard\r\n          Java library and inheritance.\r\n    <p>\r\n    <li><b>Controller</b>: This class collects together all the controls in the\r\n          GUI.\r\n        Whenever the user activates a control, it calls a method in the Model\r\n          to tell it to change its state appropriately.\r\n        The <i>listeners</i> specified in the Controller are complicated (but\r\n          small) chunks of Java code that detect an action by the user and call\r\n          the method in the Model that takes care of that action.\r\n        Writing controllers involves understanding lots of classes from the\r\n          standard Java library and inheritance.\r\n  </ul>\r\n  Using the MVC pattern for a tiny GUI application is overkill: it would\r\n    probably be harder to understand a GUI written this way, compared to\r\n     writing it as one big class that has all the necessary code.\r\n  But as GUI applications get even a bit bigger, partitioning their code into\r\n    these three classes allows us to keep the complexity of each class small\r\n    enough to manage easily (remember: divide and conquer).\r\n  Such a division also makes testing and debugging easier, as well as adding\r\n    new features: to do so, we typically edit just one of these classes, or\r\n    make small related changes in all three.\r\n  These classes each encapsulate a different aspect of the GUI; when\r\n    modifying code we start by asking ourselves what aspect do we need to\r\n    change.\r\n  Even relatively small GUI applications, like the ones that we will study this\r\n    semester, will be easier to understand if they follow the MVC pattern\r\n    (once you get some experience using this pattern).\r\n  <p>\r\n  Finally, a tiny <b>main</b> method in the <b>Application</b> class\r\n    coordinates this pattern by creating objects from each of these three\r\n    classes, and then calling some special methods in each object to allow it\r\n    to access the other objects it needs to call methods on.\r\n  The <b>main</b> method then starts the GUI and disappears: the GUI stays\r\n    around even after the <b>main</b> method has terminated.\r\n  The <b>main</b> body is typically under a dozen lines of code, and every\r\n    <b>main</b> method controlling an application written via the MVC pattern\r\n    looks similar to every other one.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Color Calculator -->\r\n\r\n<a name=\"ColorCalculator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Color Calculator</b></td>\r\n<td width =\"80%\">\r\n  The Color Calculator application is implemented using the\r\n    Model-View-Controller pattern.\r\n  It allows us to see a color (and its hexadecimal value) as we change its red,\r\n    green, and blue components in the range [0..255].\r\n  We can change each component by directly entering a legal value into its\r\n    text field (each is labeled above by the name of a color), or by pressing a\r\n    button to increment or decrement its current value.\r\n  It shows a swatch of the resulting color, along with its hex value (which we\r\n    can use directly in HTML to specify a background or foreground color).\r\n  For a swatch to be shown, each color component must store/display a legal\r\n    value in the range [0..255].\r\n  <p>\r\n  The view is split: on the left are some labels (Red, Green, and Blue), some\r\n    text fields that display the current value for the intensity of each color\r\n    (they are editable: the user can also type a value directly into them), and\r\n    increment/decrement buttons (labeled +10 and -10).\r\n  On the right is a color swatch (used when all the intensity values for the\r\n    colors display a legal value), and a hex value of the color currently being\r\n    shown (or the word <b>unknown</b>, if there is no swatch being displayed.\r\n  <p>\r\n  Here is a screen shot of this application running.\r\n  You should download and run the <a href=\"../../programs/colorcalculator.zip\">\r\n     Color Calculator</a> now, experimenting with it by entering text and\r\n    pressing its buttons.\r\n  <p>\r\n  <img src=\"images/colorcalculator.gif\"></image>\r\n  <p>\r\n  The controller has three editable text fields (one for each color) and six\r\n    buttons (two to the right of each color: one to increment the color's\r\n    value by 10 and one to decrement its value by 10).\r\n  <p>\r\n  The model stores (in instance variables) the intensity of each of the colors\r\n    as references to <b>ModularCounter</b> values.\r\n  If an instance variable stores <b>null</b>, it denotes that the intensity of\r\n    that color has not yet been entered correctly.\r\n  It also stores a reference to the view, so it can call its <b>update</b>\r\n    method (see the <b>changeColorViaTextField</b> and\r\n    <b>changeColorViaButton</b> methods) whenever the user changes the state of\r\n    the model by entering a new intensity or incrementing/decrementing the\r\n    intensity by pressing one of the buttons.\r\n  <p>\r\n  When a textfield conrol is activated (either because the user presses\r\n    \"enter\" after entering text there, or because the user moves to another\r\n    control after entering text there) it calls the\r\n    <b>changeColorViaTextField</b> method in the Model class.\r\n  This method is passed, as <b>String</b>s, both the color that was activated\r\n    and the information that was entered in the box (it is supposed to be\r\n    an intensity in the range [0..255]): if the intensity </b>String</b> can be\r\n    parsed as an <b>int</b> in this range, the instance variables storing that\r\n    color's intensity is reset to  that value; otherwise it is reset to\r\n    <b>null</b>. \r\n  In either case, the model tells the view to update itself afterwards.\r\n  <p>\r\n  When a button control is activated (because it is pressed), it calls the\r\n    <b>changeColorViaButton</b> method in the Model class.\r\n  This method is passed, as a <b>String</b>, the color that was activated, and\r\n   as an <b>int</b>, the change (either <b>+10</b> or <b>-10</b>, depending on\r\n   which button was pressed): if the instance variable storing the intensity of\r\n   this color is non-<b>null</b>, it is incremented (or decremented)\r\n   appropriately; otherwise it remains <b>null</b>.\r\n  In either case, the model tells the view to update itself afterwards.\r\n  <p>\r\n  Whenever a button is pressed, the cursor is moved to a new textfield, or a\r\n    \"enter\" is pressed in a textfield, the controller displays a trace message\r\n    inside the console window; the console is NOT used for input/output in \r\n    GUIs, but is often used to help debug GUIs.\r\n  The message includes a description of what happens and the parameters to be\r\n    sent to the model method that is subsequently called.\r\n  <p>\r\n  Whenever the view's <b>update</b> method is called, it calls the\r\n    <b>getRed</b>, <b>getGreen</b>, and  <b>getBlue</b> accessor/query\r\n    methods in the model: it then displays these values in each textbox.\r\n  If all are legal values, it also displays a swatch of color and calls\r\n    the <b>getHex</b> accessor/query method in the model: it then displays\r\n    this value beneath the swatch.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Package -->\r\n\r\n<a name=\"Package\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Package Access</b></td>\r\n<td width =\"80%\">\r\n  Before we explore the actual definitions in the <b>Model</b> class in the\r\n    <b>colorCalculator</b> package, we will learn another access modifier\r\n   (which is frequently used there).\r\n  Recall that the EBNF for access modifiers (so far, we will add more later)\r\n    is\r\n  <pre>  <i>access-modifiers</i> <= [<b>public</b>|<b>private</b>] [<b>static</b>] [<b>final</b>]</pre>\r\n  We have always specified either <b>public</b> or <b>private</b>, but in fact\r\n    these alternatives appear in an option, so we can discard them.\r\n  If we do discard the option, writing neither <b>public</b> nor\r\n    <b>private</b>, we say that the resulting access is <b>package-friendly</b>\r\n    or just <b>package</b>.\r\n  When access is package-friendly, Java considers it to be <b>public</b> to all\r\n    classes defined in its package, but <b>private</b> to all classes defined\r\n    in other packages.\r\n  So, it is a bit more restrictive than making the memember <b>public</b> (it\r\n    isn't <b>public</b> in other classes), but less restrictive than making it\r\n    <b>private</b> (it isn't <b>private</b> in classes defined in the same\r\n    package).\r\n  <p>\r\n  The application being described contains the classes <b>Model</b>,\r\n    <b>View</b> and <b>Controller</b>, all in the <b>colorCalculator</b>\r\n    package.\r\n  Some members are declared <b>private</b> (e.g., all instance variables and\r\n    helper methods), others are declared <b>public</b> (e.g., all constructors,\r\n    which <b>new</b> uses in the <b>Application</b> class, which is in the\r\n    anonymous package), and some are package-friendly (e.g., the <b>Model</b>\r\n    methods called by the controller and the <b>update</b> method in the\r\n    <b>View</b> class, called in the <b>Model</b> class.\r\n  <p>\r\n  Recall that when a class is defined in a package, it does not need to\r\n    import other classes from that same package: the Java compiler\r\n    automatically imports them.\r\n  It is exactly these implicitly-imported classes that can access\r\n    package-friendly members.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Color Definitions -->\r\n\r\n<a name=\"ColorDefs\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Color Calculator Model Definitions</b></td>\r\n<td width =\"80%\">\r\nNow we will examine in detail the <b>Model</b> class defined in the\r\n  <b>colorCalculator</b> package.\r\nIt defines the following instance variables.\r\n<b><pre>  private View view;  \r\n  private ModularCounter red,green,blue;</pre></b>\r\nThe color instance variables initially store <b>null</b>, meaning\r\n  they have no values yet (they are first assigned values via the\r\n  <b>changeColorViaTextField</b> method, described below).\r\nThe <b>view</b> instance variable is reinitialized when the <b>main</b>\r\n  method in the <b>Application</b> class constructs an object from this\r\n  class and calls <b>addView</b> with it as an argument.\r\n<b><pre>  public void addView (View v)\r\n  {view = v;}</pre></b>\r\nRecall that this method must be <b>public</b>, because the <b>Application</b>\r\n  class calling it is defined in the anonymous package, not\r\n  <b>colorCalculator</b>.\r\n<p>\r\nThe constructor in the <b>Model</b> class is simply\r\n<b><pre>  public Model ()\r\n  {}</pre></b>\r\nwhich does nothing: all color instance variables in this class are correctly\r\n  initialized when they are declared.\r\n<p>\r\nThe four main accessor/query methods are\r\n<b><pre>\r\n  int getRed()\r\n  {return (red == null ? -1 : red.getValue());}\r\n    \r\n  int getGreen()\r\n  {return (green == null ? -1 : green.getValue());}\r\n    \r\n  int getBlue()\r\n  {return (blue == null ? -1 : blue.getValue());}\r\n\r\n  String getHex()\r\n  {return gh(getRed()) + gh(getGreen()) + gh(getBlue());}</pre></b>\r\nThese methods are all defined to be package-friendy, and thus are callable only\r\n   by methods in other classes defined in the <b>colorCalculator</b> package\r\n   (in this case, by methods in the <b>View</b> class).\r\nThe <b>View</b> class expects the first three methods to return <b>int</b>\r\n   values, with <b>-1</b> meaning no definition: so these methods examine the\r\n   appropriate instance variable to supply the correct information.\r\nThe <b>getHex</b> method calls the <b>private gh</b> helper method three times,\r\n  one for each color, catenating their results together; it is called only\r\n  if the other three methods return non <b>-1</b> values.\r\n<p>\r\nNext, we will examine the two main mutators/commands, called from the\r\n  controller.\r\n<b><pre>  void changeColorViaTextField(String color, String intensity)\r\n  {\r\n    if (color.equals(\"Red\"))\r\n      red = null;\r\n    else if (color.equals(\"Green\"))\r\n      green = null;\r\n    else if (color.equals(\"Blue\"))\r\n      blue = null;\r\n    else\r\n      return;  //Not a good color!\r\n      \r\n    try {\r\n      int i = Integer.parseInt(intensity);\r\n      if (color.equals(\"Red\"))\r\n\tred = new ModularCounter(i,256);\r\n      if (color.equals(\"Green\"))\r\n\tgreen = new ModularCounter(i,256);;\r\n      if (color.equals(\"Blue\"))\r\n\tblue = new ModularCounter(i,256);;\r\n    }catch (Exception e) {/*don't set value; use null one*/} \r\n    \r\n    System.out.println(\"State: \" + this +\"\\n\");\r\n    if (view != null)    //In case Model's main (not Application's) is running\r\n      view.update();\r\n  }</pre></b>\r\n  Each call of this method updates one of the color instance variables.\r\n  Note that the identifier <b>Exception</b> is the name of a class that\r\n    matches any exception thrown in the method.\r\n<ul>\r\n  <li>The first cascaded <b>if</b> statement uses the <b>color</b> parameter\r\n        to store <b>null</b> into the instance variable of the color whose\r\n        textfield was modified.\r\n      In this way, if the value entered is bad (either not a number, or not\r\n        in the range [0..255])) the instance variable now stores the correct\r\n        result.\r\n  <li>The <b>try</b> block first tries to <b>parse</b> the <b>intensity</b>\r\n        parameter; if it throws the <b>NumberFormatException</b> it skips the\r\n        code storing into the instance variable, so it still stores\r\n        <b>null</b>.\r\n      If it doesn't throw an exception, the instance variable is assigned a new\r\n        <b>ModularCounter</b>; but again, if the <b>intensity</b> is not in the\r\n        range [0..255] this constructor throws <b>IllegalArgumentException</b>\r\n        and the result is that the instance variable still stores <b>null</b>;\r\n        but, if the values is in range, then the instance variable stores a\r\n        reference to a <b>ModularCounter</b> object with the correct value.\r\n  <li>Finally, regardless of how the instance variable was updated, this method\r\n        prints the state in the console window and calls <b>update</b>, which\r\n        updates the GUI (calling the accessors/queueris discussed above to\r\n        determine what to display).\r\n</ul> \r\nNext we examine the method called when buttons are pressed in the GUI.\r\n<b><pre>  void changeColorViaButton(String color, int amount)\r\n  {\r\n    if (color.equals(\"Red\")        && red   != null)\r\n      red.update(amount);\r\n    else if (color.equals(\"Green\") && green != null)\r\n      green.update(amount);\r\n    else if (color.equals(\"Blue\")  && blue  != null)\r\n      blue.update(amount);\r\n    else\r\n      return;  //Not a good color!\r\n\r\n    System.out.println(\"State: \" + this +\"\\n\");\r\n    if (view != null)    //In case Model's main (not Application's) is running\r\n      view.update();\r\n  }</pre></b>\r\nThis method is a bit shorter, less complex, and easier to understand.\r\n<ul>\r\n  <li>The cascaded <b>if</b> statement uses the <b>color</b> parameter to\r\n        determine whether an instance variable can be updated: it must already\r\n        store a correct value.\r\n      If so, the value stored in the <b>ModularCounter</b> object is\r\n        incremented (or decremented: <b>udpate</b> does one or the other)\r\n        by the value stored in the parameter <b>amount</b>.\r\n  <li>Again, regardless of how the instance variable was updated, this method\r\n        prints the state in the console window and calls <b>update</b>, which\r\n        updates the GUI (calling the accessors/queueris discussed above to\r\n        determine what to display).\r\n</ul> \r\nFinally, the <b>toString</b> method follows the standard form\r\nThis method must be declared <b>public</b> (we will learn why when we\r\n  discuss inheritance).\r\n<b><pre>  public String toString()\r\n  {return \"Model[red=\" + red + \", green=\" + green + \", blue=\" + blue +\"]\";}</pre></b>\r\nNote that it is automatically called in \r\n  <b>System.out.println(\"State: \" + this +\"\\n\");</b>, as if we had written\r\n  <b>System.out.println(\"State: \" + this.toString() +\"\\n\");</b> or just\r\n  <b>System.out.println(\"State: \" + toString() +\"\\n\");</b>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Debugging -->\r\n\r\n<a name=\"Debugging\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Model Debugging</b></td>\r\n<td width =\"80%\">\r\n  In GUI applications, we often use the console window to display information\r\n    useful for debugging purposes.\r\n  In the <b>Controller</b> class, every user action displays itself in the\r\n    console window.\r\n  For example, pressing the <b>Red +10</b> button prints the message\r\n    <b>Debug-Controller: Color button +10/-10 button pressed (Red,10)</b>\r\n    in the console window.\r\n  In this way we can determine whether we are activating the controls\r\n    correctly.\r\n  <p>\r\n  In the <b>Model</b> class, every time one of its methods calls\r\n    <b>view.update();</b> it first prints the state of the model (the three\r\n    important instance variables) in the console window.\r\n  For example, if the first thing we do is to enter <b>10</b> in the <b>Red</b>\r\n    textfield, the model prints\r\n    <b>State: Model[red=10(mod 256), green=null, blue=null]</b>\r\n    in the console window.\r\n  In this way, we can display a textual representation of the state of the\r\n    <b>Model</b> class in a scrollable window, so we can examine the entire\r\n    history of our interaction with the GUI and what changes it made for each\r\n    one.\r\n  <p>\r\n  There is another interesting way to test a <b>Model</b> class, even without\r\n    having access to its <b>View</b> and <b>Controller</b> classes (which may\r\n    not even be written when the <b>Model</b> is finished: we'd certainly like\r\n    to test each class independently from the others, as soon as it is\r\n    written).\r\n  We can write a driver for it, similar to the other drivers that test classes.\r\n  But, in this case we will actually write the driver as a <b>main</b> method\r\n    in the class itself; we could also have done so in the other classes that \r\n    we examined, but I delayed introducing this material until we were a bit\r\n    more sophisticated about writing classes.\r\n  <p>\r\n  Recall that every class is allowed to define a special <b>main</b> method.\r\n  In this class it appears as\r\n  <b><pre>\r\n  public static void main(String[] args)\r\n  {\r\n    Model m = new Model();\r\n    System.out.println(\"State: \"+ m +\"\\n\");\r\n\t  \r\n    for (;;)\r\n      try {\r\n\tSystem.out.println(\"Menu\");\r\n        System.out.println(\"  t - changeColorViaTextField\");\r\n        System.out.println(\"  b - changeColorViaButton\");\r\n        System.out.println(\"  ? - view all accessors\");\r\n        System.out.println(\"  q - quit\");\r\n        char selection = Prompt.forChar(\"Enter Command\",\"tb?q\");\r\n\r\n        if (selection == 't') {\r\n          String color     = Prompt.forString(\"  Enter color    \");\r\n          String intensity = Prompt.forString(\"  Enter intensity\");\r\n          m.changeColorViaTextField(color,intensity);\r\n          \r\n        }else if (selection == 'b') {\r\n          String color  = Prompt.forString(\"  Enter color \");\r\n          int    amount = Prompt.forInt   (\"  Enter amount\");\r\n          m.changeColorViaButton(color,amount);\r\n       \r\n        }else if (selection == '?') {\r\n           System.out.println(\"  getRed   = \" + m.getRed());\r\n           System.out.println(\"  getGreen = \" + m.getGreen());\r\n           System.out.println(\"  getBlue  = \" + m.getBlue());\r\n           if (m.getRed() == -1 || m.getGreen() == -1 || m.getBlue() == -1)\r\n             System.out.println(\"  No getHex because some colors missing\");\r\n           else\r\n             System.out.println(\"  getHex   = \" + m.getHex());\r\n           System.out.println();\r\n\r\n        }else if (selection == 'q')\r\n          break;\r\n        \r\n        else\r\n          System.out.println(\"\\\"\"+selection+\"\\\" is unknown command\");\r\n\r\n      }catch(Exception e) {\r\n        System.out.println(\"  Exception Caught/Handled: \"+e.getMessage());\r\n      }\r\n  }</pre></b>\r\nThis method first constructs an object from the <b>Model</b> class.\r\nThen, as with all drivers, it displays a menu of options, prompts the\r\n  user to call a method, prompts the user for whatever (if any) arguments are\r\n  needed to call that method, and calls the method (which, as you will recall,\r\n  prints the state of the model whenever its state changes).\r\nThus, prompting for the menu entry and arguments takes the place of activating\r\n  a control.\r\n<p>\r\nTo direct Java to execute this <b>main</b> method, instead of the one in\r\n  the <b>Application</b> class, change the <b>Java Target</b> so that\r\n  the <b>Main Class</b> text field contains <b>colorCalculator.Model</b>.\r\nThis was discussed in more detail in the general lecture on\r\n    <a href=\"../writingclasses/lecture.html#mainMethod\">\r\n    <b>main</b> methods</a>.\r\nRecall that because <b>Application</b> is in the anonymous package, it\r\n  is not prefaced here by any package name; but since <b>Model</b> is\r\n  in the <b>colorCalculator</b> package, it must be prefaced by this name.\r\nHere is a short session with this driver\r\n<b><pre>State: Model[red=null, green=null, blue=null]\r\n\r\nMenu\r\n  t - changeColorViaTextField\r\n  b - changeColorViaButton\r\n  ? - view all accessors\r\n  q - quit\r\nEnter Command[tb?q]: t\r\n  Enter color    : Red\r\n  Enter intensity: 100\r\nState: Model[red=100(mod 256), green=null, blue=null]\r\n\r\nMenu\r\n  t - changeColorViaTextField\r\n  b - changeColorViaButton\r\n  ? - view all accessors\r\n  q - quit\r\nEnter Command[tb?q]: b\r\n  Enter color : Red\r\n  Enter amount: -10\r\nState: Model[red=90(mod 256), green=null, blue=null]\r\n\r\nMenu\r\n  t - changeColorViaTextField\r\n  b - changeColorViaButton\r\n  ? - view all accessors\r\n  q - quit\r\nEnter Command[tb?q]: ?\r\n  getRed   = 90\r\n  getGreen = -1\r\n  getBlue  = -1\r\n  No getHex because some colors missing</pre></b>\r\nFinally, the reason each mutator/command includes\r\n<b><pre>  if (view != null)    //In case Model's main (not Application's) is running\r\n    view.update();\r\n</pre></b>\r\ninstead of just calling <b>view.update()</b> is that in the case of running\r\n  <b>main</b> from the <b>Model</b> class itself, <b>view</b> is never set to\r\n  refer to an object: it stores its initial value, <b>null</b>.\r\nIf <b>main</b> is run from the <b>Application</b> class, it will always first\r\n  call the <b>setView</b> method appropriately.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Bouncing Balls -->\r\n\r\n<a name=\"Balls\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Bouncing Balls</b></td>\r\n<td width =\"80%\">\r\n  The Bouncing Balls application is also implemented using the\r\n    Model-View-Controller pattern.\r\n  In addition, its <b>Model</b> class uses arrays (and length doubling).\r\n  We can create any number of balls by clicking on its window's screen\r\n   (the array stores them all).\r\n  A ball appears at each clicked location, initialized by a random color (which\r\n   does not change) and a random velocity.\r\n  When balls reach the boundaries of the window, they bounce back into the\r\n    interior.\r\n  <p>\r\n  There is a panel of buttons at the top of the application: there are buttons\r\n    to start and stop the simulation, and there is a button to reset it:\r\n    stop it and remove all the balls (clearing the screen).\r\n  <p>\r\n  Here is a screen shot of this application running.\r\n  You should download and run <a href=\"../../programs/bouncingballs.zip\">\r\n    Bouncing Balls</a> now, experimenting with it by clicking in the window\r\n    and pressing its buttons.\r\n  <p>\r\n  <img src=\"images/bouncingballs.gif\"></image>\r\n  <p>\r\n  The application runs mainly by defining a timer (a kind of control) that\r\n    automatically fires every 100 milliseconds.\r\n  When it fires, it first calls the <b>updateAll</b> method in the <b>Model</b>\r\n    class, which calls the <b>update</b> method on every <b>Ball</b> object in\r\n    the array that <b>Model</b> stores; each <b>Ball</b> object computes its\r\n    new x,y coordinate (based on its current x,y coordinate and it horizontal\r\n    and vertical velocities) including whether it bounces off a wall (if it\r\n    does, it changes its  horizontal or vertical velocity too -to move in the\r\n    opposite direction).\r\n  <p>\r\n  Next the timer calls the <b>displayAll</b> method in the <b>Model</b> class,\r\n    which clears the window and calls the <b>display</b> method on every \r\n    <b>Ball</b> object in the array that <b>Model</b> stores; each <b>Ball</b>\r\n    object  displays itself in the window at its current x,y coordinate.\r\n  The update and display actions happen so quickly that it looks like the\r\n    balls are moving smoothly.\r\n  <p>\r\n  Methods in the <b>Model</b> class are also called whenever the user presses\r\n    the <b>Start</b>, <b>Stop</b>, or <b>Reset</b> button.\r\n  The first two buttons toggle an instance variable that determines if the\r\n    simulation is running: actually, <b>updateAll</b> does nothing if the\r\n    simulation is stopped.\r\n  If <b>Reset</b> is pressed, all current <b>Ball</b> objects are removed from\r\n    the array.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Bouncing Balls Model -->\r\n\r\n<a name=\"BBDefs\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Bouncing Balls Model Definitions</b></td>\r\n<td width =\"80%\">\r\nNow we will examine in detail the <b>Model</b> class defined in the\r\n  <b>bouncingBalls</b> package.\r\nIt defines the following instance variables.\r\n<b><pre> private View view;\r\n    \r\n  private Ball[]     balls;       //Refer to each ball\r\n  private int        used;        //How much of the balls array is used\r\n  private boolean    running;     //Whether updateAll should update balls\r\n  private int        cycleCount;  //Times updateAll called since reset\r\n}</pre></b>\r\nHere <b>used</b> is similar to <b>top</b>/<b>rear</b> when storing the\r\n  <b>stack</b>/<b>queue</b> collections: it stores the number of indexed\r\n  members that are stored in <b>balls</b> (in locations <b>0</b> to\r\n  <b>used-1</b>).\r\nThe <b>Ball</b> class, used to declare the array, is very small.\r\nIt defines just one constructor and three methods\r\n<b><pre>  Ball (int x, int y, int vx, int vy){...}\r\n\r\n  void          update  (Dimension box) {...}\r\n  void          display (Graphics  g)   {...}\r\n  public String toSTring()              {...}</pre></b>\r\nwhich we will be used in the methods defined in the <b>Model</b> class.\r\nNotice that these methods are all defined to be package-friendly (except\r\n  <b>toString</b>, which always must be declared <b>public</b>).\r\n<b>Dimension</b> and <b>Graphics</b> are two classes declared in the standard\r\n  Java library.\r\n<p>\r\nThe <b>view</b> instance variable is reinitialized when the <b>main</b>\r\n  method in the <b>Application</b> class constructs an object from this\r\n  class and calls <b>addView</b> with it as an argument.\r\n<b><pre>  public void addView (View v)\r\n  {view = v;}</pre></b>\r\nRecall that this method must be <b>public</b>, because the <b>Application</b>\r\n  class calling it is defined in the anonymous package, not\r\n  <b>bouncingBalls</b>.\r\n<p>\r\nThe constructor in the <b>Model</b> class is\r\n<b><pre>  public Model ()\r\n  {reset();}</pre></b>\r\nand the definition of <b>reset</b> is\r\n<b><pre>  void reset ()\r\n  {\r\n    running    = false;\r\n    cycleCount = 0;\r\n    used       = 0;\r\n    balls      = new Ball[1];\r\n  }</pre></b>\r\nWhenever a <b>Model</b> object is constructed, it calls <b>reset</b>; also,\r\n  whenever the <b>Reset</b> button is pressed, the controller calls this\r\n  same method, reinitializing these instance variables.\r\nThese methods, and all the others to be discussed in this section, are\r\n  defined to be package-friendy, callable only by methods in other classes\r\n   defined in the <b>bouncingBalls</b> package.\r\n<p>\r\nThe two accessor/query methods are also very simple\r\n<b><pre>  int getCycleCount()\r\n  {return cycleCount;}  \r\n\r\n  int getBallCount()\r\n  {return used;}</pre></b>\r\nLikewise, two more methods (besides <b>reset</b>) that the controller calls\r\n  are very simple.\r\n<b><pre>  void start ()\r\n  {running = true;}\r\n    \r\n  void stop ()\r\n  {running = false;}</pre></b>\r\nEach sets the <b>running</b> instance variables, which is examined only in\r\n  the <b>updateAll</b> method (see below).\r\n<p>\r\nThe first interesting method is called by the controller whenever the user\r\n  clicks somewhere in the window.\r\nIt receives as arguments the x,y coordinate of the click in the window and a\r\n  click count (e.g., 2 means a double click) although this last parameter is\r\n  ignored here.\r\n<b><pre>  void mouseClick(int x, int y, int clickCount)\r\n  { \r\n    if (used == balls.length)\r\n      doubleLength();\r\n    balls[used++] = new Ball(x,y,\r\n                             randomInRange(-10,10), randomInRange(-10,10),\r\n                             randomColor());\r\n  }</pre></b>\r\nThis method puts a new <b>Ball</b> object at the rear of the array,\r\n  doubling its length if there is not enough room.\r\n(We don't discuss this helper method here; it is defined similarly to what we\r\n  have seen.)\r\nThe <b>Ball</b> object is constructed to have a state that is initially the\r\n  same x,y coordinate of the click, horiztontal and vertical velocities that\r\n  are random values in the range [-10..10], and a random color (we will not\r\n  examine these \"random\" helper methods: read them in the actual class\r\n  definition).\r\n<p>\r\nWe have now seen every method called by a user interaction with the controller:\r\n  <b>reset</b>, <b>start</b>, <b>stop</b>, and <b>mouseClick</b>.\r\nNow we focus on the two methods automatically called every 100 milliseconds\r\n  by the controller: <b>updateAll</b> and <b>displayAll</b>\r\n<b><pre>  void updateAll()\r\n  {\r\n    if (!running)\r\n      return;\r\n      \r\n    cycleCount++;\r\n    for (int i=0; i&lt;used; i++)\r\n      balls[i].update(view.getEnclosingBox());\r\n      \r\n    //System.out.println(\"State: \" + this +\"\\n\");\r\n  }</pre></b>\r\nNote that if the instance variable <b>running</b> is <b>false</b>, this\r\n  method returns immediately; otherwise it increments <b>cycleCount</b> and\r\n  just calls the <b>update</b> method on each <b>Ball</b> object it stores\r\n  (telling it the dimensions of the box in which the balls are bouncing:\r\n  information the <b>View</b> class provides).\r\nI have \"commented-out\" the output statement, because it would generate\r\n  too much data in normal circumstances, although at the end of this\r\n  section I show the results of using this output in a very simple simulation.\r\n<p>\r\nSo, this method mostly acts as a dispatcher: when the controller says that it\r\n  is time for the <b>Model</b> to change its state, it iterates over all the\r\n  <b>Ball</b> objects that it stores and instructs each to update its state.\r\nIn this way we have distributed complexity: the <b>Model</b> manages a\r\n  collection of <b>Ball</b> objects; when we do something to the <b>Model</b>,\r\n  it just does it to all the <b>Ball</b>s.\r\n<p>\r\nLikewise for the <b>displayAll</b> method.\r\n<b><pre>  void displayAll(Graphics g)\r\n  {\r\n    for (int i=0; i&lt;used; i++)\r\n      balls[i].display(g);\r\n  }</pre></b>\r\nWhen the controller says that it is time for the <b>Model</b> to (re)display\r\n  itself on a blank window, it iterates over all <b>Ball</b> objects that it\r\n  stores and instructs each to display itself.\r\nEven if we don't understand the details about how a <b>Ball</b> object\r\n  updates/displays itself, we can write code that manages a collection of\r\n   <b>Ball</b> objects.\r\nThe result is that the bodies of all the methods in this model, which produces\r\n  an interesting simulation, are simple.\r\n<p>\r\nNote that there are no calls to <b>view.update()</b> in this class.\r\nThat is because when the timer fires, it automatically calls this\r\n  method, which then calls <b>displayAll</b>.\r\nTechnically then, when a new <b>Ball</b> object is added to the simulation, it\r\n  can take up to 100 milliseconds before it appears in the window.\r\n<p>\r\nFinally, the <b>toString</b> method follows the standard form (with a\r\n  <b>for</b> loop looking much the same as the <b>toString</b> methods in\r\n  collection classes).\r\n<b><pre>  public String toString()\r\n  {\r\n    String answer = \"Model[used=\"+used+\",running=\"+running+\r\n                           \",cycleCount=\"+cycleCount;\r\n    for (int i=0; i&lt;used; i++)\r\n      answer+=\",\\n  balls[\"+i+\"]=\"+balls[i];\r\n    return answer+\"\\n]\";\r\n  }</pre></b>\r\nIf I uncommented the output statement in <b>updateAll</b>, it could trace\r\n  two <b>Ball</b> objects as follows.\r\nNotice for example, that after the 1st cycle, the x,y coordinate of the first\r\n  <b>Ball</b> object has moved from its initial value <b>(76,84)</b> to\r\n  <b>(79,91)</b>, which is what we would expect given <b>vx=3</b> and\r\n  <b>vy=7</b>.\r\n\r\n</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<b><pre>  Debug-Controller: Mouse clicked (1) at (76,84)\r\n  Debug-Controller: Mouse clicked (1) at (251,193)\r\n  Debug-Controller: Start button pressed\r\n  State: Model[used=2,running=true,cycleCount=1,\r\n    balls[0]=Ball[x=79,y=91,vx=3,vy=7,color=java.awt.Color[r=39,g=37,b=151]],\r\n    balls[1]=Ball[x=257,y=203,vx=6,vy=10,color=java.awt.Color[r=102,g=10,b=174]]\r\n  ]\r\n\r\n  State: Model[used=2,running=true,cycleCount=2,\r\n    balls[0]=Ball[x=82,y=98,vx=3,vy=7,color=java.awt.Color[r=39,g=37,b=151]],\r\n    balls[1]=Ball[x=263,y=213,vx=6,vy=10,color=java.awt.Color[r=102,g=10,b=174]]\r\n  ]\r\n\r\n  State: Model[used=2,running=true,cycleCount=3,\r\n    balls[0]=Ball[x=85,y=105,vx=3,vy=7,color=java.awt.Color[r=39,g=37,b=151]],\r\n    balls[1]=Ball[x=269,y=223,vx=6,vy=10,color=java.awt.Color[r=102,g=10,b=174]]\r\n  ]\r\n\r\n  State: Model[used=2,running=true,cycleCount=4,\r\n    balls[0]=Ball[x=88,y=112,vx=3,vy=7,color=java.awt.Color[r=39,g=37,b=151]],\r\n    balls[1]=Ball[x=275,y=233,vx=6,vy=10,color=java.awt.Color[r=102,g=10,b=174]]\r\n  ]</pre></b>\r\n\r\n\r\n<!-- Writing Models -->\r\n\r\n<a name=\"WritingModels\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Writing Models</b></td>\r\n<td width =\"80%\">\r\n  How does one generally think about writing a model class (given a  matching\r\n    controller and view class)?\r\n  As the model, think of yourself sitting at a desk with various telephones:\r\n    one for each method that the controller or viewer might call you on.\r\n  You also have various note-cards on your desk; on which each is written the\r\n    value of one of your instance variables.\r\n  The model's job is to take calls on the phones and update information\r\n    appropriately on the cards.\r\n  <p>\r\n  In the <b>colorCalculator</b> model, you will have a telephone labelled\r\n    <b>changeColorViaButton</b>  (called by the controller when the user\r\n     presses an increment/decrement button) and a telephone labelled\r\n     <b>changeColorViaTextField</b> (called by the controller when the user\r\n     enters text into one of  the color fields).\r\n  When called on the <b>changeColorViaButton</b> phone, you are told the color\r\n    and the amount of the increment/decrement (its parameters); when called on\r\n    the <b>changeColorViaTextField</b> phone, you are told the color and the\r\n    amount (this time the amount is a <b>String</b> that may or may not contain\r\n    a legal integer value: the model has to figure that out).\r\n  In this model, we need three note cards: one each for the amount of red,\r\n     green, and blue in the current color: by using <b>ModularCounter</b>s,\r\n     these values are always in the range [0..255], and we use <b>null</b> to\r\n     mean that the amount of this color has not yet been set.\r\n  Each method call (potentially) changes one of these cards.\r\n  <p>\r\n  There are also phones called by the view, asking for information.\r\n  The <b>getRed</b>, <b>getGreen</b>, <b>getBlue</b> methods are all\r\n    accessors/queries; when called on one of these phones, we tell the caller\r\n    some <b>int</b> value representing the intensity of that color.\r\n  There is also a <b>getHex</b> phone; when called on it, we must compute and\r\n    return a <b>String</b> that stores one integer, written in base 16, that\r\n    represents the red, green, and blue components.\r\n  This value does not need to be stored in its own instance variable: it is\r\n    just computed, as necessary, from the red, green, and blue instance\r\n    variables.\r\n  <p>\r\n  So, model classes don't really initiate their own actions.\r\n  They respond to requests: either requests that originate in the controller\r\n    to change state, or requiests that originate in the view to examine the\r\n    current state.\r\n  Of course, the model does notify the view when its state is changed, causing\r\n    it to call back methods in the model to examine the new state that it\r\n    must redisplay.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\nTo ensure that you understand all the material in this lecture, please solve\r\n  the the announced problems after you read the lecture.\r\n<p>\r\nIf you get stumped on any problem, go back and read the relevant part of the\r\n   lecture.\r\nIf you still have questions, please get help from the Instructor, a CA, a \r\n  Tutor, or any other student.\r\n\r\n<ol> \r\n<li>Suppose that a color field contains a legal value, but the user enters a\r\n      bad one.\r\n    Rewrite the model to redisplay/store the old value that was \r\n      there (right before the wrong one was entered), instead of redisplaying\r\n      the message <b>\"Enter [0,255]</b>, \r\n<p>\r\n<li>What happens if you comment out the call to <b>view.update</b> in the\r\n      <b>changeColorViaButton</b> and/or <b>changeColorViaTextField</b>\r\n       methods.\r\n<p>\r\n<li>Instead of initializing all the colors in the model to <b>null</b>,\r\n      rewrite the model to initialize them all to 0, or all to random numbers\r\n      in the 0 to 255 range.\r\n<p>\r\n<li>In the bouncing balls application, can we eliminate the <b>reset</b> method\r\n       by initializing all the instance variables when they are declared?\r\n<p>\r\n<li>Why are the \"random\" helper methods in <b>bouncingBalls.Model</b> defined\r\n      to be <b>static</b>? Could they be defined non-<b>static</b>?\r\n   Why is the <b>doubleLength</b> helper method defined\r\n      to be non-<b>static</b>? Could it be defined <b>static</b>?\r\n<p>\r\n<li>If we uncomment the output statement in the <b>updateAll</b> method\r\n      in the bouncing ball simulation, why will we never see\r\n      <b>running=false</b>?\r\n<p>\r\n<li>Examine the Javadoc of the <b>Color</b> class in the standard Java library.\r\n    Assume we defined <b>Color a = randomColor(), b = randomColor, c;</b>\r\n    Write code that stores into <b>c</b> a reference to a <b>Color</b> object\r\n      whose red, green, and blue components are the average of <b>a</b>'s\r\n      and <b>b</b>'s color components.\r\n<p>\r\n<li>Rewrite the <b>bouncingBalls.Model</b> class to remove any <b>Ball</b>\r\n      object that is displayed within a distance of 2 from any other\r\n      <b>Ball</b> object.\r\n    Rewrite the <b>bouncingBalls.Model</b> class to fuse any <b>Ball</b>\r\n      object that is displayed within a distance of 2 from any other\r\n      <b>Ball</b> object: fusing means average their velocities and color.\r\n<p>\r\n<li>Rewrite the <b>colorCalculator.Model</b> class to be simpler by using\r\n      use a 3-value array to store the color components.\r\n    Other arrays might be helpful too (try to simplify the code as much\r\n      as possible).\r\n<p>\r\n<li>Why is the <b>public</b> access modifier used for the constructor in the\r\n       <b>Model</b> class?\r\n    Why can't it be package-friendly?\r\n    What change (in another class) would allow it to be defined to be\r\n      package friendly?\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}