{"url": "https://www.ics.uci.edu/~eppstein/261/s13-hw1-answers.txt", "content": "CS 261, Spring 2013, Homework 1 Solutions\n\n1. Suppose that we want to maintain collections of items, and support the following operations:\n- report the number n of items in the collection\n- add an item to the collection\n- report the i'th item in the collection, for an argument i with 0 <= i < n\n- remove the i'th item from the collection, for an argument i with 0 <= i < n\nThe ordering of the items in the collection is arbitrary, and is allowed to change after an addition or removal (for example item that was the 3rd item in a collection prior to removing something else may become the 5th item in the collection afterwards) as long as each index from 0 to n-1 is associated with a unique item.\n\nDescribe how to use one or more arraylists to implement each of these operations. For the purposes of this problem, an arraylist can only perform the following operations:\n- set the item at position i of the arraylist\n- get the item at position i\n- find the length of the arraylist\n- increase the length of the arraylist by one\n- decrease the length of the arraylist by one.\nEach of the operations of your collection data structure should translate into a a constant number of the arraylist operations.\n\nYour answer should include both a description of how the collection is represented, and how the collection operations are to be performed. You may use either pseudocode or English text to describe how to perform each collection operation.\n\nANSWER:\n\nMaintain the collection of items in an arraylist. To report the number of items, return the length of the arraylist. To add an item, add it to the end of the arraylist using the increase and set operations. To report the i'th item, return the result of the arraylist get operation.\n\nThe only tricky operation is the remove operation. To remove the item at position i, find the length L of the arraylist, move the item at position L-1 into position i, and then decrease the length of the arraylist.\n\n\n2. Suppose that we maintain a binary counter as described in class, but with a decrement operation as well as the increment operation that was described. The decrement operation should be the opposite of the increment operation, in that it subtracts one from the binary value stored in this counter.\n\n(a) Describe how to perform the decrement operation in time proportional to the amount of information within the counter that gets changed by the operation.\n\n(b) Does the data structure with both increment and decrement operations still take constant amortized time per operation? If so, provide a potential function for which the amortized time is constant, and explain why it is constant. If not, explain why there does not exist a suitable potential function.\n\nANSWER:\n\n(a) Suppose that the counter is stored in an array C[i]. To subtract one, loop over the positions i=0, i=1, i=2, etc., changing each value in C[i] to the opposite of its previous value, until reaching a position that is changed from 1 to 0; then stop.\n\n(b) Consider a sequence of operations that consists of 2^x increment operations (starting from a zero counter) and then 2^x steps that alternate between decrement and increment operations. The total actual time for this sequence is Theta(x 2^x), and since the total actual time for a sequence cannot exceed the total amortized time, the amortized time per operation must be Omega(x). Since x can be arbitrarily large, the amortized time cannot be constant.\n\n\n3. A stack data structure can be implemented by an arraylist (as described in class), but it can also be implemented by a collection of \"stack node\" objects, each of which has a \"value\" pointer and a \"next\" pointer, as follows:\n\ndef push(stack s, value x):\n    create a new stack node object q\n    q.value = x\n    q.next = s.top\n    s.top = q\n\ndef pop(stack s):\n    x = s.top.value\n    s.top = s.top.next\n\nIn terms of actual time, both of these operations obviously take constant time. Find a potential function Phi for which the amortized time per push is still constant, but for which the amortized time per pop is zero. Explain why the operations have these amortized times for your choice of Phi.\n\nANSWER:\n\nChoose Phi to be the number of items on the stack. Each push takes constant actual time and increases Phi by one, for a total amortized time of constant. Each pop takes constant actual time but decreases Phi by one; the actual time is cancelled by the decrease in the potential function, so the amortized time per pop is zero.\n", "encoding": "ascii"}