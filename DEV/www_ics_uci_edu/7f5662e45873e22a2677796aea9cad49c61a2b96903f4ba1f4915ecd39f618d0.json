{"url": "https://www.ics.uci.edu/~thornton/cs141/CodeExamples/HaskellExamples1.hs", "content": "-- HaskellExamples1.hs\r\n--\r\n-- CompSci 141 / CSE 141 / Informatics 101 Spring 2013\r\n-- Code Example\r\n--\r\n-- A few examples of writing simple Haskell functions, as seen in the first\r\n-- lecture on Haskell.\r\n\r\nmodule HaskellExamples1 where\r\n\r\n\r\n-- This is how you define a constant expression in Haskell, a name that always\r\n-- evaluates to the same value.\r\n--\r\n-- The first line is a \"type signature,\" which we would read as \"zero has type\r\n-- Integer\".  Note that type signatures are almost always optional in Haskell;\r\n-- the compiler will actually infer types automatically from context (and will\r\n-- always infer the most general type it can), though there is value in writing\r\n-- them, because they are a useful form of documentation, and because they\r\n-- provide a fail-safe against our intentions not matching reality (i.e., if\r\n-- we expect the type to be one thing, but it turns out that it can't be, then\r\n-- this means we may have misunderstood the function we were writing).\r\n\r\nzero :: Integer\r\nzero = 0\r\n\r\n\r\n-- Most of the code we write in Haskell will be expressed as functions.  The\r\n-- function below takes an Integer and returns its square.  Notice that the\r\n-- function is written in two parts:\r\n--\r\n-- (1) A type signature, which says that \"square has the type of a function\r\n--     that takes an Integer and returns an Integer\"\r\n-- (2) An \"equation,\" which specifies what the function's result would be,\r\n--     given its parameter.  In this case, there is only one equation because\r\n--     the result is always the same -- given an integer, we want to return\r\n--     that integer multiplied by itself -- though you can write multiple\r\n--     equations to cover different scenarios.\r\n\r\nsquare :: Integer -> Integer\r\nsquare n = n * n\r\n\r\n\r\n-- These functions calculate the value of n! (i.e., the product of all numbers\r\n-- from 1 through n) in a couple of ways.  The first has one equation that\r\n-- contains \"guards,\" which allow us to specify different values to return in\r\n-- different cases.  In this case, we've named the parameter \"n\", and then\r\n-- decide what to do on the basis of whether n is zero or not.  Note, too,\r\n-- that there is no guard specifying what to do when n is negative; that\r\n-- means that this function has no result (i.e., it fails) when given a\r\n-- parameter that is negative.\r\n\r\nfactorial1 :: Integer -> Integer\r\nfactorial1 n\r\n    | n == 0     = 1\r\n    | n > 0      = n * factorial1 (n - 1)\r\n\r\n\r\n-- This second version of factorial instead uses pattern matching to distinguish\r\n-- between the case where the parameter is 0.  Unlike in many programming\r\n-- languages, where the only thing you can say about arguments are a name and\r\n-- (sometimes) a type, Haskell allows you to write \"patterns\" that describe\r\n-- the structure of a parameter.  If the parameter's value matches the pattern,\r\n-- the equation will be chosen (and they're evaluated in the order written).\r\n--\r\n-- So, in this case, if given a parameter of 0, this function returns 1.\r\n-- If given a parameter that is not 0, this function checks if that parameter\r\n-- is greater than 0 -- there's no pattern that does this, so we have to check\r\n-- it with a guard -- and returns the appropriate value if so.\r\n\r\nfactorial2 :: Integer -> Integer\r\nfactorial2 0   = 1\r\nfactorial2 n\r\n\t| n > 0   = n * factorial2 (n - 1)\r\n", "encoding": "ascii"}