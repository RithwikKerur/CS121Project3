{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/for/for.txt", "content": "\t\t\t\tfor Statements\r\n\r\n\r\nPython has a general fo\" loop statement that we use in a variety of programming\r\ncontexts. In this lecture, we will learn and explore how to use a for loop to\r\niterate over characters in a string, integers in a range, and lines in a file\r\n(each line is a string; and we will learn some string methods that are useful\r\nin this context). As we learn about new types in Python (e.g., tuples, lists,\r\nsets, and dicts) we will find that many of them (all of these) allow us to use\r\na for loop to iterate over their values as well.\r\n\r\nFor loops are called definite loops, because when they execute the number of\r\niterations is known and there is a guarantee that the loop will terminate: i.e.,\r\nthey know the amount of data that they will process, so they know the number of\r\niterations they will perform: all the characters in a string; all the numbers\r\nin a range; all the lines in a file.\r\n\r\nIn the next lecture we will study while loops, which are called indefinite\r\nloops: at the time they start they do not know how many iterations they will\r\nperform (and if written incorrectly, they might never terminate: what we call\r\nan infinite loop). While loops use a boolean-condition to determine when to\r\nterminate.\r\n\r\nLoops are powerful constructs. There is little that we've programmed up to\r\nthis point in the course that we couldn't do more easily by hand or with a\r\npocket calculator. But once we know about loops, it is easy to solve problems\r\non the computer that include lots of data, that we could solve only clumsily\r\nwith simpler tools.\r\n\r\nThe EBNF for a for_statement is quite simple to state (compared to the the\r\nrepetition and options in the EBNF for if_statement). Note that like an if\r\nstatement, its first line ends with a : indicating that a block (indented)\r\nfollows. Here is the simplest version of the EBNF for a for statement.\r\n\r\n  for_statement <= for identifier in iterable:\r\n                       block\r\n\r\nNote the block in a for statement is typically called the body of the for loop.\r\nTypically the body will involve some statement(s) that refers to the\r\nidentifier, which is just a name bound to different values in the iterable\r\n(see below).\r\n\r\nThe power of this language feature comes from the many objects in Python that\r\nare classified as iterable objects. For now we will identify three categories\r\nof iterable objects, with many more to come. Much of what we will learn (and \r\nuse) in Python relates to executing for loops on iterable objects.\r\n\r\n  iterable <= str | range | open | ...more later\r\n\r\nSemantically, Python executes a for_statement as follows\r\n\r\n  (1) Evaluate the iterable\r\n  (2) Repeatedly execute block with identifier bound to every successive value\r\n         in the iterable\r\n\r\nWe can describe the semantics of this loop in a bit more detail as follows\r\n\r\n  (1) Evaluate the iterable\r\n  (2) If there is a first value in the iterable, bind identifier to the first\r\n        value and execute block\r\n  (3) If there is a second value in the iterable, bind identifier to the second\r\n        value and execute block\r\n  ....\r\n  (?) When there is a last value in the iterable, bind identifier to the last\r\n        value and execute block, then the loop terminates because there are\r\n        no more values in the iterable\r\n\r\nFinally, we can describe these semantics in a more compact/loop-like way.\r\n\r\n  (1) Evaluate the iterable\r\n  (2) Is there is a(nother) value in the iterable?\r\n        True : bind identifier to the value and execute block\r\n               redo (loop back) to step (2)\r\n        False: terminate the loop: if the for loop is in a block itself,\r\n               execute the statement in the block that comes after the for loop\r\n\r\nWe can think of an iterable object as producing a sequence of values that are\r\nconsumed, one at a time, by the for loop, by binding each value in the sequence\r\nto identifier and then executing block with that value for identifier.\r\n\r\nSo for loops execute 0 or more times: 0 times if the iterable has no values\r\n(for example the empty string, '', which contains 0 characters). Once again 0\r\ntakes a prominent places in programming.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterating over Strings\r\n\r\nLet us start with an example that we know: string objects. When we iterate over\r\na string object, the identifier in the for loop repeatedly takes on the values\r\nof successive/sequential characters in the string: first the character at index\r\n0 (recall indexes for strings start at 0), then the character at index 1, ...,\r\nfinally the character at the last index.  The simple loop\r\n\r\nfor c in 'abc':\r\n    print(c,end='->')  #note argument matching print's end parameter\r\n\r\nproduces the result\r\n\r\n  a->b->c->\r\n\r\nCopy, paste, and run this code in Eclipse. Experiment with all the code in this\r\nlecture. We will now explore most of the interesting aspects of the for loop\r\nin this section (using strings) so it is quite long. The range and open\r\nsections that follow are much shorter, not because they are simpler or less\r\npowerful, but because we will have learned most of what we need to know about\r\nfor loops by seeing how they process strings.\r\n\r\nWe can adapt our trace tables to include for loops too.\r\n\r\nStatement         |  c  | Console   | Explanation\r\n------------------+-----+-----------+---------------------------------------\r\nInitial state     |     |           | Nothing interesting in the intial state\r\nfor c in 'abc':   | 'a' |           | Start loop; bind c to 'a'(1st in iterable)\r\nprint(c,end='->') |     | a->       | print c's value with -> at end\r\n...for c in 'abc':| 'b' |           | Continue loop; bind c to 'b'(next in ...)\r\nprint(c,end='->') |     | a->b->    | print c's value with -> at end\r\n...for c in 'abc':| 'c' |           | Continue loop; bind c to 'c'(next in ...)\r\nprint(c,end='->') |     | a->b->c-> | print c's value with -> at end\r\n...for c in 'abc':|     |           | Terminate loop; no next value in iterable\r\n\r\nHere we preface all loop iterations after the start by ...\r\n\r\nWe can also use a variable to refer to a string object. The script below\r\n\r\ns =  'abc'  \r\nfor c in s:\r\n    print(c,end='->')\r\n\r\nproduces exactly the same output. Think about expressions and what they\r\nevaluate to: the value of a string literal and the value of a name bound to the\r\nsame string literal both evaluate to the same string object.\r\n\r\nNote that there is nothing special about the name c. The great programmer\r\nShakespeare (who wrote some of the greatest scripts) had it right when he said,\r\n\r\n   \"What's in a name? That which we call a rose by any other name would\r\n    smell as sweet.\"\r\n\r\nExamine the following for loop that uses i, not c, for the identifer (and also\r\nuses i in the print statement in its body). Also notice that in this script,\r\nthe for loop is the first statement in a block (of 3 statements), so when the\r\nfor loop terminates, Python will continue executing code in the block that is\r\nthe script, and print more information. Here it prints the value of i AFTER THE\r\nTHE LOOP TERMINATES (still on the same line as the other values printed,\r\nbecause of end='->'); but print(i) specifies no end= so after printing this\r\nvalue it advances to the next line where it prints 'done'. Running this script\r\n\r\nfor i in 'abc':\r\n    print(i,end='->')\r\nprint(i)\r\nprint('done')\r\n\r\nproduces the result\r\n\r\n  a->b->c->c\r\n  done\r\n\r\nExamine the trace table written above to see that the for loop identifier\r\nstores 'c' when the loop terminates, so c is what is (re)printed.\r\n\r\nAlthough it is generally a VERY BAD IDEA to refer to the identifier used in the\r\nfor loop AFTER THE FOR LOOP TERMINATES, Python does allow it. But pragmatic\r\nrules for programming dictage that we should refer to that identifier ONLY\r\nINSIDE THE block THAT IS THE BODY OF ITS for LOOP.\r\n\r\nHere is one more interesting example that illustrates why we should not refer\r\nto the for loop identifier after the loop. Here the same code above, but with\r\nthe loop iterating over and empty (0-character) string.\r\n\r\nfor i in '':\r\n    print(i,end='->')\r\nprint(i)\r\nprint('done')\r\n\r\nWhat happens? Python executes the loop zero times and then raises an exception:\r\nNameError: name 'i' is not defined. Why? The iterable contains no characters,\r\nso the for loop terminates without i every being bound to a value, so when\r\nPython tries to print i's value after the loop, Python must raise an exception.\r\nThe body of the for loop is executed 0 times (another way to say \"is not\r\nexecuted\"), because the string is empty: there is no first character in an\r\nempty string.\r\n\r\nLet's go back to a slightly extended version of the original example, and fix\r\nit, illustrating looping over string slices.\r\n\r\ns =  'abcde'  \r\nfor c in s:\r\n    print(c,end='->')\r\n\r\nproduces the result\r\n\r\n  a->b->c->d->e->\r\n\r\nIt is a bit strange to have that extra -> at the end (leading to nothing).\r\nReally it would make more sense to print '->' only between characters in the\r\nstring, with the last character on the line not followed by \"->'\r\n\r\nSo let's suppose that we specify that we want to write a script that prints\r\nevery character in a string, with the characters SEPARATED by -> (and no -> at\r\nthe end). For this example, we want to print: a->b->c->d->e. This is actually\r\na hard problem to solve perfectly. You might think we could solve it by using\r\nsep instead of end in the code above; a good guess, and something to try, but\r\n\r\ns =  'abcde'  \r\nfor c in s:\r\n    print(c,sep='->')\r\n\r\nproduces the result\r\n\r\n  a\r\n  b\r\n  c\r\n  d\r\n  e\r\n\r\nDo you know why? You should be able to predict this result with your knowledge\r\nof how the print function works and the difference between what the sep and end\r\nparameters control, and what values end defaults to when not specified in a\r\nprint function.\r\n\r\nInstead, we will attempt to solve this problem first by writing the following\r\ncode.\r\n\r\ns =  'abcde'  \r\nprint(s[0],end='')\r\nfor c in s[1:]:\r\n    print('->'+c,end='')  # could also write print('->',c,sep='',end='')\r\n\r\nIn fact, it produces the result we want\r\n\r\n  a->b->c->d->e\r\n\r\nPython prints the first letter; then to execute the for loop it must compute\r\nthe iterable object by the expression s[1:]; recall that this specifies a slice\r\nof string s that contains all characters from index 1 to the end; so here it\r\nevaluates to the string 'bcde'. So Python binds c to each of these values,\r\nprinting -> prefacing each c. Therefore it produces the correct result. \r\n\r\nNote that we need to print 5 letters and four arrows; if each loop prints a\r\nletter and arrow, then there will be the same number of each. But, we need to\r\nprint one more letter than arrow, so we need a print statement outside the\r\nloop (either before, as we showed it, or after).\r\n\r\nThere is a famous problem in computer science called the fence-post problem,\r\nwhich relates to this issue. If we want to build a 30 foot fence with\r\nhorizontal rails that are 3 feet wide, how many rails and fenceposts do we\r\nneed? Here is a picture\r\n\r\n   +---+---+---+---+---+---+---+---+---+---+\r\n   |   |   |   |   |   |   |   |   |   |   |\r\n\r\nMost students just divide 30 by 3 and get 10. And inded we need 10 rails to\r\nspan 30 feet, but the number of fenceposts we need is 11; that might be hard to\r\nsee in the picture above, but it is much simpler to see below, in a 3 foot wide\r\nfence.\r\n\r\n   +---+\r\n   |   |\r\n\r\nObviously we need 2 fenceposts and 1 rail. In fact we always need one more\r\nfencepost than rail. Just as we printed one more letter than arrow separator.\r\n\r\nSo, we are almost done, but not quite. We should think about/test \"strange\"\r\ncases. What would happen if we set s = 'a' (just one character) and ran this\r\nscript? Our script should work correctly in all cases, no matter how many \r\ncharacters are in the string s. Here, because there is one character, the script\r\nshould print that one character and be done: print no -> because with only one\r\ncharacter, there is nothing to separate. Can you predict what will happen?\r\n\r\nWhat happens is that we print the a, the first character in index 0, then we\r\nevaluate s[1:] but for a one character string s, the result here is the empty\r\nstring, so the for loop executes its body 0 times. So the result is this script\r\nprints just a, which is correct.\r\n\r\nNow let's look at an even \"stranger\" case. What would happen if we set s = ''\r\nthe empty string and ran this code? Can you predict what will happen?\r\n\r\nPython will raise an exception when it tries to index s[0] in the first print\r\nfunction.  Because s is the empty string, it contains no characters (there are\r\nno character at any index, not even at index 0). So using 0 as an index forces\r\nPython to raise an exception: IndexError: string index out of range. It raises\r\nthis same exception in the Python interpreter if we write ''[0]. What do we\r\nwant the script to print in this case? We want it to print nothing, because\r\nthere are no characters in the string: it should print neither a character nor\r\na separator.\r\n\r\nHere is one script to solve the problem\r\n\r\ns =  ''  \r\nif s != '':\r\n    print(s[0],end='')\r\n    for c in s[1:]:\r\n        print('->'+c,end='')  # could also write print('->',c,sep='',end='')\r\n\r\nBy using an if statement, we execute the code we wrote before, but only when we\r\nknow s is not the empty string (we could have also written this boolean\r\nexpression as len(s) > 0 and gotten the same behavior). Now the script works\r\ncorrectly for the empty string and strings with 1 or more characters.\r\n\r\nActually, another version of this script that is also correct/equivalent in\r\nexecution is\r\n\r\ns =  ''  \r\nif s != '':\r\n    print(s[0],end='')\r\nfor c in s[1:]:\r\n    print('->'+c,end='')  # could also write print('->',c,sep='',end='')\r\n\r\nInstead of a script with an if statement controlling a print function and a for\r\nloop statement, this code has an if statement controlling only a print function;\r\nthe for loop statement is always executed after the if is finished: but for any\r\nstrings with 0 or 1 characters, the for loop's body is executed 0 times\r\n(because s[1:] is the empty string). \r\n\r\nSo which script is simpler/easier to understand? Some would say the first\r\nbecause the if controls/(groups together) the two statments; some would say the\r\nsecond because the if controls only what it must control. Both perspectives have\r\nmerit. What is most important is that we can prove the two are equivalent. Note\r\nthe first is like [print loop] and the second like [print]loop. We will discuss\r\nprogramming pragmatics throughout the quarter.\r\n\r\nOf course, we should generalize this script (to make testing easier) to prompt\r\nthe user for a string to test, and then do the computation on it.\r\n\r\nimport prompt\r\ns =  prompt.for_string('Enter string to test')  \r\nif s != '':\r\n    print(s[0],end='')\r\n    for c in s[1:]:\r\n        print('->'+c,end='')  # could also write print('->',c,sep='',end='')\r\n\r\n------------------------------\r\n\r\nLet's use a for loop (and an if) to solve another problem: counting how many\r\nvowels are in a string. This script will also include the in operator, which\r\nhere determines whether or not a character is in (one of the characters in) a\r\nstring. Finally, it shows a common idiom of for counting something conditionally\r\nin Python. Here is the script to count and print the number of vowels in any\r\nstring input by the user.\r\n\r\nimport prompt\r\ns =  prompt.for_string('Enter string to test')  \r\ncount = 0\r\nfor c in s:\r\n    if c in 'aeoiu':\r\n         count += 1\r\nprint('There were', count, 'vowels in:', s)\r\n\r\nLet's write a trace table for hand-simulation of this code, using what we know\r\nboth about hand-simulating both for loops and if statements. To save space we\r\nwill omitt the input/output (so no Console column)\r\n\r\nStatement        |   s    | c |count | Explanation\r\n-----------------+--------+---+------+---------------------------------------\r\nInitial state    | 'amen' |   |      | Initialized from prompt\r\ncount = 0        |        |   |   0  | Create and intialize name\r\nfor c in s:      |        |'a'|      | Start loop; bind c to 'a' (1st in s)\r\nif c in 'aeoiu': |        |   |      | True: execute next block\r\ncount += 1       |        |   |   1  | increment count; block/if finished\r\n...for c in s:   |        |'m'|      | Continue loop; bind c to 'm' (2nd in s)\r\nif c in 'aeoiu': |        |   |      | False: skip next block\r\n...for c in s:   |        |'e'|      | Continue loop; bind c to 'e' (3rd in s)\r\nif c in 'aeoiu': |        |   |      | True: execute next block\r\ncount += 1       |        |   |   2  | increment count; block/if finished\r\n...for c in s:   |        |'n'|      | Continue loop; bind c to 'n' (4th in s)\r\nif c in 'aeoiu': |        |   |      | False: skip next block\r\n...for c in s:   |        |   |      | Terminte loop; no next value in s\r\n\r\nAt this point, the script would print the information that it accumulated in the\r\nvariable count: print('There were', count, 'vowels in:', s) prints\r\n\r\n  There were 2 vowels in: amen\r\n\r\nThis computation really belongs in a function, which we could write as follows\r\n(which I slightly generalized to count vowels in both upper- and lower-case).\r\nNotice that the body of the function contains most of the code from the script,\r\nembedded in a function defintion (which we have seen, but not discussed\r\nformally yet).\r\n\r\ndef vowel_count(s : str) -> int:\r\n    count = 0\r\n    for c in s:\r\n        if c in 'aeoiuAEIOU':\r\n             count += 1\r\n    return count\r\n\r\nAfter defining this function, we might call it in the following script\r\n\r\nimport prompt\r\ns =  prompt.for_string('Enter string to test')  \r\nprint('There were', vowel_count(s), 'vowels in:', s)\r\n\r\nWe might also call it in the following context\r\n\r\nimport prompt\r\ns =  prompt.for_string('Enter string to test')  \r\nif vowel_count(s) == len(s):\r\n    print('All vowels!')\r\n\r\nIMPORTANT:\r\n\r\nNote that most functions (whether we write them or find them in a library) do\r\nnot perform input/prompting or output/printing, unless that is their primary\r\npurpose: all the functions in the prompt class and the print function itself.\r\nTypically it is the script that performs these operations, in conjunction with\r\ncalling the function to compute its value.\r\n\r\nA good way to think about a function is that its \"inputs\" come from the\r\narguments matching its parameters and its \"output\" is the result that it\r\nreturns. Note that in both scripts calling the vowel_count function, we prompt\r\nthe user for a string (s) and then pass it (use it as an argument) when calling\r\nthe vowel_count function. In the first script we call vowel_count in a print\r\nfunction to print its value: in the second script we call vowel_count to\r\ncontrol whether or not another message is printed.\r\n\r\nBut vowel_count itself does no prompting or printing.\r\n\r\nIf we prompt or print a value in the function, we lose versatility. Let the\r\ncode calling the function determine what informtion to give it and what to do\r\nwith the  resulting value (printing it for using it in some other context).\r\nLet the function be simple and useful in its form.\r\n\r\nHere is one final similar function for computing whether or not all the letters\r\nin a string are capitalized.\r\n\r\ndef all_caps(s : str) -> bool:\r\n    # look for a counterexample: a non-upper-case character\r\n    for c in s:\r\n        if c not in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\r\n            return False  # found a counterexample\r\n\r\n    # found no counterexamples\r\n    return True\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterating over ranges of integers\r\n\r\nIn this section we will see how to iterate over ranges of integers, using\r\nobjects constructed from range and irange. Note that range is automatically\r\nimported from Python's builtins module; irange is defined in my goody module,\r\nand is normally imported as from goody import irange (so we can use its name\r\nby itself, just like range).\r\n\r\nFirst let's look at the syntax for constructing range and irange objects, then\r\nwe will discuss their semantics, see exmples of their use, and explore the exact\r\nrules Python applies when these iterators are in for loops.\r\n\r\n  start  <= expression\r\n  stop   <= expression\r\n  step   <= expression\r\n\r\n  range  <= range (stop | start,stop | start,stop,step)\r\n  irange <= irange(stop | start,stop | start,stop,step)\r\n\r\nWe could describe range as \r\n\r\n  range  <= range (expression[,expression][,expresssion])\r\n\r\nbut it is useful to name the three expressions in our discussion of the\r\nsemantics of range/irange objects. Note that range/irange always require one\r\nargument: stop. They accept two or three arguments, whose difference we will\r\nexplore below.\r\n\r\nSemantically, Python computes a range/irange iterable object as follows:\r\n\r\n  (1) If start is omitted, its default value is 0\r\n  (2) If step  is omitted, its default value is 1\r\n\r\n  range : produces values from start (inclusive) to stop (NOT INCLUSIVE) using\r\n          increments of step\r\n\r\n  irange: produces values from start (inclusive) to stop (INCLUSIVE) using\r\n          increments of step; in fact, the \"i\" in \"irange\" means \"i\"nclusive\r\n          of the stop value.\r\n\r\nHere are some examples of ranges/iranges; we can explore ranges/iranges in\r\nEclipse by simply running the following script\r\n\r\nfor i in range(fill in details):\r\n    print(i)\r\n\r\nRange           | Values bound to identifier in the for loop\r\n----------------+-----------------------------------------------\r\nrange (5)       | 0, 1, 2, 3, 4\r\nirange(5)       | 0, 1, 2, 3, 4, 5\r\nrange (1,5)     | 1, 2, 3, 4\r\nirange(1,5)     | 1, 2, 3, 4, 5\r\nrange (1,5,2)   | 1, 3\r\nirange(1,5,2)   | 1, 3, 5\r\nirange(5,1,1)   | empty range, no values bound to identifier\r\nirange(1,5,-1)  | empty range, no values bound to identifier\r\nirange(5,1,-1)  | 5, 4, 3, 2, 1\r\nirange(5,1,-2)  | 5, 3, 1\r\n\r\nHere are the details of how ranges/iranges work. When a range/irange object is\r\nconstructed, (0) there is a secret name called next that is initialized to\r\nstart. When an irange (easier to descibe than range) has to produce a value\r\n\r\n  (1) if step > 0 and next > stop, produce no more values; terminate the loop\r\n      if step < 0 and next < stop, produce no more values; terminate the loop\r\n\r\n  (2) produce the value next, but internaly update next += step (next goes up\r\n      or down depending on whether step is positive or negative) for use the\r\n      next time the irange must produce a value.\r\n\r\nSo here is how irange(3,5) produces values:\r\n\r\n  next is initialized to 3 (start is 3, stop is 5 and step is 1). When asked to\r\n  produce a new value, rule (1) doesn't apply; rule (2) produces 3 and updates\r\n  next to 4. When asked to produce a new value, rule (1) doesn't apply; rule\r\n  (2) produces 4 and updates next to 5. When asked to produce a new value, rule\r\n  (1) doesn't apply; rule (2) produces 5 and updates next to 6. When asked to\r\n  produce a new value, rule (1) applies and the irange produces no more values.\r\n\r\nUse this detailed description to better understand how all the values are\r\nproduced in strange iranges like irange(5,1,-2).\r\n  \r\nNote that we could be in big trouble if we specified a step that was 0; can you\r\nexplain why? So Python prohibits this value from being used at the third\r\nargument in a range/irange. If we write range(x,y,0) Python raises an\r\nexception: ValueError: range() arg 3 must not be zero\r\n\r\nIf you think back to the indexes used in string slices, ranges are similar. The\r\nbiggest difference is that a string s knows how long it is, so it can use len(s)\r\nas a default stop value, but there is no such upper bound in an integer range.\r\n\r\nWe can easily write a simple script to print all the prime values in any range.\r\n\r\n------------------------------\r\nimport prompt\r\nfrom predicate import is_prime\r\n\r\nmin = prompt.for_int('Enter minimum value to check')\r\nmax = prompt.for_int('Enter maximum value to check')\r\n\r\nfor i in irange(min,max):\r\n    if is_prime(i):\r\n        print(i)\r\n------------------------------\r\n\r\nHere is a version that counts and prints the number of primes in a range.\r\nIt just combines the counting idiom for loops we saw above, with this\r\nparticular loop.\r\n\r\n------------------------------\r\nimport prompt\r\nfrom predicate import is_prime\r\n\r\nmin = prompt.for_int('Enter minimum value to check')\r\nmax = prompt.for_int('Enter maximum value to check')\r\n\r\ncount = 0\r\nfor i in irange(min,max):\r\n    if is_prime(i):\r\n        count += 1\r\nprint(count)\r\n------------------------------\r\n\r\nHere is a function that computes the number of primes in a range. Note we\r\nDIDN'T prompt for min/max in the function, but instead listed those as\r\nparameters to the function, following the rules explained above. The prompts\r\noccur outside the function, and the returned result is printed outside the\r\nfunction as well.\r\n\r\nfrom goody import irange\r\nfrom predicate import is_prime\r\n\r\ndef primes_between(min,max):\r\n    count = 0\r\n    for i in irange(min,max):\r\n        if is_prime(i):\r\n            count += 1\r\n    return count\r\n\r\nWe would call it as follows\r\n\r\nprint('The number of primes between 1000 and 2000 is',primes_between(1000,2000))\r\n\r\nwhich prints\r\n\r\n  The number of primes between 1000 and 2000 is 135\r\n\r\nI want to show you something now, but cautiously. Because, what I am going to\r\nshow you is illustrative, but typically the WRONG thing to do in most\r\ncircumstances. We can print all the characters in a string (we've already seen\r\nhow to do it one way) by using a range of integers to index each character. The \r\ncode would be\r\n\r\ns = 'abcde'\r\nfor i in range(len(s)):\r\n  print(s[i],end='')\r\n\r\nwhich prints: abcde\r\n\r\nNote for the string s,\r\n\r\n 0 1 2 3 4\r\n+-+-+-+-+-+\r\n|a|b|c|d|e|\r\n+-+-+-+-+-+\r\n\r\nNotice that range produces values from 0 (by default; and the start of the\r\nstring) up to but not including len(s) - here 5. So it produces the the values\r\n0, 1, 2, 3, 4 which are all legal indexes of the string. So range does exactly\r\nthe thing we want in this example, by not including the last value (5) among the\r\nvalues it produces.\r\n\r\nWhy is what I showed typically not the best way to solve this problem? Because,\r\nwe have a simpler way to solve it without resorting to the indexes of the\r\ncharacters in the string. Recall we can write the simpler code\r\n\r\ns = 'abcde'\r\nfor c in s:\r\n  print(c,end='')\r\n\r\nwhich produces the same result, without refering to integers and indexes, just\r\nrelying on the properties of strings as iterables. It prints: abcde\r\n\r\nSo, we should avoid writing for loops that produce indexes if we don't need\r\nthem. When might we need them? Well suppose that we wanted to print all the\r\ncharacters in a string in reverse order: we could write the script\r\n\r\ns = 'abcde'\r\nfor i in range(len(s)-1,-1,-1):  # or, for i in irange(len(s)-1,0,-1)\r\n  print(s[i],end='')\r\n\r\nwhich prints: edcba\r\n\r\nMaybe here it would be a little more intuitive to write the for loop using an\r\nirange, as for i in irange(len(s)-1,0,-1): although really the best for loop\r\nuses a Python feature we will learn later: for c in reversed(s): in which the\r\nreversed object iterates backward through whatever object is its argument. We'll\r\nsave that for another day.\r\n\r\nOn Python and Language Extensions\r\n\r\nThe standard Python includes a range object but not an irange object. Yet I\r\nfound that more often than not, it is easier to write irange: I would have to\r\nwrite things like range(1,11) to get the value 1-10, which is confusing. So, I\r\nwrote the irange definition and put it in my goody module so I could easily use\r\nit whenever I wanted it.\r\n\r\nProgrammers are constantly creating better tools for themselves. Python is\r\npopular because it is an easy language to make such tools and use them. If we\r\ndon't like something about the Python language, we might be able to \"fix it\",\r\nwhen we've learned enough about Python.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterating over lines in a file (and some useful string methods)\r\n\r\nIn this section we will see how to iterate over lines (each represented by a\r\nstring) in a file using objects constructed from open. Note that open, like\r\nrange, is automatically imported from Python's builtins module.\r\n\r\nFirst let's look at the syntax for constructing open objects, then\r\nwe will discuss their semantics and see examples of their use. \r\n\r\n  open <= open(file-name) | ...other options for writing files later\r\n\r\nFor file-name, we must specify a string representing the name of an existing\r\nfile: e.g., 'letter.txt'.\r\n\r\nNote that to read information from files easily using a script running in\r\nEclipse, the file we are opening must appear in the project folder that\r\ncontains the .py script we are running, in the project folder at the same level\r\nas the script's .py file. We should see it in the same location as the script\r\nfile in the PyDev Package Explorer.\r\n\r\nIn fact, we can open files that reside anywhere on our computer, but it is\r\nharder (and irrelevant to what we are learning now), so we will assume the\r\nfiles we want to open are in the correct location in the project folder.\r\n\r\nSemantically, Python computes an open iterable as follows:\r\n\r\n  (1) Find the file (raise the FileNotFoundError if not found or unreadable)\r\n  (2) Produce values for each line in the file (each a string representing the\r\n      line)\r\n\r\nSo, one simple script would echo a file to the console: binding the identifier\r\nto each line and printing it. Install the project folder accompanying this\r\nlecture, which contains the following script (test.py) and two text files:\r\nletter.txt (a dozen lines) and dictionary.txt (25,000 lines).\r\n\r\nfor l in open('letter.txt'):\r\n    print(l)\r\n\r\nHere, the for loop binds l to each string/line in the file, one after another,\r\nand print l for each binding. If we run this script successfully, it will print\r\nevery line from the file (which we can examine by double-clicking its name in\r\nEclipse) in the console, but with a mysterious blank line between every line of\r\ntext. Now, we could fix this problem by changing the print to print(l,end='')\r\nbut we need to learn what the real problem is and how to fix it in many other\r\ncontexts. Here is what the start of the print looks like\r\n\r\n------------------------------\r\nDear Jack:\r\n\r\nI want a man who knows what love is all about.\r\n\r\n*Good direct start\r\n\r\nYou are generous, kind, and thoughtful.\r\n\r\n...more lines\r\n------------------------------\r\n\r\nIf we change the print to have the following \"magic\" (__repr__ is a special\r\nmethod we will learn more about later), we will see the lines printed, but with\r\nno blank lines between them.\r\n\r\nfor l in open('letter.txt'):\r\n    print(l.__repr__())\r\n\r\nEach line looks like\r\n\r\n------------------------------\r\n'Dear Jack:\\n'\r\n'I want a man who knows what love is all about.\\n'\r\n'*Good direct start\\n'\r\n'You are generous, kind, and thoughtful.\\n'\r\n------------------------------\r\n\r\nUsing __repr__ shows the string literal equivalent of each line, including its\r\nopening and closing quotes, and each line is seen to have the \\n escape\r\ncharacter at the end (because each line in a file ends with a newline). When we\r\nuse print(l), the '\\n' in the string itself forces Python to go to the next\r\nline, and when the print has finished printing l it goes to the next line too,\r\nwhich is why the line is skipped.\r\n\r\nTypically when we read a line from a file, we want to strip any special\r\nwhite-space characters at its end (but not always, which is why Python doesn't\r\nautomatically do it). There is a right strip method (like a function, but\r\nremember methods are called with the syntax object.method(...)) that strips\r\nwhite-space, including newlines, off the right end of a string. Here is an\r\nexample that illustrates (with .__repr__()) the meaning of \r\n\r\nl = 'Hello\\n   \\n'\r\nls = l.rstrip()\r\nprint(l.__repr__())\r\nprint(ls.__repr__())\r\n\r\nNote that rstrip does not CHANGE the string it is called on (string are\r\nimmutable) but it returns a new string that has all the characters of the\r\nold string, but not the white-space at the end.\r\n\r\nThese statemetns print the following (producing a new string stripped of all of\r\n'\\n  \\n' off the right end of this string).\r\n\r\n  'Hello\\n  \\n'\r\n  'Hello'\r\n\r\nFYI, there is a lstrip method (for stripping white space off the left end) and\r\na strip method (for stripping white space off both ends). But rstrip is the\r\nmost useful method.\r\n\r\nSo if we go back to our original code and call the rstrip method on each line,\r\nto strip the whitespace on the right, our code would be\r\n\r\nfor l in open('letter.txt'):\r\n    print(l.rstrip())\r\n\r\nAgain, l does not change when its rstrip method is called, but calling this\r\nmethod produces a new string without the white-space at the end; this new\r\nstring is what print prints.\r\n\r\nRunning the script above would print as follows with no extra lines. This is\r\ncalled echoing a file (printing its contents on the console, one line at a\r\ntime).\r\n\r\n------------------------------\r\nDear Jack:\r\nI want a man who knows what love is all about.\r\n*Good direct start\r\nYou are generous, kind, and thoughtful.\r\n...more lines\r\n------------------------------\r\n\r\nThe actual letter.txt file represents a letter, in which each line can be\r\nannotated below by lines that starts with a *. Let's examine a program that\r\nuses an if statement to  print only the lines in the letter, not printing any\r\nannotation lines (which all start with a *).\r\n\r\nfor l in open('letter.txt'):\r\n    ls = l.rstrip()\r\n    if ls.find('*') != 0:  # or test len(ls) > 0 and ls[0] =! '*':\r\n        print(ls)\r\n\r\nHere I needed to use the stripped line twice: once in the if statement and \r\nagain in the print function call. So I have decided to define an extra name,\r\nls, to store a reference to the line stripped; and then use that name ls where\r\nnecessary. Note the boolean expression is a call to the find method, which\r\nreturns the index (remember they start at 0) of the first '*' in the string (or\r\na -1 if * does not occur in the string). So this boolean expression evaluates\r\nto True exactly when strings that have a * in their first position (at index 0).\r\nNote that for an empty string, the find method always returns -1, and hence the\r\nboolean expression is always False for empty strings.\r\n\r\nSo, this script would print as follows (missing from above is the line:\r\n*Good direct start)\r\n\r\n------------------------------\r\nDear Jack:\r\nI want a man who knows what love is all about.\r\nYou are generous, kind, and thoughtful.\r\n...more lines\r\n------------------------------\r\n\r\nThe following script reads a file that has one word on each line, and computes\r\nthe average word length for all the words in that file. The file dictionary.txt\r\nhas this correct forma.\r\n\r\nword_count = 0  # accumulate count of all words/lines read\r\nlength_sum = 0  # accumulate # of all characters in these words\r\n\r\nfor l in open('dictionary.txt'):\r\n    word_count += 1\r\n    length_sum += len(l.rstrip())\r\n\r\nprint('Word count =',word_count)\r\nprint('Length sum =',length_sum)\r\nprint('Average length =',length_sum/word_count)\r\n\r\nNotice that since I used l.rstrip() just once in this script, I did not define\r\na new name to refer to its value. This script would run almost instantaneously\r\n(on this file of about 25,000 words) and print the following.\r\n\r\nWord count = 25094\r\nLength sum = 181268\r\nAverage length = 7.223559416593608\r\n\r\nHere is a simlar verion that reads a file of numbers (one per line) and\r\ncomputes the sum and the average of the numbers read from the file. Remember\r\nthat open produces a sequence of string values: we use the int(...) conversion\r\nfunction on each line: e.g., int('123') is the int 123.\r\n\r\ncount = 0\r\nsum   = 0\r\n\r\nfor l in open('numbers.txt'):\r\n   count += 1\r\n   sum   += int(l.rstrip()) # strip the '\\n' and determine int equivalent of str\r\n\r\nprint('Count =',count)\r\nprint('Sum =',sum)\r\nprint('Average =',sum/count)\r\n\r\nAs a final example, here is a function that determines whether a word is legal\r\naccording to a specified dictionary file.\r\n\r\ndef is_legal(word : str, dict_file : str) -> bool:\r\n    # look for a word in the dictionary file\r\n    for l in open(dict_file):\r\n        if word == l.rstrip():\t# found it; legal\r\n            return True\r\n\r\n    return False\t\t# couldn't find it in the dictionary: illegal\r\n\r\nprint('Is immature a legal word?',is_legal('immature','dictionary.txt'))\r\nprint('Is immatur  a legal word?',is_legal('immatur' ,'dictionary.txt'))\r\n    \r\nUsing this function, you could you write a script that read a file of words\r\n(1 word per line) and printed all the illegal/misspelled words.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nClosing:\r\n\r\nWe should now have a good understanding a working knowledge of for loops, and\r\nhow to write code using for loops iterating over strings, integer ranges, and\r\nfiles. Because it is so easy to repeat code over and over again in loops, even\r\nthough the work done in each block that is the body of the loop may be small,\r\nwe can specify loops that do large amounts of work by repeating that simple\r\ncalculation many times.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems\r\n\r\n1) What happens:\r\n  s = 'abc':\r\n  for c in s:\r\n      print(c)\r\n      s = 'xyz'    \r\n\r\n2) Rewrite code to print a->b->c->d->e with the extra print statement after the\r\nloop, not before it; make it go to the next line after printing this last value\r\nas well (not stay on the current line as needed in the loop).\r\n\r\n3) Write a scripts that prompts the user for a word and file name (both are\r\nstrings) and reads the file, printing every line that contains the word;\r\nenhance this code to print the number of the line in the file: so if only the\r\n100th line in a file contained the word, it would print as line 100.\r\n", "encoding": "ascii"}