{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/dictionaries/dictionaries.txt", "content": "\t\t\t\tDictionaries\r\n\r\nHere are the bare bones. I will demonstrate dictionaries in class. The next\r\nlecture will include many scripts and functions that we can write to process\r\ndictionaries. As with lists, the reality of understanding dictionaries is\r\nunderstanding the basic operations that we can perform on them. There are fewer\r\noperations that we can perform on dictionaries than lists, but their meanings\r\nare a bit more subtle.\r\n\r\nDictionaries are like generalized lists: lists associate indexes with values,\r\nwith the indexes ranging from 0 to len(...)-1; dictionaries (the dict type)\r\nassociate arbitrary keys (not just integers) with values. Often the keys are\r\nstrings and often values are ints, strings, or lists/tuples. The three major\r\ncategories of operations on dictionaries are \r\n\r\n(1) setting the value associated with a key\r\n\r\n(2) examining the value associated with a key (and sometimes mutating it)\r\n\r\n(3) iterating through a dictionary (there are three ways: by keys, by values,\r\n    and by items: items are 2-tuples consisting of a key and its value);\r\n    dictionaries are not ordered with indexes (like strings/lists/tuples) so\r\n    there is NO STANDARD ORDER that they are iteratated over, but we will learn\r\n    about the sorted function, which we canuse to iterate through dictionaries\r\n    in a special order.\r\n\r\nSo, like lists, dictionaries are mutable data structures. Sometimes dictionaries\r\nare called maps, because they embody how to map a key to its associated value.\r\n\r\nDictionaries have literals: any number of key:values pairs (0 or more, with the\r\nkey and its associated value separated by a colon), with different key:value\r\npairs separated by commas, all in braces: the empty dictionary is written {}.\r\nNote that a key/value pair, stored as a tuple, is called an \"item\" (see the\r\n iteration over .items() in a dictionary). Here are example of dictionary\r\nliterals.\r\n\r\na = {'a':1, 'b':2, 'c':3} is a dictionary of str:int associations\r\n\r\nb = {1:'a', 2:'b', 3:'c'} is a dictionary of int:str associations\r\n\r\nc = {'penny':1, 'nickel':5, 'dime':10, 'quarter':25}\r\n     like a, but useful information\r\n\r\nd = {'bob':['ICS-31','MATH-2A','ICS-6B'], 'mary':['ICS-31','BIO-9','ICS-6D']}\r\n    is a dictionary of str:list[str]\r\n\r\ne = {'even': {0:'even',1:'odd'}, 'odd': {0:'odd',1:'even'}}\r\n    is a dictionary whose values are sub-dictionaries (just as we can have\r\n    lists whose values are sub-lists. We describe this annotation as\r\n    {str:{str:str}}.\r\n\r\nf = {'a':'str', 2:'int', (0,0):'tuple'}\r\n    is a dictionary whose keys are different types; we cannot use lists as KEYS\r\n    in dictionaries, but we can use tuples. The difference is mutability: all\r\n    keys must be immutable (recall strings and ints are immutable, so we can\r\n    use them as keys); more on this later.\r\n\r\nDictionary operations:\r\n\r\n(1) len: we can compute the length of a dictionary (# of key:value pairs at\r\n    the top-level) len(a) is 3; len(b) is 3; len(c) is 4, len(d) is 2; len(e)\r\n    is 2.\r\n\r\n(2) Indexing: we can refer to each value in a dictionary by its key: we index\r\n    a dictionary by a key, computing its value: a['a'] is 1; b[3] is 'c';\r\n    c['quarter'] is 25; d['bob'] is ['ICS-31','MATH-2A','ICS-6B'] and note that\r\n    d['bob'][0] is 'ICS-31'; e['even'][1] is 'odd'; f[(0,0)] is 'tuple'\r\n\r\n    Note the asymmetry: given a key we can easily find its value, but given a\r\n    value we cannot easily find its key: in fact, although keys are unique,\r\n    there may be muliple values with different keys: {'alex':24, 'jessie':24}.\r\n\r\n    Note that c['peso'] raises an exception: KeyError: 'peso'; because there is\r\n    no value in the dictionary c associated with 'peso'. Another way to say\r\n    this is there is no key 'peso' in this dictionary.\r\n\r\n(3) No Slicing\r\n\r\n(4) Checking containment: the in/not in operators\r\n    These operators work on the KEYS in a dictionary\r\n    'a' in a is True; 'a' in b is False, but 3 in b is True; 'peso' in c is\r\n    False; 'bob' in d is True; 0 in d['even'] is True; 'int' in f is False\r\n\r\n    Sometimes we will see code like the following: it checks whether a key (x)\r\n    is in a dictionary (d) before using the key as in index, to ensure no\r\n    exception is not raised.\r\n\r\n    if x in d:\r\n        print(d[x])\r\n\r\n\r\n(5) No Catenation\r\n\r\n(6) No Multiplication\r\n\r\n(7) Iterability: there are three ways to iterate through a dictionary: by its\r\n      keys, by its values, and by its items (tuples of key:value pairs). Each\r\n      produces len(...) values, but their order is not fixed.\r\n\r\n    for k in d:/for k in d.keys(): produce all top-level keys in d\r\n    for v in d.values()          : produce all top-level values in d\r\n    for kv in d.items()          : produce all top-level (key,value) pairs in d\r\n\r\n    We can write\r\n      for k in sorted(...) if the keys/values/items can be compared for order\r\n        (they are produced in the order specified: as with the the sort method,\r\n        we can optionally supply key/reverse arguments to control the order).\r\n    Note that we cannot sort a dictionary, but we can iterate over the keys\r\n      in a sorted order; this is an important distinction, and is unlike lists.\r\n\r\n    for k in c:\r\n        print(k,end=';')\r\n    prints: penny;dime;nickel;quarter;\r\n\r\n    for k in sorted(c):\r\n        print(k,end=';')\r\n    prints: dime;nickel;penny;quarter;\r\n\r\n      This is similar to\r\n        keys = list(c)                # created list by iterating over d's keys\r\n        keys.sort()    \t     \t      # sort the list (lists are sortable)\r\n        for k in keys:\t\t      # iterate through sorted keys list\r\n            print(k,end=';')\r\n\r\n    for k in sorted(c.keys()):\t      # a common idiom: keys and values\r\n        print(k,c[k],sep=':',end=';')\r\n    prints: dime:10;nickel:5;penny:1;quarter:25;\r\n\r\n    for kv in sorted(c.items()):\r\n        print(kv,end=';')\r\n    prints: ('dime', 10);('nickel', 5);('penny', 1);('quarter', 25);\r\n\r\n    for kv in sorted(c.items()):\r\n        print(kv[0],kv[1],sep=':',end=';')\r\n    # note how each tuple in kv can have its indexes 0 and 1 accessed\r\n    prints: 'dime':10;'nickel:'5;'penny':1;'quarter':25;\r\n\r\n    for k,v in sorted(c.items()):     # a common idiom: keys and values\r\n        print(k,v,sep=':',end=';')\r\n    # note how each tuple produced is unpacked into the names k and v\r\n    prints: 'dime':10;'nickel:'5;'penny':1;'quarter':25;\r\n\r\n    for v in sorted(c.values()):      # this form isn't common but can be used\r\n        print(v,end=';')\r\n    prints: 1;5;10;25;\r\n    \r\nIn fact, we can write the sorted function as\r\n\r\ndef sorted(iterable,key=None,reverse=None):\r\n    alist = list(iterable)\r\n    alist.sort(key=key, reverse=reverse)\r\n    return alist\r\n\r\nwhich creates a list with every value produced by iterating over the iterable \r\nparameter. Then it sorts that list using the key/reverse parameters. Finally\r\nit returns that list. So when writing\r\n\r\n    for i in sorted(...):\r\n\r\ni takes on every value (one after another) that is in the list returned by\r\ncalling the sorted function: a list whose values are sorted.\r\n\r\n\r\n      \r\nDictionary (mutation) operations\r\n\r\n(a) Assignment\r\n\r\n   Suppose x = {'a':1, 'b':2, 'c':3}\r\n   x['a'] is 1\r\n   x['a'] = 'z'\r\n   now x is {'a':'z', 'b':2, 'c':3}; the value associated with key 'a' has been\r\n      changed to 'z'\r\n   x['b'] = ['b1','b2']\r\n   now x is {'a':'z', 'b':['b1','b2'], 'c':3}; the value in key 'b' has been\r\n      changed to ['b1','b2']\r\n\r\n   If we assign to a key not already in the dictionary, Python just adds it\r\n     (very different from lists, which require a call to append).\r\n\r\n   x['d'] = 'new'\r\n   now x is {'a':'z', 'b':['b1','b2'], 'c':3, 'd':'new'}; key 'd' is added to\r\n     the dictionary, with an associated value of 'new'. len(x) goes from 3 to 4.\r\n\r\n   So, looking up a non-existant key raises KeyError, but assigning a\r\n     non-existant key is fine. This process if like like bind names in general:\r\n     to look up the value of name, the name must be bound to some value; but to\r\n     set/rebind a value to a name the name can exist (change its value)or not\r\n     exist (create the name and set its value)\r\n\r\n(b) del form: del adict[key]\r\n    del x['b']\r\n    now x is {'a':'z', 'c':3, 'd':'new'}\r\n\r\n    if we try to delete a key not in adict, Python raises KeyError; we can\r\n    always write\r\n      if key in adict:\r\n          del adict[key]\r\n    to ensure this exception is not raised.\r\n\r\n(c) The get function is convenient to explain here, but it does not mutate the\r\n      dictionary\r\n    adict.get(key,default)\r\n    Same as adict[key] except if key is not in adict, it returns the value of\r\n      default (and if default is not specified, returns None); but unlike []\r\n      indexing, it never raises KeyError\r\n    Similar to the following function definition (we'll learn the truth soon)\r\n\r\n    def get(key,default=None)\r\n       if key in adict:\r\n           return adict[key]\r\n       else:\r\n           return default\r\n       \r\n(d) adict.setdefault(key,default)\r\n    Same as adict.get(key,default) except if key is not in adict, it first\r\n    adds the key:default pair to the dict and then returns the value of\r\n    adict[key], which is now guaranteed to exist.\r\n    Similar to the following function definition (we'll learn the truth soon)\r\n\r\n    def setdefault(key,default=None)\r\n       if key not in adict:\r\n          adict[key] = default\r\n       return adict[key] # which is default\r\n   \r\n    So setdefault is like get, but if the key is not found, it not only returns\r\n    default, but first mutates the dictionary, puting the key:value pair in it.\r\n          \r\n(e) adict.pop(key) or adict.pop(key,default)\r\n    First form: removes the key (and its associted value) from the dict and\r\n       returns the value associated with the key: it raises a KeyError if key\r\n       is not in adict.\r\n    Second form: the same, but returns default if key is not in adict, not\r\n      raising an exception\r\n\r\n    adict.popitem()\r\n    Removes a random key from the dictionary and returns the key:value as a\r\n     tuple: raises KeyError if the dictionary is empty: len(adict) == 0\r\n\r\n(f) adict.clear()\r\n    Deletes all key:value pairs from the adict; equivalent to adict = {}\r\n\r\n(g) keys(), values(), items() are technically called views of the dictionary.\r\n    Besides iterating over these views, we can check if values are in/not in\r\n      them\r\n\r\n(h) d = dict(...)\r\n    Recall that we can write list(...) and tuple(...) to construct a list/tuple\r\n    that contains all the values specified by ...\r\n\r\n    For dict, there are two forms of ...\r\n\r\n    (1) anything we can iterate over, that produces a sequence of 2-list/-tuple\r\n    which is treated as a key/value. For example, we write a list of 2-tuples:\r\n    d = dict([('a',1),('b',2),('c',3)]) is the same as d = {'a':1, 'b':2, 'c':3}\r\n\r\n    (2) a list of parameters of the form p=v, where p (as a string) becomes\r\n    a key and v becomes its associated value. This only works for keys that are\r\n    string, but this is very common.\r\n    d = dict(a=1,b=2,c=3) is the same as d = {'a':1, 'b':2, 'c':3}\r\n\r\n(i) adict.update(...)\r\n    Update adict with the information in ..., with three forms of ....\r\n    (0) another dict\r\n    (1) see (h) above\r\n    (2) see (h) above\r\n\r\n    so, if adict is {'a':100, 'b':200, 'c':300} the following\r\n       adict.update([('a',1),('x',2),('c',3)])     # note the 'x'\r\n       adict.update({'a':1, 'x':2, 'c':3})         # note the 'x'\r\n       adict.update(a=1,x=2,c=3)   \t\t   # note the 'x'\r\n    all are like executing\r\n       adict['a'] = 1\r\n       adict['x'] = 2\r\n       adict['c'] = 3\r\n    which result in adict being {'a':1, 'b':200, 'c':3, 'x':2}\r\n\r\n    Students use update too much. Try to use [] and mutation instead. For\r\n      example, if classes is a dictionary whose keys are UCInetIDs and whose\r\n      associated values are the courses that student is taking, writing\r\n      classes['pattis'].append('ICS-31') would mutate the list associated\r\n      with UCInetID 'pattis' to also include 'ICS-31'.\r\n    \r\n\r\n------------------------------------------------------------------------------\r\n\r\nComprehensions\r\n\r\nAs with lists/tuples, we can build dictionaries via comprehensions as\r\n\r\nd = {dict-comprehension}\r\n\r\nThe form of a dict-comprehension is as follows (bool-expression-i is a boolean\r\nexpression that can refer to i). Note that the [] mean EBNF option.\r\n\r\n  key-expression-i:value-expresion-i for i in iterable [if bool-expression-i]\r\n\r\nSo, to create a dictionary of keys that are strings and values that are their\r\nlengths, we could write\r\n\r\nd = {s : len(s) for s in 'Four score and seven years ago'.split(' ')}\r\n\r\nHere d is {'Four':4, 'score':5, 'and':3, 'seven':5, 'years':5, 'ago':3}\r\n\r\nIf we wanted only the words longer than 3 characters, we could include the\r\noption and write:\r\n\r\n{s : len(s) for s in 'Four score and seven years ago'.split(' ') if len(s)>3}\r\n\r\nGenerally, we can translate a dictonary comprehension as follows.\r\n\r\n  comprehension = {}\r\n  for i in iterable:\r\n      if bool_expression-i:\r\n          comprehension[key-expression-i] = value-expression-i\r\n\r\nAs with list, comprehensions are good for creating new dictionaries, but not\r\nfor mutating existing dictionaries\r\n\r\n------------------------------------------------------------------------------\r\n\r\nPutting it all Together: Some Real Dictionary Code (The Power of Dictionaries)\r\n\r\nSuppose that we have a list of words and we want a count of how often each word\r\nappears. Here is a function that takes such a list as an argument and returns\r\na dictionary of how often each word occurs.\r\n\r\ndef count_words(alist):\r\n    answer = {}\t\t\t# create empty dictionary\r\n    for w in alist:\t\t# iterate over all words in alist\r\n        if w in answer:\t\t# check if that word is a key\r\n            answer[w] += 1\t#   udpate count for existing key\r\n        else:\r\n            answer[w] = 1\t#   create count for non-existing key\r\n    return answer\r\n\r\nWe can simplify this function by using setdefault (review its meaning). It is\r\nso useful just because this update-idiom is so frequent. In fact, we will learn\r\nabout defaultdict that even makes this idiom easier to express.\r\n\r\ndef count_words(alist):\r\n    answer = {}\r\n    for w in alist:\r\n        answer[w] = answer.get(w,0) + 1\r\n    return answer\r\n\r\nIn both cases, calling\r\n\r\ncount_words('how much wood could a woodchuck chuck if a woodchuck could chuck wood'.split(' '))\r\n\r\nreturns\r\n\r\n{'could': 2, 'much': 1, 'chuck': 2, 'if': 1, 'a': 2, 'how': 1, 'wood': 2, 'woodchuck': 2}\r\n\r\nNotice that the order of the key:value pairs is indeterminate. If we wrote\r\nanswer = count_words(...)\r\nfor k in sorted(answer):\r\n    print(k,'->',answer[k])\r\n\r\nthe printed result would be \r\n\r\na -> 2\r\nchuck -> 2\r\ncould -> 2\r\nhow -> 1\r\nif -> 1\r\nmuch -> 1\r\nwood -> 2\r\nwoodchuck -> 2\r\n\r\nIf you understand all aspects of count_words, you have a good starting \r\nunderstanding of dictionaries.\r\n", "encoding": "ascii"}