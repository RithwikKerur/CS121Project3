{"url": "https://www.ics.uci.edu/~irus/wisen/wisen98/presentations/Summary-Reqts/Final_report.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD W3 HTML//EN\">\n<HTML>\n<HEAD>\n\n<META content=3Dtext/html;charset=3Diso-8859-1 \nhttp-equiv=3DContent-Type><TITLE>WISEN - Requirements for an\nInternet-scale event notification service</TITLE>\n<META content=3D'\"MSHTML 4.72.3110.7\"' name=3DGENERATOR>\n</HEAD>\n<BODY>\n<H1>Requirements for Internet scale event notifications</H1>The goal of \nthis\nsession was to identify a set of requirements for an Internet-scale \nevent\nnotification service. More specifically, the discussion developed from\n<I>minimal</I> requirements to <I>advanced</I> and \n<I>domain-specific</I>\nrequirements. Also, the tension between various domain-specific \nrequirements led\nto discussing the possibility of having one single event service, usable\nin\ndifferent contexts, as opposed to a number of separate services targeted\nto some\nparticular application domain.\n<P><I>Core</I> or <I>minimal</I> requirements define the core \nfunctionalities of\nan Internet-scale event notification service. These are the features \nthat a\ntechnology must exhibit in order to qualify as an Internet-scale event\nnotification service.\n<P><I>Advanced</I> features are not mandatory parts of the core service, \nhowever\nthey are desirable functionalities that any Internet-scale event \nnotification\nservice should provide either because they are of common utility for\nmany\nclasses of applications or because they can not be easily or efficiently \n\nimplemented on top of the core services.\n<P>\n<H2>Core Requirements</H2>A quite numerous list of core requirements has \nbeen\nproposed. Only some items were analyzed in detail<SPAN=20\nclass=3D90003922-31071998><FONT color=3D#000000 face=3DArial \nsize=3D3>,</FONT></SPAN>\nand a few comments were made on the interplay between different items.\n<DL>\n    <DT><B>core functionality</B>\n    <DD><SPAN class=3D90003922-31071998><FONT color=3D#000000 \nface=3DArial\n    size=3D3>T</FONT></SPAN>he main service provided by an event-based\n    infrastructure is the notification of the occurrence of events. \nObjects can\n    declare their interest in being notified of the occurrence of an \nevent or a\n    class of events by issuing a <I>subscription</I>. In other words,\n    subscriptions can be used to select notifications. The selection is \nbased on\n    the <I>content</I> of notifications, which corresponds to the data\n    associated with the observation of the event.\n    <P></P>\n    <DT><B>attributes of the notification service</B>\n    <DD><SPAN class=3D90003922-31071998><FONT color=3D#000000 \nface=3DArial=20\n    size=3D3>T</FONT></SPAN>he notification of an event is \n<I>asynchronous</I>\n    with respect to the occurrence of the event. Event producers and \nconsumers\n    are <I>decoupled</I>, i.e., it is not necessary for producers to be \naware of\n    the existence of consumers nor of their identity, and vice-versa. \nNote that\n    this principle doesn't require or imply notifications be anonymous. \nA\n    notification must be <I>reliably</I> delivered to all the components \nthat\n    subscribed for it. Most of these aspects can be seen in a more \ngeneral\n    perspective in which the <I>quality of service</I> can be \ndynamically\n    configured. For example, an object publishing a message can require\n    anonymity of the notification. Or conversely, an object subscribing \nfor some\n    events might require notifications to report information about the\n    publisher. As far as <I>reliability</I><SPAN \nclass=3D90003922-31071998><FONT=20\n    color=3D#000000 face=3DArial size=3D3> </FONT></SPAN><SPAN\n    class=3D90003922-31071998><FONT color=3D#000000 face=3DArial \nsize=3D3>is concerned,\n    </FONT></SPAN>both publishers and subscribers ideally<SPAN\n    class=3D90003922-31071998><FONT color=3D#000000 face=3DArial \nsize=3D3>\n    </FONT></SPAN>should be able to specify different levels or kinds of \n\n    service. For example, one subscriber might want to receive \n<I>exactly</I>\n    one notification for each event while others might accept repeated\n    notifications or even lost notifications. The same service \nparameters could\n    be set by publishers.\n    <DT><B>event notification protocol</B>\n    <DD><SPAN class=3D90003922-31071998><FONT color=3D#000000 \nface=3DArial\n    size=3D3>I</FONT></SPAN>n order to define the interface of the event \nservice,\n    an event notification <I>protocol</I> or an <I>API</I> should be \ndefined.\n    The choice of a protocol is preferable because a protocol is more\n    language-neutral and it is presumably easier to agree on. Also, \ndifferent\n    implementations and vendors can provide extended APIs and \nlanguage-dependent\n    bindings that should not be included or constrained by the common \ninterface\n    definition.\n    <P>For the design of this protocol, some extensions of HTTP have \nbeen\n    proposed. The major requirement for an event notification protocol \nis to be\n    compatible with existing firewalls. Other obvious requirements are\n    extensibility and efficiency. It would also be possible and in some \ncases\n    desirable to piggy-back the notification protocol on top of other \nstandard\n    protocols. </P>\n    <DT><B>distributed architecture</B>\n    <DD>Although the functionality of the service per se doesn't impose \nthis,\n    everyone agrees that it is necessary to have some sort of \ndistributed\n    architecture for the implementation of the service.\n    <P></P></DD></DL>\n<H2>Advanced Requirements</H2>\n<DL>\n    <DT><B>extensions and variances of the basic service</B>\n    <DD>It has been suggested as a <I>minimalist</I> approach that \nnotification\n    be idempotent. This supposedly makes the event service simpler \nbecause it is\n    not necessary for it to avoid repeated notification. It should be \nclear that\n    this is a requirement on the applications that use the event service \nrather\n    than on the event service itself.\n    <P>Many applications would benefit from having advanced subscription \n\n    mechanisms that facilitate the selection of very specific classes of \nevents\n    as well as sequences of events. As an example consider a security \nmonitor,\n    in order to detect an intrusion, the monitor might want to receive a \n\n    notification every time three consecutive failed logins occur for \nthe same\n    user on any machine in a subnet. Although suggested by \ndomain-specific\n    applications, this requirement seems to be useful in a generic event \n\n    notification service.\n    <P>The event notification interface, and therefore the event \nnotification\n    protocol, should allow for objects to be connected to the event \nservice\n    through <I>proxy</I> agents. This forces an additional de-coupling \nin the\n    protocol specification in that it should be possible for an object \nto\n    publish (and subscribe) on the behalf of another object.\n    <P></P>\n    <DT><B>persistence</B>\n    <DD>It is clearly necessary for subscriptions to be persistent \nwithin the\n    event service. It has also been argued that the event service should \nprovide\n    persistent storage of notifications. This feature is also related to \nthe\n    types of ``call-back'' mechanism that can be registered with \nsubscriptions.\n    Ideally, the event service should support various communication \nmethods,\n    possibly including HTTP and SMTP. Also, for every single \nsubscription, a\n    list of notification call-backs could be registered so that the \nevent\n    service could try the main one and then fall back to the other ones \nin case\n    the main one is not accessible.\n    <P>Persistence of notifications is also implied in case the event \nservice\n    supports a pull-style notification mechanism in which objects \nactively poll\n    the service to check for new notifications.\n    <P>There has been quite a bit of discussion on this aspect. Some \nthink that\n    persistence is so crucial that it would be a bad idea to retrofit \nit. On the\n    other hand, others argue that persistence should not be handled \ndirectly by\n    the event service, but instead, when required, it could be \nincorporated and\n    dealt with by the call-back mechanisms. An example of a persistent \ncall-back\n    mechanism is e-mail. The impact of persistence should also be \nevaluated with\n    respect to scalability. </P>\n    <DT><B>mobility</B>\n    <DD>Mobile computing technology allows roaming users to access their \n\n    personal resources from different nodes on a wide-area network. \nSimilarly,\n    thanks to mobile code technology, applications can ``move'' through \nthe net\n    requesting services from several access points. This possibility \nposes an\n    additional requirement on the event service. In fact, it is \ndesirable that\n    the event service support mobility by automatically re-routing \nnotifications\n    to follow users or applications as they move. Clearly, this would \nalso\n    require to augment the event service interface (and the \ncorresponding\n    protocol) with the appropriate mobility primitives. \n<p>\n\n<br>\n\n<em> Breakout Session Scribe:</em> \n\tAntonio Carzaniga, University of Colorado, Boulder\n</DD></DL></BODY></HTML>\n", "encoding": "ascii"}