{"url": "https://www.ics.uci.edu/~aburtsev/143A/hw/hw1-simple-programs.html", "content": "<HTML>\n<HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">\n<TITLE>143A Principles of Operating Systems</TITLE>\n<LINK HREF=\"./css/main.css\" TYPE=\"text/css\" REL=\"stylesheet\">\n<META NAME=\"Description\" CONTENT=\"Home page of Anton Burtsev.\">\n<META NAME=\"Keywords\" CONTENT=\"Anton Burtsev, Burtsev, Anton, cs143A\">\n<SCRIPT SRC=\"./scripts/image_switcher.js\" LANGUAGE=\"JavaScript\"></SCRIPT>\n</HEAD>\n\n<BODY BGCOLOR=\"#FFFFFF\" LEFTMARGIN=\"0\" TOPMARGIN=\"0\" MARGINWIDTH=\"0\" MARGINHEIGHT=\"0\">\n\t<TABLE  ID=\"text\" ALIGN=\"CENTER\" WIDTH=\"600\" BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD>\n\t\t<DIV ID=\"tech_nav\">\n\t\t\t<A HREF=\"../index.html\">Home</A>\n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"30\" ALT=\"\" BORDER=\"0\"/>\n\t\t</DIV>\n\t</TD>\n\t</TR>\t\n\t<TR>\n\t<TD COLSPAN=\"4\" ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\">\n\n\n\t\t<P>\n\n<h1>Homework 1: Simple UNIX programs</h1>\n\n<p>This assignment will make you more familiar with how to build simple Unix programs, create Makefiles, look at assembly code, and use the GDB debugger. The things\nyou learn will prepare you to handle a more complex environment of the xv6 kernel required \nfor the future homework. You can do this assignment on any operating system that supports the Unix API (Linux\nOpenlab machines, your laptop that runs Linux or Linux VM, and\neven MacOS, etc.). <b>You don't need to set up xv6 for this assignment</b> \nSubmit your programs and the shell through Gradescope (see instructions at\nthe bottom of this page). \n\nFor <b>Mac / OSX</b>> users. The support of 32 bit applications is depricated in the latest version of your system. So if you already updated your system to macOS Catalina or have updated your XCode then we recommend you to do the homework at the Openlab machines.\n\n<h2>Part 1: Simple UNIX programs</h2> \n\n<p>Download the <a href=\"main.c\">main.c</a>, and look it over. This is a\nskeleton for a simple UNIX program.  \n\n<p>To compile <tt>main.c</tt>, you need a C compiler, such as gcc.  On\nOpenlab machines, you can compile the skeleton with the following command: \n\n<pre> $ gcc main.c </pre> \n\nThis will produce an <tt>a.out</tt> file, which you can run: <pre> $ ./a.out </pre> \n\n<p>Alternatively you can pass an additional option to gcc to give a more\nmeaningful name to the compiled binary, like <pre> $gcc main.c -o hello</pre>\n\n<p>Here gcc will compile your program as <tt>hello</tt>.  \n\nIn the rest of this part of the assignment you will explore how to automate program \ndevelopment with Makefiles, learn how debug your code with GDB, and disassemble the \nprogram to verify your understanding of assembly language. \n\n<h2>Part 2: Simple Makefiles</h2>\n\nThis part of the homework is adapted from <a href=\"https://opensource.com/article/18/8/what-how-makefile\">https://opensource.com/article/18/8/what-how-makefile</a> and \n<a href=\"http://mrbook.org/blog/tutorials/make/\">http://mrbook.org/blog/tutorials/make/</a>\nIt aims to introduce you to basics of Makefiles and the <tt>make</tt> tool that provides a way to compile complex software projects like \nxv6 and Linux kernel. \n\n<p>If you want to run or update a task when certain files are updated, the make utility can come in handy. The make utility requires a file, Makefile (or makefile), which defines set of tasks to be executed. You may have used make to compile a program from source code. Most open source projects use make to compile a final executable binary, which can then be installed using make install.\n\n<p>\nWe'll explore make and Makefile using basic and advanced examples. Before you start, ensure that make is installed in your system.\n\n<p>\nLet's start by printing the classic \"Hello World\" on the terminal. Create a empty directory myproject containing a file Makefile with this content:\n\n<pre>\nsay_hello:\n        echo \"Hello World\"\n</pre>\n\n<p>\nNow run the file by typing make inside the directory myproject. The output will be:\n\n<pre>\n$ make\necho \"Hello World\"\nHello World\n</pre>\n\n<p>\nIn the example above, say_hello behaves like a function name, as in any programming language. This is called the target. The prerequisites or dependencies follow the target. For the sake of simplicity, we have not defined any prerequisites in this example. The command echo \"Hello World\" is called the recipe. The recipe uses prerequisites to make a target. The target, prerequisites, and recipes together make a rule.\n\n<p>\nTo summarize, below is the syntax of a typical rule:\n\n<pre>\ntarget: prerequisites\n&lt;TAB&gt; recipe\n</pre>\n\n<p>\nAs an example, a target might be a binary file that depends on prerequisites (source files). On the other hand, a prerequisite can also be a target that depends on other dependencies:\n\n<pre>\nfinal_target: sub_target final_target.c\n        Recipe_to_create_final_target\n\nsub_target: sub_target.c\n        Recipe_to_create_sub_target\n</pre>\n\n<p>\nIt is not necessary for the target to be a file; it could be just a name for the recipe, as in our example. We call these \"phony targets.\"\n\n<p>\nGoing back to the example above, when make was executed, the entire command echo \"Hello World\" was displayed, followed by actual command output. We often don't want that. To suppress echoing the actual command, we need to start echo with <tt>@</tt>:\n\n<pre>\nsay_hello:\n        @echo \"Hello World\"\n</pre>\n\n<p>\nNow try to run make again. The output should display only this:\n\n<pre>\n$ make\nHello World\n</pre>\n\n<p>\nLet's add a few more phony targets: generate and clean to the Makefile:\n\n<pre>\nsay_hello:\n        @echo \"Hello World\"\n\ngenerate:\n        @echo \"Creating empty text files...\"\n        touch file-{1..10}.txt\n\nclean:\n        @echo \"Cleaning up...\"\n        rm *.txt\n</pre>\n\n<p>\nIf we try to run make after the changes, only the target say_hello will be executed. That's because only the first target in the makefile is the default target. Often called the default goal, this is the reason you will see all as the first target in most projects. It is the responsibility of all to call other targets. We can override this behavior using a special phony target called <tt>.DEFAULT_GOAL</tt>.\n\n<p>\nLet's include that at the beginning of our makefile:\n\n<pre>\n.DEFAULT_GOAL := generate\n</pre>\n\nThis will run the target generate as the default:\n\n<pre>\n$ make\nCreating empty text files...\ntouch file-{1..10}.txt\n</pre>\n\n<p>\nAs the name suggests, the phony target <tt>.DEFAULT_GOAL</tt> can run only one target at a time. This is why most makefiles include all as a target that can call as many targets as needed.\n\n<p>\nLet's include the phony target all and remove <tt>.DEFAULT_GOAL</tt>:\n\n<pre>\nall: say_hello generate\n\nsay_hello:\n        @echo \"Hello World\"\n\ngenerate:\n        @echo \"Creating empty text files...\"\n        touch file-{1..10}.txt\n\nclean:\n        @echo \"Cleaning up...\"\n        rm *.txt\n</pre>\n\n<p>\nBefore running make, let's include another special phony target, <tt>.PHONY</tt>, where we define all the targets that are not files. make will run its recipe regardless of whether a file with that name exists or what its last modification time is. Here is the complete makefile:\n\n<pre>\n.PHONY: all say_hello generate clean\n\nall: say_hello generate\n\nsay_hello:\n        @echo \"Hello World\"\n\ngenerate:\n        @echo \"Creating empty text files...\"\n        touch file-{1..10}.txt\n\nclean:\n        @echo \"Cleaning up...\"\n        rm *.txt\n</pre>\n\n<p>\nThe make should call <tt>say_hello</tt> and <tt>generate</tt>\n\n<pre>\n$ make\nHello World\nCreating empty text files...\ntouch file-{1..10}.txt\n</pre>\n\n<p>\nIt is a good practice not to call clean in all or put it as the first target. clean should be called manually when cleaning is needed as a first argument to make:\n\n<pre>\n$ make clean\nCleaning up...\nrm *.txt\n</pre>\n\n<p>\nNow that you have an idea of how a basic makefile works and how to write a simple makefile, let's look at some more advanced examples.\n\n<h3>Something more real</h3>\n\n<p>Now lets try to create a simple Makefile that we can use to compile our programs:</p>\n<pre>all:\n    gcc main.c  -o hello\n</pre>\n\n<p>Now you can run:</p>\n\n<pre>make</pre>\n\nInstead of running GCC manually, the Makefile lets you compile <tt>main.c</tt> into the <tt>hello</tt> program. \n\n<p>In our example the only target in the Makefile is <tt>all</tt>. The <tt>make</tt> utility will try to resolve this target if no other targets are specified.<br />\n\t\tWe also see that there are no dependencies for target <tt>all</tt>, so <tt>make</tt> safely executes the system commands specified.</p>\n<p>Finally, make compiles the program according to the command line we gave it.</p>\n\n<h3>Using dependencies</h3>\n\n<p>Sometimes it is useful to use different targets. It makes the Makefile more modular and allows assembling a complex project from multiple pieces.<br />\nHere is an example:</p>\n\n<pre>all: hello\n\nhello: main.o \n    gcc main.o -o hello\n\nmain.o: main.c\n    gcc -c main.c\n\nclean:\n    rm *.o hello\n\n</pre>\n<p>Now we see that the target <tt>all</tt> has only one dependency (i.e., <tt>hello</tt>), but no system commands. In order for <tt>make</tt> to execute correctly, it has to meet all the dependencies of the called target.</p>\n\n<p>Each of the dependencies are searched through all the targets available and executed if found.</p>\n\n<p>In this example we see the target called <tt>clean</tt>. It is useful to have such target if you want to have a fast way to get rid of all the object files and executables.</p>\n\n<pre>make clean</pre>\n\n<h3>Using variables and comments</h3>\n\n<p>You can also use variables when writing Makefiles. It comes in handy in situations where you want to change the compiler, or compiler options.</p>\n<pre>\n# This is how you write comments\n# Use gcc as a compiler\nCC=gcc\n# CFLAGS will be the options we'll pass to the compiler\nCFLAGS=-Wall\n\nall: hello\n\nhello: main.o\n    $(CC) $(CFLAGS) main.o -o hello\n\nmain.o: main.c\n    $(CC) -c $(CFLAGS) main.c\n\nclean:\n    rm *.o hello\n\n</pre>\n\n<p>Variables can be very useful. To use them, just assign a value to a variable before you start writing your targets. After that, you can just use them with the dereference operator $(VAR).</p>\n\n<h2>If you want to know more...</h2>\n\n<p>With this brief introduction to Makefiles, you can create some very sophisticated mechanisms for compiling your projects. However, this is just the tip of the iceberg. More documentation is available here: <a href=\"http://www.gnu.org/software/make/manual/make.html\">Make documentation</a>.</p>\n\n<p>Here is an example of a more automated Makefile that you might use in one of your projects (not required for this homework). \n\n<pre>CC=gcc\n# Compiler flags\nCFLAGS=-Wall\n# Linker flags\nLDFLAGS=\n# You can add multiple source files here separated with spaces\nSOURCES=main.c\n\n# Replace .c with .o creating a list of object files\nOBJECTS=$(SOURCES:.c=.o)\n\n# Name executable \nEXECUTABLE=hello\n\nall: $(SOURCES) $(EXECUTABLE)\n    \n$(EXECUTABLE): $(OBJECTS) \n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n# Rule that tells make how to make an object file out of a .c file \n.c.o:\n    $(CC) -c $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm *.o $(EXECUTABLE)\n</pre>\n\n<h2>What to submit</h2> \n\nThree Makefiles you created to compile your hello example\n\n<h2>Part 3: Debugging programs with GDB</h2>\n\nOn UNIX systems the main debugger is GDB (GNU debugger). To be able to comfortably debug your code compile it with the -g option which will instruct the compiler to generate debug symbols (variable names, source lines, etc.) for the program. For example, change your Makefile to have\n\n<pre> \nCFLAGS=-Wall -g -m32 -fno-pic\n</pre>\n\nThis will compile your hello program with debugging symbols (<tt>-g</tt> flag), as a 32bit x86 executable (<tt>-m32</tt> flag), and for simplicity avoid generating position independent code (<tt> -fno-pic</tt> flag). Then you can start you program under control of gdb\n\n<pre>\ngdb hello\n</pre>\n\nThis starts gdb ready to execute your <tt>hello</tt> program. To get it running type the <tt>run</tt> command in the GDB command prompt (or <tt>r</tt> -- short for run):\n\n<pre>\ngdb\\> run\n</pre>\n\nNow the program runs and finished printing \"Hello world\". \n\n<p>\nGDB is a feature-rich debugger, and it will take you some time to learn all the features. Here is a couple of starting points:\n<a href=\"http://www.cs.cmu.edu/~gilpin/tutorial/#3.4\">GDB tutorial</a>, \n<a href=\"https://courses.cs.washington.edu/courses/cse378/97au/help/gdb-intro.html\">GDB intro</a> and <a href=\"https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf\">GDB Cheat Sheet</a>.\n\n<p>\nAt a high level you need only two main things: 1) breakpoints and 2) ability to examine data. Breakpoints can be set with the \"b\" command inside gdb.\n\n<h3>Breakpoints and single stepping</h3>\n\nJust to make debugging a bit more realistic lets add another function to our simple program. \nLets change it to compute a sum of numbers from 0 to n. You can do this by implementing the following function\n\n<pre>\nunsigned long sum(int n) {\n    int i;\n    unsigned long sum = 0;\n\n    for (i = 0; i < n; i++) {\n        sum = sum + i;\n    }\n\n    return sum;\n}\n</pre>\n\nand calling it from <pre>main()</pre>\n\n<pre>\nint main(void) {\n\n    unsigned long s;\n\n    s = sum(100);\n    printf(\"Hello world, the sum:%ld\\n\", s);\n    return 0;\n}\n</pre>\n\n\n<p>\nRunning the programs on its own is not that useful. Lets try setting a breakpoint on the \"main\" function to examine what the program is actually doing. \nFor that type <tt>break <function_name></tt> in the GDB command prompt or <tt>b</tt> and then run the program with <tt>r</tt>\n \n<pre>\n(gdb) break main\nBreakpoint 1 at 0x56b: file main.c, line 26.\n(gdb) r\nStarting program: ...  \n\nBreakpoint 1, main () at main.c:26\n26          s = sum(100);\n(gdb) \n</pre>\n\n<p>\nThe debugger stopped at the beginning of the <tt>main</tt> function (line 26 of <tt>main.c</tt>. You can examine the source code of the program by typing <tt>list</tt> or <tt>l</tt>\n\n<pre>\n(gdb) list\n21\n22      int main(void) {\n23\n24          unsigned long s;\n25\n26          s = sum(100);\n27          printf(\"Hello world, the sum:%ld\\n\", s);\n28          return 0;\n29      }\n30\n</pre>\n\n<p> Now you can execute the program line by line by typing <tt>next</tt> (execute next line, or <tt>n</tt> for short), and <tt>step</tt> (<tt>s</tt>) to step into a function. \n\nTry stepping into the <tt>sum</tt> function by running <tt>step</tt>\n\n<pre>\n(gdb) s\nsum (n=100) at main.c:13\n13          unsigned long sum = 0;\n</pre>\n\n<p>Here I'm inside the <tt>sum</tt> function, where I type <tt>l</tt> to list the source code, and then type <tt>n</tt> to execute it line by line (I type <tt>n</tt> once, and then simply hit \"Enter\" asking GDB to execute the last command for me\n\n<pre>\n(gdb) l\n8       #include <sys/stat.h>\n9       #include <sys/wait.h>\n10\n11      unsigned long sum(int n) {\n12          int i;\n13          unsigned long sum = 0;\n14\n15          for (i = 0; i < n; i++) {\n16              sum = sum + i;\n17          }\n(gdb) n\n15          for (i = 0; i < n; i++) {\n(gdb)\n16              sum = sum + i;\n(gdb)\n15          for (i = 0; i < n; i++) {\n(gdb)\n16              sum = sum + i;\n</pre>\n\n<h3>TUI: Graphical User Interface</h3>\n\nThe second most useful feature is the TUI mode that turns GDB into a real modern debugger. Here is a couple of links to <a href=\"https://stackoverflow.com/questions/10115540/gdb-split-view-with-code\">TUI</a>.\n\n<p>\nYou can switch into TUI by pressing Ctrl-X and then \"1\", or start gdb in TUI mode right away\n\n<pre>\n  gdb hello -tui\n</pre>\n\nOr by typing this in the gdb command prompt (this command doesn't work on Openlab, so you'll have to do <tt>Ctrl-X</tt> and then 1, but normally it works)\n\n<pre>\n(gdb) tui enable\n</pre>\n\n<p>\n\nStart the program from the begginging and single step it with <tt>n</tt> and <tt>s</tt>. The source code of the program will be scrolling in the TUI window in the top part of the screen. \n\n\n<h3>Examining data</h3>\n \n<p>\nYou can print values of variables with \"print\", e.g., print the values of <tt>i</tt> and <tt>sum</tt>\n\n<pre>\n  gdb\\> p i\n  gdb\\> p sum\n</pre>\n\n\n<h3>Conditional breakpoints</h3>\n\nWhile debugging programs it's often useful to see what the program is doing right before it crashes. One way to do this is to step through, one at a time, every statement of the program until we get to the point of execution where we want to see what is happening. This works, but sometimes you may want to just run to a particular section of code and stop execution at that point so you can examine data at that location.\n\n<p>GDB allows you to set conditional breakpoints. For example, lets break inside the loop of the <tt>sum</tt> function when the index <tt>i</tt> is equal to 50. I first list the source code to get the exact source lines and then set a brakpoint inside the <tt>main.c</tt> file at line 16 with <tt>break main.c:16</tt>\n\n<pre>\n(gdb) l\n11      unsigned long sum(int n) {\n12          int i;\n13          unsigned long sum = 0; \n14\n15          for (i = 0; i < n; i++) {\n16              sum = sum + i; \n17          }\n18\n19          return sum; \n20      }\n(gdb) break main.c:16\nBreakpoint 2 at 0x56555543: file main.c, line 16.\n</pre>\n\nThis breakpoint will trigger for every iteration of the loop. So if we want it to fire only when <tt>i</tt> is 50 we add the following condition. I use <tt>2</tt> as this is the number of the breakpoint that I set at line 16. \n\n<pre>\n(gdb) condition 2 i==50\n</pre>\n\n<p>I now continue execution of the program with the <tt>continue</tt> or <tt>c</tt> command. \n\n<pre>\n(gdb) c\nContinuing.\n\nBreakpoint 2, sum (n=100) at main.c:16\n16              sum = sum + i; \n</pre>\n\n<p>\nWhen the breakpoint is hit I check that the value of i is really 50\n<pre>\n(gdb) p i\n$1 = 50\n(gdb) \n</pre>\n\n<h3>Exploring crashes</h3>\n\nNow, lets take a look at how you can use GDB to debug your crashing programs. First, lets generate a program that crashes. \n\nAdd a global variable <tt>a[32]</tt> to your program (it's an array of 32 integers). \n<pre>\nint a[32];\n</pre>\n\nLets then add a function that makes an out of bounds array access\n\n<pre>\nunsigned long crash_array(int n) {\n    int i;\n    unsigned long sum = 0;\n\n    for (i = 0; i < n; i++) {\n        sum = sum + a[i];\n    }\n\n    return sum;\n}\n</pre>\n\nIf you invoke this function with <tt>n</tt> larger than 31 it will crash (Note, you might get lucky and it will not crash, i.e., not all out of bounds accesses cause a crash in C programs). To be \nsafe lets invoke it with n equal to 10,000.\n\n<pre>\ns = crash_array(100000);\nprintf(\"crash array sum:%ld\\n\", s);    \n</pre>\n\nIf you make this program and run it, it will crash\n<pre>\n./hello\nHello world, the sum:4950\nSegmentation fault (core dumped)\n</pre>\n\nNow, to understand the crash you can run it under gdb: \n\n<pre>\n(gdb) r\nStarting program: /home/aburtsev/doc/OS_Stuff/Flux/git/personal/classes/os-class/cs143a/hw/hello\nHello world, the sum:4950\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x56555566 in crash_array (n=100000) at main-full.c:18\n18\t        sum = sum + a[i];\n</pre>\n\nYou can use the <tt>backtrace</tt> (<tt>bt</tt>) command to look at the backtrace (a chain of function invocations leading to the crash): \n\n<pre>\n(gdb) bt\n#0  0x56555566 in crash_array (n=100000) at main-full.c:18\n#1  0x565555ec in main () at main-full.c:45\n</pre>\n\nHere, the GDB tells you that <tt>crash_array</tt> got a segfault at line 18 in <tt>main-full.c</tt>. You see that there are two stack frames available (0 for <tt>main</tt> and 1 for <tt>crash_array</tt>). \n\nYou can use the <tt>frame <frame_number></tt> (<tt>f</tt>) command to choose any of the frames and inspect it. For example, lets choose frame <tt>#0</tt> and list the crashing code with the <tt>list</tt> command\n\n<pre>\n(gdb) f 0\n#0  0x56555566 in crash_array (n=100000) at main-full.c:18\n18\t        sum = sum + a[i];\n(gdb) l\n13\tunsigned long crash_array(int n) {\n14\t    int i;\n15\t    unsigned long sum = 0;\n16\n17\t    for (i = 0; i < n; i++) {\n18\t        sum = sum + a[i];\n19\t    }\n20\n21\t    return sum;\n22\t}\n</pre>\n\nWe know that line 18 is the crashing line. We can print the values of the local variable <tt>i</tt>\n\n<pre>\n(gdb) p i\n$1 = 35824\n</pre>\n\nIt is equal to 35824. This should give you enough information for why you crashed. \n\n<p>Now fix the <tt>crash_array</tt> function to prevent the crash. \n\n<h3>What to submit</h3>\n\nThe Makefile and the updated main.c program. \n\n<h2>Part 4: Exploring assembly code</h2>\n\nIn this part of the homework you will explore assembly code of the <tt>sum</tt> function. \n\n<p>Re-start GDB and set the breakpoint on the <tt>sum</tt> function\n\n<pre>\n(gdb) b sum\nBreakpoint 1 at 0x533: file main.c, line 13.\n(gdb) r\nStarting program: /home/aburtsev/doc/OS_Stuff/Flux/git/personal/classes/os-class/cs143a/hw/hello \n\nBreakpoint 1, sum (n=100) at main.c:13\n13          unsigned long sum = 0; \n</pre>\n\nGDB can disassemble the code of the program with the <tt>disassemble</tt> (or <tt>disas</tt>) command\n<pre>\n(gdb) disas\nDump of assembler code for function sum:\n   0x5655552d <+0>:     push   %ebp\n   0x5655552e <+1>:     mov    %esp,%ebp\n   0x56555530 <+3>:     sub    $0x10,%esp\n=> 0x56555533 <+6>:     movl   $0x0,-0x4(%ebp)\n   0x5655553a <+13>:    movl   $0x0,-0x8(%ebp)\n   0x56555541 <+20>:    jmp    0x5655554d <sum+32>\n   0x56555543 <+22>:    mov    -0x8(%ebp),%eax\n   0x56555546 <+25>:    add    %eax,-0x4(%ebp)\n   0x56555549 <+28>:    addl   $0x1,-0x8(%ebp)\n   0x5655554d <+32>:    mov    -0x8(%ebp),%eax\n   0x56555550 <+35>:    cmp    0x8(%ebp),%eax\n   0x56555553 <+38>:    jl     0x56555543 <sum+22>\n   0x56555555 <+40>:    mov    -0x4(%ebp),%eax\n   0x56555558 <+43>:    leave  \n   0x56555559 <+44>:    ret    \nEnd of assembler dump.\n(gdb) \n</pre>\n\n<p>Unfortunately, the default syntax for the disassembly is AT&T. So the first thing you do is switch to Intel syntax we were using in class. \nInvoke the <tt>set disassembly-flavor intel</tt> command and disassembly the function again\n\n<pre>\n(gdb) set disassembly-flavor intel\n(gdb) disas\nDump of assembler code for function sum:\n   0x5655552d <+0>:     push   ebp\n   0x5655552e <+1>:     mov    ebp,esp\n   0x56555530 <+3>:     sub    esp,0x10\n=> 0x56555533 <+6>:     mov    DWORD PTR [ebp-0x4],0x0\n   0x5655553a <+13>:    mov    DWORD PTR [ebp-0x8],0x0\n   0x56555541 <+20>:    jmp    0x5655554d <sum+32>\n   0x56555543 <+22>:    mov    eax,DWORD PTR [ebp-0x8]\n   0x56555546 <+25>:    add    DWORD PTR [ebp-0x4],eax\n   0x56555549 <+28>:    add    DWORD PTR [ebp-0x8],0x1\n   0x5655554d <+32>:    mov    eax,DWORD PTR [ebp-0x8]\n   0x56555550 <+35>:    cmp    eax,DWORD PTR [ebp+0x8]\n   0x56555553 <+38>:    jl     0x56555543 <sum+22>\n   0x56555555 <+40>:    mov    eax,DWORD PTR [ebp-0x4]\n   0x56555558 <+43>:    leave  \n   0x56555559 <+44>:    ret    \nEnd of assembler dump.\n(gdb) \n</pre>\n\n<b>Your assignment is</b> to explain every line of the assembly dump and submit it as a text file. \n\nNote, while you can understand what the assembly code is doing, you can also use GDB to step through the assembly code of the program. \nYou can simply type\n\n<pre>\n(gdb) layout asm\n</pre>\n\nto switch TUI to the assmebly mode. Then you can use two new GDB commands: <tt>nexti</tt> (<tt>ni</tt>) and <tt>stepi</tt> (<tt>si</tt>) for stepping \nthrough the assembly instructions (<i>i</i> stands for \"instruction\", e.g., next instruction and step instrucion). \n\n<pre>\n(gdb) si\n</pre>\n\n<p>You can do the split layout to show both assembly and the C source code windows at the same time. \n\n<pre>\n(gdb) layout split\n</pre>\n\n\nYou can also show the registers on the screen (don't forget the <a href=\"https://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html\">list of TUI commands</a> --- they can be very handy). \n\n<pre>\n(gdb) layout regs\n</pre>\n\n<h3>What to submit</h3>\n\nA text file that explains every line of the assembly dump.  \n\n<h2>Part 5: Exploring calling conventions</h2>\n\nIn this final part of the homework you will explore the calling conventions for passing the arguments on the stack. \n\n<p>Re-start GDB and set the breakpoint on the <tt>sum</tt> function, and run the program. \n\n<pre>\n(gdb) b sum \nBreakpoint 1 at 0x533: file main.c, line 13.\n(gdb) r\nStarting program: /home/aburtsev/doc/OS_Stuff/Flux/git/personal/classes/os-class/cs143a/hw/hello \n\nBreakpoint 1, sum (n=100) at main.c:13\n13          unsigned long sum = 0; \n(gdb)\n</pre>\n\nUse the <tt>info</tt> command to see the content of the registers\n\n<pre>\n(gdb) info regs\nUndefined info command: \"regs\".  Try \"help info\".\n(gdb) info reg\neax            0xf7fb0dd8       -134541864\necx            0xffffc8c0       -14144\nedx            0xffffc8e4       -14108\nebx            0x0      0\nesp            0xffffc874       0xffffc874\nebp            0xffffc884       0xffffc884\nesi            0xf7faf000       -134549504\nedi            0x0      0\neip            0x56555533       0x56555533 <sum+6>\neflags         0x286    [ PF SF IF ]\ncs             0x23     35\nss             0x2b     43\nds             0x2b     43\nes             0x2b     43\nfs             0x0      0\ngs             0x63     99\n</pre>\n\nUse the <tt>x</tt> command to inspect the stack\n\n<pre>\n(gdb)  x/24x $esp\n0xffffc874:     0xf7faf000      0x00000000      0xf7e0760b      0xf7faf3fc\n0xffffc884:     0xffffc8a8      0x56555572      0x00000064      0x00000001\n0xffffc894:     0xffffc954      0xffffc95c      0x565555c1      0xf7fe59b0\n0xffffc8a4:     0xffffc8c0      0x00000000      0xf7defe81      0xf7faf000\n0xffffc8b4:     0xf7faf000      0x00000000      0xf7defe81      0x00000001\n0xffffc8c4:     0xffffc954      0xffffc95c      0xffffc8e4      0x00000001\n</pre>\n\n<p><b>Explain every value from the dump that you get (similar to the one above but generated on your machine)</b>, i.e., which one is a local \nvariable inside <tt>sum</tt>, which is the frame pointer, what are the arguments to <tt>sum</tt> and \nso on. The more values you can exaplain the better. \n\n<p><b>Hints:</b> start from <tt>main</tt>, i.e., set a breakpoint on <tt>main</tt> and see how the values \non the stack are changing, step through <tt>main</tt> and see what gets pushed on the stack. \n\n<p><b>Note:</b> GCC generates the code that keeps the stack aligned at 16 bytes, hence instead of allocating 4 bytes \nfor the local variable in <tt>sum</tt> it allocates 16. \n\n<h3>What to submit</h3>\n\nSubmit a text file explaining every value on the stack. \n\n\n<h2>Submit your work</h2>\n\n\n<p>\nSubmit your solution through \nGradescope <a href=\"https://www.gradescope.com/courses/68891\">Gradescope CS143A Principles of Operating Systems</a>. Place each part of the assignment into folders with name part2, part3, part4 or part5, then pack it into a zip archive and submit it. Please name makefiles as Makefile1, Makefile2, Makefile3 for the part 2. Please submit .txt files for parts 4 and 5. You can resubmit as many times as you wish. If you have any problems with the structure the autograder will tell you. Part 4 and 5 of the assignment will be graded manually after the deadline.\n\nThe structure of the zip file should be the following:\n<pre>\n/\n  - /part2\n    - Makefile1\n    - Makefile2\n    - Makefile3\n    - main.c\n  - /part3\n    - Makfile\n    - main.c\n  - /part4\n    - explaination.txt\n  - /part5\n    - explaination.txt\n</pre>\n\n\n\t</TD>\t\t\t\n\t</TR>\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD COLSPAN=\"4\">\n\t\t<DIV ID=\"tech\">Updated: October, 2019</DIV>\n\t</TD>\n\t</TR>\n\t</TABLE>\n</BODY>\n</HTML>\n\n", "encoding": "ascii"}