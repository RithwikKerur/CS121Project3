{"url": "https://www.ics.uci.edu/~dan/class/267P/datasets/calgary/progc", "content": "/* \n * Compress - data compression program \n */\n#define\tmin(a,b)\t((a>b) ? b : a)\n\n/*\n * machine variants which require cc -Dmachine:  pdp11, z8000, pcxt\n */\n\n/*\n * Set USERMEM to the maximum amount of physical user memory available\n * in bytes.  USERMEM is used to determine the maximum BITS that can be used\n * for compression.\n *\n * SACREDMEM is the amount of physical memory saved for others; compress\n * will hog the rest.\n */\n#ifndef SACREDMEM\n#define SACREDMEM\t0\n#endif\n\n#ifndef USERMEM\n# define USERMEM \t450000\t/* default user memory */\n#endif\n\n#ifdef interdata\t\t/* (Perkin-Elmer) */\n#define SIGNED_COMPARE_SLOW\t/* signed compare is slower than unsigned */\n#endif\n\n#ifdef pdp11\n# define BITS \t12\t/* max bits/code for 16-bit machine */\n# define NO_UCHAR\t/* also if \"unsigned char\" functions as signed char */\n# undef USERMEM \n#endif /* pdp11 */\t/* don't forget to compile with -i */\n\n#ifdef z8000\n# define BITS \t12\n# undef vax\t\t/* weird preprocessor */\n# undef USERMEM \n#endif /* z8000 */\n\n#ifdef pcxt\n# define BITS   12\n# undef USERMEM\n#endif /* pcxt */\n\n#ifdef USERMEM\n# if USERMEM >= (433484+SACREDMEM)\n#  define PBITS\t16\n# else\n#  if USERMEM >= (229600+SACREDMEM)\n#   define PBITS\t15\n#  else\n#   if USERMEM >= (127536+SACREDMEM)\n#    define PBITS\t14\n#   else\n#    if USERMEM >= (73464+SACREDMEM)\n#     define PBITS\t13\n#    else\n#     define PBITS\t12\n#    endif\n#   endif\n#  endif\n# endif\n# undef USERMEM\n#endif /* USERMEM */\n\n#ifdef PBITS\t\t/* Preferred BITS for this memory size */\n# ifndef BITS\n#  define BITS PBITS\n# endif BITS\n#endif /* PBITS */\n\n#if BITS == 16\n# define HSIZE\t69001\t\t/* 95% occupancy */\n#endif\n#if BITS == 15\n# define HSIZE\t35023\t\t/* 94% occupancy */\n#endif\n#if BITS == 14\n# define HSIZE\t18013\t\t/* 91% occupancy */\n#endif\n#if BITS == 13\n# define HSIZE\t9001\t\t/* 91% occupancy */\n#endif\n#if BITS <= 12\n# define HSIZE\t5003\t\t/* 80% occupancy */\n#endif\n\n#ifdef M_XENIX\t\t\t/* Stupid compiler can't handle arrays with */\n# if BITS == 16\t\t\t/* more than 65535 bytes - so we fake it */\n#  define XENIX_16\n# else\n#  if BITS > 13\t\t\t/* Code only handles BITS = 12, 13, or 16 */\n#   define BITS\t13\n#  endif\n# endif\n#endif\n\n/*\n * a code_int must be able to hold 2**BITS values of type int, and also -1\n */\n#if BITS > 15\ntypedef long int\tcode_int;\n#else\ntypedef int\t\tcode_int;\n#endif\n\n#ifdef SIGNED_COMPARE_SLOW\ntypedef unsigned long int count_int;\ntypedef unsigned short int count_short;\n#else\ntypedef long int\t  count_int;\n#endif\n\n#ifdef NO_UCHAR\n typedef char\tchar_type;\n#else\n typedef\tunsigned char\tchar_type;\n#endif /* UCHAR */\nchar_type magic_header[] = { \"\\037\\235\" };\t/* 1F 9D */\n\n/* Defines for third byte of header */\n#define BIT_MASK\t0x1f\n#define BLOCK_MASK\t0x80\n/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is\n   a fourth header byte (for expansion).\n*/\n#define INIT_BITS 9\t\t\t/* initial number of bits/code */\n\n/*\n * compress.c - File compression ala IEEE Computer, June 1984.\n *\n * Authors:\tSpencer W. Thomas\t(decvax!harpo!utah-cs!utah-gr!thomas)\n *\t\tJim McKie\t\t(decvax!mcvax!jim)\n *\t\tSteve Davies\t\t(decvax!vax135!petsd!peora!srd)\n *\t\tKen Turkowski\t\t(decvax!decwrl!turtlevax!ken)\n *\t\tJames A. Woods\t\t(decvax!ihnp4!ames!jaw)\n *\t\tJoe Orost\t\t(decvax!vax135!petsd!joe)\n *\n * $Header: compress.c,v 4.0 85/07/30 12:50:00 joe Release $\n * $Log:\tcompress.c,v $\n * Revision 4.0  85/07/30  12:50:00  joe\n * Removed ferror() calls in output routine on every output except first.\n * Prepared for release to the world.\n * \n * Revision 3.6  85/07/04  01:22:21  joe\n * Remove much wasted storage by overlaying hash table with the tables\n * used by decompress: tab_suffix[1<<BITS], stack[8000].  Updated USERMEM\n * computations.  Fixed dump_tab() DEBUG routine.\n *\n * Revision 3.5  85/06/30  20:47:21  jaw\n * Change hash function to use exclusive-or.  Rip out hash cache.  These\n * speedups render the megamemory version defunct, for now.  Make decoder\n * stack global.  Parts of the RCS trunks 2.7, 2.6, and 2.1 no longer apply.\n *\n * Revision 3.4  85/06/27  12:00:00  ken\n * Get rid of all floating-point calculations by doing all compression ratio\n * calculations in fixed point.\n *\n * Revision 3.3  85/06/24  21:53:24  joe\n * Incorporate portability suggestion for M_XENIX.  Got rid of text on #else\n * and #endif lines.  Cleaned up #ifdefs for vax and interdata.\n *\n * Revision 3.2  85/06/06  21:53:24  jaw\n * Incorporate portability suggestions for Z8000, IBM PC/XT from mailing list.\n * Default to \"quiet\" output (no compression statistics).\n *\n * Revision 3.1  85/05/12  18:56:13  jaw\n * Integrate decompress() stack speedups (from early pointer mods by McKie).\n * Repair multi-file USERMEM gaffe.  Unify 'force' flags to mimic semantics\n * of SVR2 'pack'.  Streamline block-compress table clear logic.  Increase \n * output byte count by magic number size.\n * \n * Revision 3.0   84/11/27  11:50:00  petsd!joe\n * Set HSIZE depending on BITS.  Set BITS depending on USERMEM.  Unrolled\n * loops in clear routines.  Added \"-C\" flag for 2.0 compatibility.  Used\n * unsigned compares on Perkin-Elmer.  Fixed foreground check.\n *\n * Revision 2.7   84/11/16  19:35:39  ames!jaw\n * Cache common hash codes based on input statistics; this improves\n * performance for low-density raster images.  Pass on #ifdef bundle\n * from Turkowski.\n *\n * Revision 2.6   84/11/05  19:18:21  ames!jaw\n * Vary size of hash tables to reduce time for small files.\n * Tune PDP-11 hash function.\n *\n * Revision 2.5   84/10/30  20:15:14  ames!jaw\n * Junk chaining; replace with the simpler (and, on the VAX, faster)\n * double hashing, discussed within.  Make block compression standard.\n *\n * Revision 2.4   84/10/16  11:11:11  ames!jaw\n * Introduce adaptive reset for block compression, to boost the rate\n * another several percent.  (See mailing list notes.)\n *\n * Revision 2.3   84/09/22  22:00:00  petsd!joe\n * Implemented \"-B\" block compress.  Implemented REVERSE sorting of tab_next.\n * Bug fix for last bits.  Changed fwrite to putchar loop everywhere.\n *\n * Revision 2.2   84/09/18  14:12:21  ames!jaw\n * Fold in news changes, small machine typedef from thomas,\n * #ifdef interdata from joe.\n *\n * Revision 2.1   84/09/10  12:34:56  ames!jaw\n * Configured fast table lookup for 32-bit machines.\n * This cuts user time in half for b <= FBITS, and is useful for news batching\n * from VAX to PDP sites.  Also sped up decompress() [fwrite->putc] and\n * added signal catcher [plus beef in writeerr()] to delete effluvia.\n *\n * Revision 2.0   84/08/28  22:00:00  petsd!joe\n * Add check for foreground before prompting user.  Insert maxbits into\n * compressed file.  Force file being uncompressed to end with \".Z\".\n * Added \"-c\" flag and \"zcat\".  Prepared for release.\n *\n * Revision 1.10  84/08/24  18:28:00  turtlevax!ken\n * Will only compress regular files (no directories), added a magic number\n * header (plus an undocumented -n flag to handle old files without headers),\n * added -f flag to force overwriting of possibly existing destination file,\n * otherwise the user is prompted for a response.  Will tack on a .Z to a\n * filename if it doesn't have one when decompressing.  Will only replace\n * file if it was compressed.\n *\n * Revision 1.9  84/08/16  17:28:00  turtlevax!ken\n * Removed scanargs(), getopt(), added .Z extension and unlimited number of\n * filenames to compress.  Flags may be clustered (-Ddvb12) or separated\n * (-D -d -v -b 12), or combination thereof.  Modes and other status is\n * copied with copystat().  -O bug for 4.2 seems to have disappeared with\n * 1.8.\n *\n * Revision 1.8  84/08/09  23:15:00  joe\n * Made it compatible with vax version, installed jim's fixes/enhancements\n *\n * Revision 1.6  84/08/01  22:08:00  joe\n * Sped up algorithm significantly by sorting the compress chain.\n *\n * Revision 1.5  84/07/13  13:11:00  srd\n * Added C version of vax asm routines.  Changed structure to arrays to\n * save much memory.  Do unsigned compares where possible (faster on\n * Perkin-Elmer)\n *\n * Revision 1.4  84/07/05  03:11:11  thomas\n * Clean up the code a little and lint it.  (Lint complains about all\n * the regs used in the asm, but I'm not going to \"fix\" this.)\n *\n * Revision 1.3  84/07/05  02:06:54  thomas\n * Minor fixes.\n *\n * Revision 1.2  84/07/05  00:27:27  thomas\n * Add variable bit length output.\n *\n */\nstatic char rcs_ident[] = \n\"$Header: compress.c,v 4.0 85/07/30 12:50:00 joe Release $\";\n\n#include <stdio.h>\n#include <ctype.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#define ARGVAL() (*++(*argv) || (--argc && *++argv))\n\nint n_bits;\t\t\t\t/* number of bits/code */\nint maxbits = BITS;\t\t\t/* user settable max # bits/code */\ncode_int maxcode;\t\t\t/* maximum code, given n_bits */\ncode_int maxmaxcode = 1 << BITS;\t/* should NEVER generate this code */\n#ifdef COMPATIBLE\t\t/* But wrong! */\n# define MAXCODE(n_bits)\t(1 << (n_bits) - 1)\n#else\n# define MAXCODE(n_bits)\t((1 << (n_bits)) - 1)\n#endif /* COMPATIBLE */\n\n#ifdef XENIX_16\ncount_int htab0[8192];\ncount_int htab1[8192];\ncount_int htab2[8192];\ncount_int htab3[8192];\ncount_int htab4[8192];\ncount_int htab5[8192];\ncount_int htab6[8192];\ncount_int htab7[8192];\ncount_int htab8[HSIZE-65536];\ncount_int * htab[9] = {\n\thtab0, htab1, htab2, htab3, htab4, htab5, htab6, htab7, htab8 };\n\n#define htabof(i)\t(htab[(i) >> 13][(i) & 0x1fff])\nunsigned short code0tab[16384];\nunsigned short code1tab[16384];\nunsigned short code2tab[16384];\nunsigned short code3tab[16384];\nunsigned short code4tab[16384];\nunsigned short * codetab[5] = {\n\tcode0tab, code1tab, code2tab, code3tab, code4tab };\n\n#define codetabof(i)\t(codetab[(i) >> 14][(i) & 0x3fff])\n\n#else\t/* Normal machine */\ncount_int htab [HSIZE];\nunsigned short codetab [HSIZE];\n#define htabof(i)\thtab[i]\n#define codetabof(i)\tcodetab[i]\n#endif\t/* XENIX_16 */\ncode_int hsize = HSIZE;\t\t\t/* for dynamic table sizing */\ncount_int fsize;\n\n/*\n * To save much memory, we overlay the table used by compress() with those\n * used by decompress().  The tab_prefix table is the same size and type\n * as the codetab.  The tab_suffix table needs 2**BITS characters.  We\n * get this from the beginning of htab.  The output stack uses the rest\n * of htab, and contains characters.  There is plenty of room for any\n * possible stack (stack used to be 8000 characters).\n */\n\n#define tab_prefixof(i)\tcodetabof(i)\n#ifdef XENIX_16\n# define tab_suffixof(i)\t((char_type *)htab[(i)>>15])[(i) & 0x7fff]\n# define de_stack\t\t((char_type *)(htab2))\n#else\t/* Normal machine */\n# define tab_suffixof(i)\t((char_type *)(htab))[i]\n# define de_stack\t\t((char_type *)&tab_suffixof(1<<BITS))\n#endif\t/* XENIX_16 */\n\ncode_int free_ent = 0;\t\t\t/* first unused entry */\nint exit_stat = 0;\n\ncode_int getcode();\n\nUsage() {\n#ifdef DEBUG\nfprintf(stderr,\"Usage: compress [-dDVfc] [-b maxbits] [file ...]\\n\");\n}\nint debug = 0;\n#else\nfprintf(stderr,\"Usage: compress [-dfvcV] [-b maxbits] [file ...]\\n\");\n}\n#endif /* DEBUG */\nint nomagic = 0;\t/* Use a 3-byte magic number header, unless old file */\nint zcat_flg = 0;\t/* Write output on stdout, suppress messages */\nint quiet = 1;\t\t/* don't tell me about compression */\n\n/*\n * block compression parameters -- after all codes are used up,\n * and compression rate changes, start over.\n */\nint block_compress = BLOCK_MASK;\nint clear_flg = 0;\nlong int ratio = 0;\n#define CHECK_GAP 10000\t/* ratio check interval */\ncount_int checkpoint = CHECK_GAP;\n/*\n * the next two codes should not be changed lightly, as they must not\n * lie within the contiguous general code space.\n */ \n#define FIRST\t257\t/* first free entry */\n#define\tCLEAR\t256\t/* table clear output code */\n\nint force = 0;\nchar ofname [100];\n#ifdef DEBUG\nint verbose = 0;\n#endif /* DEBUG */\nint (*bgnd_flag)();\n\nint do_decomp = 0;\n\n/*****************************************************************\n * TAG( main )\n *\n * Algorithm from \"A Technique for High Performance Data Compression\",\n * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.\n *\n * Usage: compress [-dfvc] [-b bits] [file ...]\n * Inputs:\n *\t-d:\t    If given, decompression is done instead.\n *\n *      -c:         Write output on stdout, don't remove original.\n *\n *      -b:         Parameter limits the max number of bits/code.\n *\n *\t-f:\t    Forces output file to be generated, even if one already\n *\t\t    exists, and even if no space is saved by compressing.\n *\t\t    If -f is not used, the user will be prompted if stdin is\n *\t\t    a tty, otherwise, the output file will not be overwritten.\n *\n *      -v:\t    Write compression statistics\n *\n * \tfile ...:   Files to be compressed.  If none specified, stdin\n *\t\t    is used.\n * Outputs:\n *\tfile.Z:\t    Compressed form of file with same mode, owner, and utimes\n * \tor stdout   (if stdin used as input)\n *\n * Assumptions:\n *\tWhen filenames are given, replaces with the compressed version\n *\t(.Z suffix) only if the file decreases in size.\n * Algorithm:\n * \tModified Lempel-Ziv method (LZW).  Basically finds common\n * substrings and replaces them with a variable size code.  This is\n * deterministic, and can be done on the fly.  Thus, the decompression\n * procedure needs no input table, but tracks the way the table was built.\n */\n\nmain( argc, argv )\nregister int argc; char **argv;\n{\n    int overwrite = 0;\t/* Do not overwrite unless given -f flag */\n    char tempname[100];\n    char **filelist, **fileptr;\n    char *cp, *rindex(), *malloc();\n    struct stat statbuf;\n    extern onintr(), oops();\n\n\n    if ( (bgnd_flag = signal ( SIGINT, SIG_IGN )) != SIG_IGN ) {\n\tsignal ( SIGINT, onintr );\n\tsignal ( SIGSEGV, oops );\n    }\n\n#ifdef COMPATIBLE\n    nomagic = 1;\t/* Original didn't have a magic number */\n#endif /* COMPATIBLE */\n\n    filelist = fileptr = (char **)(malloc(argc * sizeof(*argv)));\n    *filelist = NULL;\n\n    if((cp = rindex(argv[0], '/')) != 0) {\n\tcp++;\n    } else {\n\tcp = argv[0];\n    }\n    if(strcmp(cp, \"uncompress\") == 0) {\n\tdo_decomp = 1;\n    } else if(strcmp(cp, \"zcat\") == 0) {\n\tdo_decomp = 1;\n\tzcat_flg = 1;\n    }\n\n#ifdef BSD4_2\n    /* 4.2BSD dependent - take it out if not */\n    setlinebuf( stderr );\n#endif /* BSD4_2 */\n\n    /* Argument Processing\n     * All flags are optional.\n     * -D => debug\n     * -V => print Version; debug verbose\n     * -d => do_decomp\n     * -v => unquiet\n     * -f => force overwrite of output file\n     * -n => no header: useful to uncompress old files\n     * -b maxbits => maxbits.  If -b is specified, then maxbits MUST be\n     *\t    given also.\n     * -c => cat all output to stdout\n     * -C => generate output compatible with compress 2.0.\n     * if a string is left, must be an input filename.\n     */\n    for (argc--, argv++; argc > 0; argc--, argv++) {\n\tif (**argv == '-') {\t/* A flag argument */\n\t    while (*++(*argv)) {\t/* Process all flags in this arg */\n\t\tswitch (**argv) {\n#ifdef DEBUG\n\t\t    case 'D':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\t    case 'V':\n\t\t\tverbose = 1;\n\t\t\tversion();\n\t\t\tbreak;\n#else\n\t\t    case 'V':\n\t\t\tversion();\n\t\t\tbreak;\n#endif /* DEBUG */\n\t\t    case 'v':\n\t\t\tquiet = 0;\n\t\t\tbreak;\n\t\t    case 'd':\n\t\t\tdo_decomp = 1;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t    case 'F':\n\t\t\toverwrite = 1;\n\t\t\tforce = 1;\n\t\t\tbreak;\n\t\t    case 'n':\n\t\t\tnomagic = 1;\n\t\t\tbreak;\n\t\t    case 'C':\n\t\t\tblock_compress = 0;\n\t\t\tbreak;\n\t\t    case 'b':\n\t\t\tif (!ARGVAL()) {\n\t\t\t    fprintf(stderr, \"Missing maxbits\\n\");\n\t\t\t    Usage();\n\t\t\t    exit(1);\n\t\t\t}\n\t\t\tmaxbits = atoi(*argv);\n\t\t\tgoto nextarg;\n\t\t    case 'c':\n\t\t\tzcat_flg = 1;\n\t\t\tbreak;\n\t\t    case 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\t    default:\n\t\t\tfprintf(stderr, \"Unknown flag: '%c'; \", **argv);\n\t\t\tUsage();\n\t\t\texit(1);\n\t\t}\n\t    }\n\t}\n\telse {\t\t/* Input file name */\n\t    *fileptr++ = *argv;\t/* Build input file list */\n\t    *fileptr = NULL;\n\t    /* process nextarg; */\n\t}\n\tnextarg: continue;\n    }\n\n    if(maxbits < INIT_BITS) maxbits = INIT_BITS;\n    if (maxbits > BITS) maxbits = BITS;\n    maxmaxcode = 1 << maxbits;\n\n    if (*filelist != NULL) {\n\tfor (fileptr = filelist; *fileptr; fileptr++) {\n\t    exit_stat = 0;\n\t    if (do_decomp != 0) {\t\t\t/* DECOMPRESSION */\n\t\t/* Check for .Z suffix */\n\t\tif (strcmp(*fileptr + strlen(*fileptr) - 2, \".Z\") != 0) {\n\t\t    /* No .Z: tack one on */\n\t\t    strcpy(tempname, *fileptr);\n\t\t    strcat(tempname, \".Z\");\n\t\t    *fileptr = tempname;\n\t\t}\n\t\t/* Open input file */\n\t\tif ((freopen(*fileptr, \"r\", stdin)) == NULL) {\n\t\t\tperror(*fileptr); continue;\n\t\t}\n\t\t/* Check the magic number */\n\t\tif (nomagic == 0) {\n\t\t    if ((getchar() != (magic_header[0] & 0xFF))\n\t\t     || (getchar() != (magic_header[1] & 0xFF))) {\n\t\t\tfprintf(stderr, \"%s: not in compressed format\\n\",\n\t\t\t    *fileptr);\n\t\t    continue;\n\t\t    }\n\t\t    maxbits = getchar();\t/* set -b from file */\n\t\t    block_compress = maxbits & BLOCK_MASK;\n\t\t    maxbits &= BIT_MASK;\n\t\t    maxmaxcode = 1 << maxbits;\n\t\t    if(maxbits > BITS) {\n\t\t\tfprintf(stderr,\n\t\t\t\"%s: compressed with %d bits, can only handle %d bits\\n\",\n\t\t\t*fileptr, maxbits, BITS);\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\t/* Generate output filename */\n\t\tstrcpy(ofname, *fileptr);\n\t\tofname[strlen(*fileptr) - 2] = '\\0';  /* Strip off .Z */\n\t    } else {\t\t\t\t\t/* COMPRESSION */\n\t\tif (strcmp(*fileptr + strlen(*fileptr) - 2, \".Z\") == 0) {\n\t\t    \tfprintf(stderr, \"%s: already has .Z suffix -- no change\\n\",\n\t\t\t    *fileptr);\n\t\t    continue;\n\t\t}\n\t\t/* Open input file */\n\t\tif ((freopen(*fileptr, \"r\", stdin)) == NULL) {\n\t\t    perror(*fileptr); continue;\n\t\t}\n\t\tstat ( *fileptr, &statbuf );\n\t\tfsize = (long) statbuf.st_size;\n\t\t/*\n\t\t * tune hash table size for small files -- ad hoc,\n\t\t * but the sizes match earlier #defines, which\n\t\t * serve as upper bounds on the number of output codes. \n\t\t */\n\t\thsize = HSIZE;\n\t\tif ( fsize < (1 << 12) )\n\t\t    hsize = min ( 5003, HSIZE );\n\t\telse if ( fsize < (1 << 13) )\n\t\t    hsize = min ( 9001, HSIZE );\n\t\telse if ( fsize < (1 << 14) )\n\t\t    hsize = min ( 18013, HSIZE );\n\t\telse if ( fsize < (1 << 15) )\n\t\t    hsize = min ( 35023, HSIZE );\n\t\telse if ( fsize < 47000 )\n\t\t    hsize = min ( 50021, HSIZE );\n\n\t\t/* Generate output filename */\n\t\tstrcpy(ofname, *fileptr);\n#ifndef BSD4_2\t\t/* Short filenames */\n\t\tif ((cp=rindex(ofname,'/')) != NULL)\tcp++;\n\t\telse\t\t\t\t\tcp = ofname;\n\t\tif (strlen(cp) > 12) {\n\t\t    fprintf(stderr,\"%s: filename too long to tack on .Z\\n\",cp);\n\t\t    continue;\n\t\t}\n#endif  /* BSD4_2\t\tLong filenames allowed */\n\t\tstrcat(ofname, \".Z\");\n\t    }\n\t    /* Check for overwrite of existing file */\n\t    if (overwrite == 0 && zcat_flg == 0) {\n\t\tif (stat(ofname, &statbuf) == 0) {\n\t\t    char response[2];\n\t\t    response[0] = 'n';\n\t\t    fprintf(stderr, \"%s already exists;\", ofname);\n\t\t    if (foreground()) {\n\t\t\tfprintf(stderr, \" do you wish to overwrite %s (y or n)? \",\n\t\t\tofname);\n\t\t\tfflush(stderr);\n\t\t\tread(2, response, 2);\n\t\t\twhile (response[1] != '\\n') {\n\t\t\t    if (read(2, response+1, 1) < 0) {\t/* Ack! */\n\t\t\t\tperror(\"stderr\"); break;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (response[0] != 'y') {\n\t\t\tfprintf(stderr, \"\\tnot overwritten\\n\");\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t    }\n\t    if(zcat_flg == 0) {\t\t/* Open output file */\n\t\tif (freopen(ofname, \"w\", stdout) == NULL) {\n\t\t    perror(ofname);\n\t\t    continue;\n\t\t}\n\t\tif(!quiet)\n\t\t\tfprintf(stderr, \"%s: \", *fileptr);\n\t    }\n\n\t    /* Actually do the compression/decompression */\n\t    if (do_decomp == 0)\tcompress();\n#ifndef DEBUG\n\t    else\t\t\tdecompress();\n#else\n\t    else if (debug == 0)\tdecompress();\n\t    else\t\t\tprintcodes();\n\t    if (verbose)\t\tdump_tab();\n#endif /* DEBUG */\n\t    if(zcat_flg == 0) {\n\t\tcopystat(*fileptr, ofname);\t/* Copy stats */\n\t\tif((exit_stat == 1) || (!quiet))\n\t\t\tputc('\\n', stderr);\n\t    }\n\t}\n    } else {\t\t/* Standard input */\n\tif (do_decomp == 0) {\n\t\tcompress();\n#ifdef DEBUG\n\t\tif(verbose)\t\tdump_tab();\n#endif /* DEBUG */\n\t\tif(!quiet)\n\t\t\tputc('\\n', stderr);\n\t} else {\n\t    /* Check the magic number */\n\t    if (nomagic == 0) {\n\t\tif ((getchar()!=(magic_header[0] & 0xFF))\n\t\t || (getchar()!=(magic_header[1] & 0xFF))) {\n\t\t    fprintf(stderr, \"stdin: not in compressed format\\n\");\n\t\t    exit(1);\n\t\t}\n\t\tmaxbits = getchar();\t/* set -b from file */\n\t\tblock_compress = maxbits & BLOCK_MASK;\n\t\tmaxbits &= BIT_MASK;\n\t\tmaxmaxcode = 1 << maxbits;\n\t\tfsize = 100000;\t\t/* assume stdin large for USERMEM */\n\t\tif(maxbits > BITS) {\n\t\t\tfprintf(stderr,\n\t\t\t\"stdin: compressed with %d bits, can only handle %d bits\\n\",\n\t\t\tmaxbits, BITS);\n\t\t\texit(1);\n\t\t}\n\t    }\n#ifndef DEBUG\n\t    decompress();\n#else\n\t    if (debug == 0)\tdecompress();\n\t    else\t\tprintcodes();\n\t    if (verbose)\tdump_tab();\n#endif /* DEBUG */\n\t}\n    }\n    exit(exit_stat);\n}\n\nstatic int offset;\nlong int in_count = 1;\t\t\t/* length of input */\nlong int bytes_out;\t\t\t/* length of compressed output */\nlong int out_count = 0;\t\t\t/* # of codes output (for debugging) */\n\n/*\n * compress stdin to stdout\n *\n * Algorithm:  use open addressing double hashing (no chaining) on the \n * prefix code / next character combination.  We do a variant of Knuth's\n * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n * secondary probe.  Here, the modular division first probe is gives way\n * to a faster exclusive-or manipulation.  Also do block compression with\n * an adaptive reset, whereby the code table is cleared when the compression\n * ratio decreases, but after the table fills.  The variable-length output\n * codes are re-sized at this point, and a special CLEAR code is generated\n * for the decompressor.  Late addition:  construct the table according to\n * file size for noticeable speed improvement on small files.  Please direct\n * questions about this implementation to ames!jaw.\n */\n\ncompress() {\n    register long fcode;\n    register code_int i = 0;\n    register int c;\n    register code_int ent;\n#ifdef XENIX_16\n    register code_int disp;\n#else\t/* Normal machine */\n    register int disp;\n#endif\n    register code_int hsize_reg;\n    register int hshift;\n\n#ifndef COMPATIBLE\n    if (nomagic == 0) {\n\tputchar(magic_header[0]); putchar(magic_header[1]);\n\tputchar((char)(maxbits | block_compress));\n\tif(ferror(stdout))\n\t\twriteerr();\n    }\n#endif /* COMPATIBLE */\n\n    offset = 0;\n    bytes_out = 3;\t\t/* includes 3-byte header mojo */\n    out_count = 0;\n    clear_flg = 0;\n    ratio = 0;\n    in_count = 1;\n    checkpoint = CHECK_GAP;\n    maxcode = MAXCODE(n_bits = INIT_BITS);\n    free_ent = ((block_compress) ? FIRST : 256 );\n\n    ent = getchar ();\n\n    hshift = 0;\n    for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )\n    \thshift++;\n    hshift = 8 - hshift;\t\t/* set hash code range bound */\n\n    hsize_reg = hsize;\n    cl_hash( (count_int) hsize_reg);\t\t/* clear hash table */\n\n#ifdef SIGNED_COMPARE_SLOW\n    while ( (c = getchar()) != (unsigned) EOF ) {\n#else\n    while ( (c = getchar()) != EOF ) {\n#endif\n\tin_count++;\n\tfcode = (long) (((long) c << maxbits) + ent);\n \ti = ((c << hshift) ^ ent);\t/* xor hashing */\n\n\tif ( htabof (i) == fcode ) {\n\t    ent = codetabof (i);\n\t    continue;\n\t} else if ( (long)htabof (i) < 0 )\t/* empty slot */\n\t    goto nomatch;\n \tdisp = hsize_reg - i;\t\t/* secondary hash (after G. Knott) */\n\tif ( i == 0 )\n\t    disp = 1;\nprobe:\n\tif ( (i -= disp) < 0 )\n\t    i += hsize_reg;\n\n\tif ( htabof (i) == fcode ) {\n\t    ent = codetabof (i);\n\t    continue;\n\t}\n\tif ( (long)htabof (i) > 0 ) \n\t    goto probe;\nnomatch:\n\toutput ( (code_int) ent );\n\tout_count++;\n \tent = c;\n#ifdef SIGNED_COMPARE_SLOW\n\tif ( (unsigned) free_ent < (unsigned) maxmaxcode) {\n#else\n\tif ( free_ent < maxmaxcode ) {\n#endif\n \t    codetabof (i) = free_ent++;\t/* code -> hashtable */\n\t    htabof (i) = fcode;\n\t}\n\telse if ( (count_int)in_count >= checkpoint && block_compress )\n\t    cl_block ();\n    }\n    /*\n     * Put out the final code.\n     */\n    output( (code_int)ent );\n    out_count++;\n    output( (code_int)-1 );\n\n    /*\n     * Print out stats on stderr\n     */\n    if(zcat_flg == 0 && !quiet) {\n#ifdef DEBUG\n\tfprintf( stderr,\n\t\t\"%ld chars in, %ld codes (%ld bytes) out, compression factor: \",\n\t\tin_count, out_count, bytes_out );\n\tprratio( stderr, in_count, bytes_out );\n\tfprintf( stderr, \"\\n\");\n\tfprintf( stderr, \"\\tCompression as in compact: \" );\n\tprratio( stderr, in_count-bytes_out, in_count );\n\tfprintf( stderr, \"\\n\");\n\tfprintf( stderr, \"\\tLargest code (of last block) was %d (%d bits)\\n\",\n\t\tfree_ent - 1, n_bits );\n#else /* !DEBUG */\n\tfprintf( stderr, \"Compression: \" );\n\tprratio( stderr, in_count-bytes_out, in_count );\n#endif /* DEBUG */\n    }\n    if(bytes_out > in_count)\t/* exit(2) if no savings */\n\texit_stat = 2;\n    return;\n}\n\n/*****************************************************************\n * TAG( output )\n *\n * Output the given code.\n * Inputs:\n * \tcode:\tA n_bits-bit integer.  If == -1, then EOF.  This assumes\n *\t\tthat n_bits =< (long)wordsize - 1.\n * Outputs:\n * \tOutputs code to the file.\n * Assumptions:\n *\tChars are 8 bits long.\n * Algorithm:\n * \tMaintain a BITS character long buffer (so that 8 codes will\n * fit in it exactly).  Use the VAX insv instruction to insert each\n * code in turn.  When the buffer fills up empty it and start over.\n */\n\nstatic char buf[BITS];\n\n#ifndef vax\nchar_type lmask[9] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00};\nchar_type rmask[9] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};\n#endif /* vax */\n\noutput( code )\ncode_int  code;\n{\n#ifdef DEBUG\n    static int col = 0;\n#endif /* DEBUG */\n\n    /*\n     * On the VAX, it is important to have the register declarations\n     * in exactly the order given, or the asm will break.\n     */\n    register int r_off = offset, bits= n_bits;\n    register char * bp = buf;\n\n#ifdef DEBUG\n\tif ( verbose )\n\t    fprintf( stderr, \"%5d%c\", code,\n\t\t    (col+=6) >= 74 ? (col = 0, '\\n') : ' ' );\n#endif /* DEBUG */\n    if ( code >= 0 ) {\n#ifdef vax\n\t/* VAX DEPENDENT!! Implementation on other machines is below.\n\t *\n\t * Translation: Insert BITS bits from the argument starting at\n\t * offset bits from the beginning of buf.\n\t */\n\t0;\t/* Work around for pcc -O bug with asm and if stmt */\n\tasm( \"insv\t4(ap),r11,r10,(r9)\" );\n#else /* not a vax */\n/* \n * byte/bit numbering on the VAX is simulated by the following code\n */\n\t/*\n\t * Get to the first byte.\n\t */\n\tbp += (r_off >> 3);\n\tr_off &= 7;\n\t/*\n\t * Since code is always >= 8 bits, only need to mask the first\n\t * hunk on the left.\n\t */\n\t*bp = (*bp & rmask[r_off]) | (code << r_off) & lmask[r_off];\n\tbp++;\n\tbits -= (8 - r_off);\n\tcode >>= 8 - r_off;\n\t/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */\n\tif ( bits >= 8 ) {\n\t    *bp++ = code;\n\t    code >>= 8;\n\t    bits -= 8;\n\t}\n\t/* Last bits. */\n\tif(bits)\n\t    *bp = code;\n#endif /* vax */\n\toffset += n_bits;\n\tif ( offset == (n_bits << 3) ) {\n\t    bp = buf;\n\t    bits = n_bits;\n\t    bytes_out += bits;\n\t    do\n\t\tputchar(*bp++);\n\t    while(--bits);\n\t    offset = 0;\n\t}\n\n\t/*\n\t * If the next entry is going to be too big for the code size,\n\t * then increase it, if possible.\n\t */\n\tif ( free_ent > maxcode || (clear_flg > 0))\n\t{\n\t    /*\n\t     * Write the whole buffer, because the input side won't\n\t     * discover the size increase until after it has read it.\n\t     */\n\t    if ( offset > 0 ) {\n\t\tif( fwrite( buf, 1, n_bits, stdout ) != n_bits)\n\t\t\twriteerr();\n\t\tbytes_out += n_bits;\n\t    }\n\t    offset = 0;\n\n\t    if ( clear_flg ) {\n    \t        maxcode = MAXCODE (n_bits = INIT_BITS);\n\t        clear_flg = 0;\n\t    }\n\t    else {\n\t    \tn_bits++;\n\t    \tif ( n_bits == maxbits )\n\t\t    maxcode = maxmaxcode;\n\t    \telse\n\t\t    maxcode = MAXCODE(n_bits);\n\t    }\n#ifdef DEBUG\n\t    if ( debug ) {\n\t\tfprintf( stderr, \"\\nChange to %d bits\\n\", n_bits );\n\t\tcol = 0;\n\t    }\n#endif /* DEBUG */\n\t}\n    } else {\n\t/*\n\t * At EOF, write the rest of the buffer.\n\t */\n\tif ( offset > 0 )\n\t    fwrite( buf, 1, (offset + 7) / 8, stdout );\n\tbytes_out += (offset + 7) / 8;\n\toffset = 0;\n\tfflush( stdout );\n#ifdef DEBUG\n\tif ( verbose )\n\t    fprintf( stderr, \"\\n\" );\n#endif /* DEBUG */\n\tif( ferror( stdout ) )\n\t\twriteerr();\n    }\n}\n\n/*\n * Decompress stdin to stdout.  This routine adapts to the codes in the\n * file building the \"string\" table on-the-fly; requiring no table to\n * be stored in the compressed file.  The tables used herein are shared\n * with those of the compress() routine.  See the definitions above.\n */\n\ndecompress() {\n    register char_type *stackp;\n    register int finchar;\n    register code_int code, oldcode, incode;\n\n    /*\n     * As above, initialize the first 256 entries in the table.\n     */\n    maxcode = MAXCODE(n_bits = INIT_BITS);\n    for ( code = 255; code >= 0; code-- ) {\n\ttab_prefixof(code) = 0;\n\ttab_suffixof(code) = (char_type)code;\n    }\n    free_ent = ((block_compress) ? FIRST : 256 );\n\n    finchar = oldcode = getcode();\n    if(oldcode == -1)\t/* EOF already? */\n\treturn;\t\t\t/* Get out of here */\n    putchar( (char)finchar );\t\t/* first code must be 8 bits = char */\n    if(ferror(stdout))\t\t/* Crash if can't write */\n\twriteerr();\n    stackp = de_stack;\n\n    while ( (code = getcode()) > -1 ) {\n\n\tif ( (code == CLEAR) && block_compress ) {\n\t    for ( code = 255; code >= 0; code-- )\n\t\ttab_prefixof(code) = 0;\n\t    clear_flg = 1;\n\t    free_ent = FIRST - 1;\n\t    if ( (code = getcode ()) == -1 )\t/* O, untimely death! */\n\t\tbreak;\n\t}\n\tincode = code;\n\t/*\n\t * Special case for KwKwK string.\n\t */\n\tif ( code >= free_ent ) {\n            *stackp++ = finchar;\n\t    code = oldcode;\n\t}\n\n\t/*\n\t * Generate output characters in reverse order\n\t */\n#ifdef SIGNED_COMPARE_SLOW\n\twhile ( ((unsigned long)code) >= ((unsigned long)256) ) {\n#else\n\twhile ( code >= 256 ) {\n#endif\n\t    *stackp++ = tab_suffixof(code);\n\t    code = tab_prefixof(code);\n\t}\n\t*stackp++ = finchar = tab_suffixof(code);\n\n\t/*\n\t * And put them out in forward order\n\t */\n\tdo\n\t    putchar ( *--stackp );\n\twhile ( stackp > de_stack );\n\n\t/*\n\t * Generate the new entry.\n\t */\n\tif ( (code=free_ent) < maxmaxcode ) {\n\t    tab_prefixof(code) = (unsigned short)oldcode;\n\t    tab_suffixof(code) = finchar;\n\t    free_ent = code+1;\n\t} \n\t/*\n\t * Remember previous code.\n\t */\n\toldcode = incode;\n    }\n    fflush( stdout );\n    if(ferror(stdout))\n\twriteerr();\n}\n\n/*****************************************************************\n * TAG( getcode )\n *\n * Read one code from the standard input.  If EOF, return -1.\n * Inputs:\n * \tstdin\n * Outputs:\n * \tcode or -1 is returned.\n */\n\ncode_int\ngetcode() {\n    /*\n     * On the VAX, it is important to have the register declarations\n     * in exactly the order given, or the asm will break.\n     */\n    register code_int code;\n    static int offset = 0, size = 0;\n    static char_type buf[BITS];\n    register int r_off, bits;\n    register char_type *bp = buf;\n\n    if ( clear_flg > 0 || offset >= size || free_ent > maxcode ) {\n\t/*\n\t * If the next entry will be too big for the current code\n\t * size, then we must increase the size.  This implies reading\n\t * a new buffer full, too.\n\t */\n\tif ( free_ent > maxcode ) {\n\t    n_bits++;\n\t    if ( n_bits == maxbits )\n\t\tmaxcode = maxmaxcode;\t/* won't get any bigger now */\n\t    else\n\t\tmaxcode = MAXCODE(n_bits);\n\t}\n\tif ( clear_flg > 0) {\n    \t    maxcode = MAXCODE (n_bits = INIT_BITS);\n\t    clear_flg = 0;\n\t}\n\tsize = fread( buf, 1, n_bits, stdin );\n\tif ( size <= 0 )\n\t    return -1;\t\t\t/* end of file */\n\toffset = 0;\n\t/* Round size down to integral number of codes */\n\tsize = (size << 3) - (n_bits - 1);\n    }\n    r_off = offset;\n    bits = n_bits;\n#ifdef vax\n    asm( \"extzv   r10,r9,(r8),r11\" );\n#else /* not a vax */\n\t/*\n\t * Get to the first byte.\n\t */\n\tbp += (r_off >> 3);\n\tr_off &= 7;\n\t/* Get first part (low order bits) */\n#ifdef NO_UCHAR\n\tcode = ((*bp++ >> r_off) & rmask[8 - r_off]) & 0xff;\n#else\n\tcode = (*bp++ >> r_off);\n#endif /* NO_UCHAR */\n\tbits -= (8 - r_off);\n\tr_off = 8 - r_off;\t\t/* now, offset into code word */\n\t/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */\n\tif ( bits >= 8 ) {\n#ifdef NO_UCHAR\n\t    code |= (*bp++ & 0xff) << r_off;\n#else\n\t    code |= *bp++ << r_off;\n#endif /* NO_UCHAR */\n\t    r_off += 8;\n\t    bits -= 8;\n\t}\n\t/* high order bits. */\n\tcode |= (*bp & rmask[bits]) << r_off;\n#endif /* vax */\n    offset += n_bits;\n\n    return code;\n}\n\nchar *\nrindex(s, c)\t\t/* For those who don't have it in libc.a */\nregister char *s, c;\n{\n\tchar *p;\n\tfor (p = NULL; *s; s++)\n\t    if (*s == c)\n\t\tp = s;\n\treturn(p);\n}\n\n#ifdef DEBUG\nprintcodes()\n{\n    /*\n     * Just print out codes from input file.  For debugging.\n     */\n    code_int code;\n    int col = 0, bits;\n\n    bits = n_bits = INIT_BITS;\n    maxcode = MAXCODE(n_bits);\n    free_ent = ((block_compress) ? FIRST : 256 );\n    while ( ( code = getcode() ) >= 0 ) {\n\tif ( (code == CLEAR) && block_compress ) {\n   \t    free_ent = FIRST - 1;\n   \t    clear_flg = 1;\n\t}\n\telse if ( free_ent < maxmaxcode )\n\t    free_ent++;\n\tif ( bits != n_bits ) {\n\t    fprintf(stderr, \"\\nChange to %d bits\\n\", n_bits );\n\t    bits = n_bits;\n\t    col = 0;\n\t}\n\tfprintf(stderr, \"%5d%c\", code, (col+=6) >= 74 ? (col = 0, '\\n') : ' ' );\n    }\n    putc( '\\n', stderr );\n    exit( 0 );\n}\n\ncode_int sorttab[1<<BITS];\t/* sorted pointers into htab */\n\ndump_tab()\t/* dump string table */\n{\n    register int i, first;\n    register ent;\n#define STACK_SIZE\t15000\n    int stack_top = STACK_SIZE;\n    register c;\n\n    if(do_decomp == 0) {\t/* compressing */\n\tregister int flag = 1;\n\n\tfor(i=0; i<hsize; i++) {\t/* build sort pointers */\n\t\tif((long)htabof(i) >= 0) {\n\t\t\tsorttab[codetabof(i)] = i;\n\t\t}\n\t}\n\tfirst = block_compress ? FIRST : 256;\n\tfor(i = first; i < free_ent; i++) {\n\t\tfprintf(stderr, \"%5d: \\\"\", i);\n\t\tde_stack[--stack_top] = '\\n';\n\t\tde_stack[--stack_top] = '\"';\n\t\tstack_top = in_stack((htabof(sorttab[i])>>maxbits)&0xff, \n                                     stack_top);\n\t\tfor(ent=htabof(sorttab[i]) & ((1<<maxbits)-1);\n\t\t    ent > 256;\n\t\t    ent=htabof(sorttab[ent]) & ((1<<maxbits)-1)) {\n\t\t\tstack_top = in_stack(htabof(sorttab[ent]) >> maxbits,\n\t\t\t\t\t\tstack_top);\n\t\t}\n\t\tstack_top = in_stack(ent, stack_top);\n\t\tfwrite( &de_stack[stack_top], 1, STACK_SIZE-stack_top, stderr);\n\t   \tstack_top = STACK_SIZE;\n\t}\n   } else if(!debug) {\t/* decompressing */\n\n       for ( i = 0; i < free_ent; i++ ) {\n\t   ent = i;\n\t   c = tab_suffixof(ent);\n\t   if ( isascii(c) && isprint(c) )\n\t       fprintf( stderr, \"%5d: %5d/'%c'  \\\"\",\n\t\t\t   ent, tab_prefixof(ent), c );\n\t   else\n\t       fprintf( stderr, \"%5d: %5d/\\\\%03o \\\"\",\n\t\t\t   ent, tab_prefixof(ent), c );\n\t   de_stack[--stack_top] = '\\n';\n\t   de_stack[--stack_top] = '\"';\n\t   for ( ; ent != NULL;\n\t\t   ent = (ent >= FIRST ? tab_prefixof(ent) : NULL) ) {\n\t       stack_top = in_stack(tab_suffixof(ent), stack_top);\n\t   }\n\t   fwrite( &de_stack[stack_top], 1, STACK_SIZE - stack_top, stderr );\n\t   stack_top = STACK_SIZE;\n       }\n    }\n}\n\nint\nin_stack(c, stack_top)\n\tregister c, stack_top;\n{\n\tif ( (isascii(c) && isprint(c) && c != '\\\\') || c == ' ' ) {\n\t    de_stack[--stack_top] = c;\n\t} else {\n\t    switch( c ) {\n\t    case '\\n': de_stack[--stack_top] = 'n'; break;\n\t    case '\\t': de_stack[--stack_top] = 't'; break;\n\t    case '\\b': de_stack[--stack_top] = 'b'; break;\n\t    case '\\f': de_stack[--stack_top] = 'f'; break;\n\t    case '\\r': de_stack[--stack_top] = 'r'; break;\n\t    case '\\\\': de_stack[--stack_top] = '\\\\'; break;\n\t    default:\n\t \tde_stack[--stack_top] = '0' + c % 8;\n\t \tde_stack[--stack_top] = '0' + (c / 8) % 8;\n\t \tde_stack[--stack_top] = '0' + c / 64;\n\t \tbreak;\n\t    }\n\t    de_stack[--stack_top] = '\\\\';\n\t}\n\treturn stack_top;\n}\n#endif /* DEBUG */\n\nwriteerr()\n{\n    perror ( ofname );\n    unlink ( ofname );\n    exit ( 1 );\n}\n\ncopystat(ifname, ofname)\nchar *ifname, *ofname;\n{\n    struct stat statbuf;\n    int mode;\n    time_t timep[2];\n\n    fclose(stdout);\n    if (stat(ifname, &statbuf)) {\t\t/* Get stat on input file */\n\tperror(ifname);\n\treturn;\n    }\n    if ((statbuf.st_mode & S_IFMT/*0170000*/) != S_IFREG/*0100000*/) {\n\tif(quiet)\n\t    \tfprintf(stderr, \"%s: \", ifname);\n\tfprintf(stderr, \" -- not a regular file: unchanged\");\n\texit_stat = 1;\n    } else if (statbuf.st_nlink > 1) {\n\tif(quiet)\n\t    \tfprintf(stderr, \"%s: \", ifname);\n\tfprintf(stderr, \" -- has %d other links: unchanged\",\n\t\tstatbuf.st_nlink - 1);\n\texit_stat = 1;\n    } else if (exit_stat == 2 && (!force)) { /* No compression: rm file.Z */\n\tif(!quiet)\n\t\tfprintf(stderr, \" -- file unchanged\");\n    } else {\t\t\t/* ***** Successful Compression ***** */\n\texit_stat = 0;\n\tmode = statbuf.st_mode & 07777;\n\tif (chmod(ofname, mode))\t\t/* Copy modes */\n\t    perror(ofname);\n\tchown(ofname, statbuf.st_uid, statbuf.st_gid);\t/* Copy ownership */\n\ttimep[0] = statbuf.st_atime;\n\ttimep[1] = statbuf.st_mtime;\n\tutime(ofname, timep);\t/* Update last accessed and modified times */\n\tif (unlink(ifname))\t/* Remove input file */\n\t    perror(ifname);\n\tif(!quiet)\n\t\tfprintf(stderr, \" -- replaced with %s\", ofname);\n\treturn;\t\t/* Successful return */\n    }\n\n    /* Unsuccessful return -- one of the tests failed */\n    if (unlink(ofname))\n\tperror(ofname);\n}\n/*\n * This routine returns 1 if we are running in the foreground and stderr\n * is a tty.\n */\nforeground()\n{\n\tif(bgnd_flag) {\t/* background? */\n\t\treturn(0);\n\t} else {\t\t\t/* foreground */\n\t\tif(isatty(2)) {\t\t/* and stderr is a tty */\n\t\t\treturn(1);\n\t\t} else {\n\t\t\treturn(0);\n\t\t}\n\t}\n}\n\nonintr ( )\n{\n    unlink ( ofname );\n    exit ( 1 );\n}\n\noops ( )\t/* wild pointer -- assume bad input */\n{\n    if ( do_decomp == 1 ) \n    \tfprintf ( stderr, \"uncompress: corrupt input\\n\" );\n    unlink ( ofname );\n    exit ( 1 );\n}\n\ncl_block ()\t\t/* table clear for block compress */\n{\n    register long int rat;\n\n    checkpoint = in_count + CHECK_GAP;\n#ifdef DEBUG\n\tif ( debug ) {\n    \t\tfprintf ( stderr, \"count: %ld, ratio: \", in_count );\n     \t\tprratio ( stderr, in_count, bytes_out );\n\t\tfprintf ( stderr, \"\\n\");\n\t}\n#endif /* DEBUG */\n\n    if(in_count > 0x007fffff) {\t/* shift will overflow */\n\trat = bytes_out >> 8;\n\tif(rat == 0) {\t\t/* Don't divide by zero */\n\t    rat = 0x7fffffff;\n\t} else {\n\t    rat = in_count / rat;\n\t}\n    } else {\n\trat = (in_count << 8) / bytes_out;\t/* 8 fractional bits */\n    }\n    if ( rat > ratio ) {\n\tratio = rat;\n    } else {\n\tratio = 0;\n#ifdef DEBUG\n\tif(verbose)\n\t\tdump_tab();\t/* dump string table */\n#endif\n \tcl_hash ( (count_int) hsize );\n\tfree_ent = FIRST;\n\tclear_flg = 1;\n\toutput ( (code_int) CLEAR );\n#ifdef DEBUG\n\tif(debug)\n    \t\tfprintf ( stderr, \"clear\\n\" );\n#endif /* DEBUG */\n    }\n}\n\ncl_hash(hsize)\t\t/* reset code table */\n\tregister count_int hsize;\n{\n#ifndef XENIX_16\t/* Normal machine */\n\tregister count_int *htab_p = htab+hsize;\n#else\n\tregister j;\n\tregister long k = hsize;\n\tregister count_int *htab_p;\n#endif\n\tregister long i;\n\tregister long m1 = -1;\n\n#ifdef XENIX_16\n    for(j=0; j<=8 && k>=0; j++,k-=8192) {\n\ti = 8192;\n\tif(k < 8192) {\n\t\ti = k;\n\t}\n\thtab_p = &(htab[j][i]);\n\ti -= 16;\n\tif(i > 0) {\n#else\n\ti = hsize - 16;\n#endif\n \tdo {\t\t\t\t/* might use Sys V memset(3) here */\n\t\t*(htab_p-16) = m1;\n\t\t*(htab_p-15) = m1;\n\t\t*(htab_p-14) = m1;\n\t\t*(htab_p-13) = m1;\n\t\t*(htab_p-12) = m1;\n\t\t*(htab_p-11) = m1;\n\t\t*(htab_p-10) = m1;\n\t\t*(htab_p-9) = m1;\n\t\t*(htab_p-8) = m1;\n\t\t*(htab_p-7) = m1;\n\t\t*(htab_p-6) = m1;\n\t\t*(htab_p-5) = m1;\n\t\t*(htab_p-4) = m1;\n\t\t*(htab_p-3) = m1;\n\t\t*(htab_p-2) = m1;\n\t\t*(htab_p-1) = m1;\n\t\thtab_p -= 16;\n\t} while ((i -= 16) >= 0);\n#ifdef XENIX_16\n\t}\n    }\n#endif\n    \tfor ( i += 16; i > 0; i-- )\n\t\t*--htab_p = m1;\n}\n\nprratio(stream, num, den)\nFILE *stream;\nlong int num, den;\n{\n\tregister int q;\t\t\t/* Doesn't need to be long */\n\n\tif(num > 214748L) {\t\t/* 2147483647/10000 */\n\t\tq = num / (den / 10000L);\n\t} else {\n\t\tq = 10000L * num / den;\t\t/* Long calculations, though */\n\t}\n\tif (q < 0) {\n\t\tputc('-', stream);\n\t\tq = -q;\n\t}\n\tfprintf(stream, \"%d.%02d%%\", q / 100, q % 100);\n}\n\nversion()\n{\n\tfprintf(stderr, \"%s\\n\", rcs_ident);\n\tfprintf(stderr, \"Options: \");\n#ifdef vax\n\tfprintf(stderr, \"vax, \");\n#endif\n#ifdef NO_UCHAR\n\tfprintf(stderr, \"NO_UCHAR, \");\n#endif\n#ifdef SIGNED_COMPARE_SLOW\n\tfprintf(stderr, \"SIGNED_COMPARE_SLOW, \");\n#endif\n#ifdef XENIX_16\n\tfprintf(stderr, \"XENIX_16, \");\n#endif\n#ifdef COMPATIBLE\n\tfprintf(stderr, \"COMPATIBLE, \");\n#endif\n#ifdef DEBUG\n\tfprintf(stderr, \"DEBUG, \");\n#endif\n#ifdef BSD4_2\n\tfprintf(stderr, \"BSD4_2, \");\n#endif\n\tfprintf(stderr, \"BITS = %d\\n\", BITS);\n}\n", "encoding": "ascii"}