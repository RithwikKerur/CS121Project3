{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/TwoDimensionalLists/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Two-Dimensional Lists</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Two-Dimensional Lists</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>In a project earlier this quarter, you and a partner implemented a Connect Four game.  The game logic itself &mdash; the actual implementation of the rules of the game &mdash; was provided in a module called <b>connectfour.py</b>, but even if you didn't look through the module's code, some of the details of its implementation were made clear to you while you worked on the project.  Connect Four is a game whose playfield is a two-dimensional grid, with tiles being dropped into columns from the top or popped from columns at the bottom; for that reason, <b>connectfour.py</b> organized the playfield as a <i>two-dimensional list</i> (i.e., a list in which each element is a list), the most natural way to store a simple grid or matrix structure in Python, with the list primarily containing each of the playfield's columns in a sublist, and each element of the sublist being one row of that column.  So, for example, the playfield might be represented like this (with some spacing added to make the structure clearer):</p>\r\n\r\n<blockquote><pre>\r\n[[0, 0, 0, 0, 1, 2],\r\n [0, 0, 0, 2, 2, 1],\r\n [0, 0, 0, 0, 1, 1],\r\n [0, 0, 0, 1, 2, 2],\r\n [0, 0, 0, 0, 1, 2],\r\n [0, 0, 2, 1, 1, 2],\r\n [0, 0, 0, 0, 0, 1]]\r\n</pre></blockquote>\r\n\r\n<p>We used named constants, as well, so we could refer to the <b>0</b>, <b>1</b>, and <b>2</b> in our code as <b>NONE</b>, <b>RED</b>, and <b>YELLOW</b>, which aided readability further; being able to call things what they are, instead of some encoded version of what they are (e.g., <b>RED</b> instead of <b>1</b>), is one of the hallmarks of well-written, maintainable code.</p>\r\n\r\n<p>While it's important to note that this arrangement was the most convenient way to implement various parts of the game logic &mdash; e.g., dropping and popping pieces, which had an effect on only one column (and therefore only one sublist) &mdash; you faced the problem that this arrangement wasn't the right one to show to a human user, who would want to see the columns vertically and the rows horizontally.  So you had to write a function that could present that same playfield like this:</p>\r\n\r\n<blockquote><pre>\r\n. . . . . . .\r\n. . . . . . .\r\n. . . . . Y .\r\n. Y . R . R .\r\nR Y R Y R R .\r\nY R R Y Y Y R\r\n</pre></blockquote>\r\n\r\n<p>which actually underscores an important point about how you choose data structures when you write programs.  The right thing to do is to choose the data structure that leads to the best outcome <i>within your program</i>, so the most important and frequently-used operations can be implemented in a way that is time- and memory-efficient and, hopefully, relatively simple.  At the cost of making the problem of printing the board a little more complicated (because we needed to print the board primarily in order of the rows, even though this was different from how the data was stored), all of the other algorithms were made simpler (because everything else involves only a single column, which means only a single sublist).  All in all, this was a good trade, though it might not have seemed like it to you at the time, since I was the primary beneficiary as the author of <b>connectfour.py</b>, and you bore the cost of writing the function to print the board.</p>\r\n\r\n<p>Writing functions in Python that process two-dimensional lists might well have been new territory for you when working on that project, but there was relatively little code to write.  In <a href=\"../../ProjectGuide/Project4\">Project #4</a>, you'll need to implement the game logic for a different game, whose rules are quite different from Connect Four's, but whose playfield is structurally similar &mdash; the game is played on a rectangular grid on which tiles of opposing colors are placed and flipped.  As in <b>connectfour.py</b>, a reasonable choice for storing the game board would be a two-dimensional list, but this time you'll be responsible for all of the game logic.  So before you embark too far on that journey, it would be wise to spend a little bit of time beefing up your skills at navigating and manipulating two-dimensional lists, and solidifying some prior Python knowledge that turns out to be critical for this kind of problem.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">References, mutability, and immutability</p>\r\n\r\n<p>When you learn any programming language, part of what you're doing is building up a mental model of what's happening behind the scenes while your program runs.  You can achieve a certain amount of success even if your mental model is incomplete (or just plain wrong in places), but you eventually run into issues where you simply need to understand the reality of the language if you want to be able to write programs correctly.</p>\r\n\r\n<p class=\"subtitle\">Variables contain references, not objects</p>\r\n\r\n<p>When you assign an object into a variable in Python, that variable does not actually store the object.  Instead, the variable stores a <i>reference</i> to that object, which you can think of as the location in memory where the object resides.  You can get the value of the reference itself by calling the function <b>id</b>, like this:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x = 20563</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n20563\r\n&gt;&gt;&gt; <b>id(x)</b>\r\n55367280\r\n</pre></blockquote>\r\n\r\n<p>(Note that you might see a different <b>id</b> value than I do, but the <b>id</b> values should be comparatively equal or comparatively different for you when they are for me; what's important here is when an <b>id</b> changes and whether one <b>id</b> is the same as another or different.  Note, also, that our implementation of Python handles very small integer values differently from others, so I'm using examples with relatively large numbers, so we can be sure to see the true effect.)</p>\r\n\r\n<p>Over the course of a variable's life, it may store different objects at different times, in which case its <b>id</b> changes, also.  For example:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x += 1</b>\r\n&gt;&gt;&gt; <b>x</b>\r\n20564\r\n&gt;&gt;&gt; <b>id(x)</b>\r\n55367568\r\n</pre></blockquote>\r\n\r\n<p>Embedded in the example above is a strong hint that adding 1 to an integer using the += operator does not change the value of the integer object that <b>x</b> refers to; instead, it makes <b>x</b> refer to a different integer, as evidenced by the fact that <b>x</b>'s <b>id</b> changed.</p>\r\n\r\n<p class=\"subtitle\">Mutability vs. immutability</p>\r\n\r\n<p>Python draws a distinction between types whose objects are <i>mutable</i> and types whose objects are <i>immutable</i>.  Mutable types are the ones whose objects can be changed; immutable types are the ones whose objects cannot.</p>\r\n\r\n<p>For example, integer values are immutable in Python, which means that there's nothing you can do to change an integer object once it's been created; all you can do is create a new integer object.  So, in the example above, when we added 1 to <b>x</b>, we were actually creating a new integer value that was 1 greater than the one currently referred to by <b>x</b>.</p>\r\n\r\n<p>Meanwhile, lists in Python are mutable, which means that alterations to an existing list <i>change that list</i>, as opposed to building a new one.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a = [1001, 1002, 1003]</b>\r\n&gt;&gt;&gt; <b>id(a)</b>\r\n55035272\r\n&gt;&gt;&gt; <b>a.append(1004)</b>\r\n&gt;&gt;&gt; <b>a</b>\r\n[1001, 1002, 1003, 1004]\r\n&gt;&gt;&gt; <b>id(a)</b>\r\n55035272\r\n</pre></blockquote>\r\n\r\n<p>The <b>id</b> of <b>a</b> has not changed, which tells us that <b>a</b> is still referring to the same list that it used to, meaning that lists are mutable and <b>append</b> mutates them.  (The <b>+=</b> operator does, too.  The <b>+</b> operator does not, as it turns out; it builds a new list that is the concatenation of the two lists being added together.)</p>\r\n\r\n<p>To be sure we understand the practical effect of this, we need to think about what happens when more than one variable refers to the same object, and then we try to modify one variable or the other.  Consider first the following example using variables storing integers.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a = 657123</b>\r\n&gt;&gt;&gt; <b>id(a)</b>\r\n55088720\r\n&gt;&gt;&gt; <b>b = a</b>\r\n&gt;&gt;&gt; <b>id(b)</b>\r\n55088720\r\n</pre></blockquote>\r\n\r\n<p>In this example, <b>a</b> and <b>b</b> are now variables storing a reference to <i>the same integer object</i>.  Now consider what would happen if we did this.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a += 1</b>\r\n</pre></blockquote>\r\n\r\n<p>What effect would this have on the value of <b>b</b>?  The answer is none; <b>b</b> will remain unchanged.  Since integers are immutable, the act of adding 1 to <b>a</b> caused a new integer object to be created with the value 657124, and <b>a</b> now refers to it, while <b>b</b> still refers to the same object it did before.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a</b>\r\n657124\r\n&gt;&gt;&gt; <b>id(a)</b>\r\n55628976\r\n&gt;&gt;&gt; <b>b</b>\r\n657123\r\n&gt;&gt;&gt; <b>id(b)</b>\r\n55088720\r\n</pre></blockquote>\r\n\r\n<p>Now let's consider the effect of the mutability of lists in a similar example:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a = [1001, 1002, 1003]</b>\r\n&gt;&gt;&gt; <b>id(a)</b>\r\n55266312\r\n&gt;&gt;&gt; <b>b = a</b>\r\n&gt;&gt;&gt; <b>id(b)</b>\r\n55266312\r\n</pre></blockquote>\r\n\r\n<p>At this point, <b>a</b> and <b>b</b> are two variables each containing a reference to the same list.  (Among other things, this tells us that the assignment of <b>a</b> into <b>b</b> was very cheap, since it was only the reference being assigned; even if <b>a</b> had been a very long list, this would have been a cheap assignment.)</p>\r\n\r\n<p>Now we'll mutate one of the lists:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>a.append(1004)</b>\r\n&gt;&gt;&gt; <b>a</b>\r\n[1001, 1002, 1003, 1004]\r\n&gt;&gt;&gt; <b>id(a)</b>\r\n55266312\r\n&gt;&gt;&gt; <b>id(b)</b>\r\n55266312\r\n&gt;&gt;&gt; <b>b</b>\r\n[1001, 1002, 1003, 1004]\r\n</pre></blockquote>\r\n\r\n<p>Lo and behold, mutating one of the lists also mutated the other!  This isn't magic; this is simply due to the fact that lists are mutable, and that <b>a</b> and <b>b</b> were both referring to <i>the same list</i>, so mutating that list had the same effect on both variables.</p>\r\n\r\n<p>Finally, to be sure we have our heads wrapped all the way around this, we'll consider the effect of mutating the elements of a list, continuing the previous example.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>c = a[0]</b>\r\n&gt;&gt;&gt; <b>id(c)</b>\r\n55088736\r\n&gt;&gt;&gt; <b>id(a[0])</b>\r\n55088736\r\n&gt;&gt;&gt; <b>c</b>\r\n1001\r\n&gt;&gt;&gt; <b>c += 1</b>\r\n</pre></blockquote>\r\n\r\n<p>What do you think the effect of <b>c += 1</b> is?  What values have changed?  What values haven't?  Let's take a look.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>c</b>\r\n1002\r\n&gt;&gt;&gt; <b>id(c)</b>\r\n55628912\r\n&gt;&gt;&gt; <b>a[0]</b>\r\n1001\r\n&gt;&gt;&gt; <b>id(a[0])</b>\r\n55088736\r\n&gt;&gt;&gt; <b>a</b>\r\n[1001, 1002, 1003, 1004]\r\n</pre></blockquote>\r\n\r\n<p>Since integers are immutable, <b>c += 1</b> will have created a new integer object with the value 1002.  <b>c</b> will now refer to that, but <b>a[0]</b> will not have changed.</p>\r\n\r\n<p class=\"subtitle\">Why the mutability distinction matters</p>\r\n\r\n<p>The distinction between mutability and immutability might at first seem like nothing more than a curiosity, an implementation detail that doesn't significantly affect the meaning of a Python program.  Even if you've never thought of things this way &mdash; and even if your mental model about these details hasn't matched this reality &mdash; it may not have negatively affected anything you've had to write so far, because many Python programs have the same effect regardless of the mutability of their objects.</p>\r\n\r\n<p>The reality, however, is that you eventually reach the point where this distinction is absolutely critical, as we did in this lecture on two-dimensional list algorithms.  When iterating over a list <b>a</b>, you have a few options:</p>\r\n\r\n<ul>\r\n  <li>Use a <b>for</b> loop that iterates over the list's elements.\r\n    <blockquote><pre>for x in a:</b></pre></blockquote>\r\n  In this case, the variable <b>x</b> will refer to each object in the list <b>a</b>, one per loop iteration.  <b>x</b> will refer directly to the objects in the list, but if those objects are immutable (e.g., they're integers), modifying <b>x</b> will have no effect on the list.  But in a case where you don't need to modify the list, this is the simplest and (usually) best approach.</li>\r\n  <br />\r\n  <li>Use a <b>for</b> loop that iterates over the <i>indices</i> of the list's elements.\r\n    <blockquote><pre>for x in range(len(a)):</pre></blockquote>\r\n  In this case, the variable <b>x</b> will not refer directly to each object in the list.  It will instead store the <i>index</i> (i.e., the position within the list) of each element.  You can use this index to access or modify the list's elements, and any modifications you make using an index (e.g., <b>x[i] = 3</b>) will take effect on the list.  But if you never need to modify the list, this approach is more complicated than it needs to be.</li>\r\n  <br />\r\n  <li>Use a <b>while</b> loop, managing the values of variables that access indices manually, while ensuring that they remain valid (e.g., that they aren't less than 0 or at least as big as the size of the list).  This is the trickiest technique, but the most useful when it's difficult to know in advance how far you need to go, or when the condition that gets you out of the loop isn't based only on an index (e.g., the way that we search in Connect Four for four tiles in a row of the same color).</li>\r\n</ul>\r\n\r\n<p>As you can see, the choice here depends at least partly on whether your goal is just to look at elements of the list, as opposed to changing them.  Consider a straightforward pair of nested loops like this, assuming that we're trying to increment every element in a two-dimensional list of integers called <b>a</b>:</p>\r\n\r\n<blockquote><pre>\r\nfor i in a:\r\n    for j in i:\r\n        j += 1\r\n</pre></blockquote>\r\n\r\n<p>At first blush, this technique may appear to work:</p>\r\n\r\n<ul>\r\n  <li>The outer loop takes us to each sublist and names each one <b>i</b> temporarily.</li>\r\n  <li>The inner loop takes us to each integer in each sublist and names each one <b>j</b> temporarily.</li>\r\n</ul>\r\n\r\n<p>So every integer in every sublist will be visited, and 1 will always be added to each one.  The problem is that <b>j</b> contains a reference to an integer, and integers are immutable, so our attempt to add 1 to <b>j</b> does just that: it adds 1 to the temporary variable <b>j</b>, but has no effect on the underlying list.</p>\r\n\r\n<p>At this stage, then, we'll have to be more careful about our understanding of how these kinds of things work in Python, as it will be vital if we want to be able to solve these kinds of problems.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>In lecture, we wrote several functions that demonstrated two-dimensional list algorithms, and how sometimes we need <b>for</b> loops that iterate the elements, sometimes we need <b>for</b> loops that iterate the <i>indices</i> of those elements, and sometimes we only need a single loop even though the list is multiple dimensions.</p>\r\n\r\n<ul>\r\n  <li><a href=\"two_d_lists.py\">two_d_lists.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}