{"url": "https://www.ics.uci.edu/~stasio/winter06/Homeworks/sol5.txt", "content": "Solutions to Homework 5\r\n\r\nR-6.14 \r\n[here change \"sequence\" to \"node list\", and use only the operations from the \r\nNode List ADT (also called \"List ADT\" or \"Position List ADT\")]\r\n\r\nLet S be the node list. Using the List ADT we can move position p to front\r\nby doing the following:\r\n\r\nE e = S.remove(p);\r\nS.addFirst(e);\r\n\r\nOr, even faster:\r\nS.addFirst(S.remove(p));\r\n\r\nEven though you were asked to use just the List ADT methods, we accepted\r\nsolutions which described how to perform the move-to-form from scratch, i.e.\r\nwithout using the already-programmed List ADT methods, and assuming the\r\nList ADT is implemented as a double-linked list of DNodes (see pages 239-241).\r\nThen the code could look like this:\r\n\r\np.getPrev().setNext(p.getNext());\r\np.getNext().setPrev(p.getPrev());\r\nheader.getNext().setPrev(p);\r\np.setNext(header.getNext());\r\nheader.setNext(p);\r\np.setPrev(header);\r\n\r\n\r\nR-6.16\r\n[give a pseudocode for this iterator]\r\n\r\nSome students just gave the procedure that returns a list composed of every\r\nother element of the initial list, or prints out every other element of the list,\r\nbut that's not what an Iterator is.  See section 6.3.  So here is an example\r\nof an implementation of such iterator (compare to the code for an iterator\r\nof elements in a list on page 245):\r\n\r\npublic class NewIterator<E> implements Iterator<E> {\r\n PositionList<E> L;\r\n Position<E> p;\r\n \r\n public NewIterator(PositionList<E> L) {\r\n   this.L = L;\r\n   if L.isEmpty()\r\n       p = null\r\n     else p = L.first();\r\n }\r\n  \r\n public hasNext() { return (p != null); }\r\n \r\n public E next() throws NoNextElementException {\r\n   if (p == null) throw new NoNextElementException(\"...\");\r\n   E elementToReturn = p.element();\r\n   p = L.next(p);\r\n   if (p != null) \r\n     p = L.next(p);\r\n   return elementToReturn;\r\n }\r\n\r\n\r\nR-6.19,\r\n\r\nOne student noted that the question can be solved only if the initial access\r\ncount for every element in list L is zero (or, more generally, if these\r\naccess counts are all the same).  That was indeed the intention of this\r\nquestion.  \r\n\r\nLet \"l_i\" refer to an element that sits at index i in list L at the \r\nbeginning.  Let n = L.size().  Assuming that all elements in L have \r\nequal initial counts, the following access pattern will have the effect of \r\nreversing the list if the list is maintained as ordered by decreasing \r\naccess counts:\r\n\r\nfor i = 1 to n\r\n  for j = i to n\r\n    access element l_i in the list (wherever it currently is)\r\n    \r\nFor example, if L = {A,B,C,D}, this loop encodes the following pattern\r\nof accesses to these elements:  A,B,C,D,B,C,D,C,D,D\r\n\r\nIn general, element l_i will be accessed i times in this access pattern,\r\nand therefore the resulting list will look like this:\r\n\r\n{l_n, l_{n-1}, ... , l_3, l_2, l_1}\r\n\r\nNote that the number of accesses is O(n^2).\r\n\r\n\r\nR-6.20,\r\n\r\nLet \"l_i\" refer to an element that sits at index i in list L at the \r\nbeginning.  Let n = L.size().  The following access pattern will have \r\nthe effect of reversing the list if the list is maintained according\r\nto the move-to-front heuristic:\r\n\r\nfor i = 1 to n\r\n  access l_i in the list (wherever it currently is)\r\n  \r\nNote that the last element accessed is l_n, therefore it'll be at the\r\nfront of the list now.  The element accessed before that is l_{n-1},\r\nso it'll be second.  Etc.\r\n\r\nNote that the number of accesses is n.\r\n\r\n\r\nC-6.11,\r\n\r\nThe list L can be implemented like this:  Whenever element l in L is\r\naccessed, two things happen: (1) Element l is moved to the front of\r\nthe list, and (2) The last element of the list is removed from the list,\r\nunless this last element is equal to element l (in which case no\r\nelement is removed from the list).\r\n\r\nAssuming the list is implemented with linked list of DNodes, the \r\nmove-to-front takes O(1) time and so does removal of the last node.\r\n\r\nNote that at any time, the list L contains then only the elements which have\r\nbeen accessed at least once among the past n = L.size() accesses.\r\n\r\nNote also, that this is a somewhat strange list, because unless you access\r\nthe last element, the list shrinks.\r\n\r\nSome students said that you can maintain an additional queue L', on which \r\nyou enqueue every element that is accessed, and you dequeue elements from L'\r\nas long as L'.size() > n.  This has the effect that list L' contains all\r\nthe elements in L that were accessed in the past n accesses.  We accepted\r\nsuch answer, even though the question asked you to make the *original* list\r\nL have this property.\r\n\r\n\r\nC-6.12,\r\n\r\nThis was a little tricky.  The following access pattern works.  Assume\r\nagain that \"l_i\" refer to an element that sits at index i in list L at the \r\nbeginning and that n = L.size():\r\n\r\ndo the following n times:\r\n  for i = 1 to n\r\n    access element l_i (wherever it currently resides in L)\r\n\r\nNote that this pattern consists of n^2 accesses to L.\r\n\r\nNote also that whenever element l_i is accessed, it is actually still at\r\nposition i in the list, and therefore it takes O(i) time to access this\r\nelement (and then O(1) time to move him to the front).  Therefore the\r\ntotal time taken by the \"for i = 1 to n\" loop is 1+2+3+...+n = \\Omega(n^2),\r\nand therefore the total time taken by this access pattern to process is\r\n\\Omega(n^3).\r\n\r\nSome students gave this as an answer:\r\n\r\nfor i = 1 to n\r\n  do the following n times:\r\n    access element l_i (wherever it currently resides in L)\r\n\r\nThis is not correct because the first access to l_i takes i steps.\r\nAll the subsequent accesses to l_i will take 1 step, and hence the\r\ntotal takes only O(n^2) time.\r\n\r\n\r\nR-8.7,\r\n\r\nThe answer depends on how exactly you program Insertion Sort,\r\nbut if the code is as on page 333, then the worst case is\r\nwhen the original list is actually in the *sorted* order.\r\nThis is because every time you insert a new element l_i you\r\nhave to traverse the already-sorted list, which takes time i,\r\nso the resulting time is 1+2+3+...+n = O(n^2).\r\n\r\nYou could implement Insertion Sort so that the algorithm\r\ntraverses the already-sorted list, searching for the place\r\nin which to insert the new element l_i, from the end to the\r\nbeginning, in which case the worst case is when the original\r\nlist is in the reverse-sorted order.\r\n\r\n\r\nC-8.4,\r\n\r\nHere you had to implement a Stack using a Priority Queue PQ\r\nand a constant integer c.  To do that, you could start up \r\nwith c equal to any value (e.g. 0), and an empty PQ,\r\nand implement the stack ADT as follows:\r\n\r\nPush(e) { PQ.insert(c,e); c--; }\r\nPop() { return PQ.removeMin() }\r\nTop() { return PQ.min(); }\r\nsize() { return PQ.size(); }\r\nisEmpty() { return PQ.isEmpty(); }\r\n\r\nYou could also increment c back when popping.\r\nOne student observed that you dont even need the constant c:\r\nYou could use just the negative of the current system time\r\ninstead of it, i.e.\r\n\r\nPush(e) { PQ.insert(-System.getTime(),e); }\r\n\r\n\r\nC-8.5\r\n\r\nHere you had to implement a Queue using a Priority Queue PQ\r\nand a constant integer c.  Again, you start up with c equal \r\nto any value (e.g. 0), and an empty PQ, and implement the \r\nstack ADT as follows:\r\n\r\nPush(e) { PQ.insert(c,e); c++; }\r\nPop() { return PQ.removeMin() }\r\nTop() { return PQ.min(); }\r\nsize() { return PQ.size(); }\r\nisEmpty() { return PQ.isEmpty(); }\r\n\r\nAgain, you could also decrement c back when popping,\r\nand you could do away with c by using the \r\ncurrent system time instead, i.e.\r\n\r\nPush(e) { PQ.insert(System.getTime(),e); }", "encoding": "ascii"}