{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/10.inttree", "content": "1-d queries with intervals\n    last time:\n\tdata = points\n\tquery = interval\n\trange = points in interval\n\n    this time:\n\tdata = intervals\n\tquery = point\n\trange = intervals containing point\n\t\t\t\n    so e.g. pixel-in-window query can solved by nested interval/pt queries\n\n2 techniques:\n\tsegment tree\n\tinterval tree\n\n\tsolve similar problems (interval range search)\n\thave similar sounding names\n\tare quite different from each other\n\n\ninterval trees\n\tgiven collection of intervals\n\n\tpick a point \"roughly in the middle\" e.g. median of int endpts\n\t\tform root of tree\n\t\tcollect all intervals containing that point there\n\t\tsorted two ways:\n\t\t\tby left endpoint\n\t\t\tby right endpoint\n\n\t\trecursively form tree for remaining intervals left & right\n\n\t=> tree with O(log n) levels\n\tO(n) space since each interval stored in a single level\n\tO(n log n) setup time or O(n) with sorted interval endpoints\n\n\tcan organize lists at each node in other ways\n\te.g. sorted by their left or right endpoints\n\n\twhat is it good for?\n\t\treduces range problems to O(log n) subproblems\n\t\tin which intervals all overlap\n\t\tincrease query time but does not increase space\n\n\tlist intervals containing given point:\n\t\tbinary search down interval tree\n\t\tat each node of search path, sequential scan sorted list\n\t\ttotal query time O(log n + k)\n\n\toverall result:\n\toverall space O(n)\n\tpt-in-interval range reporting O(log n + k)\n\n\tother kinds of range query:\n\t\tuse (augmented) binary search tree in place of sorted list\n\t\tbinary search to find solution\n\t\t=> total query time O(log^2 n)\n\n\tdynamic interval trees:\n\t\trotation difficult, use BB[alpha] trees\n\n\t\toverall structure:\n\t\tBB[alpha]-tree of segment endpoints\n\t\teach node stores search structure\n\t\t\tallowing constant-time scan from start\n\t\t\t(e.g. splay tree; bst with parents)\n\n\t\tinsert: add endpoints to tree\n\t\t\tfollow path down tree to store segment\n\n\t\tamortized time O(log n) per update\n\nsegment trees\n\tform balanced binary tree\n\teach node in tree => segment of line (not necessarily input interval)\n\ttwo children => split segment in two\n\n\teach input interval gets partitioned into O(log n) segments\n\t\tby binary search for its endpts,\n\t\ttaking segments along path between them\n\n\tstore all the segments from intervals at corresponding tree nodes\n\tspace O(n log n)\n\n\tanswers recursive range queries:\n\t\tintervals containing query pt or query interval\n\t\tO(log n) factor more space/preproc\n\t\tO(log n) larger query time\n\t\t[just put together answers within O(log n) tree nodes]\n\n\t\tbut have to be careful since will get same interval\n\t\tin different subproblems\n\t\tso e.g. range reporting O(log n) factor applies\n\t\tto dependence on k as well.\n\n\t(therefore all other types of queries as well,\n\t\tO(log n) or O(k log n) time O(n log n) space)\n\n\tcan also sometimes be used for other two ranges\n\n\nsolution to 2d pixel-in-window:\n\tfor all vertical intervals of windows containing pixel y coord\n\t\tfind best horiz intervals containing x coord\n\n\touter recursion: segment tree, O(log n) factor time&space\n\tinner range reporting: interval tree, O(log n) queries O(n) space\n\n\ttotal:\tO(log^2 n) per query\n\t\tO(n log n) space\n\t\tO(n log n) preprocessing time:\n\t\t\tO(n log n) presort x coordinates\n\t\t\tO(n log n) build seg tree preserving sorted order\n\t\t\t\tof x coordinates in subproblems\n\t\t\tO(n log n) build interval trees in sorted subprobs,\n\t\t\t\tlinear in total subprob size\n\nfurther improvement: \"fractional cascading\"\n\tinstead of binary searches in O(log n) different lists,\n\t\t(of endpoints at the O(log n) different levels of IT)\n\t\"simultaneously\" search all lists\n\n\tidea: from each lower level,\n\t\tpass up every other pt to next level up\n\ttotal # pts in all levels increases by (1+1/2+1/4+...)=2\n\tgiven position among given level,\n\t\tcan find position in next level in O(1) comparisons\n\n\tbut resulting binary searches are in sets with \"extra\" pts\n\tkeep ptrs to corresponding \"real\" pts\n", "encoding": "ascii"}