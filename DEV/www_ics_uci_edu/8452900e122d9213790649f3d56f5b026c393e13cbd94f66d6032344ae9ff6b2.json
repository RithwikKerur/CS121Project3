{"url": "https://www.ics.uci.edu/~aburtsev/143A/2018fall/hw/hw2-boot-xv6.html", "content": "<HTML>\n<HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">\n<TITLE>143A Principles of Operating Systems</TITLE>\n<LINK HREF=\"./css/main.css\" TYPE=\"text/css\" REL=\"stylesheet\">\n<META NAME=\"Description\" CONTENT=\"Home page of Anton Burtsev.\">\n<META NAME=\"Keywords\" CONTENT=\"Anton Burtsev, Burtsev, Anton, xv6, operating systems, 143A\">\n<SCRIPT SRC=\"./scripts/image_switcher.js\" LANGUAGE=\"JavaScript\"></SCRIPT>\n</HEAD>\n\n<BODY BGCOLOR=\"#FFFFFF\" LEFTMARGIN=\"0\" TOPMARGIN=\"0\" MARGINWIDTH=\"0\" MARGINHEIGHT=\"0\">\n\t<TABLE  ID=\"text\" ALIGN=\"CENTER\" WIDTH=\"600\" BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD>\n\t\t<DIV ID=\"tech_nav\">\n\t\t\t<A HREF=\"../index.html\">Home</A>\n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"30\" ALT=\"\" BORDER=\"0\"/>\n\t\t</DIV>\n\t</TD>\n\t</TR>\t\n\t<TR>\n\t<TD COLSPAN=\"4\" ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\">\n\n\n\t\t<P>\n\n\n\n<h1>Homework 2: Make QEMU, boot xv6, understand address translation</h1> \n\n<p>To start working on this homework follow the xv6 <a href=\"xv6-setup.html\">setup instructions</a>. After you're done with them, you'll be ready to start working on the assignment. \n\n<p><p> <h2>Exercise 1: Finding and breaking at an address</h2>\n\nFind the address of <code>_start</code>, the entry point of the kernel:\n<pre>\nopenlab$ nm kernel | grep _start\n8010b50c D _binary_entryother_start\n8010b4e0 D _binary_initcode_start\n0010000c T _start\nopenlab$\n</pre>\nIn this case, the address is <code>0010000c</code>.\n\n<p>\nRun the kernel inside QEMU GDB, setting a breakpoint\nat <code>_start</code> (i.e., the address\nyou just found).\n</p>\n\n<pre>\nopenlab$ make qemu-nox-gdb\n...\n</pre>\n\nNow open another terminal (<b>you do that on your openlab host machine, i.e., andromeda-XX, odin, or tristram, whichever you're using</b>).\nIn this new terminal change to the folder where you've built xv6, and start GDB: \n<pre>\nopenlab$ cd /vagrant/ics143a/xv6-public\nopenlab$ gdb\nGNU gdb 6.8-debian\nCopyright (C) 2008 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\n+ target remote localhost:26000\nThe target architecture is assumed to be i8086\n[f000:fff0]    0xffff0:\tljmp   $0xf000,$0xe05b\n0x0000fff0 in ?? ()\n+ symbol-file kernel\n</pre>\n\n<p>What you see on the screen is the assembly code of the BIOS that QEMU\nexecutes as part of the platform initialization. The BIOS starts at address\n<tt>0xfff0</tt> (you can read more about it in the <a\nhref=\"https://binarydebt.wordpress.com/2018/10/06/how-does-an-x86-processor-boot/\">How\nDoes an Intel Processor Boot?</a> blog post. You can single step through the\nBIOS machine code with the <tt>si</tt> (single instruction) GDB command if you\nlike, but it's hard to make sense of what is going on so lets skip it for now\nand get to the point when QEMU starts executing the xv6 kernel. \n\n<p>Set a breakpoint at the address of <tt>_start</tt>, e.g.  \n\n<pre> (gdb) br * 0x0010000c \nBreakpoint 1 at 0x10000c \n</pre>\n\n\n<!--(gdb) c Continuing.  The target\narchitecture is assumed to be i386 => 0x10000c:\tmov    %cr4,%eax\n\nBreakpoint 1, 0x0010000c in ?? ()\n(gdb)\n</pre>-->\n\nThe details of what you see may differ slightly from the above output.\n\n<h3>Troubleshooting GDB</h3>\n\n<pre>\nandromeda-1:1001-/16:40>gdb\nGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7\nCopyright (C) 2013 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-redhat-linux-gnu\".\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nwarning: File \"/home/aburtsev/projects/cs143a/xv6-public/.gdbinit\" auto-loading has been declined by your `auto-load safe-path' set to \"$debugdir:$datadir/auto-load:/usr/bin/mono-gdb.py\".\nTo enable execution of this file add\n\tadd-auto-load-safe-path /home/aburtsev/projects/cs143a/xv6-public/.gdbinit\nline to your configuration file \"/home/aburtsev/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"/home/aburtsev/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n(gdb) quit\n</pre>\n\nAdd the line \n\n<pre>add-auto-load-safe-path /home/aburtsev/projects/cs143a/xv6-public/.gdbinit</pre>\n\nto <pre>/home/aburtsev/.gdbinit</pre>\n\nbut of course replace my user name, \"aburtsev\", with yours. \n\n<h3>Task 1: Make yourself familiar with GDB</h3>\n\n<p>This part of the homework teaches you how to use GDB. If the xv6 and GDB are still running exit them. You can exit xv6 by terminating QEMU with <b>Ctrl-A X</b>. You can exit GDB by pressing \n<b>Ctrl-C</b> and then <b>Ctrl-D</b>.\n\n<p>Start the xv6 and gdb again as you did before (use two terminals one to start the xv6): \n\n<pre>make qemu-nox-gdb</pre>\n\nand another to start gdb\n\n<pre>gdb</pre>\n\n<p>Now explore the other ways of setting breakpoints. Instead of \n\n <pre>\n(gdb) br * 0x0010000c\n</pre>\n\nYou can use the name of the function or an assembly label, e.g., to set the breakpoint at the beginning of the <tt>_start</tt> label you can use: \n\n<pre>\n(gdb) br _start\n</pre>\n\n<p>Similar you can set the breakpoint on the <tt>main()</tt> function. \n\n<pre>\n(gdb) br main\n</pre>\n\nIf you need help with GDB commands, GDB can show you a list of all commands with \n\n<pre>\n(gdb) help all\n</pre>\n\n<p>Now since you set two breakpoints you can continue execution of the system until one of them \ngets hit. In gdb enter the \"c\" (continue) command to run xv6 until it hits the first breakpoint (<tt>_start</tt>). \n\n<pre>\n(gdb) c\n</pre>\n\n<p>Now use the <tt>si</tt> (step instruction) command to single step your execution (execute it one \nmachine instruction at a time). Remember that the <tt>_start</tt>\nlabel is defined in the assembly file, <tt>entry.S</tt> to be the entry point for the kernel. \nEnter <tt>si</tt> a couple of times. Note, you don't have to enter <tt>si</tt> every time, if you just \npress \"enter\" the GDB will execute the last command. \n\n<pre>\n(gdb) si\n</pre>\n\n<p>Every time you enter <tt>si</tt> it executes one machine instruction and shows you the next machine \ninstruction so you know what is coming next\n\n<pre>\n(gdb) si\n=> 0x10000f:\tor     $0x10,%eax\n0x0010000f in ?? ()\n</pre>\n\n<p>You can switch between ATT and Intel disassembly syntax with these commands: \n\n<pre>\n(gdb) set disassembly-flavor intel\n(gdb) set disassembly-flavor att\n</pre>\n\n<p>To make sure that you understand what is going on, open the <tt>entry.S</tt> file and look over it. Remember, \nthat the <tt>_start</tt> label is defined in this file. And the instructions that you were executing in GDB \ncome from exactly this file. Make sure that you understand what is happening \nthere (we covered in the lecture), i.e., the kernel works on enabling the 4MB page tables, and create a stack for executing the \nC code inside <tt>main()</tt>.\n\n<p>You can either continue single stepping until you reach the <tt>main()</tt> function, or you can enter \"c\" to continue \nexecution until the next breakpoint. \n\n<pre>\n(gdb) c\nContinuing.\n=> 0x80102e60 <main>:\tlea    0x4(%esp),%ecx\n\nThread 1 hit Breakpoint 2, main () at main.c:19\n</pre>\n\n<p> Now you've reached the C code, and since we compiled it with the \"-g\" flag\nthat includes the symbol information into the ELF file we can see the C source\ncode that we're executing. Enter the <tt>l</tt> (list) command. \n\n<pre>\n(gdb) l\n14\t// Bootstrap processor starts running C code here.\n15\t// Allocate a real stack and switch to it, first\n16\t// doing some setup required for memory allocator to work.\n17\tint\n18\tmain(void)\n19\t{\n20\t  kinit1(end, P2V(4*1024*1024)); // phys page allocator\n21\t  kvmalloc();      // kernel page table\n22\t  mpinit();        // detect other processors\n23\t  lapicinit();     // interrupt controller\n</pre>\n\n<p>Remember that when you hit the <tt>main</tt> breakpoint the GDB showed you that you're at line 19 in the main.c file (<tt>main.c:19</tt>). This is where you are. You can either step into the \nfunctions with the <tt>s</tt> (step) command (note, in contrast to the <tt>si</tt> step instruction command, this one will execute <b>one C line at a time</b>), or step over the functions with the <tt>n</tt> (next) command which will not enter the function, but instead will execute it till completion. \n\n<p>Try stepping into the <tt>kinit1</tt> function. \n\n<pre>\n(gdb) s\n</pre>\n\n<p>Note, that on my machine when I enter <tt>s</tt> for the first time the GDB believes that I'm executing the <tt>startothers()</tt> function. It's a glitch---the compiler generated an incorrect debug symbol information and GDB is confused. If I hit <tt>s</tt> a couple of times I eventually get to <tt>kinit1()</tt>. \n\n<p>The whole listing of the source code seems a bit inconvenient (entering <tt>l</tt> every time you want to see the source line is a bit annoying). GDB provides a more conventional way of following the program execution with the TUI mechanism. Enable it with the following GDB command\n\n<pre>\n(gdb) tui enable\n</pre>\n\n<p>Now you see the source code window and the machine instructions at the bottom. You can use the same commands to walk through your program. You can scroll the source with arrow keys, PgUp, and PgDown.  \n\n<p>TUI can show you the state of the registers and how they are changing as you execute your code\n\n<pre>\n(gdb) tui reg general\n</pre>\n\n<p>TUI is a very cute part of GDB and hence it makes sense to read more about various capabilities <a href=\"http://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html\">http://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html</a>. For example, you can specify the assembly layout to single step through machine instructions similar to source code: \n\n<pre>\n(gdb) layout asm\n</pre>\n\nFor example, you can switch to the asm layout right after hitting the <tt>_start</tt> breakpoint. \n\n\n<h3>Question 1: What is on the stack?</h3>\n\n<p>Restart your xv6 and gdb session. Set a breakpoint at the <tt>_start</tt> label.\n\n<pre>\n(gdb) br _start\n</pre>\n\nContinue execution until the breakpoint is hit. Look at the registers and the stack contents:\n\n<pre>\n(gdb) info reg\n...\n(gdb) x/24x $esp\n...\n(gdb)\n</pre>\n\n<p>Write a short (3-5 word) comment next to each <b>zero and non-zero</b> value of the printout\nexplaining what it is.  Which part of the printout is actually the stack?\n(Hint: not all of it.)\n\n<p>You might find it convenient to consult the files bootasm.S, bootmain.c, and\nbootblock.asm (this last file is contains assmbly generated by the compiler from both C and ASM files). A\nshort <a href=\"http://www.cs.virginia.edu/~evans/cs216/guides/x86.html\">x86 Assembly Guide</a> and additional \nresources from the MIT <a\nhref=\"http://pdos.csail.mit.edu/6.828/2018/reference.html\">reference page</a>\nprovide pointers to x86 assembly documentation, if you are wondering about the\nsemantics of a particular instruction.  Here are some questions to help you\nalong:\n\n<ul>\n\n<li>Start by setting a break-point at 0x7c00, the start of the boot\n  block (bootasm.S). Single step\n  through the instructions. Where in bootasm.S the stack pointer is initialized?\n\n<li>Single step through the call to <tt>bootmain</tt>; what is on the stack now?\n\n<li>What do the first <it>assembly</it> instructions of bootmain do to the\nstack? Look for bootmain in bootblock.asm.\n\n<li>Look in bootmain in bootblock.asm for the call that changes <tt>eip</tt> to\n  </tt>0x10000c</tt>.  What does that call do to the stack?\n  \n</ul>\n\n<h3>Tip</h3>\n \nSince we're running QEMU in headless mode (`make clean qemu-nox`) you don't\nhave a GUI window to close whenever you want. There are two ways to exit QEMU. \n\n<ol>\n\n<li>First, you can exit the xv6 QEMU session by killing the QEMU process from another terminal. \nA useful shortcut is to define an `alias` in your local machine as follows:\n\n\n<pre>\nalias kill-qemu='killall qemu-system-i386'\n</pre>\n\n<p>Add this to your `~/.bash_profile` or `~/.zshrc` file to make it persistant.\n\n<p>If you're still using Vagrant this becomes\n\n<pre>\nalias kill-qemu='vagrant ssh -c \"killall qemu-system-i386\"'\n</pre>\n\nThis will send the `killall qemu-system-i386` command over ssh to your vagrant machine.\nNotice this command will only work if you're running it from somewhere in the directory path of the Vagrantfile running this machine\n</li>\n\n<li>\nAlternatively you can send a <b>Ctrl-a x</b> command to the QEMU emulator forcing it to exit \n(here is a <a href=\"http://wiki.qemu-project.org/download/qemu-doc.html#mux_005fkeys\">list of QEMU\nshortcuts and commands</a>). \n</li>\n</ol>\n\n<p>You can find more information about QEMU monitor and GDB debugger  <a\nhref=\"https://pdos.csail.mit.edu/6.828/2011/labguide.html\">here</a>, feel free\nto explore them.  </p>\n\n<h2>Exercise 2: Understanding address translation</h2>\n\n<h3>Question 1: Explain how logical to physical address translation works</h3>\n\nThis question asks you to illustrate organization of the x86, 4K, 32bit segmentation \nand paging mechanisms through a simple example. Assume that the hardware\ntranslates the logical address '0x803004' that is involved into a memory access\nin the data segment into the physical address '0x8004'. The physical addresses\nof the page table directory (Level 1) and the page table (Level 2) involved in\nthe translation of this virtual address are respectively 0x5000 and 0x8000. The\nentry 1 of the Global Descriptor Table (GDB) contains the base of 0x1000000 and\nthe limit of 2GBs. The DS register contains the value 0x8. Draw a diagram (hand\ndrawn figures are sufficient, but need to be clear) representing the state of\nthe GDT, page table, and hardware CPU registers pointing to the GDT and page\ntable directory and the process of translation (similar to Figure 2-1 in the\nxv6 book but using concrete physical and virtual addresses and page table\nentries).  Provide a short explanation.  Use Chapter 2 of the <a\nhref=https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf\">xv6 book</a> to\nreview how page tables work.  \n\n<h2>Extra credit (5%): Can you explain the nature of the memory access in the question above?</h2>\n\n\n<h2>Extra credit (15%): What is the state of page tables after xv6 is done\ninitializing the first 4K page table?</h2>\n\nDuring boot, xv6 calls the <tt>kvmalloc()</tt> function to set up the kernel\npage table (<tt>kvmalloc()</tt> is called from <tt>main()</tt>).  What is the\nstate of this first 4K page table after <tt>kvmalloc()</tt> returns, and what\nare the details of page table initialization? \n\nTo understand the state of the page table, we first take a look at the\nimplementation of the <tt>kvmalloc</tt> function and then inspect the actual\npage tables with the QEMU monitor. \n\n<!--\n<h3>Question 1: Explain implementation of <tt>kvmalloc()</tt> and related functions</h3>\n\nUse <a href=\"https://pdos.csail.mit.edu/6.828/2016/xv6/xv6-rev9.pdf\">xv6 source\ncode</a> to understand and explain implementation of the following functions:\n<tt>setupkvm()</tt>, <tt> walkpgdir()</tt>, <tt>mappages()</tt>, and their role\nin the implementation of <tt>kvmalloc()</tt>. Use line numbers from the source\nprintout to refer to specific places of code. Provide a reasonably detailed\ndescription for individual lines of code to demonstrate your understanding of\nthe code. \n\n<h3>Question 2: What is the state of page tables after <tt>kvmalloc()</tt>\nreturns?</h3>\n-->\n\nBased on your analysis of the source code, and based on the inspection of the\npage tables with the QEMU monitor, explain the state of the page tables after\n<tt>kvmalloc()</tt> is done. Draw a figure of a page table, and briefly explain\neach page table entry. \n\n<p>To aid your analysis, inspect the actual page table with QEMU. QEMU includes\na built-in monitor that can inspect and modify the machine state in useful\nways.  To enter the monitor, press <b>Ctrl-a c</b> in the terminal running\nQEMU.  Press <b>Ctrl-a c</b> again to switch back to the serial console.</p>\n\nTo inspect the page table, run xv6 to the point after it is done with\n<tt>kvmalloc()</tt>.  Similar to Exercise 1, open two terminal windows. In one\nwindow start xv6 under control of the GDB debugger\n\n<pre>\nopenlab$make qemu-nox-gdb\n</pre>\n\nIn the GDB window set breakpoint on <tt>main</tt> function, run continue (c), and run (n) executing functions inside <tt>main</tt> until you exit <tt>kvmalloc()</tt> (use \"n\" three times):\n<pre>\n(gdb) b main\n(gdb) c\nContinuing.\nThe target architecture is assumed to be i386\n=> 0x80102eb0 <main>:\tpush   %ebp\n\nBreakpoint 1, main () at main.c:19\n19\t{\n(gdb) n\n=> 0x80102eba <main+10>:\tmovl   $0x80400000,0x4(%esp)\n20\t  kinit1(end, P2V(4*1024*1024)); // phys page allocator\n(gdb) n\n=> 0x80102ece <main+30>:\tcall   0x80106790 <kvmalloc>\n21\t  kvmalloc();      // kernel page table\n(gdb) n\n=> 0x80102ed3 <main+35>:\tcall   0x80103070 <mpinit>\n22\t  mpinit();        // detect other processors\n</pre>\n\n<p>At this point switch back to the terminal running the QEMU monitor and type\n<tt>info pg</tt> to display the state of the active page table. You will see\npage directory entries and page table entries along with the permissions for\neach separately.  Repeated PTE's and entire page tables are folded up into a\nsingle line.  For example,\n\n  <pre>VPN range     Entry         Flags        Physical page\n[00000-003ff]  PDE[000]     -------UWP\n  [00200-00233]  PTE[200-233] -------U-P 00380 0037e 0037d 0037c 0037b 0037a ..\n[00800-00bff]  PDE[002]     ----A--UWP\n  [00800-00801]  PTE[000-001] ----A--U-P 0034b 00349\n  [00802-00802]  PTE[002]     -------U-P 00348\n</pre>\n\n  This shows two page directory entries, spanning virtual addresses\n  0x00000000 to 0x003fffff and 0x00800000 to 0x00bfffff, respectively.\n  Both PDE's are present, writable, and user and the second PDE is also\n  accessed.  The second of these page tables maps three pages, spanning\n  virtual addresses 0x00800000 through 0x00802fff, of which the first\n  two are present, user, and accessed and the third is only present and\n  user.  The first of these PTE's maps physical page 0x34b.\n</p>\n\n\n<div class=\"question\"> <p><b>If you're using Vagrant, shut down your VM</b> <p>After you're done please halt your VM so it does not run on the cluster forever. All the xv6 files will be there in the cs238p/xv6-vagrant-master folder when you start vagrant the next time. \n\n<p>To shut down your VM, when you close your ssh connection type\n<pre> \nUCInetID@andromeda-XX$ vagrant halt\n</pre>\n\n<p>You will be able to start your Vagrant VM from the same folder (cs238p/xv6-vagrant-master) by typing\n<pre> \nUCInetID@andromeda-XX$ vagrant up\nUCInetID@andromeda-XX$ vagrant ssh\n</pre>\n\n\n\n<div class=\"question\"> <p><b>Submit</b> <p>Submit your answers in a single PDF file named <tt>hw2.pdf</tt> on Canvas <a href=\"https://canvas.eee.uci.edu/courses/12602\">HW2 Boot xv6</a>. \n\n</div>\n\n\t</TD>\t\t\t\n\t</TR>\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD COLSPAN=\"4\">\n\t\t<DIV ID=\"tech\">Updated: October, 2018</DIV>\n\t</TD>\n\t</TR>\n\t</TABLE>\n</BODY>\n</HTML>\n\n\n", "encoding": "ascii"}