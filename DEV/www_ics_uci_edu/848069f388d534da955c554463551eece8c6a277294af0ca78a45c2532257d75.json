{"url": "https://www.ics.uci.edu/~ejw/authoring/uuid-guid/draft-leach-uuids-guids-01.txt", "content": "\n\n\n\n\n\nNetwork Working Group               Paul J. Leach, Microsoft\nINTERNET-DRAFT                             Rich Salz, Certco\n<draft-leach-uuids-guids-01.txt>\nCategory: Standards Track\nExpires August 4, 1998                      February 4, 1998\n\n\n\n                             UUIDs and GUIDs\n\nSTATUS OF THIS MEMO\n\n  This document is an Internet-Draft. Internet-Drafts are working\n  documents of the Internet Engineering Task Force (IETF), its areas,\n  and its working groups. Note that other groups may also distribute\n  working documents as Internet-Drafts.\n\n  Internet-Drafts are draft documents valid for a maximum of six months\n  and may be updated, replaced, or obsoleted by other documents at any\n  time. It is inappropriate to use Internet-Drafts as reference\n  material or to cite them other than as \"work in progress\".\n\n  To learn the current status of any Internet-Draft, please check the\n  \"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow\n  Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),\n  munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or\n  ftp.isi.edu (US West Coast).\n\n  Distribution of this document is unlimited.  Please send comments to\n  the authors or the CIFS mailing list at <cifs@discuss.microsoft.com>.\n  Discussions of the mailing list are archived at\n  <URL:http://discuss.microsoft.com/archives/index.\n\n\nABSTRACT\n\n  This specification defines the format of UUIDs (Universally Unique\n  IDentifier), also known as GUIDs (Globally Unique IDentifier). A UUID\n  is 128 bits long, and if generated according to the one of the\n  mechanisms in this document, is either guaranteed to be different\n  from all other UUIDs/GUIDs generated until 3400 A.D. or extremely\n  likely to be different (depending on the mechanism chosen). UUIDs\n  were originally used in the Network Computing System (NCS) [1] and\n  later in the Open Software Foundation's (OSF) Distributed Computing\n  Environment [2].\n\n  This specification is derived from the latter specification with the\n  kind permission of the OSF.\n\n\nTable of Contents\n\n1. Introduction .......................................................3\n\n\n[Page 1]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n2. Motivation .........................................................3\n\n3. Specification ......................................................3\n\n 3.1 Format............................................................4\n\n   3.1.1  Variant......................................................4\n\n   3.1.2  UUID layout..................................................5\n\n   3.1.3  Version......................................................5\n\n   3.1.4  Timestamp....................................................6\n\n   3.1.5  Clock sequence...............................................6\n\n   3.1.6  Node.........................................................7\n\n   3.1.7  Nil UUID.....................................................7\n\n 3.2 Algorithms for creating a time-based UUID.........................7\n\n   3.2.1  Basic algorithm..............................................7\n\n   3.2.2  Reading stable storage.......................................8\n\n   3.2.3  System clock resolution......................................8\n\n   3.2.4  Writing stable storage.......................................9\n\n   3.2.5  Sharing state across processes...............................9\n\n   3.2.6  UUID Generation details......................................9\n\n 3.3 Algorithm for creating a name-based UUID.........................10\n\n 3.4 Algorithms for creating a UUID from truly random or pseudo-random\n numbers .............................................................11\n\n 3.5 String Representation of UUIDs...................................12\n\n 3.6 Comparing UUIDs for equality.....................................12\n\n 3.7 Comparing UUIDs for relative order...............................13\n\n 3.8 Byte order of UUIDs..............................................13\n\n4. Node IDs when no IEEE 802 network card is available ...............14\n\n5. Obtaining IEEE 802 addresses ......................................15\n\n6. Security Considerations ...........................................15\n\n7. Acknowledgements ..................................................15\n\n  Leach, Salz              expires  Aug 1998                    [Page 2]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n8. References ........................................................15\n\n9. Authors' addresses ................................................16\n\n10.Notice ............................................................16\n\n11.Full Copyright Statement ..........................................16\n\nAppendix A _ UUID Sample Implementation...............................17\n\nAppendix B _ Sample output of utest...................................27\n\nAppendix C _ Some name space IDs......................................27\n\n\n\n\n1. Introduction\n\n  This specification defines the format of UUIDs (Universally Unique\n  IDentifiers), also known as GUIDs (Globally Unique IDentifiers). A\n  UUID is 128 bits long, and if generated according to the one of the\n  mechanisms in this document, is either guaranteed to be different\n  from all other UUIDs/GUIDs generated until 3400 A.D. or extremely\n  likely to be different (depending on the mechanism chosen).\n\n\n2. Motivation\n\n  One of the main reasons for using UUIDs is that no centralized\n  authority is required to administer them (beyond the one that\n  allocates IEEE 802.1 node identifiers). As a result, generation on\n  demand can be completely automated, and they can be used for a wide\n  variety of purposes. The UUID generation algorithm described here\n  supports very high allocation rates: 10 million per second per\n  machine if you need it, so that they could even be used as\n  transaction IDs.\n\n  UUIDs are fixed-size (128-bits) which is reasonably small relative to\n  other alternatives. This fixed, relatively small size lends itself\n  well to sorting, ordering, and hashing of all sorts, storing in\n  databases, simple allocation, and ease of programming in general.\n\n\n3. Specification\n\n  A UUID is an identifier that is unique across both space and time,\n  with respect to the space of all UUIDs. To be precise, the UUID\n  consists of a finite bit space. Thus the time value used for\n  constructing a UUID is limited and will roll over in the future\n  (approximately at A.D. 3400, based on the specified algorithm). A\n  UUID can be used for multiple purposes, from tagging objects with an\n  extremely short lifetime, to reliably identifying very persistent\n  objects across a network.\n\n  Leach, Salz              expires  Aug 1998                    [Page 3]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  The generation of UUIDs does not require that a registration\n  authority be contacted for each identifier. Instead, it requires a\n  unique value over space for each UUID generator. This spatially\n  unique value is specified as an IEEE 802 address, which is usually\n  already available to network-connected systems. This 48-bit address\n  can be assigned based on an address block obtained through the IEEE\n  registration authority. This section of the UUID specification\n  assumes the availability of an IEEE 802 address to a system desiring\n  to generate a UUID, but if one is not available section 4 specifies a\n  way to generate a probabilistically unique one that can not conflict\n  with any properly assigned IEEE 802 address.\n\n\n3.1 Format\n\n  In its most general form, all that can be said of the UUID format is\n  that a UUID is 16 octets, and that some bits of octet 8 of the UUID\n  called the variant field (specified in the next section) determine\n  finer structure.\n\n\n3.1.1 Variant\n  The variant field determines the layout of the UUID. That is, the\n  interpretation of all other bits in the UUID depends on the setting\n  of the bits in the variant field. The variant field consists of a\n  variable number of the msbs of octet 8 of the UUID.\n\n  The following table lists the contents of the variant field.\n\n       Msb0  Msb1   Msb2  Description\n\n        0      -     -    Reserved, NCS backward compatibility.\n\n        1      0     -    The variant specified in this document.\n\n        1      1     0    Reserved, Microsoft Corporation backward\n                          compatibility\n\n        1      1     1    Reserved for future definition.\n\n\n\n  Other UUID variants may not interoperate with the UUID variant\n  specified in this document, where interoperability is defined as the\n  applicability of operations such as string conversion and lexical\n  ordering across different systems. However, UUIDs allocated according\n  to the stricture of different variants, though they may define\n  different interpretations of the bits outside the variant field, will\n  not result in duplicate UUID allocation, because of the differing\n  values of the variant field itself.\n\n  The remaining fields described below (version, timestamp, etc.) are\n  defined only for the UUID variant noted above.\n\n\n  Leach, Salz              expires  Aug 1998                    [Page 4]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n3.1.2 UUID layout\n  The following table gives the format of a UUID for the variant\n  specified herein. The UUID consists of a record of 16 octets. To\n  minimize confusion about bit assignments within octets, the UUID\n  record definition is defined only in terms of fields that are\n  integral numbers of octets. The fields are in order of significance\n  for comparison purposes, with \"time_low\" the most significant, and\n  \"node\" the least significant.\n\n   Field                  Data Type     Octet  Note\n                                        #\n\n   time_low               unsigned 32   0-3    The low field of the\n                          bit integer          timestamp.\n\n   time_mid               unsigned 16   4-5    The middle field of the\n                          bit integer          timestamp.\n\n   time_hi_and_version    unsigned 16   6-7    The high field of the\n                          bit integer          timestamp multiplexed\n                                               with the version number.\n\n   clock_seq_hi_and_rese  unsigned 8    8      The high field of the\n   rved                   bit integer          clock sequence\n                                               multiplexed with the\n                                               variant.\n\n   clock_seq_low          unsigned 8    9      The low field of the\n                          bit integer          clock sequence.\n\n   node                   unsigned 48   10-15  The spatially unique\n                          bit integer          node identifier.\n\n\n\n\n3.1.3 Version\n  The version number is in the most significant 4 bits of the time\n  stamp (time_hi_and_version).\n\n  The following table lists currently defined versions of the UUID.\n\n       Msb0  Msb1   Msb2  Msb3   Version  Description\n\n        0      0     0      1       1     The time-based version\n                                          specified in this\n                                          document.\n\n        0      0     1      0       2     Reserved for DCE\n                                          Security version, with\n                                          embedded POSIX UIDs.\n\n        0      0     1      1       3     The name-based version\n                                          specified in this\n\n  Leach, Salz              expires  Aug 1998                    [Page 5]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n                                          document\n\n        0      1     0      0       4     The randomly or pseudo-\n                                          randomly generated\n                                          version specified in\n                                          this document\n\n\n3.1.4 Timestamp\n  The timestamp is a 60 bit value. For UUID version 1, this is\n  represented by Coordinated Universal Time (UTC) as a count of 100-\n  nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of\n  Gregorian reform to the Christian calendar).\n\n  For systems that do not have UTC available, but do have local time,\n  they MAY use local time instead of UTC, as long as they do so\n  consistently throughout the system. This is NOT RECOMMENDED, however,\n  and it should be noted that all that is needed to generate UTC, given\n  local time, is a time zone offset.\n\n  For UUID version 3, it is a 60 bit value constructed from a name.\n\n  For UUID version 4, it is a randomly or pseudo-randomly generated 60\n  bit value.\n\n\n3.1.5 Clock sequence\n  For UUID version 1, the clock sequence is used to help avoid\n  duplicates that could arise when the clock is set backwards in time\n  or if the node ID changes.\n\n  If the clock is set backwards, or even might have been set backwards\n  (e.g., while the system was powered off), and the UUID generator can\n  not be sure that no UUIDs were generated with timestamps larger than\n  the value to which the clock was set, then the clock sequence has to\n  be changed. If the previous value of the clock sequence is known, it\n  can be just incremented; otherwise it should be set to a random or\n  high-quality pseudo random value.\n\n  Similarly, if the node ID changes (e.g. because a network card has\n  been moved between machines), setting the clock sequence to a random\n  number minimizes the probability of a duplicate due to slight\n  differences in the clock settings of the machines. (If the value of\n  clock sequence associated with the changed node ID were known, then\n  the clock sequence could just be incremented, but that is unlikely.)\n\n  The clock sequence MUST be originally (i.e., once in the lifetime of\n  a system) initialized to a random number to minimize the correlation\n  across systems. This provides maximum protection against node\n  identifiers that may move or switch from system to system rapidly.\n  The initial value MUST NOT be correlated to the node identifier.\n\n  For UUID version 3, it is a 14 bit value constructed from a name.\n\n\n  Leach, Salz              expires  Aug 1998                    [Page 6]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  For UUID version 4, it is a randomly or pseudo-randomly generated 14\n  bit value.\n\n\n3.1.6 Node\n  For UUID version 1, the node field consists of the IEEE address,\n  usually the host address. For systems with multiple IEEE 802\n  addresses, any available address can be used. The lowest addressed\n  octet (octet number 10) contains the global/local bit and the\n  unicast/multicast bit, and is the first octet of the address\n  transmitted on an 802.3 LAN.\n\n  For systems with no IEEE address, a randomly or pseudo-randomly\n  generated value may be used (see section 4). The multicast bit must\n  be set in such addresses, in order that they will never conflict with\n  addresses obtained from network cards.\n\n  For UUID version 3, the node field is a 48 bit value constructed from\n  a name.\n\n  For UUID version 4, the node field is a randomly or pseudo-randomly\n  generated 48 bit value.\n\n\n3.1.7 Nil UUID\n  The nil UUID is special form of UUID that is specified to have all\n  128 bits set to 0 (zero).\n\n\n3.2 Algorithms for creating a time-based UUID\n\n  Various aspects of the algorithm for creating a version 1 UUID are\n  discussed in the following sections. UUID generation requires a\n  guarantee of uniqueness within the node ID for a given variant and\n  version. Interoperability is provided by complying with the specified\n  data structure.\n\n\n3.2.1 Basic algorithm\n  The following algorithm is simple, correct, and inefficient:\n\n  .  Obtain a system wide global lock\n\n  .  From a system wide shared stable store (e.g., a file), read the\n     UUID generator state: the values of the time stamp, clock sequence,\n     and node ID used to generate the last UUID.\n\n  .  Get the current time as a 60 bit count of 100-nanosecond intervals\n     since 00:00:00.00, 15 October 1582\n\n  .  Get the current node ID\n\n\n\n\n  Leach, Salz              expires  Aug 1998                    [Page 7]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  .  If the state was unavailable (non-existent or corrupted), or the\n     saved node ID is different than the current node ID, generate a\n     random clock sequence value\n\n  .  If the state was available, but the saved time stamp is later than\n     the current time stamp, increment the clock sequence value\n\n  .  Format a UUID from the current time stamp, clock sequence, and node\n     ID values according to the structure in section 3.1 (see section\n     3.2.6 for more details)\n\n  .  Save the state (current time stamp, clock sequence, and node ID)\n     back to the stable store\n\n  .  Release the system wide global lock\n\n  If UUIDs do not need to be frequently generated, the above algorithm\n  may be perfectly adequate. For higher performance requirements,\n  however, issues with the basic algorithm include:\n\n  .  Reading the state from stable storage each time is inefficient\n\n  .  The resolution of the system clock may not be 100-nanoseconds\n\n  .  Writing the state to stable storage each time is inefficient\n\n  .  Sharing the state across process boundaries may be inefficient\n\n  Each of these issues can be addressed in a modular fashion by local\n  improvements in the functions that read and write the state and read\n  the clock. We address each of them in turn in the following sections.\n\n\n3.2.2 Reading stable storage\n  The state only needs to be read from stable storage once at boot\n  time, if it is read into a system wide shared volatile store (and\n  updated whenever the stable store is updated).\n\n  If an implementation does not have any stable store available, then\n  it can always say that the values were unavailable. This is the least\n  desirable implementation, because it will increase the frequency of\n  creation of new clock sequence numbers, which increases the\n  probability of duplicates.\n\n  If the node ID can never change (e.g., the net card is inseparable\n  from the system), or if any change also reinitializes the clock\n  sequence to a random value, then instead of keeping it in stable\n  store, the current node ID may be returned.\n\n\n3.2.3 System clock resolution\n  The time stamp is generated from the system time, whose resolution\n  may be less than the resolution of the UUID time stamp.\n\n\n  Leach, Salz              expires  Aug 1998                    [Page 8]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  If UUIDs do not need to be frequently generated, the time stamp can\n  simply be the system time multiplied by the number of 100-nanosecond\n  intervals per system time interval.\n\n  If a system overruns the generator by requesting too many UUIDs\n  within a single system time interval, the UUID service MUST either:\n  return an error, or stall the UUID generator until the system clock\n  catches up.\n\n  A high resolution time stamp can be simulated by keeping a count of\n  how many UUIDs have been generated with the same value of the system\n  time, and using it to construction the low-order bits of the time\n  stamp. The count will range between zero and the number of 100-\n  nanosecond intervals per system time interval.\n\n  Note: if the processors overrun the UUID generation frequently,\n  additional node identifiers can be allocated to the system, which\n  will permit higher speed allocation by making multiple UUIDs\n  potentially available for each time stamp value.\n\n\n3.2.4 Writing stable storage\n  The state does not always need to be written to stable store every\n  time a UUID is generated. The timestamp in the stable store can be\n  periodically set to a value larger than any yet used in a UUID; as\n  long as the generated UUIDs have time stamps less than that value,\n  and the clock sequence and node ID remain unchanged, only the shared\n  volatile copy of the state needs to be updated. Furthermore, if the\n  time stamp value in stable store is in the future by less than the\n  typical time it takes the system to reboot, a crash will not cause a\n  reinitialization of the clock sequence.\n\n\n3.2.5 Sharing state across processes\n  If it is too expensive to access shared state each time a UUID is\n  generated, then the system wide generator can be implemented to\n  allocate a block of time stamps each time it is called, and a per-\n  process generator can allocate from that block until it is exhausted.\n\n\n3.2.6 UUID Generation details\n  UUIDs are generated according to the following algorithm:\n\n  - Determine the values for the UTC-based timestamp and clock sequence\n  to be used in the UUID, as described above.\n\n  - For the purposes of this algorithm, consider the timestamp to be a\n  60-bit unsigned integer and the clock sequence to be a 14-bit\n  unsigned integer. Sequentially number the bits in a field, starting\n  from 0 (zero) for the least significant bit.\n\n  - Set the time_low field equal to the least significant 32-bits (bits\n  numbered 0 to 31 inclusive) of the time stamp in the same order of\n  significance.\n\n  Leach, Salz              expires  Aug 1998                    [Page 9]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  - Set the time_mid field equal to the bits numbered 32 to 47\n  inclusive of the time stamp in the same order of significance.\n\n  - Set the 12 least significant bits (bits numbered 0 to 11 inclusive)\n  of the time_hi_and_version field equal to the bits numbered 48 to 59\n  inclusive of the time stamp in the same order of significance.\n\n  - Set the 4 most significant bits (bits numbered 12 to 15 inclusive)\n  of the time_hi_and_version field to the 4-bit version number\n  corresponding to the UUID version being created, as shown in the\n  table in section 3.1.3.\n\n  - Set the clock_seq_low field to the 8 least significant bits (bits\n  numbered 0 to 7 inclusive) of the clock sequence in the same order of\n  significance.\n\n  - Set the 6 least significant bits (bits numbered 0 to 5 inclusive)\n  of the clock_seq_hi_and_reserved field to the 6 most significant bits\n  (bits numbered 8 to 13 inclusive) of the clock sequence in the same\n  order of significance.\n\n  - Set the 2 most significant bits (bits numbered 6 and 7) of the\n  clock_seq_hi_and_reserved to 0 and 1, respectively.\n\n  - Set the node field to the 48-bit IEEE address in the same order of\n  significance as the address.\n\n\n3.3 Algorithm for creating a name-based UUID\n\n  The version 3 UUID is meant for generating UUIDs from \"names\" that\n  are drawn from, and unique within, some \"name space\". Some examples\n  of names (and, implicitly, name spaces) might be DNS names, URLs, ISO\n  Object IDs (OIDs), reserved words in a programming language, or X.500\n  Distinguished Names (DNs); thus, the concept of name and name space\n  should be broadly construed, and not limited to textual names. The\n  mechanisms or conventions for allocating names from, and ensuring\n  their uniqueness within, their name spaces are beyond the scope of\n  this specification.\n\n  The requirements for such UUIDs are as follows:\n\n  .  The UUIDs generated at different times from the same name in the\n     same namespace MUST be equal\n\n  .  The UUIDs generated from two different names in the same namespace\n     should be different (with very high probability)\n\n  .  The UUIDs generated from the same name in two different namespaces\n     should be different with (very high probability)\n\n  .  If two UUIDs that were generated from names are equal, then they\n     were generated from the same name in the same namespace (with very\n     high probability).\n\n  Leach, Salz              expires  Aug 1998                   [Page 10]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  The algorithm for generating the a UUID from a name and a name space\n  are as follows:\n\n  .  Allocate a UUID to use as a \"name space ID\" for all UUIDs generated\n     from names in that name space\n\n  .  Convert the name to a canonical sequence of octets (as defined by\n     the standards or conventions of its name space); put the name space\n     ID in network byte order\n\n  .  Compute the MD5 [3] hash of the name space ID concatenated with the\n     name\n\n  .  Set octets 0-3 of  time_low field to octets 0-3 of the MD5 hash\n\n  .  Set octets 0-1 of  time_mid field to octets 4-5 of the MD5 hash\n\n  .  Set octets 0-1 of  time_hi_and_version field to octets 6-7 of the\n     MD5 hash\n\n  .  Set the clock_seq_hi_and_reserved field to octet 8 of the MD5 hash\n\n  .  Set the clock_seq_low field to octet 9 of the MD5 hash\n\n  .  Set octets 0-5 of the node field to octets 10-15 of the MD5 hash\n\n  .  Set the 2 most significant bits (bits numbered 6 and 7) of the\n     clock_seq_hi_and_reserved to 0 and 1, respectively.\n\n  .  Set the 4 most significant bits (bits numbered 12 to 15 inclusive)\n     of the time_hi_and_version field to the 4-bit version number\n     corresponding to the UUID version being created, as shown in the\n     table above.\n\n  .  Convert the resulting UUID to local byte order.\n\n\n3.4 Algorithms for creating a UUID from truly random or pseudo-random\nnumbers\n\n  The version 4 UUID is meant for generating UUIDs from truly-random or\n  pseudo-random numbers.\n\n  The algorithm is as follows:\n\n  .  Set the 2 most significant bits (bits numbered 6 and 7) of the\n     clock_seq_hi_and_reserved to 0 and 1, respectively.\n\n  .  Set the 4 most significant bits (bits numbered 12 to 15 inclusive)\n     of the time_hi_and_version field to the 4-bit version number\n     corresponding to the UUID version being created, as shown in the\n     table above.\n\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 11]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  .  Set all the other bits to randomly (or pseudo-randomly) chosen\n     values.\n\n  Here are several possible ways to generate the random values:\n\n  .  Use a physical source of randomness: for example, a white noise\n     generator, radioactive decay, or a lava lamp.\n\n  .  Use a cryptographic strength random number generator.\n\n\n3.5 String Representation of UUIDs\n\n  For use in human readable text, a UUID string representation is\n  specified as a sequence of fields, some of which are separated by\n  single dashes.\n\n  Each field is treated as an integer and has its value printed as a\n  zero-filled hexadecimal digit string with the most significant digit\n  first. The hexadecimal values a to f inclusive are output as lower\n  case characters, and are case insensitive on input. The sequence is\n  the same as the UUID constructed type.\n\n  The formal definition of the UUID string representation is provided\n  by the following extended BNF:\n\n  UUID                   = <time_low> \"-\" <time_mid> \"-\"\n                           <time_high_and_version> \"-\"\n                           <clock_seq_and_reserved>\n                           <clock_seq_low> \"-\" <node>\n  time_low               = 4*<hexOctet>\n  time_mid               = 2*<hexOctet>\n  time_high_and_version  = 2*<hexOctet>\n  clock_seq_and_reserved = <hexOctet>\n  clock_seq_low          = <hexOctet>\n  node                   = 6*<hexOctet\n  hexOctet               = <hexDigit> <hexDigit>\n  hexDigit =\n        \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n        | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\n        | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n\n  The following is an example of the string representation of a UUID:\n\n       f81d4fae-7dec-11d0-a765-00a0c91e6bf6\n\n3.6 Comparing UUIDs for equality\n\n  Consider each field of the UUID to be an unsigned integer as shown in\n  the table in section 3.1. Then, to compare a pair of UUIDs,\n  arithmetically compare the corresponding fields from each UUID in\n  order of significance and according to their data type. Two UUIDs are\n  equal if and only if all the corresponding fields are equal.\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 12]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  Note: as a practical matter, on many systems comparison of two UUIDs\n  for equality can be performed simply by comparing the 128 bits of\n  their in-memory representation considered as a 128 bit unsigned\n  integer. Here, it is presumed that by the time the in-memory\n  representation is obtained the appropriate byte-order\n  canonicalizations have been carried out.\n\n\n3.7 Comparing UUIDs for relative order\n\n  Two UUIDs allocated according to the same variant can also be ordered\n  lexicographically. For the UUID variant herein defined, the first of\n  two UUIDs follows the second if the most significant field in which\n  the UUIDs differ is greater for the first UUID. The first of a pair\n  of UUIDs precedes the second if the most significant field in which\n  the UUIDs differ is greater for the second UUID.\n\n\n3.8 Byte order of UUIDs\n\n  UUIDs may be transmitted in many different forms, some of which may\n  be dependent on the presentation or application protocol where the\n  UUID may be used.  In such cases, the order, sizes and byte orders of\n  the UUIDs fields on the wire will depend on the relevant presentation\n  or application protocol.  However, it is strongly RECOMMENDED that\n  the order of the fields conform with ordering set out in section 3.1\n  above. Furthermore, the payload size of each field in the application\n  or presentation protocol MUST be large enough that no information\n  lost in the process of encoding them for transmission.\n\n  In the absence of explicit application or presentation protocol\n  specification to the contrary, a UUID is encoded as a 128-bit object,\n  as follows: the fields are encoded as 16 octets, with the sizes and\n  order of the fields defined in section 3.1, and with each field\n  encoded with the Most Significant Byte first (also known as network\n  byte order).\n\n  0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                          time_low                             |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |       time_mid                |         time_hi_and_version   |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                         node (2-5)                            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n\n\n\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 13]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n4. Node IDs when no IEEE 802 network card is available\n\n  If a system wants to generate UUIDs but has no IEE 802 compliant\n  network card or other source of IEEE 802 addresses, then this section\n  describes how to generate one.\n\n  The ideal solution is to obtain a 47 bit cryptographic quality random\n  number, and use it as the low 47 bits of the node ID, with the most\n  significant bit of the first octet of the node ID set to 1. This bit\n  is the unicast/multicast bit, which will never be set in IEEE 802\n  addresses obtained from network cards; hence, there can never be a\n  conflict between UUIDs generated by machines with and without network\n  cards.\n\n  If a system does not have a primitive to generate cryptographic\n  quality random numbers, then in most systems there are usually a\n  fairly large number of sources of randomness available from which one\n  can be generated. Such sources are system specific, but often\n  include:\n\n  - the percent of memory in use\n  - the size of main memory in bytes\n  - the amount of free main memory in bytes\n  - the size of the paging or swap file in bytes\n  - free bytes of paging or swap file\n  - the total size of user virtual address space in bytes\n  - the total available user address space bytes\n  - the size of boot disk drive in bytes\n  - the free disk space on boot drive in bytes\n  - the current time\n  - the amount of time since the system booted\n  - the individual sizes of files in various system directories\n  - the creation, last read, and modification times of files in various\n  system directories\n  - the utilization factors of various system resources (heap, etc.)\n  - current mouse cursor position\n  - current caret position\n  - current number of running processes, threads\n  - handles or IDs of the desktop window and the active window\n  - the value of stack pointer of the caller\n  - the process and thread ID of caller\n  - various processor architecture specific performance counters\n  (instructions executed, cache misses, TLB misses)\n\n  (Note that it precisely the above kinds of sources of randomness that\n  are used to seed cryptographic quality random number generators on\n  systems without special hardware for their construction.)\n\n  In addition, items such as the computer's name and the name of the\n  operating system, while not strictly speaking random, will help\n  differentiate the results from those obtained by other systems.\n\n  The exact algorithm to generate a node ID using these data is system\n  specific, because both the data available and the functions to obtain\n\n  Leach, Salz              expires  Aug 1998                   [Page 14]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  them are often very system specific. However, assuming that one can\n  concatenate all the values from the randomness sources into a buffer,\n  and that a cryptographic hash function such as MD5 [3] is available,\n  then any 6 bytes of the MD5 hash of the buffer, with the multicast\n  bit (the high bit of the first byte) set will be an appropriately\n  random node ID.\n\n  Other hash functions, such as SHA-1 [4], can also be used. The only\n  requirement is that the result be suitably random _ in the sense that\n  the outputs from a set uniformly distributed inputs are themselves\n  uniformly distributed, and that a single bit change in the input can\n  be expected to cause half of the output bits to change.\n\n\n5. Obtaining IEEE 802 addresses\n\n  At the time of writing, the following URL\n\n       http://standards.ieee.org/db/oui/forms/\n\n  contains information on how to obtain an IEEE 802 address block. At\n  the time of writing, the cost is $1250 US.\n\n\n6. Security Considerations\n\n  It should not be assumed that UUIDs are hard to guess; they should\n  not be used as capabilities.\n\n\n7. Acknowledgements\n\n  This document draws heavily on the OSF DCE specification for UUIDs.\n  Ted Ts'o provided helpful comments, especially on the byte ordering\n  section which we mostly plagiarized from a proposed wording he\n  supplied (all errors in that section are our responsibility,\n  however).\n\n\n8. References\n\n  [1]  Lisa Zahn, et. al., Network Computing Architecture, Prentice\n     Hall, Englewood Cliffs, NJ, 1990\n\n  [2] DCE: Remote Procedure Call, Open Group CAE Specification C309\n  ISBN 1-85912-041-5 28cm. 674p. pbk. 1,655g. 8/94\n\n  [3] R. Rivest, RFC 1321, \"The MD5 Message-Digest Algorithm\",\n     04/16/1992.\n\n  [4] NIST FIPS PUB 180-1, \"Secure Hash Standard,\" National Institute\n  of Standards and Technology, U.S. Department of Commerce, DRAFT, May\n  31, 1994.\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 15]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n9. Authors' addresses\n\n  Paul J. Leach\n  Microsoft\n  1 Microsoft Way\n  Redmond, WA, 98052, U.S.A.\n  paulle@microsoft.com\n  Tel. 425 882 8080\n  Fax. 425 936 7329\n\n  Rich Salz\n  100 Cambridge Park Drive\n  Cambridge MA  02140\n  salzr@certco.com\n  Tel. 617 499 4075\n  Fax. 617 576 0019\n\n\n10. Notice\n\n  The IETF takes no position regarding the validity or scope of any\n  intellectual property or other rights that might be claimed to\n  pertain to the implementation or use of the technology described in\n  this document or the extent to which any license under such rights\n  might or might not be available; neither does it represent that it\n  has made any effort to identify any such rights.  Information on the\n  IETF's procedures with respect to rights in standards-track and\n  standards-related documentation can be found in BCP-11.  Copies of\n  claims of rights made available for publication and any assurances of\n  licenses to be made available, or the result of an attempt made to\n  obtain a general license or permission for the use of such\n  proprietary rights by implementors or users of this specification can\n  be obtained from the IETF Secretariat.\n\n  The IETF invites any interested party to bring to its attention any\n  copyrights, patents or patent applications, or other proprietary\n  rights which may cover technology that may be required to practice\n  this standard.  Please address the information to the IETF Executive\n  Director.\n\n\n11. Full Copyright Statement\n\n  Copyright (C) The Internet Society 1997. All Rights Reserved.\n\n  This document and translations of it may be copied and furnished to\n  others, and derivative works that comment on or otherwise explain it\n  or assist in its implementation may be prepared, copied, published\n  and distributed, in whole or in part, without restriction of any\n  kind, provided that the above copyright notice and this paragraph are\n  included on all such copies and derivative works.  However, this\n  document itself may not be modified in any way, such as by removing\n  the copyright notice or references to the Internet Society or other\n  Internet organizations, except as needed for the purpose of\n\n  Leach, Salz              expires  Aug 1998                   [Page 16]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  developing Internet standards in which case the procedures for\n  copyrights defined in the Internet Standards process must be\n  followed, or as required to translate it into languages other than\n  English.\n\n  The limited permissions granted above are perpetual and will not be\n  revoked by the Internet Society or its successors or assigns.\n\n  This document and the information contained herein is provided on an\n  \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n  TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n  BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n  HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\n\n Appendix A _ UUID Sample Implementation\n\n  This implementation consists of 5 files: uuid.h, uuid.c, sysdep.h,\n  sysdep.c and utest.c. The uuid.* files are the system independent\n  implementation of the UUID generation algorithms described above,\n  with all the optimizations described above except efficient state\n  sharing across processes included. The code has been tested on Linux\n  (Red Hat 4.0) with GCC (2.7.2), and Windows NT 4.0 with VC++ 5.0. The\n  code assumes 64 bit integer support, which makes it a lot clearer.\n\n  All the following source files should be considered to have the\n  following copyright notice included:\n\n  copyrt.h\n\n  /*\n  ** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.\n  ** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &\n  ** Digital Equipment Corporation, Maynard, Mass.\n  ** Copyright (c) 1998 Microsoft.\n  ** To anyone who acknowledges that this file is provided \"AS IS\"\n  ** without any express or implied warranty: permission to use, copy,\n  ** modify, and distribute this file for any purpose is hereby\n  ** granted without fee, provided that the above copyright notices and\n  ** this notice appears in all source code copies, and that none of\n  ** the names of Open Software Foundation, Inc., Hewlett-Packard\n  ** Company, or Digital Equipment Corporation be used in advertising\n  ** or publicity pertaining to distribution of the software without\n  ** specific, written prior permission.  Neither Open Software\n  ** Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital\n  Equipment\n  ** Corporation makes any representations about the suitability of\n  ** this software for any purpose.\n  */\n\n\n  uuid.h\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 17]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  #include \"copyrt.h\"\n  #undef uuid_t\n  typedef struct _uuid_t {\n      unsigned32          time_low;\n      unsigned16          time_mid;\n      unsigned16          time_hi_and_version;\n      unsigned8           clock_seq_hi_and_reserved;\n      unsigned8           clock_seq_low;\n      byte                node[6];\n  } uuid_t;\n\n  /* uuid_create -- generate a UUID */\n  int uuid_create(uuid_t * uuid);\n\n  /* uuid_create_from_name -- create a UUID using a \"name\"\n     from a \"name space\" */\n  void uuid_create_from_name(\n    uuid_t * uuid,        /* resulting UUID */\n    uuid_t nsid,          /* UUID to serve as context, so identical\n                             names from different name spaces generate\n                             different UUIDs */\n    void * name,          /* the name from which to generate a UUID */\n    int namelen           /* the length of the name */\n  );\n\n  /* uuid_compare --  Compare two UUID's \"lexically\" and return\n          -1   u1 is lexically before u2\n           0   u1 is equal to u2\n           1   u1 is lexically after u2\n     Note:   lexical ordering is not temporal ordering!\n  */\n  int uuid_compare(uuid_t *u1, uuid_t *u2);\n\n  uuid.c\n\n  #include \"copyrt.h\"\n  #include <string.h>\n  #include <stdio.h>\n  #include <stdlib.h>\n  #include <time.h>\n  #include \"sysdep.h\"\n  #include \"uuid.h\"\n\n  /* various forward declarations */\n  static int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,\n  uuid_node_t * node);\n  static void write_state(unsigned16 clockseq, uuid_time_t timestamp,\n  uuid_node_t node);\n  static void format_uuid_v1(uuid_t * uuid, unsigned16 clockseq,\n  uuid_time_t timestamp, uuid_node_t node);\n  static void format_uuid_v3(uuid_t * uuid, unsigned char hash[16]);\n  static void get_current_time(uuid_time_t * timestamp);\n  static unsigned16 true_random(void);\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 18]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  /* uuid_create -- generator a UUID */\n  int uuid_create(uuid_t * uuid) {\n    uuid_time_t timestamp, last_time;\n    unsigned16 clockseq;\n    uuid_node_t node;\n    uuid_node_t last_node;\n    int f;\n\n    /* acquire system wide lock so we're alone */\n    LOCK;\n\n    /* get current time */\n    get_current_time(&timestamp);\n\n    /* get node ID */\n    get_ieee_node_identifier(&node);\n\n    /* get saved state from NV storage */\n    f = read_state(&clockseq, &last_time, &last_node);\n\n    /* if no NV state, or if clock went backwards, or node ID changed\n       (e.g., net card swap) change clockseq */\n    if (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n        clockseq = true_random();\n    else if (timestamp < last_time)\n        clockseq++;\n\n    /* stuff fields into the UUID */\n    format_uuid_v1(uuid, clockseq, timestamp, node);\n\n    /* save the state for next time */\n    write_state(clockseq, timestamp, node);\n\n    UNLOCK;\n    return(1);\n  };\n\n  /* format_uuid_v1 -- make a UUID from the timestamp, clockseq,\n                       and node ID */\n  void format_uuid_v1(uuid_t * uuid, unsigned16 clock_seq, uuid_time_t\n  timestamp, uuid_node_t node) {\n      /* Construct a version 1 uuid with the information we've gathered\n       * plus a few constants. */\n    uuid->time_low = (unsigned long)(timestamp & 0xFFFFFFFF);\n      uuid->time_mid = (unsigned short)((timestamp >> 32) & 0xFFFF);\n      uuid->time_hi_and_version = (unsigned short)((timestamp >> 48) &\n         0x0FFF);\n      uuid->time_hi_and_version |= (1 << 12);\n      uuid->clock_seq_low = clock_seq & 0xFF;\n      uuid->clock_seq_hi_and_reserved = (clock_seq & 0x3F00) >> 8;\n      uuid->clock_seq_hi_and_reserved |= 0x80;\n      memcpy(&uuid->node, &node, sizeof uuid->node);\n  };\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 19]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  /* data type for UUID generator persistent state */\n  typedef struct {\n    uuid_time_t ts;       /* saved timestamp */\n    uuid_node_t node;     /* saved node ID */\n    unsigned16 cs;        /* saved clock sequence */\n    } uuid_state;\n\n  static uuid_state st;\n\n  /* read_state -- read UUID generator state from non-volatile store */\n  int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,\n  uuid_node_t *node) {\n    FILE * fd;\n    static int inited = 0;\n\n    /* only need to read state once per boot */\n    if (!inited) {\n        fd = fopen(\"state\", \"rb\");\n        if (!fd)\n             return (0);\n        fread(&st, sizeof(uuid_state), 1, fd);\n        fclose(fd);\n        inited = 1;\n    };\n    *clockseq = st.cs;\n    *timestamp = st.ts;\n    *node = st.node;\n    return(1);\n  };\n\n  /* write_state -- save UUID generator state back to non-volatile\n  storage */\n  void write_state(unsigned16 clockseq, uuid_time_t timestamp,\n  uuid_node_t node) {\n    FILE * fd;\n    static int inited = 0;\n    static uuid_time_t next_save;\n\n    if (!inited) {\n        next_save = timestamp;\n        inited = 1;\n    };\n    /* always save state to volatile shared state */\n    st.cs = clockseq;\n    st.ts = timestamp;\n    st.node = node;\n    if (timestamp >= next_save) {\n        fd = fopen(\"state\", \"wb\");\n        fwrite(&st, sizeof(uuid_state), 1, fd);\n        fclose(fd);\n        /* schedule next save for 10 seconds from now */\n        next_save = timestamp + (10 * 10 * 1000 * 1000);\n    };\n  };\n\n  Leach, Salz              expires  Aug 1998                   [Page 20]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n\n  /* get-current_time -- get time as 60 bit 100ns ticks since whenever.\n    Compensate for the fact that real clock resolution is\n    less than 100ns. */\n  void get_current_time(uuid_time_t * timestamp) {\n      uuid_time_t                time_now;\n      static uuid_time_t  time_last;\n      static unsigned16   uuids_this_tick;\n    static int                   inited = 0;\n\n    if (!inited) {\n          get_system_time(&time_now);\n        uuids_this_tick = UUIDS_PER_TICK;\n        inited = 1;\n    };\n\n      while (1) {\n          get_system_time(&time_now);\n\n        /* if clock reading changed since last UUID generated... */\n          if (time_last != time_now) {\n             /* reset count of uuids gen'd with this clock reading */\n              uuids_this_tick = 0;\n             break;\n        };\n          if (uuids_this_tick < UUIDS_PER_TICK) {\n             uuids_this_tick++;\n             break;\n        };\n        /* going too fast for our clock; spin */\n      };\n    /* add the count of uuids to low order bits of the clock reading */\n    *timestamp = time_now + uuids_this_tick;\n  };\n\n  /* true_random -- generate a crypto-quality random number.\n     This sample doesn't do that. */\n  static unsigned16\n  true_random(void)\n  {\n    static int inited = 0;\n    uuid_time_t time_now;\n\n    if (!inited) {\n        get_system_time(&time_now);\n        time_now = time_now/UUIDS_PER_TICK;\n        srand((unsigned int)(((time_now >> 32) ^ time_now)&0xffffffff));\n        inited = 1;\n    };\n\n      return (rand());\n  }\n\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 21]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  /* uuid_create_from_name -- create a UUID using a \"name\" from a \"name\n  space\" */\n  void uuid_create_from_name(\n    uuid_t * uuid,        /* resulting UUID */\n    uuid_t nsid,          /* UUID to serve as context, so identical\n                             names from different name spaces generate\n                             different UUIDs */\n    void * name,          /* the name from which to generate a UUID */\n    int namelen           /* the length of the name */\n  ) {\n    MD5_CTX c;\n    unsigned char hash[16];\n    uuid_t net_nsid;      /* context UUID in network byte order */\n\n    /* put name space ID in network byte order so it hashes the same\n        no matter what endian machine we're on */\n    net_nsid = nsid;\n    htonl(net_nsid.time_low);\n    htons(net_nsid.time_mid);\n    htons(net_nsid.time_hi_and_version);\n\n    MD5Init(&c);\n    MD5Update(&c, &net_nsid, sizeof(uuid_t));\n    MD5Update(&c, name, namelen);\n    MD5Final(hash, &c);\n\n    /* the hash is in network byte order at this point */\n    format_uuid_v3(uuid, hash);\n  };\n\n  /* format_uuid_v3 -- make a UUID from a (pseudo)random 128 bit number\n  */\n  void format_uuid_v3(uuid_t * uuid, unsigned char hash[16]) {\n      /* Construct a version 3 uuid with the (pseudo-)random number\n       * plus a few constants. */\n\n      memcpy(uuid, hash, sizeof(uuid_t));\n\n    /* convert UUID to local byte order */\n    ntohl(uuid->time_low);\n    ntohs(uuid->time_mid);\n    ntohs(uuid->time_hi_and_version);\n\n    /* put in the variant and version bits */\n      uuid->time_hi_and_version &= 0x0FFF;\n      uuid->time_hi_and_version |= (3 << 12);\n      uuid->clock_seq_hi_and_reserved &= 0x3F;\n      uuid->clock_seq_hi_and_reserved |= 0x80;\n  };\n\n  /* uuid_compare --  Compare two UUID's \"lexically\" and return\n         -1   u1 is lexically before u2\n          0   u1 is equal to u2\n          1   u1 is lexically after u2\n\n  Leach, Salz              expires  Aug 1998                   [Page 22]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n      Note:   lexical ordering is not temporal ordering!\n  */\n  int uuid_compare(uuid_t *u1, uuid_t *u2)\n  {\n    int i;\n\n  #define CHECK(f1, f2) if (f1 != f2) return f1 < f2 ? -1 : 1;\n    CHECK(u1->time_low, u2->time_low);\n    CHECK(u1->time_mid, u2->time_mid);\n    CHECK(u1->time_hi_and_version, u2->time_hi_and_version);\n    CHECK(u1->clock_seq_hi_and_reserved, u2->clock_seq_hi_and_reserved);\n    CHECK(u1->clock_seq_low, u2->clock_seq_low)\n    for (i = 0; i < 6; i++) {\n        if (u1->node[i] < u2->node[i])\n             return -1;\n        if (u1->node[i] > u2->node[i])\n        return 1;\n      }\n    return 0;\n  };\n\n  sysdep.h\n\n  #include \"copyrt.h\"\n  /* remove the following define if you aren't running WIN32 */\n  #define WININC 0\n\n  #ifdef WININC\n  #include <windows.h>\n  #else\n  #include <sys/types.h>\n  #include <sys/time.h>\n  #include <sys/sysinfo.h>\n  #endif\n\n  /* change to point to where MD5 .h's live */\n  /* get MD5 sample implementation from RFC 1321 */\n  #include \"global.h\"\n  #include \"md5.h\"\n\n  /* set the following to the number of 100ns ticks of the actual\n  resolution of\n  your system's clock */\n  #define UUIDS_PER_TICK 1024\n\n  /* Set the following to a call to acquire a system wide global lock\n  */\n  #define LOCK\n  #define UNLOCK\n\n  typedef unsigned long   unsigned32;\n  typedef unsigned short  unsigned16;\n  typedef unsigned char   unsigned8;\n  typedef unsigned char   byte;\n\n  Leach, Salz              expires  Aug 1998                   [Page 23]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n\n  /* Set this to what your compiler uses for 64 bit data type */\n  #ifdef WININC\n  #define unsigned64_t unsigned __int64\n  #define I64(C) C\n  #else\n  #define unsigned64_t unsigned long long\n  #define I64(C) C##LL\n  #endif\n\n\n  typedef unsigned64_t uuid_time_t;\n  typedef struct {\n    char nodeID[6];\n  } uuid_node_t;\n\n  void get_ieee_node_identifier(uuid_node_t *node);\n  void get_system_time(uuid_time_t *uuid_time);\n  void get_random_info(char seed[16]);\n\n\n  sysdep.c\n\n  #include \"copyrt.h\"\n  #include <stdio.h>\n  #include \"sysdep.h\"\n\n  /* system dependent call to get IEEE node ID.\n     This sample implementation generates a random node ID\n     */\n  void get_ieee_node_identifier(uuid_node_t *node) {\n    char seed[16];\n    FILE * fd;\n    static inited = 0;\n    static uuid_node_t saved_node;\n\n    if (!inited) {\n        fd = fopen(\"nodeid\", \"rb\");\n        if (fd) {\n             fread(&saved_node, sizeof(uuid_node_t), 1, fd);\n             fclose(fd);\n        }\n        else {\n             get_random_info(seed);\n             seed[0] |= 0x80;\n             memcpy(&saved_node, seed, sizeof(uuid_node_t));\n             fd = fopen(\"nodeid\", \"wb\");\n             if (fd) {\n                    fwrite(&saved_node, sizeof(uuid_node_t), 1, fd);\n                    fclose(fd);\n             };\n        };\n        inited = 1;\n    };\n\n  Leach, Salz              expires  Aug 1998                   [Page 24]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n    *node = saved_node;\n  };\n\n  /* system dependent call to get the current system time.\n     Returned as 100ns ticks since Oct 15, 1582, but resolution may be\n     less than 100ns.\n  */\n  #ifdef _WINDOWS_\n\n  void get_system_time(uuid_time_t *uuid_time) {\n    ULARGE_INTEGER time;\n\n    GetSystemTimeAsFileTime((FILETIME *)&time);\n\n      /* NT keeps time in FILETIME format which is 100ns ticks since\n       Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.\n       The difference is 17 Days in Oct + 30 (Nov) + 31 (Dec)\n       + 18 years and 5 leap days.\n    */\n\n      time.QuadPart +=\n            (unsigned __int64) (1000*1000*10)       // seconds\n          * (unsigned __int64) (60 * 60 * 24)       // days\n          * (unsigned __int64) (17+30+31+365*18+5); // # of days\n\n    *uuid_time = time.QuadPart;\n\n  };\n\n  void get_random_info(char seed[16]) {\n    MD5_CTX c;\n    typedef struct {\n        MEMORYSTATUS m;\n        SYSTEM_INFO s;\n        FILETIME t;\n        LARGE_INTEGER pc;\n        DWORD tc;\n        DWORD l;\n        char hostname[MAX_COMPUTERNAME_LENGTH + 1];\n    } randomness;\n    randomness r;\n\n    MD5Init(&c);\n    /* memory usage stats */\n    GlobalMemoryStatus(&r.m);\n    /* random system stats */\n    GetSystemInfo(&r.s);\n    /* 100ns resolution (nominally) time of day */\n    GetSystemTimeAsFileTime(&r.t);\n    /* high resolution performance counter */\n    QueryPerformanceCounter(&r.pc);\n    /* milliseconds since last boot */\n    r.tc = GetTickCount();\n    r.l = MAX_COMPUTERNAME_LENGTH + 1;\n\n  Leach, Salz              expires  Aug 1998                   [Page 25]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n    GetComputerName(r.hostname, &r.l );\n    MD5Update(&c, &r, sizeof(randomness));\n    MD5Final(seed, &c);\n  };\n  #else\n\n  void get_system_time(uuid_time_t *uuid_time)\n  {\n      struct timeval tp;\n\n      gettimeofday(&tp, (struct timezone *)0);\n\n      /* Offset between UUID formatted times and Unix formatted times.\n         UUID UTC base time is October 15, 1582.\n         Unix base time is January 1, 1970.\n      */\n      *uuid_time = (tp.tv_sec * 10000000) + (tp.tv_usec * 10) +\n        I64(0x01B21DD213814000);\n  };\n\n  void get_random_info(char seed[16]) {\n    MD5_CTX c;\n    typedef struct {\n        struct sysinfo s;\n        struct timeval t;\n        char hostname[257];\n    } randomness;\n    randomness r;\n\n    MD5Init(&c);\n    sysinfo(&r.s);\n    gettimeofday(&r.t, (struct timezone *)0);\n    gethostname(r.hostname, 256);\n    MD5Update(&c, &r, sizeof(randomness));\n    MD5Final(seed, &c);\n  };\n\n  #endif\n\n  utest.c\n\n  #include \"copyrt.h\"\n  #include \"sysdep.h\"\n  #include <stdio.h>\n  #include \"uuid.h\"\n\n  uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */\n      0x6ba7b810,\n      0x9dad,\n      0x11d1,\n      0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n    };\n\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 26]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  /* puid -- print a UUID */\n  void puid(uuid_t u);\n\n  /* Simple driver for UUID generator */\n  void main(int argc, char **argv) {\n    uuid_t u;\n    int f;\n\n    uuid_create(&u);\n    printf(\"uuid_create()             -> \"); puid(u);\n\n    f = uuid_compare(&u, &u);\n    printf(\"uuid_compare(u,u): %d\\n\", f);     /* should be 0 */\n    f = uuid_compare(&u, &NameSpace_DNS);\n    printf(\"uuid_compare(u, NameSpace_DNS): %d\\n\", f); /* s.b. 1 */\n    f = uuid_compare(&NameSpace_DNS, &u);\n    printf(\"uuid_compare(NameSpace_DNS, u): %d\\n\", f); /* s.b. -1 */\n\n    uuid_create_from_name(&u, NameSpace_DNS, \"www.widgets.com\", 15);\n    printf(\"uuid_create_from_name() -> \"); puid(u);\n  };\n\n  void puid(uuid_t u) {\n    int i;\n\n    printf(\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-\", u.time_low, u.time_mid,\n        u.time_hi_and_version, u.clock_seq_hi_and_reserved,\n        u.clock_seq_low);\n    for (i = 0; i < 6; i++)\n        printf(\"%2.2x\", u.node[i]);\n    printf(\"\\n\");\n  };\n\nAppendix B _ Sample output of utest\n\n  uuid_create()             -> 7d444840-9dc0-11d1-b245-5ffdce74fad2\n  uuid_compare(u,u): 0\n  uuid_compare(u, NameSpace_DNS): 1\n  uuid_compare(NameSpace_DNS, u): -1\n  uuid_create_from_name()   -> e902893a-9d22-3c7e-a7b8-d6e313b71d9f\n\nAppendix C _ Some name space IDs\n\n  This appendix lists the name space IDs for some potentially\n  interesting name spaces, as initialized C structures and in the\n  string representation defined in section 3.5\n\n  uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */\n      0x6ba7b810,\n      0x9dad,\n      0x11d1,\n      0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n    };\n\n\n  Leach, Salz              expires  Aug 1998                   [Page 27]\f\n\n\n  Internet-Draft        UUIDs and GUIDs (DRAFT)                 02/04/98\n\n\n  uuid_t NameSpace_URL = { /* 6ba7b811-9dad-11d1-80b4-00c04fd430c8 */\n      0x6ba7b811,\n      0x9dad,\n      0x11d1,\n      0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n    };\n\n  uuid_t NameSpace_OID = { /* 6ba7b812-9dad-11d1-80b4-00c04fd430c8 */\n      0x6ba7b812,\n      0x9dad,\n      0x11d1,\n      0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n    };\n\n  uuid_t NameSpace_X500 = { /* 6ba7b814-9dad-11d1-80b4-00c04fd430c8 */\n      0x6ba7b814,\n      0x9dad,\n      0x11d1,\n      0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "encoding": "ascii"}