{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/threads.tmpl", "content": "\t\t\t+--------------------+\n\t\t\t|    CompSci 143A    |\n\t\t\t| PROJECT 1: THREADS |\n\t\t\t|   DESIGN DOCUMENT  |\n\t\t\t+--------------------+\n\t\t\t\t   \n---- GROUP ----\n\n>> Fill in the names and email addresses of your group members.\n\nFirstName LastName <email@domain.example>\nFirstName LastName <email@domain.example>\nFirstName LastName <email@domain.example>\n\n---- PRELIMINARIES ----\n\n>> If you have any preliminary comments on your submission or notes for the\n>> TAs, please give them here.\n\n>> Please cite any offline or online sources you consulted while\n>> preparing your submission, other than the Pintos documentation, course\n>> text, lecture notes, and course staff.\n\n\t\t\t     ALARM CLOCK\n\t\t\t     ===========\n\n---- DATA STRUCTURES ----\n\n>> A1: Copy here the declaration of each new or changed `struct' or\n>> `struct' member, global or static variable, `typedef', or\n>> enumeration.  Identify the purpose of each in 25 words or less.\n\n---- ALGORITHMS ----\n\n>> A2: Briefly describe what happens in a call to timer_sleep(),\n>> including the effects of the timer interrupt handler.\n\n>> A3: What steps are taken to minimize the amount of time spent in\n>> the timer interrupt handler?\n\n---- SYNCHRONIZATION ----\n\n>> A4: How are race conditions avoided when multiple threads call\n>> timer_sleep() simultaneously?\n\n>> A5: How are race conditions avoided when a timer interrupt occurs\n>> during a call to timer_sleep()?\n\n---- RATIONALE ----\n\n>> A6: Why did you choose this design?  In what ways is it superior to\n>> another design you considered?\n\n\t\t\t PRIORITY SCHEDULING\n\t\t\t ===================\n\n---- DATA STRUCTURES ----\n\n>> B1: Copy here the declaration of each new or changed `struct' or\n>> `struct' member, global or static variable, `typedef', or\n>> enumeration.  Identify the purpose of each in 25 words or less.\n\n>> B2: Explain the data structure used to track priority donation.\n>> Use ASCII art to diagram a nested donation.  (Alternately, submit a\n>> .png file.)\n\n---- ALGORITHMS ----\n\n>> B3: How do you ensure that the highest priority thread waiting for\n>> a lock, semaphore, or condition variable wakes up first?\n\n>> B4: Describe the sequence of events when a call to lock_acquire()\n>> causes a priority donation.  How is nested donation handled?\n\n>> B5: Describe the sequence of events when lock_release() is called\n>> on a lock that a higher-priority thread is waiting for.\n\n---- SYNCHRONIZATION ----\n\n>> B6: Describe a potential race in thread_set_priority() and explain\n>> how your implementation avoids it.  Can you use a lock to avoid\n>> this race?\n\n---- RATIONALE ----\n\n>> B7: Why did you choose this design?  In what ways is it superior to\n>> another design you considered?\n\n\t\t\t  ADVANCED SCHEDULER\n\t\t\t  ==================\n\n---- DATA STRUCTURES ----\n\n>> C1: Copy here the declaration of each new or changed `struct' or\n>> `struct' member, global or static variable, `typedef', or\n>> enumeration.  Identify the purpose of each in 25 words or less.\n\n---- ALGORITHMS ----\n\n>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each\n>> has a recent_cpu value of 0.  Fill in the table below showing the\n>> scheduling decision and the priority and recent_cpu values for each\n>> thread after each given number of timer ticks:\n\ntimer  recent_cpu    priority   thread\nticks   A   B   C   A   B   C   to run\n-----  --  --  --  --  --  --   ------\n 0\n 4\n 8\n12\n16\n20\n24\n28\n32\n36\n\n>> C3: Did any ambiguities in the scheduler specification make values\n>> in the table uncertain?  If so, what rule did you use to resolve\n>> them?  Does this match the behavior of your scheduler?\n\n>> C4: How is the way you divided the cost of scheduling between code\n>> inside and outside interrupt context likely to affect performance?\n\n---- RATIONALE ----\n\n>> C5: Briefly critique your design, pointing out advantages and\n>> disadvantages in your design choices.  If you were to have extra\n>> time to work on this part of the project, how might you choose to\n>> refine or improve your design?\n\n>> C6: The assignment explains arithmetic for fixed-point math in\n>> detail, but it leaves it open to you to implement it.  Why did you\n>> decide to implement it the way you did?  If you created an\n>> abstraction layer for fixed-point math, that is, an abstract data\n>> type and/or a set of functions or macros to manipulate fixed-point\n>> numbers, why did you do so?  If not, why not?\n\n\t\t\t   SURVEY QUESTIONS\n\t\t\t   ================\n\nAnswering these questions is optional, but it will help us improve the\ncourse in future quarters.  Feel free to tell us anything you\nwant--these questions are just to spur your thoughts.  You may also\nchoose to respond anonymously in the course evaluations at the end of\nthe quarter.\n\n>> In your opinion, was this assignment, or any one of the three problems\n>> in it, too easy or too hard?  Did it take too long or too little time?\n\n>> Did you find that working on a particular part of the assignment gave\n>> you greater insight into some aspect of OS design?\n\n>> Is there some particular fact or hint we should give students in\n>> future quarters to help them solve the problems?  Conversely, did you\n>> find any of our guidance to be misleading?\n\n>> Do you have any suggestions for the TAs to more effectively assist\n>> students, either for future quarters or the remaining projects?\n\n>> Any other comments?\n", "encoding": "ascii"}