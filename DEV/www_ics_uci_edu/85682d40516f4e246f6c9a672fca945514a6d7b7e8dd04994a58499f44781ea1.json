{"url": "https://www.ics.uci.edu/~ejw/authoring/requirements/webdav-req-021097.txt", "content": "\n\nWEBDAV Working Group\t\t\t\tJ.A. Slein\nINTERNET-DRAFT      \t\t\t\tXerox Corporation                         \n< >\t\t\t\t\t\tE.J. Whitehead, Jr.\n\t\t\t\t\t\tU.C. Irvine\n\t\t\t\t\t\tD.G. Durand\n\t\t\t\t\t\tBoston University\n\t\t\t\t\t\tF. Vitali\n\t\t\t\t\t\tUniversity of Bologna              \n\t\t\t\t\t\tFebruary 1997\n\nExpires August 1997\n\n   Requirements on HTTP for Distributed Authoring and Versioning\n\n\nStatus of this Memo\n\nThis document is an Internet draft. Internet drafts are working\ndocuments of the Internet Engineering Task Force (IETF), its areas and\nits working groups. Note that other groups may also distribute working\ninformation as Internet drafts.\n\nInternet Drafts are draft documents valid for a maximum of six months\nand can be updated, replaced or obsoleted by other documents at any\ntime. It is inappropriate to use Internet drafts as reference material\nor to cite them as other than as \"work in progress\".\n\nTo learn the current status of any Internet draft please check the\n\"lid-abstracts.txt\" listing contained in the Internet drafts shadow\ndirectories on ftp.is.co.za (Africa), nic.nordu.net (Europe),\nmunnari.oz.au (Pacific Rim), ds.internic.net (US East coast) or\nftp.isi.edu (US West coast). Further information about the IETF can be\nfound at URL: http://www.ietf.org/\n\nDistribution of this document is unlimited. Please send comments to the\nWWW Distributed Authoring and Versioning mailing list,\n<w3c-dist-auth@w3.org>, which may be joined by sending a message with\nsubject \"subscribe\" to <w3c-dist-auth-request@w3.org>. Discussions are\narchived at URL:\nhttp://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth/. The HTTP\nworking group at <http-wg@cuckoo.hpl.hp.com> also discusses the HTTP\nprotocol.  Discussions of the HTTP working group are archived at URL:\nhttp://www.ics.uci.edu/pub/ietf/http/. General discussions about HTTP\nand the applications which use HTTP should take place on the\n<www-talk@w3.org> mailing list.\n\n\nAbstract\n\nThe HyperText Transfer Protocol, version 1.1 (HTTP/1.1), provides\nsimple support for applications which allow remote editing of typed\ndata. In practice, the existing capabilities of HTTP/1.1 have proven\ninadequate to support efficient, scalable remote editing free of\noverwriting conflicts.  This document presents a list of features in\nthe form of requirements which, if implemented, would improve the\nefficiency of common remote editing operations, provide a locking\nmechanism to prevent overwrite conflicts, improve relationship\nmanagement support between non-HTML data types, provide a simple\nattribute-value metadata facility, provide for the creation and\nreading of container data types, and integrate versioning into the WWW.\n\n\n1. Introduction\n\nThis document describes functionality which, if provided in the\nHyperText Transfer Protocol (HTTP) [4], would support the\ninteroperability of tools which allow remote loading, editing and\nsaving (publishing) of various media types using HTTP. As much as\npossible, this functionality is described without suggesting a proposed\nimplementation, since there are many ways to perform the functionality\nwithin the HTTP framework. It is also possible that a single mechanism\nwithin HTTP could simultaneously satisfy several requirements.\n\n***Fabio - Many of the versioning requirements call for extensions to\nURLs, not to HTTP.\n\n***Judy - There is controversy in the group about whether we should be\nextending HTTP or defining a separate protocol.\n\n2. Rationale\n\nThe HTTP protocol contains functionality which enables the editing of \nweb content at a remote location, without direct access to the storage \nmedia via an operating system. This capability is exploited by several \nexisting HTML distributed authoring tools, and by a growing number of \nmainstream applications (e.g. word processors) which allow users to \nwrite (publish) their work to an HTTP server. To date, experience from \nthe HTML authoring tools has shown they are unable to meet their users' \nneeds using the facilities of the HTTP protocol. The consequence of \nthis is either postponed introduction of distributed authoring \ncapability, or the addition of nonstandard extensions to the HTTP \nprotocol.  These extensions, developed in isolation, are not \ninteroperable.\n\nOther authoring applications have wanted to access document repositories \nor version control systems through Web gateways, and have been similarly\nfrustrated.  Where this access is available at all, it is through\nnonstandard extensions to HTTP that force clients to use a different\ninterface for each vendor's service.\n\nThis document describes requirements for a set of standard extensions\nto HTTP that would allow distributed Web authoring tools to provide\nthe functionality their users need by means of the same standard\nsyntax across all compliant servers. The broad categories of \nfunctionality that need to be standardized are:\n\n\tAttributes\n\tRelationships\n\tLocking\n\tNotification of Intent to Edit\n\tRetrieval of Unprocessed Source for Editing\n\tPartial Write\n\tName Space Manipulation\n\tCollections\n\tVersioning\n\n3. General Principles\n\nThis section describes a set of general principles that the HTTP\nextensions should follow.  These principles cut across categories of\nfunctionality.\n\n3.1. User Agent Interoperability\n\nAll clients should be able to work with any WebDAV-compliant HTTP\nserver. It is acceptable for some client/server combinations to provide\nspecial features that are not universally available, but the protocol\nshould be sufficient that a basic level of functionality will be\nuniversal. It should be possible for servers and clients to negotiate\nthe use of optional features.\n\n3.2. Legacy Client Support\n\nWebDAV-compliant servers should be able to interoperate with non-WebDAV\nclients.\n\n3.3. Data Format Compatibility.\n\nWebDAV-compliant servers should be able to work with existing resources \nand URLs. Special additional information should not become a mandatory \npart of document formats.\n\n3.4. HTTP Compatibility (new)\n\nOur aim is to make extended authoring capabilities available through\nHTTP.  In extending HTTP, we are obligated to follow its design\nconventions and stay within its spirit.  This means, for example, that\nmethods should operate only on resources.  It means that parameters\nshould be communicated in headers.  These and other conventions should\nbe observed in the design of the extensions.\n\n3.5. Replicated, Distributed Systems (new)\n\nDistribution and replication are at the heart of the Internet.  All\nWebDAV extensions should be designed to allow for distribution and\nreplication.  Version trees should be able to be split across multiple\nservers.  Collections may have members on different servers.  Resources\nmay have attributes on different servers.  Any resources may be cached\nor replicated for mobile computing or other reasons.  Consequently, we\nmust keep these issues in mind through all our design efforts.\n\n4. Requirements\n\nIn the requirement descriptions below, the requirement will be stated,\nfollowed by its rationale. If any distributed authoring tools\ncurrently implement the requirement, this is also mentioned. It is\nassumed that \"server\" means \"a program which receives and responds to\nHTTP requests,\" and that \"distributed authoring tool\" or \"intranet\nenabled tool\" means \"a program which can retrieve a source entity via\nHTTP, allow editing of this entity, and then save/publish this entity\nto a server using HTTP.\" A \"client\" is \"a program which issues HTTP\nrequests and accepts responses.\"\n\n(Get rid of references to current tools altogether, or do more thorough\nresearch.)\n\n4.1. Attributes\n\nVia HTTP, it should be possible to create, modify, query, read and \ndelete arbitrary attributes on resources of any media type.\n\n***Judy - Query is not supported in the specification.\n\nAttributes can be used to define fields such as author, title, subject, \nand organization, on resources of any media type. These attributes have \nmany uses, such as supporting searches on attribute contents, and the \ncreation of catalog entries as a placeholder for an object which is \nnot available in electronic form, or which will be available later.\n\n4.2. Relationships\n\nVia HTTP, it should be possible to create, query, and delete typed \nrelationships between resources of any media type.\n\nA hypertext link is a relationship between resources which is browsable \nusing a hypertext style point-and-click user interface. Relationships, \nwhether they are browsable hypertext links, or simply a means of \ncapturing a interrelation between resources, have many purposes.  \nRelationships can support pushbutton printing of a multi-resource \ndocument in a prescribed order, jumping to the access control page for \nan resource, and quick browsing of related information, such as a table \nof contents, an index, a glossary, help pages, etc. While relationship \nsupport is provided by the HTML \"LINK\" element, this is limited only to \nHTML resources, and does not support bitmap image types, and other \nnon-HTML media types.  \n\nAOLpress from America Online [1] currently \"allows pages to add toolbar \nbuttons on the fly using the HTML 3.2 <LINK REL....> tag. For example, \nyour page can add toolbar buttons that link to a home page, table of \ncontents, index, glossary, copyright page, next page, previous page, \nhelp page, higher level page, or a bookmark in the document.\"\n\n***Fabio - The definition of locking here conflicts with the one that\nwas used in the versioning requirements paper.  More in a separate\nmail note.\n\n4.3. Locking\n\n4.3.1. General Principles\n\n4.3.1.1. Independence of locks. It should be possible to lock a resource\nwithout re-reading the resource, and without committing to editing the \nresource.\n\n4.3.1.2. Multi-Resource Locking. It should be possible to take out a \nlock on multiple resources in the same action, and this locking \noperation must be atomic across these resources.\n\n***Judy - Multi-resource locking is not in the specification\n\n4.3.1.3. Partial-Resource Locking. It should be possible to take out a \nlock on subsections of an resource.\n\n***Judy - Controversy on this issue at Irvine.\n\n4.3.1.4. Multi-Person Locking.  It should be possible to assign a lock\nto a single person or to multiple persons with a single action.\n\n***Judy - Multi-person locking is not in the specification.\n\n***Fabio - Add a statement that support for locking is optional.  Also\nsay that systems that do not support locking should provide some other\ntype of consistency management.\n\n4.3.2. Functional Requirements\n\n4.3.2.1.  Write Locks. It should be possible, via HTTP, to restrict \nmodification of a resource to a specific person, or list of persons.\n\n***Fabio - The definition of a write lock should be this:  A write lock\nstates that no consistency problem will ever occur by changing the\nresource, not that no one else is allowed access to that resource.  On\nthe other hand, it can be said that access rights to successfully\nUnlocked resources should be allowed to all authorized users.\n\n4.3.2.2.  Read Locks. It should be possible, via HTTP, to indicate to \nthe HTTP server that the contents of a resource should not be modified \nuntil the read lock is released.\n\n***Judy - Read locks are not in the specification.\n\n4.3.2.3. Lock Query. It should be possible to query for whether a given \nURL has any active modification restrictions, and if so, who currently\nhas modification permission.\n\n***Judy - Should add Unlock.\n\n4.3.3. Rationale\n\nAt present, HTTP provides limited support for preventing two or more \npeople from overwriting each other's modifications when they save to a \ngiven URL. Furthermore, there is no way for people to discover if \nsomeone else is currently making modifications to a resource. This is \nknown as the \"lost update problem,\" or the \"overwrite problem.\" Since \nthere can be significant cost associated with discovering and repairing \nlost modifications, preventing this problem is crucial for supporting \ndistributed authoring. A \"write\" lock ensures that only one person (or \nlist of persons) may modify a resource, preventing overwrites.\nFurthermore, locking support is also a key component of many versioning \nschemes, a desirable capability for distributed authoring.\n\nAn author may wish to lock an entire web of resources even though he \nis editing just a single resource, to keep the other resources from \nchanging. In this way, an author can ensure that if a local hypertext \nweb is consistent in his distributed authoring tool, it will then be \nconsistent when he writes it to the server. Because of this, it should \nbe possible to take out a lock without also causing transmission of the \ncontents of a resource. Since it should not be assumed that because a \nresource is locked, that it will necessarily be modified, and since \nmany people may wish to have simultaneous guarantees that a resource \nwill not be modified, but still not want to modify the resource \nthemselves, it is desirable to have a \"read\" lock capability. A read \nlock, by being less restrictive, provides better support than a write \nlock for providing a guarantee that a resource will not be modified. \nPut differently, a read lock states that the resource is guaranteed not \nto change for the duration of the lock. A write lock states that a \nresource is guaranteed not to change only if the owner of the lock \ndoes not change it, and only the owner of the lock may change it.\n\nIt is often necessary to guarantee that a lock or unlock operation \noccurs at the same time across multiple resources, a feature which is \nsupported by the multiple-resource locking requirement. This is useful \nfor preventing a collision between two people trying to establish locks \non the same set of resources, since with multi-resource locking, one of \nthe two people will get a lock. If this same multiple-resource locking \nscenario was repeated by using atomic lock operations iterated across \nthe resources, the result would be a splitting of the locks between the \ntwo people, based on resource ordering and race conditions.\n\nPartial resource locking provides support for collaborative editing \napplications, where multiple users may be editing the same resource\nsimultaneously. Partial resource locking also allows multiple people to \nsimultaneously work on a database type resource.\n\n4.4. Notification of Intention to Edit. \n\nIt should be possible to notify the HTTP server that a resource is about \nto be edited by a given person. It should be possible to query the HTTP \nserver for the list of people who have notified the server of their \nintent to edit a resource.\n\n***Judy - It should be possible to notify the server that one no longer\nintends to edit the resource.\n\n***Judy - Support for notification of intent to edit is found in the\nspecification only in the context of version management.  The \nspecification does not allow such notification for non-versioned\nresources.\n\nExperience from configuration management systems has shown that people \nneed to know when they are about to enter a parallel editing situation. \nOnce notified, they either decide not to edit in parallel with the \nother authors, or they use out-of-band communication (face-to-face, \ntelephone, etc.) to coordinate their editing to minimize the difficulty \nof merging their results. Notification is separate from locking, since \na write lock does not necessarily imply a resource will be edited, and \na notification of intention to edit does not carry with it any access \nrestrictions. This capability is supportive of versioning, since a \ncheck-out typically involves taking out a write lock, making a \nnotification of intention to edit, and getting the resource to be \nedited.\n\n4.5. Retrieval of Unprocessed Source for Editing\n\nThe source of any given entity should be retrievable via HTTP.\n\n***Judy - Not in the specification.\n\nThere are many cases where the source stored on a server does \nnot correspond to the actual entity transmitted in response to an HTTP \nGET. Current known cases are server side include directives, and \nStandard Generalized Markup Language (SGML) source which is\nconverted on the fly to HyperText Markup Language (HTML) [2] output \nentities. There are many possible cases, such as automatic conversion \nof bitmap images into several variant bitmap media types (e.g. GIF, \nJPEG), and automatic conversion of an application's native media type \ninto HTML. As an example of this last case, a word processor could \nstore its native media type on a server which automatically converts \nit to HTML. A GET of this resource would retrieve the HTML. Retrieving \nthe source would retrieve the word processor native format.\n\nThis requirement should be met by a general mechanism which can handle \nboth the \"single-step\" source processing described above, where the \nsource is converted into the transmission entity via a single \nconversion step, as well as \"multi-step\" source processing, where there \nare one or more intermediary processing steps and outputs. An example \nof multi-step source processing is the relationship between an \nexecutable binary image, its object files, and its source language \nfiles. It should be noted that the relationship between source and \ntransmission entity could be expressed using the relationship \nfunctionality described above in \"4.2. Relationships.\"\n\n4.6. Partial Write. \n\nAfter editing a resource, it should be possible, via HTTP, to write \nonly the changes to the resource, rather than retransmitting the entire \nresource.\n\n***Judy - Not in the specification.\n\nDuring distributed editing which occurs over wide geographic separations\nand/or over low bandwidth connections, it would be extremely inefficient\n(and frustrating) to rewrite a large resource after minor changes, such \nas a one-character spelling correction. Ideally, support will be \nprovided for transmitting \"insert\" (e.g., add this sentence in the \nmiddle of a document) and \"delete\" (e.g. remove this paragraph from the \nmiddle of a document) style updates. Support for partial resource \nupdates will make small edits more efficient, and allow distributed \nauthoring tools to scale up for editing of large documents.\n\n4.7. Name Space Manipulation\n\n***Fabio - A general treatment of server's name space management from\nclients should be introduced here.\n\n***Judy - Need more details of the semantics of copy and move,\nespecially for collections, versioned resources, and resources with\nattributes.\n\n***Judy - In the specification, but not mentioned here:  Destroy,\nUndelete, CopyHead, MoveHead.\n\n4.7.1. Copy. \n\nVia HTTP, it should be possible to make a byte-for-byte duplicate of a \nresource without a client loading, then resaving the resource. This copy \nshould leave an audit trail.\n\nThere are many reasons why a resource might need to be duplicated, such \nas change of ownership, a precursor to major modifications, or to make \na backup. In combination with delete functionality, copy can be used to \nimplement rename and move capabilities, by performing a copy to a new \nname, and a delete of the old name. Due to network costs associated \nwith loading and saving a resource, it is far preferable to have a \nserver perform a resource copy than a client. If a copied resource \nrecords which resource it is a copy of, then it would be possible for \na cache to avoid loading the copied resource if it already locally \nstores the original.\n\n4.7.2. Move/Rename. \n\nVia HTTP, it should be possible to change the URL of a resource without \na client loading, then resaving the resource under a different name.\n\nIt is often necessary to change the name of a resource, for example due \nto adoption of a new naming convention, or if a typing error was made \nentering the name originally. Due to network costs, it is undesirable \nto perform this operation by loading, then resaving the resource,\nfollowed by a delete of the old resource. Similarly, a single rename \noperation is more efficient than a copy followed by a delete operation.\nIdeally an HTTP server should record the move operation, and issue a \n\"301 Moved Permanently\" status code for requests on the old URL. A move \noperation, if implemented with attribute support, should also preserve \nmost attributes across a move. Note that moving a resource is considered \nthe same function as renaming a resource.\n\n4.8. Collections\n\n4.8.1. List Collection. A listing of all resources, along with\ntheir media type, and last modified date, which are located in a\nspecific collection should be accessible via HTTP.\n\n***Judy - Not in the specification.\n\nIn [3] it states that, \"some URL schemes (such as the ftp, http, and \nfile schemes) contain names that can be considered hierarchical.\" \nEspecially for HTTP servers which directly map all or part of their URL \nname space into a filesystem, it is very useful to get a listing of all \nresources located at a particular hierarchy level. This functionality \nsupports \"Save As...\" dialog boxes, which provide a listing of the \nentities at a current hierarchy level, and allow navigation through \nthe hierarchy. It also supports the creation of graphical visualizations\n(typically as a network) of the hypertext structure among the entities \nat a hierarchy level, or set of levels. It also supports a tree\nvisualization of the entities and their hierarchy levels.\n\nIn addition, document management systems may want to make their \ndocuments accessible through HTTP.  They typically allow the \norganization of documents into collections, and so also want their users\nto be able to view the collection hierarchy through HTTP.\n\nThere are many instances where there is not a strong correlation between\na URL hierarchy level and the notion of a collection. One example is a \nserver in which the URL hierarchy level maps to a computational process \nwhich performs some resolution on the name. In this case, the contents \nof the URL hierarchy level can vary depending on the input to the \ncomputation, and the number of resources accessible via the computation \ncan be very large. It does not make sense to implement a directory \nfeature for such a namespace. However, the utility of listing the \ncontents of those URL hierarchy levels which do correspond to \ncollections, such as the large number of HTTP servers which map their \nnamespace to a filesystem, argue for the inclusion of this capability, \ndespite not being meaningful in all cases. If listing the contents of \na URL hierarchy level does not makes sense for a particular URL, then \na \"405 Method Not Allowed\" status code could be issued.\n\nAOLpress from America Online currently supports \"Save As...\" dialog \nboxes, and graphical network visualization of a portion of a site's \nhypertext structure, which they term a \"mini-web.\" FrontPage from \nMicrosoft [6] also currently supports a graphical network visualization \nand additionally supports a tree visualization of a portion of a \nsite's structure.\n\n4.8.2. Make Collection. Via HTTP, it should be possible to\ncreate a new collection.\n\nThe ability to create collections to hold related resources supports \nmanagement of a name space by packaging its members into small, related \nclusters. The utility of this capability is demonstrated by the broad \nimplementation of directories in recent operating systems. The ability \nto create a collection also supports the creation of \"Save As...\" \ndialog boxes with \"New Level/Folder/Directory\" capability, common in \nmany applications.\n\nAOLpress from America Online currently supports this capability \nthrough their \"Save As...\" dialog box, and their custom MKDIR method.\n\n4.9. Versioning\n\nIn the following discussion, \"versioned resource\" means a resource that\nhas the structure of a directed acyclic graph, each node of which is \na version. \"Version\" means a node in this structure, which is itself \na resource. Each version typically stands in a \"derived from\" \nrelationship to its predecessor(s).\n\n***Judy - new definitions\n\n4.9.1. General Principles\n\n4.9.1.1. Stableness of versions. Most versioning systems are intended to\nprovide an accurate record of the history of evolution of a document. \nThis accuracy is ensured by the fact that a version eventually becomes \n\"frozen\" and immutable. Once a version is frozen, further changes will \ncreate new versions rather than modifying the original. In order for \ncaching and persistent references to be properly maintained, a client \nmust be able to determine that a version has been frozen. We require \nthat unlocked resource versions be frozen. This enables the common \npractice of keeping unfrozen \"working versions\". Any successful attempt \nto retrieve a frozen version of a resource will always retrieve exactly \nthe same content, or return an error if that version (or the resource \nitself) are no longer available.  Since URLs may be reassigned at a \nserver's discretion this requirement applies only for that period of \ntime during which a URL identifies the same resource. HTTP 1.1's Entity \ntags will need to be integrated into the versioning strategy in order \nfor caching to work properly.\n\n***Judy - Does the specification support this?\n\n4.9.1.2. Policy-free Versioning. Haake and Hicks [5] have identified \nthe notion of versioning styles (referred to here as versioning \npolicies, to reflect the nature of client/server interaction) as one \nway to think about the different policies that versioning systems \nimplement. Versioning policies include decisions on the shape of \nversion histories (linear or branched), the granularity of change \ntracking, locking requirements made by a server, etc. The protocol \nshould not unnecessarily restrict version management policies to any \none paradigm. For instance, locking and version number assignment \nshould be inter-operable across servers and clients, even if there are \nsome differences in their preferred models.\n\n4.9.1.3. Separation of resource retrieval and concurrency control. The \nprotocol must separate the reservation and release of versioned \nresources from their access methods. Provided that consistency \nconstraints are met before, during and after the modification of a \nversioned resource, no single policy for accessing a resource should be \nenforced by the protocol. For instance, a user may declare an intention \nto write before or after retrieving a resource via GET, may PUT a\nresource without releasing the lock, and might even request a lock via\nHTTP, but then retrieve the document using another communication\nchannel such as FTP.\n\n***Judy - The specification assumes that it's the server, not the user,\nthat determines the policy -- order of operations and what operations\nare required.\n\n***Judy - \"Separation of resource retrieval and concurrency control\" is \nsupported by the Request-Lock, Request-Intent, and Request-Working-Loc \nparameters to the CheckOut method and the discovery mechanism. This is \nall embroiled in the controversy over how much latitude we want to give \nservers, how simple we want to make things for clients, whether we want \nto rely on the discovery mechanism, etc.\n\n4.9.2. Functional Requirements\n\n***Judy - In the specification, but not mentioned here: Diff/Merge,\nServerMerge, UnVersion.\n\n4.9.2.1. Access to specific versions via a URL. For each version of a \nresource, on a server, there should be a URL to refer to that version.\nThat is, a version is itself a resource. \n\nThis is required for version-specific linking, and for non-versioning \nclient support.\n\n4.9.2.2. A URL to denote a versioned resource itself, rather than \nspecific versions of it.\n\nThis identifier is needed for queries about the versioning status of a\nresource, that do not apply only to one version of that resource. It is\nalso used to perform operations (such as adjusting attributes, changing\nlocks, or reassigning URLs) that affect all versions of a resource,\nrather than any specific version.\n\n4.9.2.3. Direct access to a server-defined \"default\", \"current\" or \"tip\"\nversion of a resource.\n\nThis is one of the simplest ways to guarantee non-versioning client\ncompatibility. If no special version information is provided, the\nserver will provide a default. This does not rule out the possibility\nof a server returning an error when no sensible default exists, but it\ndoes provide a standard way to support non-versioning clients, and one\nof the most common version access disciplines.\n\n4.9.2.4. A way to access common related URLs from the URL of a \nparticular version or of a versioned resource:\n   o root version(s) of this document\n   o predecessor version(s) of this document\n   o successor version(s) of this document\n   o default version of this document\nIt must be possible in some way for a versioning client to access \nversions related to a resource whose URL it has. In particular, access \nto the \"default\" version of a resource is an extremely important \noperation, that a client should be able to perform at any time that \na URL for a particular version or for a versioned resource is seen.\n\n***Judy - Specification provides some, but not all, of these navigation\npaths.\n\n4.9.2.5. A way to retrieve the complete version topology for a resource.\nThere should be a way to retrieve information about all versions of a\nresource. The format for this information must be standardized so that\nthe basic information can be used by all clients. Other specialized\nformats should be accomodated, for servers and clients that require\ninformation that cannot be included in the standard topology.\n\n4.9.2.6. A way to determine whether a given URL points to a version \nof a versioned resource.\n\n***Judy - Are we requiring that you be able to tell this just by\nexamining the URL?\n\n4.9.2.7. A way to distinguish, given a URL of a version, the part of\nthe URL that identifies the version from the part that identifies the\nversioned resource.\n\n***Judy - Do we really have to (want to) require that you be able to\nfind out the URL of the versioned resource by examining the URL of the\nversion?  Is the requirement really just that there be some way to find\nout, for any version, the URL of its versioned resource?\n\n***Judy - Specification does not provide a way to find out the URL of\nthe versioned resource(s) to which a version belongs.  \n\nBeing able to determine the URL of the versioned resource makes it \npossible to implement browsing the version tree. \n\nIt also supports some comparison operations: It makes it possible to\ndetermine whether two URLs designate versions of the same versioned \nresource. However, given the phenomenon of URL aliasing, it \nis insufficient to determine that they are not versions of the same \nresource.\n\n***Judy - If 4.9.2.8 - 14 are intended to require separate operations\nfor each of these functions, they conflict with the approach taken in\nthe WEBDAV specification.\n\n4.9.2.8. A way to request exclusive access to a version of a resource \n(Lock). (See Section 4.3 \"Locking\" above.)\n\nSince not all systems implement lock-based access, the protocol should\nnot require clients to take out a lock before editing, nor should it\nrequire servers to support locking. \n\n4.9.2.9. A way to release exclusive access to a resource (Unlock). This \nis the inverse of Lock.\n\n4.9.2.10. A way for a client to declare an intention to modify a \nresource (Reserve). (See Section 4.4 \"Notification of Intent to Edit\"\nabove.)\n\nThis operation is required before any versioned update. Its effects may\nvary depending on server policy, from locking a resource, to forking a\nnew variant, to a NOOP on servers that do not track sessions or restrict\nupdates. If this operation returns a version number, the client is\nrequired to make sure that it uses a copy of the data associated with\nthat version number of the resource for any update operations it\ncarries out. Servers that wish to enforce a mandatory GET operation\nbefore update, should simply use a fresh version identifier on the\nreturn from this operation.\n\n4.9.2.11. A way to declare the end of an intention to write a resource \n(Release). This is the inverse of Reserve. Typically, servers will \ncommit updates at this time, and return a final version identifier if \npossible and if it was not already returned.\n\n4.9.2.12. A way to submit a new version of a resource (PUT). The server \nshould be able to attach it to the correct part of the version tree, \nbased on the version number associated with the resource before its \nmodification.\n\n4.9.2.13. A way for a client to request a version identifier for a \nchecked out version. Such an identifier will not be used by any other \nclient in the meantime. The server may refuse the request.\n\n4.9.2.14. A way for a client to propose a version identifier upon \nsubmitting a version of a resource. The server may refuse to to use \nthe client's suggested version identifier.\n\n4.9.2.15. A way for a client to supply metadata to be associated with \na version. (See Section 4.1 \"Attributes\" above.)\n\nThe kinds of data supplied here might be simple textual comments or\nmore structured data. An ability to attach arbitrary fields and content\nis probably required, but a standard set of attributes that would\nenable interoperation would be useful.  At a minimum, it must be \npossible to associate comments with a version, explaining what changes\nwere made, when it is checked in.\n\n4.9.2.16. A way for a server to provide a version identifier to be used \nfor a resource in further operations.\n\nThis identifier must accompany client requests to manipulate the\nresource. In particular, if a resource is being modified, the identifier\nmust be used when submitting an update. This allows servers to track \nactive sessions by assigning version identifiers when documents are \nretrieved, locked, or reserved.\n\n4.9.2.17. A way to track resources that have been Reserved (Session \nTracking).  This allows the server to ensure that the user operating\non a resource is the same one who Reserved it.\n\n***Judy -- Not in the specification.\n\n***Judy - Uncheckout is neither in the requirements nor in the\nspecification.  Do we need it?\n\n4.9.3. Rationale\n\nVersioning in the context of the world-wide web offers a variety of\nbenefits:\n\nIt provides infrastructure for efficient and controlled management of \nlarge evolving web sites. Modern configuration management systems are \nbuilt on some form of repository that can track the revision history of\nindividual resources, and provide the higher-level tools to manage \nthose saved versions. Basic versioning capabilities are required to \nsupport such systems.\n\nIt allows parallel development and update of single resources. Since \nversioning systems register change by creating new objects, they\nenable simultaneous write access by allowing the creation of variant\nversions. Many also provide merge support to ease the reverse operation.\n\nIt provides a framework for access control over resources. While \nspecifics vary, most systems provide some method of controlling or \ntracking access to enable collaborative resource development.\n\nIt allows browsing through past and alternative versions of a resource.\nFrequently the modification and authorship history of a resource is\ncritical information in itself.\n\nIt provides stable names that can support externally stored links for\nannotation and link-server support. Both annotation and link servers \nfrequently need to store stable references to portions of resources \nthat are not under their direct control. By providing stable states of \nresources, version control systems allow not only stable pointers into \nthose resources, but also well-defined methods to determine the \nrelationships of those states of a resource.\n\nIt allows explicit semantic representation of single resources with \nmultiple states. A versioning system directly represents the fact that \na resource has an explicit history, and a persistent identity across \nthe various states it has had during the course of that history.\n\n5. Acknowledgements (Get current mailing list)\n\nOur understanding of these issues has emerged as the result of much\nthoughtful discussion, email, and assistance by many people, who\ndeserve recognition for their effort.\n\nMartin Cagan, Continuus Software, Marty_Cagan@continuus.com\nDan Connolly, World Wide Web Consortium, connolly@w3.org\nRon Fein, Microsoft, ronfe@microsoft.com\nDavid Fiander, Mortice Kern Systems, davidf@mks.com\nRoy Fielding, U.C. Irvine, fielding@ics.uci.edu\nYaron Goland, Microsoft, yarong@microsoft.com\nPhill Hallam-Baker, MIT, hallam@ai.mit.edu\nDennis Hamilton, Xerox PARC, hamilton@parc.xerox.com\nAndre van der Hoek, University of Colorado, Boulder,\n  andre@bigtime.cs.colorado.edu\nGail Kaiser, Columbia University, kaiser@cs.columbia.edu\nRohit Khare, World Wide Web Consortium, khare@w3.org\nDave Long, America Online, dave@sb.aol.com\nHenrik Frystyk Nielsen, World Wide Web Consortium, frystyk@w3.org\nOra Lassila, Nokia Research Center, ora.lassila@research.nokia.com\nLarry Masinter, Xerox PARC, masinter@parc.xerox.com\nMurray Maloney, SoftQuad, murray@sq.com\nJim Miller, World Wide Web Consortium, jmiller@w3.org\nAndrew Schulert, Microsoft, andyschu@microsoft.com\nChristopher Seiwald, Perforce Software, seiwald@perforce.com\nRichard Taylor, U.C. Irvine, taylor@ics.uci.edu\nRobert Thau, MIT, rst@ai.mit.edu\n\n6. References\n\n[1] America Online, \"AOL Web Tools -- AOLpress 1.2 Features.\" WWW page.\nhttp://www.aolpress.com/press/1.2features.html.\n\n[2] T. Berners-Lee, D. Connolly. \"HyperText Markup Language\nSpecification - 2.0.\" RFC 1866, MIT/LCS, November 1995.\n\n[3] T. Berners-Lee, L. Masinter, M. McCahill. \"Uniform Resource\nLocators (URL).\" RFC 1738, CERN, Xerox PARC, University of Minnesota,\nDecember 1994.\n\n[4] R. Fielding, J. Gettys, J. C. Mogul, H. Frystyk, and\nT. Berners-Lee.  \"Hypertext Transfer Protocol -- HTTP/1.1.\" RFC 2068,\nU.C. Irvine, DEC, MIT/LCS, January 1997.\n\n[5] A. Haake, D. Hicks. \"VerSE: Towards Hypertext Versioning Styles\", \nProc. Hypertext'96, the Seventh ACM Conference on Hypertext, 1996,\npages 224-234.\n\n[6] Microsoft. \"Microsoft FrontPage for Windows Data Sheet.\" WWW page.\nhttp://www.microsoft.com/msoffice/frontpage/productinfo/brochure/\ndefault.htm.\n\n[7] K. Osterbye. \"Structural and Congitive Problems in Providing Version\nControl for Hypertext\", Proceedings of the ACM Conference on Hypertext,\nMilano, Italy, 1992, pp 33-42.\n\n[8] \"Version Control in Hypermedia Databases\" Technical report\nTAMU-HRL-91-004, Hypertext Research Lab, Texas A&M University. 1991.\n\nAuthors' Addresses\n\nJudith Slein\nXerox Corporation\n800 Phillips Road 128-29E\nWebster, NY 14580\n\nEMail: slein@wrc.xerox.com\n\nE. James Whitehead, Jr.\nDepartment of Information and Computer Science\nUniversity of California\nIrvine, CA 92697-3425\n\nFax: 714-824-4056\nEMail: ejw@ics.uci.edu\n\nDavid G. Durand\nDepartment of Computer Science\nBoston University\nBoston, MA\n\nEMail: dgd@cs.bu.edu\n\nFabio Vitali\nDepartment of Computer Science\nUniversity of Bologna\nITALY\n\nEMail: fabio@cs.unibo.it\n\n", "encoding": "ascii"}