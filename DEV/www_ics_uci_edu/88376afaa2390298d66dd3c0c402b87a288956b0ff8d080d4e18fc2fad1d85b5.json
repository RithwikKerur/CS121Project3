{"url": "https://www.ics.uci.edu/~irani/s11_22/CodeExamples/SortingAlgorithms.txt", "content": "Here is some pseudo-code for Selection Sort.\r\nMy version keeps the right portion of the array sorted and\r\ninserts items a[n-2] down to a[0]\r\nThe version most commonly seen keeps the right portion of the\r\narray sorted and inserts items a[2] through a[n-1]\r\n\r\nInsertionSort:\r\n\r\n/* a[0] to a[n-1] is the array to sort */\r\n\r\n// items a[i+1] through a[n-1] are assumed to be sorted.\r\n// inserting item a[i] in it's correct place\r\nfor ( i = n-2; i >= 0; i-- )\r\n{\r\n    // save item to be inserted\r\n    save = a[i];\r\n    \r\n    j = i+1;\r\n    // going from left to right, move items over if they are less than save\r\n    while( j < n && a[j] < save )\r\n    {\r\n        a[j-1] = a[j];\r\n        j++;\r\n     }\r\n     \r\n     // put save in its correct location\r\n     a[j-1] = save;\r\n}\r\n\r\n\r\nThis version from Wikipedia is close to what I presented in class:\r\n\r\n/* a[0] to a[n-1] is the array to sort */\r\nint iPos;\r\nint iMin;\r\n \r\n/* advance the position through the entire array */\r\n/*   (could do iPos < n-1 because single element is also min element) */\r\nfor (iPos = 0; iPos < n; iPos++)\r\n{\r\n  /* find the min element in the unsorted a[iPos .. n-1] */\r\n \r\n  /* assume the min is the first element */\r\n  iMin = iPos;\r\n  /* test against all other elements */\r\n  for (i = iPos+1; i < n; i++)\r\n    {\r\n      /* if this element is less, then it is the new minimum */  \r\n      if (a[i] < a[iMin])\r\n        {\r\n          /* found new minimum; remember its index */\r\n          iMin = i;\r\n        }\r\n    }\r\n \r\n  /* iMin is the index of the minimum element. Swap it with the current position */\r\n  if ( iMin != iPos )\r\n  {\r\n    swap(a, iPos, iMin);\r\n  }\r\n}\r\n", "encoding": "ascii"}