{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/writingclasses2/writingclasses2.txt", "content": "\t\t\tWriting Classes (continued)\r\n\r\nIn this lecture we will look at the scope of names: the places that the names\r\ncan be used and how Python determines the object associated with a name. We\r\nwill first look at scope in modules. Then we will look at class names refering\r\nto value objects (not methods). Finally we will examine how to define one\r\nfunction inside another and discuss the full generality of the LEGB rule\r\n(Local, Enclosing, Global, and Builtins). We close with a discussion of the\r\ndifferent kinds of names in Python.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nScope in Modules: Global and Local Names for Functions\r\n\r\nModules (that do not define/import classes) typically define names that refer\r\nto value objects and names that refer to functions, as is illustrated below.\r\n\r\n  x = 1\r\n\r\n  def factorial(n):\r\n      answer = 1\r\n      for i in irange(2,n):\r\n          answer *= i\r\n      return answer\r\n\r\n  g = factorial\r\n\r\nprint(factorial(3),g(3))\r\n\r\nIn this code Python binds names (x, factorial, g) to objects (a value object\r\nthat is an instance of the class int, a function object). Note that after\r\ndefining g = factorial, the names g and factorial both refer to (share) the same\r\nfunction object. So calling either factorial(3) or g(3) calls the same function\r\nobject with the argument 3 (matching its parameter n) and both return a result\r\nof 6 (which is 3!=1*2*3). So this script prints: 6 6\r\n\r\nNames defined at the module level are called \"global\" names. So in this module,\r\nx, factorial, and g are all examples of global names.\r\n\r\nFunctions also define names: parameter names and local names (we might more\r\naccurately define parameter names as a special kind of local name). When a\r\nfunction is called, all its parameter names are bound to the arguments from the\r\ncall; when the function returns, these names disappear, only to be rebound when\r\nthe function is called again. The factorial function defines only the parameter\r\nn.\r\n\r\nWhen a function executes, it can define local names which are initialized and\r\nused within the function. As with parameters, when the function returns, these\r\nnames disappear, only to be redefined again when the function is executed again.\r\nThe factorial function defines the local names answer and i.\r\n\r\n    Contrast this with the instance/self names for objects; when an object is\r\n    constructed in the __init__ method, it defines instance/self names which\r\n    stay with the object through all its method calls: in fact most method\r\n    calls examine, change the state, or rebind of these instance/self names.\r\n\r\nThe script outside a function cannot refer to any parameters or local names\r\ndefined inside the fucntion: these names are for use only within that function\r\n(inside the scope of the function). Also two functions that are both global\r\ncannot refer to/examine any names defined in the other. At the end of this\r\nlecture we will see how to define one function INSIDE another, in which case\r\nthe inner function can examine the names in the outer function (in the outer\r\nfunction's scope).\r\n\r\nThere is one interesting interaction between global names and names used in\r\nfunctions. A function may use (refer to, but not change the binding of) a global\r\nname. For example, we can trivially use the global name x in the function f.\r\n\r\n  x = 1\r\n\r\n  def f(n):\r\n      print(n,x)\r\n\r\n  f(3)\r\n\r\nThis script prints: 3 1\r\n\r\nIn a more interesting way, we could define\r\n\r\n  tracing = True\r\n\r\n  def f(n):\r\n      if tracing:\r\n          print('f called with argument', n)\r\n      ....\r\n\r\n  f(3)\r\n\r\n  tracing = False\r\n\r\n  f(3)\r\n\r\nWhen the first f(3) is called, the global name tracing is bound to True, so the\r\nfunction's if test evaluates to True and the function prints\r\n\r\n  f called with argument 3.\r\n\r\nBut the next statement rebinds the name tracing to False, so when the second\r\nf(3) is called, the global name tracing is bound to False, so the function's if\r\ntest evaluates to False and it skips the print.\r\n\r\nGenerally, when a function is called, and it refers to a non-local name, it\r\ntries to find a binding of that global name.\r\n\r\nOf course, it is better style to not use global names in a function, but\r\ninstead pass it as an argument to some parameter in the function. But in the\r\ncase of a global tracing name (which might affect many functions), sometimes it\r\nis easier to just define it as a global name and use that global name in each\r\nfunction. Beginners often use global names too frequently: they are sometimes\r\nuseful, but functions should mostly use only information passed to their\r\nparameters.\r\n\r\nNow we will come to something confusing, but we will learn the right way to\r\nthink about it. I'm cutting this example down to the bare bones. In previous\r\nexamples we examined functions that examined a global name; here it \"looks like\"\r\nwe are trying to change the binding of such a global name (from 1 to 2).\r\n\r\n  x = 1\r\n\r\n  def f(n):\r\n      x = 2\r\n      print(n,x)\r\n\r\n  f(3)\r\n\r\n  print(x)\r\n\r\nBut what actually happens is that x = 2 defines a new local name in the\r\nfunction f; it DOES NOT change the binding of the global name (but we will see\r\nhow this can be done soon). So, the function prints the value associated with\r\nthis local name (2) and then the function terminates and the local name goes\r\naway. The print in the script after the function call refers to the global name\r\nx whose binding is unchanged, and prints its value (1).\r\n\r\nIf we want to change the binding for the global name x inside the function f, we\r\ncan do so, but it requires a special \"global\" declaration.\r\n\r\n  x = 1\r\n\r\n  def f(n):\r\n      global x\r\n      x = 2\r\n      print(n,x)\r\n\r\n  f(3)\r\n\r\n  print(x)\r\n\r\nHere, the global x declaration means that the function should not define x as\r\na local name, so x = 2 should rebind the global name x, not introduce a local\r\nname x in the function; so it DOES change the binding of the global name. The\r\nfunction prints the value associated with this updated global name (2) and then\r\nthe function terminates. The print in the script after the function call refers\r\nto the global name x whose binding the function changed and prints its new\r\nvalue (2).\r\n\r\nIn fact, if we didn't start by defining a global name x, but still wrote\r\n\r\n  def f(n):\r\n      global x\r\n      x = 2\r\n      print(n,x)\r\n\r\n  f(3)\r\n\r\n  print(x)\r\n\r\nThen the definition x = 2 inside the function f defines a (new) global name and\r\nbinds it to 2, so this code prints what the code above prints.\r\n\r\nTo summarize what we know at this point\r\n\r\n(1) We can refer to global names in a function without a special mechanism, but\r\n       not rebind the values of global names (see 2-3)\r\n\r\n(2) If we assign to a global name in a function, the function instead creates\r\n       a local name and leaves the global name untouched (bound to the same\r\n       value).\r\n\r\n(3) If we declare a name global in a function then in contrast to (2), any\r\n       assignment to that name binds (if the name is not already bound)\r\n       or rebinds (if the name is already bound) the global name to a new value\r\n\r\nFinally, these rules combine to create a confusing situation. Look at the code\r\nbelow, which has no \"global x\" declaration. There are two natural ways to\r\ninterpret what is happening: the simple one is WRONG, the more complicated one\r\nis RIGHT.\r\n\r\n  x = 1\r\n\r\n  def f(n):\r\n      print(n,x)\r\n      x = 2\r\n      print(n,x)\r\n\r\n  f(3)\r\n\r\n  print(x)\r\n\r\nWRONG: We might think that Python binds the global x to 1; then calls the\r\nfunction f, which prints the value 1, bound to the global name (by 1 above) and\r\nthen defines and intializes to 2 a local name (by 2 above); and then prints 2,\r\nthe value bound to the local name. But this is not what Python does.\r\n\r\nRIGHT: Python raises an exception on the first print(n,x) in f:\r\n\r\n   UnboundLocalError: local variable 'x' referenced before assignment\r\n\r\nPython's reasoning goes as follows. When f is declared (before it is called)\r\nPython determines that it doesn't declare x to be global, so it knows that x\r\nwill be defined as a local name, and ALL USES of x will be to that local name.\r\nBut the first use of x occurs BEFORE that local name is defined and initialized\r\nto 2, so Python raises an exception.\r\n\r\nBy this reasoning, examine the following code, which is the same but includes\r\na global decaration for x at the very end of the function.\r\n\r\n  x = 1\r\n\r\n  def f(n):\r\n      print(n,x)\r\n      x = 2\r\n      print(n,x)\r\n      global x\r\n\r\n  f(3)\r\n\r\n  print(x)\r\n\r\nThis code calls f, which first prints the value 1, of the global name x; then\r\nit rebinds the global name x to the value 2, then it prints the new value 2,\r\nof the global name x, and terminates the function. Then the script prints the\r\nvalue 2, bound to the global name x.\r\n\r\nPython's reasoning goes as follows. When f is declared (before it is called)\r\nPython determines that it DOES declare x to be global (even though this\r\ndeclaration is written at the end of the function (good programming practice\r\nwould place it first in the function), so it knows that x will mean the global\r\nname x, so ALL USES of x will be to that global name.\r\n\r\nSummary: Python has special rules for how functions use global and local names.\r\nBut these rules can be a source of confusion and errors. If possible, use NO\r\nglobal names in functions; if a function must use information bound to a global\r\nname, use that name as an argument to pass that information to the parameter of\r\na function.\r\n\r\nCan you carefully use the rules above to predict (and explain) what is printed\r\nby the following code. The problem is compounded by the fact that we are using\r\nnames of function objects, not names of value objects, but in Python objects\r\nare objects.\r\n\r\n  def f():\r\n      print(1)\r\n\r\n  def g():\r\n      global f\r\n      def f():\r\n          print(2)\r\n      f()\r\n    \r\n  g()\r\n  f()\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nClass Names: Methods and Values\r\n\r\nWe have learned that we can define classes in modules: doing so defines the\r\nclass name, which refers to the class object from which instance of the class\r\ncan be constructed, when called). When we define a class, primarily we define\r\nall the methods in the class. Every object constructed from a class has its\r\nstate initialized by Python automatically calling the __init__ method (which\r\ndefines and initializes instance/self names in the object's namespace). And\r\nthen we can call class methods on the object in the form o.m(arguments).\r\n\r\nBut classes can also define other names besides methods: names that are bound\r\nto values. In the methods of the class we refer to such names by using qualified\r\nname syntax: writing them as the name of the class, followed by a period,\r\nfollowed by the name. Outside the class methods, we can refer to such names via\r\nthe same qualified name, or via an object of the class. Again Python translates\r\nthe access o.n as type(o).n. A name defined in this way is shared by all the\r\nobjects constructed from the class (unlike instance names which are different\r\nfor each object constructed from the class).\r\n\r\nHere is an example of a class C that defines and manipulates a name bound to a\r\nvalue object. This class does nothing but use this name to count how many\r\nobjects are constructed from the class: how many times __init__ is called.\r\nSometimes this counting is useful, and this is the standard way to do it.\r\nNote that this class uses no intstance names (no self.name)\r\n\r\nclass C:\r\n    objects_created = 0\r\n    \r\n    def __init__(self):\r\n        C.objects_created += 1\r\n        \r\n    def how_many(self):\r\n        return C.objects_created\r\n\r\nHere objects_created is defined and initialized in the class, just as the\r\n__init__ and how_many methods are defined. Notice how this name is referred in\r\nthe methods as C.objects_created.\r\n\r\nHere are 5 statements that use the class.\r\n\r\na = C()\r\nb = C()\r\n\r\nprint(a.how_many()) \r\nprint(C.objects_created)\r\nprint(c.objects_created)\r\n\r\nThe last three all print 2, but in different ways:\r\n\r\na.how_many()      calls a method that returns the value\r\nC.objects_created refers to this name directly\r\na.objects_created uses the fundamental equation of object-oriented to refer to\r\n                  this name: Python translates a.objects_created  into\r\n                  type(a).objects_created into C.objects_created\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDefining Functions with Functions and the full LEGB Rules\r\n\r\nPython allows us to define functions within functions. Often this is done to\r\nwrite a helper function (and later we will see how we can use this technique \r\nto write functions that return functions). In this lecture we will examine one\r\nfunction defined in a function to study the scope rules involved.\r\n\r\nThe following function takes two lists as a parameter: a list of values and a\r\nlist of checks. It returns a list the same size as the check list: for every \r\nvalue in the second list, the result list shows the number of times that value\r\nappears in the first list.\r\n\r\ncount_all([1, 5, 3, 5, 2, 6, 5, 3, 2, 7, 4], [3, 4, 5]) returns [2, 1, 3]\r\nbecause 3 occurs 2 times in the first list, 4 occurs 1 time in the first list,\r\nand 5 occurs 3 times in the first list.\r\n\r\ndef count_all(alist,checks):\r\n    # computed result (by appending values)\r\n    result = []\r\n\r\n    # inner function\r\n    def count_one(check):\r\n        count = 0\r\n        for v in alist:\r\n            if v == check:\r\n                count += 1\r\n        result.append(count)\r\n\r\n    # body of count_all, to compute the result\r\n    # result changes in count_one (alist is examined there)\r\n    for c in checks:\r\n        count_one(c)\r\n    return result\r\n\r\nHere are the names the outer/check_all and inner/check_one functions define\r\n  (1) count_all defines two parameter names: alist and checks\r\n  (2) count_all defines three local names: result, c, and the function count_one\r\n\r\n  (3) count_one defines one parameter name: check\r\n  (3) count_one defines two local names: count and v\r\n\r\nThe interesting scoping issue here is that the inner/count_one function uses\r\nthe names alist and result, which refer to names defined in the outer/count_all\r\nfunction (alist is defined there as a parameter, result is defined there as a\r\nlocal variable).\r\n\r\nWhy can an inner function refer to names defined in an outer function?\r\nGenerally, Python uses the LEGB rule to determine what name to use (and what\r\nnames are legal to use) in a scope. These abbreviate Local, Enclosing, Global,\r\nand Builtins. Whenever we use a name in Python, it looks at the following scopes\r\nIN THE FOLLOWING ORDER:\r\n\r\n(1) Local scope (of a module or function)\r\n(2) Enclosing scope (count_all is the enclosing scope of count_one)\r\n(3) Global scope (in the module; discussed at length above)\r\n(4) Builtins (names defined in the builtins module, automatically imported)\r\n\r\nSo, when defining function inside functions, the inner function (by rule 2) can\r\nrefer to names defined in the outer function. We have already discussed rules\r\n1 and 3 earlier in this lecture. And rule 4 much earlier in the quarter. But we\r\ncan now put all these rules together under the LEGB name.\r\n\r\nNote that although we referred to and mutated result in count_one, we never\r\nchanged its binding. If we wrote result = ['strange'] instead of \r\nresult.append(count), we might first imagine that count_all would return\r\n['strange']? But it would return [] (the value initially assigned to result).\r\n\r\nThis is because like with global names, names in an enclosing scope can be\r\nexamined, but if we assign to them Python creates a new local name in the\r\nenclosed scope. So writing result = ['strange'] doesn't change the binding of\r\nthe name in the enclosing scope, it defines a new name in the enclosed scope.\r\nAs with the \"global\" declaration, there is a \"nonlocal\" declaration. If we\r\ndeclare nonlocal result in check_one, then the assignment result = ['strange']\r\nwould change the binding of the result defined as a local name in the enclosing\r\nscope, and the function would ultimately return that strange value.\r\n\r\nFinally, now is a good time to review a classification of names:\r\n\r\n(1) global names   : defined in a module (via =, def, or class)\r\n(2) parameter names: defined in the header of functions/methods\r\n(3) local names    : defined in the body of functions/methods\r\n(4) instance names : defined in class methods (typically in __initi__ via\r\n                       self.name = value) and used in class method\r\n(5) class names    : defined in a class (see the discussion above)\r\n", "encoding": "ascii"}