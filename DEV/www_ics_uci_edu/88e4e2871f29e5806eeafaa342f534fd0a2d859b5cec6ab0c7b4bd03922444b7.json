{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/collectionsi/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Collection Classes: Basics (including Iterators)</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Collection Classes: Basics<br>Including Iterators</h1>\r\n<p>\r\n<h2>Introduction to Computer Science II<br>\r\nICS-22<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nThis lecture begins a series of lectures that together act as a capstone for\r\n  the first half of the quarter.\r\nThese lectures explore collection classes, which are a sophisticated and\r\n  powerful group of related interfaces and classes that are useful in a wide\r\n  variety of programming tasks; they are also designed and built using most\r\n  of the high-level Java programming features that we have studied: interfaces,\r\n  inheritance, abstract classes, concrete classes, exceptions, and analysis\r\n  of algorithims (and iterators, and inner-clases which we learn in this\r\n  lecture).\r\n<p>\r\nThus, studying collection classes now brings all these features back into\r\n  focus, each sharing the spotlight with -and complementing- the others.\r\nOnce you accept the power of these tools, and practice using them, you'll\r\n  never think about plain old arrays in the same way again (and maybe you'll\r\n  never think of them at all).\r\n<p>\r\nThis lecture begins with a taxonomy of the collection classes, and an\r\n  introduction to the interfaces, abstract classes, and concrete classes\r\n  that are used to define them.\r\nThe second part of this lecture explores <b>iterators</b>, which is an\r\n  interesting concept by itself, but which takes on a central role when\r\n  coupled with collection classes.\r\nWe can create extremely sophisticated and efficient behavior by composing\r\n  collection classes (for modelling complex data) and processing them with\r\n  iterators.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Design -->\r\n\r\n<a name=\"Design\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Design of Collection Classes</b></td>\r\n<td width =\"80%\">\r\nIn this section we will briefly examine the standard Java collection classes,\r\n  to get a birds-eye view of how they are designed and implemented.\r\nFirst we will examine the overall relationships among the interfaces, abstract\r\n  classes, and concrete classes; these features naturally arrange themselves\r\n  into three vertical levels in a hierarchy.\r\nThen we will examine one example more closely, at each level in the hierarchy.\r\n<p>\r\nThe following legend explains the three levels and some of the notation used.\r\n</table>\r\n<p>\r\n<img src=\"images/legend.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nOverall, there are three major groups of \"collection\" classes, eact rooted in\r\n  one special interface: <b>OrderedCollection</b>, <b>Collection</b>, and\r\n  <b>Map</b>.\r\nEach group is presented using the three vertical levels of interfaces,\r\n  abstract classes, and concrete classes.\r\nWe depict the <b>OrderedCollection</b> group as follows.\r\n</table>\r\n<p>\r\n<img src=\"images/orderedcollectiontree.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nNext, we depict the <b>Collection</b> group as follows.\r\n</table>\r\n<p>\r\n<img src=\"images/collectiontree.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nAnd finally, we depict the <b>Map</b> group as follows.\r\n</table>\r\n<p>\r\n<img src=\"images/maptree.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nIn each, interfaces are implemented by abstract classes (which supply some\r\n  but not all of the needed methods) which are extended by concrete classes\r\n  that inherit some behvaior from the abstract classes and define all their\r\n  abstract methods.\r\nIn some cases, an interface extends another interface: \r\n   <b>List</b> and <b>Set</b> extend <b>Collection</b>;\r\n   <b>SortedSet</b> extends <b>Set</b>; and\r\n   <b>SortedMap</b> extends <b>Map</b>.\r\nIn many cases, one abstract class extends another, before being extended by\r\n  a concrete subclass.\r\nRecall that concrete subclasses automatically implement the interfaces that\r\n  their superclasses implement, and [abstract]classes can implement more\r\n  than one interface (but can extend only one superclass); this is a\r\n  fundamentcal difference between interfaces and classes.\r\n<p>\r\nIn the next three sections, we will examine the Javadoc of an interface, two\r\n  abstract classes, and a concrete class, forming a chain from top to bottom,\r\n  starting with the <b>Collections</b> interface and ending with the\r\n  <b>HashSet</b> concrete class.\r\nWe will spend two more lectures covering this same material in more detail.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Interfaces -->\r\n\r\n<a name=\"Interfaces\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Interfaces</b></td>\r\n<td width =\"80%\">\r\nThe methods specified in the <b>Collection</b> interface are summarized\r\n  in the following Javadoc.\r\nThe semantics of most methods should be somewhat intuitive.\r\nPrimarily, objects can be added and removed from a collection, and checked for\r\n  membership.\r\nMethods like <b>add</b>, <b>contains</b>, and <b>remove</b> which have\r\n  <b>Object</b> parameters, have counterparts <b>addAll</b>,\r\n  <b>containsAll</b>, and <b>removeAll</b> which use another\r\n  <b>Collection</b> as a parameter, adding, removing, or checking for\r\n  containment each of the values in the parameter.\r\n<p>\r\nRead these Javadoc descriptions now; we will examine them again, in more\r\n  detail, in a subsequent lecture (including <b>hashCode</b>).\r\nWe will discuss the <b>iterator</b> method (and the <b>Iterator</b>\r\n  interface) at the end of this lecture.\r\n</table>\r\n<p>\r\n<img src=\"images/collection.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNow we will examine an abstract class and abstract subclass that implement\r\n  a surprising number of these methods, leaving the concrete subclass to\r\n  implement very little (mostly the iterator, which many other methods use).\r\nRemember that there are 15 methods specified in this interface.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Abstract Classes -->\r\n\r\n<a name=\"Abstract\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Abstract Classes</b></td>\r\n<td width =\"80%\">\r\nNow we will examine the Javadoc of an abstract class and its abstract subclass\r\n  that implement the interface specified above (although some of its methods\r\n  are abstract).\r\nThe <b>Collection</b> interface specified 15 methods.\r\nThe <b>AbstractCollection</b> class specifies one <b>protected</b> constructor\r\n  and 14 methods; it doesn't define <b>equals</b> or <b>hashCode</b> which are\r\n  inherited from the <b>Object</b> class that this one implicitly extends\r\n  (and overridden is the abstract subclass in the next section); it adds the\r\n  specification of a <b>toString</b> method.\r\nOf these 14 (=15-2+1) methods, all but two <b>iterator</b> and <b>size</b> are\r\n  defined here (they are defined to be <b>abstract</b>), although operations\r\n  like <b>add</b>, <b>contains</b>, and <b>remove</b> are implemented to throw\r\n  <b>UnsupportedOperationException</b>.\r\nYet the <b>addAll</b>, <b>containsAll</b>, and <b>removeAll</b> methods are\r\n  completely written here, using the promised iterator and eventually-working\r\n <b>add</b>, <b>contains</b>, and <b>remove</b> methods: they iterate through\r\n  the parameter collection, calling the appropriate method for each element.\r\nHere is the Javadoc of <b>AbstractCollection</b> (because of size constraints,\r\n  it appears in a smaller font).\r\n</table>\r\n<p>\r\n<img src=\"images/abstractcollection.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n</tbody>\r\n</table>\r\nThe <b>AbstractSet</b> class extends <b>AbstractCollection</b>.\r\nIt too specifies one <b>protected</b> constructor, and it specifies 3 methods:\r\n  it overrides the <b>equals</b> and <b>hashCode</b> methods inherited\r\n  from <b>Object</b>, and it also overrides the <b>removeAll</b> method\r\n  inherited from the <b>AbstractCollection</b> (it can improve its peformance\r\n  knowing something that is true about sets but not collections in general).\r\nHere is the Javadoc of <b>AbstractSet</b>, which is very short.\r\n</table>\r\n<p>\r\n<img src=\"images/abstractset.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNow we will examine the Javadoc of a concrete class that extends\r\n  <b>AbstractSet</b>.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Concrete Classes -->\r\n\r\n<a name=\"Concrete\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Concrete Classes</b></td>\r\n<td width =\"80%\">\r\nNow we will examine the Javadoc of a concrete class that extends\r\n  <b>AbstractSet</b>.\r\nThis class is implemented by an advanced and efficient technique called\r\n  <b>hashing</b>\r\nWe will briefly discuss hash tables at the end of this series of lectures.\r\nNeedless to say from the constructors, hash tables have \"initial sizes\" and\r\n  \"load factors\"; you will need to use only the first two constructors this\r\n  quarter; the other parameters relate to fine-tuning the efficiency of\r\n  the underlying hash table, and is a topic you will study in IC-23.\r\n<p>\r\nThe <b>HashSet</b> class extends <b>AbstractSet</b>.\r\nIt specifies some <b>public</b> constructors and 8 methods:\r\n  defines the two abstract methods that it inherited, <b>iterator</b>\r\n  and <b>size</b>; it overrides some other inherited methods as well\r\n  (it either implements methods like <b>add</b>, which were previously defined\r\n  to throw <b>UnsupportedOperationException</b> and can improve the\r\n  peformance of others, knowing something about the hash tables that\r\n  implement this class)\r\nHere is the Javadoc of <b>HashSet</b> (because of size constraints,\r\n  it appears in a smaller font).\r\n</table>\r\n<p>\r\n<img src=\"images/hashset.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nSo, the structure leading from the <b>Collection</b> interface to the\r\n  <b>HashSet</b> concrete class involved all sorts of interesting\r\n  inheritance of abstract and concrete methods.\r\nIn some sense, we can use this class without knowing all this information,\r\n  by examining the <b>Collection</b> and <b>Set</b> interfaces, and knowing\r\n  that it implements its methods efficienty.\r\n<p>\r\nFinally, we when discuss the actual implementation of all these methods in\r\n  concrete classes, we will discuss their performance in terms of big O\r\n  notation, where <b>n</b> is typically the number of values stored in the\r\n  collection.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- A Simple Example -->\r\n\r\n<a name=\"Simple\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Simple Example of Using a Collection Class</b></td>\r\n<td width =\"80%\">\r\nAssume that we have to prompt the user for a sequence of <b>n String</b>s,\r\n  such that the they are different.\r\nThe following program uses the <b>Set</b> interface and <b>HashSet</b> class\r\n  to solve this problem.\r\nNote that <b>i</b> is incremented only if a new value is successfully\r\n  added to the set.\r\n<b><pre>  System.out.println(\"Enter \"+n+\" different Strings\");\r\n  Set unique = new HashSet();\r\n  for (int i=1; i&lt;=n; ) {\r\n    String attempt = Prompt.forString(\"Enter unique value #\"+i);\r\n    if (!unique.contains(attempt)) {\r\n      unique.add(attempt);\r\n      i++;\r\n    }\r\n  }</pre></b>\r\nActually, this code can be simplified if you carefully read the real\r\n  Javadoc (not just the summary listed in this lecture) for the <b>HashSet</b>\r\n  class.\r\nThe <b>add</b> method adds the value to the set only if it is not there\r\n  (generally, sets don't contain duplicates) and returns whether it\r\n  added it.\r\n<b><pre>  System.out.println(\"Enter \"+n+\" different Strings\");\r\n  Set unique = new HashSet();\r\n  for (int i=1; i&lt;=n; ) {\r\n    String attempt = Prompt.forString(\"Enter unique value #\"+i);\r\n    if (unique.add(attempt))\r\n      i++;\r\n  }</pre></b>\r\nGenerally, we use the name of the interface (<b>Set</b>) for the type\r\n  of the variable (<b>unique</b>), not the name of the actual class\r\n  we are using for its implementation (<b>HashSet</b>).\r\nBut we must use this name when constructing an object.\r\n<p>\r\nTechnically, the most elegant solution to this problem uses the fact that the\r\n  <b>Set</b> knows its size, so we don't need the counter <b>i</b> at all.\r\n<b><pre>  System.out.println(\"Enter \"+n+\" different Strings\");\r\n  Set unique = new HashSet();\r\n  while (unique.size()&lt;n)\r\n    unique.add( Prompt.forString(\"Enter unique value #\"+ (unique.size()+1)) );</pre></b>\r\nNotice here that we must write <b>( unique.size()+1) )</b> in parentheses,\r\n  otherwise Java would treat the <b>+</b> operator as catenation instead of\r\n  addition.\r\n</table>\r\n\r\n\r\n\r\n<!-- Iterators -->\r\n\r\n<a name=\"Iterators\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Iterators (and inner classes)</b></td>\r\n<td width =\"80%\">\r\nThe <b>Iterator</b> interface (declared in the <b>java.util</b> package) is\r\n  used heavily with collection classes (both to implement the collection\r\n  classes and by users of the collection classes), but it it also useful in\r\n  other contexts.\r\nIterators allow us to process, one at at time, a sequence of values\r\n  (which we are said to iterate over), either stored in some collection or\r\n  generated on the fly, as necessary.\r\nBefore we begin to study using iterators with collection classes, we will first\r\n   study them independently (and a bit later in simplified collection classes).\r\nThe <b>Iterator</b> interface is very simple (as a heuristic, the simpler the\r\n  interface, the more useful it is): it comprises jut three methods.\r\n<b><pre>  public interface Iterator {\r\n    public boolean hasNext();\r\n    public Object  next   ();\r\n      throws NoSuchElementException\r\n    public void    remove ();\r\n      throws UnsupportedOperationException, IllegalStateException\r\n  }</pre></b>\r\nThe first two methods are the most interesting and useful; the third method\r\n  does not have to be implemented to do anything but throw\r\n  the <b>UnsupportedOperationException</b>.\r\nThe standard code fragment using the first two methods looks like\r\n<b><pre>  for (Iterator i = <i>an-iterator-object</i>; i.hasNext(); ) {\r\n    Object o = i.next();\r\n    ...process o...\r\n  }</b></pre>\r\nSo, the <b>hasNext</b> and <b>next</b> methods work together to query whether\r\n  the loop should continue, and if so, access and process the next value in\r\n  the collection.\r\nSometimes the next object retrieved will be cast immediately and stored in\r\n  a non-<b>Object</b> variable.\r\n<p>\r\nBecause <b>next</b> can throw an exception, we can also write the following\r\n  loop to iterate over a sequence of values, which is equivalent to the first\r\n<b><pre>  for (Iterator i = <i>an-iterator-object</i>; ; ) \r\n    try {\r\n      Object o = i.next();\r\n      ...process o...\r\n    } catch (NoSuchElementException nsee){break;}\r\n  }</pre></b>\r\nMost programmers prefer the non <b>try-catch</b> code, deeming it simpler.\r\nIn many ways, we use iterators much like we use objects from the\r\n  <b>StringTokenizer</b> class; this method has <b>hasNext</b> and\r\n  <b>nextToken</b> methods, although it DOES NOT implement this interface.\r\n<p>\r\nThe <b>Squares</b> class illustrates how to write a simple class that\r\n  implements this interface; it contains only a constructor and the methods\r\n  required to implement the <b>Iterator</b> interface.\r\n<b><pre>  public class Squares implements Iterator {\r\n\r\n    private int current;\r\n    private int leftToGenerate;\r\n\r\n    public Squares(int numberToGenerate)\r\n    {this(0,numberToGenerate-1);}\r\n\r\n    public Squares(int start, int stop)\r\n    {\r\n      current        = start;\r\n      leftToGenerate = stop-start+1;\r\n    }\r\n\r\n    public boolean hasNext()\r\n    {return leftToGenerate != 0;}\r\n\r\n    public Object next ()\r\n      throws NoSuchElementException\r\n    {\r\n      if (!hasNext())\r\n        throw NoSuchElementException(\"Squares: next\");\r\n      leftToGenerate--;\r\n      Integer answer = new Integer(current*current);\r\n      current++;\r\n      return answer;\r\n    }\r\n\r\n    public void remove ()\r\n      throws UnsupportedOperationException, IllegalStateException\r\n    {throw UnsupportedOperationException(\"Squares: remove\");}\r\n  }</pre></b>\r\nHand simulate the following code to ensure that it prints the squares\r\n  of the first 10 integers (starting with 0): 0, 1, 4, 9, ... , 81.\r\n<b><pre>  for (Iterator i = new Squares(10); i.hasNext(); )\r\n    System.out.println(i.next());</pre></b>\r\nNote that because all we are doing to each value is printing it, we\r\n  do not store it in an <b>Object</b> variable, and the\r\n  <b>System.out.println</b> automatically calls the <b>toString</b> method\r\n  on the object returned.\r\nTo print the sequence 25, 36, ... , 100 we would instead write\r\n  <b>new Squares(5,10)</b> in the initialization part of the <b>for</b> loop.\r\n<p>\r\n<!---\r\nIn fact, Java 1.5 allows a new, simpler to use form of the <b>for</b> loop,\r\n  usable with any objects constructed from classes that implement\r\n  <b>Iterator</b>.\r\nWe could write the previous code as just\r\n<b><pre>  for (Integer x : new Squares(10))\r\n    System.out.println(x);</pre></b>\r\nHere, Java takes care of creating the iterator, and applying to it all the\r\n  calls to <b>hasNext</b> and <b>next</b> (including a cast); it\r\n  translates this code to the equivalent (but more verbose).\r\n<b><pre>  for (Iterator i = new Squares(10); i.hasNext(); ) {\r\n    Integer x = (Integer)i.next();\r\n    System.out.println(x);\r\n  }</pre></b>\r\nNotice the use of the colon separator; the \"right\" thing to do is to make\r\n  a new keyword <b>in</b> (as C# does), but that might break lots of programs\r\n  that use that identifier for a variable name: using a separator is safer.\r\n-->\r\n</tbody>\r\n</table>\r\n<a name=\"Inner\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Inner Classes to Implement Iterators in Collection Classes</b></td>\r\n<td width =\"80%\">\r\nNow lets start learning about how iterators are implemented in collection\r\n  classes.\r\nBut, instead of starting with \"real\" collection classes (involving interfaces\r\n  and abstract classes), we will write an iterator in a simpler context: the\r\n  <b>SimpleQueue</b> class that we studied in the lecture on \r\n  <a href=\"../arrays1d/lecture.html#Queue\">1-d Arrays</a>.\r\nPlease find and review this code now; pay close attention to the\r\n  class invariant that <b>rear</b> refers to the largest member index\r\n  that stores a value.\r\n<p>\r\nTo illustrate iterators, we will add a method to this class with the prototype\r\n  <b>public Iterator iterator()</b>: it returns a reference to an object from\r\n  some class that implements <b>Iterator</b> (over the sequence of values that\r\n  this collection stores).\r\nIt is simple to use the result returned by this class with the idiom shown\r\n  above; to print all the values in the queue (without changing their\r\n  order in the queue) we would write just\r\n<b><pre>  SimpleQueue sq = new SimpleQueue();\r\n  ...put some values in the queue...\r\n  for (Iterator i = sq.iterator(); i.hasNext(); )\r\n    System.out.println(i.next());</pre></b>\r\nGenerally, iterators in collection classes allow us to process each value in\r\n  the collection (say to print each) without altering the contents of the\r\n  collection (in the case of a queue, all the elements remain in the queue in\r\n  their original order); in addition, the <b>remove</b> method allows us to\r\n  alter the collection by removing the value which the most recent call to\r\n  <b>next</b> returned; it throws <b>IllegalStateException</b> if\r\n  <b>next</b> has not been called OR if its value has already been removed.\r\nThis method can also just throw <b>UnsupportedOperationException</b> if\r\n  it is not meaningful (or just not implemented).\r\n<p>\r\nIn this context, it is useful to discuss the concept of an <b>inner class</b>.\r\nSometimes -as with iterators- it is useful to declare a <b>private</b> class\r\n  INSIDE another (<b>public</b>) class.\r\nBy doing so, Java allows some interesting behaviors to emerge.\r\n<ol>\r\n<li>Only the methods in the outer class can construct objects from\r\n     the inner class; in fact, only non-<b>static</b> methods can do so\r\n     (or the Java compiler will detect and report an error).\r\n<p>\r\n<li>When a method in the outer class constructs an object from its inner\r\n      class, the inner class object can refer to all the instance variables\r\n      by name (even <b>private</b> ones) in the outer class object that it was\r\n      constructed in.\r\n</ol>\r\nThe scope rules for classes (outer and inner) are just like the scope rules\r\n  for blocks (inner and outer): an inner block can freely refer to variables\r\n  define in the outer block enclosing it.\r\nThink of the inner class object storing a reference to the outer class\r\n  object, which by the restriction in rule 1, always must exist.\r\nIn fact, we can explicitly refer to this outer object by\r\n  writing <b><i>Outer-Class-Name</i>.this</b>, and its instance variable\r\n  <b><i>p</i></b> by <b><i>Outer-Class-Name</i>.this.<i>p</i></b> -either\r\n  to be explicit, or in case there is a name conflict between the instance\r\n  variable <b><i>p</i></b> and some other variable.\r\n<p>\r\nSo, how can we extend the <b>SimpleQueue</b> to allow iterators?\r\nFirst, we must define  the <b>iterator</b> method in that class as\r\n<b><pre>  public Iterator iterator()\r\n  {return new SimpleQueueIterator();}</pre></b>\r\nwhere <b>SimpleQueueIterator</b> is an inner class defined in \r\n  <b>SimpleQueue</b>.\r\nWe must also import the following classes for this definition and\r\n  the ones below to make sense to Java\r\n<b><pre>  import java.util.Iterator;\r\n  import java.util.NoSuchElementException;</pre></b>\r\n(the <b>UnsupportedOperationException</b> is in the <b>java.lang</b>\r\n  package, and doesn't need to be imported).\r\nThe simplest version of this inner class is\r\n<b><pre>\r\n  private class SimpleQueueIterator implements Iterator {\r\n     private int next = 0;\r\n     \r\n    public boolean hasNext()\r\n    {return next <= rear;}\r\n\r\n    public Object next ()\r\n      throws NoSuchElementException\r\n    {\r\n      if (!hasNext())\r\n        throw new NoSuchElementException\r\n          (\"SimpleQueueIterator: next\");\r\n\r\n      return q[next++];\r\n    }\r\n    \r\n    public void remove ()\r\n      throws UnsupportedOperationException, IllegalStateException\r\n    {throw new UnsupportedOperationException\r\n       (\"SimpleQueueIterator: remove\");\r\n    }\r\n  }</pre></b>\r\nHere, each new <b>SimpleQueueIterator</b> object intializes <b>next</b> to\r\n  <b>0</b>: it refers to the index of the next value in the queue that the\r\n  <b>next</b> method returns.\r\nBoth the <b>hasNext</b> and <b>next</b> methods can access the\r\n  <b>SimpleQueue</b> instance  variables <b>q</b> and <b>rear</b>,\r\n  either directly by these names or by <b>SimpleQueue.this.q</b> and\r\n  <b>SimpleQueue.this.rear</b>.\r\nSo long as <b>next</b> is not beyond <b>rear</b>, the last member index that\r\n  stores a value, there is another value to iterate over.\r\nThe <b>next</b> method returns the value in that location, and increments\r\n  <b>next</b> for (possibly) another call to this method.\r\nThe following picture illustrates both a <b>SimpleQueue</b> object, and a\r\n  <b>SimpleQueueIterator</b> object that is ready to iterate over it.\r\n</table>\r\n<p>\r\n<img src=\"images/simplequeueiterator.gif\"></image>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nIf we wanted to implement the <b>remove</b> method, we would have to declare\r\n  an additional <b>removedAlready</b> instance variable and rewrite the\r\n  methods as follows.\r\n<b><pre>  private class SimpleQueueIterator implements Iterator {\r\n  \r\n    private int     next           = 0;\r\n    private boolean removedAlready = true;\r\n     \r\n    public boolean hasNext()\r\n    {return next <= rear;}\r\n\r\n    public Object next ()\r\n      throws NoSuchElementException\r\n    {\r\n      if (!hasNext())\r\n        throw new NoSuchElementException\r\n          (\"SimpleQueueIterator: next - no next value\");\r\n        \r\n      removedAlready = false;\r\n      return q[next++];\r\n    }\r\n    \r\n    public void remove ()\r\n      throws UnsupportedOperationException,\r\n             IllegalStateException\r\n    {\r\n      if (removedAlready)\r\n        throw new IllegalStateException\r\n          (\"SimpleQueueIterator: remove - cannot remove\");\r\n\r\n      //Backup next: the value at that index will be removed.\r\n      //Shift everything beyond to the left by 1, and decrement\r\n      //  rear too (since removing a value shrinks the queue).\r\n      removedAlready = true;\r\n      next--;\r\n      for (int i=next; i&lt;rear; i++)\r\n        q[i] = q[i+1];\r\n      q[rear--] = null;\r\n    }\r\n  }</pre></b>\r\nThe differences are that <b>next</b> resets <b>removedAlready</b> to\r\n  <b>false</b> when it successfully advances to return another value, and\r\n  <b>remove</b> checks this value.\r\nIf <b>remove</b> does remove a value, it must shift the values following it to\r\n  the left by 1 index, just like the <b>dequeue</b> method: in fact, a\r\n  generalized helper method\r\n  <b><pre>  private void shiftLeftFrom (int shiftStart)</pre></b>\r\nwould be useful to simplify both methods.\r\nFinally, <b>removedAlready</b> is initialized to <b>true</b>, because we\r\n  cannot call <b>remove</b> until <b>next</b> has been called; this\r\n  initialization ensures this requirement.\r\n<p>\r\nWe can use the <b>remove</b> method to remove every odd value in a queue of\r\n <b>Integer</b>s easy.\r\nThe code is\r\n<b><pre>  SimpleQueue sq = new SimpleQueue();\r\n  ...put some values in the queue...\r\n  for (Iterator i = sq.iterator(); i.hasNext(); ) {\r\n    Integer x = (Integer)i.next();\r\n    if (x.intValue()%2 == 1)\r\n      i.remove();\r\n  }</pre></b>\r\nYou can download, unzip, run, and examine all this code (along with\r\n  a driver program) in the\r\n  <a href=\"../../programs/simplequeuewithiteratordemo.zip\">\r\n      SimpleQueue with Iterator Demonstration</a>.\r\nIn fact, this code includes the material described in the next section on\r\n  what happens when a collection is modified concurrently with it being\r\n  iterated over.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Concurrent Modification -->\r\n\r\n<a name=\"Concurrent\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Detecting Concurrent Changes</b></td>\r\n<td width =\"80%\">\r\nThere is still one loose end connecting collection classes and iterators.\r\nIf we are iterating through a collection class, and we modify it (add or\r\n  remove a value), how should this affect the way our iterator works in the\r\n  future, when <b>hasNext</b>/<b>next</b> are called?\r\nIt turns out that there is no uniformly good way to answer to this question\r\n  for all collection classes,  so instead all Java collection classes (with\r\n  iterators) prohibit it from occurring.\r\n<p>\r\nJava prohibits it from occuring by forcing the <b>next</b> method to\r\n  throw the <b>ConcurrentModificationException</b> if any state changes have\r\n  been made to the object it is iterating over: i.e., we are modifying a\r\n  collection class while concurrently iterating over it.\r\nThis is accomplished in a surprisingly simple and efficient way (funny how\r\n  those two properties often go together) by the iterator class.\r\nWhen this approach is used, the iterators are said to be <b>fail-fast</b>\r\n  iterators.\r\n<p>\r\nOn the <b>SimpleQueue</b> side:\r\n<ul>\r\n<li>Each <b>SimpleQueue</b> object stores another instance variable, named\r\n      <b>modCount</b>: it represents the modification count of this queue\r\n      and is initialized to <b>0</b> at construction.\r\n<li>Each mutator method in this class increments this instance variable.\r\n</ul>\r\nOn the <b>SimpleQueueIterator</b> side:\r\n<ul>\r\n<li>Each <b>SimpleQueueIterator</b> object stores another instance variable,\r\n      named <b>expectedModCount</b>: it represents the modification count of\r\n      the queue when THIS ITERATOR WAS CONSTRUCTED, so it is initialized to the\r\n      <b>modCount</b> of its <b>SimpleQueue</b> object at construction.\r\n<p>\r\n<li>Each call to <b>next</b> in this class first compares this stored value\r\n      with the <b>modCount</b> value stored in the queue that it is iterating\r\n      over; if they differ (the queue has been changed), it immediately throws\r\n      <b>ConcurrentModificationException</b>.\r\n</ul>\r\nIn this way, if the expected modification count is not found, we know that\r\n  the collection was modified after the iterator was constructed, so this\r\n  iterator cannot continue to iterate over it.\r\n<p>\r\nFinally, if the <b>remove</b> method in the iterator successfully removes an\r\n  element from the collection, no other iterator should be able to continue.\r\nThis is accomplished by incrementing the <b>modCount</b> of the collection\r\n  first, and then copying this new value into the <b>expectedModCount</b> of\r\n  this iterator.\r\nTherefore, this iterator can continue (because it knows how to ensure that\r\n  it still iterates over all the remaining values in the collection) but any \r\n  other iterator is forced to throw <b>ConcurrentModificationException</b>.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Write a class named <b>Constant</b> that implements <b>Iterator</b>.\r\n    Its constructor should be called with some object, and its <b>next</b>\r\n      method should always return a reference to that same object, with\r\n      <b>hasNext</b> always returning <b>true</b>.\r\n<p>\r\n<li>Write a class named <b>Prime</b> that implements <b>Iterator</b>,\r\n      retuning only prime numbers.\r\n    You may assume that the method <b>public static boolean isPrime(int i)</b>\r\n      is defined in the <b>Math</b> class (it isn't, but assume it).\r\n    Write a few reasonable constructors for this class.\r\n<p>\r\n<li>Write a class named <b>Combine</b> that implements <b>Iterator</b>.\r\n    Its constructor should be called with two objects constructed from a\r\n      class implementing <b>Iterator</b>, and an object constructed from a\r\n      class implementing <b>Combine2</b>.\r\n<b><pre>  public interface Combine2 {\r\n    public Object combine2(Object o1, Object o2);\r\n  }</pre></b>\r\n  The <b>hasNext</b> method returns <b>true</b> when both of the iterators\r\n    it stores have a next value; its <b>next</b> method combines the next\r\n   values from each of the iterators it stores.\r\n<p>\r\n<li>What are the implications of defining the <b>iterator</b> method\r\n     in <b>SimpleQueue</b> to be <b>static</b>.\r\n<p>\r\n<li>Write an inner class implementing iterators of <b>SimpleStack</b>.\r\n<p>\r\n<li>Devise a scheme whereby each mutator method in the <b>SimpleQueue</b>\r\n      class detects if there is an iterator iterating over the object it is\r\n      about to change, and throws the <b>ConcurrentModificationException</b>.\r\n    Compare the efficiency of these two approaches to reportng this problem.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n\r\n", "encoding": "ascii"}