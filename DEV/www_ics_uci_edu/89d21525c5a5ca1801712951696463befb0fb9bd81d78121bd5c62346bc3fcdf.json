{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/abstractclasses/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Abstract Classes</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Abstract Classes</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will continue our discussion of inheritance features by \r\n    examing <b>abstract</b> classes.\r\n  Once again, in many ways abstract classes are a simple concept (involving\r\n    only one new keyword that can be used in two places) that has deep\r\n    ramifications when designing complex class hierarchies.\r\n  We will discuss this Java language feature in the context of the\r\n    <a href=\"../../programs/positionalshapedemo.zip\">\r\n      Positional Shape Inheritance Demo</a>, which you should\r\n      download, run, and examine.\r\n  In this lecture we will compare abstract classes to interfaces (which seem\r\n    closely related: for example we can extend interfaces via inheritance too)\r\n    and see multiple ways to accomplish approximate the same result -and \r\n    compare them.\r\n  Finally, we will examine some general principles for designing classes in\r\n    inheritance hierarchies..\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Definition -->\r\n\r\n<a name=\"Definition\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Defining Abstract Methods and Classes</b></td>\r\n<td width =\"80%\">\r\n  Sometimes a class should define a method that logically belongs in the class,\r\n    but that class cannot specify how to implement the method.\r\n  For example, the <b>Shape</b> class is used as a superclass for 2-dimensional\r\n    shapes (like circles, rectangles, etc).\r\n  Logically, every shape should have a <b>getArea</b> method, because every\r\n    shape has an area.\r\n  But, every shape would compute its area using a different formula, and there\r\n    is no way to specify one <b>getArea</b> method in the <b>Shape</b> class\r\n    that is correct for all its possible subclasses.\r\n  <p>\r\n  In an application, we might want to declare a <b>Shape</b> array, fill it\r\n    with references to objects constructed from actual shapes (subclasses of\r\n    <b>Shape</b>), and then ask each shape to return its area.\r\n  We would like Java to call the correct <b>getShape</b> method for each object\r\n    to compute the result correctly; again, this illustrate how Java implements\r\n    polymorphism to solve such a problem.\r\n  <p>\r\n  We accomplish this in Java by defining the <b>getArea</b> method in the\r\n    <b>Shape</b> class, but by specfying the <b>abstract</b> keyword in its \r\n    list of access modifiers (as a syntax constraint this keyword can be used\r\n    when defining only classes and methods) and then specifying no\r\n    implementation (no method body, just like in an interface).\r\n  We would specify it in the <b>Shape</b> class as follows\r\n  <pre><b>  public abstract double getArea();</b></pre>\r\n  By defining this method, we are telling the Java  compiler that it should\r\n    allows us to call the <b>getArea</b> method using any variable declared\r\n    with the type <b>Shape</b>, or declared with any class that is a subclass\r\n    of <b>Shape</b> (where the definition of <b>getArea</b> will really\r\n    appear).\r\n  For example, we can define the <b>toString</b> method in the <b>Shape</b>\r\n    class as\r\n\r\n  <pre><b>  public String toString( )\r\n  {return \"Shape[id=\"+id+\",area=\"+getArea()+\"]\";}</b></pre>\r\n\r\n  This method calls <b>getArea</b> and returns (as a <b>String</b>) the area of\r\n    the shape.\r\n  Our first big rule about using <b>abstract</b> concerns where abstract\r\n    methods can be called.\r\n  <ol>\r\n    <li>Any method in a class can be declared <b>abstract</b>.\r\n        Such a method has no body (<b>{...}</b> is replaced by just <b>;</b>,\r\n          as in interfaces) and can be called in other methods defined in that\r\n          class, or be called in methods defined in any of its subclasses, or\r\n          be called using any variables whose type is this class or any of its\r\n          subclasses.  \r\n  </ol>\r\n  <p>\r\n  Our second big rule about using <b>abstract</b> concerns the relationship\r\n    between abstract method and the classes in which the are defined.\r\n  <ol start=\"2\">\r\n    <li>\r\n      If a class defines any abstract methods (or, as we will see, inherits\r\n        any abstract methods and doesn't override them), that class must be\r\n        defined using the <b>abstract</b> keyword in its access modifiers.\r\n  </ol>\r\n  If this second rule is violated, the Java compiler will detect and report an\r\n    error, so if we forget to make a class abstract, Java will just remind us\r\n    with no harm caused..\r\n  <p>\r\n  In fact, we will define the <b>Shape</b> class (using an <b>id</b> instance\r\n    variable and constructor) throughout the examples in this lecture as\r\n  <pre><b>  public abstract class Shape {\r\n\r\n    public Shape (String id)\r\n    {this.id = id;}\r\n\r\n    //This abstract method must be defined in a concrete subclass.\r\n    //Note that it is called in this class in the toString method.\r\n    public abstract double getArea();\r\n\r\n    public String getId()\r\n    {return id;}\r\n    \r\n    public String toString( )\r\n    {return \"Shape[id=\"+id+\",area=\"+getArea()+\"]\";}\r\n\r\n    private String id;\r\n  }</b></pre>\r\n  Generally, abstract classes can specify all the standard class components:\r\n    constructors, methods, and instance variables.\r\n  Again, a class must be defined with the keyword <b>abstract</b> (as is the\r\n    case above) if any of its methods is defined with the keyword\r\n    <b>abstract</b> (as is the case above).\r\n  Note that we can call the <b>abstract</b> method in other methods defined in\r\n    the class, even if its body isn't defined yet.\r\n  <p>\r\n  Again, logically this method belongs in the class, even if it cannot\r\n    be written there (because <b>Shape</b> is too high in the hierarchy).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Use -->\r\n\r\n<a name=\"Use\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Using Abstract Classes (as Superclasses)</b></td>\r\n<td width =\"80%\">\r\n  Now, it should be  obvious that it would make no sense to write\r\n  <pre><b>  Shape s = new Shape(\"s1\");\r\n  System.out.println(s);</pre></b>\r\n  because although we are allowed to call the <b>getArea</b> method (Java\r\n    knows the prototype of this method), its implementation\r\n    HAS NOT BEEN SPECIFIED.\r\n  Java would have no idea what code to execute to compute <b>getArea</b>\r\n    inside <b>toString</b>.\r\n  <p>\r\n  But the problem is not in the method call, it is in the construction.\r\n  This issue brings us to our third big rule about using <b>abstract</b> for\r\n    classes, concerning the restriction on calling constructors ONLY IN\r\n    SUBCLASSES.\r\n  <ol start =\"3\">\r\n    <li>\r\n    If a class is defined with the keyword <b>abstract</b>, we may call its\r\n      constructor only via <b>super</b> in a class that extends it, not\r\n      via the <b>new</b> operator.\r\n    That is, we cannot explicitly construct an object using an <b>abstract</b>\r\n      class, but we can use it to help construct an object from a subclass.\r\n  </ol>\r\n  Thus the Java compiler would detect and report an error in the statement\r\n    <b>Shape s = new Shape(\"s1\");</b> and never even get to compiling the\r\n    call to the <b>getArea</b> method.\r\n  <p>\r\n  If we cannot construct an object with an abstract class, what can we do with\r\n    one?\r\n  We can definine a subclass that extends it.\r\n  If the subclass overrides every abstract method that it inherits, then that\r\n    subclass is not abstract.\r\n  But, if it inherits any abstract methods and doesn't override them, then the \r\n    subclass also has abstract methods and must itself also be defined\r\n    abstract.\r\n  We call a \"non-abstract\" class concrete, although there is no keyword with\r\n    this name.\r\n  <p>\r\n  For example, we can define a concrete <b>Circle</b> subclass by extending\r\n    <b>Shape</b> as follows\r\n  <pre><b>  public class Circle extends Shape {\r\n\r\n    public Circle (String name, double r)\r\n    { \r\n      super(name);\r\n      radius = r;\r\n    }\r\n    \r\n    //Overide the abstract method declared in shape\r\n    public double getArea()\r\n    {return Math.PI * radius * radius;}\r\n    \r\n    public double getRadius()\r\n    {return radius;}\r\n    \r\n    public void setRadius(double newRadius)\r\n    {radius = newRadius;}\r\n    \r\n    public String toString( )\r\n    {return \"Circle[\"radius=\"+radius+\",\"+super.toString()+\"];}\r\n\r\n    private double radius;\r\n  }</b></pre>\r\n  Here the <b>Circle</b> subclass does override the one abstract method\r\n    that it inherits from <b>Shape</b>; it defines a few new methods, but none\r\n    of them is abstract; so, it is a concrete class -and therefore not defined\r\n    with the <b>abstract</b> keyword.\r\n  Also notice that its constructor must be supplied a radius that is stored in\r\n     an instance variable in this class, and is used to compute the area.\r\n  As we described above, although we cannot constuct a new object from the\r\n    class <b>Shape</b>, we can call the constructor for this class\r\n    <b>inside</b> the constructor for a subclass (as the <b>Circle</b> class\r\n    does with its call of <b>super(name);</b> in its constructor).\r\n  <p>\r\n  Because the <b>Circle</b> class is concrete, we can construct new objects\r\n    from this class.\r\n  So, we can write\r\n\r\n  <pre><b>  Circle c = new Circle(\"c1\",1.0);\r\n  System.out.println(c.toString());  //or just ...(c);</pre></b>\r\n\r\n  Which will print\r\n    <b>Circle[radius=1.0,Shape[id=c1,,area=3.141592653589793]]</b>\r\n  <p>\r\n  In fact, we can even write\r\n  <pre><b>  Shape s = new Circle(\"c1\",1.0);    //Note the type\r\n  System.out.println(s.toString());  //or just ...(s);</pre></b>\r\n  <p>\r\n  which prints exactly the same thing!\r\n  Here is the reasoning.\r\n  Both <b>Shape</b> and <b>Circle</b> define <b>toString</b> methods, Java\r\n    allows us to call <b>toString</b> on such variables.\r\n  In both cases the object to which <b>c</b>/<b>s</b> refer is constructed\r\n    from the <b>Circle</b> class, so it is the method DEFINED IN THIS CLASS\r\n    that is called.\r\n  <p>\r\n  Stop and think hard!\r\n  Many students reason that since <b>s</b> is DEFINED to be of type\r\n    <b>Shape</b> then calling <b>s.toString</b> calls the <b>toString</b>\r\n    method defined in the <b>Shape</b> class.\r\n  THIS IS INCORRECT THINKING!\r\n  Recall that Java's rule say that the TYPE determines WHAT methods can be\r\n    called, but the CLASS OF THE OBJECT determines WHICH method is called!\r\n  This is polymorphism in action.\r\n  <p>\r\n  Of course, if we wrote <b>Shape s = new Circle(\"c1\",1.0);</b> then we\r\n    COULD NOT call <b>s.setRadius(2.0);</b> because the type <b>Shape</b>\r\n    defines no <b>setRadius</b> method.\r\n  But if we wrote <b>Circle c = new Circle(\"c1\",1.0);</b> then we\r\n    COULD call <b>c.setRadius(2.0);</b> because the type <b>Circle</b>\r\n    does define this method.\r\n  <p>\r\n  Finally we learn our fourth, and last, big rule about using <b>abstract</b>.\r\n  <ol start=\"4\">\r\n    <li>\r\n     We can treat an abstract class as a superclass and extend it; its\r\n       subclasses can override some or all of its inherited abstract methods.\r\n     If through this overriding a subclass contains no more abstract methods,\r\n       that class is concrete (and we can construct objects directly from it).\r\n     If it still abstract, it too can be used as a superclass ... (until\r\n       eventually a subclass of a subclass ... is concrete).\r\n  </ol>\r\n  <p>\r\n  We can also easily define a simlar subclass for rectangles.\r\n  <pre><b>  public class Rectangle extends Shape {\r\n    public Rectangle (String name, double w, double h)\r\n    { \r\n      super(name);\r\n      width  = w;\r\n      height = h;\r\n    }\r\n    \r\n    //Overide the abstract method declared in Shape\r\n    public double getArea()\r\n    {return width*height;}\r\n    \r\n    public double getWidth()\r\n    {return width;}\r\n    \r\n    public double getHeight()\r\n    {return height;}\r\n    \r\n    public void setWidthHeight(double newWidth, double newHeight)\r\n    {\r\n      width  = newWidth;\r\n      height = newHeight;\r\n    }\r\n    \r\n    public String toString( )\r\n    {return \"Rectangle[\"width=\"+width+\",height=\"+height+\",+super.toString()+\"];}\r\n\r\n    private double width, height;\r\n  }</b></pre>\r\n  Because the <b>Rectangle</b> class is also concrete, we can construct new\r\n    objects from this class too.\r\n  We can write, for example\r\n  <pre><b>  Shape s = new Rectangle(\"r1\",2.0,3.0); //Note the type\r\n  System.out.println(s);</pre></b>\r\n  Which will print\r\n    <b>Rectangle[width=2.0,height=3.0,Shape[id=r1,area=6.0]]</b>\r\n  <p>\r\n  We can picture such an object using our standard notation.\r\n</table>\r\n   <img src=\"images/rectangle.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  <p>\r\n  Of course, it is very simple to add more shapes (square, triangle, etc.)\r\n    to this hierarchy by extending the <b>Shape</b> class.\r\n  Neither the <b>Shape</b> class, nor <b>Circle</b> and <b>Rectangle</b>\r\n    need to know any information about such newly added shapes.\r\n  <p>\r\n  Now, lets look at a more complicated example: writing parts of a model\r\n    class that uses arrays, abstract classes interfaces.\r\n  Suppose that we wanted to store an array of ten object that were each\r\n    constructed from subclasses of <b>Shape</b>.\r\n  We could declare <b>Shape[] allShapes = new Shape[10];</b> and then\r\n    initialize this array.\r\n  Some member migh index circles and some rectangles.\r\n  <p>\r\n  Now assume that we want to find the two shapes that have the most similar\r\n    area.\r\n  We can do this by first sorting the shapes in this array by their areas\r\n    (smallest to biggest).\r\n  We can call <b>Arrays.sort</b> using the <b>allShapes</b> array and the\r\n     following anonymous class (that implements the correct <b>Comparator</b>).\r\n<b><pre>  Arrays.sort(allShapes,\r\n    new Comparator () {\r\n      public int compare(Object o1, Object o2)\r\n      {\r\n        double areaDiff = ((Shape)o1).getArea() - ((Shape)o2).getArea();\r\n        if (areaDiff < 0)\r\n          return -1;\r\n        else if (areaDiff > 0)\r\n          return +1;\r\n        else return 0;\r\n      }\r\n    });</pre></b>\r\n  Now we can scan the array to find the adjacent shapes that have the most\r\n    similar areas.<br>\r\n<b><pre>  int bestIndex  = -1;\r\n  double minDist = Double.MAX_VALUE;\r\n  for (int i=0; i&lt;allShapes.length-1; i++) {\r\n    double newDist = allShapes[i+1].getArea()-allShapes[i].getArea();\r\n    if (newDist < minDist) {\r\n      bestIndex = i;\r\n      minDist   = newDist;\r\n    }</pre></b>\r\n  Now, the minimum distance is between <b>bestIndex</b> and <b>bestIndex</b>+1.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Faking It -->\r\n\r\n<a name=\"Fakingit\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Doing Without Abstract Methods/Classes</b></td>\r\n<td width =\"80%\">\r\n  We can get close to the effect of declaring <b>abstract</b> methods and\r\n    classes by doing the following.\r\n  <ul>\r\n    <li>Remove the word <b>abstract</b> from each method and class.\r\n    <li>Implement each formerly <b>abstract</b> method by a stub.\r\n         <ul>\r\n           <li> If the method\r\n          is <b>void</b> its body should be just <b>{}</b>; if its method\r\n          returns some primitive value, return <b>0</b>, or <b>0.0</b>, or\r\n          <b>'?'</b>, or <b>false</b>; and if its method returns some\r\n          reference to an object, return <b>null</b>.\r\n           <li> Or, just have each method throw\r\n          <b>UnsupportedOperationException</b>; in either case the method\r\n            does nothing useful.\r\n         </ul>\r\n    <li>Leave unchanged any methods in a subclass that overrides a formerly\r\n          <b>abstract</b> method.\r\n  </ul>\r\n  Any compiling/working classes will still compile/work after these changes.\r\n  They will execute identically.\r\n  But other -not so good- things can also happen.\r\n  <ul>\r\n    <li>We can construct objects from the formerly <b>abstract</b> class; when\r\n          calling their stub methods, bad results are returned.\r\n    <li>We can extend the formerly <b>abstract</b> class, and forget to\r\n          override its stub methods; when calling these methods, the usefuless\r\n          results are also returned.\r\n  </ul>\r\n  In the latter case, which is an easy mistake of omission (or even one of\r\n    misspelling), if we used <b>abstract</b> methods the Java compiler would\r\n    detect and inform us that the subclass must be defined to be abstract\r\n    because an abstract method was not overridden: typically this message\r\n    doesn't really what it says; normally we fix the problem not by defining\r\n    the class to be <b>abstract</b> but by adding/fixing the appropriate\r\n    method(s).\r\n  <p>\r\n  The designers of Java felt that the possiblity of \"messing up\" in this way\r\n    was too big, and introduced the keyword <b>abstract</b> into the language\r\n    for the purposes explained above.\r\n  Its purpose is much like <b>final</b> for variables: we can provide the\r\n    compiler with extra information about our intent; if we do something\r\n    inconsistant with this intent, we receive an error message from the Java\r\n    compiler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- PositionalShape -->\r\n\r\n<a name=\"Positionalshape\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Positional Shape Hierarchy</b></td>\r\n<td width =\"80%\">\r\n  Let's now deal with a more complicated example of a positional shape\r\n    inheritance hierarchy.\r\n  It is illustrated below graphically; the superscript <b>A</b> is used to\r\n    denote classes that are abstract.\r\n  <p>\r\n   <img src=\"images/positionalshape.gif\"></image>\r\n  <p>\r\n  Here the root of the inheritance hierarchy is shown as the concrete\r\n    <b>Object</b> class.\r\n  The <b>Shape</b> subclass, defined exactly as shown above, extends this\r\n    concrete superclass and introduces an abstract method (<b>getArea</b>),\r\n    so it becomes abstract.\r\n  The <b>PositionalShape</b> subclass, extends the abstract <b>Shape</b>\r\n    superclass.\r\n  <p>\r\n  It defines a constructor that initializes one new instance variable, a\r\n    <b>Point</b> (read its Javadoc in the standard Java library) that\r\n    specifies the position of the center of the shape (an x,y coordinate)\r\n    on a 2-dimensional plane.\r\n  This class adds a few new methods that manipulate the position, and adds one\r\n    additional abstract method that returns the <b>bounding box</b> of the\r\n     shape\r\n    (the smallest <b>Rectangle</b> in which the shape can be enclosed; \r\n    note, this class has the full name <b>java.awt.Rectange</b> and IS NOT\r\n    the <b>Rectangle</b> class that we will define; read its Javadoc in the\r\n    standard Java library).\r\n  Finally, it adds one additional method that detects whether two shapes\r\n    \"may overlap\" by checking for intersection in their bounding boxes: if\r\n    the bounding boxes don't intersect, there is no possibility of an overlap.\r\n  <p>\r\n  So, this class must be abstract because it contains two abstract methods:\r\n    it specifies <b>getBoundingBox</b> and also inherits (and doesn't override)\r\n    <b>getArea</b>.\r\n  Here is a complete the class.\r\n<b><pre>  public abstract class PositionalShape extends Shape {\r\n\r\n    public PositionalShape (String id, int centerX, int centerY)\r\n    { \r\n      super(id);\r\n      center = new Point(centerX,centerY);\r\n    }\r\n    \r\n    //These abstract methods must be defined in a concrete subclass.\r\n    public abstract Rectangle getBoundingBox();\r\n\r\n    public Point getCenter ()\r\n    {return center;}\r\n\r\n    public double distanceTo (PositionalShape other)\r\n    {return center.distance(other.center);}\r\n\r\n    public void moveCenterTo (Point newCenter)\r\n    {\r\n      center.x = newCenter.x;\r\n      center.y = newCenter.y;\r\n    }\r\n\r\n    public void moveCenterBy (int dx, int dy)\r\n    {\r\n      center.x += dx;\r\n      center.y += dy;\r\n    }\r\n\r\n    public boolean mayOverlap (PositionalShape other)\r\n    {return getBoundingBox().intersects(other.getBoundingBox());}\r\n    \r\n    public String toString ()\r\n    {return \"PositionalShape[center=\"+center+\",\"+super.toString()+\"]\";}\r\n\r\n    //Fields\r\n    private Point center;\r\n  }</pre></b>\r\n<p>\r\nNotice that although this class does not know how bounding boxes are\r\n  constructed from <b>PositionalShape</b>  objects (that method is abstract),\r\n  it defines a concrete <b>mayOverlap</b> method because it knows that the\r\n  <b>getBoundingBox</b> method in any concrete subclass of\r\n  <b>PositionalShape</b> is defined concretely.\r\nThus, just as the concrete <b>toString</b> method in the <b>Shape</b> class\r\n  called the abstract method <b>getArea</b>, the concrete <b>mayOverlap</b>\r\n  method in the <b>PositionalShape</b> class calls the abstract method\r\n  <b>getBoundingBox</b>.\r\n<p>\r\nFinally, we can define the <b>Circle</b> subclass as follows.\r\nNote that it is concrete: it extends the abstract <b>PositionalShape</b>\r\n  class, and overrides both the <b>getArea</b> and <b>getBoundingBox</b>\r\n  methods.\r\n<b><pre>  public class Circle extends PositionalShape {\r\n\r\n    public Circle (String name, int centerX, int centerY, double r)\r\n    { \r\n      super(name,centerX,centerY);\r\n      radius = r;\r\n    }\r\n    \r\n    //Overide the abstract method declared in Shape\r\n    public double getArea()\r\n    {return Math.PI * radius * radius;}\r\n\r\n    //Overide the abstract method declared in PositionalShapee\r\n    public Rectangle getBoundingBox()\r\n    {\r\n      return new Rectangle( (int)(getCenter().x-radius),\r\n                            (int)(getCenter().y-radius),\r\n                            (int)(2*radius),\r\n                            (int)(2*radius) );\r\n    }\r\n    \r\n    public double getRadius()\r\n    {return radius;}\r\n  \r\n    public void setRadius(double newRadius)\r\n    {radius = newRadius;}\r\n\r\n    public String toString( )\r\n    {return \"Circle[radius=\"+radius+\",\"+super.toString()+\"]\";}\r\n\r\n    //Fields\r\n    private double radius;\r\n  }</pre></b>\r\n  The bounding boxes are specified by the coordinate of the shapes upper-left\r\n   corner and its width and height.\r\n  For a circel, here is a picture of its bounding box.\r\n  <p>\r\n</table>\r\n   <img src=\"images/boundingbox.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\n  Again, bounding boxes can detect whether two shapes \"may overlap\" by\r\n    checking for an intersection: if the bounding boxes don't intersect,\r\n    there is no possibility of an overlap; if they do intersect, the shapes\r\n    must be examined more closely.\r\n  This property is illustrated below.\r\n<p>\r\n</table>\r\n   <img src=\"images/overlap.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nGiven all this intheritance, we can picture the result of calling\r\n  <b>new Circle(\"c1\", 100, 150, 1.0);</b>\r\n  by the following picture.\r\n<p>\r\n</table>\r\n   <img src=\"images/circleobject.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nIf you have not already done so, download\r\n  <a href=\"../../programs/positionalshapedemo.zip\">\r\n  Positional Shape Inheritance Demonstration</a> and run this driver\r\n  program.\r\nIt contains all the code above, as well as the defintion of the\r\n  <b>Rectangle</b> class.\r\nNotice in the <b>Rectangle</b> class how we differentiate between the\r\n  <b>Rectangle</b> class we are defining and the <b>java.awt.Rectangle</b>\r\n  class that we are using to help define it: no import, full class name\r\n  (prefixed by its package name).\r\n<p>\r\nFinally, notice that the <b>Shape</b> class defines a concrete\r\n  <b>PromptForInformation</b> method, which is overridden (and called via\r\n  <b>super</b>) in the <b>PositionalShape</b> class, which is again overridden\r\n  (and called via <b>super</b>) in the <b>Circle</b> and <b>Rectangle</b>\r\n  class (a lot like how <b>toString</b> is overridden/called in these same\r\n  classes).\r\nThe result is that there is no checking <b>instanceof</b> or casting in the\r\n  application.\r\nThis absence is always desired.\r\nIt ensures that if we add other subclasses of <b>PositionalShape</b> they\r\n  will all work with this application; we must change only <b>get</b> in\r\n  the application to allow it to return other subclasses.\r\n<p>\r\nIf you are writing <b>instanceof</b>, you are probably not defining your\r\n  classes correctly, making appropriate use of polymorphism.\r\nFor example, if you need to know whether a an object is drawn with only\r\n  straight lines (a square, rectangle, polygon; not a circle or elipse),\r\n  don't use <b>instanceof</b> to pick out the right classes.\r\nInstead define <b>public abstract boolean drawnWithLines()</b> inside the\r\n  <b>Shape</b> class and then override this method in each subclass.\r\n<p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Inheritance and Interfaces -->\r\n\r\n<a name=\"Interfaces\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Inheritance and Interfaces</b></td>\r\n<td width =\"80%\">\r\nThere is another interesting way to design the <b>Circle</b> and\r\n  <b>Rectangle</b> classes through the use of inheritance of interfaces,\r\n  combined with inheritance of classes/abstract classes.\r\nTo do so, we must first learn that we can use the keyword <b>extends</b> to\r\n  specify that one interface extends another.\r\nIn fact, UNLIKE CLASSES, an interface can extend multiple interfaces\r\n  (much like the way that a class can implement multiple interfaces; recall\r\n  that a class can extend only one other class).\r\nThe use of subinterfaces and superinterfaces will appear immediately below,\r\n  including the specification of a subinterface that extend multiple\r\n  superinterfaces.\r\n<p>\r\nWe will start by specifying two interfaces separately, <b>Shape</b> and\r\n  <b>Position</b>, and then one interface that has the properties of\r\n  both: <b>PositionShape</b>.\r\nNotice that these interfaces include all the abstract and concrete\r\n  methods defined in the <b>Shape</b> and <b>PositionalShape</b> CLASSES\r\n  above (except <b>toString</b>, which is not needed, because every\r\n  class -whether or not it implements these interfaces- inherits a\r\n  <b>toString</b> method that it can override).\r\n  <pre><b>  public interface Shape {\r\n    public double getArea();\r\n    public String getId();\r\n  }\r\n\r\n  public interface Position {\r\n    public Point     getCenter    ();\r\n    public double    distanceTo   (Position other);\r\n    public void      moveCenterTo (Point newCenter);\r\n    public void      moveCenterBy (int dx, int dy);\r\n  }\r\n\r\n  public interface PositionalShape extends Position,Shape {\r\n    public Rectangle getBoundingBox();\r\n    public boolean   mayOverlap    (PositionalShape other);\r\n  }</pre></b>\r\nHere, the <b>PositionalShape</b> (sub)interface inherits all the methods\r\n  specified in the <b>Position</b> and <b>Shape</b> (super)interfaces,\r\n  and specifies two new methods.\r\nWhy are these methods new here and not inherited from other interfaces?\r\nIt WOULD NOT make sense to specify <b>getBoundingBox</b> or <b>mayOverlap</b>\r\n  in either individual interface, because the concepts of bounding boxes\r\n  and overlaping shapes don't make sense when applied to just shapes without\r\n  positions or just positions without shapes.\r\nIt makes sense to specify these methods only within interfaces combining\r\n   both shape and position properities.\r\n<p>\r\nIf we declare a variable using the <b>PositionalShape</b> interface,\r\n  Java allows us to use such a variable to call methods from the <b>Shape</b>,\r\n  <b>Position</b> and <b>PositionalShape</b> interfaces.\r\nI guess that we could also call this interfaces <b>ShapelyPosition</b>,\r\n  and this begins to get at the point.\r\nThere is no obvious reason to have <b>Shape</b> as the superclass and then\r\n  extend it to <b>PositionalShape</b>; we could have <b>Position</b> as the\r\n  superclass and then extend it to <b>ShapelyPositional</b>.\r\nIn the original design we needed to make an arbitrary choice: which is the\r\n  subclass and which is the superclass; in this design we avoid making such\r\n  a choice, developing each part on its own can combining them on equal terms.\r\n<p>\r\nOnce we define these interfaces, we can define three \"simple\" classes\r\n  that implement them; the last of these classes it implemented using the\r\n  first two, and will be extended when defining the <b>Circle</b> and\r\n  <b>Rectangle</b> classes.\r\nFirst we define a class that implements the basic part of the\r\n   <b>Shape</b> interface (all but the abstract method).\r\nIt cannot say that it <b>implements Shape</b> because it defines no\r\n  <b>getArea</b> method.\r\n<pre><b>  public class ShapeBasics {\r\n\r\n    public ShapeBasics (String id)\r\n    {this.id = id;}\r\n\r\n    public String getId()\r\n    {return id;}\r\n  \r\n    public String toString( )\r\n    {return \"ShapeBasics[id=\"+id+\"]\";}\r\n\r\n    private String id;\r\n  }</b></pre>\r\nNext we similarly define the <b>PositionBasics</b> class.\r\nIt CAN say that it <b>implements Position</b> because it defines all\r\n  the specified methods (the formerly abstract <b>getBoundingBox</b> method\r\n  is not specified in the <b>Position</b> interface, but in\r\n  <b>PositionalShape</b>).\r\nBecause we can, we do specify <b>implements Position</b>.\r\n  <b><pre>  public class PositionBasics implements Position {\r\n\r\n    public PositionBasics (int centerX, int centerY)\r\n    {center = new Point(centerX,centerY);}\r\n    \r\n    public Point getCenter ()\r\n    {return center;}\r\n\r\n    public double distanceTo (Position other)\r\n    {return center.distance(other.getCenter());}\r\n\r\n    public void moveCenterTo (Point newCenter)\r\n    {\r\n      center.x = newCenter.x;\r\n      center.y = newCenter.y;\r\n    }\r\n\r\n    public void moveCenterBy (int dx, int dy)\r\n    {\r\n      center.x += dx;\r\n      center.y += dy;\r\n    }\r\n\r\n    public String toString ()\r\n    {return \"PositionBasic[center=\"+center+\"]\";}\r\n\r\n    //Fields\r\n    private Point center;\r\n  }</pre></b>\r\nNote one small change in the <b>distanceTo</b> method.\r\nIt now is implemented via\r\n  <b>{return center.distance(other.getCenter());}</b> instead of\r\n  <b>{return center.distance(other.center);}</b> because the <b>Position</b>\r\n  parameter is an interface, and stores no instance variables for this method\r\n  to access.\r\n<p>\r\nFinally, we define an abstract class that implements the basic part of the\r\n   <b>PositionalShape</b> interface.\r\nIt is this abstract class that our concrete <b>Circle</b> and </b>Rectangle</b>\r\n  classes will extend.\r\nThe <b>PositionShapeBasics</b> class constructs objects from the\r\n  <b>ShapeBasics</b> and <b>PositionBasics</b> classes, and uses these\r\n  objects whenever one of their methods is needed.\r\nThis is called <b>delegation</b>: one object uses another to implement a\r\n  method.\r\n<p>\r\nThus, this class defines many methods (all those in the <b>Shape</b>,\r\n  <b>Position</b>, and <b>PositionalShape</b> interfaces), with most being\r\n  concrete.\r\nIt also has the the same two (from the first design) abstract methods:\r\n  <b>getArea</b> and <b>getBoundingBox</b>.\r\nAll the concrete methods are implemented by delegation, with one-line bodies\r\n that delegate the call to the right object.\r\nNote that <b>mayOverap</b> can be defined concretely here, knowing that\r\n  the <b>getBoundingBox</b> method will eventually be defined in a concrete\r\n  subclass.\r\n<b><pre>  public abstract class PositionalShapeBasics implements PositionalShape {\r\n\r\n    public PositionalShapeBasics (String name, int centerX, int centerY)\r\n    { \r\n      s  = new ShapeBasics(name);\r\n      p  = new PositionBasics(centerX,centerY);\r\n    }\r\n  \r\n    //These abstracts method must be defined in a concrete subclass.\r\n    public abstract double    getArea();\r\n    public abstract Rectangle getBoundingBox();\r\n    \r\n    public String getId()\r\n    {return s.getId();}\r\n    \r\n    public double distanceTo(Position other)\r\n    {return p.distanceTo(other);}\r\n    \r\n    public Point getCenter()\r\n    {return p.getCenter();}\r\n    \r\n    public void moveCenterTo(Point newCenter)\r\n    {p.moveCenterTo(newCenter);}\r\n    \r\n    public void moveCenterBy(int dx, int dy)\r\n    {p.moveCenterBy(dx,dy);}\r\n    \r\n    public boolean mayOverlap(PositionalShape other)\r\n    {return getBoundingBox().intersects(other.getBoundingBox());}\r\n    \r\n    public String toString( )\r\n    {return \"PositionalShapeBasics[s=\"+s+\",p=\"+p+\"]\";}\r\n\r\n    //Fields\r\n    private ShapeBasics    s;\r\n    private PositionBasics p;\r\n  }</pre></b>\r\nAny class extending the <b>PositionalShapeBasics</b> class in this design\r\n  can do all the jobs of a class subclassing the <b>PositionalShape</b> class\r\n  in the previous design.\r\nA class like <b>Circle</b> is defined almostly identically: the only \r\n  difference is on the name of the class it extends (and my comments in\r\n  the class).\r\nRecall that by knowing <b>Circle extends PositionalShapeBasics</b> and\r\n  <b>PositionalShapeBasics implements PositionalShape</b> Java deduces\r\n  (and we don't have to write) that <b>Circle implements PositionalShape</b>.\r\n<b><pre>  public class Circle extends PositionalShapeBasics {\r\n\r\n    public Circle (String name, int centerX, int centerY, double r)\r\n    { \r\n      super(name,centerX,centerY);\r\n      radius = r;\r\n    }\r\n    \r\n    //Implement the getArea method,\r\n    //  specified in the Shape interface\r\n    public double getArea()\r\n    {return Math.PI * radius * radius;}\r\n\r\n    //Implement the getBoundingBox method,\r\n    //  specified inthe PositionalShape interface\r\n    public Rectangle getBoundingBox()\r\n    {\r\n      return new Rectangle( (int)(getCenter().x-radius),\r\n                            (int)(getCenter().y-radius),\r\n                            (int)(2*radius),\r\n                            (int)(2*radius) );\r\n    }\r\n    \r\n    public double getRadius()\r\n    {return radius;}\r\n    \r\n    public void setRadius(double newRadius)\r\n    {radius = newRadius;}\r\n\r\n    public String toString( )\r\n    {return \"Circle[radius=\"+radius+\",\"+super.toString()+\"]\";}\r\n\r\n    //Fields\r\n    private double radius;\r\n  }</b></pre>\r\nWith this hierarchy, we would picture a <b>Circle</b> object as follows.\r\nRecall that the <b>PositionalShapeBasics</b> abstract class delegates\r\n  all its methods to the objects referred to by either of its its instance\r\n  variables.\r\n<p>\r\n</table>\r\n   <img src=\"images/circle2object.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\nSo, what are the advantage to each design, given that by the time we\r\n  construct <b>Circle</b> and <b>Rectangle</b> subclasses (and other similar\r\n  ones) we do so identically.\r\nAs stated above, the second design is a bit more symmetrical.\r\nBut the first design is certainly easier to understand (2 abstract classes,\r\n  2 concrete ones; vs. 3 interfaces, 4 concrete classes, and 1 abstract one).\r\nThere is a general design rule that says to prefer delegation to inheritance,\r\n  because you can delegate using many classes but directly inherit from only\r\n  one.\r\nOther interfaces/classes can more easily be constructed to use properties\r\n  of these interfaces/classes, and others like them.\r\nIn fact, the pattern used in the second solution, although more complicated,\r\n  can be used more often to solve other similar (and not so similar) problems.\r\n<p>\r\nI think the bottom line is: GOOD DESIGN IS A HARD.\r\nI DO NOT have a goal for this class that you can design elegant\r\n  inheritance hierarchies.\r\nI DO have a goal that given an inheritance hierarchy, you can quickly read,\r\n  understand, and use it (extend classes it contains).\r\n<p>\r\nYou can download this alternative code in\r\n  <a href=\"../../programs/positionalshapedemo2.zip\">\r\n  Positional Shape Inheritance Demonstration #2</a> and run its driver,\r\n  which is identical to the first one.\r\nIt contains all the code above, as well as the <b>Rectangle</b> class.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- General -->\r\n\r\n<a name=\"General\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>General Comments on Inheritance</b></td>\r\n<td width =\"80%\">\r\nIn the next lecture we will apply inheritance to acheive a more perfect\r\n  understanding of exceptions.\r\nIt will introduce no new material.\r\n<p>\r\nIn this section I'd like to make just a few observations about classes.\r\n<ul>\r\n<li>GOOD DESIGN IS A HARD.\r\nReread the last part of the previous section.\r\nDon't try to fix a poor design by hacking it implementation; fix the design.\r\n<p>\r\n<li>There are two important relationships between classes: we must be\r\n  be able to recognize and understand (and differentiate) them.\r\nThe <b>extends</b> mechanism is also know as the IS-A mechanism.\r\nIt is appropriate to use when the subclass IS-A slightly different (extended)\r\n  class than its superclass.\r\nThe delegation mechanism is known as the HAS-A mechanism.\r\nIt is appropriate to use when an object from one class HAS-A object from \r\n  another class to help it do its work (remember state; implement behavior);\r\n  this second object is stored as an instance variable in the first.\r\n<p>\r\n<li>The Liskov subsitution rule:\r\n<blockquote><i>\r\nIf for each object o1 of type S there is an object o2 of type T such that for\r\n   all programs P defined in terms of T, the behavior of P is unchanged when\r\n   o1 is substituted for o2 then S is a subtype of T.\r\n</i></blockquote>\r\nParaphrased: If S it is a subclass of T, then everything you can do to an\r\n  object from class T should also make sense (and have the same effect)\r\n  for an object from class S.\r\n<p>\r\nAn example that is often dragged out is circles and elipses.\r\nMathematicians want to say a circle is just a special kind of elipse,\r\n  but the <b>setAxes(double x, double y)</b> method on elipses makes no\r\n  sense to apply to a circle (since it has one radius, not a major/minor\r\n  axis).\r\nLikewise an elipse is not just a special kind of circle: the relationship\r\n  between the radius of a circle and its area makes no sense when speaking\r\n  about an elipses.\r\nThis, at a fundamental level, as appealing as it may be, a circle and an\r\n  elipses are not IS-A related.\r\n<p>\r\nOne could, for example, define the <b>Circle</b> and <b>Elipses</b> classes\r\n  separately, and then implement the <b>Circle</b> class by delegating its\r\n  behavior to an <b>Elipse</b> stored as an instance variable, ensuring that\r\n  the major and minor axes are always the same.\r\nThis implementation technique, delegation, is common.\r\n<p>\r\nIt has been asserted that most inheritance problems boil down to a\r\n  variant of the circle/elipses scenario, if you are smart enough to\r\n  spot it.\r\nIf you truly understand this reasoning, you will be able to apply it\r\n  everywhere.\r\nFor example, should <b>SortedList</b> extend <b>List</b>: no, because\r\n  we can perform many operations on a <b>List</b> that make no sense\r\n  for a <b>SortedList</b>: we can call <b>insertFront</b> and <b>insertRear</b>\r\n  on a <b>List</b> and the inserted value becomes the first/last value\r\n  respectively in the <b>List</b>;  but, in a <b>SortedList</b>, we cannot put\r\n  values in these places (when can put values in, but they move to their\r\n  \"naturally sorted\" place).\r\nBut one could, for example, specify the <b>List</b> and <b>SortedList</b> class\r\n  separately, and then implement the <b>SortedList</b> by delegating its\r\n  behavior to a <b>List</b stored as an instance variable, ensuring that\r\n  values are always stored in appropriate indexes.\r\n<p>\r\nSo again, we see delegation (HAS-A relationships) are more common than\r\n  inheritance (IS-A relationships) between classes.\r\n<p>\r\n<li>Generally, \"Classes should be closed for modification but open for\r\n      extension.\"\r\nThis means that once the specification and implementation of a class\r\n  stabilizes, we should never change it; instead we can extend it with\r\n  subclasses that behave similarly but not identically, if we need different\r\n  state and behavior.\r\n</ul>\r\nAgain, relationships among classes in a large system is a quite advanced\r\n  topic.\r\nWe need lots of experience reading classes -noticing their designs and\r\n  learning how to use them effectively- before we can start creating\r\n  complicated designs.\r\n<p>\r\nFinally, <b>final</b> as an access modifier for class and methods in classes.\r\nIf a method in a class is prefaced by the <b>final</b> access modifier, it\r\n   means that it cannot be overridden.\r\nLikewise, if a class is prefaced by the the <b>final</b> access modifier, it\r\n  means that it cannot be extended (thus, none of its methods can be\r\n  overridden).\r\nThe <b>String</b> class is defined to be <b>final</b>.\r\n</ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Abstract Rules Restated -->\r\n\r\n<a name=\"Abstractrules\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Abstract Rules Review</b></td>\r\n<td width =\"80%\">\r\n  To review, here are the four rules for using the <b>abstract</b> keyword,\r\n    collected in one place.\r\n  <ol>\r\n    <li>Any method in a class can be declared <b>abstract</b>.\r\n        Such a method has no body (<b>{...}</b> is replaced by just <b>;</b>,\r\n          as in interfaces) and can be called in other methods defined in that\r\n          class, or be called in methods defined in any of its subclasses, or\r\n          be called using any variables whose type is this class or any of its\r\n          subclasses.  \r\n      <p>\r\n \r\n    <li>\r\n      If a class defines any abstract methods (or, as we will see, inherits\r\n        any abstract methods and doesn't override them), that class must be\r\n        defined using the <b>abstract</b> keyword in its access modifiers.\r\n      <p>\r\n \r\n    <li>\r\n    If a class is defined with the keyword <b>abstract</b>, we may call its\r\n      constructor only via <b>super</b> in a class that extends it, not\r\n      via the <b>new</b> operator.\r\n    That is, we cannot explicitly construct an object using an <b>abstract</b>\r\n      class, but we can use it to help construct an object from a subclass.\r\n    <p> \r\n\r\n    <li>\r\n     We can treat an abstract class as a superclass and extend it; its\r\n       subclasses can override some or all of its inherited abstract methods.\r\n     If through this overriding a subclass contains no more abstract methods,\r\n       that class is concrete (and we can construct objects directly from it).\r\n     If it still abstract, it too can be used as a superclass ... (until\r\n       eventually a subclass of a subclass ... is concrete).\r\n   </ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a TA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>Does Java allow us to declare a class <b>abstract</b> even if it define and\r\n      inherits no <b>abstract</b> methods?\r\n    If so, what do you expect the properties of the class to be?\r\n<p>\r\n<li>Does it make sense to define a <b>final abstract</b> method (use these\r\n      two access modifiers together)?\r\n<p>\r\n<li>Write the <b>ModularCounter</b> class from the previous lecture to\r\n      implement <b>Counter</b> but not by subclassing <b>IntCounter</b>;\r\n      instead, store an <b>IntCounter</b> and delegate all the methods to \r\n      operate on it.\r\n<p>\r\n<li>Explain how a subclass can overload an inherited method (not override it).\r\n<p>\r\n<li>Do you think that an abstract class can say that it implements an\r\n      interface, even if one of the methods in the interface is declared to\r\n      be abstract in the class?\r\n    Explain why your answer is reasonable.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}