{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/14.suffixtree", "content": "This week: non-binary search structures that make use of internal\nstructure of searched objects (strings and integers)\n\n\nHow to represent and look up sets of words?\n\n- binary search tree\n\tO(log n) steps for search, each involving string compare\n\n- hashtable\n\tpretty good for many applications\n\tconstant number of string compares\n\n- trie\n\tnon-binary tree\n\t\tnode = prefix of a dictionary word\n\t\t\tchildren = prefixes with one more character\n\n\t\texample:\n\t\t\tapple\n\t\t\tberry\n\t\t\tbanana\n\n\t\tadd $ at end of each string so word<=>leaf\n\t\t\t\n\tsize = linear in total length of all words\n\n- compressed trie (Patricia trie):\n\tnodes = leaves and branching nodes of trie\n\tedges correspond to multiple characters of input\n\n- suffix tree (suffix trie):\n\ttrie where words = suffixes of a single input word\n\tsize can be quadratic! (aaabbb$)\n\n- compressed suffix tree\n\trepresent edge substring by indices into original string\n\tsize = linear (n leaves => at most 2n-1 edges)\n\n\tanother example: bananas\n\n\nAlgorithms using suffix trees\n\tlist all occurrences of pattern p in t:\n\t(e.g. word or phrase search in large texts)\n\t\tfollow path for p\n\t\tlist all leaves descending from path endpoint\n\t\t\t(e.g. 1d range reporting)\n\n\tfrequency of pattern in t:\n\t\tnumber of leaves descending from path\n\n\tlongest common substring of two strings X,Y:\n\t\tfind suffix tree for X#Y$\n\t\tfind lowest node having both X- and Y-leaf descendant\n\n\tgiven starting positions x,y, find min i s.t. str[x+i]!=str[y+i]:\n\t\tleast common ancestor of leaves for positions x,y\n\n\nRepresentation of suffix tree node\n\tinformation on parent link + pointers to children\n\tfor small alphabet size, table letter->child\n\tfor large alphabet size, hashtable or sorted list\n\n\nConstruction of suffix trees\n\tknown (Weiner, 1973) O(ns) for small alphabet size\n\tfor large alphabet size (e.g. integers 0..k-1, k<n), still linear time\n\t\t[Farach, FOCS 1997]\n\n\tidea:\n\t\t(1) form shorter string by grouping characters into\n\t\t\tpairs of characters\n\t\t\tba, na, na, $\n\t\t(2) mark pairs with their position in string,\n\t\t    radix-sort pairs (bucket sort by 2nd char then 1st):\n\t\t    and renumber them to form equivalent word with\n\t\t    smaller alphabet (numbers 0...k-1, k<new n)\n\t\t\t0,1,1,2\n\t\t(3) recursively construct suffix tree on smaller input\n\t\t(4) expand back out to give tree of even suffixes\n\t\t\t(split pairs of children w/same first char)\n\t\t(5) scan tree to list even suffixes in sorted order\n\t\t(6) prepend previous characters to get list of odd suff's\n\t\t(7) bucket sort odd suffixes by 1st char => completely sorted\n\t\t(8) use LCA in even tree to find length(common prefix)\n\t\t\tbetween adjacent pairs of odd suffixes\n\t\t(9) built tree of odd suffixes by scanning L-R\n\t\t\tusing LCA info to know how far up to go\n\t\t\tfrom previous leaf\n\t\t(10) merge even and odd trees\n\t\t\t(messy, details omitted, linear time)\n\n\ttotal time: T(n)=O(n) (all steps but 3) + T(n/2) (step 3) = O(n)\n", "encoding": "ascii"}