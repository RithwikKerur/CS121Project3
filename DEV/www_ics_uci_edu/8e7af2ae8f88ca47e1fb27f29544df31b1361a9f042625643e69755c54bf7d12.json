{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes991208.txt", "content": "WebDAV Advanced Collections Minutes December 8, 1999\n\nATTENDING: Judy Slein, Chuck Fay, Jim Whitehead, Geoff Clemm, Kevin Wiggen\n\nDISCLAIMER: All decisions made by the design team are subject to review by \nthe WebDAV mailing list.\n\nACTION ITEMS\n\nChuck: Re-send edits to the simple binding example.\nGeoff: Send Judy the latest definition of MKRESOURCE from the DeltaV spec.\nJim: Ask Yaron to review the section on Redirect References to Collections.\n\nLOGISTICS\n\nNext meeting Wednesday December 15, if there are agenda items to make it\nworthwhile.\n\nTHE BINDING SPEC\n\nCOMMENTS\n\nJim liked the changes to the introduction.\n\nChuck liked the simple example that used to be in the abstract.  He would\nlike to see it used someplace.\nAgreed: We'll include it in the terminology section, in the definition\nof Binding, immediately after the introduction of the C: (S -> R) notation\nand before the discussion of URI mappings.  Incorporate Chuck's edits.\n\nATOMICITY\nJason reported no response from the people at Microsoft he asked about\nhow hard it would be for their file systems to support atomic DELETE / MOVE.\nGeoff talked to Chris Kaler thinks maybe it is hard, but doesn't know any\ndetail about why.\nWe need explanation to convince us that atomic DELETE / MOVE are not\nfeasible.\nAgreed: The spec will continue to require atomic DELETE / MOVE for the\ntime being.\n\nUUID URI SCHEME\nYaron's point about this is that we shouldn't proliferate URI schemes that\nbasically do the same thing.\nCan we just use the opaquelocktoken URI scheme?  Can we use it but give it\na different name that's less confusing in our context?  If we change the\nname, it still has to be registered independently with IANA.\ncan we use opaquelocktoken name?\nJim: Using the name \"opaquelocktoken\" will be confusing, since we are using\nit to identify a resource, not a lock.\nAgreed: Call the URI scheme something new. Call it resourceid, then someone else can \ndefine a more carefully thought out generic UUID URI scheme someday.  Don't even\nmention opaquelocktoken, even though the definition is copied from there.\n\nIn the definition of the DAV:resourceid property (as opposed to the URI scheme),\ngive more detail about the semantics:\nCOPY must produce new one, MOVE must maintain the same one\nCross-server MOVE would have to fail if can't do that?  Yes.\nFor cross-server MOVE, source must pass the guid to the destination.  \nProbably the destination server would have distinct internal and external\nidentifiers for the resource, since it might want its own URI scheme for\ninternal use.\n(it's a live property)\nPUT that creates a resource makes a new one, update does not.\nIt's a required property (The reason we introduced it was so that you could\ndetermine whether two URIs are mapped to the same resource.)\n\nCHECKING DESCENDENTS\nJudy: Maybe we should take out the (recently added) language in DELETE / MOVE\nthat says you have to check the lock and acl state of all descendents to\ndetermine whether to allow the DELETE / MOVE of a collection.  We were careful\nto remove all other statements about locking, and let the locking proposal\ndetermine what behavior will be.\nGeoff: Agrees. Let locking define this, don't have statements about locking \nhere.\nChuck:  The language implies protecting the URI of any locked resource \nthat might conflict with the MOVE.  We should just let the general decision\nabout whether to protect URIs determine this, and not say anything here.\nJim: Agrees.\nKevin: Agrees.  It's a given that you need to check locks, acls.  We don't \nneed to say this.\nAgreed.\n\nDEFINITION OF DELETE / HTTP\nWe keep as is, including the statement about the relation of our definition\nto HTTP.\n\nCOPY\nIs this section really needed? Does it say anything beyond what you would\ninfer from reading RFC 2518?\nJudy: At least the last paragraph is needed.  It would be confusing reading\nRFC 2518 together with the binding spec, and trying to figure out whether\nthe bindings get copied with a Depth: 0 copy of a collection.\nGeoff: Thinks it's actually clear from RFC 2518 what you should do, though\nit's the wrong thing to do. \nChuck: The paragraph is needed for clarification.\nJim: It adds to 8.8.3 of RFC 2518 the explicit discuss of the divergence \nbetween RFC 2518 and the data model of the bindings spec.\nJim: We also need 1st paragraph, since it introduces a new abstraction. \nIt's useful if you are just approaching bindings for the first time. \nGeoff: Agrees.  It also makes clear that you have to copy the children\nof a collection, not just create new bindings to existing children.\nKevin: It also makes clear to everybody that we at least thought about\nissues related to COPY.\nAgreed: Keep the whole section.\n\nBINDINGS AND OTHER METHODS\nJim: Fix the bullet to be an ascii character.\nGeoff: Now that we define the DAV:resourceid property, that may subsume \nour intent here. Maybe we don't need this section.\nKevin: Keep it. It shows that you at least thought about it.\nSay that everything else works the way you would expect except for \ndynamic resources.\nJim: Keep.\nGeoff: Maybe it could be removed if / when we fold bindings into RFC 2518.\nThe only methods we don't mention anywhere are LOCK, UNLOCK. Add them to\nthe list in this section.\nChuck: Adding the qualifier \"on success\" was to get around cases like\nfailure through one binding because of some access control constraint?\nIs there anything that could cause you to get different results from\na successful request on a static resource, depending on the binding used?\nNo. This is the definition of the difference between static / dynamic. (So\nthis section is circular.)\n\nWEAK BINDINGS AND CYCLES\nIs any change to the spec needed as a result of this discussion on the\nmailing list?\nGeoff - No. To do anything else would favor one platform over others.\nJim - Eric's comments on accounting for quotas are interesting.\nKevin - If a client creates a binding, do you count that for accounting purposes?\nGeoff - Don't go there.  Don't standardize stuff related to accounting / \ncharging for bindings.\n\nChuck - What about the issues around delete and garbage collection? \nIf you just get rid of a binding, you can't\nfind the resource through the namespace, but you can find it through properties.\nMaybe I make a guarantee to my customers that if they delete all bindings, \nit won't be possible to find the resource.\nGeoff: CM systems also have the strong / weak distinction, but it's done \ndifferently than Oracle has done it.  Standardizing on one way of doing it \nwould be difficult.  For example, some servers leave dangling weak references\nwhile others garbage collect them.\nJim - Having a deleted file appear in a search is not so terrible.\nKevin - yes it is.  You can prevent that, though.  You just have to do more \nwork to prevent it.  You can have a \"deleted\" property that you include in\nall search conditions.\n\nTHE REDIRECT REFERENCES SPEC\nCOMMENTS\n\nMKRESOURCE AND DELTAV\nJudy: We need to make sure the text in DeltaV and bindings is identical.\nEventually, whichever spec is complete first keeps the text, and the other\nspec just references it.\nGeoff will send Judy the current language from DeltaV.\n\nMKRESOURCE WITH OVERWRITE: T\nJudy: Overwrite creates issues about atomicity that were discussed \nat IETF.  Maybe we just shouldn't support the Overwrite header with\nMKRESOURCE.\nGeoff - Do support overwrite, because it makes sense, not because there is\na strong need for it.\nGeoff: Versioning is not using collections for much, so atomicity is not\na big issue.\nJudy: Atomicity is a problem even for non-collection resources, because\nif Overwrite: T, and the delete succeeds but the write fails, we have to\ndecide whether to require rollback of the delete.\nKevin: MKCOL does not support Overwrite.  It fails if there's a resource\nalready at the Request-URI.\nSo there is no precedent for supporting Overwrite on a creation method.  Just\nfail if something is there already.\nJim: Overwrite was intended only for the Destination of methods that take\n2 URIs as operands.  The plan was to use If-Match: * or If-None-Match: * for\nother methods.\nJudy: So the atomicity question is still there for If-None-Match.\nAgreed: MKRESOURCE will not allow the Overwrite header.  It will fail if a \nresource already exists at the Request-URI.\n\nREDIRECT REFERENCES TO COLLECTIONS\nJim will talk to Yaron.\n\nMOVE, DELETE, AND ATOMICITY\nLeave as is for now.  (Atomicity is assumed.)\n", "encoding": "ascii"}