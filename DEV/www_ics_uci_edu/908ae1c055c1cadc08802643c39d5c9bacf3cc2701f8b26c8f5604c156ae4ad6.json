{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/AdvCollReqts.txt", "content": "     WEBDAV Working Group                                   J. Slein, Xerox\n     INTERNET DRAFT                                     J. Davis, CourseNet\n     <draft-ietf-webdav-collection-reqts-04.1>                June 11, 1999\n     Expires December 11, 1999\n\n          Requirements for Advanced Collection Functionality in WebDAV\n\n     Status of this Memo\n\n        This document is an Internet-Draft and is in full conformance\n        with all provisions of Section 10 of RFC2026. Internet-Drafts are\n        working documents of the Internet Engineering Task Force (IETF),\n        its areas, and its working groups. Note that other groups may\n        also distribute working documents as Internet-Drafts.\n\n        Internet-Drafts are draft documents valid for a maximum of six\n        months and may be updated, replaced, or obsoleted by other\n        documents at any time. It is inappropriate to use Internet-Drafts\n        as reference material or to cite them other than as \"work in\n        progress\".\n\n        To view the list Internet-Draft Shadow Directories, see \n        http://www.ietf.org/shadow.html.\n\n        Distribution of this document is unlimited. Please send comments\n        to the Distributed Authoring and Versioning (WebDAV) working\n        group at <w3c-dist-auth@w3.org>, which may be joined by sending a\n        message with subject \"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\n        Discussions of the WEBDAV working group are archived at URL: \n        <http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\n     Abstract\n\n        The WebDAV Distributed Authoring Protocol [WebDAV] provides basic \n        support for collections, offering the ability to create and list\n        unordered collections.  Many applications, however, need more\n        powerful collections, especially for resource sharing and\n        collection ordering.\n\n        This draft sets out requirements for more advanced, optional\n        collection functionality. It extends the base functionality in the\n        two directions of resource sharing and collection ordering.  A\n        separate WebDAV specification is expected to define protocol \n        elements providing the functionality described here.\n\n     1  Terminology\n\n        The terminology used here follows and extends that in the WebDAV \n        Distributed Authoring Protocol specification [WebDAV]. Definitions \n        of the terms resource, Uniform Resource Identifier (URI), and \n        Uniform Resource Locator (URL) are provided in [URI].\n\n        Association\n           A direct or indirect connection between a resource and a \n           namespace element to support resource sharing. Bindings, URI \n           mappings, and redirect references are types of associations.\n\n        URI Mapping\n           An association between an absolute URL or URI and a resource. \n           Since a resource can represent items that are not network \n           retrievable, as well as those that are, it is possible for a \n           resource to have zero, one, or many URI mappings to URLs or \n           URIs. Mapping a resource to an \"http\" scheme URL makes it \n           possible to submit HTTP protocol requests to the resource using \n           the URL.\n\n        Path Segment\n           Informally, the characters found between slashes (\"/\") in a URL \n           or URI.  Formally, as defined in section 3.3 of [URI].\n\n        Binding\n           An association between a single path segment (in a collection) \n           and a resource. A binding creates one or more URI mappings, and \n           hence is a mechanism for resource sharing, allowing a single \n           resource to be accessed from multiple locations in a URI \n           namespace.\n \n        Collection\n           A resource that contains, as part of its state, a set of \n           bindings which identify member resources.\n\n        Internal Member URI\n           The URI mapping, created by a binding, that is a member of a \n           collection.  While, in general, bindings can create multiple \n           URI mappings to a resource, for a given request, only one of \n           these URI mappings is referred to as the internal member. The \n           URI of the parent collection used in a given request determines \n           the base URI for internal member URI calculation.\n\n     2  Introduction and Rationale\n\n        The simple collections that the WebDAV Distributed Authoring \n        Protocol specification supports are powerful enough to be widely \n        useful.  They provide for the hierarchical organization of \n        resources, with mechanisms for creating and deleting collections, \n        copying and moving them, locking them, adding resources to them \n        and deleting resources from them, and getting listings of their \n        members.  Delete, copy, move, list, and lock operations can be \n        applied recursively, so that a client can operate on whole \n        hierarchies with a single request.\n\n        Many applications, however, need more powerful collections.  There\n        are two areas in particular where more powerful functionality is\n        often needed: shared resources and ordering.  This draft details \n        the additional functionality that is needed in these two areas.\n\n        In both areas, it should be a goal of the protocol specification\n        to be compatible with HTTP 1.1 and with the WebDAV Distributed\n        Authoring Protocol.  It should be a goal that down-level clients\n        be able to take advantage of any new constructs, even if they\n        cannot create and manipulate them.  It should be a goal that the\n        new functionality be relatively simple to implement, both for\n        clients and for servers.  It should be a goal that the new\n        constructs satisfy the infrastructure needs of other WebDAV\n        facilities, particularly the current work on versioning and\n        configuration management.\n\n     2.1  Shared Resources\n\n        Associations make it possible for many collections, on the\n        same or different servers, to share the same resource.  Only one\n        physical copy of the resource need exist, and any changes made in\n        the resource are visible from all the collections that share it.\n\n        A number of scenarios motivate adding associations to the \n        functionality of WebDAV:\n\n        Organizing resources into hierarchies places them into collections,\n        which are more easily browsed and manipulated than a flat \n        namespace.  However, hierarchies require categorization decisions \n        that locate resources at a single location in the hierarchy, a \n        drawback when a resource has multiple valid categories. For \n        example, in a hierarchy of vehicle descriptions containing \n        collections for cars and boats, a description of a combination \n        car/boat vehicle could belong in either collection. Ideally, the \n        description should be accessible from both.\n\n        Sharing between collections on different servers may be desired.\n        For example, the mathematics department at one university may wish\n        to create a collection of information on fractals that contains \n        some local resources, but also provides access to resources at\n        several other universities.  For many reasons, it may be\n        undesirable to make physical copies of the shared resources on the\n        local server - to conserve disk space, to respect copyright\n        constraints, or to make any changes in the shared resources visible\n        automatically.\n\n        In another scenario, a manufacturing company develops and maintains\n        its product maintenance manuals on the Web. There is a separate\n        collection for each product manual.  Each manual is divided into\n        sections, one section for every product component.  Since many of\n        the company\u2019s products contain some of the same components, many of\n        the product maintenance manuals have sections in common.  Each\n        manual may have some unique sections, but for product components \n        that are common to multiple products, the manual's collection \n        accesses a resource in a shared library.\n\n        These requirements do not address issues of the integrity of\n        associations, though integrity will be of great importance to\n        some applications.  Some applications cannot tolerate broken links.\n        A software development application, for example, must be able to\n        rely on the integrity of references to component modules.  Other\n        applications may want integrity not to be enforced.  For example,\n        a Web site manager might want to be able to create access paths\n        before the resources are created for which they will provide \n        access, or might want to be able to remove content temporarily\n        without deleted and later recreating the associations to the\n        content.  Addressing these concerns is considered too difficult\n        for the planned protocol specification, however.  Consequently,\n        they are not included in this set of requirements.\n\n     2.2  Ordered Collections\n\n        For many applications, it is useful for clients to be able to \n        impose orderings on collections at the server.  When the server\n        receives a request for a list of a collection's members, it always\n        responds with a list ordered according to the ordering specified\n        for that collection.  In the product manual application above, the\n        sections of each manual may be ordered so that they can be printed\n        together as a book.  A configuration management application might\n        use a collection to represent a version series, in which case the\n        \"derives from\" relationship might be represented as an ordering on\n        the collection.\n\n        A collection ordering may sometimes be based on property values.\n        An example of such an ordering is one that is alphabetical by\n        author\u2019s last name, or one from most recent to oldest last-\n        modified-date.  An ordering need not be based on property values,\n        however.  A professor may order a collection of course readings in\n        the sequence that makes sense to coordinate them with her lectures,\n        where there is no property on the member resources that could be\n        used to create this ordering.  This set of requirements is\n        primarily concerned with orderings that are not based on property\n        values.  The rationale for this emphasis is that property-based\n        orderings can be obtained, even if inefficiently, using the planned\n        search facility described in [DASL].  But there is no other\n        planned WebDAV facility that could provide orderings that are\n        not based on property values.\n\n        Another useful distinction is between server-maintained and\n        client-maintained orderings.  For server-maintained orderings, the\n        server enforces the semantics of the ordering by placing each\n        collection member at the appropriate position in the ordering;\n        clients cannot alter the position of any collection mamber in the \n        ordering.  In client-maintained orderings, the client places each\n        collection member in the ordering based on its understanding of the\n        semantics of the ordering; the server does nothing to validate the\n        client's positioning of the member in the ordering.  These\n        requirements address both client-maintained and server-maintained\n        orderings.\n\n        WebDAV already provides tools that could be used for creating and\n        maintaining ordered collections.  For example, using only the base\n        WebDAV specification, an application could create a WebDAV property\n        called \"Order\" on a collection resource.  The value of this\n        property might be a list of the collection's member URIs.\n\n        What the base WebDAV specification does not do is standardize a\n        single way to represent orderings for collections.\n\n        Different applications and services should be able to operate on\n        the same collection without private agreements about how to manage\n        and examine its order.  To make this possible, there needs to be a\n        standard way to manipulate and retrieve the order of a collection,\n        and a standard representation of the ordering.\n\n        In any situation where collaborative management of a collection\n        takes place, and different authoring tools or WebDAV servers might\n        be used by the collaborators, standardization is important.  It is\n        also important where a different tool may be used to view the\n        collection from the one that was used to create it.\n\n        So for example, two users from different organizations, using\n        different authoring tools, are working together to create a\n        collection.  One of the tools uses a property on the collection\n        called \"Order\" to store an ordering of the collection.  The other\n        tool uses a property called \"SequenceNumber\" on the resources\n        identified by the collection's member URIs.  If each user adds some\n        members to the collection, there will be no reliable ordering.\n\n     3  Requirements\n\n     3.1  Shared Resources\n\n     3.1.1  A single target resource may be accessed through more than\n            one association.\n\n        This is the primary benefit that associations bring.  They allow \n        resources to be accessed using alternative Request-URIs, and so\n        allow them to be shared by multiple collections, on the same or\n        different servers.\n\n     3.1.2  It is possible for clients to create additional associations\n            that provide access to an existing resource.\n\n        It has always been possible for Web server administrators to create\n        alternative paths to the same resource.  However, clients have not\n        had the ability to do this.  Giving clients the ability to create\n        associations makes it possible for them to create collections that\n        share the same resources.  For several scenarios motivating this\n        requirement, see Section 2.1 above.\n\n     3.1.3  It is possible to create cross-server associations.\n\n        It is often desirable to share provide access from a collection\n        on one server to a resource that resides on another server.  For \n        many reasons, it may be undesirable to make a physical copy of the \n        shared resource on the local server - to conserve disk space, to \n        respect copyright constraints, or to make any changes in the\n        shared resources visible automatically.\n\n     3.1.4  It is possible for a client to delete an association.\n\n        It is important to note that this is a different operation from\n        deleting the resource to which the association provides access.  \n        It must be possible to delete one association without affecting\n        the ability to access the same resource through other associations.\n\n     3.1.5  For any resource, it is possible to request a list of\n            the associations that provide access to it.\n\n        This allows clients to discover what collections share the\n        resource, thus allowing end users to navigate upward from a\n        resource through all the collections that provide access to\n        it.  They can use this facility to locate other related\n        resources and to understand the contexts in which the resource\n        is being used.\n\n     3.1.6  A down-level HTTP 1.1 or WebDAV client is\n            able to use an association to access its target resource.\n\n        This minimal level of compatibility with older clients is needed\n        to make deployment of WebDAV collection functionality feasible.\n        Although new clients may be needed to create and manipulate\n        associations, older clients should be able to read and\n        make use of the collections built using these associations.\n\n     3.1.8  There is no requirement that associations be acyclic.\n\n        It is particularly problematic to require detection of cycles when\n        associations cross server boundaries, but even on a single server\n        it may be too burdensome to require detection of cycles when\n        associations are created.  In addition, there may be\n        applications where cyclic references are desirable.\n\n     3.1.9  There may be multiple associations from the same collection\n            to a given resource.\n\n        It is often useful to allow the same resource to be used in one\n        collection multiple times.  Typically, these are cases where the\n        collection is ordered.  Consider a case where a collection\n        represents a book, with one internal member URI for each page in\n        the book.  A particular graphic needs to appear in several places\n        in the book, and so there need to be multiple internal member URIs\n        in the collection pointing to that graphic.\n\n     3.2  Ordered Collections\n\n     3.2.1  Ordering is sufficiently standardized that different \n            applications and servers can operate on the same ordering \n            without private agreements.\n\n        Applications and servers can apply an ordering to a collection\u2019s \n        members or discover the ordering of a collection's members without\n        private agreements.  They can also modify an ordering, at least\n        with the help of a human user for semantics (See 3.2.3), without\n        private agreements.\n\n        This is the minimum that is needed to support collaborative\n        management of an ordered collection, where different authoring\n        tools might be used by the collaborators.  It is also what allows\n        a different tool to be used to view the collection from the one\n        that was used to create it.  Finally, it is needed in order for\n        servers to list collection members in order, as required by 3.2.6.\n\n     3.2.2  A collection is not required to be ordered.\n\n        A WebDAV server may support collections without supporting ordered\n        collections.  Even if the server supports ordered collections, \n        there is no requirement that every collection on that server be\n        ordered.  Clients decide whether any given collection is\n        ordered.\n\n        The remaining requirements apply only to collections that are\n        ordered.\n\n     3.2.3  The semantics of an ordering are discoverable.\n\n        The semantics of an ordering define the principle or rule according\n        to which the collection members are ordered.  This principle must\n        be discoverable if someone (or some application) other than the one\n        that created a collection is to be able to add a member to it and\n        determine where it makes sense to position the new member in the\n        collection's ordering.\n\n        In some cases it may be possible for the semantics to be expressed\n        in a machine-usable way, so that an application could automatically\n        position a new member in the ordering.  In other cases the \n        semantics may require a human user to apply them.  In either case\n        they should be discoverable.\n\n     3.2.4  Each collection member appears in the ordering exactly once.\n\n        It would be possible to support orderings that contain only a\n        subset of the collection members, or orderings that can contain\n        a single collection member more than once.  It is not necessary,\n        however, since the same result can be achieved by creating a\n        new collection with exactly the desired members, and including\n        each member of the new collection in its ordering exactly once.\n\n        This requirement implies that the server will check, whenever a\n        member is added to an ordering, to make sure that it is not already\n        in the ordering.  It also implies that either the protocol itself\n        or the server will insure that whenever a new member is added to\n        a collection, it is also added to the collection ordering.\n\n     3.2.5  An ordering does not include any resources that are not members\n            of the collection.\n\n        The server must insure that when a member is removed from a \n        collection, it is also removed from the collection's ordering.\n\n     3.2.6  When a client requests a listing of the members of a\n            collection, this listing is returned in the order specified by\n            the collection.\n\n        This requirement frees clients from the burden of applying the\n        ordering to the member listing.  It also insures that whatever\n        client retrieves the collection listing, the listing will appear\n        in the same order.  (An application using the listing can, of\n        course, re-order it on the client side for its own purposes.)\n\n     3.2.7  It is possible to order the members of a collection in a\n            client-specified way, not necessarily based on property values.\n\n        Orderings that are based on property values can be obtained by a\n        search protocol that supports sorted result sets.  This set of\n        requirements is not concerned with such orderings.  It is intended\n        primarily to support orderings that cannot be obtained by sorting\n        on property values.\n\n        A property is not always available that can serve as the basis for\n        a desired ordering.  For example, a professor may wish to order a \n        collection of course readings in the sequence that coordinates the\n        readings with her lectures.  But the properties of resources at the\n        Web site are standardized and do not include one that is\n        appropriate to use for this purpose.\n\n        Even if the professor in the example could create a \n        \"sequencenumber\" property to use in sorting the collection, this\n        strategy would be undesirable unless she knew she would not be\n        adding any readings or changing the order of her lectures once the\n        values of sequencenumber were set.  Inserting a new reading into\n        the sequence would require updating the sequencenumber property of\n        each reading that comes after the new one in the sequence.  Ordered\n        collections are intended to support this sort of case, where\n        sorting based on a property value is impossible or inefficient.\n\n     3.2.8  It is possible for clients to discover available\n            server-maintained orderings and to request that one of those \n            orderings be used for a collection.\n\n        Servers may wish to make available some set of server-maintained\n        orderings, and allow clients to choose which of them is applied\n        to a given collection.  These orderings are likely to be based on\n        properties of the resources in a collection.  For example, a server\n        might allow resources in collections to be ordered alphabetically\n        by author, alphabetically by title, or from most recent to earliest\n        publication date.  In order for clients to take advantage of these\n        orderings, some way must be provided for them to discover what\n        server-maintained orderings are available and to select one to be\n        applied to a given collection.\n\n     4  Acknowledgements\n\n        This draft has benefited from thoughtful discussion by Jim Amsden, \n        Alan Babich, Steve Carter, Geoffrey Clemm, Ken Coar, Ellis Cohen,\n        Bruce Cragun, Spencer Dawkins, Rajiv Dulepet, David Durand,\n        Chuck Fay, Roy Fielding, Yaron Goland, Fred Hitt, Alex Hopmann,\n        Marcus Jager, Chris Kaler, Manoj Karichainula, Rohit Khare,\n        Daniel LaLiberte, Steve Martin, Surendra Koduru Reddy, Sam Ruby,\n        Nick Shelness, John Stracke, John Turner, Jim Whitehead, and\n        others. \n\n     5  References\n\n        [DASL]\n\n        [URI] T. Berners-Lee, R. Fielding, L. Masinter, \"Uniform Resource \n        Identifiers (URI): Generic Syntax.\" RFC 2396. MIT/LCS, U.C. Irvine,\n        Xerox. August, 1998.\n\n        [WebDAV] Y. Y. Goland, E. J. Whitehead Jr., A. Faizi,\n        S. R. Carter, D. Jensen, \"HTTP Extensions for Distributed\n        Authoring - WebDAV.\" RFC 2518. Microsoft, U.C. Irvine, Netscape,\n        Novell. February, 1999.\n\n     6  Authors' Addresses\n\n        J. Slein\n        Xerox Corporation\n        800 Phillips Road\n        Webster, NY 14580\n        Email: jslein@crt.xerox.com\n\n\tJ. Davis\n\tCourseNet Systems\n        170 Capp Street\n        San Francisco, CA 94110\n\tEmail: jrd3@alum.mit.edu\n\n     Expires December 11, 1999", "encoding": "Windows-1252"}