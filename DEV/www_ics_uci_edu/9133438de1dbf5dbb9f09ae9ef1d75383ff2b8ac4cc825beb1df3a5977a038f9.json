{"url": "https://www.ics.uci.edu/~eppstein/263/w17-hw4.html", "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n<html>\n<head>\n<title>CompSci 263, Winter 2017, Homework 4</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script type=\"text/javascript\" src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n</head>\n<body>\n<h1>CompSci 263, Winter 2017, Homework 4</h1>\n<p>The 3SAT$_{\\le k}$ problem takes as input a pair $(F,k)$ where $F$ is a 3-CNF formula and $k$ is an integer parameter, and seeks a truth assignment to the variables of $F$ that satisfies $F$ and has at most $k$ true variables.\nIt is NP-complete (because when $k$ is big it is just 3SAT). We saw in class that, assuming the exponential time hypothesis, it cannot be solved in time\n$n^{o(k)}$ where $n$ is the number of variables in $F$. Therefore, it is\nprobably not fixed-parameter tractable with its natural parameter. In these\nproblems we consider the problem 2SAT$_{\\le k}$, defined in the same way\nfrom 2-CNF formulas.</p>\n<ol>\n<li><p>Prove that 2SAT$_{\\le k}$ is NP-complete. (Hint: reduce from\nvertex cover.)</p></li>\n<li><p>Prove that, for formulas $F$ in which all clauses have at least\none negated variable, the instance $(F,k)$ of 2SAT$_{\\le k}$ can be\nsolved in polynomial time.</p></li>\n<li><p>Describe a backtracking algorithm that solves 2SAT$_{\\le k}$ in\nfixed-parameter time. (Hint: Use problem (2) to show that, if the\nproblem cannot be solved directly, it contains a substructure that\nforces some variables to be positive, and recurse on the different ways\nto satisfy that substructure.) What is the time for your\nalgorithm?</p></li>\n<li><p>Describe a kernelization algorithm that solves 2SAT$_{\\le k}$ in\nfixed-parameter time. The kernelization part of your algorithm\nshould run in polynomial time and should transform the problem into\nan equivalent problem (the kernel) whose size is bounded by a\nfunction of $k$. (Hint: try to adapt one of the known kernels for\nvertex cover.) What is the size of your kernel?</p></li>\n<li><p>If you apply your kernelization and then run your backtracking\nalgorithm on the resulting kernel, what is the running time of the\nresulting hybrid algorithm?</p></li>\n</ol>\n</body>\n</html>\n", "encoding": "ascii"}