{"url": "https://www.ics.uci.edu/~majumder/VC/211HW3/vlfeat/toolbox/misc/vl_binsum.def", "content": "/** @file     vl_binsum.def\n ** @author   Andrea Vedaldi\n ** @brief    vl_binsum.def - vl_binsum template\n **/\n\n#ifndef ITERATE_1\n# define ITERATE_1 1\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 2\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 3\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 4\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 5\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 6\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 7\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 8\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 9\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n# define ITERATE_1 10\n# include \"vl_binsum.def\"\n# undef ITERATE_1\n#else\n# ifndef ITERATE_2\n#  define ITERATE_2 1\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 2\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 3\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 4\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 5\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 6\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 7\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 8\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 9\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n#  define ITERATE_2 10\n#  include \"vl_binsum.def\"\n#  undef ITERATE_2\n# endif\n#endif\n\n#if defined(ITERATE_1) & defined(ITERATE_2)\n# define __VALUE_T__ TYPE(ITERATE_1)\n# define __INDEX_T__ TYPE(ITERATE_2)\n\nstatic void\nVL_XCAT4(_vl_binsum_,__VALUE_T__,_,__INDEX_T__)\n(mxArray * H_array,\n mxArray const * X_array,\n mxArray const * B_array,\n vl_index dim)\n{\n  vl_size KH, KX, KB ;\n  vl_index j ;\n  __VALUE_T__ * H_pt ;\n  __VALUE_T__ const * X_pt ;\n  __INDEX_T__ const * B_pt ;\n  __INDEX_T__ const * B_end ;\n\n  KH = mxGetNumberOfElements(H_array) ; /* accumulator */\n  KX = mxGetNumberOfElements(X_array) ; /* values */\n  KB = mxGetNumberOfElements(B_array) ; /* accumulator indeces */\n\n  H_pt = (__VALUE_T__ *) mxGetData(H_array) ;\n  X_pt = (__VALUE_T__ const *) mxGetData(X_array) ;\n  B_pt = (__INDEX_T__ const *) mxGetData(B_array) ;\n\n  B_end = B_pt + KB ;\n\n  if ((KX != KB) && (KX > 1)) {\n    vlmxError(vlmxErrInvalidArgument,\n              \"VALUES and INDEXES do not have the same number of elements nor VALUES is a scalar.\") ;\n  }\n\n  /* All dimensions mode ------------------------------------------- */\n  if (dim <= 0) {\n\n    while (B_pt < B_end) {\n\n      /* next bin to accumulate */\n      j = (vl_index)(*B_pt) - 1 ;\n\n      /* bin index out of bounds ?*/\n      if(j < -1 || j >= (signed) KH) {\n        vlmxError(vlmxErrInconsistentData,\n                  \"The index INDEXES(%\"  VL_FMT_INDEX \") = %\" VL_FMT_INDEX \" is out of bound.\",\n                  (vl_index)(B_pt - (__INDEX_T__ const *)mxGetData(B_array) + 1),\n                  j + 1) ;\n      }\n\n      /* accumulate (but skip null indeces) */\n      if (j >= 0) {\n        H_pt[j] += *X_pt ;\n      }\n\n      /* except for the scalar X case, keep X and B synchronized */\n      ++ B_pt ;\n      if (KX > 1) ++ X_pt ;\n    }\n  }\n\n  /* One dimension mode -------------------------------------------- */\n  else {\n    vl_index k ;\n    vl_size d  = dim - 1 ;\n\n    mwSize HD = mxGetNumberOfDimensions(H_array) ;\n    mwSize XD = mxGetNumberOfDimensions(X_array) ;\n    mwSize BD = mxGetNumberOfDimensions(B_array) ;\n\n    mwSize const * Hdims = mxGetDimensions(H_array) ;\n    mwSize const * Xdims = mxGetDimensions(X_array) ;\n    mwSize const * Bdims = mxGetDimensions(B_array) ;\n\n    __INDEX_T__ const * B_brk ;\n    __INDEX_T__ const * B_nbrk ;\n\n    vl_size srd ;\n\n    /* We need to check a few more details about the matrices */\n    if (d >= HD) {\n      vlmxError(vlmxErrInconsistentData,\n                \"DIM is smaller than one or larger than the number of dimensions of ACCUMULATOR.\") ;\n    }\n\n    /*\n     Here either B has the same number of dimensions of H, or B has\n     exactly one dimension less and DIM=end.  The latter is a\n     special case due to the fact that MATLAB deletes singleton\n     dimensions at the ends of arrays, so it would be impossible to\n     operate with DIM=end and size(B,end)=1, which is a logically\n     acceptable case.\n     */\n\n    if (HD != BD) {\n      if (! d == HD - 1 && BD == HD - 1) {\n        vlmxError(vlmxErrInconsistentData,\n                  \"ACCUMULATOR and INDEXES do not have the same number of dimensions.\") ;\n      }\n    }\n\n    if ((BD != XD) && (KX > 1)) {\n      vlmxError(vlmxErrInconsistentData,\n                \"VALUES is not a scalar nor has the same number of dimensions of INDEXES.\") ;\n    }\n\n    /* This will contain the stride required to advance to the next\n     * element along dimension DIM. This is the product of all\n     * dimensions < d. */\n\n    srd = 1 ;\n\n    for(k = 0 ; k < (signed) XD ; ++k) {\n      if (KX > 1 &&  Xdims[k] != Bdims[k]) {\n        vlmxError(vlmxErrInconsistentData,\n                  \"VALUES and INDEXES have incompatible dimensions.\") ;\n      }\n      if (k != (signed) d && (Bdims[k] != Hdims[k])) {\n        vlmxError(vlmxErrInconsistentData,\n                  \"VALUES and ACCUMULATOR have incompatible dimensions.\") ;\n      }\n      if (k < (signed) d) {\n        srd = srd * Bdims[k] ;\n      }\n    }\n\n    /* We sum efficiently by a single pass of B_pt in memory order.\n     * This however makes the algorithm a bit more involved. How the\n     * sum is performed is easeir understood by an example. Consider\n     * the case d = 3 and BD = 5. So elements in B are indexed as\n     *\n     *  B[i0, i1, id, i4, i5]  (note that id=i3)\n     *\n     * where the indexes (i0,i1,id,i4,i5) are scanned in column-major\n     * orer. For each of such elements, we acces the element\n     *\n     *  R[i0, i1, B[i0,i1,id,i4,i5], i4, i5]\n     *\n     * For greater efficiency, we do not compute the multi-indexes\n     * explicity; instead we advance B_pt at each iteration and we\n     * keep R_pt properly synchronized.\n     *\n     * In particular, at each iteration we want R_pt to point to\n     *\n     *  R[i0, i1, 0, i4, i5]\n     *\n     * Therefore, whenever advancing B_pt correspnds to advancing\n     *\n     * a - i0, i1 : we advance R_pt\n     * b - id     : we advance R_pt and then we subtract srd to move id back\n     *              one position;\n     * c - i4,i5  : we do the same as before, but then we need to add\n     *              srd * Hdims[d] *  elements to move R_pt up one place\n     *              after dimension d.\n     *\n     * We can easily keep track of the three cases without computing\n     * explicitly the indexs. In fact, case (a) occurs srd-1\n     * consecutive steps and case (b) at the srd step. Similarly, case\n     * (c) accurs at step srd * Bdims[d] steps. The pattern repeats\n     * regularly.\n     */\n\n    KH     = Hdims[d] ;\n    B_brk  = B_pt + srd ;              /* next time case (b) */\n    B_nbrk = B_pt + srd * Bdims [d] ;  /* next time case (c) */\n\n    while (B_pt < B_end) {\n\n      /* next bin to accumulate */\n      j = (vl_index)(*B_pt) - 1;\n\n      /* index out of bounds? */\n      if(j < -1 || j >= (signed) KH) {\n        vlmxError(vlmxErrInconsistentData,\n                  \"The index INDEXES(%\"  VL_FMT_INDEX \") = %\" VL_FMT_INDEX \" is out of bounds.\",\n                  (vl_index)(B_pt - (__INDEX_T__ * const)mxGetData(B_array)) + 1,\n                  j + 1) ;\n      }\n\n      /* accumulate (but skip null indeces) */\n      if (j >= 0) {\n        H_pt [j * srd] += *X_pt ;\n      }\n\n      /* next element */\n      if (KX > 1) X_pt++ ;\n      B_pt ++ ;\n      H_pt ++ ;\n\n      if (B_pt == B_brk) {                 /* case (b) occurs */\n        B_brk += srd ;                     /* next time case (b) */\n        H_pt  -= srd ;\n        if (B_pt == B_nbrk) {              /* case (c) occurs */\n          B_nbrk += srd * Bdims[d] ;       /* next time case (c) */\n          H_pt   += srd * Hdims[d] ;\n        }\n      }\n    }\n  }\n}\n\n#undef __VALUE_T__\n#undef __INDEX_T__\n#endif\n", "encoding": "ascii"}