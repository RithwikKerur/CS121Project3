{"url": "https://www.ics.uci.edu/~aburtsev/143A/2018fall/hw/hw4-threads.html", "content": "<HTML>\n<HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">\n<TITLE>143A Principles of Operating Systems</TITLE>\n<LINK HREF=\"./css/main.css\" TYPE=\"text/css\" REL=\"stylesheet\">\n<META NAME=\"Description\" CONTENT=\"Home page of Anton Burtsev.\">\n<META NAME=\"Keywords\" CONTENT=\"Anton Burtsev, Burtsev, Anton, 143A\">\n<SCRIPT SRC=\"./scripts/image_switcher.js\" LANGUAGE=\"JavaScript\"></SCRIPT>\n</HEAD>\n\n<BODY BGCOLOR=\"#FFFFFF\" LEFTMARGIN=\"0\" TOPMARGIN=\"0\" MARGINWIDTH=\"0\" MARGINHEIGHT=\"0\">\n\t<TABLE  ID=\"text\" ALIGN=\"CENTER\" WIDTH=\"600\" BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD>\n\t\t<DIV ID=\"tech_nav\">\n\t\t\t<A HREF=\"../index.html\">Home</A>\n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"30\" ALT=\"\" BORDER=\"0\"/>\n\t\t</DIV>\n\t</TD>\n\t</TR>\t\n\t<TR>\n\t<TD COLSPAN=\"4\" ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\">\n\n\n\t\t<P>\n\n\n<h1>HW4: POSIX Threads</h1>\n\n<p>This homework asks you to extend xv6 with support for POSIX threads. To make\nit real and fun, we pretty much implement the interface of the POSIX\nthreads that are de facto standard on most UNIX systems.  \n\n<p>You will program the xv6 operating system, so you should use the same setup\nas for the <a href=\"hw2-boot-xv6.html\">HW2: Xv6 boot</a>.\n\n<p>Specifically, you'll define three new system\ncalls: first one to create a kernel thread, called <tt>thread_create()</tt>, \nsecond to wait for the thread to finish <tt>thread_join()</tt>, and then a\nthird one that allows the thread to exit <tt>thread_exit()</tt>. \n\n<p> As a challenge exercise you can implement POSIX-like synchronization primitives: spinlocks and mutexes. To test\nyour implementation you will use a simple program we provide. \n\n<p>Before starting to work on your thread implementation, you should understand\nwhat threads are. Here is a good link that introduces POSIX threads that you\nhave to develop (you don't have to read all of it, just get the basic idea of\nwhat threads are and how they work): <a\nhref=\"https://computing.llnl.gov/tutorials/pthreads/\">https://computing.llnl.gov/tutorials/pthreads/</a>.\nIf you feel like it you can also read a couple of chapters from the OSTEP book:\n<a href=\"http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf\">Concurrency:\nAn Introduction</a> and <a\nhref=\"http://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf\">Interlude: Thread\nAPI</a>\n\n<p>The take-away idea for threads: threads are very much like processes (they\ncan run in parallel on different physical CPUs), but they share the same address\nspace (the address space of the process that created them). Hence all threads\nof the same process can read and update the all variables in that address space\nto communicate and collaborate on computing a complex result in parallel. \n\n<p>While threads share the same address space they each need their own stack as\nthey might execute entirely different code in the program (call different\nfunctions with different arguments --- all this information has to be preserved\nfor each thread individually, hence they need different stacks. The parent\nprocess allocates the stacks with <tt>malloc()</tt> or <tt>sbrk()</tt> for each\nthread before starting it (obviously, this can be hidden inside the\n<tt>thread_create()</tt> function).  While these new stacks will not have a\nguard page in front of it, but otherwise should work just fine (the heap is\nmapped with the same attributes as stack (writable)). \n\n<p>Now, lets get back to work. Your new <tt>thread_create()</tt> system call\nshould look like this: \n\n<pre>int thread_create(void(*fcn)(void*), void *arg, void*stack)</pre> \n\nThis call creates a new kernel thread which shares the address space with the \ncalling process. In our implementation we will copy file descriptors in the same manner \nfork() does it. The new process uses <code>stack</code> as its\nuser stack, which is passed the given argument <code>arg</code> and uses a fake\nreturn PC (0xffffffff). The stack should be one page in size. The new thread \nstarts executing at the address specified by <code>fcn</code> . \nAs with fork(), the PID of the new thread is returned to the\nparent.</p> \n\n<p>The other new system call is <code>int thread_join(void)</code> . This call waits\nfor a child thread that shares the address space with the calling process. It\nreturns the PID of waited-for child or -1 if none. \n\n<p>Finally, the <code>int thread_exit(void)</code> system call allows a thread to terminate. \n\n<p>You also need to think about the semantics of a couple of existing system\ncalls. For example, <code>int wait()</code> should wait for a child process that does not\nshare the address space with this process. It should also free the address\nspace if this is last reference to it. Finally, <code>exit()</code> should work as\nbefore but for both processes and threads; little change is required here.</p> \n\nYou can follow the following example template for <tt>thread.c</tt> to test your thread \nimplementation:\n\n<pre>\n#include \"types.h\"\n#include \"stat.h\"\n#include \"user.h\"\n\nstruct balance {\n    char name[32];\n    int amount;\n};\n\nvolatile int total_balance = 0;\n\nvolatile unsigned int delay (unsigned int d) {\n   unsigned int i; \n   for (i = 0; i < d; i++) {\n       __asm volatile( \"nop\" ::: );\n   }\n\n   return i;   \n}\n\nvoid do_work(void *arg){\n    int i; \n    int old;\n   \n    struct balance *b = (struct balance*) arg; \n    printf(1, \"Starting do_work: s:%s\\n\", b->name);\n\n    for (i = 0; i < b->amount; i++) { \n         //thread_spin_lock(&lock);\n         old = total_balance;\n         delay(100000);\n         total_balance = old + 1;\n         //thread_spin_unlock(&lock);\n    }\n  \n    printf(1, \"Done s:%x\\n\", b->name);\n\n    thread_exit();\n    return;\n}\n\nint main(int argc, char *argv[]) {\n\n  struct balance b1 = {\"b1\", 3200};\n  struct balance b2 = {\"b2\", 2800};\n \n  void *s1, *s2;\n  int t1, t2, r1, r2;\n\n  s1 = malloc(4096);\n  s2 = malloc(4096);\n\n  t1 = thread_create(do_work, (void*)&b1, s1);\n  t2 = thread_create(do_work, (void*)&b2, s2); \n\n  r1 = thread_join();\n  r2 = thread_join();\n  \n  printf(1, \"Threads finished: (%d):%d, (%d):%d, shared balance:%d\\n\", \n      t1, r1, t2, r2, total_balance);\n\n  exit();\n}\n</pre>\n\n<p>Here the process creates two threads that execute the same\n<tt>do_work()</tt> function concurrently. The <tt>do_work()</tt> function in\nboth threads updates the shared variable <tt>total_balance</tt>. \n\n<h3>Hints</h3>\n\n<p>The <tt>thread_create()</tt> call should behave very much like fork, except\nthat instead of copying the address space to a new page directory, clone\ninitializes the new process so that the new process and cloned process use the\nsame page directory. Thus, memory will be shared, and the two \"processes\" are\nreally actually threads.\n\n<p>The <tt>int thread_join(void)</tt> system call is very similar to the\nalready existing <tt>int wait(void)</tt> system call in xv6. Join waits for a\nthread child to finish, and wait waits for a process child to finish. \n\n<p>Finally, the <tt>thread_exit()</tt> system call is very similar to\n<tt>exit()</tt>. You should however be careful and do not deallocate the page\ntable of the entire process when one of the threads exits.\n\n<h2>Extra credit: Synchronization</h2>\n\n<p>If you implemented your threads correctly and ran them a couple of times you\nmight notice that the total balance (the final value of the\n<tt>total_balance</tt> does not match the expected 6000, i.e., the sum of\nindividual balances of each thread. This is because it might happen that both\nthreads read an old value of the <tt>total_balance</tt> at the same time, and\nthen update it at almost the same time as well. As a result the deposit (the\nincrement of the balance) from one of the threads is lost. \n\n<h3>Extra credit (5%): Spinlocks</h3>\n\n<p>To fix this synchronization error you have to implement a spinlock that will\nallow you to execute the update atomically, i.e., you will have to implement\nthe <tt>thread_spin_lock()</tt> and <tt>thread_spin_unlock()</tt> functions and\nput them around your atomic section (you can uncomment existing lines above). \n\n<p>Specifically you should define a simple lock data structure and implement\nthree functions that: 1) initialize the lock to the correct initial state\n(<tt>void thread_spin_init(struct thread_spinlock *lk)</tt>), 2) a funtion to\nacquire a lock (<tt>void thread_spin_lock(struct thread_spinlock *lk)</tt>),\nand 3) a function to release it <tt>void thread_spin_unlock(struct\nthread_spinlock *lk)</tt>.\n\n<p>To implement spinlocks you can copy the implementation from the xv6 kernel.\nJust copy them into your program (<tt>threads.c</tt> and make sure you\nunderstand how the code works). \n\n\n<h3>Extra credit (10%): Mutexes</h3>\n\n<p>While spinlocks that you've implemented above implement correct\nsynchronization across threads, they might be inefficient in some cases. For\nexample, when all threads of the process run in parallel on different CPUs,\nspinlocks are perfect---each process enters a short critical section, updates\nthe shared balance atomically and then releases the spinlock for other threads\nto make progress. \n\n<p>However, if you are running on a system with a single physical CPU (you can\nchange the number of CPUs in the xv6 Makefule and set it to 1), or the system\nis under high load and a context switch occurs in a critical section (you can\nimagine that it can happen in a slightly longer critical section) then all\nthreads of the process start to spin endlessly, waiting for the interrupted\n(lock-holding) thread to be scheduled and run again the spinlocks become\ninefficient. \n\n<p>One possible approach is to implement a different synchronization primitive,\na mutex, and instead of spinning on a thread release the CPU to another thread,\nlike: \n\n<pre>\nvoid thread_mutex_lock(struct thread_mutex *m)\n{\n  while(locked(m))\n    yield();\n}\n\nvoid\nthread_mutex_unlock(struct thread_mutex *m)\n{\n  unlock(m);\n}\n</pre>\n\n<p>Based on the high-level description of the mutex above, implement a mutex\nthat will allow you to execute the update atomically similar to spinlock, but\ninstead of spinning will release the CPU to another thread. Test your\nimplementation by replacing spinlocks in your example above with mutexes. \n\n<p>Specifically you should define a simple mutex data structure and implement\nthree functions that: 1) initialize the mutex to the correct initial state\n(<tt>void thread_mutex_init(struct thread_mutex *m)</tt>), 2) a funtion to\nacquire a mutex (<tt>void thread_mutex_lock(struct thread_mutex *m)</tt>), and\n3) a function to release it <tt>void thread_mutex_unlock(struct thread_mutex\n*m)</tt>.\n\n<p>Mutexes can be implemented very similarly to spinlocks (the implementation\nyou already have). Since xv6 doesn't have an explicit <tt>yield(0)</tt> system\ncall, you can use <tt>sleep(1)</tt> instead. \n\n<h2>Extra credit (15%): Conditional variables</h2> \n\n<p>While spinlock and mutex synchronization work well, sometimes we need a\nsynchronization pattern similar to the producer-consumer queue we've discussed\nin class, i.e., instead of spinning on a spinlock or yielding the CPU in a\nmutex, we would like the thread to sleep until certain condition is met. \n\n<p>POSIX provides support for such scheme with conditional variables. A\ncondition variable is used to allow a thread to sleep until a condition is\ntrue. Note that conditional variables are always used along with the mutex. \n\n<p>You have to implement conditional variables similar to the once provided \nby POSIX. The function primarily used for this is pthread_cond_wait(). It takes two\narguments; the first is a pointer to a condition variable, and the second is a\nlocked mutex. When invoked, pthread_cond_wait() unlocks the mutex and then\npauses execution of its thread. It will now remain paused until such time as\nsome other thread wakes it up. These operations are \"atomic;\" they always\nhappen together, without any other threads executing in between them. \n\n<pre> \nstruct q {\n   struct thread_cond cv;\n   struct thread_mutex m;\n \n   void *ptr;\n};\n\n// Initialize\nthread_cond_init(&q->cv);\nthread_mutex_init(&q->m);\n\n// Thread 1 (sender)\nvoid*\nsend(struct q *q, void *p)\n{\n   thread_mutex_lock(&q->m);\n   while(q->ptr != 0)\n      ;\n   q->ptr = p;\n   thread_cond_signal(&q->cv);\n   thread_mutex_unlock(&q->m);\n}\n\n// Thread 2 (receiver)\n\nvoid*\nrecv(struct q *q)\n{\n  void *p;\n\n  thread_mutex_lock(&q->m);\n\n  while((p = q->ptr) == 0)\n    pthread_cond_wait(&q->cv, &q->m);\n  q->ptr = 0;\n\n  thread_mutex_unlock(&q->m);\n  return p;\n}\n\n</pre>\n\n<p>\nTo test your solution, develop a small queue example like above and submit it along with your extra credit solution. \n\n<h2>Extra credit (5%): Semaphores</h2> \n\n<p>Conditional variables can be used to implement semaphores (if you are still\nconfused about semaphores read about them here: <a\nhref=\"https://en.wikipedia.org/wiki/Semaphore_(programming)\">Semaphore\n(programming)</a>). The implementation of the semaphore is trivial and you can\nread up on it here and implement it in a similar manner: <a\nhref=\"https://github.com/angrave/SystemProgramming/wiki/Synchronization,-Part-5:-Condition-Variables\">Condition\nVariables</a>. \n\n<p>Implement semaphores and the producer consumer queue of N elements in which\naccess to the queue is controlled with semaphores like described here: <a\nhref=\"https://en.wikipedia.org/wiki/Semaphore_(programming)\">Semaphore\n(programming)</a>. \n\n\n<h2>Extra credit (10%): Fix sbrk() and malloc()</h2> \n\n<p>Threads of the same process can grow the address space of the process in\nparallel by calling <tt>sbrk()</tt>. Obviously this will result into an\ninconsistent page table. Unless you've already done this, analyze the code path\nof <tt>sbrk()</tt> through the kernel and see what needs to be changed to grow\nan address space in a multi-threaded process correctly.</p> \n\n<p>Similar atomicity problem exists in malloc(). If threads of the same\nprocess use malloc() concurrently it will result in an incorrect state of the\nmalloc data structures. Fix this, making sure that processes can use malloc()\ncorrectly. \n\n<p>\nTo test your solution, develop a small program that creates multiple threads and\nuses sbrk() and malloc() concurrently and submit it along with your extra credit solution. \n\n<h2>Extra credit (10%): per-thread variables</h2>\n\nImagine you would like to implement variables that are private to each thread.\nWhile you can pass them as an argument to your work function when you create\nthe thread it will require you to pass the same arguments in all functions\ncalled recursively. Hence, sometimes its convenient to keep track of the thread\nID for each thread. Then you can declare an array of variables (one for each\nthread), and access this array based on thread ID: \n\n<pre>\ntypedef struct balance {\n   char name[32];\n   char amount;\n} balance_t;\n\nbalance_t per_thread_balance[MAX_THREADS];\n\nint foo() {\n   ...   \n   a = per_thread_balance[gettid()].amount;\n   ...\n}\n</pre>\n\n<p>Implement support for the <tt>gettid()</tt> function. You should allocate a\nsmall data structure <tt>struct tls</tt> (thread local store) at the top of the\nstack of each thread. Then if you know that each stack is page aligned (note\nthat we didn't require the stack to be page aligned up until now) you can\nimplement gettid() by rounding the value of the stack pointer up to the nearest\npage and typecasting it to TLS. To make sure that stacks are page aligned,\nallocate them with <tt>sbrk()</tt>. \n\n<p>\nTo test your solution, develop a small program that creates multiple threads, \ndeclares per-thread variables and uses them. \n\n\n<h2>Extra credit (10%): Cute macros for per-thread variables</h2>\n\n<p>While the solution for per-thread variables above works it is a bit\nugly---declaring arrays clutters your code. Provide support for cleaner\nper-thread variables that declare per-thread variables arrays and provide\naccess to per-thread variables as macros. For example the two macros below:  \n\n<pre> \nDEFINE_PER_THREAD(type, name);\nper_thread(name)\n</pre>\n\nCan be used to define per-cpu balance variables, and then access them like: \n<pre>\nDEFINE_PER_THREAD(balance_t, balance);\n\nint foo() {\n  ...\n  a = per_thread(balance).amount;\n  ...\n}\n</pre>\n\n<p>\nTo test your solution, develop a small program that creates multiple threads, \ndeclares per-thread variables and uses them. \n\n\n<div class=\"question\"> <p><b>Submit</b> <p>Submit your answers on Canvas <a href=\"https://canvas.eee.uci.edu/courses/12602\">HW4 POSIX threads</a> as a compressed tar file of your xv6\nsource tree (after running make clean). You can use the following command to create a compressed tar file (if you submit extra credit assignments, put a short hw4.txt readme file \ndescribing what you've done inside your archive). \n<pre>\nopenlab$ cd xv6-public\nopenlab$ make clean\nopenlab$ cd ..\nopenlab$ tar -czvf hw3.tgz xv6-public\n</pre>\n\n\n</div>\n\n\t</TD>\t\t\t\n\t</TR>\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD COLSPAN=\"4\">\n\t\t<DIV ID=\"tech\">Updated: November, 2018</DIV>\n\t</TD>\n\t</TR>\n\t</TABLE>\n</BODY>\n</HTML>\n\n\n", "encoding": "ascii"}