{"url": "https://www.ics.uci.edu/~kay/courses/141/schemenotes.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Tuesday, February 1, 2000 3:09 PM\">\n<TITLE>Notes on Scheme</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"21A2E910\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Scheme, high-order functions, recusion, list processing\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Class notes for an introduction to functional programming in Scheme, with illustrations of high-order functions and a database of restaurants.  David G. Kay, Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 1995-1999 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<FONT FACE=\"Palatino\">Information &amp; Computer Science &#160; David G.\nKay\n<BR>\nUC Irvine &#160; ICS 141\n<BR>\n<FONT SIZE=5>Notes on Scheme</FONT></P>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Scheme is a lexically scoped dialect of Lisp</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Functional paradigm, but not purely; can do OOP, imperative,\neven logic</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Dynamic storage is automatic (automatic garbage collection)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Procedures are first-class objects (and all procedures\nare functions)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Unified numeric types</FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Programming environment:  Traditionally interactive\nand interpreted, but many non-student-oriented Scheme systems allow building\nstandalone applications.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Data in Scheme:</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Characters:  </FONT><FONT FACE=\"Courier\"><TT>A</TT></FONT><FONT FACE=\"Palatino\">-</FONT><FONT FACE=\"Courier\"><TT>Z\na</TT></FONT><FONT FACE=\"Palatino\">-</FONT><FONT FACE=\"Courier\"><TT>z 0</TT></FONT><FONT FACE=\"Palatino\">-</FONT><FONT FACE=\"Courier\"><TT>9\n% + - * / = ? ! #</TT></FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Atom:  String of characters without blanks</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">Numbers (unified), booleans (</FONT><FONT FACE=\"Courier\"><TT>#t</TT></FONT><FONT FACE=\"Palatino\">,\n</FONT><FONT FACE=\"Courier\"><TT>#f</TT></FONT><FONT FACE=\"Palatino\">), strings,\ncharacters</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">List:  Parentheses enclosing any combination of atom(s)\nand list(s).  Nested; empty.</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>cons</TT></FONT><FONT FACE=\"Palatino\"> and </FONT><FONT FACE=\"Courier\"><TT>list</TT></FONT><FONT FACE=\"Palatino\">.</FONT><FONT FACE=\"Courier\"><TT>\nnull?</TT></FONT><FONT FACE=\"Palatino\"> (a predicate)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>car</TT></FONT><FONT FACE=\"Palatino\"> and </FONT><FONT FACE=\"Courier\"><TT>cdr</TT></FONT><FONT FACE=\"Palatino\">\n(IBM 704; contents of address/decrement register).  More mnemonically, &quot;</FONT><FONT FACE=\"Courier\"><TT>first</TT></FONT><FONT FACE=\"Palatino\">&quot;\nand &quot;</FONT><FONT FACE=\"Courier\"><TT>rest</TT></FONT><FONT FACE=\"Palatino\">&quot;</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Vectors.  Structures.  </FONT><FONT FACE=\"Courier\" SIZE=2><TT>(define-structure\nrest (name cuisine phone dish price))</TT></FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">=&gt; </FONT><FONT FACE=\"Courier\"><TT>(make-rest n\nc p d $)</TT></FONT><FONT FACE=\"Palatino\">; constructor of a rudimentary\nobject</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">=&gt; </FONT><FONT FACE=\"Courier\"><TT>(rest? R)</TT></FONT><FONT FACE=\"Palatino\">;\ntype checker</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">=&gt; </FONT><FONT FACE=\"Courier\"><TT>(rest-name R)</TT></FONT><FONT FACE=\"Palatino\">;\nselector.  Similarly for cuisine, phone, dish, price</FONT></LI>\n<BR>\n</UL>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Evaluation of expressions:  (  <I><U><FONT SIZE=2>FUNCTION</FONT></U>\n  <U><FONT SIZE=2>ARGUMENTS</FONT></U> </I> ).  Read-eval-print loop.</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">Quoting:  So you don't evaluate &quot;constants&quot;.\n </FONT><FONT FACE=\"Courier\"><TT>(quote blah)</TT></FONT><FONT FACE=\"Palatino\">,\nor </FONT><FONT FACE=\"Courier\"><TT>'blah</TT></FONT><FONT FACE=\"Palatino\">.</FONT></LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>if, cond</TT></FONT><FONT FACE=\"Palatino\"> -- control\nstructures for selection.</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>lambda</TT></FONT><FONT FACE=\"Palatino\">, </FONT><FONT FACE=\"Courier\"><TT>let</TT></FONT><FONT FACE=\"Palatino\">\n-- creating procedures (which are first-class objects) and local variables</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>display</TT></FONT><FONT FACE=\"Palatino\"> and </FONT><FONT FACE=\"Courier\"><TT>newline</TT></FONT><FONT FACE=\"Palatino\">\n-- to generate output (as a side effect, apart from return value)</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Scheme reading list (in roughly ascending order by\ndifficulty):</FONT></LI>\n<BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\"><I>The Schemer&#39;s Guide,</I> 2nd ed., by Ferguson\nand Kaufman (Schemers, Inc., 1996)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Simply Scheme,</I> by Brian Harvey and Matthew\nWright (MIT Press, 1994)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Concrete Abstractions,</I> by Hailperin, Kaiser,\nand Knight (PWS, 1999)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>The Schematics of Computation</I> by Manis and\nLittle (Prentice-Hall, 1995)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>The Little Schemer,</I> 4th ed., by Friedman and\nFelleisen (SRA 1996)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Scheme and the Art of Programming,</I> by Springer\nand Friedman (McGraw-Hill)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\"><I>Structure and Interpretation of Computer Programs,</I>\n2nd ed., by Abelson and Sussman  &#160; (MIT/McGraw-Hill, 1996)</FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Palatino\">See also </FONT><FONT FACE=\"Courier\"><TT><A HREF=\"http://www.ics.uci.edu/~kay/courses/22/scheme-refs.html\">http://www.ics.uci.edu/~kay/courses/22/scheme-refs.html</A></TT></FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Defining procedures</FONT><FONT FACE=\"Courier\"><TT>--lambda</TT></FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define Thai?</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (R)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (equal? 'Thai (rest-cuisine\nR))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define match-cuisine? &#160; ; Let user specify\nwhich cuisine</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (R C) &#160;  &#160; ; to\ncheck for</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (equal? C (rest-cuisine R))))</TT></FONT>\n<BR>\n<HR>\n</LI>\n<BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Define a restaurant collection ADT, as a list of restaurants.</FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">(The following examples take advantage of procedures\nbeing first-class objects in Scheme.  That is, a procedure can take procedures\nas arguments and can also <I>return</I> a procedure.  As you go through\nthe following examples, ask yourself, &quot;What is the &#39;data type&#39;\nof each argument?  What is the type of the returned value?&quot;  In some\ncases, the answer will be, &quot;A procedure [that itself takes some arguments\nand returns some value].&quot;)</FONT>\n<BR>\n<FONT FACE=\"Palatino\" SIZE=1>&#160;  </FONT></LI>\n<BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define find-thai   ; return the first Thai restaurant\nin RC</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (RC) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((null? RC) '()) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((Thai? (first RC))\n(first RC)) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; (else (find-thai (rest\nRC))))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define find-match  ; return restaurant that satisfies\nany &#39;test?&#39;</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (RC test?) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((null? RC) '()) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; ((test? (first RC))\n(first RC)) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; (else (find-match\n(rest RC) test?)))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Call with </FONT><FONT FACE=\"Courier\"><TT>(find-match\nRC Thai?)</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Palatino\">Define </FONT><FONT FACE=\"Courier\"><TT>Chinese?</TT></FONT><FONT FACE=\"Palatino\">\nor other predicates to call </FONT><FONT FACE=\"Courier\"><TT>find-match</TT></FONT><FONT FACE=\"Palatino\">\nwith.</FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (R) </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (equal? 'Indonesian (rest-cuisine\nR))))</TT></FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Palatino\">You can use &quot;anonymous lambda&quot; rather than\nmaking up a name.</FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">A function that returns a function,--this will build\na checker for any cuisine.</FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>(define make-cuisine-checker &#160; </TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (C) &#160;    ; (make-cuisine-checker\nC) takes a cuisine</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (lambda (R)  ;  and returns\na function that takes a Rest.</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;                 ;   and checks whether its\ncuisine matches C.</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160; (equal? C (rest-cuisine\nR)))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define Indonesian? (make-cuisine-checker 'Indonesian))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC Indonesian?)</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC (make-cuisine-checker 'Indonesian))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define make-checker</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (field-selector comparison-function\nvalue)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (lambda (R)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;     (comparison-function (field-selector\nR) value))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define cheap? (make-checker rest-price &lt; 10.00))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(find-match RC cheap?)</TT></FONT>\n<HR>\n</LI>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">List manipulation [Assume the restaurant collection\nis a Lisp list]</FONT></LI>\n<BR><BR>\n<UL>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define all-cheap?</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) #t)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  ((cheap? (first Rlist))\n</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  &#160; (all-cheap?\n(rest Rlist)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  (else #f))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define all-cheap-restaurants</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       ((cheap? (first Rlist))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;     (cons (first Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;      &#160;      (all-cheap-restaurants\n(rest Rlist))))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       (else (all-cheap-restaurants\n(rest Rlist))))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define find-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       ((test? (first Rlist))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;     (cons (first Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  &#160;      (find-all-matches\n(rest Rlist) test?)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       (else (find-all-matches\n(rest Rlist) test?)))))</TT></FONT></LI>\n<BR><BR>\n<LI>\n<FONT FACE=\"Courier\"><TT>(define remove-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160; (cond ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       ((test? (first Rlist))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;     (remove-all-matches\n(rest Rlist) test?))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;       (else (cons (first Rlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\"><TT>&#160;&#160;  &#160;  &#160;  &#160;         (remove-all-matches\n(rest Rlist)  &#160;  &#160;  &#160;  &#160;                           \n test?))))))</TT></FONT></LI>\n<BR><BR>\n</UL>\n<LI>\n<FONT FACE=\"Palatino\">Notice that </FONT><FONT FACE=\"Courier\"><TT>find-all-matches</TT></FONT><FONT FACE=\"Palatino\">\nand </FONT><FONT FACE=\"Courier\"><TT>remove-all-matches</TT></FONT><FONT FACE=\"Palatino\">\nare identical except that the actions in the </FONT><FONT FACE=\"Courier\"><TT>test?</TT></FONT><FONT FACE=\"Palatino\">\nclause and the </FONT><FONT FACE=\"Courier\"><TT>else</TT></FONT><FONT FACE=\"Palatino\">\nclause are interchanged.  We can combine these by including a boolean parameter\n(true if we want to keep matches, false if we want to remove them) and applying\nsome logic to recognize that we want to </FONT><FONT FACE=\"Courier\"><TT>cons</TT></FONT><FONT FACE=\"Palatino\">\nthe first item onto the result of the recursive call if the test and the\nkeep-matches parameter are equal--both true or both false. </FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>(define handle-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160; (lambda (Rlist test? keep-matches)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; (cond</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;   ((null? Rlist) '())</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;   ((equal? keep-matches\n(test? (first Rlist)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;  &#160; (cons (first\nRlist)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;  &#160;  &#160; (handle-all-matches\n(rest Rlist) test? keep-matches)))</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160;   (else (handle-all-matches\n(rest Rlist) test? keep-matches)))))</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>(define find-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; (handle-all-matches\nRlist test? #t)))</TT></FONT>\n<BR><BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>(define remove-all-matches</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160; (lambda (Rlist test?)</TT></FONT>\n<BR>\n<FONT FACE=\"Courier\" SIZE=2><TT>&#160;&#160;  &#160; (handle-all-matches\nRlist test? #f)))</TT></FONT></LI>\n</UL>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}