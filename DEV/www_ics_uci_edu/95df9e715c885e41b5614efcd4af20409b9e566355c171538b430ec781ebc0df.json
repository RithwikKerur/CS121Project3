{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/inheritancei.txt", "content": "\t\t\t\tInheritance\r\n\r\nThis is the first of three lectures on inheritance. This lecture discusses the\r\ngeneral principles involved in defining classes in an inheritance hierarchy and\r\nusing the hierarchy to find attributes of objects (for both methods and data).\r\nIt focuses on the rules needed to understand SINGLE-inheritance, showing an\r\nexample using counters. The second lecture discusses multiple inheritance and\r\ngeneralizes these rules; it actually includes code that illustrates how class\r\nobjects (not objects constructed from classes aka instances) refer to each\r\nother in an inheritance hierarchy, and how attributes are found by Python in\r\ncomplicated inheritance hierarchies. The third lecture discusses various\r\nconcrete uses of inheritance (both single and multiple) and how we can use\r\ninheritance to simplify real programming.\r\n\r\nJust as inheritance (of money) makes the life of descendants easier, inheritance\r\n(of attributes: methods and data) makes writing derived (descendant) classes\r\neasier.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nClass Inheritance in Python\r\n\r\nAt present we know about defining classes and constructing objects that are\r\ninstances of classes (and assigning attributes in both a class and its\r\ninstances). We have explored various relationships between an object and the\r\nclass from which it was constructed (including adding attributes to objects\r\nafter they are constructed and adding attributes to classes after they are\r\ndefined).\r\n\r\nWe have studed the Fundamental Equation of Object-Oriented Programming (FEOOP)\r\nto determine how Python locates attributes for objects, mostly meaning how\r\nmethods are called on objects: by first trying to locate the attribute in the\r\nobject itself, and if that fails, locating the attribute in the class from\r\nwhich the object was constructed (passing the main object to self).\r\n\r\nObjects mostly store their own state attributes (data), while the classes they\r\nare constructed from mostly store their behavior attributes (methods): all the\r\nmethods are typically shared by all objects of that class. So, objects keep\r\ntheir own state but typically share the methods that operate on them; sometimes,\r\nthough, objects can store special methods that apply only to them. Also, class\r\nobjects can store state that is shared among its objects: recall the example\r\nof a person class storing a fingers attribute of 10, while individual people\r\nobjects can store a fingers attribute if they have fewer or more than 10\r\nfingers.\r\n\r\nTo get to full object-oriented programming, we must also learn how to define\r\nderived classes from base classes (aka create subclasses from superclasses)\r\nand learn how objects constructed from these derived/sub classes behave in\r\nregards to their inherited state and behavior: specifically, we will learn that\r\nall classes are defined in an inheritance hierarchy and learn how finding\r\nattibutes of objects is generalized:\r\n  1) looking for an attribute in the namespace of instance objects\r\n  2) looking for an attribute in the namespace of the class the object was\r\n       constructed from (we already aleady know these two rules)\r\n  3) searching the classes in the inheritance hierarchy, looking in the\r\n       namespaces of each, in turn, until the attribute is found or there are\r\n       no more classes to examine.\r\n\r\nFundamentally, what inheritance is about is writing small derived classes that\r\nreuse attributes from base classes in a natural way. The attribute location\r\nprocess is captured by augmenting the meaning of The Fundamental Equation of\r\nObject-Oriented Programming for class inheritance hierarchies. Below we discuss\r\na simple extension for single-inheritance, which is the most common kind of\r\ninheritance -the only kind available in Java; in the next lecture we will\r\ndiscuss the more complicated but complete extension for multiple inheritance.\r\n\r\nWe can define a trivial class with no state/behavior (not even an __init__\r\nmethod) in Python by writing just\r\n\r\n  class C:\r\n      pass\r\n\r\nNote the lack of parentheses after the class name C (just a colon). This means\r\nthat the class C is implicitly a class derived from the \"object\" class (yes,\r\nthere is a class named \"object\" in Python: try x = object() and print(x)); the\r\nobject class acts as the root (think trees) of Python's inheritance hierarchy.\r\nThe object class itself is defined in the builtins module and serves as the\r\nbase class, by default, for any classes defined with no explicitly specified\r\nbase class. It also contains import standard methods, like __setattr__.\r\n\r\nThe class C doesn't define any standard methods (e.g., __repr__, __setattr__,\r\netc.). Yet, we can call the repr function (which calls the __repr__ method) on\r\nobjects constructed from classes that don't define __repr___ and Python will\r\nstill find a __repr__ method to call. We can create attributes for objects\r\nconstructed from this class (e.g., o = C() and then o.a = 1) and Python will\r\nstill find a __setattr__ method to call. It can find these methods, because if\r\nwe do not define such methods in our classes, they are inherited; when we do\r\ndefine a method like __repr__ or __setattr__ in a derived class, it OVERRIDES\r\n(see this term defined and explained below) the  __repr__ or __setattr__\r\nmethods inherited from the \"object\" class. So, the standard  __setattr__ method\r\nthat we have studied is defined in the object class; it is called, because of\r\ninheritance, if we don't define a __setattr__ method in any class that we write.\r\n\r\nIf we want to specify one or more different base classes when defining a\r\nclass, we must put their names between the parentheses, separated by commas.\r\n\r\nSo, the meaning of class C: -with no parentheses- is the same as\r\n\r\n  class C(object):\r\n      pass\r\n\r\nIn both cases we illustrate the base/derived inheritance relationship with the\r\nsimple hierarchy: the derived class refers upward to its direct base class.\r\n\r\n    object\r\n       ^\r\n       |\r\n       C\r\n\r\nThere actually is a reference in the object representing the derived class C to\r\nthe object representing the base class \"object\", which we will use in the next\r\nlecture: the arrow's direction is meaningful: the derived class refers to the\r\nbase class it was derived from (not the other way around). Each class \"KNOWS\"\r\nits base class(es), but a class DOES not \"KNOW\" its derived class(es): the arrow\r\nis one way.\r\n\r\nNote that many other classes that we know inherit only from the object class\r\n(e.g., the standard date types list, set, and dict), and we shall soon see that\r\ndefaultdict inherits from dict, by actually examining its code). Here is how we\r\nshow the inheritance hierarchy of these classes as an N-ary tree, with object\r\nas its root.\r\n\r\n                 object\r\n              ^     ^     ^\r\n             /      |      \\\r\n           list    set    dict\r\n                           ^\r\n                           |\r\n                      defaultdict\r\n\r\nIf we use only single-inheritance the resulting inheritance hierarchy is an\r\nN-ary tree (a generalization of binary tree) with object at its root. Derived\r\nclasses are children of their base classes. Note that the derived classes can\r\nthemselves be base classes of other derived classes (e.g., dict is a class\r\nderived from object, but a base class from which defaultdict is a derived\r\nclass). Eventually (tracing upward from any class towards the root of the\r\ninheritance hierarchy) following arrows from a derived class to its base class\r\nwill lead upward in the inheritance tree until the root (the class \"object\") is\r\nreached. The situation gets a bit more complicated when multiple-inheritance is\r\nallowed (more details in the next lecture).\r\n\r\nSo in this lecture we will being seeing class definitions like\r\n\r\n  class Derived_Class(Base_Class):\t\t\t# single-inheritance\r\n\r\nand in the next lecture like\r\n\r\n  class Derived_Class(Base_Class1, Base_Class2, ...):\t# multiple-inheritance\r\n\r\nMany languages support just single-inheritance (a derived class can have only\r\none direct base class: Java and Smalltalk are examples of such languages) but\r\nPython (like C++) supports multiple inheritance: a derived class can have many\r\ndirect base classes. Once we understand the general principle of locating\r\nattributes in a single-inheritance hierarchy, we can generalize the look-up\r\nrules for multiple-inheritance hierarchies.\r\n\r\nFinally, note an asymmetry: a derived class specifically states the name of\r\n(and refers to) its base classes, but a base class says nothing about (and\r\ndoesn't refer to or know anything about) its derived classes. There is no way\r\nfor a base class to know what derived classes will inherit from it: the\r\ninheritance mechanism (for locating attributes) allows derived classes to\r\naccess attributes in their base classes, but base classes cannot access\r\nattributes in their derived classes.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe Fundamental Equation of Object-Oriented Programming\r\n(generalized, but in this lecture only for single-Inheritance)\r\n\r\nAt present we know that instance objects refer to the class objects they are \r\nconstructed from, and we can use the type function on any instance to return a\r\nreference to the class object that it was constructed from. When we look up an\r\nattibute of an instance, Python first looks for the attribute in the namespace\r\nof the instance object itself, but it if doesn't find the attribute there, it\r\nlooks for the attribute in the class the object was constructed from. We\r\ncaptured this rule in the Fundamental Equation of Object-Oriented Programming\r\n(shown again below) in its current form, but soon expanded for inheritance.\r\n\r\nSo, if \"m\" is a method (or \"a\" is any attribute), we have seen that if the\r\nmethod/attribute IS NOT stored directly in o's namespace/__dict__, accessing it\r\nis equivalent to trying to access\r\n\r\n  o.m(...) -> type(o).m(o,...) method attributes (staticmethods omit o argument)\r\n  o.a      -> type(o).a        data attributes\r\n\r\nWhen locating a method attribute for instance o, if it is not found in o itself\r\n(and it typically isn't) Python uses the attribute in the type(o) class: the\r\nclass o was constructed from, calling that method with o as the first argument\r\n(which is why non-static methods in classes all are defined to have their first\r\nparameter, typically named self; FEOOP for static methods omits o as this first\r\nargument when it translates the call). By this mechanism, an object doesn't\r\nneed to store in its own namespace all the methods that operate on it. Those\r\nmethods can be stored (and shared) in the class object for each instance object,\r\nand located there as needed by FEOOP.\r\n\r\nThis mechanism works for non-method attributes too: if any data attribute is not\r\nfound in the instance object's namespace (although state is typically found\r\nin the instance object), Python will try to locate it by using the namespace of\r\nthe class the instance object was constructed from. So, it is possible for\r\nobjects to share data in its class's namespaces, just as methods are shared.\r\n\r\nWe have seen that a useful example of data sharing might occur in a Person\r\nclass. Suppose that we need to store how many fingers every Person (object\r\nconstructed from that class) has. We could store this information by adding an\r\nattribute to every Person object (e.g., person1.fingers = 10). But the vast\r\nmajority of people have 10 fingers, so we could store Person.fingers = 10 (an\r\nattribute in the Person class). Now if we don't store the fingers attribute in\r\nthe person1 object, it will be found in the Person class object, with value 10.\r\nIf person1 has fewer than 10 fingers, we can store person1.fingers = 9; now,\r\nfor person1, the fingers attribute will be found in the object itself, not in\r\nits class. Using this approach, we can save space by storing the fingers\r\nattribute only for people not having 10 fingers (likely to be a small\r\npercentage of all the people objects), although it takes two steps to find it:\r\nlooking in the object's namespace (and failing) and then looking in the class's\r\nnamespace. If the fingers attribute is found in the person1 object, then\r\nthe Person class object is not searched. What would happen if we somewhere\r\nexecuted Person.fingers += 1? Any data that should be \"shared\" by all the\r\nobjects in a class should be stored in the namespace of their class.\r\n\r\nWe now generalize this look up mechanism for single-inheritance hierarchies:\r\n\r\n 1) Python first tries to find the attribute in the instance object.\r\n\r\n 2) If Python fails, it next tries to find the attribute in the class object\r\n      from which the instance was constructed (the type function provides this\r\n      information: we can compute the class from which any objects is\r\n      constructed).\r\n\r\n 3) If Python fails, it tries to find the attribute in the base class of the\r\n      class from which the instance was constructed;\r\n\r\n 4) If Python fails, it next tries to find it in the base class of that class,\r\n      ... and continues until it reaches the object class at the root of the\r\n      inheritance hierarchy.\r\n\r\n 5) If Python fails to find the attribute in the object class, it calls\r\n      __getattr__ in the original class of the object (and if it is not there,\r\n      it repeats searching for that method in the hierarchy). The object class\r\n      at the root of the hierarchy defines __getattr__ to raise an\r\n      AttributeError exception.\r\n\r\nPictorally, where Python looks for an o.attribute\r\n\r\n                                     object                <-- looks here last\r\n                              (root of hierarchy)\r\n                                        ^\r\n                                        |\r\n                                       ...\r\n                                        ^\r\n                                        |\r\n                                      class\t\t   <-- looks here 3rd\r\n                                        ^\r\n                                        |\r\nLook here 1st -->      o    -->       class\t\t   <-- looks here 2nd\r\n                  (instance)   (o constructed from)\r\n                                        ^\r\n                                        |\r\n                                      class\t\t   <-- doesn't look here\r\n                                        ^\r\n                                        |\r\n                                      class\t\t   <-- doesn't look here\r\n\r\n\r\nNote that classes derived from the class o is constructed from (shown below o's\r\nclass) are not searched; searching is only sideways from o to the class it was\r\nconstructed from and then upward towards the \"object\" class\r\n\r\n------------------------------------------------------------------------------\r\n\r\nA very simple but representative example of Inheritance\r\n\r\nExamine the following two simple classes (which are in the counters.py module\r\nthat you can download with this lecture). We can examine and use the Counter\r\nclass by itself (it is a fully working class), but Counter also acts as the\r\nbase class of the derived Modular_Counter class. Together, most interesting\r\nissues concerning single inheritance can be illustrated simply in these two\r\nclasses, in which Counter is the base class and Modular_Counter is the derived\r\nclass.\r\n\r\nclass Counter:                   # implicitly use object as its base class\r\n    hierarchy_depth = 1\t\t # object is at depth 0, Counter is 1 beneath it\r\n    counter_base = 0  \t\t # track how often Counter.__init__ is called\r\n\r\n    def __init__(self,init_value=0):\r\n        assert init_value >= 0,\\\r\n            'Counter.__init__ init_value('+str(init_value)+') < 0'\r\n        self._value = init_value\r\n        Counter.counter_base += 1    # Increment class variable on __init__ call\r\n\r\n    def __str__(self):               # str of Counter is str of its _value\r\n        return str(self._value)\r\n        \r\n    def reset(self):                 # reset of Counter assigns _value = 0\r\n        self._value = 0\r\n        \r\n    def inc(self):                   # inc(rement) of Counter increments _value\r\n        self._value += 1\r\n        \r\n    def value_of(self):              # value_of Counter is _value (an int)\r\n        return self._value\r\n\r\nHere __str__ and value_of are queries; reset and inc are commands. As we will\r\nsee below, we supply such methods so that we never need to directly refer to\r\nthe data attributes in a Counter object. Instead we refer to these Counter\r\nmethods. Note in the Modular_Counter class we never directly refer to these\r\ndata attributes.\r\n    \r\nclass Modular_Counter(Counter): # explicitly use Counter as its base class\r\n    hierarchy_depth = Counter.hierarchy_depth + 1 # 1 more than Counter's depth\r\n    counter_derived = 0         # how many times Modular_Counter.__init__ called\r\n\r\n    def __init__(self,init_value,modulus):\r\n        assert modulus >= 1,\\\r\n            'Modular_Counter.__init__ modulus('+str(init_value)+') < 1'\r\n        assert 0 <= init_value < modulus,\\\r\n            'Modular_Counter.__init__ init_value('+str(init_value)+') not in [0,'+str(modulus)+')'\r\n        Counter.__init__(self,init_value)\r\n        self._modulus = modulus\r\n        Modular_Counter.counter_derived += 1    \r\n    \r\n    def __str__(self):\r\n        return Counter.__str__(self)+' mod '+str(self._modulus)\r\n        \r\n    # Note, calling self.value_of() and self.reset() is equivalent to (and\r\n    #   preferred to) calling Counter.value_of(self) and Counter.reset(self)\r\n    # But it is critical that Counter.inc(self) is called that way, because\r\n    #   calling self.inc() would be an infinitely recursive call to inc.\r\n    def inc(self):\r\n        if self.value_of() == self._modulus - 1:\r\n            self.reset()\r\n        else:\r\n            Counter.inc(self)\r\n        \r\n    def modulus_of(self):\r\n        return self._modulus\r\n\r\nThe main script at the bottom of the module creates Counter and Modular_Counter\r\nobjects and then allows the user to type in commands using the names c and\r\nmc (including defining new/more names). You can put more code down there using\r\nc and mc, or enter commands that are executed by calling the exec function.\r\n\r\nif __name__ == '__main__':\r\n    import prompt\r\n\r\n    c = Counter(0)\r\n    mc = Modular_Counter(0,3)\r\n\r\n    while True:\r\n        try:\r\n            exec(prompt.for_string('Command'))\r\n        except Exception as report:\r\n            import traceback\r\n            traceback.print_exc()\r\n\r\n----------\r\n\r\nThe Counter base class\r\n\r\nFirst we will discuss the Counter class, and then discuss the Modular_Counter\r\nclass, which is derived from the Count base class.\r\n\r\nThe Counter class defines two class attributes that are shared by all Counter\r\nobjects: hierarchy_depth, which doesn't change, and counter_base which is\r\nincremented each time __init__ is called. The Counter class also stores the\r\nclass method names __init__, __str__, reset, inc, and value_of.\r\n\r\n(1) hierarchy_depth is an int representing the depth of the Counter class in\r\nthe N-ary inheritance tree: it is 1, because it is below the root of the tree,\r\nthe object class (which has depth 0).\r\n\r\n(2) counter_base is an int that counts how many times __init__ is called in the\r\nCounter class. Counter's __init__ is called when we construct Counter objects,\r\nbut we also see that it is called when we construct Modular_Counter objects\r\n(see definition below, which calls Counter.__init__ explicitly): it is common\r\nfor the __init__ method in the derived class to call the __init__ method in its\r\nbase class (base classes -plural- for multiple inheritance).\r\n\r\n(3) __init__ initalizes each Counter object to have one piece of state: an int\r\nthat is always (so it must start) >= 0 representing the counter's value. It\r\nverifies this property of init_value first, and then increments counter_base.\r\n\r\nSo, understand the following difference: the Counter class object stores the\r\nhierarchy_depth and counter_base attributes (as well as all the other method\r\nattributes). Each object constructed from the Counter class stores its own\r\n_value attribute (and shares the attributes in the Counter class through use of\r\nthe Fundamental Equation of Object-Oriented Programming).\r\n\r\n(4) __str__ is a query that returns a string representing the Counter object's\r\n_value attribute.\r\n\r\n(5) reset is a command that resets the Counter object's _value attribute to 0.\r\n\r\n(6) inc is a command that increases the Counter object's _value attribute by 1.\r\n\r\n(7) value_of is a query that returns the _value attribute of the Counter object.\r\nThe difference between (4) and (7) is that (4) returns a str -typically for\r\nprinting- while (7) returns an int -typically for using with arithmetic and\r\nrelational operators.\r\n\r\nUsing the code in main, we can construct and experiment with objects from the\r\nCounter class: looking up state/calling methods on c (an object already\r\nconstructed in the code) or constructing more Counter objects and doing the\r\nsame on them. For example, try\r\n\r\nc = Counter(0) \t    \t # OK\r\n\r\n                        type\r\n Counter         (------------------)\r\n  +---+          |  hierarchy_depth |      int\r\n  | --+--------->| +------+         |     (---)\r\n  +---+          | |   ---+---------+---->| 1 |\r\n                 | +------+         |\t  (---)\r\n                 |                  |\r\n                 |  counter_base    |      int\r\n                 | +------+         |     (---)\r\n                 | |   ---+---------+---->| 0 |\r\n                 | +------+         |\t  (---)\r\n                 |                  |\r\n                 |                  |\r\n                 |  __init__        |    function\r\n                 | +------+         |     (---)\r\n                 | |   ---+---------+---->|   |\r\n                 | +------+         |\t  (---)\r\n                 |                  |\r\n                 |  ... all the     |\r\n                 |  other methods   |\r\n                 |                  |\r\n                 (------------------)\r\n\r\n                  Counter\r\n   c            (----------)\r\n +---+          |  _value  |      int\r\n | --+--------->| +------+ |     (---)\r\n +---+          | |   ---+-+---->| 0 |\r\n                | +------+ |\t (---)\r\n                (----------)\r\n\r\nprint(c.hiearchy_depth)\t # prints 1 (because c = ...; FEOOP for data attribute)\r\nprint(c.counter_base)\t # prints 1 (because c = ...; FEOOP for data attribute)\r\n\r\nc.inc()\t\t\t # OK; uses FEOOP to call method attribute\r\nc.inc()\t\t\t # OK; uses FEOOP to call method attribute\r\nc.inc()\t\t\t # OK; uses FEOOP to call method attribute\r\n\r\nprint(c)\t\t # prints 3 via calling str/__str__ on c, using FEOOP\r\nprint(c.value_of())\t # prints 3 via calling str(c.value_of()), using FEOOP\r\n\r\n\r\n----------\r\n\r\nThe Modular_Counter derived class\r\n\r\nNow we will discuss the Modular_Counter class, a speciialization of the Counter\r\nclass: a Modular_Counter IS-A special kind of Counter. Generally, class B should\r\nbe derived from class A if B IS-A special kind of A (e.g., a defaultdict IS-A\r\nspecial kind of dict). We will classify every Class attribute usable in the\r\nderived class as\r\n\r\n(a) a new attribute defined in the derived class: not an inherited attribute\r\n\r\n(b) an inherited attribute: not defined/overridden in the derived class\r\n\r\n(c) an inherited attribute: (re)defined in the class OVERRIDING an inherited one\r\n\r\nThese last two options rely on an understanding of what it means for a derived\r\nclass to override an inherited attribute. A derived class overrides an inherited\r\nattribute if it defines an attribute (using the same name) as an attribute it\r\ninherits: one already defined in its base class, the base class of its base\r\nclass, etc. all the way back to the object class at the root of the inheritance\r\nhierarchy (which defines lots of double-underscore methods).\r\n\r\nWhen we describe the Modular_Counter class below, we will discuss all of its\r\ndefined attributes in these terms. Generally a modular counter IS-A special\r\nkind of counter. In fact, derived classes are typically specializations of base\r\nclasses: for inheritance to be natural, all operations on the base class must\r\nMAKE SENSE on the derived class too, although the derived class may change\r\nthe MEANING OF (override) some of the inherited attributes; of course, it can\r\nalso define new attributes.\r\n\r\nSo a base class and its derived class are in an IS-A relationship. The derived\r\nclass IS-A special kind of base class: The Modular_Counter is a special kind of\r\nCounter, where all the operations on Counter objects also make sense on\r\nModular_Counter counter objects: some are done the same (inherited, like reset)\r\nand some are done differently (overridden, inc).\r\n\r\nModular counters can store values between 0 up to but not including the modulus\r\n(so the biggest a value can get is modulus-1): think of a counter for strikes\r\nin baseball as a modulus 3 counter. A batter goes from 0 strikes to 1 strike\r\nto 2 strikes to being out, with the next batter starting again back at 0\r\nstrikes. Or the digits in a car odometer go from 0 to 9 and then back to 0 again\r\n(with a carry-over to the next digit) so each digit is a modulus 10 counter.\r\n\r\nThe Modular_Counter class defines two attributes: hierarchy_depth is (c), which\r\ndoesn't change; counter_derived is (a) which is incremented in __init__); the\r\nclass method named __init__ is (c), __str__  is (c), inc is (c), and modulus_of\r\nis (a). It also inherits and does not override the attributes counter_base,\r\nreset, and value_of (all are b).\r\n\r\n(1) hierarchy_depth is an int representing the depth of the Modular_Counter\r\nclass in the N-ary inheritance tree: it is 2, because it is derived from the\r\nCounter class, whose depth is 1.\r\n\r\n(2) counter_derived is an int that counts how many times __init__ in the\r\nModular_Counter class is called (in this two-class hirerarchy, it is called\r\nonly when we construct Modular_Counter objects).\r\n\r\n(3) __init__ initalizes each Modular_Counter object to have two pieces of state:\r\nfirst, an int that remains unchanged and must be >= 1 representing the\r\ncounter's modulus; second, an int that is always (so it must start) >= 0 and\r\nstictly < the modulus, representing the module counter's value. The __init__\r\nverifies these properties of modulus and init_value first, and increments\r\ncounter_derived. Note that THE _value ATTRIBUTE IS NOT DIRECTLY DEFINED IN THIS\r\n__init__ METHOD, but instead it is defined in the instance object when\r\n__init__ calls Counter.__init__ on this object (which adds to its attributes).\r\nThe self object is passed along to Counter's __init__ where it is updated (by\r\nadding the _value attribute to its namespace).  Overriding methods often call\r\nthe same named method in their base classe (the overridden one) to help get\r\ntheir job done.\r\n\r\n(4) __str__ is a query that returns a string representing the Modular_Counter\r\nobject's _value attribute, by calling Counter.__str__(self) concatenated with\r\nthe word ' mod ' and the string equivalent of the modulus attribute. Overriding\r\nmethods often call the method they override to help them get their job done.\r\n\r\n(5) inc is a command that resets the Modular_Counter object's _value attribute\r\nto 0 if the current value is one less than the modulus, otherwise it increments\r\nthe Modular_Counter's _value attribute by 1, by calling Counter.inc(self). In\r\nthis way the _value attribute is still always >= 0 and < the _modulus attribute.\r\nOverriding methods often call the method they override to help them get their\r\njob done.\r\n\r\n(6) modulus_of is a query that returns the _modulus attribute of the\r\nModular_Counter object.\r\n\r\n(7) The methods reset and value_of are inherited directly from the Counter\r\nclass. When called on a Modular_Counter object, these attributes are not found\r\nin the Modular_Counter class, but are found in the Counter class (using our\r\nrevised look-up rules explained above).\r\n\r\nGenerally in programming, the methods in a class should refer to a state\r\nattribute (e.g., a.o) ONLY IF IT IS DEFINED IN THAT SAME CLASS. That is why in\r\nModular_Counter's __init__, _value is not defined directly, but is instead\r\ndefined/initialized  by calling Counter's __init__; it is also why\r\nModular_Counter's inc method calls the inherited methods reset, inc, and\r\nvalue_of, instead of directly manipulating its _value attribute.\r\n\r\nIn this approach, we consider state names to be private and should be used only\r\nwithin the class that is responsible for defining and manipulating those\r\nattribute. It is that class that ensures the integrity/invariant of that\r\nattribute.\r\n\r\nIn contrast, generally method names are considered public and usable with any\r\nobject (unless they start with  _ or __).\r\n\r\nBecause we can refer to all the state and behavior attributes in Python, Python\r\nprogrammers don't always follow this rule (although we have seen how to use\r\n__setattr__ to disallow rebinding an attribute in an object). Java and C++\r\nprogrammers must define each attribute as public (usable anywhere) or private\r\n(usable only within the class in which it is defined) and the computer ensures\r\nand enforces that private attributes are examined/changed only in the class\r\nthat defines them (there are other, more subtle options in these languages).\r\n\r\n----------\r\n\r\nConstructing an Object from a Derived Class\r\n\r\nWhen we call Modular_Counter(0,3) -or just Modular_Counter(modulus=3)- Python\r\nconstructs an instance object whose class/type is Modular_Counter; this instance\r\nobject starts with an empty namespace (dictionary). It checks the 2 assertions\r\nabout the arguments: both are True, so Python calls\r\nCounter.__init__(init_value).\r\n\r\nCounter.__init__ checks its assertion: it is True, so it adds the binding _value\r\nto the namespace of the constructed Modular_Counter object passed to self and\r\nbinds it to init_value (here 0); it also increments Counter.counter_base: the\r\nattribute counter_base defined in the Counter class object\r\n\r\nThen, returning to Modular_Counter.__init__ Python adds the binding _modulus to\r\nthe namespace of the constructed Modular_Counter object (so this object now has\r\ntwo attributes in its dictionary: _value and _modulus) and binds it to the\r\nmodulus (here 3); it also increments Modular_Counter.counter_derived: the\r\nattribute counter_derived defined in the Modular_Counter class object.\r\n\r\nSo, at this point the newly constructed Modular_Counter object stores two data\r\nattributes (_value -storing 0- and _modulus -storing 3), the Counter class\r\nobject itself stores two data attributes (hierarchy_depth (storing 1) and\r\ncounter_base (storing 1), along with all its method attributes), and the\r\nModular_Counter class object stoes two data attributes (hierarchy_depth\r\n(storing 2) and counter_derived (storing 1), along with all its method\r\nattribues).\r\n\r\nNote that executing x = Modular_Counter(0,3) means type(x) is Modular_Counter;\r\nwhile executing x = Counter(0) means type(x) is Counter. The type function\r\nalways returns the class object from which any instance object is constructed.\r\n\r\n----------\r\n\r\nAvoiding Infinite Recursion in Methods called defined in Derived Classes\r\n\r\nNote carefully the __str__ method defined in the Modular_Counter class\r\noverrides the __str__ method this class inherits from the Counter class.\r\n\r\n    def __str__(self):\r\n        return Counter.__str__(self)+' mod '+str(self._modulus)\r\n\r\nSuppose we define x = Modular_Counter(0,3). Then the Fundamental Equation of\r\nObject-Oriented Programming tells us str(x) is executed as x.str() which is\r\nexecuted as type(x).__str__(x) or Modular_Counter.__str__(x). Which executes\r\nCounter.__str__(x)+... which returns '0'+....\r\n\r\nNow, what would happen if we instead defined\r\n\r\n    def __str__(self):\t\t\t\t\t# WRONG\r\n        return str(self)+' mod '+str(self._modulus)     # WRONG\r\n\r\nHere, str(self) is still executed as self.__str__() which is still executed as\r\ntype(self).__str__(self) or Modular_Counter.__str__(self). So the body of this\r\nfunction calls str(self) which is executed again as type(self).__str__(self) or\r\nModular_Counter.__str__(self) so we have created infinite recursion with this\r\nchange.\r\n\r\nSo generally, in a method that OVERRIDES an INHERITED method, if we want to\r\ncall the INHERITED method inside it, we must preface it with the class in which\r\nthe inherited method is to be called. This was also done in the call to inc in\r\nthe Modular_Counter's inc method. Notice that it was not done for the call to\r\nreset, which appears as just self.reset(); the reason is that the reset method\r\nis inherited from the Counter class but is NOT OVERRIDDEN in Modular_Counter,\r\nso when making a call to reset on a Modular_Counter object, Python finds that\r\nthe reset attribute is NOT in the Modular_Counter class, but then in the next\r\nstep it looks and does find the reset attribute in the Counter class, so it\r\ncalls that method. This is all by the augmented Fundamental Equation of Object-\r\nOriented Programming rule.\r\n\r\n-----super start\r\n\r\nIn Python 3, we can also call super() to call a method in the base class\r\nimplicitly:\r\n\r\n    def __str__(self):\r\n        return super().__str__()+' mod '+str(self._modulus)\r\n\r\nNote that in this case using super automatically provides the self argument to\r\nthe method call.\r\n\r\nI prefer refering to Counter.__str__ explicitly. But by using super(), if we\r\nchange the base class of Modular_Counter (say to New_Counter), the call to\r\nsuper().__str__ would still be correct: we wouldn't have to also change\r\nCounter.__str__ to the New_Counter.__str__. I still prefer writing in the\r\nspecific base class for beginners.\r\n\r\n----super end\r\n\r\nLet us predict (and verify) what is printed (and why) in the following code.\r\n\r\nc = Counter(0) \t    \t    \t # OK\r\nm = Modular_Counter(0,3)\t # OK\r\n\r\n                  Counter\r\n   c            (----------)\r\n +---+          |  _value  |      int\r\n | --+--------->| +------+ |     (---)\r\n +---+          | |   ---+-+---->| 0 |\r\n                | +------+ |\t (---)\r\n                (----------)\r\n\r\n               Modular_Counter\r\n   m            (----------)\r\n +---+          |  _value  |      int\t  The Modular_Counter object has two\r\n | --+--------->| +------+ |     (---)    attributes: _value defined in\r\n +---+          | |   ---+-+---->| 0 |    Counter.__init__ and _modulus defined\r\n                | +------+ |\t (---)    in Modular_Counter.__init__, which\r\n                |          |\t \t  calls Counter.__init__\r\n                | _modulus |      int\r\n\t\t| +------+ |     (---)\r\n                | |   ---+-+---->| 3 |\r\n                | +------+ |\t (---)\r\n                (----------)\r\n\r\nprint(c.hiearchy_depth)\t\t # 1 - class attribute in Counter\r\nprint(c.counter_base)\t\t # 2 - ditto - (from both c = ... and m = ...)\r\nprint(c.counter_derived)\t # AttributeError exception\r\n\r\nprint(m.hiearchy_depth)\t\t # 2 - class attribute in Modular_Counter\r\nprint(m.counter_base)\t\t # 2 - ... in Counter- (same as c.counter_base)\r\nprint(m.counter_derived)\t # 1 - ... in Modular_Counter- (from only m = ...)\r\n\r\nc.inc()\t\t\t\t # OK - method: class attribute in Counter\r\nc.inc()\t\t\t\t # OK - method: class attribute in Counter\r\nc.inc()\t\t\t\t # OK - method: class attribute in Counter\r\n\r\nprint(c.value_of())\t\t # 3  - method: class attribute in Counter\r\nprint(c.modulus_of())\t\t # AttributeError exception\r\n\r\nm.inc()\t\t\t\t # OK - method: class attribute Modular_Counter\r\nm.inc()\t\t\t\t # OK - method: class attribute Modular_Counter\r\nm.inc()\t\t\t\t # OK - method: class attribute Modular_Counter\r\n\r\nprint(m.value_of())\t\t # 0 - method: class attribute in Counter\r\nprint(m.modulus_of())\t\t # 3 - method: calss attribute Modular_Counter\r\n\r\nYou should completely understand this example for the upcoming quiz and final\r\nexam.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nInheritance Design Rules\r\n\r\nIn languages like Java/C++, if a class adds a data attribute (state) to an\r\nobject (mostly in __init__) then only THAT class is allowed to access that state\r\ndirectly as an attribute. That is, if x = C() and C's __init__ contains\r\nself.a = ... then if any other class contains contains code that attempts to\r\nrefer to x.a or rebind x.a (e.g., x.a = ....) it will raise an exception.\r\nPython does NOT have this restriction, but it is still considered bad design\r\nform to write such accesses/rebinding in any other class, but the one that\r\ndefines the attribute.\r\n\r\nTo solve this problem, each class should define methods to access/set all the\r\nattributes it defines. That is why in there are reset/inc/value_of methods in\r\nthe Counter class: so the Modular_Counter class can examine/update the _value\r\nattribute defined in Counter, without explicitly writing self._value in\r\nModular_Counter. So,\r\n\r\n1) If a class adds an attribute to an object (e.g., in __init__) then methods\r\ndefined in only that class should access the attribute directly by name.\r\n\r\n2) If other classes (including derived/subclasses) need to access/update the\r\ninformation stored in that attribute, then the class defining the attribute\r\nshould also define METHODS that do these jobs, which the other class should\r\ncall..\r\n\r\nWe can summarize these rules as, \"Python allows any code to access all the\r\nattributes in an object by writing self.attribute.  But we should USE SELF\r\nCONTROL\". Here \"self control\" means don't access the attributes defined in\r\nother classes by writing self.attribute; instead call the appropriate method to\r\naccess the attribute (which may be by writing self.method() or Class.method()).\r\n\r\nSome languages use the terms accessors/getters for methods that return the\r\nvalue of such attributres, and mutators/setters for methods that rebind an\r\nattribute to refer to a different value. The Counter class does not allow us\r\nto arbitrarily set the _value attribute: we have methods only to set it to 0\r\nor increment it by 1.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n\r\n1) Decribe what happen using the following defintions and code\r\n\r\nclass B:\r\n    def __init__(self):\r\n        self.a = 1\r\n\r\nclass D:\r\n    def __init__(self):\r\n        self.a = 2\r\n\r\nb = B()\r\nd = D()\r\nprint(b.a)\r\nprint(d.a)\r\n\r\n2) Suppose that we define the __str__ method in the Counter class to return a\r\nstring representing value as a roman numeral; what will the statments\r\nprint(Modular_Counter(2,3)) print? \r\n\r\n3) Suppose that we define the print_it method in the Counter class as follows:\r\n\r\n    def print_it(self):\r\n        print(self.__str__())\r\n\r\nWhat is the result of defining c = Counter(0) and c.print_it(); same for\r\nmc = Modular__Counter(0,3) and mc.print_it()? Does defining print_it as follows\r\nchange the result printed? Explain how each determines what value to print and\r\nwhat value it prints.\r\n\r\n    def print_it(self):\r\n        print(str(self))\r\n\r\n\r\n4) Define __repr__ functions in Count and Modular_Counter classes.\r\n\r\n5) Suppose that we defined\r\n\r\n l = [counter(0), Modular_Counter(0,3), Modular_Counter(0,3), Counter(0)]\r\n\r\nWhat would be printed if we executed the code \r\n\r\nfor i in range(3):\r\n    for c in l:\r\n        c.inc()\r\nprint(l)\r\n\r\n6) Examine the the following defintions and executable code.\r\n\r\nclass Base:\r\n    def m1(self):\r\n        print('m1 in Base')\r\n    \r\n    def m2(self):\r\n        print('m2 in Base')\r\n        self.m1()\r\n        \r\nclass Derived(Base):\r\n    def m1(self):\r\n        print('m1 in Derived')\r\n    \r\n    def m2(self):\r\n        print('m2 in Derived')\r\n        Base.m2(self) # or the call super().m2()\r\n\r\no = Derived()\r\no.m2()\r\n\r\na) Which of the following three lines does it print?\r\n\r\nm2 in Derived\r\nm2 in Base\r\nm1 in Base\r\n\r\nor \r\n\r\nm2 in Derived\r\nm2 in Base\r\nm1 in Derived\r\n\r\nb) What changes could be make to these classes to get it\r\nto print the other three lines?\r\n", "encoding": "ascii"}