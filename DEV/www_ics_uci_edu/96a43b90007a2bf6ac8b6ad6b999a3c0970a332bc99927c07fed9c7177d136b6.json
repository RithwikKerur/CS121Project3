{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/writingclasses/writingclasses.txt", "content": "\t\t\t\tWriting Classes\r\n\r\nEvery value object in Python is an instance of a class: for example, the value\r\nobject 'abc' is an instance of the str class. If o is a name that refers to a\r\nvalue object, then type(o) refers to the class that value object is an instance\r\nof (the class the value object was constructed from). Type('abc') is str, as is\r\ntype (s) if s = 'abc'.\r\n\r\nIn this lecture we will primarly learn about instance names, which are defined\r\nin the namespace/dictionary of a value object; and learn about method names,\r\nwhich are defined in the namespace of a class. Specifically, we will learn how\r\nto initialize instance names in the __init__ method defined in a class, and how\r\nto manipulate (both examine and update) instance names in other methods defined\r\nin a class. In a large sense, these two features are what writing a class is\r\nall about. In the process we will learn about special names preceded by one or\r\ntwo underscore characters.\r\n\r\nWe will continue to use the Dice class as our primary example. All of the\r\nknowledge we need to gain about classes can be observed and discussed in this\r\nclass, which uses its information in a relatively straightforward way. We have\r\nseen that to construct a Dice object modeling two 6-sided dice, we can define\r\n\r\nd = Dice([6,6])\r\n\r\nWhen we construct a value object from a class, as above, we treat the name of\r\nthe class like a function and we call it, passing it arguments (in this example,\r\none argument: the list [6,6]). Python does three things to construct a value\r\nobject:\r\n\r\n(1) It calls a special function that creates a value object (that is the\r\n    instance of the class we are constructing. Note that this object\r\n    automatically has an empty namespace associated with it: no names.\r\n\r\n(2) It calls the special __init__ method for the class, passing the empty object\r\n    created in (1) to the first parameter (always named self) of __init__, and\r\n    following this argument with all the other arguments used in the call to\r\n    construct this instance. This special method checks the arguments, and if\r\n    they are OK, uses them to initialize the namespace of the value object.\r\n    In summary, the __init__ method defines and initializes instance names\r\n    in a value object's namespace.\r\n\r\n(3) A reference to the object that was created in (1) and initialized in (2) is\r\n    returned as the result of constructing the object. Typically such a\r\n    reference is either bound to a variable or passed to a function call: e.g.,\r\n    defining d = Dice([6,6]) or calling experiment(Dice([6,6]), 100000) are\r\n    uses of .\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe __init__ method\r\n\r\nGenerally any method lead and followed by two underscores is a special method\r\nthat Python will call automatically in certain circumstances (we can, but\r\ngenerally don't call such methods directly). In classes, __init__ is the\r\ncritical method to understand, and we describe it now (and describe __str__ and\r\n__repr__ later; ICS-33 describes dozens of such methods).\r\n\r\nThe dice class defined its __init__ method as follows. Let's follow how Python\r\nexecutes the __init__ methods for Dice([6,6]).\r\n\r\ndef __init__(self : Dice, max_pips : [int]):\r\n    assert len(max_pips) >= 1, 'Dice.__init__: max_pips is empty'\r\n    for i in range(0,len(max_pips)):\r\n        p = max_pips[i]\r\n        assert p >= 1, 'Dice.__init__: max_pips['+str(i)+']='+str(p)+': must be an int >= 1'\r\n    self._max_pips   = max_pips[:]       #Copy to avoid aliasing\r\n    self._pips      = [0]*len(max_pips)\r\n    self._roll_count = 0\r\n\r\nBy (1) Python creates a value object with a empty namespace\r\n\r\nBy (2) Python calls the __init__ method defined in the Dice class, passing the\r\nnew value object it created to the first parameter (always named self) and the\r\nlist [6,6] to the second parameter named max_pips. Recall len(max_pips)\r\ndetermines how many dice (here, 2) and the values in the max_pips list\r\ndetermines how many sides are on each die (here, 6 and 6). Now Python executes\r\nthe body of this method to ultimately define and initialize instance names in\r\nthis value object.\r\n\r\nThe first four statements in __init__ check that max_pips is a reasonable list:\r\n\r\n  (a) The list must contain at least 1 value (at least one die)\r\n  (b) Every value is the list must be at least 1 (at least one side on that die)\r\n\r\nIf any of these assertions are False, Python raises an AssertionError exception\r\nand does not complete executing the __init__ method: it cannot successfully\r\ncreate a Dice object with bad arguments. Note that I could have simplified the\r\nloop and written it as follows (iterating over list values not list indexes)\r\n\r\n    for p in max_pips:\r\n        assert p >= 1, 'Dice.__init__: str(p)+': must be an int >= 1'\r\n\r\nBut with this code, the error message couldn't contain the index in the\r\nmax_pips list at which the first illegal value was found; it would still show\r\nthe value itself.\r\n\r\nMany __init__ methods verify that a parameter has received a legal and\r\nreasonable argument value, and raise an exception to indicate that the object\r\nbeing constructed cannot be initialized properly. Sometimes it raises an\r\nexception explicitly, using an if statement that tests for an illegal value.\r\nSometimes it uses an assert statement to check for an illegal value.\r\n\r\nOnce these assertions all succeed, there are three statements that define names\r\nin the namespace of the this object and initialize them appropriately. This is\r\nsimilar to defining/initializing a name in another module: e.g., \r\n\r\n  import m \t\t# access module m\r\n  m.x = 1\t\t# define a name x in module m and intialize it to 1\r\n\r\nAll these instance names start with an underscore: _max_pips, _pips, and\r\n_roll_count. Generally starting an instance name with an underscore in Python\r\nis a convention that indicates that only methods in the class should access\r\nthis name. Most (often all) instance should start with an undersscore. We will\r\nexamine how to access names in value object later, when we discuss other\r\nmethods defined in the class.\r\n\r\nself._max_pips = max_pips[:]\r\n\r\nbinds the name _max_pips (in the self object) to a copy of the parameter list.\r\nBy coping the parameter list, we can ensure that a user cannot \"mess up\" this\r\nname by mutating a shared object. Such a \"mess up\" is impossible when a literal\r\n[6,6] is passed in, but avoids the following problem. If we wrote\r\n\r\n  l = [6,6]\r\n  d = Dice(l)\r\n  l[0] = -10\r\n\r\nthen, if we did not copy the argument as shown above, and wrote just\r\nself._max_pips = max_pips, the instance name would refer to the same\r\nlist object as l, whose first value is now -10, which is not allowed for Dice\r\nobjects.\r\n\r\nself._pips = [0]*len(max_pips)\r\n\r\nbinds the name _pips (in the self object) to a list object filled with\r\nlen(max_pips) 0s. The roll method described below will set the _pips instance\r\nname to random values, appropriate for max_pips. The _pips instance name will\r\nbe used by many other methods, but typically only if self._roll_count > 0;\r\nwhen self._roll_count is 0, this list does not contain good values yet.\r\n\r\nself._roll_count = 0\r\n\r\nbinds the name _roll_count (in the self object) to the value object 0. This\r\ninstance name gets incremented in roll and examined in othe methods.\r\n\r\nBy (3) a reference to this object, which is now initialized by defining and\r\ninitializing three instance names, is returned. for d = Dice([6,6]) that\r\nreference is bound to the name d. So d now refers to a Dice object whose state\r\nconsists of three instance names bound to values (two lists, one int).\r\n\r\nNote that we can put print statements inside __init__ to display relevant\r\ninformation when __init__ is called (possibly helping us debug this special\r\nmethod).\r\n\r\nThe top picture accompanying this lecture illustrate how we would think about\r\nd = Dice([6,6]) using the name and object diagrams that we studied earlier.\r\n\r\nAgain, the purpose of __init__, whichi is called automatically called when we\r\nwrite Dice([6,6]), is to create and initialize names the initially empty object\r\ncreated by Python and passed to the self parameter.\r\n\r\nNext, let's see how the other methods in the class, when called, can\r\nexamine/update these names (and return values based on them).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDice methods: commands/mutators\r\n\r\nThe Dice class defines the method roll, which is its only mutator method: a\r\nmethod that changes the state of a Dice object.\r\n\r\nRecall if we call d.roll() then Python uses the fundamental equation of object-\r\noriented programming to translate this call to type(d).roll(d) or Dice.roll(d),\r\ncalling the roll method declared in the Dice class with the argument d matching\r\nthe self parameter. We can also directly write Dice.roll(d) but that is not\r\nwhat programmers write. The roll method is defined in the Dice class as follows.\r\n\r\ndef roll(self : Dice) -> Dice:\r\n    self._roll_count += 1\r\n    self._pips = [ random.randint(1,max_pips) for max_pips in self._max_pips ]\r\n    return self\r\n\r\nWhen called, self refers to the same object d refers to; so any change to the\r\nnames in self actually change those names in d. So, the statement\r\n\r\n  self._roll_count += 1\r\n\r\nincrements _roll_count by 1 (from 0 to 1 the first time it is called).\r\n\r\nThe statement\r\n\r\n  self._pips = [ random.randint(1,max_pips) for max_pips in self._max_pips ]\r\n\r\nbinds ._pips to a comprehension that iterates through every value in \r\nself._max_pips and collects random integers from 1 to each value . For example\r\nself._max_pips might refer to [5,2]: 5 pips showing on the first die and 2\r\npips showing on the second.\r\n\r\nWe can also write this code without a comprehension, mutating the values (0)\r\nin the list created when __init__ was called:\r\n\r\n  for i in range(len(self._pips)):\r\n      self._pips[i] = random.randint(1,self._max_pips[i])\r\n\r\nSo, we have now advanced the roll counter and computed/stored the number of pips\r\nshowing on the side of each die.\r\n\r\nThe bottom picture accompanying this lecture illustrate how we would think about\r\nd.roll() mutating the Dice object d refers to, updating the object diagram.\r\n\r\nFinally Python executes the statement4\r\n\r\n  return self\r\n\r\nreturns the mutated object (the object that d still refers to). If we write just\r\n\r\n  d.roll()\r\n\r\nwe tell Python to do nothing with the returned result; but we can also chain\r\nanother call using this returned value: writing\r\n\r\n print(d.roll().pip_sum())\r\n\r\nuses the returned result (a reference to d) to call the pip_sum method.\r\n\r\nAlternatively, we could have written return None, in which case if we called\r\ncall d.roll().pip_sum() Python would raise an exception saying that we cannot\r\ncall pip_sum() on a NoneType object. If we wrote no return statement, Python\r\nwould even automatically return None.\r\n\r\nNotice that we do NOT need to write d = d.roll() (although this code is\r\ntechnically correct) because after calling just d.roll(), d refers to updated\r\ninstance of Dice, with an update _roll_count and _pips list.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDice methods: queries/accessors\r\n\r\nAll the remaining methods defined in the Dice class are queries/accessors. They\r\nexamine the state of a Dice value object but do not change any of its instance\r\nnames. Here are the method and a brief description of how the body of each\r\ncomputes its value correctly.\r\n\r\nTypically in classes, each method implements some interesting operation, and\r\neach is typically short and to the point.\r\n\r\n  def number_of_dice(self : Dice) -> int:\r\n      return len(self._pips)\r\n\r\nReturns the number of dice, which is just the length of either self._pips or\r\nself._max_pips lists. The __init__ method ensured these two lists have the same\r\nnumber of vaues.\r\n\r\n  def all_pip_maximums(self : Dice) -> [int]:\r\n     return self._max_pips[:]\r\n\r\nReturns a list of the maximum number of pips that can show on each side. Again\r\nwe return a copy, because we don't want whoever binds this result list to be\r\nable to change/mutate any values in the list d._max_pips: that would affect the\r\nresults produced by roll.\r\n\r\n  def rolls(self : Dice) -> int:\r\n      return self._roll_count\r\n\r\nReturns the number of times the dice have been rolled, which is counted and\r\nstored in the _roll_count instance name.\r\n\r\n  def pips_on(self : Dice, i : int) -> int:\r\n      assert self._roll_count > 0, 'Dice.pips_on: dice not rolled' \r\n      assert 0<= i < len(self._pips), \\\r\n        'Dice.pips: die index i('+str(i)+') must be >= 0 and <'+str(len(self._pips))\r\n      return self._pips[i]\r\n\r\nReturns the number of pips showing on dice i, by returning self._pips[i]. Note\r\nthat if the dice have never been rolled, the first assertion fails and the\r\nmethod raises an exception (because there are no random values in the ._pips\r\nlists). If the second asserton fails, we have not specified a legal index for\r\nthe number of dice we have.\r\n\r\n  def all_pips(self : Dice) -> [int]:\r\n      return self._pips[:]\r\n\r\nReturns a list of all the pips (even if the dice hasn't been rolled, in which\r\ncase it returns all 0s).  Again we return a copy, because we don't want whoever\r\nbinds this result list to be able to change/mutate any values in it.\r\n\r\n  def pip_sum(self : Dice) -> int:\r\n      assert self._roll_count > 0, 'Dice.pip_sum: dice not rolled' \r\n      return sum(self._pips)\r\n\r\nReturns the sum of all the values in the pips list. Note that the sum function\r\nadds up all the values in the list self._pips: e.g., sum([5,1,3,7]) returns 16.\r\n\r\nWe could write this sum explicitly as\r\n\r\n      sum = 0\r\n      for p in self._pips:\r\n          sume += p\r\n      return sum\r\n\r\nNext,\r\n       \r\n  def pips_same(self : Dice) -> bool:\r\n      return all( [self._pips[0] == p for p in self._pips] )\r\n\r\nReturns whether or not all the pips are the same. The all function returns True\r\nif all the values in the list (constructed here with a comprehension) are True,\r\nand False if any are False. In the comprehension, it computes a bool expression\r\ndetermining whether every value in the pip list is equal to the first value.\r\nAll pips have the same value if all pips have the same value as the first pip.\r\nWe could rewrite this code as without the comprehension as follows.\r\n\r\n      for p in self._pips:\r\n          if p != self._pips[0]:\r\n              return False\r\n      return True\r\n  \r\n\r\n------------------------------------------------------------------------------\r\n\r\nSpecial Methods\r\n\r\nFirst we discuss the __str__ method\r\n\r\n  def __str__(self):\r\n      return 'Dice('+str(self._pips)+')'\r\n\r\nThe __str__ method returns some useful information about the state of the\r\nobject. The method above returns a list showing the nuumber of pips on each die:\r\npossibly 'Dice([4,2])'. That is, we can call d.__str__() and it might return the\r\nstring 'Dice([4,3])'. But there is a better way to make this call: str(d)\r\n\r\nCalling str(d) works because Python's str function is designed to call __str__ \r\non its argument. It is defined like\r\n\r\n  def str(o : object)-> str:\r\n      return o.__str__()\r\n\r\nSo like the __init__ method, we typically do not directly call the __str__\r\nmethod, but call the str(...) function, which calls __str__.\r\n\r\nAlso recall that when we call a print function, Python automatically calls the\r\nstr function on all its arguments, printing the string value of each argument,\r\nfor easier reading. But if you concatenate string together, you must call str:\r\nfor example I can write either\r\n\r\nprint('d =',d)\r\n\r\nwhere no call to str is needed; or write the following where calling str(...)\r\nis required (otherwise Python would raise an exception about not being able\r\nto catenate a str to a Dice object).\r\n\r\nprint('d = ' + str(d))\r\n\r\nNow we discuss the repr function:\r\n\r\n  def __repr__(self : object):\r\n      return 'Dice('+str(self._max_pips)+')'\r\n\r\nThe __repr__ method should return a str which if eval'ed would return an\r\nequivalent object to the one it was called on.  The method above returns the\r\nstring 'Dice([6,6])' which includes the Dice class and all the information\r\nneeded to define a new Dice object. eval('Dice([6,6])') returns another dice\r\nobject representing the same 2, 6-sided dice.\r\n\r\nAgain, although we can call d.__repr__() in Python we call repr(d); it works\r\nbecause Python's repr function is designed to call __repr__ on its argument. It\r\nis defined like\r\n\r\n  def repr(o : object)-> str:\r\n      return o.__repr__()\r\n\r\nFinally, the method\r\n\r\n   def standard_rolls_for_debugging(self):\r\n      random.seed(12161949)\r\n\r\nuses knowledge (which you don't have) about the random module to change the\r\nseed of its random number generator. After this method is called, random.randint\r\n(called in the roll method) generates the same random values, so calling the\r\nroll method in the Dice class generates the same pips. This feature is useful\r\nfor debugging (so our program gets the same sequence of rolls; when we debug\r\nsome sequence of calls, it will always produce the same values).\r\n\r\nSome classes (not his one) define special helper methods that are called by\r\nother methods in the class to get their jobs done. Such methods should start\r\nwith a single underscore, to signal to anyone who reads a a class that those\r\nmethods should not be called explicitly (just as using instance names starting\r\nwith a single underscore indicates that only methods in the class should access\r\nthose instance names).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFinal Words\r\n\r\nWhen beginners write classes, they very often forget to use self everywhere it\r\nis needed: prefacing any instance names (when examined or stored) or class\r\nmethods (when called by other methods in the class: not used in Dice). \r\n\r\nThe debugger shows a disclosure +/- in front of every value object constructed\r\nfrom a class (including builtins like lists, tuples, ...). By clicking the\r\ndisclosure, Eclipse shows/hides all the instance names defined in the value\r\nobject.\r\n", "encoding": "ascii"}