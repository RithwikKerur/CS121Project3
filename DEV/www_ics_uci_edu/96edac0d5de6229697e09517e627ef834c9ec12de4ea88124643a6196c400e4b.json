{"url": "https://www.ics.uci.edu/~thornton/cs141/CodeExamples/HaskellExamples2.hs", "content": "-- HaskellExamples2.hs\r\n--\r\n-- CompSci 141 / CSE 141 / Informatics 101 Spring 2013\r\n-- Code Examples\r\n--\r\n-- This module contains a set of functions we wrote in the second Haskell\r\n-- lecture, along with some background on features like pattern matching,\r\n-- primitive recursion, curried functions, lambdas, operator sections,\r\n-- and higher-order functions.\r\n--\r\n-- Be sure to read through the \"Learn You a Haskell for Great Good\" book\r\n-- chapters listed in the course Schedule if you want more information\r\n-- about these topics.  You may not find that you need to read those\r\n-- chapters all the way through, but skimming through them is a good\r\n-- way to get yourself acquainted with some of these topics as you\r\n-- prepare to work through Project #3.\r\n\r\nmodule HaskellExamples2 where\r\n\r\n\r\n-- Here, we see an example of processing a list recursively, and also of\r\n-- using pattern matching to do two things: (1) differentiate between\r\n-- the case where a list is empty and the case where it is not, and\r\n-- (2) separately name the head (first element) and tail (all but the\r\n-- first element) of a list within the pattern.  What results is a\r\n-- shorter, clearer function than you would have to write in a language\r\n-- that required you to take the parameter and then check cases and\r\n-- split it up into pieces within the function's body.\r\n--\r\n-- The function below, listLength, takes a list as a parameter and returns\r\n-- the number of elements in its list.  A few things that are interesting\r\n-- about it:\r\n--\r\n-- * The type signature is different than the ones we've seen previously,\r\n--   because it is \"polymorphic,\" meaning that it has many types instead\r\n--   of just one.  The \"a\" in the signature is what's called a \"type\r\n--   variable,\" akin to the generic type parameters we saw in Java; what\r\n--   sets it apart from concrete type names is that its name begins with\r\n--   a lowercase letter.  Our type signature here reads \"listLength has\r\n--   the type of a function that takes a list containing some kind of\r\n--   value and returning an integer.\"\r\n--\r\n-- * The pattern [] in the function's first equation matches only the\r\n--   empty list.  So the first equation establishes that the length of\r\n--   an empty list is zero.\r\n--\r\n-- * The pattern (x:xs) matches a list that is non-empty, simultaneously\r\n--   naming the head (the first element) x and the tail (all but the first\r\n--   element) xs.  The name \"xs\" can be read as the plural of \"x\".  Note\r\n--   that the names themselves aren't meaningful -- we could have said\r\n--   (n:ns) or even (boo:alex) if we'd wanted to.  Customarily, though,\r\n--   we tend to give the tail a name that is the plural of whatever we\r\n--   named the head.\r\n--\r\n-- * In our function, we use the pattern (_:xs), which means the same\r\n--   thing as (x:xs), except that we're explicitly *not* giving the\r\n--   head a name.  We do this because we don't need to examine the head\r\n--   element; we just need to count it, but that doesn't require us to\r\n--   know what it is.\r\n--\r\n-- This function is an example of what I'm calling \"primitive recursion,\"\r\n-- where we're the ones controlling every step of the process.  An\r\n-- alternative, which we'll see later, is to use higher-order functions\r\n-- that encapsulate common patterns of primitive recursion for us.\r\n\r\nlistLength :: [a] -> Integer\r\nlistLength []      = 0\r\nlistLength (_:xs)  = 1 + listLength xs\r\n\r\n\r\n-- A slightly different function, which demonstrates using a pattern\r\n-- that names both the head and the tail, follows.\r\n\r\nsumAll :: [Integer] -> Integer\r\nsumAll []       = 0\r\nsumAll (x:xs)   = x + sumAll xs\r\n\r\n\r\n\r\n-- Tuples are another useful Haskell data type.  If lists represent\r\n-- collections of elements whose size is undetermined until run-time,\r\n-- tuples represent collections of values whose size is known.  We\r\n-- typically use these to represent heterogenous, related data,\r\n-- similar to the set of fields in an object in Java or the set of\r\n-- members of a struct in C.\r\n--\r\n-- The type of a tuple specifies not only the number of values stored\r\n-- within it, but also their types.  Tuples with different types of\r\n-- values have different types; tuples with different *numbers* of\r\n-- values also have different types.\r\n--\r\n-- This function, given a two-element tuple that is assumed to be\r\n-- an x/y coordinate, computes the distance that the x/y coordinate\r\n-- is from the origin in two-dimensional space.  Note, too, that the\r\n-- \"sqrt\" function calculates the square root of its argument.\r\n--\r\n-- The pattern (x, y) matches a two-element tuple and simultaneously\r\n-- names its first element x and its second element y.\r\n\r\ndistanceFromOrigin :: (Float, Float) -> Float\r\ndistanceFromOrigin (x, y)   = sqrt (x * x + y * y)\r\n\r\n\r\n\r\n-- We've yet to see a function that takes more than one parameter.\r\n-- Here is a very simple function that takes two parameters and\r\n-- multiplies them.\r\n\r\nmultiply :: Integer -> Integer -> Integer\r\nmultiply m n = m * n\r\n\r\n-- We could call this function by passing it two parameters, so the value\r\n-- of \"multiply 3 4\" is 12.\r\n--\r\n-- The type signature seems a little bit strange though, especially when\r\n-- you know that the -> operator is right-associative, which means that\r\n-- the type signature we wrote is equivalent to this one:\r\n--\r\n--     multiply :: Integer -> (Integer -> Integer)\r\n--\r\n-- That tells us that there's more going on than initially meets the eye.\r\n-- If we read that type signature carefully, here's what it tells us:\r\n--\r\n-- \"multiply has the type of a function that takes an Integer and returns\r\n--  a *function* that takes an Integer and returns an Integer.\"\r\n--\r\n-- This is technically true of all functions in Haskell that accept\r\n-- multiple parameters.  You can supply them with fewer parameters than\r\n-- they require (leaving out the last one or more), in which case the\r\n-- result is a function that requires the missing parameters and computes\r\n-- the value given the parameters you originally passed.\r\n--\r\n-- So \"multiply 3\" has a value: it's a function that takes an Integer\r\n-- and multiplies it by 3.\r\n--\r\n-- This technique, in general, is called \"currying.\"  A curried function\r\n-- is one that can be passed fewer parameters than it requires, in which\r\n-- case you get a new function that requires only the ones that were\r\n-- missing.\r\n--\r\n-- It might seem strange that a feature like this exists, but it's surprisingly\r\n-- useful.  To see why, though, we need a little more background.\r\n\r\n\r\n\r\n-- Instead of using primitive recursion, we can use what are called \"higher-\r\n-- order functions\".  Higher-order functions are functions that take other\r\n-- functions as a parameter or that return functions as their result.\r\n-- Their purpose is to encapsulate common patterns of code you might\r\n-- otherwise have to write by hand; you pass a function that fills in the\r\n-- pattern's gaps and you're done.\r\n--\r\n-- A few examples of higher-order functions built into Haskell's standard\r\n-- library are listed below, along with their type signatures (which is a\r\n-- handy way to understand how they work):\r\n--\r\n--     map :: (a -> b) -> [a] -> [b]\r\n--     Given a function that takes values of some type a and returns values of\r\n--     another type b, along with a list of values of type a,\r\n--     returns a list of the results you get when you apply the function to\r\n--     every element in the list.\r\n--     Example: \"map square [1..5]\" returns \"[1,4,9,16,25]\"\r\n--\r\n--     filter :: (a -> Bool) -> [a] -> [a]\r\n--     Given a function that takes a value of some type a and returns a boolean\r\n--     result, along with a list of values of type a, returns a list of the\r\n--     values in the given list for which the function returns True.\r\n--     Example: \"filter isPositive [-1,1,-2,2,-3,3]\" returns \"1,2,3\"\r\n--\r\n--     zip :: [a] -> [b] -> [(a, b)]\r\n--     Given two lists of elements, returns a list of tuples that contain the\r\n--     positionally-matched elements of the two lists (i.e., the first tuple\r\n--     is the first element of the first list combined with the first element\r\n--     of the second list, and so on).  Stops when one of the lists runs out\r\n--     of elements.\r\n--     Example: \"zip [1..3] [11..15]\" returns \"[(1,11),(2,12),(3,13)]\"\r\n--\r\n--     zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\r\n--     Given a function that takes a value of type a and a value of type b\r\n--     and transforms it to a value of type c, along with lists of a's and\r\n--     b's, returns the result of transforming positionally-matched elements\r\n--     of the two lists using the given function.  This is the general case\r\n--     of zip.\r\n--     Example: \"zipWith multiply [1,2,3] [4,5,6,7]\" returns \"[4,10,18]\"\r\n--\r\n--     foldr :: (a -> b -> b) -> b -> [a] -> b\r\n--     This one is the trickiest of these to understand.  It \"folds\" a list,\r\n--     by applying a function \"in between\" adjacent pairs of elements.  The\r\n--     \"r\" in the name means \"right\", which means that the function is\r\n--     applied from right-to-left.  An additional element is used at the\r\n--     opposite end from where the folding starts, as a way to establish a\r\n--     base case.\r\n--\r\n--     So if the function was our \"multiply\" function from earlier, our\r\n--     list was [1..4], and our base case element was 1, the effect would\r\n--     be this:\r\n--\r\n--         multiply 1 (multiply 1 (multiply 2 (multiply 3 4)))\r\n--\r\n--     and the result would be 24.\r\n\r\n\r\n-- So what does all of this have to do with curried functions?  Because we\r\n-- can pass partially-applied functions (those that have had some of their\r\n-- parameters specified, but others left out) as parameters to higher-order\r\n-- functions.  Suppose you have a list of integers and you want a list\r\n-- where all of those integers has been doubled.  This function will do it.\r\n\r\ndoubleAll :: [Integer] -> [Integer]\r\ndoubleAll xs  = map (multiply 2) xs\r\n\r\n-- Consider why this works.  \"map\" takes a list and a function that transforms\r\n-- the elements of that list one at a time.  The list contains integers, so\r\n-- the function needs to be one that takes a single integer and does something\r\n-- to it.  What is \"multiply 2\"?  A function that takes a single integer (the\r\n-- one we didn't pass to it originally) and multiplies it by 2.\r\n\r\n\r\n-- Note, too, that operators like * or == are also functions, and they're also\r\n-- curried.  Haskell provides a shorthand syntax called \"operator sections\"\r\n-- that allows you to leave out one operand or the other, in which case you get\r\n-- a partially-applied function that expects the other.\r\n\r\ndoubleAll2 :: [Integer] -> [Integer]\r\ndoubleAll2 xs  = map (2*) xs\r\n\r\n-- (2*) is a partially-applied multiplication operation, which has had its first\r\n-- operand specified by needs its second.  Similarly, we could map any of these\r\n-- operator sections over a list; think about what the result would be:\r\n--\r\n--     (*2)   (3/)   (/3)   (>0)   (0>)\r\n--\r\n-- Note, too, that the parentheses are required here to allow the code to parse\r\n-- correctly.  \"map 2 * xs\" means something very different (and, by the way,\r\n-- something illegal!) than \"map (2*) xs\" does.\r\n\r\n\r\n\r\n-- Finally, we can also make our doubleAll function above polymorphic, to extend\r\n-- its usefulness.  The multiplication operator is capable of multiplying any\r\n-- kind of number, not just an Integer, so we could specify that our doubleAll\r\n-- function is capable of doubling any kind of number.  Notice that the\r\n-- function's equation doesn't change at all, but its type signature does.\r\n\r\ndoubleAll3 :: Num a => [a] -> [a]\r\ndoubleAll3 xs  = map (2*) xs\r\n\r\n-- \"Num a =>\" represents something called a \"type constraint.\"  It's akin to\r\n-- the bounded type parameters we specified in Java (e.g., \"K extends Comparable<K>\")\r\n-- when we wanted to constrain the set of types allowable as keys in our binary\r\n-- search tree implementation in Project #2.  The constraints we write in Java are\r\n-- centered around the concept of inheritance (classes that extend some class or\r\n-- implement some interface).  Haskell's constraints are similar, though they're\r\n-- centered around what are called \"typeclasses,\" which indicate sets of\r\n-- functions that are available to certain types.  The typeclass Num specifies a\r\n-- type that is numeric, which means that it supports certain operations like\r\n-- arithmetic operators, a function that returns an absolute value, and a handful\r\n-- of others.\r\n--\r\n-- So, in general, we read doubleAll3's type signature like this: \"doubleAll3 has\r\n-- the type of a function that, for any numeric type a, takes a list of a's and\r\n-- returns a list of a's\".\r\n\r\n\r\n-- Other useful typeclasses that are built into Haskell include:\r\n--\r\n-- * \"Eq\", which specifies a type for which == and /= operators exist.\r\n-- * \"Ord\", which specifies a type whose values have a natural ordering, which\r\n--   means that not only are they Eq, but they also have <, >, <=, and >=\r\n--   operators, along with a small handful of additional functions.\r\n", "encoding": "ascii"}