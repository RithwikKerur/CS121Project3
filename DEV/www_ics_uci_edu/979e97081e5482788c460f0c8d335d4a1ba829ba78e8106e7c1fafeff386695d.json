{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_5.html#SEC77", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Project 3--Virtual Memory</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Project 3--Virtual Memory\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Project 3--Virtual Memory\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC63\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_4.html#SEC42\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_6.html#SEC85\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> 5. Project 3: Virtual Memory </H1>\n<!--docid::SEC63::-->\n<P>\n\nBy now you should have some familiarity with the inner workings of\nPintos.  Your\nOS can properly handle multiple threads of execution with proper\nsynchronization, and can load multiple user programs at once.  However,\nthe number and size of programs that can run is limited by the machine's\nmain memory size.  In this assignment, you will remove that limitation.\n</P>\n<P>\n\nYou will build this assignment on top of the last one.  Test programs\nfrom project 2 should also work with project 3.  You should take care to\nfix any bugs in your project 2 submission before you start work on\nproject 3, because those bugs will most likely cause the same problems\nin project 3.\n</P>\n<P>\n\nYou will continue to handle Pintos disks and file systems the same way\nyou did in the previous assignment (see section <A HREF=\"pintos_4.html#SEC45\">4.1.2 Using the File System</A>).\n</P>\n<P>\n\n<A NAME=\"Project 3 Background\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC64\"></A>\n<H2> 5.1 Background </H2>\n<!--docid::SEC64::-->\n<P>\n\n<A NAME=\"Project 3 Source Files\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC65\"></A>\n<H3> 5.1.1 Source Files </H3>\n<!--docid::SEC65::-->\n<P>\n\nYou will work in the <Q><TT>vm</TT></Q> directory for this project.  The\n<Q><TT>vm</TT></Q> directory contains only <Q><TT>Makefile</TT></Q>s.  The only\nchange from <Q><TT>userprog</TT></Q> is that this new <Q><TT>Makefile</TT></Q> turns on\nthe setting <Q><SAMP>-DVM</SAMP></Q>.  All code you write will be in new\nfiles or in files introduced in earlier projects.\n</P>\n<P>\n\nYou will probably be encountering just a few files for the first time:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>devices/block.h</TT></Q>\n<DD><DT><Q><TT>devices/block.c</TT></Q>\n<DD>Provides sector-based read and write access to block device.  You will\nuse this interface to access the swap partition as a block device.\n</DL>\n<P>\n\n<A NAME=\"Memory Terminology\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC66\"></A>\n<H3> 5.1.2 Memory Terminology </H3>\n<!--docid::SEC66::-->\n<P>\n\nCareful definitions are needed to keep discussion of virtual memory from\nbeing confusing.  Thus, we begin by presenting some terminology for\nmemory and storage.  Some of these terms should be familiar from project\n2 (see section <A HREF=\"pintos_4.html#SEC47\">4.1.4 Virtual Memory Layout</A>), but much of it is new.\n</P>\n<P>\n\n<A NAME=\"Pages\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC67\"></A>\n<H4> 5.1.2.1 Pages </H4>\n<!--docid::SEC67::-->\n<P>\n\nA <EM>page</EM>, sometimes called a <EM>virtual page</EM>, is a continuous\nregion of virtual memory 4,096 bytes (the <EM>page size</EM>) in length.  A\npage must be <EM>page-aligned</EM>, that is, start on a virtual address\nevenly divisible by the page size.  Thus, a 32-bit virtual address can\nbe divided into a 20-bit <EM>page number</EM> and a 12-bit <EM>page\noffset</EM> (or just <EM>offset</EM>), like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>               31               12 11        0\n              +-------------------+-----------+\n              |    Page Number    |   Offset  |\n              +-------------------+-----------+\n                       Virtual Address\n</pre></td></tr></table><P>\n\nEach process has an independent set of <EM>user (virtual) pages</EM>, which\nare those pages below virtual address <CODE>PHYS_BASE</CODE>, typically\n<TT>0xc0000000</TT> (3 GB).  The set of <EM>kernel (virtual) pages</EM>, on the\nother hand, is global, remaining the same regardless of what thread or\nprocess is active.  The kernel may access both user and kernel pages,\nbut a user process may access only its own user pages.  See section <A HREF=\"pintos_4.html#SEC47\">4.1.4 Virtual Memory Layout</A>, for more information.\n</P>\n<P>\n\nPintos provides several useful functions for working with virtual\naddresses.  See section <A HREF=\"pintos_7.html#SEC124\">A.6 Virtual Addresses</A>, for details.\n</P>\n<P>\n\n<A NAME=\"Frames\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC68\"></A>\n<H4> 5.1.2.2 Frames </H4>\n<!--docid::SEC68::-->\n<P>\n\nA <EM>frame</EM>, sometimes called a <EM>physical frame</EM> or a <EM>page\nframe</EM>, is a continuous region of physical memory.  Like pages, frames\nmust be page-size and page-aligned.  Thus, a 32-bit physical address can\nbe divided into a 20-bit <EM>frame number</EM> and a 12-bit <EM>frame\noffset</EM> (or just <EM>offset</EM>), like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>               31               12 11        0\n              +-------------------+-----------+\n              |    Frame Number   |   Offset  |\n              +-------------------+-----------+\n                       Physical Address\n</pre></td></tr></table><P>\n\nThe 80<VAR>x</VAR>86 doesn't provide any way to directly access memory at a\nphysical address.  Pintos works around this by mapping kernel virtual\nmemory directly to physical memory: the first page of kernel virtual\nmemory is mapped to the first frame of physical memory, the second page\nto the second frame, and so on.  Thus, frames can be accessed through\nkernel virtual memory.  \n</P>\n<P>\n\nPintos provides functions for translating between physical addresses and\nkernel virtual addresses.  See section <A HREF=\"pintos_7.html#SEC124\">A.6 Virtual Addresses</A>, for details.\n</P>\n<P>\n\n<A NAME=\"Page Tables\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC69\"></A>\n<H4> 5.1.2.3 Page Tables </H4>\n<!--docid::SEC69::-->\n<P>\n\nIn Pintos, a <EM>page table</EM> is a data structure that the CPU uses to\ntranslate a virtual address to a physical address, that is, from a page\nto a frame.  The page table format is dictated by the 80<VAR>x</VAR>86\narchitecture.  Pintos provides page table management code in\n<Q><TT>pagedir.c</TT></Q> (see section <A HREF=\"pintos_7.html#SEC125\">A.7 Page Table</A>).\n</P>\n<P>\n\nThe diagram below illustrates the relationship between pages and frames.\nThe virtual address, on the left, consists of a page number and an\noffset.  The page table translates the page number into a frame number,\nwhich is combined with the unmodified offset to obtain the physical\naddress, on the right.\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>                          +----------+\n         .---------------&gt;|Page Table|---------.\n        /                 +----------+          |\n   31   |   12 11    0                    31    V   12 11    0\n  +-----------+-------+                  +------------+-------+\n  |  Page Nr  |  Ofs  |                  |  Frame Nr  |  Ofs  |\n  +-----------+-------+                  +------------+-------+\n   Virt Addr      |                       Phys Addr       ^\n                   \\_____________________________________/\n</pre></td></tr></table><P>\n\n<A NAME=\"Swap Slots\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC70\"></A>\n<H4> 5.1.2.4 Swap Slots </H4>\n<!--docid::SEC70::-->\n<P>\n\nA <EM>swap slot</EM> is a continuous, page-size region of disk space in the\nswap partition.  Although hardware limitations dictating the placement of\nslots are looser than for pages and frames, swap slots should be\npage-aligned because there is no downside in doing so.\n</P>\n<P>\n\n<A NAME=\"Resource Management Overview\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC71\"></A>\n<H3> 5.1.3 Resource Management Overview </H3>\n<!--docid::SEC71::-->\n<P>\n\nYou will need to design the following data structures:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT>Supplemental page table\n<DD><P>\n\nEnables page fault handling by supplementing the hadrware page table.\nSee section <A HREF=\"pintos_5.html#SEC72\">5.1.4 Managing the Supplemental Page Table</A>.\n</P>\n<P>\n\n</P>\n<DT>Frame table\n<DD><P>\n\nAllows efficient implementation of eviction policy.\nSee section <A HREF=\"pintos_5.html#SEC73\">5.1.5 Managing the Frame Table</A>.\n</P>\n<P>\n\n</P>\n<DT>Swap table\n<DD><P>\n\nTracks usage of swap slots.\nSee section <A HREF=\"pintos_5.html#SEC75\">5.1.6 Managing the Swap Table</A>.\n</P>\n<P>\n\n</P>\n<DT>Table of file mappings\n<DD><P>\n\nProcesses may map files into their virtual memory space.  You need a\ntable to track which files are mapped into which pages.\n</DL>\n<P>\n\nYou do not necessarily need to implement four completely distinct data\nstructures: it may be convenient to wholly or partially merge related\nresources into a unified data structure.\n</P>\n<P>\n\nFor each data structure, you need to determine what information each\nelement should contain.  You also need to decide on the data structure's\nscope, either local (per-process) or global (applying to the whole\nsystem), and how many instances are required within its scope.\n</P>\n<P>\n\nTo simplify your design, you may store these data structures in\nnon-pageable memory.  That means that you can be sure that pointers\namong them will remain valid.\n</P>\n<P>\n\nPossible choices of data structures include arrays, lists, bitmaps, and\nhash tables.  An array is often the simplest approach, but a sparsely\npopulated array wastes memory.  Lists are also simple, but traversing a\nlong list to find a particular position wastes time.  Both arrays and\nlists can be resized, but lists more efficiently support insertion and\ndeletion in the middle.\n</P>\n<P>\n\nPintos includes a bitmap data structure in <Q><TT>lib/kernel/bitmap.c</TT></Q>\nand <Q><TT>lib/kernel/bitmap.h</TT></Q>.  A bitmap is an array of bits, each of\nwhich can be true or false.  Bitmaps are typically used to track usage\nin a set of (identical) resources: if resource <VAR>n</VAR> is in use, then\nbit <VAR>n</VAR> of the bitmap is true.  Pintos bitmaps are fixed in size,\nalthough you could extend their implementation to support resizing.\n</P>\n<P>\n\nPintos also includes a hash table data structure (see section <A HREF=\"pintos_7.html#SEC133\">A.8 Hash Table</A>).\nPintos hash tables efficiently support insertions and deletions over a\nwide range of table sizes.\n</P>\n<P>\n\nAlthough more complex data structures may yield performance or other\nbenefits, they may also needlessly complicate your implementation.\nThus, we do not recommend implementing any advanced data structure\n(e.g. a balanced binary tree) as part of your design.\n</P>\n<P>\n\n<A NAME=\"Managing the Supplemental Page Table\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC72\"></A>\n<H3> 5.1.4 Managing the Supplemental Page Table </H3>\n<!--docid::SEC72::-->\n<P>\n\nThe <EM>supplemental page table</EM> supplements the page table with\nadditional data about each page.  It is needed because of the\nlimitations imposed by the page table's format.  Such a data structure\nis often called a &quot;page table&quot; also; we add the word &quot;supplemental&quot;\nto reduce confusion.\n</P>\n<P>\n\nThe supplemental page table is used for at least two purposes.  Most\nimportantly, on a page fault, the kernel looks up the virtual page that\nfaulted in the supplemental page table to find out what data should be\nthere.  Second, the kernel consults the supplemental page table when a\nprocess terminates, to decide what resources to free.\n</P>\n<P>\n\nYou may organize the supplemental page table as you wish.  There are at\nleast two basic approaches to its organization: in terms of segments or\nin terms of pages.  Optionally, you may use the page table itself as an\nindex to track the members of the supplemental page table.  You will\nhave to modify the Pintos page table implementation in <Q><TT>pagedir.c</TT></Q>\nto do so.  We recommend this approach for advanced students only.\nSee section <A HREF=\"pintos_7.html#SEC131\">A.7.4.2 Page Table Entry Format</A>, for more information.\n</P>\n<P>\n\nThe most important user of the supplemental page table is the page fault\nhandler.  In project 2, a page fault always indicated a bug in the\nkernel or a user program.  In project 3, this is no longer true.  Now, a\npage fault might only indicate that the page must be brought in from a\nfile or swap.  You will have to implement a more sophisticated page\nfault handler to handle these cases.  Your page fault handler, which you\nshould implement by modifying <CODE>page_fault()</CODE> in\n<Q><TT>userprog/exception.c</TT></Q>, needs to do roughly the following:\n</P>\n<P>\n\n<OL>\n<LI>\nLocate the page that faulted in the supplemental page table.  If the\nmemory reference is valid, use the supplemental page table entry to\nlocate the data that goes in the page, which might be in the file\nsystem, or in a swap slot, or it might simply be an all-zero page.  If\nyou implement sharing, the page's data might even already be in a page\nframe, but not in the page table.\n<P>\n\nIf the supplemental page table indicates that the user process should\nnot expect any data at the address it was trying to access, or if the\npage lies within kernel virtual memory, or if the access is an attempt\nto write to a read-only page, then the access is invalid.  Any invalid\naccess terminates the process and thereby frees all of its resources.\n</P>\n<P>\n\n</P>\n<LI>\nObtain a frame to store the page.  See section <A HREF=\"pintos_5.html#SEC73\">5.1.5 Managing the Frame Table</A>, for\ndetails.\n<P>\n\nIf you implement sharing, the data you need may already be in a frame,\nin which case you must be able to locate that frame.\n</P>\n<P>\n\n</P>\n<LI>\nFetch the data into the frame, by reading it from the file system or\nswap, zeroing it, etc.\n<P>\n\nIf you implement sharing, the page you need may already be in a frame,\nin which case no action is necessary in this step.\n</P>\n<P>\n\n</P>\n<LI>\nPoint the page table entry for the faulting virtual address to the\nphysical page.  You can use the functions in <Q><TT>userprog/pagedir.c</TT></Q>.\n</OL>\n<P>\n\n<A NAME=\"Managing the Frame Table\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC73\"></A>\n<H3> 5.1.5 Managing the Frame Table </H3>\n<!--docid::SEC73::-->\n<P>\n\nThe <EM>frame table</EM> contains one entry for each frame that contains a\nuser page.  Each entry in the frame table contains a pointer to the\npage, if any, that currently occupies it, and other data of your choice.\nThe frame table allows Pintos to efficiently implement an eviction\npolicy, by choosing a page to evict when no frames are free.\n</P>\n<P>\n\nThe frames used for user pages should be obtained from the &quot;user\npool,&quot; by calling <CODE>palloc_get_page(PAL_USER)</CODE>.  You must use\n<CODE>PAL_USER</CODE> to avoid allocating from the &quot;kernel pool,&quot; which\ncould cause some test cases to fail unexpectedly (see  <A HREF=\"pintos_5.html#Why PAL_USER?\">Why PAL_USER?</A>).  If you modify <Q><TT>palloc.c</TT></Q> as part of your frame table\nimplementation, be sure to retain the distinction between the two pools.\n</P>\n<P>\n\nThe most important operation on the frame table is obtaining an unused\nframe.  This is easy when a frame is free.  When none is free, a frame\nmust be made free by evicting some page from its frame.\n</P>\n<P>\n\nIf no frame can be evicted without allocating a swap slot, but swap is\nfull, panic the kernel.  Real OSes apply a wide range of policies to\nrecover from or prevent such situations, but these policies are beyond\nthe scope of this project.\n</P>\n<P>\n\nThe process of eviction comprises roughly the following steps:\n</P>\n<P>\n\n<OL>\n<LI>\nChoose a frame to evict, using your page replacement algorithm.  The\n&quot;accessed&quot; and &quot;dirty&quot; bits in the page table, described below, will\ncome in handy.\n<P>\n\n</P>\n<LI>\nRemove references to the frame from any page table that refers to it.\n<P>\n\nUnless you have implemented sharing, only a single page should refer to\na frame at any given time.\n</P>\n<P>\n\n</P>\n<LI>\nIf necessary, write the page to the file system or to swap.\n</OL>\n<P>\n\nThe evicted frame may then be used to store a different page.\n</P>\n<P>\n\n<A NAME=\"Accessed and Dirty Bits\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC74\"></A>\n<H4> 5.1.5.1 Accessed and Dirty Bits </H4>\n<!--docid::SEC74::-->\n<P>\n\n80<VAR>x</VAR>86 hardware provides some assistance for implementing page\nreplacement algorithms, through a pair of bits in the page table entry\n(PTE) for each page.  On any read or write to a page, the CPU sets the\n<EM>accessed bit</EM> to 1 in the page's PTE, and on any write, the CPU\nsets the <EM>dirty bit</EM> to 1.  The CPU never resets these bits to 0,\nbut the OS may do so.\n</P>\n<P>\n\nYou need to be aware of <EM>aliases</EM>, that is, two (or more) pages that\nrefer to the same frame.  When an aliased frame is accessed, the\naccessed and dirty bits are updated in only one page table entry (the\none for the page used for access).  The accessed and dirty bits for the\nother aliases are not updated.\n</P>\n<P>\n\nIn Pintos, every user virtual page is aliased to its kernel virtual\npage.  You must manage these aliases somehow.  For example, your code\ncould check and update the accessed and dirty bits for both addresses.\nAlternatively, the kernel could avoid the problem by only accessing user\ndata through the user virtual address.\n</P>\n<P>\n\nOther aliases should only arise if you implement sharing for extra\ncredit (see  <A HREF=\"pintos_5.html#VM Extra Credit\">VM Extra Credit</A>), or if there is a bug in your code.\n</P>\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC128\">A.7.3 Accessed and Dirty Bits</A>, for details of the functions\nto work with accessed and dirty bits.\n</P>\n<P>\n\n<A NAME=\"Managing the Swap Table\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC75\"></A>\n<H3> 5.1.6 Managing the Swap Table </H3>\n<!--docid::SEC75::-->\n<P>\n\nThe swap table tracks in-use and free swap slots.  It should allow\npicking an unused swap slot for evicting a page from its frame to the\nswap partition.  It should allow freeing a swap slot when its page is read\nback or the process whose page was swapped is terminated.\n</P>\n<P>\n\nYou may use the <CODE>BLOCK_SWAP</CODE> block device for swapping, obtaining\nthe <CODE>struct block</CODE> that represents it by calling <CODE>block_get_role()</CODE>.\nFrom the\n<Q><TT>vm/build</TT></Q> directory, use the command <CODE>pintos-mkdisk swap.dsk\n--swap-size=<VAR>n</VAR></CODE> to create an disk named <Q><TT>swap.dsk</TT></Q> that\ncontains a <VAR>n</VAR>-MB swap partition.\nAfterward, <Q><TT>swap.dsk</TT></Q> will automatically be attached as an extra disk\nwhen you run <CODE>pintos</CODE>.  Alternatively, you can tell\n<CODE>pintos</CODE> to use a temporary <VAR>n</VAR>-MB swap disk for a single\nrun with <Q><SAMP>--swap-size=<VAR>n</VAR></SAMP></Q>.\n</P>\n<P>\n\nSwap slots should be allocated lazily, that is, only when they are\nactually required by eviction.  Reading data pages from the executable\nand writing them to swap immediately at process startup is not lazy.\nSwap slots should not be reserved to store particular pages.\n</P>\n<P>\n\nFree a swap slot when its contents are read back into a frame.\n</P>\n<P>\n\n<A NAME=\"Managing Memory Mapped Files Back\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC76\"></A>\n<H3> 5.1.7 Managing Memory Mapped Files </H3>\n<!--docid::SEC76::-->\n<P>\n\nThe file system is most commonly accessed with <CODE>read</CODE> and\n<CODE>write</CODE> system calls.  A secondary interface is to &quot;map&quot; the file\ninto virtual pages, using the <CODE>mmap</CODE> system call.  The program can\nthen use memory instructions directly on the file data.\n</P>\n<P>\n\nSuppose file <Q><TT>foo</TT></Q> is <TT>0x1000</TT> bytes (4 kB, or one page) long.\nIf <Q><TT>foo</TT></Q> is mapped into memory starting at address <TT>0x5000</TT>, then\nany memory accesses to locations <TT>0x5000</TT><small>...</small><TT>0x5fff</TT> will access\nthe corresponding bytes of <Q><TT>foo</TT></Q>.\n</P>\n<P>\n\nHere's a program that uses <CODE>mmap</CODE> to print a file to the console.\nIt opens the file specified on the command line, maps it at virtual\naddress <TT>0x10000000</TT>, writes the mapped data to the console (fd 1),\nand unmaps the file.\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &lt;stdio.h&gt;\n#include &lt;syscall.h&gt;\nint main (int argc UNUSED, char *argv[]) \n{\n  void *data = (void *) 0x10000000;     /* Address at which to map. */\n\n  int fd = open (argv[1]);              /* Open file. */\n  mapid_t map = mmap (fd, data);        /* Map file. */\n  write (1, data, filesize (fd));       /* Write file to console. */\n  munmap (map);                         /* Unmap file (optional). */\n  return 0;\n}\n</pre></td></tr></table><P>\n\nA similar program with full error handling is included as <Q><TT>mcat.c</TT></Q>\nin the <Q><TT>examples</TT></Q> directory, which also contains <Q><TT>mcp.c</TT></Q> as a\nsecond example of <CODE>mmap</CODE>.\n</P>\n<P>\n\nYour submission must be able to track what memory is used by memory\nmapped files.  This is necessary to properly handle page faults in the\nmapped regions and to ensure that mapped files do not overlap any other\nsegments within the process.\n</P>\n<P>\n\n<A NAME=\"Project 3 Suggested Order of Implementation\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC77\"></A>\n<H2> 5.2 Suggested Order of Implementation </H2>\n<!--docid::SEC77::-->\n<P>\n\nWe suggest the following initial order of implementation:\n</P>\n<P>\n\n<OL>\n<LI>\nFrame table (see section <A HREF=\"pintos_5.html#SEC73\">5.1.5 Managing the Frame Table</A>).  Change <Q><TT>process.c</TT></Q>\nto use your frame table allocator.\n<P>\n\nDo not implement swapping yet.  If you run out of frames, fail the\nallocator or panic the kernel.\n</P>\n<P>\n\nAfter this step, your kernel should still pass all the project 2 test\ncases.\n</P>\n<P>\n\n</P>\n<LI>\nSupplemental page table and page fault handler (see section <A HREF=\"pintos_5.html#SEC72\">5.1.4 Managing the Supplemental Page Table</A>).  Change <Q><TT>process.c</TT></Q> to record the\nnecessary information in the supplemental page table when loading an\nexecutable and setting up its stack.  Implement loading of code and data\nsegments in the page fault handler.  For now, consider only valid\naccesses.\n<P>\n\nAfter this step, your kernel should pass all of the project 2\nfunctionality test cases, but only some of the robustness tests.\n</OL>\n<P>\n\nFrom here, you can implement stack growth, mapped files, and page\nreclamation on process exit in parallel.\n</P>\n<P>\n\nThe next step is to implement eviction (see section <A HREF=\"pintos_5.html#SEC73\">5.1.5 Managing the Frame Table</A>).  Initially you could choose the page to evict randomly.  At\nthis point, you need to consider how to manage accessed and dirty bits\nand aliasing of user and kernel pages.  Synchronization is also a\nconcern: how do you deal with it if process A faults on a page whose\nframe process B is in the process of evicting?  Finally, implement a\neviction strategy such as the clock algorithm.\n</P>\n<P>\n\n<A NAME=\"Project 3 Requirements\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC78\"></A>\n<H2> 5.3 Requirements </H2>\n<!--docid::SEC78::-->\n<P>\n\nThis assignment is an open-ended design problem.  We are going to say as\nlittle as possible about how to do things.  Instead we will focus on\nwhat functionality we require your OS to support.  We will expect\nyou to come up with a design that makes sense.  You will have the\nfreedom to choose how to handle page faults, how to organize the swap\npartition, how to implement paging, etc.\n</P>\n<P>\n\n<A NAME=\"Project 3 Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC79\"></A>\n<H3> 5.3.1 Design Document </H3>\n<!--docid::SEC79::-->\n<P>\n\nBefore you turn in your project, you must copy <A HREF=\"vm.tmpl\">the\nproject 3 design document template</A> into your source tree under the name\n<Q><TT>pintos/src/vm/DESIGNDOC</TT></Q> and fill it in.  We recommend that you\nread the design document template before you start working on the\nproject.  See section <A HREF=\"pintos_10.html#SEC152\">D. Project Documentation</A>, for a sample design document\nthat goes along with a fictitious project.\n</P>\n<P>\n\n<A NAME=\"Paging\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC80\"></A>\n<H3> 5.3.2 Paging </H3>\n<!--docid::SEC80::-->\n<P>\n\nImplement paging for segments loaded from executables.  All of these\npages should be loaded lazily, that is, only as the kernel intercepts\npage faults for them.  Upon eviction, pages modified since load (e.g.\nas indicated by the &quot;dirty bit&quot;) should be written to swap.\nUnmodified pages, including read-only pages, should never be written to\nswap because they can always be read back from the executable.\n</P>\n<P>\n\nImplement a global page replacement algorithm that approximates LRU.\nYour algorithm should perform at least as well as the simple variant\nof the &quot;second chance&quot; or &quot;clock&quot; algorithm.\n</P>\n<P>\n\nYour design should allow for parallelism.  If one page fault requires\nI/O, in the meantime processes that do not fault should continue\nexecuting and other page faults that do not require I/O should be able\nto complete.  This will require some synchronization effort.\n</P>\n<P>\n\nYou'll need to modify the core of the program loader, which is the loop\nin <CODE>load_segment()</CODE> in <Q><TT>userprog/process.c</TT></Q>.  Each time around\nthe loop, <CODE>page_read_bytes</CODE> receives the number of bytes to read\nfrom the executable file and <CODE>page_zero_bytes</CODE> receives the number\nof bytes to initialize to zero following the bytes read.  The two always\nsum to <CODE>PGSIZE</CODE> (4,096).  The handling of a page depends on these\nvariables' values:\n</P>\n<P>\n\n<UL>\n<LI>\nIf <CODE>page_read_bytes</CODE> equals <CODE>PGSIZE</CODE>, the page should be demand\npaged from the underlying file on its first access.\n<P>\n\n</P>\n<LI>\nIf <CODE>page_zero_bytes</CODE> equals <CODE>PGSIZE</CODE>, the page does not need to\nbe read from disk at all because it is all zeroes.  You should handle\nsuch pages by creating a new page consisting of all zeroes at the\nfirst page fault.\n<P>\n\n</P>\n<LI>\nOtherwise, neither <CODE>page_read_bytes</CODE> nor <CODE>page_zero_bytes</CODE>\nequals <CODE>PGSIZE</CODE>.  In this case, an initial part of the page is to\nbe read from the underlying file and the remainder zeroed.\n</UL>\n<P>\n\n<A NAME=\"Stack Growth\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC81\"></A>\n<H3> 5.3.3 Stack Growth </H3>\n<!--docid::SEC81::-->\n<P>\n\nImplement stack growth.  In project 2, the stack was a single page at\nthe top of the user virtual address space, and programs were limited to\nthat much stack.  Now, if the stack grows past its current size,\nallocate additional pages as necessary.\n</P>\n<P>\n\nAllocate additional pages only if they &quot;appear&quot; to be stack accesses.\nDevise a heuristic that attempts to distinguish stack accesses from\nother accesses.\n</P>\n<P>\n\nUser programs are buggy if they write to the stack below the stack\npointer, because typical real OSes may interrupt a process at any time\nto deliver a &quot;signal,&quot; which pushes data on the stack.<A NAME=\"DOCF3\" HREF=\"pintos_fot.html#FOOT3\">(3)</A>\nHowever, the 80<VAR>x</VAR>86 <CODE>PUSH</CODE> instruction checks access\npermissions before it adjusts the stack pointer, so it may cause a page\nfault 4 bytes below the stack pointer.  (Otherwise, <CODE>PUSH</CODE> would\nnot be restartable in a straightforward fashion.)  Similarly, the\n<CODE>PUSHA</CODE> instruction pushes 32 bytes at once, so it can fault 32\nbytes below the stack pointer.\n</P>\n<P>\n\nYou will need to be able to obtain the current value of the user\nprogram's stack pointer.  Within a system call or a page fault generated\nby a user program, you can retrieve it from the <CODE>esp</CODE> member of the\n<CODE>struct intr_frame</CODE> passed to <CODE>syscall_handler()</CODE> or\n<CODE>page_fault()</CODE>, respectively.  If you verify user pointers before\naccessing them (see section <A HREF=\"pintos_4.html#SEC49\">4.1.5 Accessing User Memory</A>), these are the only cases\nyou need to handle.  On the other hand, if you depend on page faults to\ndetect invalid memory access, you will need to handle another case,\nwhere a page fault occurs in the kernel.  Since the processor only \nsaves the stack pointer when an exception causes a switch from user\nto kernel mode, reading <CODE>esp</CODE> out of the <CODE>struct intr_frame</CODE> \npassed to <CODE>page_fault()</CODE> would yield an undefined value, not the \nuser stack pointer.  You will need to arrange another way, such as \nsaving <CODE>esp</CODE> into <CODE>struct thread</CODE> on the initial transition \nfrom user to kernel mode.\n</P>\n<P>\n\nYou should impose some absolute limit on stack size, as do most OSes.\nSome OSes make the limit user-adjustable, e.g. with the\n<CODE>ulimit</CODE> command on many Unix systems.  On many GNU/Linux systems,\nthe default limit is 8 MB.\n</P>\n<P>\n\nThe first stack page need not be allocated lazily.  You can allocate\nand initialize it with the command line arguments at load time, with \nno need to wait for it to be faulted in.\n</P>\n<P>\n\nAll stack pages should be candidates for eviction.  An evicted stack\npage should be written to swap.\n</P>\n<P>\n\n<A NAME=\"Memory Mapped Files\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC82\"></A>\n<H3> 5.3.4 Memory Mapped Files </H3>\n<!--docid::SEC82::-->\n<P>\n\nImplement memory mapped files, including the following system calls.\n</P>\n<P>\n\n<A NAME=\"IDX17\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> mapid_t <B>mmap</B> (int <VAR>fd</VAR>, void *<VAR>addr</VAR>)\n<DD>Maps the file open as <VAR>fd</VAR> into the process's virtual address\nspace.  The entire file is mapped into consecutive virtual pages\nstarting at <VAR>addr</VAR>.\n<P>\n\nYour VM system must lazily load pages in <CODE>mmap</CODE> regions and use the\n<CODE>mmap</CODE>ed file itself as backing store for the mapping.  That is,\nevicting a page mapped by <CODE>mmap</CODE> writes it back to the file it was\nmapped from.\n</P>\n<P>\n\nIf the file's length is not a multiple of <CODE>PGSIZE</CODE>, then some\nbytes in the final mapped page &quot;stick out&quot; beyond the end of the\nfile.  Set these bytes to zero when the page is faulted in from the\nfile system,\nand discard them when the page is written back to disk.\n</P>\n<P>\n\nIf successful, this function returns a &quot;mapping ID&quot; that\nuniquely identifies the mapping within the process.  On failure,\nit must return -1, which otherwise should not be a valid mapping id,\nand the process's mappings must be unchanged.\n</P>\n<P>\n\nA call to <CODE>mmap</CODE> may fail if the file open as <VAR>fd</VAR> has a\nlength of zero bytes.  It must fail if <VAR>addr</VAR> is not page-aligned\nor if the range of pages mapped overlaps any existing set of mapped\npages, including the stack or pages mapped at executable load time.\nIt must also fail if <VAR>addr</VAR> is 0, because some Pintos code assumes\nvirtual page 0 is not mapped.  Finally, file descriptors 0 and 1,\nrepresenting console input and output, are not mappable.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX18\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> void <B>munmap</B> (mapid_t <VAR>mapping</VAR>)\n<DD>Unmaps the mapping designated by <VAR>mapping</VAR>, which must be a\nmapping ID returned by a previous call to <CODE>mmap</CODE> by the same\nprocess that has not yet been unmapped.\n</DL>\n<P>\n\nAll mappings are implicitly unmapped when a process exits, whether via\n<CODE>exit</CODE> or by any other means.  When a mapping is unmapped, whether\nimplicitly or explicitly, all pages written to by the process are\nwritten back to the file, and pages not written must not be.  The pages\nare then removed from the process's list of virtual pages.\n</P>\n<P>\n\nClosing or removing a file does not unmap any of its mappings.  Once\ncreated, a mapping is valid until <CODE>munmap</CODE> is called or the process\nexits, following the Unix convention.  See  <A HREF=\"pintos_4.html#Removing an Open File\">Removing an Open File</A>, for\nmore information.  You should use the <CODE>file_reopen</CODE> function to\nobtain a separate and independent reference to the file for each of\nits mappings.\n</P>\n<P>\n\nIf two or more processes map the same file, there is no requirement that\nthey see consistent data.  Unix handles this by making the two mappings\nshare the same physical page, but the <CODE>mmap</CODE> system call also has\nan argument allowing the client to specify whether the page is shared or\nprivate (i.e. copy-on-write).\n</P>\n<P>\n\n<HR SIZE=\"6\">\n<A NAME=\"SEC83\"></A>\n<H3> 5.3.5 Accessing User Memory </H3>\n<!--docid::SEC83::-->\nYou will need to adapt your code to access user memory (see section <A HREF=\"pintos_4.html#SEC49\">4.1.5 Accessing User Memory</A>) while handling a system call.  Just as user processes may\naccess pages whose content is currently in a file or in swap space, so\ncan they pass addresses that refer to such non-resident pages to system\ncalls.  Moreover, unless your kernel takes measures to prevent this,\na page may be evicted from its frame even while it is being accessed\nby kernel code.  If kernel code accesses such non-resident user pages,\na page fault will result.\n<P>\n\nWhile accessing user memory, your kernel must either be prepared to handle\nsuch page faults, or it must prevent them from occurring.  The kernel \nmust prevent such page faults while it is holding resources it would \nneed to acquire to handle these faults.  In Pintos, such resources include\nlocks acquired by the device driver(s) that control the device(s) containing \nthe file system and swap space.  As a concrete example, you must not \nallow page faults to occur while a device driver accesses a user buffer\npassed to <CODE>file_read</CODE>, because you would not be able to invoke\nthe driver while handling such faults.\n</P>\n<P>\n\nPreventing such page faults requires cooperation between the code within\nwhich the access occurs and your page eviction code.  For instance,\nyou could extend your frame table to record when a page contained in\na frame must not be evicted.  (This is also referred to as &quot;pinning&quot;\nor &quot;locking&quot; the page in its frame.)  Pinning restricts your page\nreplacement algorithm's choices when looking for pages to evict, so be\nsure to pin pages no longer than necessary, and avoid pinning pages when\nit is not necessary.\n</P>\n<P>\n\n<A NAME=\"Project 3 FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC84\"></A>\n<H2> 5.4 FAQ </H2>\n<!--docid::SEC84::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>How much code will I need to write?</B>\n<DD><P>\n\nHere's a summary of our reference solution, produced by the\n<CODE>diffstat</CODE> program.  The final row gives total lines inserted\nand deleted; a changed line counts as both an insertion and a deletion.\n</P>\n<P>\n\nThis summary is relative to the Pintos base code, but the reference\nsolution for project 3 starts from the reference solution to project 2.\nSee section <A HREF=\"pintos_4.html#SEC57\">4.4 FAQ</A>, for the summary of project 2.\n</P>\n<P>\n\nThe reference solution represents just one possible solution.  Many\nother solutions are also possible and many of those differ greatly from\nthe reference solution.  Some excellent solutions may not modify all the\nfiles modified by the reference solution, and some may modify files not\nmodified by the reference solution.\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre> Makefile.build       |    4\n devices/timer.c      |   42 ++\n threads/init.c       |    5\n threads/interrupt.c  |    2\n threads/thread.c     |   31 +\n threads/thread.h     |   37 +-\n userprog/exception.c |   12\n userprog/pagedir.c   |   10\n userprog/process.c   |  319 +++++++++++++-----\n userprog/syscall.c   |  545 ++++++++++++++++++++++++++++++-\n userprog/syscall.h   |    1\n vm/frame.c           |  162 +++++++++\n vm/frame.h           |   23 +\n vm/page.c            |  297 ++++++++++++++++\n vm/page.h            |   50 ++\n vm/swap.c            |   85 ++++\n vm/swap.h            |   11\n 17 files changed, 1532 insertions(+), 104 deletions(-)\n</pre></td></tr></table><P>\n\n</P>\n<DT><B>Do we need a working Project 2 to implement Project 3?</B>\n<DD><P>\n\nYes.\n</P>\n<P>\n\n</P>\n<DT><B>What extra credit is available?</B>\n<DD><A NAME=\"VM Extra Credit\"></A>\n<P>\n\nYou may implement sharing: when multiple processes are created that use\nthe same executable file, share read-only pages among those processes\ninstead of creating separate copies of read-only segments for each\nprocess.  If you carefully designed your data structures,\nsharing of read-only pages should not make this part significantly\nharder.\n</P>\n<P>\n\n</P>\n<DT><B>How do we resume a process after we have handled a page fault?</B>\n<DD><P>\n\nReturning from <CODE>page_fault()</CODE> resumes the current user process\n(see section <A HREF=\"pintos_7.html#SEC119\">A.4.2 Internal Interrupt Handling</A>).\nIt will then retry the instruction to which the instruction pointer points.\n</P>\n<P>\n\n</P>\n<DT><B>Why do user processes sometimes fault above the stack pointer?</B>\n<DD><P>\n\nYou might notice that, in the stack growth tests, the user program faults\non an address that is above the user program's current stack pointer,\neven though the <CODE>PUSH</CODE> and <CODE>PUSHA</CODE> instructions would cause\nfaults 4 and 32 bytes below the current stack pointer.\n</P>\n<P>\n\nThis is not unusual.  The <CODE>PUSH</CODE> and <CODE>PUSHA</CODE> instructions are\nnot the only instructions that can trigger user stack growth.\nFor instance, a user program may allocate stack space by decrementing the \nstack pointer using a <CODE>SUB $n, %esp</CODE> instruction, and then use a \n<CODE>MOV ..., m(%esp)</CODE> instruction to write to a stack location within\nthe allocated space that is <VAR>m</VAR> bytes above the current stack pointer.  \nSuch accesses are perfectly valid, and your kernel must grow the \nuser program's stack to allow those accesses to succeed.\n</P>\n<P>\n\n</P>\n<DT><B>Does the virtual memory system need to support data segment growth?</B>\n<DD><P>\n\nNo.  The size of the data segment is determined by the linker.  We still\nhave no dynamic allocation in Pintos (although it is possible to\n&quot;fake&quot; it at the user level by using memory-mapped files).  Supporting\ndata segment growth should add little additional complexity to a\nwell-designed system.\n</P>\n<P>\n\n</P>\n<DT><B>Why should I use <CODE>PAL_USER</CODE> for allocating page frames?</B>\n<DD><A NAME=\"Why PAL_USER?\"></A>\n<P>\n\nPassing <CODE>PAL_USER</CODE> to <CODE>palloc_get_page()</CODE> causes it to allocate\nmemory from the user pool, instead of the main kernel pool.  Running out\nof pages in the user pool just causes user programs to page, but running\nout of pages in the kernel pool will cause many failures because so many\nkernel functions need to obtain memory.\nYou can layer some other allocator on top of <CODE>palloc_get_page()</CODE> if\nyou like, but it should be the underlying mechanism.\n</P>\n<P>\n\nAlso, you can use the <Q><SAMP>-ul</SAMP></Q> kernel command-line option to limit\nthe size of the user pool, which makes it easy to test your VM\nimplementation with various user memory sizes.\n</DL>\n<A NAME=\"Project 4--File Systems\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_5.html#SEC63\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_6.html#SEC85\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}