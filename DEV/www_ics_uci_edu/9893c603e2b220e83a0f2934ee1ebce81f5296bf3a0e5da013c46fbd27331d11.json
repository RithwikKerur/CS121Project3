{"url": "https://www.ics.uci.edu/~ejw/versioning/arch/0082.html", "content": "<!-- received=\"Tue Jun 11 11:35:00 1996 PDT\" -->\n<!-- sent=\"Tue, 11 Jun 1996 14:35:00 -0500\" -->\n<!-- name=\"Fabio Vitali\" -->\n<!-- email=\"vitali@cis.njit.edu\" -->\n<!-- subject=\"Re: Version identifier in URL\" -->\n<!-- id=\"v0300710dade3697244c2@[206.139.57.64]\" -->\n<!-- inreplyto=\"18461.834416971@worf.mks.com\" -->\n<title>Archive of Working Group on Versioning and Configuration Management of World Wide Web Content: Re: Version identifier in URL</title>\n<h1>Re: Version identifier in URL</h1>\n<b>Fabio Vitali</b> (<a href=\"mailto:vitali@cis.njit.edu\"><i>vitali@cis.njit.edu</i></a>)<br>\n<i>Tue, 11 Jun 1996 14:35:00 -0500</i>\n<p>\n<ul>\n<li> <b>Messages sorted by:</b> <a href=\"index.html#82\">[ date ]</a><a href=\"thread.html#82\">[ thread ]</a><a href=\"subject.html#82\">[ subject ]</a><a href=\"author.html#82\">[ author ]</a>\n<!-- next=\"start\" -->\n<li> <b>Previous message:</b> <a href=\"0081.html\">Fabio Vitali: \"Re: First cut at Functional Requirements document\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n<hr>\n<!-- body=\"start\" -->\n<pre>\n&gt;There are two scenarios possible in a \"hierarchical version\n&gt;space\":\n&gt;\n&gt;\t<a href=\"http://host/prefix/VERSION/suffix\">http://host/prefix/VERSION/suffix</a>\n&gt;\n&gt;and\n&gt;\n&gt;\t<a href=\"http://host/prefix/suffix/VERSION\">http://host/prefix/suffix/VERSION</a>\n&gt;\n&gt;The former has the advantage that, in the general case, we can\n&gt;specify a version for a subtree, which lets us \"surf into the\n&gt;past\" for free.  The latter has the advantage that, in a sense,\n&gt;different versions of a particular node in the heirarchy are\n&gt;subordinate to it.\n&gt;\n&gt;Unfortunately, neither option addresses the practical concern\n&gt;that the server has to have some way of determining\n&gt;&lt;strong&gt;when&lt;/&gt; a URL contains a version. I mean, the path\n&gt;\n&gt;\t<a href=\"http://host/foo/1.5/bar.html\">http://host/foo/1.5/bar.html</a>\n&gt;\n&gt;could easily reference a page discussing the history of the \"bar\"\n&gt;facility in Lisp 1.5.\n\nYou have to be extremely forgiving with me, but, maybe because english is\nnot my first language, maybe - probably - because I'm dense to this\narguments and simply stupid, in those cases when one is presenting a\nparadox he should always give both sides, so as to make it exactly clear\nthat it is indeed a paradox.\n\nNow your example here definitely looks like a paradox for the way it is\nphrased and the implicit sentences: \"could easily reference XXX [and we\nobviously don't want that]\" or \"could easily reference XXX [as well as YYY,\nand this is ambiguous]\". And, in your example, I'm missing something. I\nreally don't see the problem. No paradox for me.\n\nIn my view, the server never can have any problem in determining whether a\nURL contains a version or not, except for that damn example of the Thoth\noperating system that has me here in Sardinia tending stupid goats. The URL\nis opaque to the client, not to the server. Since it is the server that\nprovide the rules to build a URL (e.g. the directory path, the home\ndirectory, etc.), it also has to provide a rule to decode it. And to use\n\n&gt;\t<a href=\"http://host/prefix/VERSION/suffix\">http://host/prefix/VERSION/suffix</a>\n\nor\n\n&gt;\t<a href=\"http://host/prefix/suffix/VERSION\">http://host/prefix/suffix/VERSION</a>\n\nis a policy decision of the server, that we are not in the position to rule\nabout. Indeed, I would appreciate a system that provides both, so that I\ncan use either one in my client: the first syntax to use relative URLs to\n\"surf into the past\" (i.e. to get the correct versions of the documents and\nimages associated to \"suffix\"), the second syntax to use relative URLs to\n\"surf *across* the past\" (i.e. access different versions of document\n\"suffix\" - for comparison, merge, or whatever), both extremely valid and\njustifiable requirements.\n\nThe point for the server therefore is not how can the *server* know about\nversions, but what kind of \"surfing\" is the server going to provide (\"into\"\nor \"across\") by using relative URLs.\n\nThe problem on the other hand is how an aware *CLIENT* can know about\nversion information. This is a tough one. So we have two cases:\n\na) The client is version-unaware, and therefore any kind of version-related\noperations must be dealt with by the user manually or by existing and\nacceptable\ntechniques (e.g. relative URLs). In this case it is necessary that the user\nunderstands, possibly at a glance, about the policies used by the VCS at\nthe server, so that she can directly create URLs for related resources\n(across or into the past) and ask for them in the \"Goto:\" field.\n\nb) The client is version-aware, and therefore can deal with version-related\noperations autonomously. In this cases: we have two additional issues: if\nthere is a single acceptable policy, then a version-aware client could use\ndifferent VCS systems (for example, in different HTTP servers) without\nmodification to the code. Otherwise, if no single policy has been found, it\nis necessary that either the client is VCS-specific, or has code for\nmanaging all the different VCSs at the servers.\n\nSince having a single acceptable policy implies not just agreeing on how to\nstore version information in the URL, but also on how to deduce the URL of\nthe resource returned by the existing VCS operations (e.g. previous\nversion, next version, latest version in which Bill provided a\nmodification, etc.), I would think that this is, currently, an overly\noptimistic goal.\n\nTo summarize, the hierarchical specification is not a problem neither for\nthe server, nor for unaware clients, in my view, but only for version-aware\nclients that have to deal with several different policies. This leads, most\nprobably, to specialized clients aware of only one specific policy, i.e.\nworking in an aware manner with only one VCS. I personally do not see a way\nout of this.\n\nFabio\n</pre>\n<!-- body=\"end\" -->\n<hr>\n<p>\n<ul>\n<!-- next=\"start\" -->\n<li> <b>Previous message:</b> <a href=\"0081.html\">Fabio Vitali: \"Re: First cut at Functional Requirements document\"</a>\n<!-- nextthread=\"start\" -->\n<!-- reply=\"end\" -->\n</ul>\n", "encoding": "ascii"}