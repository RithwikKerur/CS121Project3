{"url": "https://www.ics.uci.edu/~aburtsev/238P/hw/hw1-shell.html", "content": "<HTML>\n<HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">\n<TITLE>238P Operating Systems</TITLE>\n<LINK HREF=\"./css/main.css\" TYPE=\"text/css\" REL=\"stylesheet\">\n<META NAME=\"Description\" CONTENT=\"Home page of Anton Burtsev.\">\n<META NAME=\"Keywords\" CONTENT=\"Anton Burtsev, Burtsev, Anton, cs238p\">\n<SCRIPT SRC=\"./scripts/image_switcher.js\" LANGUAGE=\"JavaScript\"></SCRIPT>\n</HEAD>\n\n<BODY BGCOLOR=\"#FFFFFF\" LEFTMARGIN=\"0\" TOPMARGIN=\"0\" MARGINWIDTH=\"0\" MARGINHEIGHT=\"0\">\n\t<TABLE  ID=\"text\" ALIGN=\"CENTER\" WIDTH=\"600\" BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD>\n\t\t<DIV ID=\"tech_nav\">\n\t\t\t<A HREF=\"../index.html\">Home</A>\n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"30\" ALT=\"\" BORDER=\"0\"/>\n\t\t</DIV>\n\t</TD>\n\t</TR>\t\n\t<TR>\n\t<TD COLSPAN=\"4\" ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\">\n\n\n\t\t<P>\n\n<h1>Homework 1: OS interface and shell</h1>\n\n<p>This assignment will make you more familiar with the Unix system call\ninterface and the shell by implementing several simple programs and several\nfeatures in a small shell, which we will refer to as the 238P shell.  You can\ndo this assignment on any operating system that supports the Unix API (Linux\nandromeda-XX.ics.uci.edu machines, your laptop that runs Linux or Linux VM, and\neven MacOS, etc.).  Submit your programs and the shell through Canvas (see instructions at\nthe bottom of this page). \n\n<p>First, you have to read the Chapter 0 of the <a\nhref=\"https://pdos.csail.mit.edu/6.828/2016/xv6/book-rev11.pdf\">xv6 book</a>.\n\n<h2>Part 1: Simple UNIX programs</h2> \n\n<p>Download the <a href=\"main.c\">main.c</a>, and take a quick look over it. This is a\nskeleton for a simple UNIX program.  \n\n<p>To compile <tt>main.c</tt>, you need a C compiler, such as gcc.  On\nandromeda-XX.ics.uci.edu (Openlab machines), you can compile the skeleton with the \nfollowing command: <pre> $ gcc main.c </pre> which produces an <tt>a.out</tt> file, which\nyou can then run as: <pre> $ ./a.out </pre> \n\n<p>Alternatively you can pass an additional option to gcc to give a more\nmeaningful name to the compiled binary, like <pre> $gcc sh.c -o foobar238p\n</pre>\n\n<p>Here gcc will compile your program as <tt>foobar238P</tt>.  \n\nIn the rest of this part of the assignment you will convert <tt>main.c</tt>\ninto several simple UNIX programs. \n\n<h3>File copy command (cp238p)</h3>\n\n<p>Use the main.c template as a starting point for a simple file copy command\nthat you should implement. First copy the <tt>main.c</tt> into\n<tt>main-cp238p.c</tt> (you will need to use <tt>main.c</tt> for other programs\nlater, so lets keep it around). \n\n<p>The file copy command should take two arguments: names of the input and the\noutput files and copy the input file into the output file.  Here is an example\ninvocation which copies <tt>main.c</tt> into <tt>main-out.c</tt> (assuming you\ncall your executable <tt>cp238p</tt>).  \n\n<pre>cp238p main.c main-out.c</pre>\n\nYou should use <tt>read()</tt> and <tt>write()</tt> system calls to read the\ninput file and write the output. Since <tt>cp238p</tt> takes command line\narguments you should change the definition of the <tt>main()</tt> function to\nallow passing of command line arguements like:\n\n<pre>int main(int argc, char *argv[])</pre>\n\nIf you have never worked with command line arguments in C here is a link that\nmight be useful: <a\nhref=\"http://publications.gbdirect.co.uk/c_book/chapter10/arguments_to_main.html\">Arguments\nto main</a>. You can also take a look at a couple of user-level programs that\ntake command line arguments from the xv6 source tree: <a\nhref=\"https://github.com/mit-pdos/xv6-public/blob/master/rm.c\">rm.c</a>, <a\nhref=\"https://github.com/mit-pdos/xv6-public/blob/master/ls.c\">ls.c</a>, <a\nhref=\"https://github.com/mit-pdos/xv6-public/blob/master/wc.c\">wc.c</a>. \n\n\n\n<p><b>Note:</b> You might find it useful to look at the manual page for\n<tt>read()</tt>, <tt>write()</tt>, and other system calls. For example, type\n<pre> $man read </pre> and read about the <tt>read</tt> system call. Here the\nmanual says that you should include <pre>#include &lt;unistd.h&gt;</pre> in your\nprogram to be able to use it, and the system call can be called as a function\nwith the following signature \n\n<pre> ssize_t read(int fd, void *buf, size_t count); </pre>\n\nThe manual describes the meaning of the arguments for the system call, return\nvalue, and possible return codes. Finally, it lists several related system\ncalls that might be helpful. \n\n<p>Note that when the manual list a function like <tt>open(2)</tt> it means\nthat it's described in the 2nd section of the manual and to get to the specific\nsection you have to invoke man with an additional argument like this: \n\n<pre>man 2 open</pre> \n\nIt's a good idea to read the man entry on man itself, i.e., <pre>man man</pre>.\nSome useful commands are <tt>-k</tt> to search the manual for the string\nmatching a query:\n\n<pre>man -k open</pre>\n\nNote, that here there are multiple entries for the <tt>open()</tt> system call\nand default invocation of <pre>man open</pre> will return an entry for the\n<tt>openvt</tt> command, and not file open command.\n \n\n<h3>Simple I/O redirection (lsy238p)</h3>\n\n<p>Use the <tt>main.c</tt> template again as a starting point for another\nsimple program that starts <tt>ls</tt> command but redirects its output into a\n<tt>y</tt> file. I.e., your program should do an equivalent of this shell\ncommand\n\n<pre>ls > y</pre>\n\nInternally your program should start <tt>ls</tt>, but before doing this it\nshould arrange that output of the ls is redirected into a file. Note, you don't have to \nimplement <tt>ls</tt> itself, just start the one that is already there in the \nsystem with the <tt>exec()</tt> system call. \n\n\n<p>First copy the <tt>main.c</tt> into <tt>main-lsy238p.c</tt> (again you will\nneed to use <tt>main.c</tt> for other programs later).  \n\n\n<p>Here is how an example invocation of your program should look \n(assuming you call your executable <tt>lsy238p</tt>).   \n\n<pre>lsy238p</pre>\n\nYou should use <pre>exec()</pre> system call to start ls and use other system\ncalls required to implement redirection, e.g., <tt>close()</tt>,\n<tt>open()</tt>. \n\n<h3>Simple pipes (pipe238p)</h3>\n\n<p>Use the main.c template again as a starting point for another simple program\nthat starts <tt>ls</tt> command but redirects its output into the <tt>grep\n\"main\"</tt> program, which itself redirects its output to the <tt>wc</tt>.\nI.e., your program should internally start three programs connected into with\npipes that produce output equivalent of this shell command\n\n<pre>ls |grep \"main\" |wc</pre>\n\nInternally your program should start three new programs: <tt>ls</tt>, <tt>grep\n\"main\"</tt>, and <tt>wc</tt> and connect them with pipes. \n\n<p>Copy the <tt>main.c</tt> into <tt>main-pipe238p.c</tt>. Here is an example\ninvocation of your program (assuming you call your executable\n<tt>pipe238p</tt>).  \n\n<pre>pipe238p</pre>\n\nYou should use <tt>exec()</tt> and <tt>fork()</tt> system calls to create\nprograms, <tt>pipe()</tt> system call to create pipes, and other system calls\nrequired for connecting pipes, e.g., <tt>close()</tt>, <tt>dup()</tt>. \n\n<h2>Part 2: Building a shell</h2>\n\nNow you are ready to integrate the basic skills that you've gained in the first\npart of the assignment into a more general program that implements I/O\nredirection, the shell. If you are not familiar with what a shell does, do the\n<a\nhref=\"http://web.mit.edu/6.033/2015/wwwdocs/assignments/handson-unix.html\">Unix\nhands-on</a> from 6.033 class at MIT (this is optional and will not be graded\nin 238P). \n\n<p>Download the <a href=\"sh.c\">238P shell</a>, and look it\nover. The 238P shell contains two main parts: parsing shell commands and\nimplementing them. The parser recognizes only simple shell commands such as the\nfollowing:\n\n<pre>\nls > y\ncat < y | sort | uniq | wc > y1\ncat y1\nrm y1\nls |  sort | uniq | wc\nrm y\n</pre>\nCut and paste these commands into a file <tt>t.sh</tt>\n\n<p>To compile <tt>sh.c</tt>, you need a C compiler, such as gcc.  On andromeda-XX.ics.uci.edu (Openlab machines), you\ncan compile the skeleton shell as follows:\n<pre>\n$ gcc sh.c\n</pre>\nwhich produces an <tt>a.out</tt> file, which you can run:\n<pre>\n$ ./a.out < t.sh\n</pre>\nThis execution will print error messages because you have not implemented several features. In\nthe rest of this assignment you will implement those features.\n\n<p>Alternatively you can pass an additional option to gcc to give a more meaningful name to the compiled binary, like\n<pre>\n$gcc sh.c -o sh238P\n</pre>\n\n<p>Here gcc will compile your shell as <tt>sh238P</tt>. \n\n<h2>Executing simple commands</h2>\n\n<p>Now, you're ready to work on the homework itself. First, extend your shell to implement simple commands, such as executing external programs, for example ls:\n<pre>\n$ ls\n</pre>\n\n<p>Here you tell the shell to execute ls.\n\n<p>In the sh.c, the parser already builds an <tt>execcmd</tt> for you, so the only code you\nhave to write is for the ' ' case in <tt>runcmd</tt>. <b>At a high level you should understand a \ntypical UNIX interface that we've discussed in class (the functions to cone processes, i.e., \nfork(), executing new processes, i.e., exec(), working with file descriptors (close(), dup(), open(), wait(), etc.). \nCombine these functions to implement various shell features.</b>  \n\n\n\n<p>\nYou might find it useful\nto look at the manual page for exec, for example, type\n<pre>\n$man 3 exec\n</pre>\nand read about <tt>execv</tt>. Print an error message when exec fails.\n\n<p>To test your program, compile and run the resulting a.out:\n<pre>\n$./a.out\n</pre>\n\nThis prints a prompt and waits for input. <tt>sh.c</tt> prints as prompt\n<tt>238P$</tt> so that you don't get confused with your computer's shell.\n\nNow type the following in your shell:\n<pre>\n238P$ ls\n</pre>\n\n<p>Your shell may print an error message (unless there is a program named\n<tt>ls</tt> in your working directory or you are using a version\nof <tt>exec</tt> that searches <tt>PATH</tt>, i.e., execlp(), execvp(), or execvpe()).  \n\nNow type the following:\n\n<pre>\n238P$ /bin/ls\n</pre>\n\n<p>This should execute the program <tt>/bin/ls</tt>, which should print out the\nfile names in your working directory. You can stop the 238P shell by typing\nctrl-d, which should put you back in your computer's shell.\n\n<p>You may want to change the 238P shell to always try <tt>/bin</tt>, if the program\ndoesn't exist in the current working directory, so that below you don't have to\ntype \"/bin\" for each program, or (which is better) use one of the exec functions \nthat search the <tt>PATH</tt> variable. \n\n<h2>I/O redirection</h2>\n\n<p>Implement I/O redirection commands so that you can run:\n<pre>echo \"238P is cool\" > x.txt\ncat < x.txt\n</pre>\n\n<p>The parser already recognizes \">\" and \"<\", and builds a <tt>redircmd</tt> for\nyou, so your job is just filling out the missing code in <tt>runcmd</tt> for\nthose symbols. You might find the man pages for open and close useful.\n\n<p>Note that the <tt>mode</tt> field in <tt>redircmd</tt> contains access modes\n  (e.g., <tt>O_RDONLY</tt>), which you should pass in the <tt>flags</tt>\n  argument to <tt>open</tt>; see <tt>parseredirs</tt> for the mode values that\n  the shell is using and the manual page for <tt>open</tt> for\n  the <tt>flags</tt> argument.\n\n<p>Make sure you print an error message if one of the system calls you are using fails.\n\n<p>Make sure your implementation runs correctly with the above test input.  A\ncommon error is to forget to specify the permission with which the file must be\ncreated (i.e., the 3rd argument to open).\n\n<h2>Implement pipes</h2>\n\n<p>Implement pipes so that you can run command pipelines such as:\n<pre>\n$ ls | sort | uniq | wc\n</pre>\n\n<p>The parser already recognizes \"|\", and builds a <tt>pipecmd</tt> for you, so\nthe only code you must write is for the '|' case in <tt>runcmd</tt>.  You might\nfind the man pages for pipe, fork, close, and dup useful.\n\n<p>Test that you can run the above pipeline. The <tt>sort</tt> program may be in\nthe directory <tt>/usr/bin/</tt> and in that case you can type the absolute\npathname <tt>/usr/bin/sort</tt> to run sort.  (In your computer's shell you can\ntype <tt>which sort</tt> to find out which directory in the shell's search path\nhas an executable named \"sort\".)\n\n<p>From one of the andromeda machines you should be able to run the following \ncommand correctly (here a.out is your 238P shell):\n<pre>\n$ a.out < t.sh\n</pre>\n\n\n<p>Don't forget to submit your solution through \nCanvas <a href=\"https://canvas.eee.uci.edu/courses/17834\">Canvas HW1 OS Interface and Shell</a>\n(as a collection of source files \"main-cp238p.c\", \"main-lsy238p.c\", \"main-pipe238p.c\", and \"sh.c\"). If you decide to submit a challenge exercise submit an \nextra file \"sh-extra.c\", and a shell script \"extra.sh\" that contains an example \nextra command that your shell can handle as a single tar or zip archive. \nPlease write us a comment at the top of \n\"sh-extra.c\" explaining  which extra features you decided to handle. \n\n<h2>Challenge exercises (extra 21%, 7% each)</h2>\n\n<p>You can add <b>any</b> feature of your choice to your shell.  But, you may want to consider\nthe following as a start:\n<ul>\n<li> Implement lists of commands, separated by \";\"\n<li> Implement sub shells by implementing \"(\" and \")\"\n<li> Implement running commands in the background by supporting \"&\" and \"wait\"\n</ul>\nAll of these require making changes to the parser and the <tt>runcmd</tt>\nfunction.\n\n\n\t</TD>\t\t\t\n\t</TR>\n\t<TR>\n\t\t<TD ALIGN=\"LEFT\" BGCOLOR=\"#FFFFFF\"><!-- top margin --> \n\t\t\t<IMG SRC=\"./images/spacer.gif\" WIDTH=\"100%\" HEIGHT=\"15\" ALT=\"\" BORDER=\"0\"/>\n\t\t</TD>\n\t</TR>\n\t<TR>\n\t<TD COLSPAN=\"4\">\n\t\t<DIV ID=\"tech\">Updated: April, 2019</DIV>\n\t</TD>\n\t</TR>\n\t</TABLE>\n</BODY>\n</HTML>\n\n", "encoding": "ascii"}