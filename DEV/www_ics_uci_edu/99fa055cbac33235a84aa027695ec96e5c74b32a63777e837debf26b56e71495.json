{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes991201.txt", "content": "WebDAV Advanced Collections Minutes December 1, 1999\n\nATTENDING: Judy Slein, Chuck Fay, Jason Crawford, Jim Whitehead, Kevin Wiggen\n\nDISCLAIMER: All decisions made by the design team are subject to review by \nthe WebDAV mailing list.\n\nACTION ITEMS\n\nJudy: Draft alternative text for bindings vs. URI mappings, send to design team\nJason: Contact Henry Sanders about Microsoft's difficulties with atomic DELETE.\nJason: Send a summary of discussions of atomic DELETE to the WebDAV list to get\nfurther discussion there.\nJudy: Investigate requirements for URNs to be sure a UUID URI can be used as a URN.\nJudy: Check with Geoff.  Is there anyplace in the versioning spec where XML is\ndefined for responses to OPTIONS?\nJudy: Send mail to WebDAV announcing that we are removing support for server-\nmaintained orderings.\n\nLOGISTICS\n\nNext meeting Wednesday December 8\n\nTHE BINDING SPEC\n\nNEW ABSTRACT\n\nAgreed: Judy will shorten the abstract to one or 2 paragraphs. Critical \ninformation will all be in the first paragraph.\n\nJim: Too long, too detailed.  Only the 1st paragraph will appear in\nannouncements.\n\nChuck: If you keep the example -- where you talk about the path segment,\nuse S to identify it, so that in the formal notation that follows, it\nwill be clear what S means. It's hard to parse the sentence with the\nexample. Break it out into bullets to make parsing easier.\n\nNEW INTRODUCTION\n\nAgreed: The changes are OK.\n\nJudy: Tried to make it less about letting resources be shared by multiple \ncollections and instead about creating additional URIS that can be used \nto access them.\nChuck: But it really is about letting multiple collections share a resource.\nJim: Likes the changes. It starts out by talking about creating additional\nURIs, but goes on to talk about resources being shared between collections\nas an effect of that. \nChuck: Agrees.\n\nNOTE IN SECTION 4: CAN'T CREATE A NEW URI UNRELATED TO A COLLECTION\n\nAction: Judy will send out some alternative wordings to the design team.\n\nJason: This text was difficult to understand.  The example was\ncritical to making it comprehensible at all.\nJim: It's confusing.\nWe might consider taking this out of the spec and putting it into the\nrationale document.\nIt might be easier to follow if it were moved back into the terminology\nsection where the distinction between bindings and URI mappings is being\nmade.  It's really about yet another way that bindings are different from\nURI mappings.\n\nDIFFICULTIES OF IMPLEMENTING BINDINGS (KEVIN)\n\nAgreed: No changes needed based on this discussion.\n\nKevin: His developers think it will be too difficult to implement\ncross-server bindings to collections.  They have an environment where\nthey have millions of users and terabytes of data on multiple servers.\nCross-server bindings are important to them, and eventually they will\nimplement them for individual resources, but not for collections.\nSince the spec does not provide any server-to-server protocol elements,\nit's not helpful for these cases. \nFor both individual resources and collections, you have to do 2-phase\ncommits.\nBindings to collections are just potentially much more dangerous.  A\nDELETE would potentially destroy enormous quantities of data if a\ncoordination mistake between servers happened.\nMaybe we should consider having 2 compliance classes, one for \nbindings to individual resources and one for bindings to collections.\nJim: You could just always refuse bind requests to collections.\nThe issues concern cross-server cases only, and only when the binding\nis to a collection.\nKevin: Also thinks it would be hard for a file system implement\nbindings. \nJason: On Linux, the file system doesn't allow hard links to collections, only to \nindividual resources, even if you are the superuser.  You can have symbolic\nlinks to collections, but not hard links.\n\nATOMICITY OF DELETE\n\nJudy: Rather not invent a new Atomic header if we can get away with just requiring\natomicity.\nJason never got a direct response to the question whether NT can do atomic\nDELETE.\nJim: Ask Henry Sanders.  He knows the most about the implementation details\nof IIS.\nHow likely is it that Microsoft will ever implement bindings in any case?  Maybe\nwe shouldn't worry too much about whether they like atomic DELETE.\nBut if we want to merge bindings back into RFC 2518, we want to have something\nthey can live with.\n\nWe need more discussion on the WebDAV mailing list.  If there is no consensus in\nfavor of atomic DELETE, we'll add the Atomic header.\n\nUUID VS. davresourceid URL SCHEME\n\nYaron wants a generic UUID URL scheme that can be reused.  There is none \ncurrently registered with IANA.  There are 2 expired internet drafts from\nMicrosoft.\n\nJim: UUID stuff from RFC 2518 is ok for our purposes.  Just change the name\nto UUID URI Scheme.\n\nJudy: What was the issue about whether they need to be URNs? \nJim: Since they are not really locators, someone might want to be able to\nuse them as names.  So make sure that they can be used as URNs.  Check the\nURN spec to be sure we don't say anything that would prevent that.\nJudy will investigate.\n\nOPTIONS\n\nAgreed: We'll return compliance classes in the DAV header.\n\nJudy: RFC 2518 defines the DAV header as the place to return compliance\nclasses.  Delta-V has defined a separate header that they will use to\nreturn their compliance classes.  What should we do?\nJim: Just use the DAV header.  He'll try to persuade Delta-V to do the same.\n\nJim thinks Delta-V may have defined some XML for use in OPTIONS responses.\nJudy looked at the versioning spec and couldn't find any.  We do define some\n(which will not be needed if we get rid of server-maintained orderings).\n\nMKRESOURCE\n\nJudy: We have to coordinate our decisions about MKRESOURCE with DeltaV.\n\nJim: There has been no further discussion of MKRESOURCE in DeltaV since\nwe last met.\n\nSERVER-MAINTAINED ORDERINGS\n\nAgreed: We will remove support for server-maintained orderings.\n\nJudy: The support we currently provide has no cost for a server that doesn't\nsupport any server-maintained orderings, and no cost to clients who don't\ncare.  The only cost is in added text in the spec.\n\nKevin: It does have the small cost that the server has to respond if \nsomeone asks what server-maintained orderings it can provide.\n\nKevin: We should not provide the marginal support for server-maintained\norderings that we do now.  Doing half the job now will just make it\nharder for anyone who wants to specify real support for server-maintained\norderings in the future.  We should do nothing, so that whoever writes\nthe real specification for server-maintained orderings in the future will\nhave a clean slate to work from.\n\nJudy: What about the proposal that a server be able to inform clients of\nits default ordering (if any)?\nDon't forbid a server to put an arbitrary value in DAV:orderingtype, but\ndon't say anything about this in the spec.\n\nMUST DAV:orderingtype BE RETURNED IN PROPFIND RESPONSES?\n\nAgreed: DAV:orderingtype should not be returned in PROPFIND responses\nunless the client asked for it.\n\nIn addition to the 2 options Kevin described on the mailing list, he\nhas another option to suggest:\nReally minimize the work for the server by not asking it to order the\nhrefs in PROPFIND responses.  Instead, have a seqno live property that\nit maintains (based on the client's instructions as already specified).\nIf a client cares about the ordering, it asks to have seqno returned with\nthe PROPFIND, and sorts the collection members itself.\n\nObjection: Very simple clients that do no sorting would display collection\nmembers in the right order given the current spec, but would lose that if\nwe let servers respond to PROPFIND with an arbitrary ordering.  \n\nMost clients probably do their own sort unless they know that the\nserver has some ordering that matters.\n\nObjection: You don't want to have to wait for the entire result set before\nstarting to display.\n\nKevin would like DASL and PROPFIND to work the same way.  (Some implementations\nare already using DASL to implement PROPFIND.)  Add an order-by clause to\nPROPFIND.\nJim: No, that's too complicated for PROPFIND.\n\nJim: We might want results from a DASL query to come back in the order\nspecified for the collection if no order-by is specified.\nKevin: Would like to be able to get a subset of a collection's members, but\nordered according to the collection ordering.  This would happen if DASL\nand PROPFIND worked the same way.\n\nKevin really wanted it to be that a server doesn't have to return\nthe collection members in any particular order unless the client\nasks for them to be returned ordered.\nThat was not the intent of the ordering spec.  If a collection has an\nordering, the server is required to respond to PROPFIND with the hrefs\nin that order.\nIt may turn out that ordered collections won't be very useful, because clients\nwill ignore the ordering that comes back and re-sort the results some other\nway.\n\nThe discussion we started out with was only about whether the server\nshould include DAV:orderingtype in PROPFIND responses even if the client\ndoes not explicitly request it.  Consensus is that it should not.\n\nMISC COMMENTS ON BINDING SPEC\n\nChuck: Remove the statement that support for cross-server bindings\nis unlikely.  Don't try to predict the future.  That might discourage\nclients from designing for cross-server bindings.  Just say that\nsupport for cross-server bindings is potentially costly.  (Kevin\ndoes expect to support cross-server bindings on individual resources\neventually.)\n\nJason: In the new text about checking lock / acl state of descendents,\nchange it to say \"Although deleting a binding to a resource affects\nonly that one binding, if the resource is a collection the server must\nexamine the lock state and access control restrictions on all descendents\nof the collection to determine whether to allow the DELETE.\" (Same for\nMOVE.)\n\nChuck: We don't want to commit ourselves to any particular lock\nsemantics in the binding spec.  Does this statement do that?\n", "encoding": "ascii"}