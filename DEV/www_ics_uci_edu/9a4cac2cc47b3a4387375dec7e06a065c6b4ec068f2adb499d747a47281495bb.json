{"url": "https://www.ics.uci.edu/~irani/w10_23/lab5.htm", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"course2.css\" type=\"text/css\" />\r\n\r\n<title>ICS 23 / CSE 23 - Project #5: Rock and Roll Stops the Traffic</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 23 / CSE 23 - Project #5: <i>Rock and Roll Stops Traffic</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, March 12, 6:59pm</i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Introduction</p>\r\n\r\n<p>As residents of southern California, most of us face the realities of heavy traffic.  If we attempt to drive on a local freeway during rush hour, we invariably experience major traffic jams and long delays.  What's worse, we are rarely apprised of unusual delays (e.g. accidents, road closures) before we've encountered them.  Even if we know about a delay in advance, it's often difficult to find a suitable alternate route, either because we're unfamiliar with the area or because those alternatives are just as clogged with traffic as the route we're trying to avoid.</p>\r\n\r\n<p>It's not hard to imagine how the presence of wireless Internet connections in everyone's car could help the situation.  Aside from providing the obvious ability to download traffic reports and maps on demand, with up-to-the-minute traffic information and a little computing, your car could actively aid you in finding the best way to get from one place to another, optimized not only for distance, but also for the shortest drive time given the current traffic conditions.  Further, if all cars were using the system, as drivers were diverted around the scene of an accident, traffic conditions would change; the advice offered by drivers' in-car systems would also change, optimally routing cars around a traffic jam by sending different cars down different alternate paths.  This way, even the alternatives might flow as quickly as possible.</p>\r\n\r\n<p>For this project, you will write a simplified version of such a system.  Given a map of streets and freeways, along with a snapshot of the current traffic between points on the map, your program will be capable of finding the shortest distance or fastest route to get from one location to another.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Our abstraction of a street map</p>\r\n\r\n<p>Real-life street maps, such as those created by companies like Thomas Bros., are a handy way for (most) human beings to determine an appropriate route to take from one location to another.  They present an abstraction of the world as a scaled-down drawing of the actual streets.  In order to be useful to us, a street map needs to give us the names of streets and freeways, to accurately demonstrate distances and directions, and to show us where the various streets and freeways intersect.</p>\r\n\r\n<p>For our program, we'll need to develop a different abstraction of a street map.  Our abstraction must contain the information that is pertinent to the problem we're trying to solve, presented in a way that will make it as easy as possible for our program to solve it.  Not surprisingly, a picture made up of lines and words is not an abstraction that is useful to our program; it would require a tremendous amount of effort to design and implement an algorithm to interpret the lines and words and build up some alternate representation that's more convenient.  It's better that we first design the more convenient representation, then train our program to read and understand an input file that specifies it.  To do so, we'll need to consider the problem a bit further.</p>\r\n\r\n<p>Our program's main job is to discover the shortest distance or time between two <i>locations</i>.  There's no reason we couldn't think of locations as being any particular point on a street map (for example, every valid street address, or even any valid GPS coordinate).  For simplicity, we'll think of them as one of two things:</p>\r\n\r\n<ul>\r\n  <li>The intersection of two or more streets.</li>\r\n  <li>A point on a freeway at which there is an entrance and/or an exit.</li>\r\n</ul>\r\n\r\n<p>Connecting pairs of locations on the map are stretches of road.  In order to solve our problem, we'll need to know two things about each stretch of road:</p>\r\n\r\n<ul>\r\n  <li>Its length, in miles.</li>\r\n  <li>The current speed of traffic traveling on it, in miles per hour.</li>\r\n</ul>\r\n\r\n<p>Our map will consist of two kinds of roads: <i>streets</i> and <i>freeways</i>.  A street is a sequence of intersections, connected by stretches of road in opposite directions.  The lengths of the stretches of road are generally the same, or at least nearly the same, on both sides of the street, though the amount of traffic -- and, therefore, the current speed of traffic -- on either side of the street may differ.  In real life, many intersections control traffic using stop signs or traffic lights.  Our program will ignore them; we'll instead assume that the traffic speeds on streets have been adjusted appropriately downward to account for the time spent waiting at stop signs and lights.</p>\r\n\r\n<p>Freeways seem like bi-directional roads, but they're actually two separate, divided stretches of road traveling in opposite directions.  For a few reasons, we will need to treat each side of the freeway as an entirely separate road:</p>\r\n\r\n<ul>\r\n  <li>The sequence of ramps on one side of a freeway is sometimes different than the sequence on the opposite side.  For example, near UCI, the 405 South has a transition ramp that leads to the 73 South, but the 405 North has no such ramp.  For this reason, there may be a different number of locations on one side of a freeway than another.</li>\r\n  <li>The amount of traffic on one side of a freeway may be radically different from the amount on the other, so the speed of the cars traveling in one direction may also differ widely.</li>\r\n</ul>\r\n\r\n<p>It turns out that our program will not need to think about streets and freeways separately, since they are both represented the same way: as a sequence of locations, connected by stretches of road.  Also, to keep the problem relatively simple, absolute directions (i.e. north, south, east, and west) will not be considered by our program or reported in its output.  For that reason, they won't be included in our abstraction of a street map, except optionally in the names of locations.</p>\r\n\r\n<p>The output of our program will be a <i>trip</i>.  A trip is a sequence of visits to locations on the map.  For example, when I used to live in Costa Mesa, my typical trip home from UCI looked like this:</p>\r\n\r\n<ul>\r\n  <li>Start at Peltason & Los Trancos</li>\r\n  <li>Continue at Bison & Peltason</li>\r\n  <li>Continue to Bison & California</li>\r\n  <li>Continue to Bison & 73N on-ramp</li>\r\n  <li>Continue to 73N @ Birch</li>\r\n  <li>Continue to 73N @ 73N-to-55N transition</li>\r\n  <li>Continue to 55N @ Baker</li>\r\n  <li>Continue to 55N Baker/Paularino ramp & Baker</li>\r\n  <li>Continue to Baker & Bristol</li>\r\n</ul>\r\n\r\n<p>In addition to the information above, our program will also output information about the distance in miles and travel time of each of the segments of the trip, as well as the overall distance and travel time for the whole trip.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Representing our abstraction of a street map</p>\r\n\r\n<p>If you consider all of the data that we'll need to represent this abstraction, the task of organizing it can seem overwhelming.  However, there is a well-known data structure that represents this system in a straightforward way: a directed graph.</p>\r\n\r\n<p>Using a directed graph, vertices can represent locations, and edges can represent the stretches of road that connect them.  Since traffic travels in only one direction on a given stretch of road, it makes good sense that the graph should be directed.</p>\r\n\r\n<p>Each vertex in the graph will have a human-readable name for the location it represents.  For example, a vertex might be named <b>Culver & Harvard</b> or it might be named <b>I-405N @ Jamboree</b>.  The name will be used only for display purposes; it won't have any significance in the shortest-path algorithm.  The vertices should be numbered uniquely and consecutively, starting at zero.  If there are <i>n</i> vertices, they should be numbered 0 .. <i>n</i> - 1.</p>\r\n\r\n<p>Each edge will contain the two necessary pieces of information about the stretch of road\r\nit represents: the distance between the two vertices (in miles, stored as a double) and the\r\ncurrent speed of traffic (in miles per hour, stored as a double).\r\n</p>\r\n\r\n<p>Since a trip is a sequence of visits to adjacent locations on the map, locations are represented by vertices, and two locations are adjacent only when there is an edge connecting them, a trip can be represented as a path in the graph.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The input</p>\r\n\r\n<p>Your program should read its input from a file.  So that we can keep everything straight during the grading process, please write your <b>main( )</b> method in a class called <b>Project5</b>, so that we can run your program using the following command:</p>\r\n\r\n<pre>\r\njava Project5 sample.txt\r\n</pre>\r\n\r\n<p>where the name of the input file is specified as a command-line argument to the program.  If we ran your program with the command above, it would read its input from the file <b>sample.txt</b>.</p>\r\n\r\n<p>Check out this <a href=\"sample.txt\">sample input file</a>.  A description of its format follows.</p>\r\n\r\n<p>The input file is separated into three sections: the locations, the road segments connecting them, and the trips to be analyzed.  Blank lines should be ignored.  Lines beginning with a <b>#</b> character indicate comments and should likewise be ignored.  This allows the input file to be formatted and commented, for readability.</p>\r\n\r\n<p>The first section of the file defines the names of the map locations.  First is a line that contains the number of locations.  If there are <i>n</i> locations, the next <i>n</i> lines of the file contain the names of each location.  The locations will be stored in a graph as vertices.  Each vertex is given a number.  You should number the vertices consecutively in the order they appear in the file, starting at 0.</p>\r\n\r\n<p>The next section of the file defines the road segments.  Each road segment will be an edge in the graph.  The first line of this section defines the number of segments.  Following that are the appropriate number of road segment definitions.  Each segment is defined on a line, with four values on it:</p>\r\n\r\n<ol>\r\n  <li>The vertex number where the segment begins.</li>\r\n  <li>The vertex number where the segment ends.</li>\r\n  <li>The distance covered by the segment, in miles.</li>\r\n  <li>The current speed of traffic on the segment, in miles per hour.</li>\r\n</ol>\r\n\r\n<p>Finally, the trips are defined.  Again, the section begins with a line containing the number of trips.  Following that are an appropriate number of trip requests.  Each trip request is a line with three values on it:</p>\r\n\r\n<ol>\r\n  <li>The starting location for the trip.</li>\r\n  <li>The ending location for the trip.</li>\r\n  <li><b>D</b> if the program should determine the shortest distance, <b>T</b> if the program should determine the shortest driving time.</li>\r\n</ol>\r\n\r\n<p>Your program should read the vertices and edges from the file, build the graph, then process the trip requests in the order that they appear.  The output for each trip request is described later in this write-up.</p>\r\n\r\n<p>You may assume that the input file will be formatted as described above.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Implementing the graph</p>\r\n\r\n<p>There are two well-known approaches that can be used to implement a graph: an <i>adjacency matrix</i> and <i>adjacency lists</i>.  As we've discussed in class, sparse graphs (that is, graphs with few edges relative to the number of vertices) are better implemented using adjacency lists, since an adjacency matrix would waste a great deal of memory storing the vast number of blank cells in the matrix.  Our street map is clearly a sparse graph, since each vertex will have edges to and from only a few relatively \"nearby\" vertices.  So, adjacency lists are a far superior approach in our case.  You are required to use this approach to represent your graph.</p>\r\n\r\n<p>A good way to store adjacency lists is to place each vertex's information into the cell of an array indexed by its vertex number.  Each cell has a vertex name and a reference to the first node in a list of its outgoing edges.  For each of these edges, we store the ID number of the adjacent vertex, the distance to that vertex, and the time to travel to it.  (Remember that an adjacent vertex is one that can be reached from the current vertex by following one edge.)  You will obviously need methods to build up the adjacency lists and to access them to get information about a particular vertex or edge.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Finding the shortest paths</p>\r\n\r\n<p>The problem we need to solve, that of finding the fastest or shortest trip along a network of roads, is not an uncommon one in computing.  In fact, it's so common that it's already been solved abstractly.  Our problem is an instance of the <i>single-source, positive-weighted, shortest-path problem</i>.  In other words, from one particular vertex (a \"single source\"), we'll be finding the shortest path to another vertex, where all of the edges have a \"positive weight\" (in our case, distance or speed, neither of which will ever be negative) associated with them.  We'll use a well-known algorithm called Dijkstra's Algorithm to solve this problem.</p>\r\n\r\n<p>Dijkstra's Algorithm actually finds the shortest path from some start vertex to <i>all</i> the other vertices in a graph -- this doesn't slow the algorithm down, since it needs to calculate them all in order to work -- though we're only interested in one of the paths that it will find.  There's a benefit to Dijkstra's calculation of all the shortest paths from some vertex.  Suppose the file has multiple trips starting from the same vertex.  With Dijkstra's Algorithm, we can compute shortest paths from any particular start vertex to all other vertices once for distance and once for time, storing the results in memory.  Then, to learn the shortest path from that start vertex to any other vertex, we can just look up the answer.  Use this approach in your program; it is likely the file will contain multiple trips that start from a particular place, and only a poorly-designed solution would require the program to re-compute data it has already computed.</p>\r\n\r\n<p>For each vertex <i>v</i>, Dijkstra's Algorithm keeps track of three pieces of information: <i>k<sub>v</sub></i>, <i>d<sub>v</sub></i>, <i>p<sub>v</sub></i>.</p>\r\n\r\n<ul>\r\n  <li><i>k<sub>v</sub></i> is a boolean flag that indicates whether the shortest path to vertex <i>v</i> is known.  Initially, <i>k<sub>v</sub></i> is <b>false</b> for all vertices.</li>\r\n  <li><i>d<sub>v</sub></i> is the length of the shortest known path from the start vertex to <i>v</i>.  When the algorithm begins, no shortest paths are known, so <i>d<sub>v</sub></i> is initially set to &infin; for all vertices, except the start vertex, for which <i>d<sub>v</sub></i> = 0.</li>\r\n  <li><i>p<sub>v</sub></i> is the predecessor of the vertex <i>v</i> on the shortest known path from the start vertex to <i>v</i>.  Initially, <i>p<sub>v</sub></i> is <b>unknown</b> for all vertices, except for the start vertex, for which <i>p<sub>v</sub></i> is <b>none</b>.</li>\r\n</ul>\r\n\r\n<p>As the algorithm proceeds, it will need to calculate the <i>cost</i> for individual edges.  The cost of the edge from <i>v</i> to <i>w</i> will be called <i>C</i>(<i>v</i>, <i>w</i>).  How you calculate the cost depends on whether you're minimizing driving distance or driving time:</p>\r\n\r\n<ul>\r\n  <li>If you're minimizing driving distance, <i>C</i>(<i>v</i>, <i>w</i>) is the number of miles on the edge from <i>v</i> to <i>w</i>.</li>\r\n  <li>If you're minimizing driving time, <i>C</i>(<i>v</i>, <i>w</i>) is the number of minutes required to drive along the edge from <i>v</i> to <i>w</i>, given its length and traffic speed.</li>\r\n</ul>\r\n\r\n<p>Dijkstra's Algorithm proceeds in phases.  The following steps are performed in each pass:</p>\r\n\r\n<ol>\r\n  <li>From the set of vertices for which <i>k<sub>v</sub></i> is <b>false</b>, select the vertex <i>v</i> having the smallest <i>d<sub>v</sub></i>.  In other words, of the shortest paths to each vertex that we've found that we're not yet sure about, pick the one that is the shortest.</li>\r\n  <li>Set <i>k<sub>v</sub></i> to <b>true</b> for the vertex you picked in step 1.  The shortest of the \"unknown\" paths is now considered to be known.</li>\r\n  <li>For each vertex <i>w</i> adjacent to <i>v</i> (i.e. there is an edge from <i>v</i> to <i>w</i>) for which <i>k<sub>w</sub></i> is <b>false</b>, test whether <i>d<sub>w</sub></i> is greater than <i>d<sub>v</sub></i> + <i>C</i>(<i>v</i>, <i>w</i>).  If it is, set <i>d<sub>w</sub></i> to <i>d<sub>v</sub></i> + <i>C</i>(<i>v</i>, <i>w</i>) and set <i>p<sub>w</sub></i> to <i>v</i>.  In other words, if the path through <i>v</i> to <i>w</i> is better than the shortest path we'd found to <i>w</i> so far, the shortest path to <i>w</i> (so far) is the path we've just found through <i>v</i> to <i>w</i>.</li>\r\n</ol>\r\n\r\n<p>For each pass, exactly one vertex has its <i>k<sub>v</sub></i> set to <b>true</b> (in other words, we discover one known shortest path per pass).</p>\r\n\r\n<p>Here is psuedocode for the algorithm.  Notice the use of a priority queue, which allows you to easily find the vertex with the smallest <i>d<sub>v</sub></i> in step 1.</p>\r\n\r\n<pre>\r\n    for each vertex v\r\n    {\r\n        set k<sub>v</sub> to false\r\n        set p<sub>v</sub> to unknown (or none, if v is the start vertex)\r\n        set d<sub>v</sub> to &infin; (or 0, if v is the start vertex)\r\n    }\r\n\r\n    let pq be an empty priority queue\r\n    enqueue the start vertex into pq with priority 0\r\n\r\n    while (pq is not empty)\r\n    {\r\n        vertex v = the vertex in pq with the smallest priority\r\n\r\n        if (k<sub>v</sub> is false)\r\n        {\r\n            k<sub>v</sub> = true\r\n\r\n            for each vertex w such that edge v -> w exists\r\n            {\r\n                if (d<sub>w</sub> &gt; d<sub>v</sub> + C(v, w))\r\n                {\r\n                    d<sub>w</sub> = d<sub>v</sub> + C(v, w)\r\n                    p<sub>w</sub> = v\r\n                    enqueue w into pq with priority d<sub>w</sub>\r\n                }\r\n            }\r\n        }\r\n    }\r\n</pre>\r\n\r\n<p>At the conclusion of the main loop, the <i>d<sub>v</sub></i> value corresponding to the end vertex will be the amount of the shortest path.  You can find the actual path of vertices by working your way backward from the end vertex to the start vertex, following the <i>p<sub>v</sub></i> values as you go along.  (This implies, of course, that you need to store all the <i>p<sub>v</sub></i> values.)</p>\r\n\r\n<p>Remember that, after the algorithm has finished, you should store the\r\nresults in memory so that you can look them up later.  I suggest storing\r\nthe <i>p<sub>v</sub></i> values long-term.  There's no reason to store\r\nthe <i>k<sub>v</sub></i> values, because they will all be <b>true</b> after\r\nthe algorithm is completed.  And there's no need to store the <i>d<sub>v</sub></i> values,\r\nbecause you will need to lookup the times or distances between each vertex in the\r\npath anyway, since we always output all of the segments of a trip, and you can\r\neasily sum these up to calculate a total while you're generating your answer.\r\n</p>\r\n\r\n<p>As you can see from the pseudocode, you will need to implement a priority queue in order\r\nto implement Dijkstra's Algorithm.  You are required to implement it using a binary heap,\r\nas we discussed in class, so that all enqueues and dequeues run in <i>O</i>(log <i>n</i>)\r\ntime.  The priority queue should be implemented in its own class, of course.\r\n<b> In order to get full credit for this lab, your priority queue must be implemented using\r\ngeneric types. </b> </p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The output</p>\r\n\r\n<p>For each of the trip requests in the input file, your program should output a neatly-formatted report to the console that includes each leg of the trip with its distance and/or time (as appropriate), and the total distance and/or time for the trip.</p>\r\n\r\n<p>If the trip request asks for the shortest distance, the output might look something like the following (these are phony trips, to show you the output format; they are not related to the sample data file provided above):</p>\r\n\r\n<pre>\r\nShortest distance from Alton & Jamboree to MacArthur & Main\r\n  Begin at Alton & Jamboree\r\n  Continue to Main & Jamboree (1.1 miles)\r\n  Continue to Jamboree & I-405N on ramp (0.3 miles)\r\n  Continue to I-405N @ MacArthur (1.3 miles)\r\n  Continue to MacArthur & I-405N off ramp (0.1 miles)\r\n  Continue to MacArthur & Main (0.2 miles)\r\nTotal distance: 3.0 miles\r\n</pre>\r\n\r\n<p>On the other hand, if the trip request asks for the shortest time, the output might look like this:</p>\r\n\r\n<pre>\r\nShortest driving time from Alton & Jamboree to MacArthur & Main\r\n  Begin at Alton & Jamboree\r\n  Continue to Alton & MacArthur (2.7 miles @ 33.7mph = 4 mins 48.8 secs)\r\n  Continue to Main & MacArthur (1.1 miles @ 40.1mph = 1 min 38.7 secs)\r\nTotal time: 6 mins 27.5 secs\r\n</pre>\r\n\r\n<p>When outputting a time, you should separate it into its components -- hours, minutes, and seconds -- as appropriate.  Here are some examples:</p>\r\n\r\n<pre>\r\n32.5 secs\r\n2 mins 27.8 secs\r\n13 mins 0.0 secs\r\n3 hrs 13 mins 12.3 secs\r\n6 hrs 0 mins 0.0 secs\r\n</pre>\r\n\r\n<p>Don't show hours if there are zero of them.  Don't show hours or minutes if there are zero of both of them.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Starting point</p>\r\n\r\n<p>You're required to write the code for this project from scratch.  No code is provided.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Deliverables</p>\r\n\r\n<p>You must turn in all of your <b>.java</b> files.  Please do not include any <b>.class</b> files, or other files generated by your development environment.</p>\r\n\r\n<p>Follow <a href=\"SubmittingProjects.html\">this link</a> for an explanation of how to turn in your project.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Limitations</p>\r\n\r\n<p>Except for <b>java.util.ArrayList</b>, you may not use any of the collection classes in the <b>java.util</b> library (e.g. LinkedList, TreeMap, HashMap).  Remember, as always, you are to implement your own data structures.  You're free, and encouraged, to use other utility classes, such as BufferedReader and StringTokenizer to read the input file.</p>\r\n\r\n</div>\r\n\r\n<div class=\"history\">\r\n\r\n<hr />\r\n\r\n<ul class=\"nomarker\">\r\n  <li> Requiring the priority queue to be generic, added by Sandy Irani, Winter 2010. </li>\r\n  <li>A few typos corrected, along with a small amount of additional explanation about Dijkstra's Algorithm added by Alex Thornton, Summer 2004.</li>\r\n  <li>Additional modifications and clarifications by Alex Thornton, Spring 2003.</li>\r\n  <li>Revised again by Alex Thornton, Fall 2002.</li>\r\n  <li>Minor revisions by Norman Jacobson, December 2001, March 2002, May 2002, and June 2002.</li>\r\n  <li>Revised for ICS 23 Fall 2001 by Norman Jacobson, September 2001.</li>\r\n  <li>Originally written by Alex Thornton, Spring 2001.  Portions of the description of Dijkstra's algorithm based on a description in <i>Data Structures and Algorithms with Object-Oriented Design Patterns in Java</i> by Bruno R. Preiss.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n\u0000", "encoding": "ascii"}