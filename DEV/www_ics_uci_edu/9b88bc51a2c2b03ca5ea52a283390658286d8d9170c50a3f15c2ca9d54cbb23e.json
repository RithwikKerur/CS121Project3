{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/writingclasses/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Writing Methods</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Writing Classes and Javadoc</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  We have already learned a lot about using classes from prewritten libraries\r\n    and about reading their Javadoc to understand them.\r\n  In this lecture, we will discuss the form and meaning of writing Java\r\n     classes and Javadoc.\r\n  So, we will examine the same language features that that we have already\r\n    used, but now from the perspective of writing classes.\r\n  <p>\r\n  The discussion starts by investigating methods in general.\r\n  We will discuss how to write <b>static</b> methods first (and\r\n    learn about the special <b>main</b> method in an application program)\r\n     and then in simple library classes (such as <b>Math</b> and <b>Prompt</b>\r\n     which programs can import) .\r\n  We will learn about call frames: pictures that illustrate the universal\r\n    parameter passing mechanism in Java: copy by value.\r\n  We will also learn how to write methods that throw exceptions, if they are\r\n    called with objects/arguments that do not meet their preconditions.\r\n  <p>\r\n  Finally, we will learn how to write more interesting classes, focusing on\r\n    declaring fields (mostly instance variables) and using them when writing\r\n    constructors and methods.\r\n  During this process, we will see how to use various features in the the\r\n    Eclipse IDE (edit view and debug perspective) that facilitate the\r\n    analyzing, writing, and debugging of classes.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Method Definitions -->\r\n\r\n<a name=\"MethodDefinitions\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Method Definitions and Parameter Initialization</b></td>\r\n<td width =\"80%\">\r\n  Let's start our discussing by examining a simple method that defines the\r\n    <b>min</b> method inside the <b>Math</b> class.\r\n  It illustrates most interesting aspects of <b>static</b> method definitions.\r\n  Before reading this code, quickly scan the EBNF for\r\n    <a href=\"../usingclasses/lecture.html#MemberEBNF\">\r\n    <i>method-definition</i></a>.\r\n  <b><pre>  public static int min (int a, int b) {\r\n    if (a <= b)\r\n      return a;\r\n    else\r\n      return b;\r\n  }</pre></b>\r\n  We divide method definitions into two parts: the <b>header</b> and the\r\n    <b>body</b>.\r\n  <ul>\r\n    <li>The method header comprises the access modifiers\r\n          (<b>public static</b>), return type (<b>int</b>), method name\r\n          (<b>min</b>), and parameters (<b>int a, int b</b>); if this method\r\n          threw any exceptions, they would be listed next.\r\n        We should be very familiar with reading method headers in Javadoc from\r\n          previous lectures.\r\n    <p>\r\n    <li>The method body is a <b>block-statement</b> that immediately follows\r\n          the method header.\r\n        In this lecture we will focus our attention on writing this block.\r\n        Its statements use the parameter names just like variable names;\r\n        in fact, we often call them parameter variables to make this\r\n          similarity explicit.\r\n  </ul>\r\n  We have already discussed that when a method is called, its parameter\r\n     variables are always initialized by their matching arguments first.\r\n  Then, the method body executes, using these values to compute and return\r\n    its result; it can also use local variables, declared and intialized in\r\n    the block, to help in its computation.\r\n  <p>\r\n  If we wrote the statement\r\n    <b><pre>  System.out.println( Math.min(3,5) );</pre></b>\r\n  it would display <b>3</b>.\r\n  If we had declared <b>int x = 3, y = 8;</b> and wrote the statement\r\n    <b><pre>  System.out.println(Math.min (3*x+5,y) );</pre></b>\r\n    it would display <b>8</b>\r\n  <p>\r\n  Generally, We call a method by writing its name, followed in parentheses \r\n    by its arguments (one for each parameter in the method's header)\r\n  As in the header (where parameters are separated by commas), arguments are\r\n    are separated by commas as well.\r\n  When we call a method, Java first evaluates each argument (each can be a\r\n    simple or complicated expression) and <b>transmits</b> or <b>passes</b>\r\n    it to its matching parameter; this just means that Java uses each\r\n    argument's value to initialize it matching parameter in the method.\r\n  It is equivalent to writing\r\n    <b><i>first-parameter</i> = <i>first-argument</i></b>, then \r\n    <b><i>second-parameter</i> = <i>second-argument</i></b>, etc.\r\n  <p>\r\n  Thus, when calling <b>Math.max(3*x+5,y)</b> above, the first parameter\r\n    (<b>a</b>) is initialized by the value <b>14</b> (<b>3*x+5</b>: the\r\n    equivalent of <b>a = 3*x+5</b>).\r\n  Likewise,  the second parameter (<b>b</b>) is initialized by the value\r\n    <b>8</b> (<b>y</b>: the equivalent of <b>b = y</b>).\r\n  Then, Java executes the body of the method, which typically performs some\r\n    computation using these initialized parameters.\r\n  It finally returns a result, by a mechanism that we discuss in the next\r\n    section.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Return Statement -->\r\n\r\n<a name=\"ReturnStatement\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The return Statement</b></td>\r\n<td width =\"80%\">\r\n  We will now discuss another Java statement, the <i>return-statement</i>,\r\n    whose EBNF is simply stated (<b>return</b> is a keyword) as\r\n <p>\r\n  &nbsp &nbsp <i>return-statement</i> <= <b>return</b> [<i>expression</i>];\r\n <p>\r\n  As a syntax constraint, Java requires that <i>expression</i> must be\r\n    compatible with the <i>return-type</i> specified in the method's header\r\n   (either be the same, or be implicitily convertible).\r\n In a <b>void</b> method (or a constructor), Java requires us to discard\r\n     this option altogether.\r\n  Typically, <i>expression</i> is a literal or a variable, but sometimes it is\r\n    a more general expression using operators/method calls.\r\n  For example, we will see methods that include the return statements\r\n  <b><pre>  return true;        return a;        return i%divisor==0;</b></pre>\r\n  <p>\r\n  We use a <b>return</b> statement to terminate a method and specify what\r\n    result (if any) it should return\r\n  Whenever a method executes <b>return</b>, no matter what else it is is\r\n    doing (i.e., inside loops or <b>try-catch</b> or ...), the method\r\n    immediately terminates and returns to where the method was called (its\r\n    <b>call site</b>).\r\n  If the method returns a value, it is as if the method call is \"replaced\"\r\n    by the value that it returns as a result.\r\n  <p>\r\n  Ideally, a method should contain just one <b>return</b> statement, at its\r\n    end.\r\n  In fact, we can prove mathematically that there is always a way to write a\r\n    method with one <b>return</b> statement.\r\n  But sometimes methods are easier to understand if they have multiple\r\n    <b>return</b> statements.\r\n  <p>\r\n  Thus, we will adopt a more pragmatic approach, putting simplicity as the\r\n    paramount aspect of the code that we write: if multiple <b>return</b>\r\n    statements make a method simpler and easier to understand, use them.\r\n  But be able to argue why; don't just use them because you are sloppy.\r\n  I would argue, for example, that the <b>min</b> method defined above, which\r\n     has two <b>return</b> statements, is simpler than the one below, which\r\n     has only one <b>return</b> statement.\r\n  <b><pre>  public static int min (int a, int b) {\r\n    int answer;\r\n    if (a <= b)\r\n      answer = a;\r\n    else\r\n      answer = b;\r\n    return answer;\r\n  }</pre></b>\r\n  Instead of one <b>if</b> statement, this method's body is a sequence of \r\n    three statements that declare a local variable, decide how to initialize\r\n    it, and then return that value.\r\n  The original method just chose which of its parameters to returns, without\r\n    declaring any local variable.\r\n  I think that the original method is simpler and easier to understand.\r\n  <p>\r\n  In fact, this method is actually defined in the Java library by using\r\n    a single return of a conditional expression:\r\n  <b><pre>  public static int min (int a, int b)\r\n  {return (a <= b ? a : b);}</pre></b></td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Sample Methods -->\r\n\r\n<a name=\"SampleMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Sample Methods</b></td>\r\n<td width =\"80%\">\r\n  The following method definitions compute useful and interesting values.\r\n  In practice, many useful methods are short, like these; study their\r\n    headers and especially their bodies.\r\n  <b><pre>  public static boolean isLeapyear (int year)\r\n  {return  (year%4 == 0 && year%100 != 0) || year%400 == 0;}</pre></b>\r\n  This method hides a very messy calculation inside a well-named and easy to\r\n    call method: it just has one parameter: the year to do the calculation on.\r\n  <p>\r\n  <b><pre>  public static boolean isBetween(int low,\r\n                                  int middle,\r\n                                  int high)\r\n  {return low<=middle && middle<=high;}</pre></b>\r\n  This method captures a common pattern that we have explored before\r\n    (and why <b>low <= middle <= high</b> does NOT correctly compute the\r\n    required value).\r\n  The correct way to perform this test is a bit verbose, so calling this\r\n     method can simplify our code.\r\n  <p>\r\n  <b><pre>  public static double distance (double x1, double y1,\r\n                                 double x2, double y2)\r\n  {return Math.sqrt( (x1-x2)*(x1-x2) +  (y1-y2)*(y1-y2) );}</pre></b>\r\n  This method computes the simple Euclidean distance between two points,\r\n    which must be specified as four parameters: the X- and Y-coordinate of\r\n    each point (although a better method would use two parameters, each\r\n    an instance of a <b>Point</b> class, to represent these four values).\r\n  Some methods have quite a few parameters (see below for even more).\r\n  <p>\r\n  <b><pre>  public static boolean inCircle (double centerX, double centerY,\r\n                                  double centerRadius,\r\n                                  double pointX, double pointY)\r\n  {return distance(centerX,centerY,pointX,pointY) <= centerRadius;}</pre></b>\r\n  This method calls <b>distance</b> to compute whether a point\r\n   (whose coordinates are <b>pointX</b> and <b>pointY</b>) falls within a\r\n    circle (whose center's coordinates  are <b>centerX</b> and <b>centerY</b>,\r\n    and whose radius is <b>centerRadius</b>).\r\n  Note that four of the coordinate <b>parameters</b> to <b>inCircle</b> become\r\n    <b>arguments</b> to the call of <b>distance</b>; this role switch is common\r\n    in methods calling other methods.\r\n  By layering methods on top of methods, each is kept small, but each new \r\n    method accomplishes much more than the methods it calls, by building on it;\r\n    this layer mechanism enables power programming.\r\n  <p>\r\n  <b><pre>  public static int factorial (int n) {\r\n    int answer = 1;\r\n    for (int i=2; i<=n; i++)\r\n      answer *= i;\r\n    return answer;\r\n  }</pre></b>\r\n  This method is interesting because it declares two local variables\r\n   (<b>answer</b> and <b>i</b>; methods can declare and use local variables\r\n   along with their parameters), one of which is finally returned.\r\n  When writing methods, beginners sometimes have difficulty determining when to\r\n    declare parameter variables and when to declare local variables.\r\n  Here is where thinking about prototypes helps: any information that must be\r\n    communicated to the method by arguments must be stored in a parameter\r\n    variable; local variables help in the computation, but do not need to be\r\n    initialized by arguments: we need <b>n</b> to specify the factorial we are\r\n    computing, but <b>answer</b> is always initialized to <b>1</b>\r\n      and <b>i</b> is always initialized to <b>2</b> in the <b>for</b> loop.\r\n  Methods should have the fewest number of parameters possible; if a variable\r\n    can be declared locally, it should be.\r\n  <p>\r\n  <b><pre>  public static int forInt (String message) {\r\n    for (;;)\r\n      try {\r\n       return Integer.parseInt(Prompt.forString(message));\r\n     }\r\n     catch (NumberFormatException nfe)\r\n       {System.out.println(\"Enter an int please\");}\r\n  }\r\n\r\n  public static int forInt (String message, int low, int high) {\r\n    for (;;) {\r\n      int answer = Prompt.forInt(message + \"[\" + low + \"..\" + high + \"]\");\r\n      if ( Utility.isBetween(low, answer, high) )\r\n        return answer;\r\n      System.out.println(\"Entered value not in range [\" + \r\n                         + low + \"..\" + hight + \"]\");\r\n    }\r\n  }</pre></b>\r\n  These overloaded <b>forInt</b> methods (two different signatures) are two of\r\n      my favorites; they are general purpose methods that we can use in many\r\n      different programs.\r\n  In fact, they are so useful that I have put these methods in the\r\n     <b>Prompt</b> class, so I can easily use them in any programs I write;\r\n     also, one calls the other so it further illustrates the power of composing\r\n     methods (even the first calls two other methods: <b>Integer.parseInt</b>\r\n       and <b>Prompt.forString</b>).\r\n  <ul>\r\n    <li>The first <b>forInt</b> uses a <b>try-catch</b> to ensure that the\r\n          value entered by the user (read as a <b>String</b>) is in fact a\r\n          legal <b>int</b> (in which case it immediately returns that value);\r\n          if the user doesn't enter a legal value, the <b>Integer.parseInt</b>\r\n          method instead throws <b>NumberFormatException</b> before the\r\n          <b>return</b> can finish; it is caught and processed by printing an\r\n          error message and executing loop again, prompting the user to enter\r\n          a value.\r\n    <p>\r\n    <li>The second <b>forInt</b> is passed three parameters, which are used to\r\n          coordinate prompting the user with a message to enter a value between\r\n          a lower and higher bound; the method rejects any entered values that\r\n          are outside this range, prompting the user until he/she enters a\r\n          value in this range.\r\n        By calling the previously defined <b>forInt</b> method, this method\r\n          doesn't have to worry about exceptions caused by incorrect data\r\n          entry: the other method handles those kinds of errors.\r\n        Again, layering of methods very useful here.\r\n  </ul>\r\n  Notice the sophisticated use of the <b>return</b> statements to terminate \r\n    these method and return an answer.\r\n  There is no need for a <b>break</b> statement because by terminating the\r\n    method, the loop is terminated too.\r\n  <p>\r\n  <b><pre>  public static int multiRoll (DiceEnsemble d, int times) {\r\n    int sum = 0;\r\n    for (int i=1; i<=times; i++)\r\n      sum += d.roll().pipSum();     //cascaded method call\r\n    return sum;\r\n  }</pre></b>\r\n  Finally, this method rolls a <b>DiceEnsemble</b> object the required\r\n    number of times, returning the sum of all the pips seen during all the\r\n    rolls.\r\n  So, we can pass reference types as parameters to methods as easily as\r\n    primitive types.\r\n  Here we use the generic identifier <b>i</b> as an index that counts the\r\n    appropriate number of throws (and is used nowhere else in the code); we\r\n    could have also written this as the countdown loop<br>\r\n    &nbsp &nbsp<b>for (/*parameter intialized*/; times>0; times--) {...</b><br>\r\n    noting that the parameter <b>times</b> is initialized when the method is\r\n    called (by its matching argument), so the <b>for</b> loop doesn't need to\r\n    initialize it.\r\n  <p>\r\n  In summary, we can define a simply-named method (with the parameters needed\r\n    to do the calculation) and a body that hides the \"messy\" calculation. \r\n  Then we can debug it, place it in a class, and easily use it in any other\r\n    software we write (forgetting about all the code inside it).\r\n  We are always only one method name away from hiding whatever complexity a\r\n    program requires.\r\n  By layering methods, we can quickly amplify their powers.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Hand Simulation -->\r\n\r\n<a name=\"HandSimulation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Hand Simulation via Call Frames</b></td>\r\n<td width =\"80%\">\r\n  In this section we will begin to learn how to hand simulate method calls\r\n    using the <i>call frame</i> mechanism, which is mostly concerned with\r\n    passing the arguments at the method call site to the parameters in the\r\n     method definition.\r\n  We will expand upon this mechanism, to show its real predictive power,\r\n    when we discuss passing references to objects into methods in the next\r\n    section.\r\n  <p>\r\n  The general form of a call frame is always the same.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/callframe.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  For a concrete example, let's see how to write a call frame for the\r\n    <b>min</b> method definition, being called as <b>Math.min(x,y+1)</b>.\r\n  First, the parameter mechanism in Java is called <b>copy by value</b>.\r\n  With copy by value, Java copies the value of each argument (arguments are\r\n    evaluated when a method is called, at its call site) into a parameter\r\n    variable: pictured, as always, a box labeled  by its parameter's name\r\n    and type.\r\n  So, parameters are just special kinds of variables: each is always\r\n    initialized by the value of it matching argument from the call site.\r\n  <p> \r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/mincf.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  There are no local variables here, so we leave blank that part of the call\r\n     frame.\r\n  After the call frame has been specified, and the parameters have been \r\n    initialized, Java executes the body of the method, which refers to the\r\n     parameters to compute its value.\r\n  The result is that this method returns <b>5</b>, which replaces the method\r\n    call at the call site, in the <b>System.out.println</b> statement, so\r\n    ultimately <b>5</b> is printed on the console.\r\n  <p>\r\n  For another example, here is a call frame for the <b>factorial</b> method\r\n  Note that after it returns to the call site, the value that it returns as a\r\n     result is stored into the variable <b>y</b>.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/factcf.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Besides its single parameter, this method declares two local variables\r\n   (<b>answer</b> and <b>i</b>, the <b>for</b> loop index variable), which are\r\n    initialized in their declarations to <b>1</b> and <b>2</b> respectively\r\n    when Java executes the body of its method.\r\n  Note how state changes to variable are illustrated: crossing out the old\r\n   value and writing the new value after it.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Advanced Call Frames -->\r\n\r\n<a name=\"AdvancedCallFrames\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Advanced Call Frames</b></td>\r\n<td width =\"80%\">\r\n  In this section, we will explore call frames in a bit more detail, looking \r\n    closely at the difference between changing the state of a variable and \r\n    changing the state of an object (referred to by a variable).\r\n  Let's start by hand simulating a call to the following method\r\n  <pre><b>  public static void swap (int a, int b) {\r\n    int temp = a;\r\n    a = b;\r\n    b = temp;\r\n  }</b></pre>\r\n  Let's assume that this method is defined in a class named <b>Utility</b>\r\n    and that we declare <b>int x=5, y=8;</b> and call <b>Utility.swap(x,y);</b>\r\n    what values are ultimately stored in <b>x</b> and <b>y</b>?\r\n  Are these variables swapped, or do they remain unchanged?\r\n  The call frame shows us.\r\n  <p>\r\n  IMPORTANT: If we do not execute a <b>return;</b> statement in a <b>void</b>\r\n    method (there is none in the code below), Java automatically does the\r\n    equivalent of <b>return;</b> when it reaches the end of the block that\r\n    is the body of the method.\r\n  Java DOES NOT allow an implicit return in a non-<b>void</b> method, becuase\r\n    we MUST specify an expression that tells Java what value the method\r\n    returns as its result; but, because <b>void</b> methods return nothing,\r\n    Java can reasonably include an implicit <b>return;</b> at the end of the\r\n    body.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/swapcf.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  It is important to note that although the values in the parameters\r\n    (<b>a</b> and <b>b</b>) are exchanged by this code, the values stored in\r\n    the arguments (<b>x</b> and <b>y</b>) ARE NOT EXCHANGED.\r\n  The values stored in the arguments were copied to the parameters when the\r\n    method was called, but this transmission mechanism is ONE-WAY ONLY: FROM\r\n    ARGUMENTS TO PARAMETERS.\r\n  Thus, parameter transmission is asymmetrical.\r\n  If an argument is a variable, the value stored in that variable always\r\n    remains unchanged by a method call, even if we change the value stored in\r\n    its matching parameter.\r\n  The value in the box of the argument cannot be changed in a method call.\r\n  <p>\r\n  The situation gets a bit more complicated and interesting with references,\r\n    because everything is more complicated and interesting with references.\r\n  Recall how to copy a reference into a variable: make the variable refer to\r\n    the same object (this describes how references are passed from arguments to\r\n    parameters as well).\r\n  Although the value in the box of the argument cannot be changed in a method\r\n    call (it will still refer to the same object), the state of the object\r\n    that it refers to CAN BE CHANGED in the body of the method by calling\r\n    mutators/commands.\r\n  <p>\r\n  Let's look at the call frame for the <b>multiRoll</b> method to illustrate\r\n    his behavior.\r\n  Assume again that this method is defined in a class named <b>Utility</b> and\r\n    that we declare <b>DiceEnsemble dice = new DiceEnsemble(2,6);</b> and call \r\n    <b>System.out.println(Utility.multiRoll(dice,3));</b>\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/multithrowcf.gif\"></image>\r\n  <image src=\"images/multithrowcf2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Java passes the argument to the parameter by copying its reference, resulting\r\n    in both the argument <b>dice</b> and the parameter <b>d</b> sharing the\r\n    same object.\r\n  Then, each time the <b>multiRoll</b> method calls <b>d.roll();</b> the state\r\n    of the shared object changes (see the <b>rollCount</b> and <b>pips</b>\r\n    instance variables).\r\n  The different values returned by <b>getPipSum</b>\r\n   (<b>7=2+5</b>, <b>4=3+1</b>, <b>5=1+4</b>) account for the state changes\r\n     shown for the local variable <b>sum</b>.\r\n  So, the first statement prints the returned value from <b>sum</b>\r\n    (<b>16</b>), and the second prints the value of <b>rollCount</b> from the\r\n    object (now <b>3</b>)\r\n  <p>\r\n   In summary, we cannot change arguments in a method call by changing the\r\n     values stored in their matching parameters. \r\n   But, if an argument and parameter share an object, then we can change the\r\n     state of that object by calling a mutator/command method in the method.\r\n   Once the method returns its result, the argument must refer to the same\r\n     object, but THAT OBJECT'S STATE CAN BE CHANGED.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- final parameters -->\r\n\r\n<a name=\"final\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>final parameters</b></td>\r\n<td width =\"80%\">\r\n  Finally, here is an update to the EBNF rule for <i>parameter</i>.\r\n  It adds the option of specifying the keyword <b>final</b> before <i>type</i>.\r\n  <p>&nbsp &nbsp <i>parameter</i> <= [<b>final</b>] <i>type</i> <i>identifier</i><p>\r\n  If a parameter variable is declared <b>final</b>, we must treat it like\r\n    any other <b>final</b> variable: we cannot change its state.\r\n  So, throughout the method body it will always store the value to which it\r\n    was initialized by its matching argument.\r\n  It is frequently (but not always) the case that a method examines\r\n    but does not store into its parameters.\r\n  So, most of the time we can specify that a parameter is <b>final</b>.\r\n  But, most Java style standards DO NOT require specifying parameters as\r\n    <b>final</b>, even if  they remain unchanged in the body of a method.\r\n  I'm still deciding what I think is right in this case; meanwhile, you can\r\n    choose either to include <b>final</b> in the code you write, to emphasize\r\n    that the parameter does not change, or omit it; whatever you choose, be\r\n    consistent.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Design -->\r\n\r\n<a name=\"Design\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Designing Methods</b></td>\r\n<td width =\"80%\">\r\n  When designing a method, first think of a descriptive name for it;\r\n    then think about the other prototype information: what its return type is\r\n    (if it is not <b>void</b>) and what parameter types it needs.\r\n    (in headers, unlike prototypes, we also should supply descriptive names\r\n     for the parameters).\r\n  Parameter variables are used to convey special information to the method;\r\n    information that controls what a method computes.\r\n  Methods may also have declare local variables, which are needed temporarily\r\n    during the execution of a method; but these values do not have to be\r\n    initialized by arguments outside the method.\r\n  Finally, and this is typically the easiest part, write the statements that\r\n    implement the method.\r\n  <p>\r\n  Most methods perform no input/output (unless that is the primary purpose of\r\n    the method).\r\n  Notice above that except for the <b>promptInt</b> methods, no others\r\n    perform input or output.\r\n  In some sense, methods get their \"inputs\" through their parameters; they \r\n    supply their \"output\" either through a returned result or by changing the\r\n    state of the objects that their parameters refer to.\r\n  So, do not write methods that perform input/output unless that is their\r\n    primary purpose.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- EBNF Defining Classes-->\r\n\r\n<a name=\"EBNFDefiningClasses\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>EBNF for Defining Classes including Package and Imports</b></td>\r\n<td width =\"80%\">\r\n  Everything in Java is defined in a class: simple programs (as you have \r\n    already written), as well as library classes.\r\n  The EBNF for a class relies heavily on the definition of\r\n    <a href=\"../usingclasses/lecture.html#MemberEBNF\">\r\n    <i>full-member-definition</i></a> (note <b>package</b> and <b>class</b> are\r\n    keywords).\r\n  <p>\r\n&nbsp &nbsp <i>package-declaration</i> <= <b>package</b> <i>package-name</i>;<br>\r\n&nbsp &nbsp <i>class-body</i>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n  <= {<i>full-member-definition</i>}<p>\r\n&nbsp &nbsp <i>class-definition</i>\r\n&nbsp &nbsp &nbsp &nbsp <=&nbsp [<i>package-statement</i>]<br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp{<i>import-declaration</i>}<br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n   <i>access-modifiers</i> <b>class</b> <i>identifier</i> {<br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp\r\n   <i>class-body</i><br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp }<p>\r\n  The braces in the last rule stand for themselves (in the previous rules they\r\n    stand for standard EBNF repetition).\r\n  Named classes in Java are defined in their own <b>.java</b> file.\r\n  <p>\r\n  Let's examine the three major parts of a <i>class definintion</i>.\r\n  First, the <i>package-statement</i>.\r\n  Every class is defined in one package, specified in the\r\n     <i>package-statement</i>; if this option is omitted, the class is said to\r\n     be defined in the <b>anonymous</b> also known as <b>default</b> package\r\n    (the name of this package has no characters in it).\r\n  Whatever package this class is in, all other classes in that package are\r\n    automatically imported for use in it.\r\n  Second, if this class must refer to any classes in other packages, they must\r\n    be imported explicitly in an <i>import-declarations</i>.\r\n  Finally, the class itself is defined: it specifies its own access modifiers\r\n    (almost always jut <b>public</b>) and includes any number of\r\n    <i>full-member-definition</i>s.\r\n  <p>\r\n  Here is a trivial but complete class named <b>Application</b>.\r\n  It is defined in the anonymous package, imports a neccessary class from the\r\n    course library, and has a <b>main</b> method that performs some\r\n    trivial I/O on the console.\r\n<pre><b>  import edu.uci.ics.pattis.introlib.Prompt;\r\n\r\n  public class Application {\r\n\r\n    public static void main(String[] args) {\r\n      int input = Prompt.forInt(\"Enter positive n\");\r\n      System.out.println(\"You entered: \" + n);\r\n    }\r\n}</b></pre>\r\n  Typically, such a class is stored in a file with the same first name as\r\n     the class:  <b>Application.java</b>.\r\n  After discussing <b>main</b> methods, will see how to define complete\r\n    classes for simple Java programs and libraries that define other methods.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- main method -->\r\n\r\n<a name=\"mainMethod\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The main Method</b></td>\r\n<td width =\"80%\">\r\n  Any Java class can define a special <b>main</b> method as one of its members;\r\n     but, a method with this name is special only if it has exactly the\r\n     following access modifiers and header\r\n  (This method specifies an array of <b>String</b> as its parameter, although \r\n    we will not use this parameter until we study how to use Java from a\r\n    command line; we will see below how to tell the Eclipse IDE which\r\n    special <b>main</b> method to execute.)<p>\r\n    &nbsp &nbsp <b>public static void main(String[] args)</b><p>\r\n  <p>\r\n  We can direct Java to start our program (a collection of one or more classes)\r\n    automatically in any special <b>main</b> method.\r\n  In fact, any project can include multiple classes, and each class can\r\n    have its own special <b>main</b> method (this is actually quite useful,\r\n    and we will discuss this feature when we discuss testing classes in more\r\n    detail).\r\n  In such a situation, we must tell Java WHICH special <b>main</b> method to\r\n    start with.\r\n  <p>\r\n  In Eclipse, we specify the class whose <b>main</b> method is to be run\r\n    by selecting the class either in the <b>Package Explorer</b> or in the\r\n    Editor.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Application Methods -->\r\n\r\n<a name=\"ApplicationMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods in Applications</b></td>\r\n<td width =\"80%\">\r\n  We have seen how to declare one special <b>static</b> method in a class and\r\n    have Java execute that method.\r\n  Now we will learn how to define and call other <b>static</b> methods in a\r\n    class.\r\n  All we must do is place these other method definitions inside the \r\n    class, along with the <b>main</b> method.\r\n  Then, we can call these method from <b>main</b> or from each other.\r\n  <p>\r\n  Any <b>static</b> method in a class can call any other static method in that\r\n     same class, just by using its name and supplying arguments that match its\r\n     signature (or, if overloaded, one of its signatures).\r\n  We can also be a bit more consistent (and verbose) and call a <b>static</b>\r\n    method by prepending the class name to the method's name.\r\n  The following <b>Application</b> class shows a simple example of such code.\r\n<pre><b>  import edu.uci.ics.pattis.introlib.Prompt;\r\n\r\n  public class Application {\r\n\r\n    public static int factorial (int n) {\r\n      int answer = 1;\r\n      for (int i=2; i<=n; i++)\r\n        answer *= i;\r\n      return answer;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n      int input = Prompt.forInt(\"Enter positive n\");\r\n      System.out.println(input + \"! = \" + factorial(input));\r\n    }\r\n}</b></pre>\r\n  Here, <b>main</b> prompts the user for a value (using the <b>static</b> \r\n    <b>forInt</b> method in the imported <b>Prompt</b> class) and\r\n    then uses that value as an argument to call the <b>factorial</b> method\r\n    defined in this class.\r\n  We have always called <b>static</b> methods in the form\r\n    <b><i>ClassName</i>.<i>methodName</i></b>; and, in fact, we could write<br>\r\n    &nbsp &nbsp <b>System.out.println(n + \"! = \" + Application.factorial(input));</b><br>\r\n  But, if one method defined in a class calls another method defined in that\r\n   same class, then we can shorten the call to just the method's name.\r\n  Most programmers use this shortened form for method names.\r\n  <p>\r\n  Another way to think about this issue is to imagine that a class is like a\r\n    family: all members of the <b>Application</b> class belong to a family\r\n    with that last name.\r\n  Each defined member's name is like a first name.\r\n  Members of the same family (class) can refer to each other by their first\r\n    names only, without ambiguity.\r\n  This is why <b>main</b> can refer just to <b>factorial</b>; we do not need\r\n    to write <b>Application.factorial</b>.\r\n  But, when refering to some <b>static</b> member OUTSIDE your family (class)\r\n    you must use both its last and first name (separated, of course, by a\r\n    period).\r\n  This is why we write <b>Math.sqrt</b> and <b>Prompt.forInt</b> in \r\n     <b>main</b> methods in the <b>Application</b> class.\r\n  <p>\r\n  A more complicated and interesting example of <b>static</b> methods appears\r\n    in the\r\n    <a href=\"../../programs/datecalculator1.zip\">\r\n      Date Calculator #1</a> program.\r\n  This program defines and used five <b>static</b> methods (and twelve\r\n    <b>static</b> fields).\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Definition Order</b></td>\r\n<td width =\"80%\">\r\n  Java uses a <b>multi-pass</b> compiler, which means that the methods and\r\n    fields in a program can be defined in any order: Java first reads all\r\n    the method headers and fields in the file, then in reads all the bodies,\r\n    checking that they all use the types of these methods and fields correctly.\r\n  <p>\r\n  One standard way to write methods is in the \"natural\" order: if the body of\r\n    method <b>b</b> calls method <b>a</b>, then method <b>a</b> is defined\r\n    before method <b>b</b>.\r\n  For example, we might have the following program form\r\n  <b><pre>  method a's header\r\n  {...no method calls...}\r\n\r\n  method b's header\r\n  {...call to a...}\r\n\r\n  method c's header\r\n  {...no method calls...}\r\n\r\n  method d's header\r\n  {...calls to b and c...}\r\n\r\n  main methods' header\r\n  {...calls to d and a...}</b></pre>\r\n  <p>\r\n  In fact, there may be many natural orders: e.g., in this example we could\r\n   also meet the natural criteria by defining method <b>c</b> before\r\n    method <b>b</b> or even before method <b>a</b>.\r\n  The <b>main</b> method calls lots of other methods, so it typically appears\r\n    last in the file.\r\n  <p>\r\n  In the \"reverse natural\" order: if the body of method <b>a</b> calls method\r\n    <b>a</b>, then method  <b>a</b> is defined after method <b>b</b>.\r\n  In this case, the <b>main</b> method calls lots of other methods, so it\r\n   typically appears first in the file.\r\n  <b><pre>  main methods' header\r\n  {...calls to d and a...}\r\n\r\n  method d's header\r\n  {...calls to b and c...}\r\n\r\n  method c's header\r\n  {...no method calls...}\r\n\r\n  method b's header\r\n  {...call to a...}\r\n\r\n  method a's header\r\n  {...no method calls...}</b></pre>\r\n  In this way, the most powerful methods appear at the top; we can read the\r\n    details of how they work aftward.\r\n  Because Java uses a multi-pass compiler, these two orderings, or any others,\r\n    are all legal.\r\n  When we discuss mutually recursive methods, we will return to this topic\r\n    again.\r\n  <p>\r\n  Now, some words on divide and conquer, and program complexity.\r\n  Up until now, we have been putting all of our code in the <b>main</b> method,\r\n    some of which have been a hundred or more lines of code.\r\n  This practice is stopping here!\r\n  From now on, we will be distributing complexity by writing methods, and\r\n    placing them in the application program, or in class libraries.\r\n  We can write, test, and debug each method (and each class) independently.\r\n  <p>\r\n  Each method, including <b>main</b>, should not comprise more than one or two\r\n    dozen statements; when a method gets too complicated (it does \"this\" and\r\n    \"that\") then write a \"this\" method and a \"that\" method, and have the\r\n     original method call these two new methods to get its job done.\r\n  Another rule for keeping the complexity of each method small it to prohibit\r\n    more than one loop (the most complex Java statement to think about) per\r\n    method -or allow multiple loops, but not nested loops.\r\n  <p>\r\n  Notice how the complexity has been distibuted in the date calculator program,\r\n    in which each method, even <b>main</b> contains only a small number of \r\n    statements.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Throwing Exceptions -->\r\n\r\n<a name=\"ThrowingExceptions\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Throwing Exceptions<br>(an introduction)</b></td>\r\n<td width =\"80%\">\r\n  We have already discussed how to handle thrown exceptions with\r\n    <b>try-catch</b> statements.\r\n  Now is an appropriate time to begin discussing the other end of exception\r\n     processing: how to throw them them after detecting a problem.\r\n  The EBNF rule for throwing an exception (using the keyword <b>throw</b>) is\r\n    trivial:<p>\r\n    &nbsp &nbsp <i>throw-statement</i> <= <b>throw</b> <i>expression</i>;<p>\r\n  where there is a syntax constraint that <i>expression</i> must refer to an \r\n    object constructed from a class descended from the <b>Throwable</b> class.\r\n  We will discuss class hierarchies later; for now we have seen the names of a\r\n    variety of classes descended from <b>Throwable</b>: <b>EOFException</b>, \r\n    <b>NumberFormatException</b>, and most important for our current needs,\r\n    <b>IllegalArgumentException</b>, and <b>IllegalStateException</b>.\r\n  <p>\r\n  Exceptions are represented by classes; so, throwing an exception requires us\r\n    to construct a new instance of the class, typically initializing its state\r\n    by a <b>String</b> that describes the problem; this <b>String</b> can be\r\n    further examined and printed when the exception is caught.\r\n  <p>\r\n  Given that our <b>factorial</b> method only works for non-negative integers,\r\n    we might modify it as follows, to detect a bad argument and throw\r\n    <b>IllegalArgumentException</b> with an appropriate message (rather than\r\n    just returning <b>1</b>).\r\n  Notice how <b>throws IllegalArgumentException</b> now appears in \r\n   <b>factorial</b>'s signature.\r\n<pre><b>  public static int factorial (int n)\r\n      throws IllegalArgumentException {\r\n    if (n < 0)\r\n      throw new IllegalArgumentException\r\n        (\"factorial: n (\"+n+\") must be non-negative\");\r\n\r\n    int answer = 1;\r\n    for (int i=2; i<=n; i++)\r\n      answer *= i;\r\n    return answer;\r\n  }</b></pre>\r\n  A simple <b>if</b> statement, the first in the method, determines whether or\r\n    not the argument is bad, and if so throws an exception.\r\n  It is common to check all the necessary preconditions on arguments at the\r\n    start of a method's body, grouping such code together and separating \r\n    it from the code that actually performs the method's task (which executes\r\n    only after all the preconditions on the parameters have been checked).\r\n  In this example, if the argument matching parameter <b>n</b> is a negative\r\n    value, Java constructs an instance of the <b>IllegalArgumentException</b>\r\n    class (initialized with an appropriate error message), and throws that\r\n    exception.\r\n  <p>\r\n  When a statement throws an exception, Java abandons sequential execution and\r\n    tries to locate a <b>catch</b> clause to handle the exception, first\r\n    inside the method in which it was thrown; if the method itself doesn't have\r\n    one, Java goes back to the call site for the method (which is the body of\r\n    some other method) and repeats this process there.\r\n  If by repeating this process, Java eventually gets back to the special\r\n    <b>main</b> method, and if there is no matching <b>catch</b> clause to\r\n    handle the exception, Java prints the exception name, the exception's\r\n    message (the <b>String</b> argument to the exceptions constructor), and\r\n    a trace of all the methods that were called, leading up to the problem.\r\n  <p>\r\n  We will use <b>throw</b> statements as we continue to learn about writing\r\n    constructors and methods in classes.\r\n  We will come back to the topic of <b>throw</b> statements and\r\n    <b>try-catch</b> statements, and exception classes at least once more\r\n    (in the context of class hierarchies), to help us further understand this\r\n     complex error detection and recovery mechanism.\r\n  There we will learn how to write new exception classes and the difference\r\n    between checked and unchecked exceptions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Library Classes -->\r\n\r\n<a name=\"LibraryClasses\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods in Library Classes</b></td>\r\n<td width =\"80%\">\r\n  Although some <b>static</b> methods might be useful in just one application,\r\n    many are general enough to be used in other (similar) applications.\r\n  In Java, we can easily collect these methods into a class of related methods\r\n    (all the source code in the same file), which we can easily import and use\r\n    in other programs.\r\n  <p>\r\n  The <b>Math</b> class in the standard Java library serves exactly this\r\n    purpose, as doe the <b>Prompt</b> class in the course library: each\r\n    collects together a group of math-related or console i/o related methods.\r\n  For example, we ccould easily group together all of the <b>static</b> methods\r\n    and fields from the date calculator program into a <b>DateUtility</b>\r\n    class as is shown below.\r\n  Then, we could use such a class library in any program that must deal with\r\n    dates.\r\n  Examine the <a href=\"../../programs/datecalculator2.zip\">\r\n    Date Calculator #2</a> program to see exactly how this mechanism works in\r\n    a project.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<pre><b>public class DateUtility {\r\n\r\n  //Returns whether year is a leap year?\r\n\r\n  public static boolean isLeapYear (int year)\r\n  {return (year%4 == 0 && year%100 != 0) || year%400 == 0;}\r\n\r\n\r\n\r\n  //Returns the number of days in month (in year)\r\n\r\n  public static int daysIn (int month, int year)\r\n      throws IllegalArgumentException {\r\n    if (year < 1)\r\n      throw new IllegalArgumentException\r\n                 (\"daysIn: year (\"+year+\") not positive\");\r\n    if (month < JANUARY || month > DECEMBER)\r\n      throw new IllegalArgumentException\r\n                  (\"daysIn: month (\"+month+\") not in range [1,12]\");\r\n\t  \r\n    //Thirty days hath September, April, June and November...\r\n    if (month == APRIL     ||\r\n        month == JUNE      ||\r\n        month == SEPTEMBER ||\r\n        month == NOVEMBER)\r\n      return 30;\r\n\t    \r\n    //...all the rest have thirty one...\r\n    else if (month == JANUARY || \r\n             month == MARCH   ||\r\n             month == MAY     ||\r\n             month == JULY    ||\r\n             month == AUGUST  ||\r\n             month == OCTOBER ||\r\n             month == DECEMBER)\r\n      return 31;\r\n\t   \r\n    //...except February (must be FEBRUARY in else: see possible exception)\r\n    else /* if (month == FEBRUARY) */\r\n      return 28 + (isLeapYear(year) ? 1 : 0);\r\n  }\r\n\t\r\n\r\n\r\n  //Returns the ordinal (1st, 2nd, 3rd, etc) representing month, day, year\r\n\r\n  public static int ordinalDate (int month, int day, int year) {\r\n    int ordinal = 0;\r\n\t  \r\n    //Scan every earlier month, summing the # of days in that month...\r\n    for (int m=JANUARY;  m < month;  m++)\r\n      ordinal += daysIn(m, year);\r\n\t  \r\n    //...and add day in the current month\r\n    return ordinal + day;\r\n  }\r\n\r\n\r\n\r\n  //Returns a date as an American or European String\r\n  //e.g., for February 10, 1954 these return \"2/10/1954\" and \"10/2/1954\"\r\n\r\n  public static String americanFormat (int month, int day, int year)\r\n  {return month + \"/\" + day + \"/\" + year;}\r\n  \r\n  public static String europeanFormat (int month, int day, int year)\r\n  {return day + \"/\" + month + \"/\" + year;}\r\n  \r\n  \r\n   \r\n\r\n  //Fields: all public static final (constants supplied by class)\r\n  //These could be private, for use only in this class,\r\n  //  but what the heck, let programmers use them from this class\r\n  //  (with final, there is nothing a programmer can do to change them)\r\n\r\n  public static final int JANUARY   =  1;  \r\n  public static final int FEBRUARY  =  2;  \r\n  public static final int MARCH     =  3;  \r\n  public static final int APRIL     =  4;  \r\n  public static final int MAY       =  5;  \r\n  public static final int JUNE      =  6;  \r\n  public static final int JULY      =  7;  \r\n  public static final int AUGUST    =  8;  \r\n  public static final int SEPTEMBER =  9;  \r\n  public static final int OCTOBER   = 10;  \r\n  public static final int NOVEMBER  = 11;  \r\n  public static final int DECEMBER  = 12;  \r\n}</b></pre>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Recall that final variables (constants) in Java are written as\r\n    upper-case identifiers.\r\n  If their name consists of multiple words, separate them by underscores:\r\n     e.g., <b>MAX_CLASS_SIZE</b>.\r\n  <p>\r\n  Given the use of a library class, the <b>main</b> method in the\r\n    <b>Application</b> class must refer to its members by using both their\r\n    class name and member name: e.g., \r\n    <b>int ordinal = DateUtility.ordinalDate(month, day, year);</b>\r\n  <p>\r\n  Again, observe that inside this class, we refer to each member by just its\r\n     name.\r\n  Outside the class (in the <b>Application</b> class) we must refer to each\r\n    <b>static</b> member by its class name followed by its member name.\r\n  <p>\r\n  Finally, note that there are no constructors for this class (and likewise no\r\n    instance variables).\r\n  We do not construct objects from this class; we just use the class name\r\n    directly to refer to the methods that we want to call from this class.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Eclipse -->\r\n\r\n<a name=\"Eclipse1\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods/Fields and the Eclipse IDE</b></td>\r\n<td width =\"80%\">\r\n  Methods are so common in programming, various parts of the Eclipse IDE\r\n    have been built to deal with them easily.\r\n  Here we will examine mechanisms in the Java and Debugger views that help us\r\n    use methods in our programs.\r\n  <p>\r\n  The editor includes a mechanism to locate and display a method easily in a\r\n     program or library class.\r\n  When a class is active in the editor, the <b>Outline</b> window lists all\r\n    the methods in the class.\r\n  We can easily view a method in the editor by clicking its name in the\r\n    <b>Outline</b> window.\r\n\r\n  As the number of methods in a class grows, this mechanism becomes more\r\n    and more useful for quickly navigating files.\r\n  <p>\r\n  To the left of each method header is small shaded circle, containing either\r\n    a minus sign or a plus sign.\r\n   The minus sign means the method is fully disclosed; the plus sign means\r\n     the method body is non-disclosed/elided (we see only its header).\r\n   Clicking the circle toggles between disclosed and elided method bodies.\r\n  <p>\r\n  We can also use the debugger to better understand methods and debug methods\r\n    that we have written.\r\n  The options displayed when we are stepping through a program appear as\r\n  <p>\r\n  <image src=\"images/step.gif\"></image>\r\n  <ul>\r\n    <li>Middle: The <b>Step Over</b> button (the arrow pointing over a bar, as\r\n          we have discussed) executes a  method as if it were a black box:\r\n          it does not show what happens inside a stepped-over method, it just\r\n          executes its entire body in one fell swoop.\r\n    <li>Left: The <b>Step Into</b> button (the arrow pointing down between two\r\n          bars) executes a method by first showing its parameters and local\r\n          variables (in the <b>Variables</b> tab).\r\n        Then, we can step through each statement in the method and watch how it\r\n          executes.\r\n        If we step through a <b>return</b> statement, we will be returned to\r\n          the code that called the method.\r\n        If the method we are stepping through calls another method, we can\r\n          choose to step-into or step-over that other call.\r\n    <li>Right: The <b>Step Out</b> button (the arrow pointing up out of two\r\n          bars) executes all the remaining statements in the current method, up\r\n          to and including its <b>return</b> statement.\r\n  </ul>\r\n  Note, the single bar for the middle button represents an entire statement.\r\n  Stepping over it means ignoring the details of any methods that are called\r\n    in that statement.\r\n  The double bars in the left and right buttons represent a block of code\r\n    implementing a method.\r\n  We can step into a method (start executing the first line of code in the\r\n     methods) and step out of a method (finish executing the last line of\r\n     code in the method).\r\n  <p>\r\n  When we step into a method, its parameter and local variables appear in the\r\n    <b>Variables</b> tab.\r\n  All its parameters will be intialized to the values of their matching\r\n     arguments.\r\n  The name of the method will also appear underneath <b>Thread[main]</b> at\r\n     in the <b>Debug</b> tab.\r\n  If it calls another method, that method's name will appear above it (now\r\n    directly underneath <b>Thread[main]</b>); whenever a method returns, its\r\n    name is removed from the <b>Debug</b> tab and control returns to the\r\n    method that called it (the one right below it in the <b>Debug</b> tab).\r\n  <p>\r\n  If you click any method name in the <b>Debug</b> tab, it will show you\r\n    the code that is executing in that method (in the editor window) and that\r\n    method's parameters and local variables (in the <b>Variables</b> tab).\r\n  In this way, it is easy to shift focus among the methods that are currently\r\n    executing.\r\n  The <b>Application.main</b> method remains at the bottom of these method\r\n    names in the <b>Debug</b> tab, throughout the execution of the program.\r\n  <p>\r\n  In the example below, we are looking at the bottom of the <b>daysIn</b>\r\n    method; note its parameters have been initialized: <b>month</b> is\r\n    <b>2</b> and <b>year</b> is <b>2006</b>.\r\n  In fact, this method has already called the <b>isLeapYear</b> method (it is\r\n    at the top of the methods, so it is the one currently executing), but we\r\n    have refocused our attention back to the <b>daysIn</b> method that called\r\n    it, by selecting this method in the <b>Debug</b> tab.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/stack.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  After we select the <b>isLeapYear</b> method and continue single-stepping,\r\n    we return to the <b>ordinalDate</b> method, which shows the position it\r\n    is executing (in the body of the loop) and all its parameters and local\r\n    variables listed in the order they were declared in:\r\n    parameters <b>month</b>, <b>day</b>, and <b>year</b>; local variables\r\n     <b>ordinal</b> and <b>m</b> -the loop index.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/stack2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Practice using these three kinds of stepping using the two Date Calculator\r\n    programs.\r\n  The time you spend becoming familiar with debugging features will pay for\r\n    itself many times over during the semester: debugging is hard, and these\r\n    tools help tremendously.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Classes with Objects -->\r\n\r\n<a name=\"DefiningClasses\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Defining Classes from which we Construct Objects</b></td>\r\n<td width =\"80%\">\r\n  We will now shift our focus from simple classes that have only <b>static</b>\r\n    members towards more interesting and useful classes: those from which we\r\n    can construct and manipulate objects/instances.\r\n  We will first examine why/how these classes declare instance variables.\r\n  Although instance variables are declared to be <b>private</b>, we wll learn\r\n    that all other members in their class can manipulate them.\r\n  Then we will learn how to write constructors that help initialize these\r\n    instance variables.\r\n  Finally, we will build on our knowledge of methods to learn how to write\r\n    methods that manipulate instance variables.\r\n  We will discuss multiple uses of the keyword <b>this</b> in the context\r\n    of classes from which we construct objects\r\n  <p>\r\n  Classes in Java combine elements of both state and behavior.\r\n  State is embodied in an object's <b>private</b> instance variables;\r\n     behavior is embodied in the class's <b>public</b> constructors and\r\n     methods, which manipulate these instance variables.\r\n  Programmers think about classes from three important and different\r\n    viewpoints: user, implementor, and designer.\r\n  <ul>\r\n    <li>When a programmer thinks about using a class, he/she is interested\r\n          solely in its <b>public</b> members: what constructors can be used to\r\n          to build objects and what methods can be called to perform useful\r\n          operations on these objects.\r\n        Such a programmer is interested in WHAT can be done, but not HOW it is\r\n          done (so long as the implementation works and is efficient).\r\n        Reading Javadoc is the prime way to learn this information.\r\n    <p>\r\n    <li>When a programmer thinks about implementing a class, he/she is \r\n          interested first in what <b>public</b> members the class will supply\r\n          (again, what programmers using the class will be able to do); but in\r\n          addition, he/she is also interested in HOW such members can be\r\n          implemented.\r\n        Typically, knowing WHAT requires reading Javadoc; knowing HOW requires\r\n          writing Java code that specifies what state each object will store\r\n          and how its method bodies work to manipulate this state.\r\n        This programmer is often presented with many interesting decisions,\r\n          because there are many ways implement the same functionality.\r\n    <p>\r\n    <li>When a programmer thinks about designing a class, he/she is again\r\n          interested solely in what <b>public</b> members the class supplies.\r\n        This person must decide what members to include and then specify the\r\n          semantics of each member so that (a) users understand WHAT to do with\r\n          the class and (b) implementors understand HOW to implement it.\r\n        Designers do this by writing the <b>public</b> prototypes in a class\r\n          and documenting them with Javadoc.\r\n  </ul>\r\n  These three views are a bit of a simplification, because often one person\r\n    takes multiple roles, even all three: a programmer might need to use a\r\n    a class for a specific application, so he/she designs a general class that\r\n    will be usable for that application (and hopefully others), and then he/she\r\n    impelments the class; and closing the circle, he/she uses it in the\r\n    application.\r\n  Good design is hard.\r\n  A designer often needs lots of experience using/implementing classes before\r\n    he/she can effective design them (so others can use/implement them easily).\r\n  <p>\r\n  In this course we will mostly take the roles of users (as we have in \r\n    previous lectures) and implementors (as we will in this one).\r\n  As implementors, we will typically be given a design, and then be required\r\n    to implement it.\r\n  To accomplish this process, we will have to indentify the state that each\r\n    object stores, then declare it and define the required constructors and\r\n     methods.\r\n  <p>\r\n  Finally, who tests classes?\r\n  We will see that classes may be tested from all three prespectives.\r\n  <ul>\r\n    <li>The designer tests a class by developing a test suite along with\r\n           the Javadoc; because the designer doesn't know anything about the\r\n           implementation, this is  black-box testing.\r\n        Some test suites are open-ended (a driver) and some are closed\r\n           (we will learn about JUnit testing).\r\n    <p>\r\n    <li>The implementor tests a class by running the designer's tests against\r\n           the implementation, fixing errors exposed by the testing.\r\n        The implementor might also develop further tests based on the\r\n           actual implementation used (this is white-box testing).\r\n    <p>\r\n    <li>The user of a class implicitly tests it in an application program:\r\n          if the application does not work as expected, it may indicate that\r\n          the class(es) he/she is using are not correct (or, the user may\r\n          just be using them incorrectly).\r\n  </ul>\r\n  The situation of a non-working application is interesting.\r\n  Whose fault is it: the user of a class (for using it incorrectly) or\r\n    the writer of a class (for implementing it incorrectly)\r\n  We will examine this perspective at the end of the lecture, when we\r\n    summarize classes (focusing on <b>private</b> members).\r\n  <p>\r\n  The most important thing to know about a class is that any member defined\r\n   in a class can refer to any other member defined in that same class, EVEN IF\r\n   ITS ACCESS MODIFIER IS <b>private</b>.\r\n  So, access modifiers restrict what members defined OUTSIDE a class can\r\n    access; they do not restrict what members defined INSIDE a class can\r\n    access.\r\n  This rule allows a class implementor to declare instance variables\r\n    <b>private</b>, so they cannot be directly accessed by code OUTSIDE the\r\n    class, and still write constructors/method INSIDE the class that access\r\n    them; in fact, often accessor/query methods just return the values stored\r\n    in some <b>private</b> instance variable.\r\n  <p>\r\n  To illustrate all this material, we will closely examine two classes and\r\n    their drivers:\r\n    <a href=\"../../programs/simpledicedemo.zip\">\r\n      SimpleDiceEnsemble</a> and\r\n    <a href=\"../../programs/rationaldemo.zip\">Rational</a>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Fields -->\r\n\r\n<a name=\"Fields\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Instance Variables</b></td>\r\n<td width =\"80%\">\r\n  Let's start by looking at the implementation details for two sample classes.\r\n  The <b>SimpleDiceEnsemble</b> class must store information characterizing the\r\n    ensemble (number of dice and sides per die) and information about its\r\n    current state (number of rolls, pip sum, whether all die show the same\r\n    numer of pips).\r\n  It declares its instance variables as follows.\r\n  <b><pre>  private int     numberOfDice;\r\n  private int     sidesPerDie;\r\n  private int     rollCount;\r\n  private int     pipSum;\r\n  private boolean allSame;</pre></b>\r\n  <p>\r\n  The <b>Rational</b> class is much simpler: it must store only the numerator\r\n    and denominator of the rational number (fraction).\r\n  It declares its instance variables as follows.\r\n  <b><pre>  private int numerator;\r\n  private int denominator;</pre></b>\r\n  <p>\r\n  Classes typically group the declarations of all their fields at the top or\r\n     bottom (although there are no rules requiring this placement)\r\n  Recall that Javadoc pages show fields first, so declaring them at the top\r\n    is reasonable.\r\n  Another perspective is that instance variables are <b>private</b> details,\r\n     so declaring them at the bottom (out of the way) is reasonable.\r\n  <p>\r\n  Whenever <b>new</b> constructs an object, the first thing that it does is\r\n    process all the field declarations in the class, which includes reserving\r\n    space for all these field and initializing them.\r\n  Unlike local variables, ALL FIELDS ARE INITIALIZED when they are declared:\r\n    if we do not explicitly initialize them in their declarations, then Java\r\n    implicitly initializes them: for the primitive types, it uses <b>0</b> for\r\n     <b>int</b>, <b>0.</b> for <b>double</b>, <b>false</b> for\r\n    <b>boolean</b>, and the null character for <b>char</b>; for all reference\r\n    types  it uses <b>null</b> (meaning that they do not refer to any object).\r\n  <p>\r\n  In the examples above, all instance variables are initialized to <b>0</b>\r\n     and <b>false</b>; in <b>SimpleDiceEnsemble</b> it is as if we had \r\n     explicitly written\r\n  <b><pre>  private int     numberOfDice = 0;\r\n  private int     sidesPerDie  = 0;\r\n  private int     rollCount    = 0;\r\n  private int     pipSum       = 0;\r\n  private boolean allSame      = false;</pre></b>\r\n  We will soon see that constructors can (and often do) store more appropriate\r\n    values in these variables, based on the arguments that we supply to the\r\n    constructor.\r\n  So technically, when a constructor stores a value into an instance variable,\r\n    it is reinitialization, not initialization, because an initial value has \r\n    already been stored there by Java, when it executes its declaration.\r\n  Still, we will speak about initializing instance variables in constructors\r\n    (and reinitialization if we want to be precise).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Constructors -->\r\n\r\n<a name=\"Constructors\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n\r\n<td width =\"20%\"><b>Constructors</b></td>\r\n<td width =\"80%\">\r\n  The main purpose of any constructor is to ensure that all the instance\r\n    variables of the object being constructed are initialized correctly.\r\n  This is done in the body of the constructor, which contains exactly the\r\n   same statements that can appear inthe body of a <b>void</b> method.\r\n  <p>\r\n  For some instance variables a constructor may do nothing special: it leaves\r\n    them with the initial values they received when declared.\r\n  In other cases it initializes (actually reinitializes, given the\r\n    discussion above) instance variables using the arguments passed to the\r\n    constructor's parameters; the constructor often validates these arguments\r\n    first (throwing <b>IllegalArgumentException</b> if they are incorrect).\r\n  <p>\r\n  There are classes, some quite complicated, in which constructors take no\r\n    arguments and reinitialize no fields.\r\n  In these cases, the fields are initialized correctly in their declarations\r\n    (either explicitly or implicitly).\r\n  The <b>Timer</b> class is one example of this kind of class.\r\n  Its constructor looks like\r\n  <b><pre>  public Timer ()\r\n  {}</pre></b>\r\n  In fact, if we fail to define any constructor for a class, Java will\r\n    automatically supply one that looks like this one (with the appropriate\r\n    class name).\r\n  But, if we define even one constructor for a class, Java will not\r\n    overload the constructor(s) by defining this one.\r\n  <p>\r\n  Most classes define at least one constructor (and many overload the\r\n    constructor).\r\n  These constructors always have parameter that help reinitialize instance\r\n    variables.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>SimpleDiceEnsemble</b></td>\r\n<td width =\"80%\">\r\n  The first constructor defined in the <b>SimpleDiceEnsemble</b> class is\r\n<b><pre>  public SimpleDiceEnsemble (int numberOfDice, int sidesPerDie)\r\n      throws IllegalArgumentException {\r\n    if (numberOfDice < 1)\r\n      throw new IllegalArgumentException\r\n        (\"SimpleDiceEnsemble constructor: \" +\r\n         \"Number of dice (\"+numberOfDice+\") < 1\"); \r\n    if (sidesPerDie < 1)\r\n      throw new IllegalArgumentException\r\n        (\"SimpleDiceEnsemble constructor: \" +\r\n         \"Sides per die (\"+sidesPerDie+\") < 1\"); \r\n\r\n    this.numberOfDice = numberOfDice;\r\n    this.sidesPerDie  = sidesPerDie;\r\n    //rollCount: see declaration for implicit initializaton to 0\r\n    //pipSum and allSame indeterminate until roll\r\n  }</pre></b>\r\n  It first validates the values of its two parameters: if either does not make\r\n     sense (we must have at least one die, and it must have at least one side),\r\n     the constructor throws an <b>IllegalArgumentException</b> with an \r\n     appropriate message.\r\n  If the parameters do make sense, it copies them into two of the instance\r\n    variables (reinitializing them).\r\n  The other three instance variables are not reinitialized: the initial\r\n    values they received when decared are correct: <b>rollCount</b> should\r\n    always start at zero, and <b>pipSum</b> and <b>allSame</b>, although they\r\n    store zero/false, really represent nothing, because the dice haven't been\r\n    rolled yet (so any values would work for these).\r\n</td>\r\n</tbody>\r\n</table>\r\n<a name=\"NameConflicts\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Interlude: Variable Name Conflicts and Resolving\r\n                 them with \"this\"</b></td>\r\n<td width =\"80%\">\r\n  We must take a briefly diversion to discuss variable name conflicts and how \r\n    to resolve them with  the keyword <b>this</b>.\r\n  There are three kinds of variable names in Java.\r\n  <ol>\r\n    <li>The name of a parameter (defined in the constructor/method header)\r\n    <li>The name of a local variable (defined in the constructor/method body)\r\n    <li>The name of a field (defined in its class)\r\n  </ol>\r\n  The Java compiler automatically implements a syntax constraint that prohibits\r\n    defining a parameter with the same name as a local variable.\r\n  So, the compiler would detect and report an error in following code\r\n  <pre><b>  public static int returnIt (int a) {\r\n    int a = 1;\r\n    return a;\r\n  }</b></pre>\r\n  In fact, Java points at the local variable declaration of <b>a</b> and says,\r\n    \"Variable 'a' is already defined in this method\".\r\n  <p> \r\n  But, Java does allow instance variables to have the same names as parameters\r\n    or local variables.\r\n  When this happens, it is called a variable name conflict, because when we\r\n    use that common name, there is a conflict as to what it means.\r\n  Whenever there is a variable name conflict, the name by itself NEVER refers\r\n    to the instance variable; it ALWAYS refers to the parameter or local\r\n    variable.\r\n  If instead we want to refer to the instance variable, we must preface its\r\n   name with <b>this.</b> (<b>this</b> is a keyword).\r\n  In a constructor, <b>this</b> is a reference to the object being constructed;\r\n    and <b>this.numberOfDice</b> refers to the <b>numberOfDice</b> instance\r\n    variable defined inside the class.\r\n  In fact, writing <b>this.numberOfDice</b> is always a legal way to refer to\r\n    the <b>numberOfDice</b> instance variable in the object being constructed,\r\n    whether or not there is a variable name conflict.\r\n  <p>\r\n  So, in the constructor above, both parameter variables have a name conflict\r\n    with two of the instance variables.\r\n  The <b>if</b> statements, which check <b>numberOfDice</b> and\r\n    <b>sidesPerDie</b>, are testing the parameter variables; the statements\r\n<pre><b>  this.numberOfDice = numberOfDice;\r\n  this.sidesPerDie  = sidesPerDie;</pre></b>\r\n  store the values of the parameter variables (which disappear when the\r\n    constructor finishes executing) into the instance variables (which exist so\r\n    long as the object they are in exists).\r\n  If we wrote <b>numberOfDice = numberOfDice;</b> then Java would just store\r\n    the parameter's value back into the parameter variable: it stores nothing\r\n    into the instance variable!\r\n  Such a statement can cause a very hard to locate bug!\r\n  <p>\r\n  Another way around this whole \"name conflict\" problem is to change the\r\n    parameter names; e.g. use <b>number</b> and <b>sides</b>.\r\n  With no name conflicts, so we can write just <b>numberOfDice = number;</b>\r\n    and <b>sidesPerDie = sides</b>.\r\n  But, it is often the case that a well chosen name for an instance variable is\r\n    replicated as a parameter name, because it captures exactly the right\r\n    description; in such cases we must understand name conflicts and use\r\n    <b>this</b> to resolve them.\r\n  <p>\r\n  To help avoid confusion, some style guidelines for Java specify that every\r\n    access to an instance variable should be prefixed by <b>this.</b> to\r\n    indicated explicitly it that is accessing a field.\r\n  I'm still on the fence about this style rule.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Back to Discussing Constructors</b></td>\r\n<td width =\"80%\">\r\n  The second <b>SimpleDiceEnsemble</b> constructor has a much different form.\r\n  First, it has no parameters; second, it does not throw any exceptions\r\n   (this information is all specified in the constructor's header).\r\n  We could have written this constructor as\r\n<pre><b>  public SimpleDiceEnsemble () {\r\n    numberOfDice = 2;\r\n    sidesPerDie  = 6;\r\n  }</b></pre>\r\n  which initializes the two instance variables so that the object represents\r\n    two, six-sided dice.\r\n  Note that because there are no parameter names in this constructor, so there\r\n    are no name conflicts; therefore, we can use the instance variables\r\n    directly with the <b>this.</b> prefix (although we could include this\r\n    prefix for stylistic reasons).\r\n  <p>\r\n  But Java provides an even simpler way to define this constructor (even if \r\n    it requires us to learn a new language feature: a different context in\r\n    which to use <b>this</b>).\r\n  The actual constructor appears as\r\n  <pre><b>  public SimpleDiceEnsemble () \r\n  {this(2,6);}</b></pre>\r\n  In the constructor above <b>this</b> says \"to initialize the instance\r\n    variables, use another constructor from <b>this</b> class, one taking two\r\n    <b>int</b> arguments.\r\n  This is a common pattern, where one general constructor (with many\r\n    parameters) is used by one or more special constructors (with fewer\r\n    parameters) to do the initializations.\r\n  Note that if we needed, we could add more statements to the constuctor AFTER\r\n    this one (here, none are needed).\r\n  <p>\r\n  In fact, another way to handle all the initialization in this class is to\r\n    declare\r\n  <b><pre>  private int     numberOfDice = 2;\r\n  private int     sidesPerDie  = 6;\r\n  private int     rollCount;\r\n  private int     pipSum;\r\n  private boolean allSame;</pre></b>\r\n  The first constructor would work as before,  reinitializing\r\n    <b>numberOfDice</b> and <b>sidesPerDie</b> using the parameters.\r\n  But the second constructor could be simplified to contain nothing in its\r\n     body, because now when the instance variables are declared, they correctly\r\n     represent two, six-sided dice.\r\n  <p>\r\n  Thus, constructors act as middlemen: they accept arguments, check these\r\n    values for correctness, and ultimately use them to (re)initialize instance\r\n    variables (if they are correct).\r\n  Because instance variables are <b>private</b>, they can be initialized only\r\n    in the declaration themselves, and reinitialized by a constructor defined\r\n    inside the class.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Rational</b></td>\r\n<td width =\"80%\">\r\n  The first and most general constructor defined in the <b>Rational</b> class\r\n    is\r\n<pre><b>  public Rational (int numerator, int denominator)\r\n    throws IllegalArgumentException {\r\n    if (denominator == 0)\r\n      throw new IllegalArgumentException\r\n        (\"Rational Construtor: - denominator 0\");\r\n\r\n    if (numerator == 0)\r\n      denominator = 1;\r\n    \r\n    //Ensure non-negative denominator; if a rational is\r\n    // negative, its numerator is negative\r\n    if (denominator < 0) {\r\n      denominator = -denominator;\r\n      numerator   = -numerator;\r\n    }\r\n    \r\n    //call gcd (greatest commmon divisor)\r\n    //  a private static method defined in this class\r\n    int common = gcd(numerator,denominator);  //or ...Rational.gcd(...)\r\n    \r\n    //name conflict\r\n    this.numerator   = numerator  /common;\r\n    this.denominator = denominator/common;\r\n  }</b></pre>\r\n  This constructor ultimately stores very special values into its two\r\n    instance variables, carefully checking/altering its parameters before\r\n    doing so.\r\n  First, it cannot construct a rational value with a denominator or zero,\r\n    is if the parameter has this values, it throws an exception.\r\n  For all other numerators and denominators, it stores values according\r\n    to the following rules.\r\n  <ul>\r\n    <li>Zero is always stored as 0/1\r\n    <li>The denominator is always stored as a positive value\r\n    <li>The numerator and denominator are reduced to have no common factors\r\n  </ul>\r\n  So, if we declare <b>Rational x = new Rational(2,-4);</b> then <b>x</b>\r\n    refers to an object that stores -1 for the numerator and 2 for the\r\n    denominator (try some other examples).\r\n  The parameters are examined and changed as needed in all but the last two\r\n    statements; at the end, <b>this.</b> is used to resolve the name conflicts.\r\n  Note the call to the method <b>gcd</b>, which is a <b>static</b> method\r\n    defined in this class.\r\n  Any non-<b>static</b> method can call a <b>static</b> method.\r\n  <p>\r\n  The following more special constructors create new objects by using\r\n    <b>this</b> (in the sense of using another constructor in this class\r\n    to initialize the instance variables)\r\n<pre><b>  public Rational (int numerator)\r\n  {this(numerator, 1);}\r\n\r\n  public Rational ()\r\n  {this(0, 1);}</b></pre>\r\n  <p>\r\n  In the first of these constructors, we specify a only a numerator parameter\r\n   and by using <b>this</b> construct a rational with that value over <b>1</b>;\r\n   in the case of a parameterless constuctor, we construct a rational with the\r\n   value <b>0</b> over <b>1</b>; we could also have written <b>this(0);</b>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Blank Final</b></td>\r\n<td width =\"80%\">\r\n  Recall that we can declare \r\n    <a href=\"../morejava/lecture.html#Final\">blank final</a> local variables.\r\n  We can also declare blank final instance variables, but we must follow and\r\n    additional constraint.\r\n  Java allows us to declare an intance variable <b>final</b> and not initialize\r\n    it in its declaration (the definition of blank final)\r\n  But, we must initialize this variable in EVERY constructor that we write,\r\n    otherwise the Java compiler will detect and report an error.\r\n  Of course, the Java compiler will ensure that we never try to assign a\r\n    second value to any <b>final</b> variable, including <b>final</b> instance\r\n    variables.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Methods -->\r\n\r\n<a name=\"Methods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Methods</b></td>\r\n<td width =\"80%\">\r\n  Method bodies follow the same rules as constructor bodies, in terms of their\r\n    use of parameter variables, local variables, and instance variables\r\n    (and in terms of <b>this</b>, variable name conflicts, etc).\r\n  In fact, when we illustrate the call frame for a non-<b>static</b> method,\r\n    it will show an <b>implicit parameter</b> named <b>this</b> and we will see\r\n     how this parameter gets initialized by an <b>implicit argument</b> when\r\n     such a method is called.\r\n  <p>\r\n  Recall that methods are divided into two categories\r\n  <ul>\r\n    <li>Mutator/command methods can access and store into instance\r\n          variables declared in the class; they change the state of the\r\n          object they are called on.\r\n    <p>\r\n    <li>Accessor/query methods can access instance variables declared in the\r\n          class, but not store into them; they do not change the state of the\r\n          object they are called on.\r\n  </ul>\r\n  We cannot tell just by looking at a method header whether it defines an \r\n     accessor or a mutator (we must look at the method body or Javadoc).\r\n  Yet, this is a fundamentally important piece of information about any method.\r\n  <p>\r\n  Often, one can tell which it is by the name of the method: accessor method\r\n     names often begin with <b>get</b>.\r\n  Also, <b>void</b> methods are almost always mutators: if they don't return a\r\n    result, the only interesting thing they can do is change the state\r\n    of the object they were called on.\r\n  Some methods, like <b>nextToken</b> in the <b>StringTokenizer</b> clas act\r\n    as both a mutator/command and accessor/query: changing an object's state\r\n    and returning some value.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>SimpleDiceEnsemble</b></td>\r\n<td width =\"80%\">\r\n  The <b>SimpleDiceEnsemble</b> class defines the <b>roll</b> method to be\r\n    both a mutator/command and accessor/query (it is the only mutator in the\r\n    class).\r\n  It is defined as follows.\r\n<b><pre>  public SimpleDiceEnsemble roll () {\r\n    this.rollCount++;\r\n    int firstThrow = this.randomDie();\r\n    this.pipSum    = firstThrow;\r\n    this.allSame   = true;\r\n    for (int i=2; i<=this.numberOfDice; i++) {\r\n      int nextThrow =  this.randomDie();\r\n      this.pipSum += nextThrow;\r\n      this.allSame = this.allSame && (nextThrow == firstThrow);\r\n    }\r\n    return this;\r\n  }</pre></b>\r\n  Here, for clarity in the discussion to come, I have prefaced each instance\r\n    variable by <b>this.</b> (even though there are no name conflicts).\r\n  The <b>roll</b> method has no parameters; it declares two local variables\r\n    (<b>firstThrow</b> and <b>nextThrow</b>) that it uses to change the\r\n    <b>rollCount</b>, <b>pipSum</b>, and <b>allSame</b> instance variables\r\n  <p>\r\n  Methods often have few or no parameters, because they primarily operate on\r\n    the instance variables of an object.\r\n  The pips showing for each die are computed by the <b>randomDie</b> method,\r\n    which We will examine later.\r\n  <p>\r\n  Let us see how to hand simulate a call to this method by using a call frame.\r\n  Pay close attention to how <b>this</b>, the implicit parameter, is \r\n    initialized by the implicit argument.\r\n  Assume that we have declared\r\n  <b><pre>  SimpleDiceEnsemble dice = new SimpleDiceEnsemble(2,6);</pre></b>\r\n  and now we execute the statement\r\n  <b><pre>  dice.roll();</pre></b>\r\n  We illustrate the call of this method by the call frame below (assume that\r\n    we roll a <b>3</b> on the first die and a <b>5</b> on the second).\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thiscallframe.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  The implicit parameter <b>this</b> appears in every non-<b>static</b> call\r\n    frame; <b>roll</b> declares no explicit parameters.\r\n  <b>this is always initialized to refer to the object on which the\r\n    method was called.</b>\r\n  In this case, the call was <b>dice.roll()</b> so <b>dice</b> is the\r\n    implcit argument and <b>this</b> is initialized to refer to the same\r\n    object as <b>dice</b> (the equivalent of <b>this = dice</b>, which looks\r\n    a lot like an argument initializing a parameter, even though both are\r\n    implicit).\r\n  <p>\r\n  This method then examines and changes the instance variables\r\n    in this object, as well as the local loop index variable <b>i</b>. \r\n  Hand simulate this code, again assuming <b>randomDie</b>\r\n    returns <b>3</b> when it is called the first time and <b>5</b> the second.\r\n  <p>\r\n  Note that by writing <b>this.rollCount</b> we are explicitly showing which\r\n    object is being referred to when the <b>rollCount</b> index variable is\r\n    accessed.\r\n  As stated above, even if we wrote just <b>rollCount</b>, because there are\r\n    no name conflicts, the meaning of using this variable is exactly the same\r\n    as <b>this.rollCount</b>.\r\n  <p>\r\n  Notice too the call to <b>this.randomDie()</b>; it means to call the\r\n    <b>randomDie</b> method on the object that <b>this</b> refers to,\r\n    which is the same object on which <b>roll</b> is called.\r\n  Generally, non-<b>static</b> methods inside a class can call other\r\n    non-<b>static</b> methods in that same class, to help them accomplish\r\n    their task on an object.\r\n  As in the case of instance variables, writing <b>randomDie()</b> has\r\n    exactly the same meaning here: calling another method on the same object\r\n    that <b>roll</b> was called on.\r\n  The <b>randomDie</b> method must be able to access the <b>sidesPerDie</b>\r\n    instance variable to compute a random roll of a die with that many sides.\r\n  In the actual code for <b>SimpleDiceEnsemble</b>, <b>this</b> is used only\r\n    where necessary.\r\n  <p>\r\n  Finally, the <b>return</b> statement returns the reference stored in\r\n    <b>this</b>: the code above does nothing with the returned result, but\r\n    if we had instead written\r\n  <b><pre>  System.out.Println(dice.roll().getPipSum());</pre></b>\r\n    Java would have called the <b>getPipSum</b> method on the returned\r\n    reference, printing a value of <b>8</b>.\r\n  <p>\r\n  The <b>SimpleDiceEnsemble</b> class defines many accessor methods, two of\r\n   which are shown below.\r\n  <pre><b>  public int getRollCount ()\r\n  {return rollCount;}\r\n  \r\n\r\n  public int getPipSum () throws IllegalStateException {\r\n    if (rollCount == 0)\r\n      throw new IllegalStateException(\"getPipSum - dice not rolled\");\r\n\r\n    return pipSum;\r\n  }</b></pre>\r\n  Accessors are often simpler than mutators.\r\n  The forms of many of these methods are actually quite common: just\r\n    returning the value stored in one of the <b>private</b> instance variables.\r\n  Note that by making the <b>rollCount</b> and <b>pipSum</b> instance variables\r\n    <b>private</b>, no code external to the class can directly examine or\r\n     change these variables, possibly trashing them; yet such code can always\r\n     determine the current values stored in these instance variables\r\n     indirectly, by calling their accessor/query methods.\r\n  So, accessor/query methods allow any code to determine the value stored in a\r\n    <b>private</b> instance variable without giving that code direct access to\r\n    change that instance variable.\r\n  <p>\r\n  Note that the second method first checks that the <b>pipSum</b> instance\r\n    variable actually stores a computed value before returning it; if the dice\r\n    have not yet been rolled, it throws the <b>IllegalStateException</b>: the\r\n    object is not in a good state yet to call this method.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Rational</b></td>\r\n<td width =\"80%\">\r\n  The <b>Rational</b> class is immutable.\r\n  All its methods are accessors, although many construct and return values\r\n    of primitive types or  references to new <b>Rational</b> objects (the\r\n    result of computing on the state(s) of old one(s), just as many\r\n    <b>String</b> and <b>BigInteger</b> methods do).\r\n  In the <b>Rational</b> class, I have adopted the style of always using\r\n    <b>this.</b> when accessing instance variables.\r\n  Two simple accessors that DO NOT construct objects are\r\n  <pre><b>  public int getNumerator()\r\n  {return this.numerator;}\r\n\r\n\r\n  public boolean equals (Rational other)\r\n  {return this.numerator   == other.numerator && \r\n          this.denominator == other.denominator;}</b></pre>\r\n  The first method just returns the value stored in the\r\n     <b>private numerator</b> instance variable (but, we could write just\r\n     <b>return numerator;</b>).\r\n  <p>\r\n  The second method returns whether or not (a) the object the method is called\r\n    on, and (b) the object the method is passed as a parameter, are equal.\r\n  Given the canonical way <b>Rational</b> stores these objects (zero as\r\n     <b>0/1</b>; denominators always positive; no common factors), they are\r\n     equal if and only if both pairs of instance variables are equal.\r\n  Note that if we did not store these objects canonically, then this method\r\n    would not work: e.g., comparing the rational 1/2 vs 2/4; the rational 0/1\r\n     vs 0/12; the rational -1/2 vs 1/-2.\r\n  Here, using <b>this.</b> adds a certain symmetry to our code (but, we could\r\n    write just  <b>numerator == other.numerator</b> and\r\n     <b>denominator = other.denominator</b>).\r\n  <p>\r\n  Finally, note that there is NOTHING SPECIAL about the parameter name\r\n   <b>other</b> (I've known students to get superstitious about this\r\n   parameter name): so long as the parameter name appears identically in the\r\n   code, we can use any name we want.\r\n  <p>\r\n  We illustrate this method call by the call frame below.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/equals.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Notice that the implicit parameter, <b>this</b>, refers to the object that\r\n    <b>a</b> refers to: the implicit argument; the explicit parameter,\r\n    <b>other</b>, refers to the object that the explicit argument <b>b</b>\r\n    refers to. \r\n  Again, there is nothing special about the parameter named <b>other</b>; we\r\n    can name this parameter anything we want.\r\n  If we called <b>b.equals(a)</b> the references stored in the implicit and\r\n    explicit parameters would be swapped.\r\n  This method call returns a result of <b>false</b>, because although the\r\n    numerators are the same, the denominators are different.\r\n  <p>\r\n  Two more complicated accessors that DO construct objects are\r\n<pre><b>  public Rational abs()\r\n  {return new Rational(Math.abs(this.numerator),this.denominator);}\r\n\r\n\r\n  public Rational add (Rational other) { \r\n    int a = this.numerator;          //  a     c     ad + cb\r\n    int b = this.denominator;        // --- + --- = ---------\r\n    int c = other.numerator;         //  b     d        bd\r\n    int d = other.denominator;       //\r\n    \r\n    return new Rational(a*d + c*b, b*d);\r\n  }</b></pre>\r\n  The <b>abs</b> method constructs and returns a new <b>Rational</b> object,\r\n    whose state is the absolute value of the state of the object that this\r\n    method was called on; we know the <b>denominator</b> is always positive,\r\n    so we can use its value directly.\r\n  The return type of <b>Rational</b> means that this method returns a\r\n    reference to an object that is an instance of the <b>Rational</b> class.\r\n  In the <b>abs</b> method, we return a newly constructed <b>Rational</b>\r\n    whose numerator is non-negative (all denominators are already positive).\r\n  <p>\r\n  The <b>add</b> method constructs and returns a new <b>Rational</b> object,\r\n    whose state is the sum the states of the object that this\r\n    method was called on and the object passed as the explicit argument.\r\n  If we wrote\r\n    <b><pre>  Rational x = new Rational(1,2), y = new Rational(1,3);\r\n  Rational z = x.add(y);</pre></b>\r\n  We would illustrate these variable and method call by the call frame below\r\n  (note that for space reasons, I have left out the four local variables\r\n   <b>a</b>, <b>b</b>, <b>c</b>, and <b>d</b>, which store the values\r\n   <b>1</b>, <b>2</b>, <b>1</b>, and <b>3</b> respectively).\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/add.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  In this <b>add</b> method, we return a newly constructed <b>Rational</b>\r\n    whose numerator and denomiator are computed according to the standard\r\n    algorithm for adding rational values.\r\n  Note that the code in the complicated constructor for this class will\r\n    automatically reduce the results to lowest terms.\r\n  If we call <b>x.add(y)</b> then <b>this</b> refers the state of the object\r\n    that <b>x</b> refers to: the object on which <b>add</b> is called; and\r\n    <b>other</b> refers to the state of the object that <b>y</b> refers to:\r\n    the object that is an argument to <b>add</b>\r\n  Of course, if we call <b>y.add(x)</b> then <b>this</b> and <b>other</b>\r\n    would refer to the opposite objects (but since addition is symmetric, it\r\n    would return the same result).\r\n  <p>\r\n  Because this method returns a reference to a <b>Rational</b> object, we can\r\n    cascade our method calls. If we wanted to compute the sum of the objects\r\n    all three variables refer to, we can write\r\n  <b>x.add(y).add(z)</b> which first creates an object containing the sum\r\n   of <b>x</b> and <b>y</b>, and then it adds this object to <b>z</b>,\r\n   producing an object storing the total sum.\r\n  We can also write <b>x.add(y.add(z))</b>, which produces the same result\r\n    by adding objects in a different order.\r\n  <p>\r\n  Each of these classes include a <b>toString</b> method that returns a\r\n    <b>String</b> catenating together all the state of the object (which is\r\n    used mostly for debugging purposes).\r\n  Such <b>toString</b> methods are often easy to write; examine them.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Private & Static Methods -->\r\n\r\n<a name=\"SpecialMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Special Methods</b></td>\r\n<td width =\"80%\">\r\n  There are two kinds of special methods that we examine here briefly: \r\n    <b>private</b> and <b>static</b>.\r\n  Both kinds occur in classes that we will write, but they do not occur\r\n    frequently.\r\n</td>\r\n</tbody>\r\n</table>\r\n<a name=\"PrivateMethods\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Private Methods</b></td>\r\n<td width =\"80%\">\r\n  First, sometimes a class will define <b>private</b> methods.\r\n  Such a method is callable only from other methods defined in that class,\r\n    not from any methods outside the class to use.\r\n  Typically, <b>private</b> methods are small helper methods; they are useful\r\n    for the implementor of the class, but not useful (or dangerous) for someone\r\n    outside the class; like many methods, they hide some details.\r\n  The <b>SimpleDiceEnsemble</b> defines the <b>randomDie()</b> method, which\r\n    uses a random numuber generator to simulate throwing one die.\r\n  The <b>roll</b> method has two calls to this one: one outside its loop and\r\n    one inside the loop (which may get executed multiple times).\r\n<pre><b>  private int randomDie ()\r\n  {return (int)Math.round(Math.random()*sidesPerDie + .5);}</pre></b>\r\n  Notice that this method uses the instance variable <b>sidesPerDie</b>.\r\n  The <b>static</b> method <b>random</b> defined in the <b>Math</b> class \r\n   always returns a <b>double</b> result in the semiopen range <b>[0,1)</b>; \r\n   the expression transforms this value into an <b>int</b> between <b>1</b> and\r\n   <b>sidesPerDie</b>, with each value equally likely to occur.\r\n</td>\r\n</tbody>\r\n</table>\r\n<a name=\"StaticMethods\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Static Methods</b></td>\r\n<td width =\"80%\">\r\n  Second, sometimes a class (one with a constructor) will define <b>static</b>\r\n    methods, either <b>public</b> or <b>private</b>.\r\n  The <b>Rational</b> class defines the <b>prompt</b> method as\r\n    <b>public static</b>.\r\n<pre><b>  public static Rational prompt(String s) {\r\n    System.out.println(s);\r\n    for (;;)\r\n      try{\r\n        int numerator   = Prompt.forInt(\"  Enter numerator  \");\r\n        int denominator = Prompt.forInt(\"  Enter denominator\");\r\n        return new Rational(numerator,denominator);\r\n      }catch (Exception e)\r\n        {System.out.println(\"Illegal value entered; try again\");}\r\n  }</pre></b>\r\n  Any class can call this method in its code as follows.\r\n    <pre><b>  Rational x = Rational.prompt(\"Enter x\");</b></pre>\r\n  Recall that to use a <b>static</b> method outside a class, we must\r\n    prefix its name by the name of its class NOT A REFRENCE TO AN OBJECT\r\n    OF THAT CLASS.\r\n  The console interaction would look like\r\n  <pre><b>  Enter x\r\n    Enter numerator  : 1\r\n    Enter denominator: 2</b></pre>\r\n  <p>\r\n  Why make this method <b>static</b>?\r\n  Because its sole purpose it to construct/return a reference to an object.\r\n  If we made this method non-<b>static</b>, we would have to write something\r\n    like\r\n  <pre><b>  //get an object (storing 0/1) to call prompt with\r\n  Rational x = new Rational();\r\n \r\n  //store new value in x, throwing away 0/1 that we just created.\r\n  x = x.prompt(\"Enter x\");</b></pre>\r\n  In this case, we first construct an object to call the non-<b>static</b>\r\n    method on, but we just throw away the original object, replacing it by a\r\n    reference to an object containing the user-input rational.\r\n  Thus, it is much simpler and easier to use this method if it is \r\n     <b>static</b>.\r\n  <p>\r\n  The <b>Rational</b> class also defines the <b>gcd</b> method as\r\n    <b>private static</b>.\r\n<b><pre>  private static int gcd (int x, int y) {\r\n    ...lots of complicated code\r\n  }</b></pre>\r\n  This method is called only in the first constructor, to reduce to lowest\r\n    terms the numerator and denominator (by dividing-out all common factors).\r\n  Because this method is defined in the <b>Rational</b> class, we can call it\r\n   as either <b>gcd(numerator,denomiator)</b> or as\r\n    <b>Rational.gcd(numerator,denomiator)</b>.\r\n  Note that because this method is <b>private</b>, it cannot be called\r\n    from anywhere but inside a constructor or method defined in this class.\r\n  <p>\r\n  Finally, notice that the <b>randomDie</b> method cannot be <b>static</b>.\r\n  That is because it must refer to the instance variable <b>sidesPerDie</b>;\r\n    <b>static</b> methods can refer only their parameter variables and local\r\n     variables (see <b>prompt</b> and <b>gcd</b>).\r\n  The fact that we can call <b>static</b> methods without objects means\r\n    that they have no guaranteed access any object's instance variables.\r\n  Of course, we could have rewritten it as a <b>static</b> method if we added\r\n    a parameter:\r\n<pre><b>  private static int randomDie (int max)\r\n  {return (int)Math.round(Math.random()*max + .5);}</pre></b>\r\n  and then called this method in <b>roll</b> as <b>randomDie(sidesPerDie)</b>,\r\n  but I thought the former way was simpler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Static Fields -->\r\n\r\n<a name=\"StaticFields\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Static Fields</b></td>\r\n<td width =\"80%\">\r\n  There are two main uses of <b>static</b> fields.\r\n  The first and foremost is a place to declare constants (using the\r\n    <b>final</b> access modifier) that other classes can use.\r\n  For example, the <b>DateUtility</b> class declares <b>final</b> variables\r\n    naming all the months.\r\n  The <b>Rational</b> class declares the constants <b>ZERO</b> and <b>ONE</b>\r\n   (both storing references to an object representing one of these values).\r\n  Recall that one can call mutator on <b>final</b> variables to change their\r\n    states, but one cannot store a new reference (to a different object) in\r\n    a <b>final</b> variable.\r\n  Because <b>Rational</b> is an immutable class (it contains no mutator\r\n    methods) the instance values stored in these objects always will remain\r\n    the same.\r\n  <p>\r\n  The second use of <b>static</b> fields is more subtle: we use them to store\r\n    information shared by all objects in a class.\r\n  Normally, each objects stores its own state in instance variables; but\r\n   <b>static</b> variables are stored in a special spot that all objects\r\n   can access.\r\n  <p>\r\n  Suppose that we wanted to be able to know how many times\r\n    objects were constructed from a class (i.e., how many times <b>new</b> \r\n    operated on a certain class).\r\n  We can declare <b>private static int allocated = 0;</b> in the class, and\r\n    then include  the statement <b>allocated++;</b> in each constructor.\r\n  Now, whenever an object is constructed, the <b>static</b> variable shared\r\n    by all the objects in the class is incremented.\r\n  Finally, we could define \r\n    <pre><b>  public static int getAllocated ()\r\n  {return allocated;}</b></pre>\r\n    to return its value.\r\n  <p>\r\n  So, what would happen if we did not declare this field to be <b>static</b>.\r\n  If this information were stored in an instance variable (the only other\r\n    choice), each object would store this value as part of its own state; each\r\n    time an object was constructed it would initialize this instance variable\r\n    to zero and then increment it in the constructor.\r\n  Thus, if we constructed <b>n</b> objects, we would have <b>n</b> instance\r\n    variables storing <b>1</b>, not one <b>static</b> field storing <b>n</b>.\r\n  <p>\r\n  The final strangeness about <b>static</b> fields is that their declarations\r\n    (and intializations) are done just once, the first time Java needs to\r\n    do something with a class.\r\n  Contrast this with instance variable declarations which are executed each\r\n    time that <b>new</b> constructs an object.\r\n  <p>\r\n  Most fields in class with constructors are instance variables.\r\n  The ones that aren't are mostly the constants described above.\r\n  If you see other <b>static</b> fields, study them careful to understand them.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Writing Javadoc -->\r\n\r\n<a name=\"Javadoc\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Writing Javadoc Comments</b></td>\r\n<td width =\"80%\">\r\n  Java is the first popular programming language to come with a special\r\n    program (of course, written in Java) for documenting its classes.\r\n  This is important, because most interesting programming involves locating a\r\n    collection of useful classes and determining what constructors\r\n    and methods they define, and how to use them (based on their syntax and\r\n    semantics).\r\n  Having all this information stored, indexed, and viewable via standard web\r\n    browsers (with links), has made a big difference in my programming\r\n    efficiency.\r\n  <p>\r\n  We have already studied how to read web pages produced by Javadoc (both for\r\n    the standard Java library and classes that I have provided for this\r\n    course).\r\n  Now we will begin to learn how to write our own Javadoc comments, to document\r\n    classes that we write ourselves.\r\n  <p>\r\n  We can run Javadoc on Java source code (<b>.java</b> files).\r\n  Even if we have added none of the special comments desrcribed below,\r\n    Javadoc still produces a skeletal web page listing all the fields,\r\n    constructors, and methods in <b>Summary</b> and <b>Detail</b> tables.\r\n  Such web pages, though, won't have any commentary, and none of the \r\n   special <b>parameter</b>, <b>return</b>, and <b>throws</b> information.\r\n  <p>\r\n  In general, we can further document our classes with comments.\r\n  Javadoc ignores general comments, but reads and process comments written \r\n    in a special form: comments that start with <code><b>/**</b></code>.\r\n  These are called Javadoc comments.\r\n  Notice that a Javadoc comment is also a general comment (starting with\r\n    <b>/*</b>) so it is also treated as whitespace by the Java compiler.\r\n  <p>\r\n  Here is the Javadoc commment prefacing the <b>DiceEnsemble</b> class.\r\n  View it along with the Javadoc pages it generates in the\r\n    <a href=\"../../../common/classes/doc/index.html\" target=\"_blank\">\r\n    Javadoc of Course API</a>.\r\n  <pre><b>  /** \r\n   * Objects constructed from the &lt;code&gt;DiceEnsemble&lt;/code&gt;\r\n   *   class act as collections of dice.\r\n   * The number of dice in an ensemble (and the number of sides of\r\n   *   each die)  can be controlled by the programmer.\r\n   * The class models the basic operations need to roll the dice and\r\n   *   determine the number of pips showing -both for individual dice\r\n   *   and for the entire  ensemble.   \r\n   * \r\n   * @author Richard E. Pattis\r\n  */</b></pre>\r\n  Javadoc <b>copies</b> the contents of this comment into the web page that it\r\n    builds for this class; it appears near the top, right before the first\r\n    <b>Summary</b> table.\r\n  I write such comments in the <b>.java</b> file a special style, for ease of\r\n    editing; each line is a sentence, with sentences longer than one line\r\n    indented.\r\n  The web browser renders this text as a nice paragraph.\r\n  <p>\r\n  Note that I said that Javadoc <b>copies</b> the contents of the message...\r\n    and the web browser renders the text...\r\n  This means that the comment can us embedded HTML markup tags; these tags are\r\n    copied into the web page and rendered by the browser, just like normal\r\n    HTML tags in text.\r\n  Notice the use of <b>&lt;code&gt;DiceEnsemble&lt;/code&gt;</b> to render the\r\n    name of this class in the <b>code</b> font; in a multi-paragraph\r\n    description, we use <b>&lt;p&gt;</b> to separate the paragraphs.\r\n  Generally, use what HTML markup tags you are familiar with to format your\r\n    documentation.\r\n  <p>\r\n  Finally, note the special Javadoc markup tag <b>@author</b>; Javdoc makes\r\n    special use of these tag, often creating special HTML for them.\r\n  <p>\r\n  A typical constructor or method is documented by a Javadoc comment of the\r\n    following form; the comment appear in the <b.java</b> file right before\r\n    the member it documents.\r\n  <pre><b>  /**\r\n  * One sentence. More documentation\r\n  * @param  tag(s)\r\n  * @return tag(s)\r\n  * @throws tag(s)\r\n  */</b></pre>\r\n  This section always begins with at least one sentence ended by a period;\r\n    other material (e.g., <b>More documentation</b>) can follow.\r\n  All information up to and including the first period appears in the\r\n    <b>Summary</b> section; it also appears in the <b>Detail</b> sections,\r\n    followed by any other material (e.g., <b>More documentation</b>).\r\n  <p>\r\n  Again, each appearance of <b>@something</b> is a special Javadoc markup tag\r\n    that Javadoc recognizes and processes by inserting special HTML markup\r\n    commands to highlight the information coming after the tag.\r\n  We should include only those tags that are relevant: a constructor/method \r\n   with no parameters has no  <b>@param</b> tags; otherwise we use one tag per\r\n    parameter.\r\n  A constructor or <b>void</b> method has no <b>return</b> tag; otherwise we\r\n    use only one tag.\r\n  A constructor/method throwing no exceptions has no <b>@throws</b> tags;\r\n    otherwise we use one tag per exception. \r\n  <p> \r\n  The information documented by all these tags appears in the <b>Detail</b>\r\n    sections.\r\n  The words <b>Parameters</b>, <b>Returns</b>, and <b>Throws</b> are\r\n    highlighted.\r\n  The first word after <b>@param</b> should be the name of the parameter; it\r\n    automatically is rendered in the <b>code</b> font, followed by a dash, and\r\n    then the rest the information we write.\r\n  The first word after <b>@throws</b> should be the name of the exception; it\r\n    appears as a link to the class of that name, followed by a dash, and then\r\n    the rest the information that we write.\r\n  Again, we can embed any HTML markup tags directly in any comments processed\r\n    by Javadoc (it will just copy them to the web page, where the browswer will\r\n    interpret them).\r\n  <p>\r\n  Here are the Javadoc comment that precede the first constructor and the\r\n    <b>roll</b> and <b>getPips</b> methods in the <b>DiceEnsemble</b> class.\r\n  Notice that the <b>One sentence.</b> comment ends in a period, while the tags\r\n    don't; words enclosed inside the <b>code</b> HTML commands are displayed\r\n    in a special font.\r\n  I group all the parameter tags together, separated by blank lines.\r\n<pre><b>  /** \r\n  * Constructs a &lt;code&gt;DiceEnsemble&lt;/code&gt; object, specifying\r\n  *   the number of dice and the number of sides per die.\r\n  *\r\n  * @param  numberOfDice specifies the number of dice in the ensemble\r\n  * @param  sidesPerDie specifies the number of sides on each and every\r\n  *           die in the ensemble (the pips showing are 1, 2, 3, ...\r\n  *           &lt;code&gt;sidesPerDie&lt;/code&gt;)\r\n  *\r\n  * @throws IllegalArgumentException if either parameter is less than 1\r\n */\r\n  public DiceEnsemble (int numberOfDice, int sidesPerDie)\r\n    throws IllegalArgumentException\r\n  {...}\r\n\r\n\r\n\r\n  /** \r\n   * Returns this &lt;code&gt;DiceEnsemble&lt;/cod&gt; after rolling every\r\n   *   die in it.\r\n   * By using the return type <code>DiceEnsemble</code> instead of\r\n   *   &lt;code&gt;void&lt;/code&gt;, we can \"cascade\" method calls, writing\r\n   *   expressions such as: &lt;code&gt;d.roll().getPipSum()&lt;/code&gt;\r\n   *   instead of writing roll as its own statement.\r\n   *\r\n   * @return the rolled dice ensemble\r\n  */\r\n  public DiceEnsemble roll ()\r\n  {..}\r\n\r\n\r\n\r\n  /** \r\n   * Returns the the number of pips showing on die &lt;code&gt;dieIndex&lt;/code&gt;\r\n   *   (changed each time the ensemble is rolled).\r\n   *\r\n   * @param  dieIndex specifies the index of the die whose pips are\r\n   *           returned\r\n   *\r\n   * @throws IllegalStateException if this ensemble has not been rolled\r\n   * @throws IllegalArguementException if &lt;code&gt;dieIndex&lt;/code&gt;\r\n   *           is outside the range [1,getNumberOfDice()].\r\n   *\r\n   * @return the the number of pips showing on die &lt;code&gt;dieIndex&lt;/code&gt;.\r\n  */\r\n  public int getPips (int dieIndex)\r\n     throws IllegalStateException, IllegalArgumentException\r\n  {...}</b></pre>\r\n  <p>\r\n  The documentation for \r\n    <a href=\"http://java.sun.com/j2se/1.4/docs/tooldocs/win32/javadoc.html\"\r\n      target=\"_blank\">Javadoc</a>\r\n    appears on the Sun Microsystems web site. \r\n  If you want to know more about Javadoc than this course covers, start\r\n     reading here.\r\n  <p>\r\n  I will partially describe two other very interesting Javadoc tags:\r\n    <b>@see</b> and <b>@link</b>.\r\n  Both tags are use to create links to other fields, constructors, or methods\r\n    either on this page or any other page documenting another class.\r\n  The <b>@see</b> tag collects the references and puts them in a special\r\n    section; the <b>@link</b> tag embeds links in any documentation, right\r\n    where it appears.\r\n  A typical use is\r\n  <b><pre>  ...This method should never be called until first calling\r\n  <b>the {@link DiceEnsemble#roll roll}</b> method to ensure the dice\r\n  actually have some pips showing.</pre></b>\r\n  The first piece of information is the way to refer to some field,\r\n    constructor, or method; the second piece of information is what word the\r\n    link should  appear as.\r\n  The Javadoc web page has much more information about this interesting tag,\r\n    including the following general forms.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/linksyntax.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  <p>\r\n  We can run the Javadoc program (to produce Javadoc web pages) from the\r\n    cammand line; it has many interesting options.\r\n  The standard way I run it is\r\n<b><pre>  javadoc -d publicdocs -public *.java -link http://java.sun.com/j2se/1.3/docs/ap</pre></b>\r\n  If you don't want to type all this information, you can download the\r\n     <a href=\"../../../common/classes/generatedocs.bat\">\r\n       Generate Javadoc</a> batch file, which contains this command and another\r\n    (one to generate Javadoc from the perspective of an implememtor, including\r\n    all the <b>private</b> stuff).\r\n  This batch file is also available under <b>Miscellaneous</b> in the  \r\n     <a href=\"../../../common/online.html\">Online Resources</a> web page.\r\n  <p>\r\n  Put this file in a folder that contains the <b>.java</b> files that you want\r\n    to run through Javadoc.\r\n  If you are runing under Windows, double-click the file named\r\n    <b>generatedocs.bat</b>, and you will see a console window pop up; this\r\n    window shows the Javadoc utility running (otherwise, cut/paste/execute\r\n    the lines from this file).\r\n  It creates a folder named <b>publicdocs</b> containing all the Javadoc\r\n    comments related to public class members (the ones we have been reading as\r\n    class users); and a folder named <b>privatedocs</b> containing all the\r\n     Javadoc comments related to public and private class members (the ones\r\n     we would read as class implementors).\r\n  Each folder contains a file named <b>index.html</b>, which acts as the root\r\n    for all the Javadoc web pages in that folder; click on it to start viewing\r\n    the Javadoc\r\n  <p>\r\n  It can take a few seconds or so for each class that Javadoc examines\r\n    and extracts into a web page.\r\n  For debugging purposes (if your <b>@link</b> tags contain errors), twice\r\n    you will be asked to press any key to continue (so if there are errors,\r\n    you can stop and examine them, instead of having them scroll by).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Eclipse -->\r\n\r\n<a name=\"Eclipse2\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Instance Variables in the Eclipse Debugger</b></td>\r\n<td width =\"80%\">\r\n  The Eclipse debugger includes a few useful features to illustrate classes\r\n    from which we construct objects.\r\n  All the material that we discussed previously in this lecture note (about\r\n    the editor and  debugger) concerning <b>static</b> methods works for\r\n    non-<b>static</b>  methods as well.\r\n  We know that whenever a method is called, the debugger displays all its\r\n    its parameter variables and local variables in the <b>Variables</b> tab.\r\n  But in addition, whenever a non-<b>static</b> method is called on an object,\r\n    this pane also displays a special entry named <b>this</b> (surprised? it\r\n    was the same in the call frames) that refers to that object's instance\r\n    variables (so, our call frames do accurately reflect the main aspect of\r\n    <b>this</b>).\r\n  <p>\r\n  Suppose that we stop on the first line inside the <b>roll</b> method.\r\n  The full name of the method (<b>packageName.ClassName.methodName</b>)\r\n     appears  underneath<b> Thread[main]</b>); recall that <b>temp</b>\r\n     is the package name for this class.\r\n  Note that in the <b>Variables</b> tab </b>this</b> appears on a single line\r\n   that is preceded by a box showing a <b>+</b> and followed by an id\r\n   number (ignore the id number).\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thisvars1.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  The box is is called a <b>disclosure box</b>; it is currently in its\r\n    <b>non-disclosing</b> (or elided) state.\r\n  By clicking this box, it toggles to it <b>disclosing</b> state: its contents\r\n    will be replaced by a <b>-</b> and all the instance variables in the\r\n    object <b>this</b> refers to will appear, indented, under <b>this</b>.\r\n  (clicking this box again will return it to its non-disclosing state).\r\n  This is the first time these two, six-sided dice are being rolled, so\r\n    the instance variables <b>rollCount</b>, <b>pipSum</b>, and <b>allSame</b>\r\n    all display their initial values.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thisvars2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  By watching these instance variables change while single stepping through\r\n    the statements in this method, we can see how this mutator/command changes\r\n    the state of the object.\r\n  When the last line of the method is reached, the instance variables now\r\n   display their new values.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <image src=\"images/thisvars3.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Understanding how the debugger treats objects is crucial to being able to\r\n    debug classes quickly.\r\n  Practice using these kinds of stepping and object observations using the\r\n    drivers for the <b>SimpleDiceEnsemble</b> and <b>Rational</b> classes.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Class Roundup -->\r\n\r\n<a name=\"ClassRoundup\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Summary and Class Invariants</b></td>\r\n<td width =\"80%\">\r\n  This has been a long lecture, discussing many interesting language features,\r\n    and tons of technical terms.\r\n  It looked as classes from a new perspective -that of a class implementor-\r\n    leveraging off all the information that we have learned previously -as\r\n    class users.\r\n  Let me try to review the most important ideas here briefly.\r\n  <p>\r\n  We began by studying the form and meaning of <b>static</b> method\r\n    definitions, along with the <b>return</b> and <b>throw</b> statements.\r\n  We learned how to hand simulate these methods in call frames and how to\r\n    use them in programs -in two ways: directly in an application\r\n    (along with a <b>main</b> method) and as definitions in a library class.\r\n  We examined how the Metrowerks IDE makes using methods easier (in the editor\r\n    and the debugger).\r\n  <p>\r\n  Then we discussed how to define instance variables in a class, along with\r\n    the related topics of how to write constructors that help initialize them\r\n    and methods to manipulate them.\r\n  We learned that a <b>private</b> member can be accessed from any other\r\n    members in the class it is defined in (but not from members outside this\r\n    class).\r\n  We found two interesting uses for the keyword <b>this</b>: to specify\r\n   instance variables (in variable name conflicts) and to help in constructors.\r\n  Finally, we discussed writing Javadoc to document classes and their members.\r\n  <p>\r\n  Finally, I would like to look one more time at constructors and methods\r\n    as middlemen with respect to <b>private</b> instance variables.\r\n  An <b>invariant</b> is a statement about something that remains true while\r\n    that something is manipulated; if such a statement is true, we say it is\r\n    satisfied.\r\n  A <b>class invariant</b> is a set of statements about the instance variables\r\n    of objects constructed from the class: these statements must be true when\r\n    an object is first constucted, and they must remain true after each method\r\n    is called.\r\n  <p>\r\n  Of course, accessor/queries do not change state, so they can be ignored when\r\n    discussing class invariants.\r\n  In fact, many interesting class are immutable: e.g., <b>String</b>,\r\n    <b>BigInteger</b>, and <b>Rational</b>; so their class invariants have to\r\n    be true only after object construction.\r\n  The <b>Rational</b> class, for example, has three invariants.\r\n  <ul>\r\n    <li>Zero is stored with a numerator of zero and a denominator of one.\r\n    <li>The denominator is always stored as a positive value.\r\n    <li>The numerator and denominator are reduced to have no common factors.\r\n  </ul>\r\n  The constructor carefully ensures that these are all true.\r\n  Various methods (especially <b>equals</b>) assume that invariants are true\r\n    in order to operate correctly (and sometimes efficiently).\r\n  <p>\r\n  The <b>DiceEnsemble</b> class, for another example, requires positive values\r\n    for the number of dice and sides per die.\r\n  Its constructor also ensures this invariant and the only accessor,\r\n    <b>roll</b> does not change these instance variables.\r\n  <p>\r\n  Using <b>private</b> instance variables helps an implementor ensure class\r\n    invariants.\r\n  By declaring instance variables to be <b>private</b>, we know that the\r\n    only place they can change is in the code for methods defined in that\r\n    class. \r\n  Users of the class cannot change these variables directly and possibly\r\n    make an invariant unsatisfied.\r\n  <p>\r\n  Imagine what would happen if we declared <b>numerator</b> or\r\n    <b>denominator</b> to be <b>public</b>.\r\n  An incompetent or malicious programmer could store anything in such\r\n    instance variables, violating any or all of the invariants stated above.\r\n  Thus, a class implementor prefers <b>private</b> instance variables\r\n    (and sometimes <b>public final</b> ones will work too) so that users of the\r\n    class cannot do bad things to its instances.\r\n  This access modfier ensures that the constructors and methods of the class\r\n    have ultimate control over what state changes are made to objects.\r\n  <p>\r\n  Now we come to how this aids us when debugging.\r\n  Imagine a scenerio where the user of a class is getting bad results in \r\n    an application program; who is to blame, the user or implementor of the\r\n    class.\r\n  If an object's state ever doesn't satisfy its class invariants, the\r\n    implementor has definitely made a mistake.\r\n  If an object's state always satisfies its class invariants, but the\r\n    postcondition of a method is not satisifed, then the implementor has also\r\n    made a mistake.\r\n  All other mistakes are the result of the user of a class.\r\n  <p>\r\n  A well designed class is a cohesive collection of related instance\r\n    variables, the constructors that initialize them, and the methods that\r\n    manipulate them.\r\n  Each method performs some small, well-defined service.\r\n  Taken together, these methods allow programmers to do everything needed to\r\n    objects constructed from the class.\r\n  It is the composition of these coordinated services, under control of the\r\n    programmer, that make well-designed classes easy to reuse in many related\r\n    applications.\r\n  So, in a well-designed class, it is common to write many small methods (the\r\n    classes that we have seen are typical); this is true even in more \r\n    complicated classes, which may have many more constructors, methods, and\r\n     instance variables, but whose method definitions are still quite small.\r\n  <p>\r\n  It is not a goal of ICS-21 (nor 22 for that matter; ICS-23 gets closer with\r\n     collection classes) to teach you how to design a (re)usable class.\r\n  It is a goal to teach you how to read and use classes; it is also a goal for\r\n    you to be able to implement (write the <b>.java</b> file) for a\r\n    well-designed (by someone else) class.\r\n  <p>\r\n  Finally, if you want to read the <b>.java</b> source code files for any of\r\n    Java's standard library classes, you can find them in the <b>src.jar</b>\r\n    file in the <b>jdk1...</b> folder (or whatever folder representes the\r\n    top of your Java file system: mine is\r\n     <b>C:\\Program Files\\Java\\jdk1....</b>.\r\n  Open this file with <b>zip</b> and you can select and examine any of the\r\n    nearly 2,000 files it contains.\r\n  These files comprise industrial-strength code written by excellent\r\n    programmers: don't expect to breeze through the code, but it is\r\n    remarkably readable (say, compared to C/C++ libraries).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA,\r\n    or any other student.\r\n\r\n  <ol> \r\n     <li>Write a statement that calls any of the \"result-returning\" methods (maybe just\r\n           display the returned result on the console) and hand simulate its execution with\r\n           a call frame.\r\n     <p>\r\n     \r\n\r\n     <li>Java allows methods to have no parameters; such methods are defined and called by\r\n           specifying their name followed and an empty argument list: e.g., <b>f()</b>.\r\n         Use your knowledge of the semantics of the <b>return</b> statement to explain what\r\n           happens for the following method and its calls.\r\n         Don't get confused by what you think it does (or want it to do): follow the rules.\r\n         <b><pre>  int f()\r\n  {\r\n    return 1;\r\n    return 2;\r\n  }</pre></b>\r\n         What is displayed by <b>System.out.print(\"1st f = \" + f() + \" 2nd f = \" + f());</b>\r\n     <p>\r\n\r\n  <li>Write a  method named <b>characteristic</b>, which returns 1 if its parameter is <b>true</b>\r\n        and 0 if its parameter is <b>false</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>abs</b>, which returns the absolute value of its\r\n        <b>int</b> parameter (it always returns the non-negative magnitude of its parameter;\r\n        don't call the <b>Math.abs</b> method).\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>signum</b>, which returns <b>-1</b> if its <b>double</b> parameter\r\n        is negative, <b>0</b> if its parameter is zero, and <b>+1</b> if its parameter is positive.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>constrain</b>.\r\n      Calling <b>constrain(1,5,10)</b> returns <b>5</b> because this middle value is between the first\r\n         and third values.\r\n      Calling <b>constrain(1,-5,10)</b> returns <b>1</b> because this middle value is smaller than the first\r\n         value, so the method returns the first value.\r\n      Calling <b>constrain(1,15,10)</b> returns <b>10</b> because this middle value is larger than the third\r\n         value, so the method returns the third value.\r\n      Thus, this method returns the middle value, but it is constrained to lie between the first and\r\n        third values inclusize.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>forChar</b>.\r\n      We could call the method as <b>forChar(\"Enter an Upper-Case Letter\", 'A', 'Z')</b> which\r\n        always returns a <b>char</b> whose ASCII value is between <b>'A'</b> and <b>'Z'</b>; or\r\n      we could call the method as <b>forChar(\"Enter a Digit\", '0', '9')</b> which\r\n        always returns a <b>char</b> whose ASCII value is between <b>'0'</b> and <b>'9'</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Why can't we write a  simple method named <b>makeChange</b>, which is supplied the amount of change\r\n        to vend, and returns the number of quarters, dimes, nickels, and pennies needed to vend the\r\n        required change.\r\n      How do you think we can write a method to solve such a problem?\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>majority</b>, which returns the most frequently occuring value\r\n        of its three <b>boolean</b> parameters: no matter the values, at two of three (and possibly\r\n        three of three) will have the same value.\r\n      For example, the call <b>majority(true,false,false)</b> returns <b>false</b>, while\r\n        the call <b>majority(true,true,true)</b> returns <b>true</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>median</b>, which returns the middle value of its three arguments.\r\n      For example, the call <b>median(3,2,5)</b> returns <b>3</b> because it is between <b>2</b>\r\n        and <b>5</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Assume that we declare <b>char roman;</b> and store in it a character that is a\r\n        roman numeral.\r\n      Write a method that returns the <b>int</b> equivalent of the Roman numeral:\r\n        <b>I</b> is <b>1</b>, <b>V</b> is <b>5</b>, \r\n        <b>X</b> is <b>10</b>, <b>L</b> is <b>50</b>, <b>C</b> is <b>100</b>,\r\n        <b>D</b> is <b>500</b>, <b>M</b> is <b>1000</b>; if it stores any other character,\r\n        return <b>-1</b>.\r\n  <p> \r\n \r\n  <li>Write a  method named <b>isPrime</b>, which returns whether or not its parameter is a\r\n        prime number.\r\n      A prime number has only 1 and itself as divisors: neither 0 nor 1 are considered prime; 2 is\r\n       the smallest prime number, then 3, 5, 7, 11, etc.\r\n      Hint: Use a <b>for</b> loop to check for possible divisors, along with the <b>%</b> operator.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>harmonic</b>, which takes one <b>int</b> parameter and returns a\r\n        <b>double</b> value representing the harmonic series of that order.\r\n      <b>harmonic(n)</b> is defined as <b>1 + 1/2 + 1/3 + ... 1/n</b>.\r\n      So <b>harmonic(2)</b> returns <b>1.5</b>; and <b>harmonic(4)</b> returns <b>2.083333</b>.\r\n  <p>\r\n     \r\n\r\n  <li>Write a  method named <b>fw</b>, which returns the number of characters needed to print its\r\n        integer parameter.\r\n      For example, <b>fw(5)</b> returns <b>1</b>; <b>fw(-5)</b> returns <b>2</b>;\r\n        <b>fw(453)</b> returns <b>3</b>; and <b>fw(-243)</b> returns <b>4</b>.\r\n      Hint: the number of digits in a number is related to how many times you can divide it\r\n        by <b>10</b> and still have a non-zero value; treat negative numbers specially.\r\n  <p>\r\n     \r\n\r\n  <li>Write a method named <b>block</b> that has an <b>int</b> height and width parameter, and a\r\n      <b>char</b> parameter.\r\n      This method returns a <b>String</b> which when printed displays a rectangle of that the specified \r\n      height and width, consisting of the specified character.\r\n      Calling <b>System.out.println(block(5,20,'*'));</b> would print.\r\n      <b><pre>  ******************** \r\n  ******************** \r\n  ******************** \r\n  ******************** \r\n  ********************</pre></b>\r\n      Remember that catenating an escape sequence character (<b>'\\n'</b>) in a <b>String</b> causes\r\n        a carriage return when that character is printed.\r\n   <p>\r\n\r\n     <li>Suppose our program consists of the the methods <b>main</b>, <b>a</b>,\r\n           <b>b</b>, <b>c</b>, <b>d</b>, and <b>e</b>.\r\n         Also suppose <b>main</b> calls <b>a</b>, <b>b</b>, <b>d</b>, and <b>e</b>,\r\n           <b>a</b> calls <b>c</b>, <b>b</b> calls <b>a</b>, <b>c</b> calls nothing else,\r\n           <b>d</b> calls <b>a</b>, and <b>e</b> calls <b>d</b> and <b>c</b>.\r\n         <ul>\r\n            <li>Find two \"natural orders\" in which to write these methods in a file \r\n            <li>Find two \"reverse natural orders\" in which to write these methods in a file \r\n         </ul>     \r\n\r\n      <p>\r\n      <li>For all the sample methods in this lecture, identify the ones in\r\n            which it makes sense to throw <b>IllegalArgumentExceptions</b> and\r\n            describe under what conditions.\r\n          Note that sometimes individual parameters will store reasonable\r\n            values, but pairs of parameters will have values that are\r\n            incompatible.\r\n\r\n      <p>\r\n\r\n      <li>As we saw in this lecture, we can specify that a parameter variable\r\n            is <b>final</b>.\r\n          For example, we can rewrite <b>factorial</b> as\r\n<pre><b>  public static int factorial (final int n)\r\n  {\r\n    int answer = 1;\r\n    for (int i=2; i<=n; i++)\r\n      answer *= i;\r\n    return answer;\r\n  }</b></pre>\r\n  What does <b>final</b> mean when added before a parameter?\r\n  Does the <b>factorial</b> method still work correctly if its parameter is specified <b>final</b>?\r\n  If it didn't, would we find out at compile-time or at run-time?\r\n  Which methods in this lecture can have their parameters(s) declared to be\r\n     <b>final</b>? Which cannot?\r\n  Can any of the local variables in these methods be declared <b>final</b>?\r\n<p>\r\n\r\n<li>Define a class with the following characteristics:\r\n      its name is <b>Utility</b> and\r\n      it is in the <b>cs200</b> package.\r\n    It contains two <b>static</b> methods, both named <b>factorial</b>: the\r\n      first takes an <b>int</b> parameter and returns an <b>int</b> result;\r\n      the second takes a <b>BigInteger</b> parameter and returns a\r\n      <b>BigInteger</b> result.\r\n    Important whatever classes are necessary to write the bodies of these\r\n      methods successfully.\r\n<p>\r\n\r\n<li>Explain why when defining a class, we never need to write an import\r\n       declaration for the <b>Math</b> class.\r\n<p>\r\n\r\n     <li>I predict that half the students in class will make the following mistake when\r\n           they write one of their first few constructors.\r\n         Can you spot the mistake (compare it to the correctly written constructor in this lecture)?\r\n         What actually happens if we write this code?\r\n         Will Java detect/report the error? If so, with what message? If not, what will Java do when\r\n           it executes this code?\r\n<pre><b>  public SimpleDiceEnsemble () \r\n  {\r\n    int numberOfDice = 2;\r\n    int sidesPerDie  = 6;\r\n    int rollCount    = 0;\r\n  }</b></pre>\r\n  If we wrote each of these like <b>this.numberOfDice</b>, would it help?\r\n<p>\r\n\r\n<li>Explain how to simplify the following declarations and constructor.\r\nI have used the style of always writing <b>this.</b> to access instance\r\n  variables.\r\n<pre><b>  private int a;\r\n  private int b;\r\n  private int c;\r\n\r\n  public C (int a) \r\n  {\r\n    this.a = a;\r\n    this.b = 10;\r\n    this.c = 0;\r\n  }</b></pre><p>\r\n<p>\r\n\r\n     <li>Examine the code for the <b>SimpleDiceEnsemble</b> class.\r\n     <ul>\r\n       <li>Assume that we decide to roll the dice automatically, at the time\r\n             when the ensemble is constructed, to initialize them.\r\n           How could we modify the constructor to perform this task?\r\n           What changes (if any) could we make the method headers and bodies?\r\n       <li>Assume that we want users of this class to be able to retrieve the\r\n             minimum and maximum number of pips showing after each roll.\r\n           What extra instance variables should we declare?\r\n           What new methods should we write and what changes to old methods\r\n             should we make?\r\n     </ul>\r\n<p>\r\n<li>\r\nWrite a class named <b>RangeTally</b>.\r\nEach instance of this class stores four fields: the lower legal value, the\r\n  upper legal value, the sum of all the int values in this range that it is\r\n  has seen (via the <b>tally</b> method), and the total number of values that\r\n  has seen (whether they were in range or not).\r\nIts constructor should initialize these fields appropriately; its accessor,\r\n  <b>getTally</b>, should return the sum of all values seen which were in\r\n  range; its accessor, <b>getCount</b>, should return a count of all of values\r\n   that it has seen (whether they were in range or not); its mutator,\r\n  <b>tally</b>, is passed an <b>int</b> parameter that is conditionally tallied\r\n  into the sum; it should change all fields as appropriate\r\nFor example, if we declare <b>RangeTally t = new RangeTally(1,10);</b> and\r\n   execute the statements <b>t.tally(5); t.tally(8); t.tally(15);</b>\r\n   and then <b>System.out.println(t.getTally()+\":\"+t.getCount());</b> Java\r\n    prints </b>13:3</b> -the last value is counted, but not summed, because it\r\n    is not in the range <b>1</b> to <b>10</b>, specified in the constructor.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}