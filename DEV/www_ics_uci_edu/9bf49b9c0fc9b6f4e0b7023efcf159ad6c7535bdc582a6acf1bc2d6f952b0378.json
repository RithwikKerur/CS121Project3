{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/simplify/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-#IETF#DTD HTML#EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Simplification</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Simplification</h1>\r\n<p>\r\n<h2>ICS-31: Introduction to Programming\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture, we will discuss a variety of general issues in program\r\n  simplification.\r\nIt introduces no new Python programming features, but instead steps back to\r\n  provide a perspective on one very important programming skill that all\r\n  competent programmers must acquire.\r\nSometimes simplifying a program is the only way to comprehend it, and hence\r\n  debug it.\r\nFinally, this lecture shows that programs themselves can be studied and\r\n  manipulated in a formal way (just as expressions are manipulated in algebra).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Simplification -->\r\n\r\n<a name=\"Simplification\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Simplification</b></td>\r\n<td width =\"80%\">\r\nWe can use the laws of algebra to tell whether two forms are equivalent: using\r\n  either one produces the same result.\r\nThus, equivalence is a mathematical topic.\r\nBut as programmers, we must judge which form (the simpler one) to use in our\r\n  programs.\r\n<p>\r\nThe simplest program is the one that is easiest to read, debug, and maintain.\r\nThus, simplicity is a psychological topic.\r\nAs a rule of thumb, smaller forms are often easier to understand (although\r\n   sometimes a bit ofredundancy makes forms easier to understand:\r\n   smtms lss s nt mr).\r\n<p>\r\nIn this section we will examine three kinds of algebras for proving equivalences\r\n<ul>\r\n  <li>Boolean Algebra\r\n  <li>Relational Algebra\r\n  <li>Control Structure Algebra\r\n</ul>\r\nWe will learn how to prove equivalences in each algebra and discuss how to\r\n  gauge simplicity, as well as show lots of examples of simplifictions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Boolean Algebra -->\r\n\r\n<a name=\"BooleanAlgebra\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Boolean Algebra</b></td>\r\n<td width =\"80%\">\r\nBoolean Algebra concerns equivalences involving the <b>bool</b> type and the\r\n   logical operators.\r\nThe following is a list of useful laws (theorems, if you will) of Boolean\r\n  Algebra.\r\nThe most practical law is DeMorgan's law: one form explains how to simplify the\r\n  negation of a conjunction (<b>and</b>) and the other form explains how to\r\n  simplify the negaion of a disjunction (<b>or</b>).\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/boolean.jpg\"></mage>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nWe can easily prove laws in Boolean Algebra by trying every combination of\r\n  the <b>True</b> and <b>False</b> values for each of the variables.\r\nFor example, to prove the conjunctive version of DeMorgan's law, we can start\r\nwith the following table of values, called a <i>truth table</i>.\r\nHere we list all the variables in the leftmost columns, and the two\r\n  expressions -which we hope to prove equivalent- in the rightmost columns.\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">A</th><th>B</th><th>not(A and B)</th><th>not A or not B</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>True</td><td>&nbsp</td><td>&nbsp</td>\r\n<tr valign=\"top\"><td>True</td><td>False</td><td>&nbsp</td><td>&nbsp</td>\r\n<tr valign=\"top\"><td>False</td><td>True</td><td>&nbsp</td><td>&nbsp</td>\r\n<tr valign=\"top\"><td>False</td><td>False</td><td>&nbsp</td><td>&nbsp</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nWe then fill in each column by just computing the values of the expressions\r\n  (using the semantics of the operators and our knowledge of evaluating\r\n   expressions: e.g., operator precedence and associativity).\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">A</th><th>B</th><th>not(A and B)</th><th>not A or not B</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>True</td><td>False</td><td>False</td>\r\n<tr valign=\"top\"><td>True</td><td>False</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>False</td><td>True</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>False</td><td>False</td><td>True</td><td>True</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nThe law is proved if the columns under the two expressions always contain the\r\n  same pair of values on each line.\r\nThis means that for every pair of operands, the expressions compute the same\r\n  result, so the expression are equivalent and thus interchangable in our code.\r\n<p>\r\nThis approach also illustrates a divide and conquer strategy to proofs: we\r\n  divide the complicated proof into four different parts (each a line in the\r\n  truth table); each line is easy to verify by pure calculation; once we verify\r\n  all of the lines, we have verified the entire proof.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Relational Algebra -->\r\n\r\n<a name=\"RelationalAlgebra\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Relational Algebra</b></td>\r\n<td width =\"80%\">\r\nRelational Algebra concerns equivalances mostly involving the <b>int</b> and\r\n  <b>float</b> types and the numeric and relational operators.\r\nIt is based on the law of trichotomy. \r\n<ul>\r\n  <li><b>The law of trichotomy</b>: Given two values, the first is either less\r\n            than, equal to,or greater than the second.\r\n         One (and exactly one) of these relationships must always hold.\r\n</ul>\r\nWe can use the law of trichotomy as a divide and conquer method to break one\r\n  hard proof into many simpler ones.\r\nUnlike using boolean values, there are an infinite number of different\r\n   <b>int</b> values (even though the truth is the amount of memory on a \r\n   computer is finite, so we can store at most a finite number of digits in any\r\n   <b>int</b> object).\r\n<p>\r\nAs a first example, we will prove that <b>max(x,y)+1</b> is equivalent to\r\n  <b>max(x+1,y+1)</b>.\r\nSo, we can factor additive constants out of calls to the <b>max</b> function.\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">x?y</th><th>max(x,y)+1</th><th>max(x+1,y+1)</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>x < y</td><td>y+1</td><td>y+1</td>\r\n<tr valign=\"top\"><td>x = y</td><td>x+1 or y+1</td><td>x+1 or y+1</td>\r\n<tr valign=\"top\"><td>x > y</td><td>x+1</td><td>x+1</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nHere, knowing the relationship between <b>x</b> and <b>y</b> allows us to\r\n  compute the answer for each expression.\r\nFor example, if we know that <b>x&lty</b>, we know <b>max(x,y)</b> evaluates to\r\n   <b>y</b>, so <b>max(x,y)+1</b> evaluates to <b>y+1</b>; likewise, if we know\r\n   that <b>x&lty</b>, we know that <b>x+1&lty+1</b>, so <b>max(x+1,y+1)</b>\r\n   evaluates to <b>y+1</b>.\r\nThe other two cases can be simplified similarly. \r\n<p>\r\nAgain, the law is proved if the columns under the two expressions always have\r\n  the same pair of values on each line.\r\nThis means that for every pair of values, the expressions compute the same\r\n  result, so the expressions are interchangable.\r\n<p>\r\nAs another example, we can prove that the expression <b>x<0 == y<0</b> is\r\n  equivalent to  <b>(x<0 and y<0) or (x>=0 and y>=0)</b>, which is True when\r\n  <b>x</b> and <b>y</b> have the same sign (assuming the sign of 0 is\r\n  considered positive).\r\nHere we need to list all possibilities of how <b>x</b> and <b>y</b>\r\n  compare to <b>0</b>.\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">x?0</th><th>y?0</th><th>x<0 == y<0</th><th>(x<0 and y<0) or\r\n    (x>=0 and y>=0)</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>x<0</td><td>y<0</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>x<0</td><td>y=0</td><td>False</td><td>False</td>\r\n<tr valign=\"top\"><td>x<0</td><td>y>0</td><td>False</td><td>False</td>\r\n<tr valign=\"top\"><td>x=0</td><td>y<0</td><td>False</td><td>False</td>\r\n<tr valign=\"top\"><td>x=0</td><td>y=0</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>x=0</td><td>y>0</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>x>0</td><td>y<0</td><td>False</td><td>False</td>\r\n<tr valign=\"top\"><td>x>0</td><td>y=0</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>x>0</td><td>y>0</td><td>True</td><td>True</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nSo again, the equivalence it proven.\r\nHere is an interesting case where the smaller/simpler/more efficient code is\r\n  not necessarily easier to understand.\r\nMost students believe the larger expression is easier to understand, until\r\n  they intensely study the meaning of <b>==</b> when applied to\r\n  <b>boolean</b> values generated by relational operators.\r\n<p>\r\nIn actual code, I would suggest using the simpler form, and then include\r\n  the larger -easier to understand- form in a comment; we could even include\r\n  the above proof as part of the comment.\r\n<p>\r\nFinally we can use the law of trichotomy to prove that we simplify the \r\n  negation of relational operators.\r\nBe careful when you do so, and recall the law of trichotomy.\r\nIf it is not true that x is less than y, then there are two possiblities\r\n  left: x is equal to y or x is greater than y.\r\nBeginning programmers make the mistake of negating <b>x&lt;y</b> as\r\n<b>x&gt;y</b>, but the correct equivalent expression is <b>x&gt;=y</b>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">x?y</th><th>not (x < y)</th><th>x >= y</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>x < y</td><td>False</td><td>False</td>\r\n<tr valign=\"top\"><td>x = y</td><td>True</td><td>True</td>\r\n<tr valign=\"top\"><td>x > y</td><td>True</td><td>True</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nIn fact, we can use the same kinds of proofs to show how to simplify the\r\n  negation of every relational operator.\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">Negated Form</th><th>Simplified Form</th><th> < only Form</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>not (x < y)</td><td>x >= y</td><td>not (x < y)</td>\r\n<tr valign=\"top\"><td>not (x <= y)</td><td>x > y</td><td>y < x</td>\r\n<tr valign=\"top\"><td>not (x == y)</td><td>x != y</td><td>x < y or y < x</td>\r\n<tr valign=\"top\"><td>not (x != y)</td><td>x == y</td><td>not (x < y or y < x)</td>\r\n<tr valign=\"top\"><td>not (x >= y)</td><td>x < y</td><td>x < y</td>\r\n<tr valign=\"top\"><td>not (x > y)</td><td>x <= y</td><td>not (y < x)</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nAlso notice that each of the relational operators is equivalent to an\r\n  expression that includes only the <b>&lt</b> relational operator (along\r\n  with sone logical operators).\r\nAlthough we don't need the five other relational operators to write Python\r\n   programs (in a mathematical sense), they are provided because most\r\n   programmers are aware of them and can use them to write simpler programs\r\n   (in a psychological sense).\r\nThus the Python language is made larger (more operators) to make it easier for\r\n   human minds to use.\r\nSuch value judgements (which is better, a smaller language or a language\r\neasier for humans to use) are required by programming language designers.\r\n<p>\r\nFinally, we can often simplify negatated relational operators in DeMorgan's\r\n  Laws simplifications.\r\nFor example, we can \"simplify\" <b>not (x < 0 or y > 10)</b> to\r\n  <b>not (x < 0) and  not (y > 10)</b> which is actually a bit larger, but\r\n  can be further simplified to <b>x >= 0 and y <= 10</b> which is truly \r\n  simpler.  \r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Control Structure Algebra -->\r\n\r\n<a name=\"ControlStructureAlgebra\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Control Structure Algebra</b></td>\r\n<td width =\"80%\">\r\nNow we will explore the richest algebra: the algebra of control structures.\r\nFirst we will examine when changing the order in a sequence of statements\r\n  doesn't change the results of executing the sequence.\r\nSecond we will discuss transformations to <b>if</b> statements.\r\nFinally, we will discuss transformations to <b>while</b> loops containing\r\n  <b>break</b> statements.\r\n\r\n<a name=\"sequence\">\r\n<h3>Sequence equivalences</h3>\r\nWe start by examining the orderings of statements and defining two important\r\n  terms.\r\n<ul>\r\n  <li>A statement <i>rebind</i> a name if the name is rebound to an object.\r\n      So, in <b>x = y</b> rebinds <b>b</b> (but not <b>y</b>)).\r\n  <li>A statement <i>evaluates</i> a name if the statement needs to retrieve\r\n        the value bound to that name.\r\n      So, <b>x = y</b> evalutes <b>y</b> (but not <b>x</b>).\r\n</ul>\r\nInterestingly enough, the expression statement <b>x += 1</b> both binds and\r\n  evaluates <b>x</b>: it first finds the value stored in <b>x</b>, then\r\n  computes the value one higher, then rebinds <b>x</b> to that new value\r\n  (the equivalent assignment statement <b>x = x+1</b> illustrates this\r\n  assertion more clearly).\r\nIn the entire <b>if</b> statement <b><pre>\r\n  if x > y:            #Evaluates x and y\r\n      z = x            #Rebinds z; evaluates x\r\n  else:\r\n      y++              #Rebinds and evaluates y</pre></b>\r\nwe say that the <b>if</b> statement rebinds <b>z</b> and <b>y</b>; it evaluates\r\n  <b>x</b> and <b>y</b>.\r\nThis accounts for everything the <b>if</b> statement might do when exeucted\r\n  (even though, for example, sometimes it rebinds only <b>x</b> and sometimes\r\n   only <b>y</b>: it depends on the result of the test).\r\nNote that we will also say <b>print(\"...\")</b> rebinds into the console\r\n  because this function causes new information to appear inside the console\r\n  window (changing its state); this is a bit of a stretch.\r\n<p>\r\nArmed with this terminology, we can define <i>indepdendent</i> statements in a\r\n  sequence.\r\nTwo statements are independent if we can exchange their order and they still\r\n  always compute equivalent results.\r\nTwo statements <b>S<sub>1</sub></b> and <b>S<sub>2</sub></b> are independent if\r\n  <b>S<sub>1</sub></b> rebinds and evaluates no names that <b>S<sub>2</sub></b>\r\n  rebinds, and <b>S<sub>2</sub></b> rebinds and evaluates no names that\r\n  <b>S<sub>1</sub></b> rebinds.\r\nOr, more simply two statements are independent (and we can reverse their order)\r\n  if neither rebinds a name the other rebinds or evaluates.\r\n<p>\r\nFor example, we can exchange the order of\r\n<b><pre>  x = 1\r\n  print(y)</pre></b>\r\nbecause these statements satisfy the property above (also, just think about\r\n  whether either statement affects the other: they don't).\r\nWe cannot exchange the order of\r\n<b><pre>  x = 1\r\n  print(x)</pre></b>\r\nbecause the second statement evaluates  <b>x</b>, which the first statement\r\n  rebinds (the value printed depends on whether <b>x</b> is assigned the value\r\n  1 before or after the call of <b>print</b>).\r\nLikewise, we can exchange the order of\r\n<b><pre>  x = 1\r\n  y = 0</pre></b>\r\nbecause they satisfy the property above.\r\nWe cannot exchange the order of \r\n<b><pre>  x = 1\r\n  x += 1</pre></b>\r\nbecause the second statement rebinds <b>x</b>, which the first statement also\r\n rebinds.\r\n<p>\r\nObviously, changing the order of two statements doesn't simplify anything; but\r\n  we will learn that such exchanges can sometimes enable further \"real\"\r\n  simplifications.\r\n<p>\r\n\r\n\r\n<a name=\"if\">\r\n<h3>if equivalences</h3>\r\nNow, onto <b>if</b> statements.\r\nWe can use a modified truth table to prove the equivalence of two <b>if</b>\r\n  statements.\r\nFor the <b>if</b> statement below\r\n<b><pre>  if test:\r\n      statement<sub>1</sub>\r\n  else:\r\n      statement<sub>2</sub>  </pre></b>\r\nwe have the following modified truth table. \r\nNote that although <b>test</b> can be an arbitrarily complicated expression,\r\n  ultimately its value is either <b>True</b> or <b>False</b>.\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">test</th><th>Code Executed</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>statement<sub>1</sub></td>\r\n<tr valign=\"top\"><td>False</td><td>statement<sub>2</sub></td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\n<b>Boolean Assignment</b>:\r\nLet's examine various pairs of statements that we can prove equivalent by\r\n  using these modified truth tables.\r\nThe first involves storing a <b>bool</b> value into a name.\r\nFor the two statements <b><pre>  if test:                   b = test\r\n      b = True\r\n  else:\r\n      b = False</pre></b>\r\nwe have the following modified truth table. \r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>b = True</td><td>b = True(becaue <b>test</b> is <b>True</b>)</td>\r\n<tr valign=\"top\"><td>False</td><td>b = False</td><td>b = False (becaue <b>test</b> is <b>False</b>)</td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nAgain, because both columns show the same statements executed, regardless of\r\n  the value of <b>test</b>, the <b>if/else</b> statement on the left and\r\n  expression statement on the right are equivalent.\r\n<p>\r\n <b>Test Reversal</b>:\r\nThis equivalence shows that we can negate the <b>test</b> AND the order of\r\n  the two statements inside the <b>if/else</b> and the resulting <b>if/else</b>\r\n  statement is equivalent to the first.\r\n<b><pre>  if test:           if not(test):\r\n      statement<sub>1</sub>         statement<sub>2</sub>\r\n  else:              else:\r\n      statement<sub>2</sub>         statement<sub>1</sub></pre></b>\r\nwe have the following modified truth table. \r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>statement<sub>1</sub></td><td>statement<sub>1</sub> </td>\r\n<tr valign=\"top\"><td>False</td><td>statement<sub>2</sub> </td><td>statement<sub>2</sub> </td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nWhich means that the following two <b>if/else</b> statements are equivalent.\r\nI'd argue that the one on the right is simpler and easier to understand,\r\n  because it is easier to see that it is an <b>if/else</b> statement: our\r\n  eyes can see that loking just at the top three lines.\r\nIn the version on the left, the small <b>else</b> clause is almost hidden\r\n  at the bottom.\r\n<b><pre>\r\n  if test              if not(test)\r\n      statement<sub>T1</sub>          statement<sub>F</sub>\r\n      statement<sub>T2</sub>      else:\r\n      ...<sub>&nbsp</sub>                 statement<sub>T1</sub>\r\n      statement<sub>Tn</sub>          statement<sub>T2</sub>\r\n  else:                    ...\r\n      statement<sub>F</sub>           statement<sub>Tn</sub></pre></b>\r\nOf course, we might be able to use DeMorgan's law to further simplify\r\n   <b>not(test)</b> too.\r\n<p>\r\n<b>Bottom Factoring</b>:\r\nThis equivalence shows that we can <i>always</i> remove (factor) a common\r\n  statement out from the bottom  of an <b>if/else</b> statement.\r\nIt is similar to algebraically factoring <b>AX+BX</b> into <b>(A+B)X</b>.\r\n<b><pre>\r\n  if test:             if test\r\n      statement<sub>1</sub>           statement<sub>1</sub>\r\n      statement<sub>c</sub>       else:\r\n  else:                    statement<sub>2</sub>\r\n      statement<sub>2</sub>       statement<sub>c</sub>\r\n      statement<sub>c</sub></pre></b>\r\nTo prove this equivalence we use the following modified truth table. \r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>statement<sub>1</sub><br>statement<sub>c</sub>\r\n                 </td><td>statement<sub>1</sub><br>statement<sub>c</sub></td>\r\n<tr valign=\"top\"><td>False</td><td>statement<sub>2</sub><br>statement<sub>c</sub>\r\n                 </td><td>statement<sub>2</sub><br>statement<sub>c</sub></td>\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\nFor example, the code on the top is equivalent to the code on the bottom.\r\n  <b><pre>  if zcc == 0:\r\n      print('zcc = 0')\r\n      zcc = 1\r\n  else:\r\n      print('zcc != 0')\r\n      zcc = 1;\r\n\r\n  if zcc == 0:\r\n      print('zcc = 0')\r\n  else:\r\n      print('zcc != 0')\r\n  zcc = 1</pre></b>\r\n<p>\r\n\r\n<b>Top Factoring</b>:\r\nThis equivalence is shows that we can <i>often</i> remove a common statement \r\n  out from the front of an <b>if/else</b> statement.\r\nIt is similar to algebraically factoring <b>XA+XB</b> into <b>X(A+B)</b>.\r\n  <b><pre>\r\n  if test:             statement<sub>c</sub>\r\n      statement<sub>c</sub>       if test:\r\n      statement<sub>1</sub>           statement<sub>1</sub>\r\n  else:                else:\r\n      statement<sub>c</sub>           statement<sub>2</sub>\r\n      statement<sub>2</sub></pre></b>\r\nTo prove this equivalence we use the following modified truth table. \r\n <p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n<thead><tr><th align=\"left\">test</th><th>Left Code Executed</th><th>Right Code Executed</th>\r\n</thead>\r\n<tbody>\r\n<tr valign=\"top\"><td>True</td><td>statement<sub>c</sub><br>statement<sub>1</sub>\r\n                 </td><td>statement<sub>c</sub><br>statement<sub>1</sub></td>\r\n<tr valign=\"top\"><td>False</td><td>statement<sub>c</sub><br>statement<sub>2</sub>\r\n                 </td><td>statement<sub>c</sub><br>statement<sub>2</sub></td>\r\n</td>\r\n</tbody>\r\n</table>\r\n  <p>\r\nBut there is one more detail to take care of.\r\nNow we are executing <b>statement<sub>c</sub></b> before the <b>if/else</b>,\r\n  which means it is executed before the <b>test</b> expression is evaluated. \r\nThis is guaranteed to work only if the statement and test are independent (as\r\n  defined earlier).\r\nBecause a <b>test</b> only evaluates names, we can simplify this to\r\n  <b>statement<sub>c</sub></b> must not redefine a name evaluated in\r\n  <b>test</b>\r\nIn the example below, the code on the top is NOT equivalent to the code on the\r\n  bottom.\r\n<b><pre>  if zcc == 0:\r\n      zcc = 1\r\n      print('zcc = 0')\r\n  else:\r\n      zcc = 1\r\n      print('zcc != 0')\r\n  }\r\n\r\n\r\n  zcc = 1\r\n  if zcc == 0:\r\n      print('zcc = 0')\r\n  else\r\n      print('zcc != 0')</pre></b>\r\nbecause the code on the bottom can never have the test <b>zcc == 0</b>\r\n  evalute to True.\r\nThis is because the <b>test</b> (<b>zcc == 0</b>) is not independent of the\r\n  statement  <b>zcc = ;</b>: it evaluates a name redefined by this statement.\r\n<p>\r\nOn the other hand, sometimes even if the expression and statement are not\r\n  independent, we can modify the test to account for the statement always\r\n  executing before the <b>if/else</b> statement.\r\nThe code on the top here is equivalent to the code on the bottom (we can prove\r\n  it using the law of trichotomy: <b>zcc ? 0</b>).\r\n  <b><pre>  if zcc == 0:\r\n      zcc += 1\r\n      print('zcc was == 0')\r\n  else:\r\n      zcc += 1\r\n      print('zcc was not == 0')\r\n\r\n\r\n  zcc++\r\n  if zcc == 1:\r\n      print('zcc was == 0')\r\n  else\r\n      print('zcc was not == 0')</pre></b>\r\nIn fact, another way to simplify this code is to exchange the two statements in\r\n  each block (they are independent) and then just bottom-factor <b>zcc += 1</b>,\r\n  yielding\r\n<b><pre>  if zcc == 0:\r\n      print('zcc was == 0')\r\n  else:\r\n      print('zcc was not == 0')\r\n  zcc += 1</pre></b>\r\n\r\n<p>\r\n \r\n\r\n<a name=\"for\">\r\n<h3>loop equivalences</h3>\r\nFinally, let's look at three loop equivalences.\r\n<p>\r\n<b>else Removal</b>:\r\nThis equivalence involves the removal of an unnecessary <b>else</b> in an\r\n  <b>if</b> controlling a <b>break</b>.\r\n<b><pre>  while True:              while True:\r\n      statements<sub>1</sub>              statements<sub>1</sub>\r\n      if test:                 if test:\r\n          break                    break\r\n      else:                    statements<sub>2</sub>\r\n          statements<sub>2</sub></pre></b>\r\nIn both loops, if <b>test</b> is <b>True</b> Python executes the <b>break</b>;\r\n  if <b>test</b> is <b>False</b> each loop executes\r\n  <b>statements<sub>2</sub></b> next and\r\n  then re-executes the loop: on the left because <b>statements<sub>2</sub></b>\r\n  is in the <b>else</b>, and on the right \r\n  because the <b>if</b> finishes and Python executes the next statement in the\r\n  loop's body.\r\n  After executing <b>statements<sub>2</sub></b>, the bodies of both loops are\r\n  finished executing, so the loop causes Python to execute them again.\r\n<p>\r\nTypically code is simpler if it isn't nested deeply.\r\n<p>\r\n<b>Loop Factoring</b>:\r\n  The second loop equivalence again involves factoring statements.\r\n  <b><pre>\r\n  while True:             while True:\r\n      statements<sub>1</sub>             statements<sub>1</sub>\r\n      if test:                if (test)\r\n          statements<sub>a</sub>              break\r\n          break               statements<sub>2</sub>\r\n      statements<sub>2</sub>         statements<sub>a</sub></pre></b>\r\nIn both loops, if <b>test</b> is <b>False</b> each executes\r\n  <b>statements<sub>2</sub></b>, and the bodies of both loops are executed\r\n  again.\r\nIn the left loop, if <b>test</b> is <b>True</b> it executes\r\n  <b>statements<sub>a</sub></b> and then terminates the loop; on the right it\r\n  terminates the loop and afterward executes  <b>statements<sub>a</sub></b>.\r\nThe order of these operations makes no difference.\r\n<p>\r\nTypically, loop statements are the most complex to understand, in terms of\r\n  what they do; so by removing <b>statements<sub>a</sub></b> from the body\r\n  of the loop, we simplify it.\r\n<p>\r\n<b>Loop Rerolling</b>:  <sub></sub>\r\nThe third loop equivalence involves moving statements repeated before and at\r\n  the bottom of a loop completely inside the loop.\r\n  <b><pre>\r\n  statements<sub>1</sub>             while True:\r\n  while True:                 statements<sub>1</sub>\r\n      if test:                if test:\r\n          break                   break\r\n      statements<sub>2</sub>             statements<sub>2</sub>\r\n      statements<sub>1</sub></pre></b>\r\nEach code fragment first executes <b>statements<sub>1</sub></b> (on the left\r\n  before the loop; on the right as the first statement in the loop's body).\r\nThen, each tests for termination; if the <b>test</b> is not True, each executes\r\n  <b>statements<sub>2</sub></b>, followed by <b>statements<sub>1</sub></b> (on\r\n  the left at the  bottom of the loop; on the right at the top of th loop),\r\n  followed by testing for termination again.\r\n<p>\r\nTypically, we want to avoid duplicating statements inside and outside of\r\n  loops.\r\nBy using <b>while</b>/<b>if</b>/<b>break</b>, which allows a termination test\r\n  in the middle of a loop, we can remove this redundancy.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Pragmatics -->\r\n\r\n<a name=\"Pragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Pragmatics</b></td>\r\n<td width =\"80%\">\r\nThe formal techniques presented and illustrated above allow us to prove that\r\n  two programming forms are equivalent.\r\nIt is then up to us to determine which form is simpler, and use it in our\r\n  programs.\r\nAs a rule of thumb, the smaller the code the simpler it is.\r\nAlso, code with fewer nested statements is generally simpler.\r\n<p>\r\nMore generally, we should try to distribute complexity.\r\nSo, when decidiing between two equivalences, choose the one whose most\r\n  complicated statement is simplest.\r\n<p>\r\nIf you ever find yourself duplicating code, there is an excellent chance that\r\n  some simplification will remove this redundancy.\r\nBeginners are especially prone to duplicating large chunks of code, missing the\r\n  important simplification.\r\n<p>\r\nWe should aggressively simplify our code while we are programming.\r\nWe will be amply rewarded, because it is easier to add more code (completing\r\n  the phases of the enhancements) to an already simplified program.\r\nIf we wait until the program is finished before simplifying...well, we many\r\n  never finish the program because it has become too complex; if we do\r\n  finish, the  context in which to perform each simplification will be much\r\n  bigger and more complex, making it harder to simplify.\r\nExcessive complexity is one of the biggest problems that a software engineer\r\n  faces.\r\n<p>\r\nGenerally, I try not to get distracted when I am writing code; but one of \r\n  the few times that I will stop writing code is when I see a simplification.\r\nI know that in the long run, taking time to do a simplification immediately\r\n  will likely allow me to finish the  program faster.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\nTo ensure that you understand all the material in this lecture, please solve\r\n  the the announced problems after you read the lecture.\r\n<p>\r\nIf you get stumped on any problem, go back and read the relevant part of the\r\n   lecture.\r\nIf you still have questions, please get help from the Instructor, a TA, or any\r\n  other student.\r\n\r\n<ol> \r\n   <li>Prove that the expressions <b>x < 10</b> and <b>(x < 10) == True</b> are\r\n         equivalent.\r\n       Prove that the expressions <b>x < 10</b> and <b>(x >= 10) == False</b>\r\n          are equivalent.\r\n       In each case, which would you judge the simpler expression?\r\n  <p>\r\n     \r\n  <li>Use the law of trichotomy to prove that <b>(x+y-abs(x-y))//2</b> and\r\n           <b>min(x,y)</b> compute the same value.\r\n     <p>\r\n     \r\n  <li>In the following statements, identify which names rebind and which\r\n         are evaluted.\r\n         <ul>\r\n           <li><b>x += y</b>\r\n           <li><b>x = x + 1</b>\r\n           <li><b>print(x)</b>\r\n           <li><b>if x > 0: x = 0</b>\r\n           <li><b>if x == 0: break</b>\r\n         </ul>\r\n     <p>\r\n\r\n  <li>Prove that the following two statements are equivalent.\r\n        declared <b>boolean b;</b>\r\n      <b><pre>  if test:           b = !test;\r\n      b = False\r\n  else:\r\n      b = True</pre></b>\r\n  <p>\r\n\r\n  <li>The code on the left is not equivalent to the code on the right (which\r\n         has been top factored).\r\n      They are not equivalent because the <b>if</b>'s test and the statement\r\n         <b>x += 1</b> are not independent.\r\n      Rewrite the <b>if</b>'s test in the code on the right so that left and\r\n         right are equivalent.\r\n     <b><pre>  if x < 10:                  x += 1\r\n      x += 1                  if x < 10:\r\n      print(x)                    print(x)\r\n  else:                       else:\r\n      x += 1                      y = x\r\n      y = x</pre></b>\r\n\r\n  <p>\r\n  <li>Suppose we are comparing aspirin A1, A2, A3, and A4 for efficacy.\r\n      Suppose that the company making A1 goes on TV with the advertisement:\r\n      \u201cNo aspirin is better than A1\u201d.\r\n      Could the other companies also run ads saying the exact same thing about their products?\r\n      <p>\r\n      How does this question relate to the material in this lecture?\r\n      How does it relate to mathematical vs. perceptual/psychological truths in advertising?\r\n      As a programmer whose code is read by other people (as well as the Python compiler), what\r\n        implications does this have for the audience for which we are writing code?\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "Windows-1252"}