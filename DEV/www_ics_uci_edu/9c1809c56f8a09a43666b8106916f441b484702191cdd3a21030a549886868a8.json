{"url": "https://www.ics.uci.edu/~thornton/ics23/LabManual/RockAndRoll/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\n\n<title>ICS 23 / CSE 23 Summer 2012, Project #4: Rock and Roll Stops the Traffic</title>\n</head>\n\n<body>\n\n<div class=\"navbar\">\n\n<p>\nICS 23 / CSE 23 Summer 2012 |\n<a href=\"../../index.html\">News</a> |\n<a href=\"../../CourseReference.html\">Course Reference</a> |\n<a href=\"../../Schedule.html\">Schedule</a> |\n<a href=\"../../LabManual\">Lab Manual</a> |\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\n</p>\n\n<hr />\n\n</div>\n\n<div class=\"header\">\n\n<p>ICS 23 / CSE 23 Summer 2012<br />\n   Project #4: <i>Rock and Roll Stops the Traffic</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, August 17, 11:59pm</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Introduction</p>\n\n<p>As residents of southern California, most of us face the realities of heavy traffic.  If we attempt to drive on a local freeway during rush hour, we often experience major traffic jams and long delays.  What's worse, unless we remember to look online ahead of time, we're rarely apprised of unusual delays (e.g., accidents, road closures) before we've encountered them.  Even if we know about a delay in advance, it's often difficult to find a suitable alternate route, either because we're unfamiliar with the area or because those alternatives are just as clogged with traffic as the route we're trying to avoid.</p>\n\n<p>It's not hard to imagine how the presence of wireless Internet connections in everyone's cars could help the situation.  Aside from providing the obvious ability to download traffic reports and maps on demand, with up-to-the-minute traffic information and a little computing, your car could actively aid you in finding the best way to get from one place to another, optimized not only for distance, but also for the shortest drive time given the current traffic conditions.  Further, if all cars were using the system, as drivers were diverted around the scene of an accident, traffic conditions would change; the advice offered by drivers' in-car systems would also change, optimally routing cars around a traffic jam by sending different cars down different alternate paths.  This way, even the alternatives might flow as quickly as possible.  (This is hardly science fiction; such systems are in development today, with some of these features already available.)</p>\n\n<p>For this project, you will write a simplified version of an important piece of such a system.  Given a map of streets and freeways, along with a snapshot of the current traffic between points on the map, your program will be capable of finding the shortest distance or fastest route to get from one location to another.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Our abstraction of a street map</p>\n\n<p>Real-life street maps, such as those generated online by Google, or those published in books by companies like Thomas Bros., are a handy way for people to determine an appropriate route to take from one location to another.  They present an abstraction of the world as a scaled-down drawing of the actual streets.  In order to be useful to us, a street map needs to give us the names of streets and freeways, to accurately demonstrate distances and directions, and to show us where the various streets and freeways intersect.</p>\n\n<p>For our program, we'll need to develop a different abstraction of a street map.  Our abstraction must contain the information that is pertinent to the problem we're trying to solve, presented in a way that will make it as easy as possible for our program to solve it.  Not surprisingly, a picture made up of lines and words is not an abstraction that is useful to our program; it would require a tremendous amount of effort to design and implement an algorithm to interpret the lines and words and build up some alternate representation that's more convenient.  It's better that we first design the more convenient representation, then train our program to read and understand an input file that specifies it.  To do so, we'll need to consider the problem a bit further.</p>\n\n<p>Our program's main job is to discover the shortest distance or time between two <i>locations</i>.  There's no reason we couldn't think of locations as being any particular point on a street map (for example, any valid street address, or even any valid GPS coordinate).  For simplicity, we'll think of them as one of two things:</p>\n\n<ul>\n  <li>The intersection of two or more streets.</li>\n  <li>A point on a freeway at which there is an entrance and/or an exit.</li>\n</ul>\n\n<p>Stated differently, a location is a point at which a driver would be forced to make a decision about what direction to go.</p>\n\n<p>Connecting pairs of locations on the map are stretches of road.  In order to solve our problem, we'll need to know two things about each stretch of road:</p>\n\n<ul>\n  <li>Its length, in miles.</li>\n  <li>The current speed of traffic traveling on it, in miles per hour.</li>\n</ul>\n\n<p>Our map will consist of two kinds of roads: <i>streets</i> and <i>freeways</i>.  A street is a sequence of intersections, connected by stretches of road running in opposite directions.  The lengths of the stretches of road are generally the same, or at least nearly the same, on both sides of the street, though the amount of traffic &mdash; and, therefore, the current speed of traffic &mdash; on either side of the street may differ.  In real life, many intersections control traffic using stop signs or traffic lights.  Our program will ignore these controls; we'll instead assume that the traffic speeds on streets have been adjusted appropriately downward to account for the time spent waiting at stop signs and lights.</p>\n\n<p>Freeways seem like bi-directional roads, but they're actually two separate, divided stretches of road traveling in opposite directions.  For a few reasons, we will need to treat each side of the freeway as an entirely separate road:</p>\n\n<ul>\n  <li>The sequence of ramps on one side of a freeway is sometimes different than the sequence on the opposite side.  For example, near UCI, the 405 South has a transition ramp that leads to the 73 South, but the 405 North has no such ramp.  For this reason, there may be a different number of locations on one side of a freeway than another.</li>\n  <li>The amount of traffic on one side of a freeway may be radically different from the amount on the other, so the speed of the cars traveling in one direction may also differ widely.</li>\n</ul>\n\n<p>It turns out that our program will not need to think about streets and freeways separately, since they are both represented the same way: as a sequence of locations, connected by stretches of road.  Also, to keep the problem relatively simple, absolute directions (i.e., north, south, east, and west) will not be considered by our program or reported in its output.  For that reason, they won't be included in our abstraction of a street map, except optionally in the names of locations.</p>\n\n<p>The output of our program will be a <i>trip</i>.  A trip is a sequence of visits to locations on the map.  For example, when I used to live in Costa Mesa (and parked my car in a parking lot where Bren Hall now stands), my typical trip home from UCI looked like this:</p>\n\n<ul>\n  <li>Start at Peltason & Los Trancos</li>\n  <li>Continue to Bison & Peltason</li>\n  <li>Continue to Bison & California</li>\n  <li>Continue to Bison & 73N on-ramp</li>\n  <li>Continue to 73N @ Birch</li>\n  <li>Continue to 73N @ 73N-to-55N transition</li>\n  <li>Continue to 55N @ Baker</li>\n  <li>Continue to 55N Baker/Paularino ramp & Baker</li>\n  <li>Continue to Baker & Bristol</li>\n</ul>\n\n<p>In addition to the information above, your program will also output information about the distance in miles and travel time of each of the segments of the trip, as well as the overall distance and travel time for the whole trip.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Representing our abstraction of a street map</p>\n\n<p>If you consider all of the data that we'll need to represent this abstraction, the task of organizing it can seem overwhelming.  However, there is a well-known data structure that represents this system in a straightforward way: a directed graph.</p>\n\n<p>Using a directed graph, vertices can represent locations, and edges can represent the stretches of road that connect them.  Since traffic travels in only one direction on a given stretch of road, it makes good sense that the graph should be directed.</p>\n\n<p>Each vertex in the graph will have a human-readable name for the location it represents.  For example, a vertex might be named <b>Culver & Harvard</b> or it might be named <b>I-405N @ Jamboree</b>.  The name will be used only for display purposes; it won't have any significance in the shortest-path algorithm.  The vertices should be numbered uniquely and consecutively, starting at zero.  If there are <i>n</i> vertices, they should be numbered 0 .. <i>n</i> - 1.</p>\n\n<p>Each edge will contain the two necessary pieces of information about the stretch of road it represents: the distance between the two vertices (in miles, stored as a double) and the current speed of traffic (in miles per hour, stored as a double).</p>\n\n<p>Since a trip is a sequence of visits to adjacent locations on the map, locations are represented by vertices, and two locations are adjacent only when there is an edge connecting them, a trip can be represented as a path in the graph.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">The program</p>\n\n<p>The goal of your program is to take, as its input, a file that describes all of the locations and the stretches of road that connect them.  It then performs two tasks:</p>\n\n<ol>\n  <li>Ensures that it is possible for every location to be reached from every other location.  (If we think of the locations and roads as a directed graph, this boils down to the problem of determining whether that graph is <i>strongly connected</i>.)  If not, the message <b>Disjointed Map</b> should be output and the program should end.</li>\n  <li>Determines, for a sequence of <i>trip requests</i> listed in the input file, shortest distances or shortest times between pairs of locations.</li>\n</ol>\n\n<p>So that we can keep everything straight during the grading process, please write your <b>main()</b> method in a class called <b>Project4</b>, so that we can run your program using the following command:</p>\n\n<pre>\n    java Project4 sample.txt\n</pre>\n\n<p>where the name of the input file is specified as a command-line argument to the program.  If we ran your program with the command above, it would read its input from the file <b>sample.txt</b>; your program should be able to read files with names other than <b>sample.txt</b>, as well (i.e., read whatever file is specified on the command line).</p>\n\n<p>Check out this <a href=\"sample.txt\">sample input file</a>.  A description of its format follows.</p>\n\n<p>The input file is separated into three sections: the locations, the road segments connecting them, and the trips to be analyzed.  Blank lines should be ignored.  Lines beginning with a <b>#</b> character indicate comments and should likewise be ignored.  This allows the input file to be formatted and commented, for readability.</p>\n\n<p>The first section of the file defines the names of the map locations.  First is a line that contains the number of locations.  If there are <i>n</i> locations, the next <i>n</i> lines of the file contain the names of each location.  The locations will be stored in a graph as vertices.  Each vertex is to be given a number.  You should number the vertices consecutively in the order they appear in the file, starting at 0.</p>\n\n<p>The next section of the file defines the road segments.  Each road segment will be an edge in the graph.  The first line of this section defines the number of segments.  Following that are the appropriate number of road segment definitions.  Each segment is defined on a line, with four values on it:</p>\n\n<ol>\n  <li>The vertex number where the segment begins.</li>\n  <li>The vertex number where the segment ends.</li>\n  <li>The distance covered by the segment, in miles.</li>\n  <li>The current speed of traffic on the segment, in miles per hour.</li>\n</ol>\n\n<p>Finally, the trips are defined.  Again, the section begins with a line containing the number of trips.  Following that are an appropriate number of trip requests.  Each trip request is a line with three values on it:</p>\n\n<ol>\n  <li>The starting location for the trip.</li>\n  <li>The ending location for the trip.</li>\n  <li><b>D</b> if the program should determine the shortest distance, <b>T</b> if the program should determine the shortest driving time.</li>\n</ol>\n\n<p>Your program should read the vertices and edges from the file, build the graph, then process the trip requests in the order that they appear.  The output for each trip request is described later in this write-up.</p>\n\n<p>You may assume that the input file will be formatted according to the rules described above, but you <i>may not</i> assume that the input file we'll use to test the program will be identical to the sample.  Different numbers of vertices, different configurations of edges, different names, different distances and speeds, etc., are possible.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Implementing the graph</p>\n\n<p>There are two well-known approaches that can be used to implement a graph: an <i>adjacency matrix</i> and <i>adjacency lists</i>.  As we've discussed in class, sparse graphs (that is, graphs with few edges relative to the number of vertices) are better implemented using adjacency lists, since an adjacency matrix would waste substantial amounts of memory and time storing and processing the vast number of blank cells in the matrix.  Our street map is clearly a sparse graph, since each vertex will have edges to and from only a few relatively \"nearby\" vertices.  So, adjacency lists are a far superior approach in our case.  You are required to use this approach to represent your graph.</p>\n\n<p>A good way to store adjacency lists is to place each vertex's information into the cell of an array or ArrayList indexed by its vertex number.  Each cell has a vertex name and a reference to the first node in a list of its outgoing edges.  For each of these edges, we store the ID number of the adjacent vertex, the distance to that vertex, and the time to travel to it.  (Remember that an adjacent vertex is one that can be reached from the current vertex by following one edge.)  You will obviously need methods to build up the adjacency lists and to access them to get information about a particular vertex or edge.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Finding the shortest paths</p>\n\n<p>The problem we need to solve, that of finding the fastest or shortest trip along a network of roads, is not an uncommon one in computing.  In fact, it's so common that it's already been solved abstractly.  Our problem is an instance of the <i>single-source, positive-weighted, shortest-path problem</i>.  In other words, from one particular vertex (a \"single source\"), we'll be finding the shortest path to another vertex, where all of the edges have a \"positive weight\" (in our case, distance or speed, neither of which will ever be negative or zero) associated with them.  We'll use a well-known algorithm called Dijkstra's Shortest-Path Algorithm to solve this problem.</p>\n\n<p>Dijkstra's Algorithm actually finds the shortest path from some start vertex to <i>all</i> the other vertices in a graph &mdash; this doesn't slow the algorithm down, since it needs to calculate them all in order to find the desired answer &mdash; though we're only interested in one of the paths that it will find.  There's a benefit to Dijkstra's calculation of all the shortest paths from some vertex.  Suppose the file has multiple trips starting from the same vertex.  With Dijkstra's Algorithm, we can compute shortest paths from any particular start vertex to all other vertices once for distance and once for time, storing the results in memory.  Then, to learn the shortest path from that start vertex to any other vertex, we can just look up the answer.  Use this approach in your program; it is likely the file will contain multiple trips that start from a particular place, and only a poorly-designed solution would require the program to re-compute data it has already computed, unless memory was at such a premium that there wasn't enough space to store previous results (and, since this program is running on PCs and laptops, there will be plenty of memory avaliable).</p>\n\n<p>For each vertex <i>v</i>, Dijkstra's Algorithm keeps track of three pieces of information: <i>k<sub>v</sub></i>, <i>d<sub>v</sub></i>, <i>p<sub>v</sub></i>.</p>\n\n<ul>\n  <li><i>k<sub>v</sub></i> is a boolean flag that indicates whether the shortest path to vertex <i>v</i> is known.  Initially, <i>k<sub>v</sub></i> is <b>false</b> for all vertices.</li>\n  <li><i>d<sub>v</sub></i> is the length of the shortest path found thusfar from the start vertex to <i>v</i>.  When the algorithm begins, no paths have been considered, so <i>d<sub>v</sub></i> is initially set to &infin; for all vertices, except the start vertex, for which <i>d<sub>v</sub></i> = 0.</li>\n  <li><i>p<sub>v</sub></i> is the predecessor of the vertex <i>v</i> on the shortest path found thusfar from the start vertex to <i>v</i>.  Initially, <i>p<sub>v</sub></i> is <b>unknown</b> for all vertices, except for the start vertex, for which <i>p<sub>v</sub></i> is <b>none</b>.</li>\n</ul>\n\n<p>As the algorithm proceeds, it will need to calculate the <i>cost</i> for individual edges.  The cost of the edge from <i>v</i> to <i>w</i> will be called <i>C</i>(<i>v</i>, <i>w</i>).  How you calculate the cost depends on whether you're minimizing driving distance or driving time:</p>\n\n<ul>\n  <li>If you're minimizing driving distance, <i>C</i>(<i>v</i>, <i>w</i>) is the number of miles on the edge from <i>v</i> to <i>w</i>.</li>\n  <li>If you're minimizing driving time, <i>C</i>(<i>v</i>, <i>w</i>) is the amount of time (in seconds, let's say) required to drive along the edge from <i>v</i> to <i>w</i>, given its length and traffic speed.</li>\n</ul>\n\n<p>Dijkstra's Algorithm proceeds in phases.  The following steps are performed in each pass:</p>\n\n<ol>\n  <li>From the set of vertices for which <i>k<sub>v</sub></i> is <b>false</b>, select the vertex <i>v</i> having the smallest <i>d<sub>v</sub></i>.  In other words, of the shortest paths to each vertex that we've found that we're not yet sure about, pick the one that is the shortest.</li>\n  <li>Set <i>k<sub>v</sub></i> to <b>true</b> for the vertex you picked in step 1.  The shortest of the \"unknown\" paths is now considered to be known.</li>\n  <li>For each vertex <i>w</i> adjacent to <i>v</i> (i.e., there is an edge from <i>v</i> to <i>w</i>) for which <i>k<sub>w</sub></i> is <b>false</b>, test whether <i>d<sub>w</sub></i> is greater than <i>d<sub>v</sub></i> + <i>C</i>(<i>v</i>, <i>w</i>).  If it is, set <i>d<sub>w</sub></i> to <i>d<sub>v</sub></i> + <i>C</i>(<i>v</i>, <i>w</i>) and set <i>p<sub>w</sub></i> to <i>v</i>.  In other words, if the path through <i>v</i> to <i>w</i> is better than the shortest path we'd found to <i>w</i> so far, the shortest path to <i>w</i> (so far) is the path we've just found through <i>v</i> to <i>w</i>.</li>\n</ol>\n\n<p>For each pass, exactly one vertex has its <i>k<sub>v</sub></i> set to <b>true</b> (in other words, we discover one known shortest path per pass).</p>\n\n<p>Here is psuedocode for the algorithm.  Notice the use of a priority queue, which allows you to efficiently find the vertex with the smallest <i>d<sub>v</sub></i> in step 1.</p>\n\n<pre>\n    for each vertex v\n    {\n        set k<sub>v</sub> to false\n        set p<sub>v</sub> to unknown (or none, if v is the start vertex)\n        set d<sub>v</sub> to &infin; (or 0, if v is the start vertex)\n    }\n\n    let pq be an empty priority queue\n    enqueue the start vertex into pq with priority 0\n    \n    while (pq is not empty)\n    {\n        vertex v = the vertex in pq with the smallest priority\n        \n        if (k<sub>v</sub> is false)\n        {\n            k<sub>v</sub> = true\n\n            for each vertex w such that edge v &rarr; w exists\n            {\n                if (d<sub>w</sub> &gt; d<sub>v</sub> + C(v, w))\n                {\n                    d<sub>w</sub> = d<sub>v</sub> + C(v, w)\n                    p<sub>w</sub> = v\n                    enqueue w into pq with priority d<sub>w</sub>\n                }\n            }\n        }\n    }\n</pre>\n\n<p>At the conclusion of the main loop, the <i>d<sub>v</sub></i> value corresponding to the end vertex will be the amount of the shortest path.  You can find the actual path of vertices by working your way backward from the end vertex to the start vertex, following the <i>p<sub>v</sub></i> values as you go along.  (This implies, of course, that you need to store all the <i>p<sub>v</sub></i> values.)</p>\n\n<p>Remember that, after the algorithm has finished, you should store the results in memory so that you can look them up later.  I suggest storing the <i>p<sub>v</sub></i> values long-term.  There's no reason to store the <i>k<sub>v</sub></i> values, because they will all be <b>true</b> after the algorithm is completed.  And there's no need to store the <i>d<sub>v</sub></i> values, because you will need to lookup the times or distances between each vertex in the path anyway, since we always output all of the segments of a trip, and you can easily sum these up to calculate a total while you're generating your answer.</p>\n\n<p>As you can see from the pseudocode, you will need to implement a priority queue in order to implement Dijkstra's Algorithm.  You are required to implement it using a binary heap, as we discussed in class, so that all enqueues and dequeues run in <i>O</i>(log <i>n</i>) time.  The priority queue should be implemented in its own class, of course.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">The output</p>\n\n<p>For each of the trip requests in the input file, your program should output a neatly-formatted report to the console that includes each leg of the trip with its distance and/or time (as appropriate), and the total distance and/or time for the trip.</p>\n\n<p>If the trip request asks for the shortest distance, the output might look something like the following.  (These are phony trips, to show you the output format; they are not related to the sample data file provided above.)</p>\n\n<pre>\nShortest distance from Alton & Jamboree to MacArthur & Main\n  Begin at Alton & Jamboree\n  Continue to Main & Jamboree (1.1 miles)\n  Continue to Jamboree & I-405N on ramp (0.3 miles)\n  Continue to I-405N @ MacArthur (1.3 miles)\n  Continue to MacArthur & I-405N off ramp (0.1 miles)\n  Continue to MacArthur & Main (0.2 miles)\nTotal distance: 3.0 miles\n</pre>\n\n<p>On the other hand, if the trip request asks for the shortest time, the output might look like this:</p>\n\n<pre>\nShortest driving time from Alton & Jamboree to MacArthur & Main\n  Begin at Alton & Jamboree\n  Continue to Alton & MacArthur (2.7 miles @ 33.7mph = 4 mins 48.8 secs)\n  Continue to Main & MacArthur (1.1 miles @ 40.1mph = 1 min 38.7 secs)\nTotal time: 6 mins 27.5 secs\n</pre>\n\n<p>When outputting a time, you should separate it into its components &mdash; hours, minutes, and seconds &mdash; as appropriate.  Here are some examples:</p>\n\n<pre>\n32.5 secs\n2 mins 27.8 secs\n13 mins 0.0 secs\n3 hrs 13 mins 12.3 secs\n6 hrs 0 mins 0.0 secs\n</pre>\n\n<p>Don't show hours if there are zero of them.  Don't show hours or minutes if there are zero of both of them.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Starting point</p>\n\n<p>You're required to write the code for this project from scratch.  No code is provided.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Deliverables</p>\n\n<p>You must turn in all of your <b>.java</b> files.  Please do not include any <b>.class</b> files, or other files generated by your development environment.</p>\n\n<p>Follow <a href=\"../SubmittingProjects.html\">this link</a> for an explanation of how to turn in your project.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Limitations</p>\n\n<p>Except for <b>java.util.ArrayList</b>, you may not use any of the collection classes in the <b>java.util</b> library (e.g., LinkedList, TreeMap, HashMap, PriorityQueue).  Remember, as always, you are to implement your own data structures.  You're free, and encouraged, to use other utility classes, such as Scanner and FileReader to read the input file.</p>\n\n</div>\n\n<div class=\"history\">\n\n<hr />\n\n<ul class=\"nomarker\">\n  <li>Typos corrected, some wording adjusted, and additional requirement of detecting disconnected graphics added by Alex Thornton, Summer 2012.</li>\n  <li>A few more minor rewrites and corrections by Alex Thornton, Summer 2005.</li>\n  <li>A few typos corrected, along with a small amount of additional explanation about Dijkstra's Algorithm added by Alex Thornton, Summer 2004.</li>\n  <li>Additional modifications and clarifications by Alex Thornton, Spring 2003.</li>\n  <li>Revised again by Alex Thornton, Fall 2002.</li>\n  <li>Minor revisions by Norman Jacobson, December 2001, March 2002, May 2002, and June 2002.</li>\n  <li>Revised for ICS 23 Fall 2001 by Norman Jacobson, September 2001.</li>\n  <li>Originally written by Alex Thornton, Spring 2001.  Portions of the description of Dijkstra's algorithm based on a description in <i>Data Structures and Algorithms with Object-Oriented Design Patterns in Java</i> by Bruno R. Preiss.</li>\n</ul>\n\n</div>\n\n</body>\n</html>\n", "encoding": "ascii"}