{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/Namedtuples/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Python Background Notes: Namedtuples</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Python Background Notes: Namedtuples</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The limitations of tuples</p>\r\n\r\n<p>Tuples can have a fair number of uses in Python, because they provide the ability to bring together multiple objects within a single one, in cases where you know at the time you're writing your program how many objects there will be.  A simple example would be an object representing a point in three-dimensional space, which you might store in a tuple, with the first element representing the <i>x</i>-coordinate, the second element representing the <i>y</i>-coordinate, and the third element representing the <i>z</i>-coordinate.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>point = (2, 5, -1)</b>\r\n</pre></blockquote>\r\n\r\n<p>All three coordinates making up a point are now stored in the variable <b>point</b>.  The point could be passed as a single argument to a function, assigned to another single variable, and so on.</p>\r\n\r\n<p>On the other hand, actually using these coordinates requires one of two techniques, neither of which is quite perfect.  One technique is to index into the tuple, but this requires us to remember that the <i>x</i>-coordinate is stored in index 0, the <i>y</i>-coordinate is stored in index 1, and the <i>z</i>-coordinate is stored in index 2.  And not only do we have to remember that when we're first writing our code, but we have to keep summoning that detail into our mind later every time we read that code in the future.  For example, we could calculate the distance from the origin to the point by taking the square root of the squares of its coordinates.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>distance = math.sqrt(point[0] * point[0] + point[1] * point[1] + point[2] * point[2])</b>\r\n</pre></blockquote>\r\n\r\n<p>But this is kind of an unfortunate bit of syntax; it doesn't look, at a glance, like what it is.  The meaning is lost in a sea of <b>point[0]</b>, <b>point[2]</b>; it's obscured by what would be better left as irrelevant detail.</p>\r\n\r\n<p>An alternative is to use sequence assignment to name the coordinates first, by storing them in separate variables; we could then use those separate variables in our calculation instead.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>x, y, z = point</b>\r\n&gt;&gt;&gt; <b>distance = math.sqrt(x * x + y * y + z * z)</b>\r\n</pre></blockquote>\r\n\r\n<p>This is better, but becomes unfortunate if we have to do this in many different places.  For example, if we wanted to write ten different functions that accepted points as parameters, we might start all ten of those functions with the same statement that sequence-assigns the point's elements into the variables <b>x</b>, <b>y</b>, and <b>z</b>.  That would be unfortunate, in its own right; we should want to avoid boring, repetitive work when we write programs, because this can be a source of bugs.  (The less we have to think about the code we're writing, the more likely our minds will wander and we'll find ourselves making careless mistakes.)</p>\r\n\r\n<p>What would be useful is a tuple that's smarter about naming, one where its elements actually have names intrinsically &mdash; and whose names are actually known by the tuple.  Then, if we ever wanted an element with a particular name, we could just ask for it, and the tuple would know which one to give us back.</p>\r\n\r\n<p>As it turns out, tuples can't do this in Python, but there is a variant called a namedtuple that can.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What is a namedtuple?</p>\r\n\r\n<p>A <i>namedtuple</i> is a tuple in which each element is explicitly given a name.  Like tuples, a namedtuple has a particular number of elements stored within it at the time it's created.  Also like tuples, the number of elements never changes after that; once it's created, it is what it is.  The only real difference is that each element has a name and, because of that, the elements can be referred to by their names instead of their indices.</p>\r\n\r\n<p>Creating a namedtuple is a two-step process:</p>\r\n\r\n<ul>\r\n  <li>First, we have to create a \"blueprint\" for it, a new type that defines the set of <i>fields</i> that our new type of namedtuple will have.  (The fields of a namedtuple are analogous to the elements of a tuple.)</li>\r\n  <li>Then, we can create an object of our new type from that blueprint.  Every object of our new type will have the same collection of fields that have the same names; the only difference will be their values.</li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Defining a new namedtuple type</p>\r\n\r\n<p>Technically, namedtuples are not part of the Python language; they're actually part of the Python standard library.  So if we want to define a new namedtuple type, we'll first need to import something from the Python standard library that lets us create one.  What we need is a function called <b>namedtuple()</b>, which we'll find in a module called <b>collections</b>.  The meaning of the name <b>namedtuple</b> is self-evident enough that it's probably no better to say <b>collections.namedtuple</b>, so we can use <b>from..import</b> to import it.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>from collections import namedtuple</b>\r\n</pre></blockquote>\r\n\r\n<p>Having imported the <b>namedtuple()</b> function, we can call it by passing it two arguments: the name of our new type and a list containing the names of its fields.  We'll also need to store that type in a variable, so we can refer to it later.  By convention, we'll always want to store it in a variable whose name is the same as the name of our new type; things will get confusing if we do something different.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>Point = namedtuple('Point', ['x', 'y', 'z'])</b>\r\n</pre></blockquote>\r\n\r\n<p>Note, too, that the convention for naming new types in Python is to capitalize its first letter.  Furthermore, if the type is described by a name that contains multiple words, we also run those words together without underscores and capitalize the first letter of each of them, so we would choose names like <b>BasketballPlayer</b> or <b>AutomaticPurchaseStrategy</b>, rather than <b>basketball_player</b> or <b>automatic_purchase_strategy</b>.</p>\r\n\r\n<p>So, what did we get when we did this?  What is stored in the variable <b>Point</b>?  Let's take a look.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>Point</b>\r\n&lt;class '__main_.Point'&gt;\r\n&gt;&gt;&gt; <b>type(Point)</b>\r\n&lt;class 'type'&gt;\r\n</pre></blockquote>\r\n\r\n<p><b>Point</b> is a type, separate from the built-in ones like <b>str</b>, <b>int</b>, or <b>list</b>.  It's a wholly separate, new type that represents points in three-dimensional space.  From that type, we can create as many objects as we'd like.</p>\r\n\r\n<p class=\"subtitle\">Creating an object of a namedtuple type</p>\r\n\r\n<p>We've seen previously that you can create an object of a type by using the name of the type like a function &mdash; following the name of the type with parentheses and, optionally, passing it arguments.  This is sometimes called <i>construction</i>; we're building an object of that type.  We've seen multiple examples of that technique already.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>int('35')</b>\r\n35\r\n&gt;&gt;&gt; <b>str(5.5)</b>\r\n'5.5'\r\n&gt;&gt;&gt; <b>import socket</b>\r\n&gt;&gt;&gt; <b>s = socket.socket()</b>\r\n</pre></blockquote>\r\n\r\n<p>If <b>Point</b> is a type, it stands to reason that we should be able to do the same thing and, indeed, we can.  The arguments we would pass to its constructor are the values of the fields, which we can do in one of two ways:</p>\r\n\r\n<ul>\r\n  <li>By passing the correct number of arguments, in which case the arguments fill in the fields' values in the order the fields were defined when we created the namedtuple type.</li>\r\n  <li>By passing keyword arguments, we can specify the names of the fields directly in the call to our constructor, which can read more cleanly.</li>\r\n</ul>\r\n\r\n<p>The following three assignments involve the creation of equivalent points, whose <i>x</i>-coordinates are 3, whose <i>y</i>-coordinates are 5, and whose <i>z</i>-coordinates are 7.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p1 = Point(3, 5, 7)</b>\r\n&gt;&gt;&gt; <b>p2 = Point(x = 3, y = 5, z = 7)</b>\r\n&gt;&gt;&gt; <b>p3 = Point(z = 7, x = 3, y = 5)</b>\r\n</pre></blockquote>\r\n\r\n<p>Regardless of whether you include names on the arguments, all of the fields must be given a value when you create an object of a namedtuple type; failing to do so leads to a <b>TypeError</b>.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p4 = Point(5, 8)</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#11&gt;\", line 1, in &lt;module&gt;\r\n    p4 = Point(5, 8)\r\nTypeError: __new__() missing 1 required positional argument: 'z'\r\n&gt;&gt;&gt; <b>p4 = Point(x = 5, y = 8)</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt;\r\n    p4 = Point(x = 5, y = 8)\r\nTypeError: __new__() missing 1 required positional argument: 'z'\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Accessing the fields of a namedtuple</p>\r\n\r\n<p>Once you've created an object of a namedtuple type, accessing its fields is simply a matter of following the object with a \"dot\", then following that with the name of one of its fields.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p1.x</b>\r\n3\r\n&gt;&gt;&gt; <b>p2.y</b>\r\n5\r\n</pre></blockquote>\r\n\r\n<p>This leads to a surprisingly clear way to write a function to determine the distance from the origin to a given <b>Point</b>.</p>\r\n\r\n<blockquote><pre>\r\ndef distance_from_origin(p: Point) -> float:\r\n    return math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z)\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Replacing fields in a namedtuple</p>\r\n\r\n<p>It's important to realize that namedtuples are <i>immutable</i>, just like tuples are; once they're constructed, the values they have are the values they'll always have.  However, it is possible to construct a new namedtuple with some of the fields having their values remain and others being replaced, by calling the <b>_replace</b> method on an existing namedtuple.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>p4 = p1._replace(y = 9, x = 14)</b>\r\n&gt;&gt;&gt; <b>p4.x</b>\r\n14\r\n&gt;&gt;&gt; <b>p4.y</b>\r\n9\r\n&gt;&gt;&gt; <b>p4.z</b>\r\n7\r\n&gt;&gt;&gt; <b>p1.x</b>\r\n3\r\n&gt;&gt;&gt; <b>p1.y</b>\r\n5\r\n&gt;&gt;&gt; <b>p1.z</b>\r\n7\r\n</pre></blockquote>\r\n\r\n<p>There are a couple of important things to note in the example above.</p>\r\n\r\n<ul>\r\n  <li>The name <b>_replace</b> is actually somewhat misleading, because nothing in the original namedtuple is actually replaced.  What <b>p1._replace(...)</b> does is create a new namedtuple that is similar to <b>p1</b>, but it doesn't modify <b>p1</b> at all.  (Namedtuples are immutable; they can't be modified in this way.)</li>\r\n  <li>Another reason why the name <b>_replace</b> is misleading is because it begins with an underscore.  We've seen that previously as a way of noting a name that's considered private, though that's not what's going on here; the underscore here is used mainly to differentiate the name of the <b>_replace</b> method from the names of any of the fields in a namedtuple &mdash; as a way to accommodate the possibility of having a field named <b>replace</b>.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}