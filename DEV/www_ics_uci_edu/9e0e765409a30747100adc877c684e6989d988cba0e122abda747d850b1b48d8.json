{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/sets/sets.txt", "content": "\t\t\t\tSets and Frozen Sets\r\n\r\n\r\nHere are the bare bones. I will demonstrate sets in class, including some\r\nscripts and functions we can write using sets (and to a lesser extent\r\nfrozensets). The reality of understanding sets/frozensets understanding the\r\nbasic operations we can perform on them.\r\n\r\nSets are mostly like lists (but share two properties with dictionaries: see\r\n2-3), but with three differences\r\n\r\n  (1) Sets do not contain duplicates; if we add a valute that already is in a\r\n        set, the set remains unchanged; this means we can often add a value to\r\n        a set without first checking if it is in the set: if it isn't in the\r\n        set, it is added; if it is in the set, the set remains unchanged.\r\n\r\n  (2) Sets are unordered: we cannot index different values, and when we iterate\r\n        through them the order of the values produced is not fixed\r\n        (like dictionaries)\r\n\r\n  (3) All values in sets (like keys in dictionaries) must be immutable. So we\r\n       can have sets of tuples, but not sets of lists\r\n\r\nThere are also a large number of operators/methods that take sets as arguments\r\nand produce sets as results (discussed below).\r\n\r\nFrozensets are like immutatable sets: they have the two big properties listed\r\nabove, but their methods are restricted to those that do not mutate the\r\nfrozenset. So frozensets are to sets like tuples are to lists. As with tuples,\r\nwe can use frozensets as keys to dictionaries because frozensets are immutable.\r\n\r\nSets have literals: a positive number of values (1 or more) separated by\r\ncommas, all in braces. So, these literals are like dicts, but there is no colon\r\nbetween key:value pairs (which is how Python tells the difference between a\r\ndict and a set.\r\n\r\nBut there is one problem Python cannot tell whether {} is an empty dict or an\r\nempty set. That is why the rule above says \"1 or more\"; we write empty\r\ndictionaries as {}; we must write empty sets as set().\r\n\r\nSo \r\n\r\na = set() is the empty set (no/0 values)\r\n\r\nb = {'a', b', 'c'} is a set of str\r\n\r\nc = {('ICS-31','MATH-2A','ICS-6B'), ('ICS-31','BIO-9','ICS-6D')}\r\n    is a set of tuples\r\n\r\nNote that if we write the set {[]} Python raises:\r\n\r\n  TypeError: unhashable type: 'list'\r\n\r\nBecause list are mutable and we cannot have mutable values as keys in\r\ndictionaries or as values in sets. I would prefer is say\r\n\r\n TypeError: mutable type: 'list'\r\n\r\nbut it doesn't; instead it says unhashable. Hashable means immutable, so\r\nunhashable means-un immutable, which means mutatable.\r\n\r\n\r\nSet operations:\r\n\r\n(1) len: we can compute the length of a set (# of values at the top-level)\r\n    len(a) is 0; len(b) is 3 len(c) is 2.\r\n\r\n(2) No Indexing: the values in sets are unordered so it makes no sense to try\r\n      to index them\r\n\r\n(3) No Slicing (likewise)\r\n\r\n(4) Checking containment: the in/not in operators\r\n    These operators work on the values in a set\r\n    'a' in a is False; 'a' in b is True; 'ICS-31' in c is False, but\r\n    ('ICS-31','MATH-2A','ICS-6B') in c is True; note that\r\n    ('ICS-6B','MATH-2A','ICS-31') in c is False, because for two tuples to be\r\n    considered the same, their values must be in the same order\r\n\r\n(5) No Catenation\r\n\r\n(6) No Multiplication\r\n\r\n(7) Iterability: for i in b:  produces all the top-level values in a\r\n       (there are len(a) of them):\r\n    for i in b:\r\n        print(i,end='')\r\n    prints: abc\r\n\r\n    Note that we can write iter(aset) for use in while loops, to eventually\r\n    produce all the values stored in aset.\r\n\r\n    Note that the functions max and sum work on lists, tuples, sets, and\r\n    frozensets (and on adict.keys() and adict.values()) -so long as the values\r\n    are numeric. We will write our own functions that will take arguments that\r\n    are any iterable type of data, and thus work for all these different types\r\n    of data.\r\n\r\n    In fact, the constructors for all these types take arguments that are\r\n    iterable. We have seen how to construct a list from a tuple and a tuple from\r\n    a list. We can also construct list from sets and sets from lists, by writing\r\n\r\n    aset  = set(alist)  # len(aset) <= len(alist): aset has no duplicated values\r\n    alist = list(aset)  # len(alist) == len(aset): it has no duplicated values\r\n                        # b  ecause aset has no duplicated valuesl\r\n\r\n    Note set('abc') constructs the set {'a','b','c'} because strings are\r\n    iterable; of course if we print that set the values can appear in any\r\n    order.\r\n\r\n(8) There are a variety of set operations (from mathematics) that appear in\r\n    Python in both a method and operator form. There are mutation versions of\r\n    these operators as well (much like + from mathematics and += in Python).\r\n\r\n    aset1 == aset2       # set equality\r\n    aset1 != aset2       # set inequality\r\n\r\n    two sets are equal if they have exactly the same values, otherwise they\r\n    are not equal: {1,2,3} == {3,2,1} is True because order in sets makes no\r\n    difference (unlike strings, lists, and tuples; but like dictionaries).\r\n\r\n    Note that sets are never equal to lists. For two objects to be == they must\r\n    be the same data-type (two lists, two tuples, two dicts, two sets) and store\r\n    the same values.\r\n\r\n    aset1.isdisjoint(aset2)             : do these sets have no common values\r\n\r\n    aset1.issubset(aset2)               : every value in aset1 is also in aset2\r\n    aset1 <= aset2                      \r\n\r\n    aset1 < aset2                       : aset1 <= aset2 and aset1 != asets2\r\n\r\n    aset1.issuperset(aset2)             : every value in aset2 is also in aset1\r\n    aset1>=aset2                        \r\n\r\n    sometimes if aset1 <= aset2 we say that aset1 is contained in aset2, and if\r\n      aset1 >= aset2 we say that aset2 is contained in aset1\r\n\r\n    aset1.union(aset2, ..., asetn)\r\n    aset1 | aset2 | ... | asetn\r\n      produces a new set with the union of all the sets: the new set has one\r\n      of every value in the other sets: {1,2} | {2,3,4} | {1,3,6} is {1,2,3,4,6}\r\n      so unions construct new sets whose length are bigger\r\n\r\n    aset1.intersection(aset2, ..., asetn)\r\n    aset1 & aset2 & ... & asetn\r\n      produces a new set with the intersection of all the sets: the new set has\r\n      only values that are in every other set: {1,2} | {2,3,4} | {1,3,6} is {1}\r\n      so intersections construct new sets whose length are smaller\r\n\r\n    aset1.difference(aset2, ..., asetn)\r\n    aset1 - aset2 - ... - asetn\r\n      produces a new set with the difference between aset1 and all the other\r\n      sets: the new set has all the values that are in aset1 but not in any of\r\n      the other sets: {1,2,3,4,5,6} - {2,4} - {4,5} is {1,3,6}; so differences\r\n      construct new sets smaller than the first\r\n\r\n    aset1.symmetric_difference(aset2)\r\n    aset1 ^ set2\r\n      produces a new set with the values in one set but not the other:\r\n      {0,2,4,5,6} ^ {1,3,5,6} is {0,1,2,3,4}; so symmetic_differences produce\r\n      sets smaller than each argument/operand. Symmetric difference produces\r\n      all values not in the intersection: note {0,2,4,5,6} & {1,3,5,6} is\r\n      {5,6} and the symmetric difference is all avalues in the set, except\r\n      these. We can define a^b as (a|b) - (a&b).\r\n\r\n  There is one big difference between methods and operators: the operators\r\n  require sets for both operands, but the methods allow any iterables for\r\n  their arguments. So we CANNOT write {1,2,3} | [2,3,4], but we CAN write\r\n  {1,2,3}.union([2,3,4,2]): Python turns the list [2,3,4,2] into a set {2,3,4}\r\n  and then performs the union operation, which constructs the new set {1,2,3,4}.\r\n  \r\n\r\nSet (mutation) operations\r\n\r\n(a) aset.add(value): add value to set: does nothing if value is already in aset\r\n    Adding to a set is fundamental, like appending to a list.\r\n    Remember that we \"append\" to a list but \"add\" to a set.\r\n\r\n    Suppose x = {1,2,3}\r\n    After aset.add(2), the set is unchanged\r\n    After aset.add('x'), the set is {1,2,3,'x'} (iterated in any order)\r\n\r\n    aset.remove(value) : remove value from aset: if not in aset raise KeyError\r\n    aset.discard(value): remove value from aset: if not in aset do nothing\r\n    aset.pop()         : remove random value from aset: if empty raise KeyError\r\n    aset.clear()       : remove all values from aset: make it empty\r\n   \r\n(b) These update operations for sets are similar to update operations for\r\n    numeric values: aset1 |= aset2 is like a += b; the former translates into\r\n    aset1 = aset1 | aset 2 and the latter into a = a + b.\r\n\r\n    aset1.update(aset2,...asetn)\r\n    aset1 |= aset2 | ... | asetn\r\n    mutates aset1 to include all the values found in aset1 and any other set\r\n\r\n    aset1.intersection_update(aset2,...asetn)\r\n    aset1 &= aset2 & ... & asetn\r\n    mutates aset1 to include only the values found in aset1 and every other set\r\n\r\n    aset1.difference_update(aset2,...asetn)\r\n    aset1 -= aset2 - ... - asetn\r\n    mutates aset1 to include only the values found aset1 and no other sets\r\n\r\n    aset1.symmetric_difference_update(aset2)\r\n    aset1 ^= aset2\r\n    mutates aset1 to include only the values found aset1 or aset2 but not both\r\n\r\n\r\nFrozensets are very similar to sets, but we cannot use any of the muation\r\nmethods or operators. The constructor is named frozenset: frozenset() constructs\r\nan empty frozenset.\r\n\r\nWe can use this constructor to convert back and forth easily bewteen sets and\r\nfrozensets: frozenset(aset) constructs a frozenset with all the values in aset\r\nand set(afrozenset) constructs a set with all the values in afrozenset.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nComprehensions\r\n\r\nAs with lists/tuples, we can build sets/frozensets via comprehensions as\r\n\r\ns  = {comprehension}\r\nfs = frozenset({comprehension}) which constructs a frozenset from a set as above\r\n\r\nSo, to create a set of words (no duplicates), split (by spaces) from a string,\r\nwe could write\r\n\r\nwords = {s for s in 'to be or not to be that is the question'.split(' ')}\r\n\r\nhere words is now {'to', 'be', 'or', 'not', 'that', 'is', 'the', 'question'}\r\n\r\nIf we wanted only the words of 3 or fewer characters, we could include the\r\noption and write:\r\n\r\nwords={s for s in 'to be or not to be that is the question'.split(' ') if len(s)<=3}\r\n\r\nhere words is now {'to', 'be', 'or', 'not', 'is', 'the'}\r\n\r\nGenerally, we can translate a set comprehension as follows.\r\n\r\n  comprehension = set()\r\n  for i in iterable:\r\n      if bool_expression-i:\r\n          comprehension.add(i)\r\n\r\nNotice that we don't need to write\r\n\r\n      if bool_expression-i and not i in comprehension:\r\n          comprehension.add(i)\r\n\r\nbecause the add method automatically does the right thing. We shouldn't write\r\nsuch redundant checks. What add does is do that check first anyway, so if write\r\nsuch a check Python is doing it twice\r\n\r\n------------------------------------------------------------------------------\r\n\r\nA Quick use of Sets\r\n\r\nRecall that we discussed the following reverse method in the previous lecture. \r\n\r\ndef reverse(adict):\r\n    answer = {}\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            answer.setdefault(v,[]).append(k)\r\n    return answer\r\n\r\nBut one problem with it was that the answer dictionary could contain duplicate\r\nvalues in the list associated with its keys. We solved the problem by writing\r\ncode to not append the value to the list if it was already there.\r\n\r\ndef reverse_distinct(adict):\r\n    answer = {}\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            where = answer.setdefault(v,[])\r\n            if k not in where:\r\n                where.append(k)\r\n    return answer\r\n\r\nBut really, we should have chosen sets to use as the values in the answer\r\ndictionary. When using sets, there is a much easier solution:\r\n\r\ndef reverse_distinct(adict):\r\n    answer = {}\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            answer.setdefault(v,set()).add(k)\r\n    return answer\r\n\r\nNotice that the only change was to the line (in the original reverse_distinct)\r\n\r\n  answer.setdefault(v,set()).add(k)\r\n\r\nHere we set the default (if v is not in aswer) to be the empty set (which recall\r\nwe must write as set(), not {} which is an empty dictionary). Also we must\r\nsubstitute add (the method for adding a value to a set) for append (the method\r\nfor appending a value to a list)\r\n\r\nWhen printed (with print_dict), the answer looks as follows\r\n\r\n  AZ -> {'alex'}\r\n  CA -> {'rich', 'alex', 'ellen', 'mark'}\r\n  IL -> {'rich'}\r\n  IN -> {'mark'}\r\n  NY -> {'alex', 'david'}\r\n  OR -> {'ellen', 'patty'}\r\n  PA -> {'david', 'alex', 'rich', 'ellen', 'mark', 'patty'}\r\n  RI -> {'david'}\r\n  WA -> {'david', 'alex', 'rich', 'ellen', 'mark', 'patty'}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDefault Dictionaries: A new kind of dictionary that is often simpler to use\r\n\r\nThere is a special kind of dictionary, called a defaultdict, that makes the\r\ncode above even simpler. It also makes the code for count simpler. Let's take a\r\nquick look at defaultdict and how to simplify the code for these two\r\ndictionaries.\r\n\r\nFirst, we must import it from the collections module: typically by\r\n\r\n  from collections import defaultdict\r\n\r\nFinally (that was short!) when we define a defaultdict we specify an argument\r\nthat is often just the name of the type to construct an object from if we look\r\nup a key that is not in the defaultdict: that is, when we define a defaultdict\r\nwe specify what default value to use when a new key is used with a dictionary.\r\n\r\nOther than that, we use a defaultdict just like a dict (although it will print\r\na bit differently). With this new kind of dictionary (and I use it a lot) the\r\nabove code simplifies to\r\n\r\ndef reverse_distinct(adict):\r\n    answer = defaultdict(set)\t\t# key not in answer? use/put a set() in\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            answer[v].add(k)\t\t# add it to current set, or a new one\r\n    return answer\r\n\r\nHere, each time we lookup value v in the answer defaultdict (answer[v]), if it\r\nis not there it assocates this value with an empty set (set()) and then adds\r\nk to that empty set.\r\n\r\nLikewise, we can simplify the count function to\r\n\r\ndef count(alist):\r\n    answer = defaultdict(int)\t\t# key not in answer? use/put a int()/0\r\n    for v in alist:\r\n        answer[v] += 1\t\t\t# increment current value, or 0\r\n    return answer\r\n\r\nNote that int() returns a reference to the 0 int object (how convenient).\r\nHere, each time we lookup value v in the answer defaultdict (answer[v]), if it\r\nis not there it assocates this value with the value 0 (int()) and then\r\nincrements that value to 1.\r\n\r\nOften when we build dictionaries, it is easier to use a defaultdict; but it is\r\nnot much harder to specify a dict and use a setdefault method for it, or even\r\nuse an if instead. Recall our original definition of cout was\r\n\r\ndef count(alist):\r\n    answer = {}\r\n    for v in alist:\r\n        if v in alist:\t\t\t# Check if key v is in dictionary\r\n            answer[v] += 1\t\t#   Yes, increment its asscoated value\r\n        else:\t      \t \t\t#   No,\r\n            answer[v] = 1\t\t#     set its value to 1\r\n    return answer\r\n\r\nor\r\n\r\ndef count(alist):\r\n    answer = {}\r\n    for v in alist:\r\n        if v not in alist:\t\t# Check if key v is NOT in dictionary\r\n            answer[v] = 0\t\t#   Not present set its value to 0\r\n        answer[v] += 1\t        \t# Increment it associated value, which\r\n\t\t     \t\t\t#   might be the 0 just put there\r\n    return answer\r\n\r\n\r\n\r\n\r\n\r\n", "encoding": "ascii"}