{"url": "https://www.ics.uci.edu/~dechter/courses/ics-275a/fall-99/slides/node225.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3O//DTD W3 HTML 2.0//EN\">\r\n<!Converted with LaTeX2HTML 95.1 (Fri Jan 20 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >\r\n<HEAD>\r\n<TITLE> Type Testing</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<meta name=\"description\" value=\" Type Testing\">\r\n<meta name=\"keywords\" value=\"umsroot\">\r\n<meta name=\"resource-type\" value=\"document\">\r\n<meta name=\"distribution\" value=\"global\">\r\n<P>\r\n <BR> <HR><A NAME=tex2html4958 HREF=\"node226.html\"><IMG ALIGN=BOTTOM ALT=\"next\" SRC=\"http://www.ecrc.de/eclipse/new_icons//next_motif.gif\"></A>   <A NAME=tex2html4956 HREF=\"node222.html\"><IMG ALIGN=BOTTOM ALT=\"up\" SRC=\"http://www.ecrc.de/eclipse/new_icons//up_motif.gif\"></A>   <A NAME=tex2html4950 HREF=\"node224.html\"><IMG ALIGN=BOTTOM ALT=\"previous\" SRC=\"http://www.ecrc.de/eclipse/new_icons//previous_motif.gif\"></A>      <A NAME=tex2html4960 HREF=\"node321.html\"><IMG ALIGN=BOTTOM ALT=\"index\" SRC=\"http://www.ecrc.de/eclipse/new_icons//index_motif.gif\"></A>   <BR>\r\n<B> Next:</B> <A NAME=tex2html4959 HREF=\"node226.html\"> Unification and Binding</A>\r\n<B>Up:</B> <A NAME=tex2html4957 HREF=\"node222.html\"> Interface to Externals</A>\r\n<B> Previous:</B> <A NAME=tex2html4951 HREF=\"node224.html\"> Exit</A>\r\n<BR> <HR> <P>\r\n<H2><A NAME=SECTION001943000000000000000> Type Testing</A></H2>\r\n<P>\r\nThe basic structure of an external predicate is almost always the same:\r\nfirst a check is made on the types of the arguments, and the predicate\r\neither fails or gives an error if the arguments are not of the expected\r\ntype. Then the operation of the predicate continues. <A NAME=tex2html762 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n  provides a\r\nset of macros which make this initial type checking easy.\r\nAll take a single <i> tag</i> as argument.\r\nThe macro <blockquote> <PRE>Error_If_Ref(tag);\r\n</PRE></blockquote>\r\n<A NAME=3421>&#160;</A>\r\nwill return control from\r\nthe external predicate with an instantiation fault if its argument\r\nis a free variable.\r\nThe <tt> Check_</tt> family of\r\n<A NAME=3423>&#160;</A>\r\nmacros, such as <blockquote> <PRE>Check_Atom(val);\r\n</PRE></blockquote>\r\nhave the same effect as <tt> Error_If_Ref</tt>, and\r\nadditionally return with a type error if the argument does not have the\r\ndesired type.\r\nThe only exception is <tt> Check_Ref</tt> which raises a type error if its\r\nargument is not a free variable.\r\nThe <tt> Check_Output</tt> macro family, e.g.\r\n<blockquote> <PRE>Check_Output_Integer(tag)\r\n</PRE></blockquote>\r\n<A NAME=3431>&#160;</A>\r\nprovide a way to test the type of arguments which may be either unbound\r\nor bound to a term of a certain type.\r\nThey issue a <i> type error</i> if their argument is not a variable\r\nand it has not the specified type.\r\n<P>\r\nAll the type testing macros mentioned in this section\r\ncan be applied to arguments of the external\r\npredicates as well as to other Prolog terms, e.g. to the arguments\r\nof compound terms.\r\nIn this case, however, their value has first to be <i> dereferenced</i>\r\nusing the <tt> Dereference</tt> macro.\r\nThe <blockquote> <PRE>Dereference(pw)\r\n</PRE></blockquote>\r\n<A NAME=3437>&#160;</A>\r\n<A NAME=3438>&#160;</A>\r\nmacro takes a pointer to Prolog word <tt> pw</tt> and dereferences it,\r\nso that it points to the real value of the term.\r\nThe arguments of an external predicate are dereferenced before\r\nthe external is called and so they need not be dereferenced explicitly\r\n(as is the case in some Prolog systems).\r\nOther Prolog terms must be always\r\ndereferenced before testing.\r\n<P>\r\nOther macros are available which simply test the type of a Prolog term,\r\nand do not return control from the external. These are the <tt> Is</tt>\r\n<A NAME=3441>&#160;</A>\r\nfamily, which evaluate to true\r\nif the tag is of the correct type, and to false\r\notherwise.\r\nThus <tt> IsString(tag)</tt> will return true if <i> tag</i> is of\r\ntype <tt> TSTRG</tt>, for instance; that is, if the Prolog term represented is\r\na string.\r\n<P>\r\nAnother useful type checking macro compares two Prolog terms.\r\n<blockquote> <PRE>SameType(tag1, tag2);\r\n</PRE></blockquote> is true if tag1 and tag2 are equal,\r\n<A NAME=3447>&#160;</A>\r\nfalse otherwise.\r\n<P>\r\nIf the Prolog term represented by a <i> tag</i> is a functor, the <i> value</i>\r\nis its DID (dictionary identifier) and it\r\n<A NAME=3450>&#160;</A>\r\ncan be used instead of some more complex structure in any\r\nplace where the atom or functor needs to be referred to.\r\nTwo macros are provided which take these identifiers as\r\narguments.\r\nThe macro <blockquote> <PRE>DidName(did);\r\n</PRE></blockquote> returns a pointer to a\r\n<A NAME=3453>&#160;</A>\r\nC string corresponding to the atom or functor (i.e. if the atom is\r\n<tt> program</tt> the string will be <tt> &quot;program&quot;</tt>).\r\n<A NAME=3456>&#160;</A>\r\nA pointer to a proper <A NAME=tex2html773 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n  string (as described for the TSTRG tag)\r\ncan be obtained from an atom using the similar macro <tt> DidString()</tt>.\r\nThe macro <blockquote> <PRE>DidArity(did);\r\n</PRE></blockquote>\r\n<A NAME=3460>&#160;</A>\r\nreturns the arity of the functor identified by <tt> did</tt>, and zero\r\nfor an atom.\r\nA DID can be obtained from the name and arity of a functor using\r\nthe macro\r\n<blockquote> <PRE>Did(Cstring, Arity)\r\n</PRE></blockquote>\r\n<A NAME=3464>&#160;</A>\r\nA DID has the C type <tt> word32</tt>.\r\nThe <tt> Did()</tt> macro either only returns the appropriate DID if this\r\nfunctor already exists in the system, or it creates the new functor\r\nand its DID.\r\nFor example, to obtain the DID of the functor <i> salary/3</i> use\r\n<blockquote> <PRE>word32     d_salary;\r\n..\r\nd_salary = Did(&quot;salary&quot;, 3);\r\n</PRE></blockquote>\r\n<P>\r\nThe macro\r\n<blockquote> <PRE>Get_Name(val, tag, name)\r\n</PRE></blockquote>\r\n<A NAME=3472>&#160;</A>\r\ncan be used to obtain the C string associated with an atom\r\nor a Prolog string and to issue an error if the type\r\nof the Prolog word is not atom or string.\r\nAfter its invocation, <i> name</i> points to the string.\r\n<P>\r\nFor the predicates that take the input of the form <i> Name/Arity</i>\r\nthe following macro is useful:\r\n<blockquote> <PRE>Get_Proc_Did(val, tag, did)\r\n</PRE></blockquote>\r\n<A NAME=3477>&#160;</A>\r\nif <i> val</i> and <i> tag</i> specify a compound term of the form <b> Name/Arity</b>,\r\n<tt> did</tt> is assigned to the DID of the corresponding functor\r\notherwise the corresponding error type is raised.\r\nThe arity is checked for being in the range for predicates (0 to\r\n<tt> max_predicate_arity</tt>), so this macro should be used when predicate\r\nspecifications are to be checked.\r\nThe macro\r\n<blockquote> <PRE>Get_Functor_Did(val, tag, did)\r\n</PRE></blockquote>\r\n<A NAME=3485>&#160;</A>\r\nis similar, but apart from a term <b> Name/Arity</b> it accepts as well\r\nan atom and returns its DID. As opposed to the previous one it does\r\nnot check for an arity limit since a limit exists only for predicates,\r\nnot for data structures.\r\n<P>\r\nWith the macros so far mentioned it is possible to write externals\r\nfor Prolog procedures which simply test the types of their arguments. A\r\nsimple example is the following, which tests if its two\r\narguments are successive integers. An instantiation fault occurs if\r\neither argument is uninstantiated, and a type error if either is not an\r\ninteger.\r\n<blockquote> <PRE>int\r\np_succ_ints(val1, tag1, val2, tag2)\r\nvalue val1, val2;\r\ntype  tag1, tag2;\r\n{\r\n\r\n        Check_Integer(tag1);\r\n        Check_Integer(tag2);\r\n\r\n        Succeed_If(val1.nint + 1 == val2.nint);\r\n}\r\n</PRE>\r\n</blockquote><BR> <HR><A NAME=tex2html4958 HREF=\"node226.html\"><IMG ALIGN=BOTTOM ALT=\"next\" SRC=\"http://www.ecrc.de/eclipse/new_icons//next_motif.gif\"></A>   <A NAME=tex2html4956 HREF=\"node222.html\"><IMG ALIGN=BOTTOM ALT=\"up\" SRC=\"http://www.ecrc.de/eclipse/new_icons//up_motif.gif\"></A>   <A NAME=tex2html4950 HREF=\"node224.html\"><IMG ALIGN=BOTTOM ALT=\"previous\" SRC=\"http://www.ecrc.de/eclipse/new_icons//previous_motif.gif\"></A>      <A NAME=tex2html4960 HREF=\"node321.html\"><IMG ALIGN=BOTTOM ALT=\"index\" SRC=\"http://www.ecrc.de/eclipse/new_icons//index_motif.gif\"></A>   <BR>\r\n<B> Next:</B> <A NAME=tex2html4959 HREF=\"node226.html\"> Unification and Binding</A>\r\n<B>Up:</B> <A NAME=tex2html4957 HREF=\"node222.html\"> Interface to Externals</A>\r\n<B> Previous:</B> <A NAME=tex2html4951 HREF=\"node224.html\"> Exit</A>\r\n<BR> <HR> <P>\r\n<BR> <HR>\r\n<P><ADDRESS>\r\n<I>Micha Meier <BR>\r\nMon Mar  4 12:11:45 MET 1996</I>\r\n</ADDRESS>\r\n</BODY>\r\n", "encoding": "ascii"}