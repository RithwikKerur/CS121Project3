{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/CollSpec023.txt", "content": "WEBDAV Working Group                                     J. Slein, Xerox\nINTERNET DRAFT                                           J. Davis, Xerox\n<draft-ietf-webdav-collection-protocol-02.3>          A. Babich, FileNet\n                                           E.J. Whitehead Jr., UC Irvine\n                                                        January 21, 1999\nExpires July 21, 1999\n\n\t\t\tWebDAV Advanced Collections Protocol\n\nStatus of this Memo\n\nThis document is an Internet-Draft. Internet-Drafts are working \ndocuments of the Internet Engineering Task Force (IETF), its areas, and \nits working groups. Note that other groups may also distribute working \ndocuments as Internet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months \nand may be updated, replaced, or made obsolete by other documents at any \ntime. It is inappropriate to use Internet-Drafts as reference material \nor to cite them other than as \"work in progress\".\n\nTo view the entire list of current Internet-Drafts, please check the \n\"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow \nDirectories on ftp.is.co.za (Africa), ftp.nordu.net (Northern Europe), \nftp.nis.garr.it (Southern Europe),munnari.oz.au (Pacific Rim), \nftp.ietf.org (US EastCoast), or ftp.isi.edu (US West Coast).\n\nDistribution of this document is unlimited. Please send comments to the \nDistributed Authoring and Versioning (WebDAV) working group at <w3c-\ndist-auth@w3.org>, which may be joined by sending a message with subject \n\"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\nDiscussions of the WEBDAV working group are archived at URL: \n<http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\nAbstract\n\nThe base WebDAV protocol [WebDAV] provides basic support for \ncollections.  It defines a MKCOL method for creating collections and \nspecifies how other HTTP and WebDAV methods interact with collections.  \nIt supports internal members of collections, which it defines as URIs \nthat are immediately relative to the URI of the collection.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: referential resources and ordering.\n\nThis draft specifies extensions to the base WebDAV protocol to support \nthese more powerful collections.\n\nTable of Contents\n\n1\tTerminology\t3\n2\tIntroduction\t4\n3\tReferential Resources\t5\n3.1\tScope\t5\n3.2\tOverview\t5\n\nSlein et al.                                                     Page 1\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n3.3\tCreating Referential Resources\t7\n3.3.1\tThe MKREF Method\t7\n3.3.2\tStatus Codes\t8\n3.3.3\tExample\t8\n3.4\tDeleting, Copying, and Moving Referential Resources\t9\n3.5\tListing Referential Members of a Collection\t9\n3.6\tLocking Referential Resources\t10\n3.7\tOther WebDAV Operations on Redirect Referential Resources\t11\n3.8\tOther WebDAV Operations on Direct Referential Resources\t12\n3.9\tHTTP Operations on Redirect Referential Resources\t12\n3.10\tHTTP Operations on Direct Referential Resources\t14\n3.11\tOperations on Targets of Referential Resources\t14\n3.12\tDiscovering a Target\u2019s References\t14\n3.13\tBehavior of Dangling Direct References\t15\n3.14\tSummary of Referencing Headers Required in Responses\t17\n4\tOrdered Collections\t17\n4.1\tOverview\t17\n4.2\tCreating an Ordered Collection\t17\n4.2.1\tOverview\t17\n4.2.2\tStatus Codes\t18\n4.2.3\tExample\t18\n4.3\tSetting the Position of a Collection Member\t18\n4.3.1\tOverview\t18\n4.3.2\tStatus Codes\t19\n4.3.3\tExamples\t19\n4.4\tChanging the Semantics of a Collection Ordering\t20\n4.5\tChanging the Position of a Collection Member\t20\n4.5.1\tThe ORDERPATCH Method\t20\n4.5.2\tStatus Codes\t20\n4.5.3\tExample\t20\n4.5.4\tDesign Rationale\t22\n5\tNew Headers\t22\n5.1\tRef-Target Entity Header\t22\n5.2\tRef-Type Entity Header\t22\n5.3\tRef-Integrity Request Header\t23\n5.4\tNo-Passthrough Request Header\t23\n5.5\tOrdered Entity Header\t24\n5.6\tPosition Request Header\t24\n6\tNew Properties\t24\n6.1\treftarget Property\t24\n6.2\trefintegrity Property\t25\n6.3\treftype Property\t25\n6.4\treferences Property\t25\n6.5\torderingtype Property\t25\n7\tNew XML Elements\t26\n7.1\treference XML Element\t26\n7.2\tdirect XML Element\t26\n7.3\tredirect XML Element\t26\n7.4\tweak XML Element\t26\n7.5\textension XML Element\t26\n7.6\tlocation XML Element\t27\n7.7\tunordered XML Element\t27\n7.8\tcustom XML Element\t27\n7.9\torder XML Element\t27\n7.10\tordermember XML Element\t28\n\nSlein et al.                                                     Page 2\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n7.11\tposition XML Element\t28\n7.12\tfirst XML Element\t28\n7.13\tlast XML Element\t28\n7.14\tbefore XML Element\t29\n7.15\tafter XML Element\t29\n8\tExtensions to the DAV:multistatus XML Element\t29\n9\tCapability Discovery\t29\n9.1\tUsing OPTIONS\t29\n9.2\tExample\t30\n10\tDependencies on Other Specifications\t30\n11\tSecurity Considerations\t30\n11.1\tRedirect Loops\t30\n11.2\tReferences and Denial of Service\t30\n11.3\tMaintaining Referential Integrity May Reveal Private Locations31\n11.4\tDAV:references and Denial of Service\t31\n11.5\tDAV:references and Malicious Deletion of Resources\t31\n11.6\tMalicious Modifications of Ordering\t31\n11.7\tDenial of Service and DAV:orderingtype\t31\n12\tInternationalization Considerations\t31\n13\tIANA Considerations\t32\n14\tCopyright\t32\n15\tIntellectual Property\t32\n16\tAcknowledgements\t32\n17\tReferences\t32\n18\tAuthors' Addresses\t33\n19\tAppendices\t33\n19.1\tAppendix 1 - Extensions to the WebDAV Document Type Definition33\n\n1 Terminology\n\nThe terminology used here follows and extends that in the base WebDAV \nprotocol specification [WebDAV].\n\nCollection\n  A resource that contains a set of URIs, termed member URIs, which \n  identify member resources\n\nMember URI\n  A URI which is a member of the set of URIs contained by a \n  collection\n\nReferential Resource (or Reference)\n  A resource that has no body of its own (though it does have \n  properties), but rather is a reference to another resource\n\nOrdinary Resource\n  A resource that is not a reference to another resource\n\nTarget Resource\n  The resource referenced by a referential resource\n\nDirect Reference\n  A reference that is resolved by the server without any client \n  action, giving the client the illusion that it is operating \n directly on the target resource\n\nSlein et al.                                                     Page 3\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\nRedirect Reference\n  A reference that requires client action before it can be resolved, \n  so that the client is aware that a reference is mediating between \n  it and the target resource\n\nStrong Reference\n  A reference whose referential integrity is enforced by the server\n\nWeak Reference\n  A reference whose referential integrity is not enforced by the \n  server\n\nReferential Integrity\n  The integrity of a reference is preserved as long as it points to \n  the same resource it pointed to when it was created.  Its \n  integrity may be destroyed if the target resource is moved without \n  updating the reference to reflect its new location, or if the \n  target resource is deleted.\n\n2 Introduction\n\nThe simple collections that the base WebDAV specification supports are \npowerful enough to be widely useful.  They provide for the hierarchical \norganization of resources, with mechanisms for creating and deleting \ncollections, copying and moving them, locking them, adding members to \nthem and removing members from them, and getting listings of their \nmembers.  Delete, copy, move, list, and lock operations can be applied \nrecursively, so that a client can operate on whole hierarchies with a \nsingle request.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: references and ordering.\n\nReferences make it possible for many collections, on the same or \ndifferent servers, to share the same resource.  Because the collections \nshare the resource by referencing it, only one physical copy of the \nresource need exist, and any changes made in the resource are visible \nfrom all the collections that reference it.\n\nIt is useful for many applications to be able to impose an ordering on a \ncollection. Orderings may be based on property values, but they may be \ncompletely independent of any properties on the resources identified by \nthe collection\u2019s member URIs.  Orderings based on properties can be \nobtained using a search protocol [DASL], but orderings not based on \nproperties need some other mechanism. \n\nSince these two areas are independent of each other, servers may elect \nto comply with the Referential Resources section of this specification \nor with the Ordered Collections section or both.  A server that supports \nreferencing MUST support redirect references, and MAY support direct \nreferences.  A server MUST advertise its compliance with particular \nparts of this specification through its response to an OPTIONS request, \nas specified in Section 9 below.\n\nSlein et al.                                                     Page 4\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\n3 Referential Resources\n\n3.1 Scope\n\n[WebDAVReq] distinguishes between \"weak\" references and \"strong\" \nreferences, and also between \"redirect\" references and \"direct\" \nreferences.  This specification supports weak references, direct \nreferences, and redirect references, and is designed so that it can be \nextended to support strong references in the future.\n\nStrong references are references whose integrity is enforced by the \nserver; weak references are those whose integrity is not enforced by the \nserver.  Strong references and weak references are both useful in \ndifferent contexts.  Some applications cannot tolerate broken links.  A \nsoftware development application, for example, must be able to rely on \nthe integrity of references to component modules. Such applications must \nbe able to request strong references.  Other applications may want to \nreference target resources on multiple servers, where referential \nintegrity cannot be enforced, and may be less concerned about possible \nbroken references.  \n\nSeveral considerations led to the decision not to support strong \nreferences in the current specification.  First, there are many possible \npolicies that applications and services might use to enforce referential \nintegrity.\n\no Delete strong references when their targets are deleted.\no Decline to delete targets of strong references.\no Notify strong references when their targets have been deleted.\no Let owners of resources decide whether strong references to them are \n  allowed.\n\nThere appears to be no common practice in this area.  Moreover, some of \nthe policies have significant security risks.\n\no Moving a target of strong references could be a security risk to the \n  owner of the target by revealing secret locations on the target's \n  server.\no A strong reference could be a security risk to the owner of the \n  reference by revealing secret locations on his server.\no The presence of strong references to resources on a server could make \n  it impossible to reclaim space on that server by moving or deleting \n  those target resources. \n\nThese considerations together led to the decision not to support strong \nreferences in the short term. \n\n3.2 Overview\n\nA referential resource is a resource that has no body of its own, but \ninstead references another resource.  The resource it references may \nhave a URI in the same collection as the reference, or in any other \ncollection.  This target resource may be a collection or a simple \nresource or another reference, or any other sort of resource that may be \n\nSlein et al.                                                     Page 5\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\ndefined in the future.  A resource may be the target of any number of \nreferential resources.  To make it possible to distinguish references \nfrom ordinary resources, a new value of the DAV:resourcetype property is \ndefined here.  The DAV:resourcetype property of all references MUST have \nthe value DAV:reference.  \n\nRedirect references are references that require action by the client \nbefore they can be resolved.  They are simple for servers to implement, \nstraightforward for clients to use, and have only limited security \nimplications.  Any server that complies with WebDAV referencing MUST \nprovide redirect references.\n\nIf the client is aware that it is operating on a redirect reference, it \ncan resolve the reference by retrieving the reference\u2019s DAV:reftarget \nproperty, whose value is the URI of the target resource.  It can then \nsubmit requests to the target resource.\n\nOtherwise, the client submits a request to the redirect reference.  For \nmost operations, the response is a 302 (Moved Temporarily), accompanied \nby the Ref-Type header with the value \"DAV:redirect\" and the Location \nheader with the URI of the target resource.  The client can then \nresubmit the request to the URI of the target resource.  A few \noperations, those that affect membership in a collection rather than the \nstate of the target resource, are exceptions to this general behavior.  \nAt present, the operations that fall into this category are DELETE, \nMOVE, and COPY.  These operations are applied to the reference itself \nand do not result in a 302 response.\n\nDirect references, in contrast, are resolved automatically by the \nserver.  They give the client the illusion that it is operating directly \non the target resource.  These references are more complex for the \nserver to implement, and raise additional security issues.  \nConsequently, servers are not required to provide direct references in \norder to be compliant with WebDAV referencing. \n\nThe default behavior of a direct reference is to apply most operations \ndirectly to its target, so that the client is not aware that a reference \nis mediating between it and the target resource.  The exceptions are \noperations that affect membership in a collection rather than the state \nof the target resource.  At present, the operations that fall into this \ncategory are DELETE, MOVE, and COPY.  These operations are applied to \nthe reference itself rather than to its target, so that only the \ncollection containing the reference is affected.\n\nThe No-Passthrough request header is also provided, to force an \noperation to be applied to the reference itself rather than its target.  \nIt can be used with most requests to direct or redirect references.  \nThis header is particularly useful with PROPFIND, to allow clients to \nview the reference\u2019s own properties.\n\nIdeally, non-referencing clients should be able to use both direct and \nredirect references.  This goal is more difficult to meet for redirect \nreferences, since client action is required to resolve them.  The \nstrategy of having redirect references respond to most requests with a \n302 (Moved Temporarily), accompanied by the URI of the target resource \n\nSlein et al.                                                     Page 6\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nin the Location header, fulfills this goal in most cases.  LOCK requests \nare the most significant exception, where we have been unable to support \nnon-referencing clients.\n\nTo distinguish between direct and redirect references, a new DAV:reftype \nproperty is defined, with the values DAV:direct and DAV:redirect.  Every \nreference MUST have the DAV:reftype property.  The DAV:reftype property \nof a direct reference MUST have the value DAV:direct.  The DAV:reftype \nproperty of a redirect reference MUST have the value DAV:redirect.\n\nEvery reference MUST have the DAV:reftarget property, whose value is the \nURI of the reference\u2019s target resource.\n\nAlthough strong references are not currently supported, a new \nDAV:refintegrity property is defined in anticipation of future support \nfor strong references.  DAV:refintegrity will allow clients to \ndistinguish between weak and strong references.  All references MUST \nhave this property.  Although the only currently defined for \nDAV:refintegrity is DAV:weak, other values may be defined in the future.\n\n3.3 Creating Referential Resources\n\n3.3.1 The MKREF Method\n\nReferential resources are created using the MKREF method.  The request-\nURI of the MKREF request identifies the resource to be created.  The \nrequired Ref-Target header contains the URI of the target resource.\n\nAn optional Ref-Integrity request header is defined below, primarily for \nfuture support for strong references.  The only value currently defined \nfor this header is \"DAV:do-not-enforce\", although other values may be \nused by private agreement.  The value \"DAV:do-not-enforce\" requires the \nserver not to enforce referential integrity for the reference being \ncreated.  If the Ref-Integrity header is not used with a MKREF request, \nthe server MAY enforce referential integrity if it wishes, according to \nany policy it likes.\n\nAn optional Ref-Type general header is defined below, with values \n\"DAV:direct\" and \"DAV:redirect\". The default value is \"DAV:redirect\" if \nthe header is not present.\n\nAn optional Position request header supports ordered collections by \nallowing the client creating a reference to specify where the new member \nis to be placed in the collection's ordering.  (This header can also be \nused with PUT to create an ordinary resource at a specific position in \nthe collection ordering.) \n\nWhen a server processes a MKREF request, it MUST set the \nDAV:resourcetype property (defined in [WebDAV]) of the new resource to \nbe DAV:reference.\n\nWhen a server processes a MKREF request, it MUST set the DAV:reftarget \nproperty to the URI of the target resource.\n        \nWhen a server processes a MKREF request, it MUST set the DAV:reftype \n\nSlein et al.                                                     Page 7\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nproperty based on the value of the Ref-Type header.\n\nWhen a server processes a MKREF request, it MUST set the \nDAV:refintegrity property to \"DAV:weak\" if it is not enforcing \nreferential integrity for the newly-created reference.  If it is \nenforcing referential integrity for the new reference, it MAY set the \nvalue of DAV:refintegrity to an extension value identifying its \nenforcement policy. \n\nThe client MUST NOT send any content with the MKREF request, and so MUST \nNOT use the Content-Length or Transfer-Encoding headers.  (See [HTTP].)\n\nIf a MKREF request has a request-URI that identifies an existing \nresource, the request MUST fail.  This behavior is analogous to the \nbehavior of the MKCOL method [WebDAV].  \n\n3.3.2 Status Codes\n\n201 (Created): The reference was successfully created.\n\n400 (Bad Request): The client attempted to send content with the \nrequest, or set an invalid value for the Ref-Target, Ref-Integrity, Ref-\nType, or Position header.\n \n405 (Method Not Allowed): A resource already exists at the request-URI.\n\n409 (Conflict): Several conditions may produce this response.  There may \nbe no resource at the location specified in Ref-Target, on a server that \nprohibits dangling references.  The request may be attempting to create \nthe reference in a collection that does not exist.  The request may be \nattempting to position the reference before or after a resource that is \nnot in the collection, or before or after itself.  The request may be \nattempting to position the reference in an unordered collection.\n\n507 (Insufficient Storage): There is not enough space on the server to \ncomplete the request.\n\n3.3.3 Example\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: <http://www.ics.uci.edu/i-d/draft-webdav-protocol-08.txt>\n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  Its DAV:resourcetype property is \nset to DAV:reference.  Its DAV:reftarget property is set to the URI of \nits target resource.  Its DAV:refintegrity property is set to the \ndefault value of DAV:weak.  Its DAV:reftype property is set to the \n\nSlein et al.                                                     Page 8\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\ndefault value of DAV:redirect.\n\n3.4 Deleting, Copying, and Moving Referential Resources\n\nThe DELETE method should be used to delete referential resources.  For \nboth direct and redirect references, DELETE affects the reference \nitself, and not its target.\n\nA MOVE operation on a referential resource moves the referential \nresource to a different location, but has no effect on the location of \nits target. The DAV:reftarget property is unchanged after a MOVE.\n\nA COPY operation on a referential resource copies the referential \nresource, not its target resource, to another location. The \nDAV:reftarget property of the destination resource is the same as the \nDAV:reftarget of the source resource.\n\n3.5 Listing Referential Members of a Collection\n\nA URI of a reference can be a member of a collection just as the URI of \nan ordinary resource can.  A listing of members of a collection shows \nall of the URIs in the collection, whether they identify references or \nordinary resources.  That is, a WebDAV PROPFIND request on a collection \nresource with Depth = 1 or infinity MUST return a response XML element \nfor each URI in the collection, whether it identifies an ordinary \nresource or a referential resource.\n\nFor each direct reference, the properties returned by the PROPFIND are \nthe properties of the target resource unless the No-Passthrough header \nis included with the PROPFIND request.\n\nFor each redirect reference, the response element contains a 302 (Moved \nTemporarily) status code unless the No-Passthrough header is included \nwith the PROPFIND request.  The DAV:location element and the DAV:reftype \nproperty are included with the 302 status code, extending the syntax of \nthe DAV:response element that was defined in [WebDAV] as described in \nSection 8 below.  A referencing client can tell from the DAV:reftype \nelement that the collection contains a redirect reference.  The \nDAV:location element contains the URI of the target resource.  A \nreferencing client can either use the DAV:location element to retrieve \nthe properties of the target resource or can submit a PROPFIND to the \nredirect reference with the No-Passthrough header to retrieve its \nproperties.  The DAV:location element is expected to be defined in a \nfuture revision of [WebDAV], at which time non-referencing clients will \nalso be able to use the response to retrieve the properties of the \ntarget resource.\n\nExample:\n\n.\n.\n.\n\nIf Depth = infinity in the PROPFIND request, the server MUST NOT follow \nredirect references into any collections to which they may refer.\n\nSlein et al.                                                     Page 9\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\nIf Depth = infinity in the PROPFIND request, the server MUST follow \ndirect references into any collections to which they may refer unless \nthe No-Passthrough header is used with the request.  That is, if the \ntarget resource is a collection, the server MUST list the members of \nthat collection.\n\nThe No-Passthrough header may be used with a PROPFIND request on a \ncollection.  If the No-Passthrough header is present, then the \nproperties of the references in the collection are returned.  The No-\nPassthrough header prevents any 302 (Moved Temporarily) status codes \nfrom being returned for redirect references, and it prevents direct \nreferences from passing the request through to their target resources.  \nIn addition, it prevents the server from following direct references to \ncollections into their target collections for PROPFIND requests with \nDepth = infinity. \n\n3.6 Locking Referential Resources\n\nIdeally, a LOCK on a reference should lock both the reference and its \ntarget resource.  The owner of an exclusive write lock, for example, \nwould be surprised if anyone else could modify the content of the target \nresource while he held the lock.  He would also be surprised if anyone \nelse could delete the reference to it, or replace the reference with one \npointing to a different target.\n\nFor direct references, it is possible to provide this intuitive \nbehavior:\n\nA LOCK on a direct reference does lock both the reference and its target \nresource.\n\nA LOCK with Depth = infinity on a collection that contains direct \nreferences locks both the direct references and their target resources.  \nIf any of the targets of the direct references are collections, the \nserver does lock the members of those collections.\n\nIn the case of redirect references, however, it is not possible to \nobtain this intuitive LOCK behavior and also meet other goals:  \n\no Redirect references should be simple for servers to implement. In \n  particular, a server should never have to resolve a redirect \n  reference.  A server should not have to provide proxy capabilities in \n  order to implement redirect references.\no Non-referencing clients should be able to use both direct and \n  redirect references.\no There should be consistency between the behavior of LOCK on a single \n  referential resource and the behavior of LOCK on a collection that \n  contains referential resources.\n\nWe have sacrificed support for non-referencing clients and the intuitive \nlocking behavior in order to preserve the meaning of \"redirect \nreference\" and consistency between locking collections containing \nredirect references and locking redirect references.  Behavior for \nlocking redirect references was determined by what is possible for the \n\nSlein et al.                                                     Page 10\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\ncase of locking collections:\n\nA LOCK with Depth = infinity on a collection that contains redirect \nreferences locks the redirect references, but not their targets.  This \ngives part of the expected lock behavior without forcing the server to \nresolve the redirect reference or become a proxy server in cases where \nthe target resides on a different server.  The response does not include \n302 status codes for the redirect references.  This is because any 302 \nstatus for a response element would cause the entire lock operation to \nfail, and force clients to lock each collection member individually \nwhenever there are any redirect references in a collection.  The \nresponse element does include DAV:reftype and DAV:reftarget properties \nso that a referencing client can lock the targets if it wishes.  (There \nwill be no hint in any response code that there are redirect references \nwhose targets need to be locked.  The client will most likely not lock \nany targets until it attempts an operation on the target and gets a 302 \nresponse.)  Non-referencing clients cannot lock the targets of the \nredirect references and may never realize that the targets have not been \nlocked.  Clearly, a LOCK with Depth = infinity on a collection will not \nfollow any redirect references whose targets are collections into the \ntarget collections; it will not cause any members of those target \ncollections to be locked.\n\nA LOCK on a redirect reference locks only the reference, not its target.  \nIt does not return a 302 response.  The response does include the Ref-\nType and Ref-Target headers, so that a referencing client can lock the \ntarget resource if it wishes.  Non-referencing clients cannot lock the \ntarget of a redirect reference. This behavior is designed to be \nconsistent with the behavior just described for collections.\n\nThe No-Passthrough header can be used with LOCK requests, and in all \ncases causes only the references, and not their targets, to be locked.\n\n3.7 Other WebDAV Operations on Redirect Referential Resources\n\nAlthough non-referencing WebDAV clients cannot create referential \nresources, they should be able to use the references created by \nreference-aware WebDAV clients.  They should be able to follow any \nreferences to their targets.  To make this possible, a server that \nreceives a PROPFIND, PROPPATCH, MKCOL, or MKREF request made via a \nredirect reference MUST return a 302 (Moved Temporarily) status code. \nThe client and server MUST follow [HTTP] Section 10.3.3 \"302 Moved \nTemporarily,\" but with these additional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Ref-Type header.  This header allows \n  reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nA reference-aware WebDAV client can act on this response in one of two \nways.  It can, like a non-referencing client, resubmit the request to \nthe URI in the Location header in order to operate on the target \nresource.  Alternatively, it can resubmit the request to the URI of the \n\nSlein et al.                                                     Page 11\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nredirect reference with the No-Passthrough header in order to operate on \nthe reference itself.  The No-Passthrough header causes the request to \nbe applied to the reference itself, and prevents a 302 response.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, it can save the round trip \ncaused by the 302 response by using No-Passthrough in its initial \nrequest to the URI.\n\nSince MKCOL and MKREF fail when applied to existing resources, if the \nclient attempts to resubmit the request to the target resource, the \nrequest will fail (unless the reference is a dangling reference).  \nSimilarly, if the client attempts to resubmit the request to the \nreference with a No-Passthrough header, the request will fail.\n\n3.8 Other WebDAV Operations on Direct Referential Resources\n\nWith the exception of DELETE, MOVE, and COPY, which were discussed \nabove, operations on direct references affect the target resource, not \nthe reference, unless the No-Passthrough header is used.\n\nUnless the No-Passthrough header is used, a LOCK operation on a direct \nreference locks the target resource.  \n\nUnless the No-Passthrough header is used, a LOCK on a collection with \nDepth = infinity locks the targets of the direct references in the \ncollection; in addition, the server MUST follow any direct references to \ncollections into their target collections, locking the members of the \ntarget collections.  \n\nUnless the No-Passthrough header is used, a PROPPATCH on a direct \nreference modifies the properties of its target resource, not the \nproperties of the reference itself. \n\nUnless the No-Passthrough header is used, a PROPFIND on a direct \nreference returns the properties of its target resource, not the \nproperties of the reference itself.\n\nIf the No-Passthrough header is used with a PROPPATCH or PROPFIND \nrequest on a direct reference, the operation is applied to the reference \nitself rather than to its target resource.\n\nMKCOL and MKREF fail if their request-URI identifies an existing \nresource of any kind.  Consequently, when submitted to a target resource \nvia a direct reference, they fail unless the reference is a dangling \nreference.  If they are submitted to an existing direct reference with \nthe No-Passthrough header, they also fail.\n\n3.9 HTTP Operations on Redirect Referential Resources\n\nAlthough existing HTTP clients cannot create referential resources, they \nshould be able to read collections created by reference-aware WebDAV \nclients.  They should be able to follow any references identified by \nURIs in those collections to their targets.  To make this possible, a \nserver that receives a GET or HEAD on a redirect reference MUST return a \n\nSlein et al.                                                     Page 12\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n302 (Moved Temporarily) status code.  The server MUST follow [HTTP] \nSection 10.3.3 \"302 Moved Temporarily,\" but with these additional rules: \n\no The Location header MUST contain the target URI of the reference.  \n\no The response MUST include all referencing entity headers that make \n  sense for redirect references: Ref-Type and Ref-Target. \n\no The response MUST also include those HTTP headers that make sense for \n  referential resources, at a minimum: Cache-Control, Age, ETag, \n  Expires, and Last-Modified.\n\nThe second and third of these rules preserve normal GET and HEAD \nbehavior for reference-aware WebDAV clients.\n\nTo enable existing HTTP clients to use PUT, POST, or OPTIONS via \nredirect references, a server that receives any of these requests on a \nredirect reference MUST return a 302 (Moved Temporarily).  The client \nand server MUST follow [HTTP] Section 10.3.3 \"302 Moved Temporarily,\" \nbut with these additional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Ref-Type header.  This header allows \n  reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nReference-aware clients can act on a 302 response in either of two ways.  \nLike plain HTTP clients, they can resubmit the request to the URI in the \nLocation header (the URI of the target resource).  They may, however, \nwant to operate on the reference rather than on its target.  In this \ncase, they may resubmit the request to the URI of the reference and \ninclude the No-Passthrough header with the request.  The No-Passthrough \nheader causes the request to be applied to the reference itself, and \nprevents a 302 response.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, it can save the round trip \ncaused by the 302 response by using No-Passthrough in its initial \nrequest to the URI.\n\nThe No-Passthrough header can be used with GET or HEAD to retrieve the \nheaders of a redirect reference, although this is not necessary since \nthe headers would accompany a 302 response in any case. The No-\nPassthrough header can be used with PUT to replace the redirect \nreference with an ordinary resource or with OPTIONS to retrieve the \ncapabilities of a redirect reference.  \n\nClients MUST NOT, however, use the No-Passthrough header with POST. \nSince a reference cannot accept another entity as its subordinate, an \nattempt to POST to a reference with No-Passthrough will also fail.  If a \nserver receives a POST request with the No-Passthrough header on a \nredirect reference, it MUST fail the request with a 400 (Bad Request) \nstatus code.\n\nSlein et al.                                                     Page 13\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\n3.10 HTTP Operations on Direct Referential Resources\n\nGET, HEAD, PUT, POST, and OPTIONS on direct references are automatically \npassed through to their target resources.  GET returns the content and \nheaders of the target resource, HEAD returns the headers of the target \nresource, PUT replaces the content of the target resource, POST performs \nthe expected function at the target resource, and OPTIONS reports the \ncommunication options available at the target resource.\n\nThe No-Passthrough request header may be used with GET, HEAD, PUT, or \nOPTIONS to view the headers or capabilities of the reference, rather \nthan its target.  \n\nThe No-Passthrough request header MUST NOT be used with POST, which \ncannot be applied to references.  If a server receives a POST request on \na direct reference with the No-Passthrough header, it MUST fail the \nrequest with a 400 (Bad Request) status code.\n\n3.11 Operations on Targets of Referential Resources\n\nIn general, operations on targets of weak referential resources have no \neffect on the referential resource.  However, servers that choose to \nmaintain the integrity of references are free to make changes to the \nstate of references when moving or deleting their targets.\n\nWhen moving a target resource, a server MAY insert an optional step into \nthe semantics of MOVE as defined in [WebDAV] for the purpose of \nmaintaining referential integrity.  Between the copy step and the delete \nstep of a MOVE, the server MAY perform an update step, which changes the \nDAV:reftarget property of any references to the target to reflect its \nnew location.\n\nWhen deleting a target resource, a server MAY perform any internal \noperations necessary to implement its policy on preserving referential \nintegrity.  For example, it might delete any references to the deleted \ntarget, or it might flag them as having a deleted target, or it might \nreplace references with copies of the target.\n\n3.12 Discovering a Target\u2019s References\n\nAn optional DAV:references property on the target resource provides a \nlist of referential resources whose DAV:reftarget property points to \nthat target resource.  If present, DAV:references is a read-only \nproperty, maintained by the server.  By retrieving this property, a \nclient can discover the URIs of the references that point to the target, \nand so can also discover the collections that contain those URIs as \nmembers.  As for all DAV: properties, this specification is silent as to \nhow the DAV:references property is implemented on the server.\n\nThe DAV:references property is expected to be supported mainly by \nDocument Management Systems (DMSs) and other servers that will maintain \nthe property only for references within their own domain.  It is not in \ngeneral possible for a server to maintain the property for references on \nother servers.  If a reference on a different server points to the \n\nSlein et al.                                                     Page 14\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\ntarget, the server where the target is located is unlikely to know about \nthat reference.  This protocol provides no mechanism for one server to \nnotify another of the creation of a reference to one of its resources.  \nConsequently, the list of references in DAV:reftarget may be incomplete.\n\nRationale: A number of scenarios require clients to navigate from a \ntarget resource to the references that point to it, and to the \ncollections that contain the URIs of those references.  This capability \nis particularly important for DMSs, which may populate their collections \nentirely by reference.  Their clients may need to determine, for any \nobject in the DMS, what collections contain URIs that identify \nreferences to that object.  It is also important in other contexts.  For \nexample, some servers enforce referential integrity by refusing to \ndelete any resource that is referenced by other resources.  In such an \nenvironment, the client must be able to discover the references in order \nto delete them before attempting to delete the target.\n\nRisks: When deciding whether to support the DAV:references property, \nserver implementors / administrators should balance the benefits it \nprovides against the cost of maintaining the property and the security \nrisks enumerated in Sections 11.4 and 11.5.\n\n3.13 Behavior of Dangling Direct References\n\nWhenever the No-Passthrough header accompanies a request on a dangling \ndirect reference, the request succeeds.  Since No-Passthrough causes the \nrequest to be applied to the reference rather than to its target, it \ndoes not matter that the target resource does not exist.  The client \nwill not be informed that the reference points to a nonexistent target.\n\nIn the absence of the No-Passthrough header, the responses MUST be as \nfollows:\n\nGET, HEAD, OPTIONS, POST, PROPFIND, and PROPPATCH respond with 404 (Not \nFound), but the Ref-Type and Ref-Target headers are included in the \nresponse, so that the client can tell that it is the target, and not the \nreference, that was not found.\n\nIf PROPFIND, LOCK, or UNLOCK is submitted to a direct reference that is \nbroken, the response is 404 (Not Found).  The Ref-Type and Ref-Target \nheaders are included in the response, so that the client can tell that \nit is the target, and not the reference, that was not found.\n\nIf, however, a PROPFIND, LOCK, or UNLOCK on a collection encounters a \ndangling direct reference inside the collection, the response is a 207 \n(Multi-Status).  The DAV:response element for the dangling reference \nwill have a status of 404 (Not Found). The DAV:reftype and DAV:reftarget \nproperties of the references are included in the response.  Their \npresence informs the client that it is the target, not the reference, \nthat was not found.  These two elements are extensions to the \nDAV:response element as defined in {WEBDAV].\n\nFor example,\n\nRequest:\n\nSlein et al.                                                     Page 15\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\nPROPFIND /collection1/ HTTP/1.1\nHost: www.somehost.com\nDepth: 1\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop xmlns:X=\"http://www.somehost.com/schemas/x\">\n      <X:author/>\n      <X:title/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.somehost.com/collection1/</D:href>\n      <D:propstat>\n         <D:prop xmlns:X=http://www.somehost.com/schemas/x>\n            <X:author>Smith, J.H.</X:author>\n            <X:title>My Working Collection</X:title>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.somehost.com/collection1/directref7</D:href>\n      <D:status>HTTP/1.1 404 Not Found</D:status>\n      <D:reftype><D:direct/></D:reftype>\n      <D:reftarget>\n         <D:href>http://www.somehost.com/collection2/file19</D:href>\n      </D:reftarget>\n      <D:responsedescription>Target resource not found.      \n      </D:responsedescription>\n   </D:response>\n</D:multistatus>\n\nPUT succeeds, creating a new resource at the location specified by the \nreference\u2019s DAV:reftarget property.\n\nMKREF and MKCOL succeed, since there is no existing resource at the \ntarget URI.\n\nMOVE and DELETE succeed, since they always affect the reference rather \nthan its target.  For MOVE, the reference at the destination will be \nbroken, just as the reference at the source was.\n\n\nSlein et al.                                                     Page 16\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nThe behavior of COPY is TBD.\n\n3.14 Summary of Referencing Headers Required in Responses\n\nThis section summarizes the rules that determine which referencing \nheaders must be included in responses to requests on references.\n\no Every response to a request on a reference MUST include the Ref-Type \n  header, so that the client knows that it was operating on a \n  reference, and can understand the behavior of the reference.\n\no Every response to a request on a direct reference MUST include the \n  Ref-Target header.  This allows the client to tell what resource was \n  affected by the operation.  A request that includes the No-\n  Passthrough header affects only the reference, and so the response \n  NEED NOT include the Ref-Target header.\n\no Every response to a GET or HEAD request on a redirect reference (or \n  on a direct reference with the No-Passthrough header) MUST include \n  all the referencing and other entity headers that make sense for \n  redirect references: Ref-Type and Ref-Target.\n\n4 Ordered Collections\n\n4.1 Overview\n\nCollections on a compliant server may be ordered, but need not be.  It \nis up to the client to decide whether a given collection is ordered and, \nif so, to specify the semantics to be used for ordering its members.  If \na collection is ordered, each of its members must be in the ordering \nexactly once, and the ordering must not include any resource that is not \na member of the collection.  Only one ordering can be attached to any \ncollection.  Multiple orderings of the same resources can be achieved by \ncreating multiple collections referencing those resources, and attaching \na different ordering to each collection.\n\nThe server is responsible for enforcing these constraints on orderings.  \nThe server MUST remove a member URI from the ordering when it is removed \nfrom the collection. The server MUST add a member URI to the ordering \nwhen it is added to the collection.\n\nWhen responding to a PROPFIND on a collection, the server MUST order the \nresponse elements according to the ordering defined on the collection.\n\n4.2 Creating an Ordered Collection\n\n4.2.1 Overview \n\nWhen a collection is created, the client can request that it be ordered \nand specify the semantics of the ordering by using the new Ordered \nheader in the MKCOL request, setting its value to the URI of the \nsemantics to be used or setting its value to DAV:custom if the semantics \nare not being advertised.  If the client does not want the collection to \nbe ordered, it may omit the Ordered header, or use it with the value \n\"DAV:unordered\".\n\nSlein et al.                                                     Page 17\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\nEvery collection MUST have the new DAV:orderingtype property, which \nindicates whether the collection is ordered and, if so, identifies the \nsemantics of the ordering.  A value of DAV:unordered indicates that that \ncollection is not ordered.  That is, the client cannot depend on the \nrepeatability of the ordering of results from a PROPFIND request.  For \ncollections that are ordered, DAV:orderingtype SHOULD be set to an href \nthat identifies the semantics of the ordering, allowing a human user or \nsoftware package to insert new collection members into the ordering \nintelligently.  Although the href MAY point to a resource that contains \na definition of the semantics of the ordering, clients are discouraged \nfrom accessing that resource, in order to avoid overburdening its \nserver.  The DAV:orderingtype property MAY be set to DAV:custom to \nindicate that the collection is to be ordered, but the semantics of the \nordering is not being advertised. \n\nIf the Ordered header is present on a MKCOL request, the server MUST set \nthe collection's DAV:orderingtype property to the value of the Ordered \nheader.  If the Ordered header is not present, the server MUST treat the \nrequest as if it had an Ordered header with the value \"DAV:unordered\", \nmeaning that the collection is not ordered.  If the collection is \nordered, the server MUST respond to PROPFIND requests on the collection \nusing the specified ordering.\n\n4.2.2 Status Codes\n\nNo new error conditions are introduced.\n\n4.2.3 Example\n\nRequest:\n\nMKCOL /theNorth/ HTTP/1.1\nHost: www.server.org\nOrdered: <http://www.server.org/orderings/compass.html>\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this example, a new, ordered collection was created.  Its \nDAV:orderingtype property has as its value the URI from the Ordered \nheader.  In this case, the URI identifies the semantics governing the \nordering.  As new members are added to the collection, clients or end \nusers can use the semantics to determine where to position the new \nmembers in the ordering. \n\n4.3 Setting the Position of a Collection Member\n\n4.3.1 Overview\n\nWhen a new member is added to a collection (for example, with PUT, \nMKREF, or MKCOL), its position in the ordering can be set with the new \nPosition header.  The Position header allows the client to specify that \nthe member should be first in the collection's ordering, last in the \n\nSlein et al.                                                     Page 18\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\ncollection's ordering, before some other collection member in the \ncollection's ordering, or after some other collection member in the \ncollection's ordering.\n\nThe server MUST insert the new member into the ordering at the location \nspecified in the Position header, if one is present (and if the \ncollection is ordered); otherwise, it MUST append the new member to the \nend of the ordering (if the collection is ordered).  If a PUT causes an \nexisting resource to be replaced, and if the Position header is absent, \nthe server MUST leave the member at its previous position in thee \ncollection ordering.  If the Position header is present, the server MUST \nremove the member from its previous position, and then insert it at the \nrequested position.\n\n4.3.2 Status Codes\n\n201 (Created): The resource was successfully created.\n\n409 (Conflict): The request may be attempting to position the collection \nmember before or after a URI that is not in the collection, or before or \nafter itself, or it may be attempting to position the collection member \nin an unordered collection.\n\n4.3.3 Examples\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: <http://www.ics.uci.edu/i-d/draft-webdav-protocol-08.txt>\nPosition: After <requirements.html>       \n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  The Position header in this \nexample caused the server to set its position in the ordering of the \n/~whitehead/dav/ collection immediately after requirements.html.\n\nRequest:\n\nMOVE /i-d/draft-webdav-protocol-08.txt HTTP/1.1\nHost: www.ics.uci.edu\nDestination: </~whitehead/dav/draft-webdav-protocol-08.txt>\nPosition: First\n\nResponse:\n\nHTTP/1.1 409 Conflict\n\nIn this case, the server returned a 409 Conflict status code because the \n/~whitehead/dav/ collection is an unordered collection.  Consequently, \n\nSlein et al.                                                     Page 19\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nthe server was unable to satisfy the Position header.\n\n4.4 Changing the Semantics of a Collection Ordering\n\nAfter a collection has been created, a client can change its ordering \nsemantics, or change an ordered collection to an unordered collection or \nvice versa, by using PROPPATCH to change the value of its \nDAV:orderingtype property.  The client is then responsible for updating \nthe ordering of the collection members according to the new semantics.  \nPROPPATCH is defined in [WebDAV], Section 7.2.\n\n4.5 Changing the Position of a Collection Member\n\n4.5.1 The ORDERPATCH Method\n\nTo change the positions of collection members in the collection's \nordering, the client MUST use an ORDERPATCH request with a request body \ncontaining an order XML element.  The request-URI of an ORDERPATCH \nrequest is the URI of the collection whose ordering is to be updated.  \nThe order XML element identifies the member URIs whose positions are to \nbe changed, and describes their new positions in the ordering.  Each new \nposition can be specified as first in the ordering, last in the \nordering, before some other collection member in the ordering, or after \nsome other collection member in the ordering.  The server MUST apply the \nchanges in the order they appear in the order element.\n\n4.5.2 Status Codes\n\nSince multiple changes can be requested in a single ORDERPATCH request, \nthe server MUST return a 207 Multi-Status response, as defined in \n[WebDAV].\n\nWithin the 207 Multi-Status response, the following status codes are \npossible:\n\n200 (OK): The change in ordering was successfully made.\n\n409 (Conflict): An attempt was made to position the collection member \nbefore or after a URI that is not in the collection, or before or after \nitself, or an attempt was made to position the collection member in an \nunordered collection.\n\nA request to reposition a collection member to the same place in the \nordering is not an error. \n\n4.5.3 Example\n\nConsider a collection /coll-1/ with members ordered as follows:\n\nnunavut.map\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\n\nSlein et al.                                                     Page 20\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nnunavut.desc\niqaluit.img\niqaluit.desc\n\nRequest:\n\nORDERPATCH /coll-1/ HTTP/1.1\nHost: www.nunanet.com\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:order xmlns:d=\"DAV:\">\n   <d:ordermember>\n      <d:href>nunavut.desc</d:href>\n      <d:position> \n         <d:after>\n            <d:href>nunavut.map</d:href>\n         </d:after>\n      </d:position>\n   </d:ordermember>\n   <d:ordermember>\n      <d:href>iqaluit.img</d:href>\n      <d:position>\n         <d:last/>\n      </d:position>\n   </d:ordermember>\n</d:order>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/nunavut.desc</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/iqaluit.img</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n</d:multistatus>\n\nIn this example, after the request has been processed, the collection's \nordering is as follows:\n\nnunavut.map\nnunavut.desc\nnunavut.img\nbaffin.map\nbaffin.desc\n\nSlein et al.                                                     Page 21\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nbaffin.img\niqaluit.map\niqaluit.desc\niqaluit.img\n\n4.5.4 Design Rationale\n \nThe decision to introduce the new ORDERPATCH method was made after \ninvestigating the possibility of using the existing MOVE method with a \nPosition header.  The use of MOVE initially looked appealingly simple:\n\nMOVE /root/coll-1/foo HTTP/1.1\nHost: www.somehost.com\nDestination: </root/coll-1/foo>\nPosition: First\n\nUnfortunately, several features of the semantics of MOVE make it \nunsuitable for changing the position of a collection member in the \ncollection's ordering.  First, [WebDAV] defines MOVE as logically \nequivalent to a copy followed by a delete of the source resource.  This \ndefinition makes it impossible to MOVE a resource to a destination URL \nthat is the same as the source URL.  The resource would be deleted \nrather than moved.  Second, [WebDAV] states that when moving a resource \nto a destination where a resource already exists, the Overwrite header \nmust be \"T\", and in this case the server must DELETE the resource at the \ndestination before performing the MOVE.  Again, this makes it impossible \nto MOVE a resource to the same location.  Finally, [WebDAV] states that \nlocks are lost on a MOVE, an outcome that seems undesirable in this \ncase.\n\n5 New Headers\n\n5.1 Ref-Target Entity Header\n\nRef-Target = \"Ref-Target\" \":\" Coded-url\n\nCoded-url is defined in [WebDAV], Section 8.4.\n\nThe Ref-Target header is used with the MKREF method to identify the \ntarget resource of the new referential resource being created.  It is a \nrequired header in MKREF requests.  \n\nServers MUST include the Ref-Target header in the following responses: \n\no Responses to GET and HEAD requests on redirect references\n\no Responses to all requests on direct references, unless the request \n  included the No-Passthrough header\n\n5.2 Ref-Type Entity Header\n\nRef-Type = \"Ref-Type\" \":\" (\"DAV:direct\" | \"DAV:redirect\") \n\nThe Ref-Type header is defined to distinguish between direct and \nredirect references.  The possible values of this header are DAV:direct \n\nSlein et al.                                                     Page 22\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nand DAV:redirect.  If the header is not present on a MKREF request, the \nserver MUST treat the request as if it has a Ref-Type header with the \nvalue DAV:redirect. \n\nServers MUST include the Ref-Target header in the following responses: \n\no Responses to all requests on both direct and redirect references\n\n5.3 Ref-Integrity Request Header\n\nRef-Integrity = \"Ref-Integrity\" \":\" (\"DAV:do-not-enforce\" | extend)\nextend = 1#CHAR\n\nThe Ref-Integrity header is defined primarily to allow future support \nfor strong references.  It specifies whether the server should enforce \nreferential integrity for a referential resource being created with \nMKREF. The only value currently defined for the Ref-Integrity header is \n\"DAV:do-not-enforce\". \"DAV:do-not-enforce\" means that the server MUST \nNOT enforce referential integrity for the newly created reference.  \nOther values may be used by private agreement between the client and \nserver.  If the header is not present on a MKREF request, the server MAY \nenforce referential integrity for the resource, according to whatever \npolicy it chooses.  If the server receives an extension value that it \ndoes not understand, it MUST enforce referential integrity for the new \nreference following its default policy; if it cannot enforce referential \nintegrity, it MUST fail the request.\n\n5.4 No-Passthrough Request Header\n\nNo-Passthrough = \"No-Passthrough\" \":\"\n\nThe optional No-Passthrough header can be used on any request to a \nreference except POST.  For a direct reference, it forces the request to \nbe applied to the reference itself rather than to its target.  For a \nredirect reference, it prevents a 302 response and instead causes the \nrequest to be applied to the reference itself. If the No-Passthrough \nheader is used on a request to any other sort of resource besides a \nreference, the server SHOULD ignore it.  If the No-Passthrough header is \nused with a POST request, the server MUST respond with a 400 (Bad \nRequest).\n\nThe No-Passthrough header can be used with PROPFIND requests on \ncollections with Depth = infinity.  When it is used in this way, the \nserver MUST return the properties of any redirect references in the \ncollection, and not return 302 (Moved Temporarily) status codes for \nthem.  It MUST also return the properties of any direct references in \nthe collection (not the properties of their targets), and it MUST NOT \nfollow any direct references to collections into their target \ncollections.\n\nThe No-Passthrough header can be used with LOCK requests on collections \nwith Depth = infinity.  When it is used in this way, the server MUST \nlock any redirect references in the collection.  It MUST also lock any \ndirect references in the collection (not their target resources), and it \nMUST NOT follow any direct references to collections into their target \n\nSlein et al.                                                     Page 23\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\ncollections.\n\n5.5 Ordered Entity Header\n\nOrdered = \"Ordered\" \":\" (\"DAV:unordered\" | \"DAV:custom\" | Coded-url)\n\nThe Ordered header may be used with MKCOL to request that the new \ncollection be ordered and to specify its ordering semantics.  A value of \n\"DAV:unordered\" indicates that the collection is not ordered.  That is, \nthe client cannot depend on the repeatability of the ordering of results \nfrom a PROPFIND request. A Coded-url value indicates that the collection \nis ordered, and identifies the semantics of the ordering, allowing a \nhuman user or software package to insert new collection members into the \nordering intelligently.  The Coded-url MAY point to a resource that \ncontains a definition of the semantics of the ordering.  A value of \n\"DAV:custom\" indicates that the collection is to be ordered, but the \nsemantics of the ordering is not being advertised.\n\nIf the Ordered header is not present on a MKCOL request, the server MUST \ntreat the request as if it had an Ordered header with the value \n\"DAV:unordered\".\n\n5.6 Position Request Header\n\nPosition = \"Position\" \":\" (\"First\" | \"Last\" | \n                           ((\"Before\" | \"After\") Coded-url))\n\nThe Position header may be used with any method that adds a member to a \ncollection to tell the server where in the collection ordering to \nposition the new member being added to the collection.  It may be used \nfor both ordinary and referential members.\n\nIf the Coded-url is a relative URL, it is interpreted relative to the \ncollection to which the new member is being added. \n\nIf the Position request header is not used, then:\n\nIf the request is replacing an existing resource, the server MUST \npreserve the present ordering.\n\nIf the request is adding a new member to the collection, the server MUST \nappend the new member to the end of the ordering (if the collection is \nordered).\n\n6 New Properties\n\n6.1 reftarget Property\n\nName:\t    reftarget\nNamespace:  DAV:\nPurpose:    A required property of referential resources that provides \n            an efficient way for clients to discover the URI of the \n            target resource.  This is a read-only property, whose value \n            can only be set by using the Ref-Target header with a MKREF \n            request.\n\nSlein et al.                                                     Page 24\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nValue: \t    URI of the target resource.\n\n<!ELEMENT reftarget href>\n\n6.2 refintegrity Property\n \nName:\t    refintegrity\nNamespace:  DAV:\nPurpose:    A required property of a referential resource that indicates \n            whether the server enforces referential integrity for that \n            reference.  The refintegrity property is defined to allow \n            future support for strong references.  The only value \n            currently defined for refintegrity is weak, which means that \n            the server does not enforce referential integrity for the \n            reference.  Other values may be used by private agreement \n            between the client and server.  This is a readonly property.\nValue:\t    weak\n\n<!ELEMENT refintegrity (weak | extension)>\n\n6.3 reftype Property\n\nName:       reftype\nNamespace:  DAV\nPurpose:    A required property of a referential resource that\n            identifies the reference as direct or redirect.  This is a\n            read-only property, whose value can only be set by using\n            the Ref-Type header with a MKREF request.\nValue:      direct | redirect\n\n<!ELEMENT reftype (direct | redirect)>\n\n6.4 references Property\n\nName:\t    references\nNamespace:  DAV:\nPurpose:    Enables clients to discover, for any target resource, what \n            references point to it and what collections contain it by \n            reference.  This is an optional property.  If present, it is \n            a read-only property, maintained by the server.\nValue:\t    List of the URIs of the references that point to the target \n            resource.\n\n<!ELEMENT references (href*)>\n\n6.5 orderingtype Property\n\nName:\t    orderingtype\nNamespace:  DAV:\nPurpose:    Indicates whether the collection is ordered and, if so, \n            uniquely identifies the semantics of the ordering being \n            used.  May also point to an explanation of the semantics in \n            human and / or machine-readable form.  At a minimum, this \n            allows human users who add members to the collection to \n            understand where to position them in the ordering.\n\nSlein et al.                                                     Page 25\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nValue:\t    unordered for an unordered collection, or a URI that \n            uniquely identifies the semantics of the collection's \n            ordering.  The URI MAY point to a definition of the ordering \n            semantics.  The value custom may be used for a collection \n            that is to be ordered, but for which the semantics are not \n            being advertised.\n\n<!ELEMENT orderingtype (arbitrary | custom | href) >\n\n7 New XML Elements\n\n7.1 reference XML Element\n\nName: \t    reference\nNamespace:  DAV:\nPurpose:    A new value of the DAV:resourcetype property that identifies \n            its resource as a referential resource.  The \n            DAV:resourcetype property of a referential resource MUST\n            have this value.\nValue:\t    EMPTY\n\n<!ELEMENT reference EMPTY >\n\n7.2 direct XML Element\n\nName:\t    direct\nNamespace:  DAV:\nPurpose:    A value for the DAV:reftype property that identifies its \n            resource as a direct reference.\nValue:      EMPTY\n\n<!ELEMENT direct EMPTY >\n\n7.3 redirect XML Element\n\nName:\t    redirect\nNamespace:  DAV:\nPurpose:    A value for the DAV:reftype property that identifies its \n            resource as a redirect reference.\nValue:      EMPTY\n\n<!ELEMENT redirect EMPTY >\n\n7.4 weak XML Element\n\nName:\t    weak\nNamespace:  DAV:\nPurpose:    A value of the DAV:refintegrity property.  It means that the \n            server does not enforce referential integrity for the \n            reference to which the property belongs.\nValue: \t    EMPTY\n\n<!ELEMENT weak EMPTY >\n\n7.5 extension XML Element\n\nSlein et al.                                                     Page 26\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\nName:\t    extension\nNamespace:  DAV:\nPurpose:    To allow servers and clients to extend the set of values of \n            DAV elements and properties by private agreement, and to \n            allow for future extension of the protocol by adding new \n            values for DAV elements and properties.\nValue: \t    ANY\n\n<!ELEMENT extension ANY >\n\n7.6 location XML Element\n\nName:       location\nNamespace:  DAV:\nPurpose:    For use with 302 (Moved Temporarily) response codes in \n            Multi-Status responses.  It contains the URL of the \n            temporary location of the resource.  In the context of \n            redirect references, this value is the URL of the target \n            resource.  It is analogous to the Location header in HTTP \n            302 responses defined in [HTTP] Section 10.3.3 \"302 Moved \n            Temporarily.\"  This is an extension to the syntax of the \n            DAV:response element defined in [WebDAV].\nValue:      href\n\n<!ELEMENT location href >\n\n7.7 unordered XML Element\n\nName:\t    unordered\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is not ordered.  That is, the client cannot \n            depend on the repeatability of the ordering of results from \n            a PROPFIND request.\nValue:\t    EMPTY\n\n<!ELEMENT unordered EMPTY >\n\n7.8 custom XML Element\n\nName: \t    custom\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is ordered, but the semantics of the ordering \n            are not being advertised. \nValue: \t    EMPTY\n\n<!ELEMENT custom EMPTY >\n\n7.9 order XML Element\n        \nName: \t    order\nNamespace:  DAV\nPurpose:    For use with the new ORDERPATCH method.  Describes a change \n\nSlein et al.                                                     Page 27\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n            to be made in a collection ordering.\nValue: \t    A description of the new positions of collection members in \n            the collection's ordering.\n\n<!ELEMENT order (member+) >\n\n7.10 ordermember XML Element\n \nName: \t    ordermember\nNamespace:  DAV\nPurpose:    Occurs in the order XML Element, and describes the new \n            position of a single collection member in the collection's \n            ordering.\nValue: \t    An href containing a relative URI, and a description of its \n            new position in the ordering.  The href XML element is \n            defined in [WebDAV], Section 11.3.\n\n<!ELEMENT ordermember (href, position) >\n\n7.11 position XML Element\n\nName: \t    position\nNamespace:  DAV\nPurpose:    Occurs in the member XML element.  Describes the new \n            position in a collection's ordering of one of the \n            collection's members.\nValue: \t    The new position can be described as first in the \n            collection's ordering, last in the collection's ordering, \n            before some other member of the collection, or after some \n            other member of the collection.\n\n<!ELEMENT position (first | last | before | after)>\n\n7.12 first XML Element\n\nName: \t    first\nNamespace:  DAV\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as first in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT first EMPTY >\n\n7.13 last XML Element\n\nName: \t    last\nNamespace:  DAV\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as last in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT last EMPTY >\n\n\nSlein et al.                                                     Page 28\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n7.14 before XML Element\n\nName: \t    before\nNamespace:  DAV\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming before some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it precedes in the ordering\n\n<!ELEMENT before href >\n\n7.15 after XML Element\n\nName: \t    after\nNamespace:  DAV\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming after some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it follows in the ordering\n\n<!ELEMENT after href >\n\n8 Extensions to the DAV:multistatus XML Element\n\nAs described in Sections 3.5 and 3.6, the DAV:location element and the \nDAV:reftype property may be returned in the DAV:response element of a \n207 Multi-Status response, to allow clients to resubmit their requests \nto the target resource of a redirect reference.  \n\nAs described in Section 3.12, the DAV:reftype and DAV:reftarget \nproperties may be returned in the DAV:response element of a 207 Multi-\nStatus response, to indicate that a problem is not with a direct \nreference, but with its target resource.\n\nConsequently, the definition of the DAV:response XML element changes to \nthe following:\n\n<!ELEMENT response (href, ((href*, status, location?, reftype?, \nreftarget?) | (propstat+)), responsedescription?) >\n\n9 Capability Discovery\n\n9.1 Using OPTIONS\n\nSince referencing and ordering are independent capabilities, a resource \nMAY support either or both.  A resource that provides referencing MUST \nsupport redirect references, and MAY in addition support direct \nreferences.  A response to an OPTIONS request MUST indicate which of \nthese capabilities the resource supports.\n\nThis specification defines two new methods: MKREF in support of \nreferencing, and ORDERPATCH in support of ordering.  The response MUST \nindicate which of these methods the resource allows.  In addition, the \nresponse MUST include the DAV header, as described in Sections 9.1 and \n15 of [WebDAV].  Three new compliance classes are defined here for use \n\nSlein et al.                                                     Page 29\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nwith the DAV header: DAV:basicref, DAV:directref, and DAV:orderedcoll. \nThe value DAV:basicref indicates that the resource supports at least \nredirect references.  The value DAV:directref indicates that the \nresource supports direct references.  The value DAV:orderedcoll \nindicates that the resource supports ordering.\n\n9.2 Example\n\nRequest:\n\nOPTIONS /somecollection/ HTTP/1.1\nHOST: somehost.org\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, MKREF, ORDERPATCH\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, MKREF, ORDERPATCH\nDAV: 1, 2, DAV:basicref, DAV:directref, DAV:orderedcoll\n\nThis response indicates that the resource /somecollection/ is level 1 \nand level 2 compliant, as defined in [WebDAV], and in addition provides \nbasic referencing, direct references, and ordered collections.\n\n10 Dependencies on Other Specifications\n\nTBD\n\n11 Security Considerations\n\nThis section is provided to detail issues concerning security \nimplications of which WebDAV applications need to be aware. \n\nAll of the security considerations of HTTP/1.1 and the base WebDAV \nprotocol also apply to WebDAV collections.  In addition, referential \nresources and ordered collections introduce several new security \nconcerns and increase the risk of some existing threats.  These issues \nare detailed below.\n\n11.1 Redirect Loops\n\nAlthough redirect loops were already possible in HTTP 1.1, the \nintroduction of referential resources creates a new avenue for clients \nto create loops accidentally or maliciously.  If the referential \nresource and its target are on the same server, the server may be able \nto detect MKREF requests that would create loops. See also [HTTP], \nSection 10.3 \"Redirection 3xx.\" \n\n11.2 References and Denial of Service\n\n\nSlein et al.                                                     Page 30\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\nThe introduction of referential resources creates a new avenue for \ndenial of service attacks. Clients can create heavily used references to \ntarget locations that were not designed for heavy usage.\n\n11.3 Maintaining Referential Integrity May Reveal Private Locations\n\nAlthough this specification does not require servers to maintain \nreferential integrity, it does not prevent them from doing so.  If a \nserver updates a reference\u2019s DAV:reftarget property when its target \nresource is moved, there is the risk that a private location will be \nrevealed in the new value of DAV:reftarget.  Clients can avoid this risk \nby doing a COPY followed by a DELETE rather than a MOVE.\n\n11.4 DAV:references and Denial of Service\n\nIf the server maintains the DAV:references property in response to \nreferences created in other administrative domains, it is exposed to \nhostile attempts to make it devote resources to adding references to the \nlist.\n\n11.5 DAV:references and Malicious Deletion of Resources\n\nServers that support the DAV:references property should insure that \nclients cannot create editable properties with the name DAV:references.  \nAn editable DAV:references property would constitute a security risk on \nservers that enforce referential integrity by deleting references when \ntheir target is deleted.  These servers could be tricked into deleting a \nresource by listing it in the DAV:references property of some target \nresource.\n\n11.6 Malicious Modifications of Ordering\n\nParticularly in large collections, moving a collection member to a \ndifferent position in the ordering can make it very difficult for users \nto find.\n\n11.7 Denial of Service and DAV:orderingtype\n\nThere may be some risk of denial of service at sites that are advertised \nin the DAV:orderingtype property of collections.  However, it is \nanticipated that widely-deployed applications will use hard-coded values \nfor frequently-used ordering semantics rather than looking up the \nsemantics at the location specified by DAV:orderingtype.\n\n12 Internationalization Considerations\n\nThis specification follows the practices of [WebDAV] in encoding all \nhuman-readable content using XML [XML] and in the treatment of names.  \nConsequently, this specification complies with the IETF Character Set \nPolicy [Alvestrand].\n\nWebDAV applications MUST support the character set tagging, character \nset encoding, and the language tagging functionality of the XML \nspecification.  This constraint ensures that the human-readable content \nof this specification complies with [Alvestrand].\n\nSlein et al.                                                     Page 31\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n\nAs in [WebDAV}, names in this specification fall into three categories: \nnames of protocol elements such as methods and headers, names of XML \nelements, and names of properties.  Naming of protocol elements follows \nthe precedent of HTTP, using English names encoded in USASCII for \nmethods and headers.  The names of XML elements used in this \nspecification are English names encoded in UTF-8.\n\nFor error reporting, [WebDAV] follows the convention of HTTP/1.1 status \ncodes, including with each status code a short, English description of \nthe code (e.g., 423 Locked).  Internationalized applications will ignore \nthis message, and display an appropriate message in the user's language \nand character set.\n \nFor rationales for these decisions and advice for application \nimplementors, see [WebDAV].\n\n13 IANA Considerations\n\nTBD\n\n14 Copyright\n\n15 Intellectual Property\n\n16 Acknowledgements\n\nThis draft has benefited from thoughtful discussion by Jim Amsden, Steve \nCarter, Geoffrey Clemm, Ken Coar, Ellis Cohen, Bruce Cragun, Spencer \nDawkins, Rajiv Dulepet, David Durand, Chuck Fay, Roy Fielding, Yaron \nGoland, Fred Hitt, Alex Hopmann, Marcus Jager, Chris Kaler, Manoj \nKasichainula, Rohit Khare, Daniel LaLiberte, Steve Martin, Surendra \nKoduru Reddy, Sam Ruby, Bradley Sergeant, Nick Shelness, John Stracke, \nJohn Tigue, John Turner, and others. \n\n17 References\n\n[WebDAV] Y. Y. Goland, E. J. Whitehead, Jr., A. Faizi, S. R. Carter, D. \nJensen, \"HTTP Extensions for Distributed Authoring - WebDAV.\" Draft-\nietf-webdav-protocol-09. Internet Draft, work in progress.  Microsoft, \nU.C. Irvine, Netscape, Novell. November, 1998.\n\n[DASL] Saveen Reddy, D. Jensen, Surendra Reddy, R. Henderson, J. Davis, \nA. Babich, \"DAV Searching & Locating.\" Draft-reddy-dasl-protocol-03. \nInternet Draft, work in progress. Microsoft, Novell, Oracle, Netscape, \nXerox, Filenet.  November, 1998. \n\n[WebDAVReq] J. Slein, J. Davis, \"Requirements for Advanced Collection \nFunctionality in WebDAV.\" Draft-ietf-webdav-collection-reqts-02. \nInternet Draft, work in progress.  Xerox, 1998.\n\n[HTTP] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-Lee, \n\"Hypertext Transfer Protocol -- HTTP/1.1.\" RFC 2068.  UC Irvine, DEC, \nMIT/LCS.  January, 1997.\n\n\nSlein et al.                                                     Page 32\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n[XML] T. Bray, J. Paoli, C.M. Sperberg-McQueen, \"Extensible Markup \nLanguage (XML).\"  World Wide Web Consortium Recommendation REC-xml-\n19980210. http://www.w3.org/TR/1998/REC-xml-19980210.\n\n18 Authors' Addresses\n\nJ. Slein\nXerox Corporation\n800 Phillips Road, 105-50C\nWebster, NY 14580\nEmail: jslein@crt.xerox.com\n\nJ. Davis\nXerox Corporation\n3333 Coyote Hill Road\nPalo Alto, CA 94304\nEmail: jdavis@parc.xerox.com\n\nA. Babich\nFileNet Corporation\n3565 Harbor Boulevard\nCosta Mesa, CA 92626-1420\nEmail: ababich@filenet.com\n\nE.J. Whitehead Jr.\nDept. of Information and Computer Science\nUniversity of California, Irvine\nIrvine, CA 92697-3425\nEmail: ejw@ics.uci.edu\n\n19 Appendices\n\n19.1 Appendix 1 - Extensions to the WebDAV Document Type Definition\n\n<!--============= XML Elements from Section 7 =========================-\n->\n<!ELEMENT reference EMPTY >\n<!ELEMENT direct EMPTY >\n<!ELEMENT redirect EMPTY >\n<!ELEMENT weak EMPTY >\n<!ELEMENT extension ANY >\n<!ELEMENT location href>\n<!ELEMENT unordered EMPTY >\n<!ELEMENT custom EMPTY >\n<!ELEMENT order (member+) >\n<!ELEMENT ordermember (href, position) >\n<!ELEMENT position (first | last | before | after)>\n<!ELEMENT first EMPTY >\n<!ELEMENT last EMPTY >\n<!ELEMENT before href >\n<!ELEMENT after href >\n<!--============= Property Elements from Section 6 ====================-\n->\n<!ELEMENT reftarget href>\n<!ELEMENT refintegrity (weak | extension)>\n\nSlein et al.                                                     Page 33\n\fINTERNET-DRAFT          WebDAV Collections Protocol         January 1999\n\n<!ELEMENT reftype (direct | redirect)>\n<!ELEMENT references (href*)>\n<!ELEMENT orderingtype (arbitrary | custom | href) >\n<!--======== Changes to the DAV:multistatus Element from Section 8 ====-\n->\n<!ELEMENT response (href, ((href*, status, location?, reftype?, \nreftarget?) | (propstat+)), responsedescription?) >\n\nExpires July 21, 1999\n\nSlein et al.                                                     Page 34\n\f", "encoding": "Windows-1252"}