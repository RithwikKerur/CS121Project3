{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/06.randbst", "content": "Analysis of random search trees\n\tmodel 1 (insertions only): any permutation of inserts is equally likely\n\t\t=> some distribution on trees\n\n\tmodel 2 (ins+del): perform arbitrary seq of insert and deletes\n\t\tany permutation of items equally likely for insert sequence\n\t\tany item equally likely to be deleted\n\n\tmodified delete procedure:\n\t\tif has no right child, set parent->left child (splice or del)\n\t\telse: find successor, move into place\n\t\n\tTheorem [Hibbard, 1962; see Knuth 6.2.2]:\n\tafter a single deletion, both models => same dist on tree shapes\n\t\twork on insertion orders rather than trees\n\t\trepresent order by permutation of (1,2,...,n)\n\t\t\t(actual numerical values irrelevant)\n\n\t\tshow how mod del op corresponds to an insertion order del op:\n\t\t\tif item to be deleted is last in order, or\n\t\t\t\tsucc(item) was inserted prior to item,\n\t\t\t\tthen just remove it from the permutation\n\t\t\telse:\n\t\t\t\tmove succ(item) into place of item\n\t\t\trenumber permutation\n\n\t\tif we start with n+1 items, there are\n\t\t\t(n+1) (n+1)! combinations of deleted item & perm\n\t\t\tall combinations equally likely\n\n\t\tany given permutation P can arise from exactly (n+1)^2 combs:\n\t\t\tchoose 0 <= i,j <= n\n\t\t\tif i < j:\n\t\t\t\tlet x = P[i]-epsilon\n\t\t\t\tinsert copy of P[i] at pos j\n\t\t\t\treplace P[i]=x\n\t\t\t\trenumber\n\t\t\t\tdelete P[i]\n\t\t\tif i > j:\n\t\t\t\tlet x = P[j]-epsilon\n\t\t\t\tinsert x at pos i\n\t\t\t\trenumber\n\t\t\t\tdelete P[i]\n\t\t\tif i == j:\n\t\t\t\tlet x = n+1\n\t\t\t\tinsert x at pos i\n\t\t\t\tdelete P[i]\n\n\t\tso after delete, all permutations still equally likely\n\n\tBUT, while dist(shapes) same,\n\t\tjoint dist (values & shapes) becomes nonuniform\n\t\tso does not allow us to analyze model 2...\n\t\t\tonly simpler model (some insertions then some dels)\n\n\t\tin practice, dels + reinserts tend to make tree better shaped\n\n\n\tE[height(x)] = Sum_y P(y is anc.) <= 2 H_n = O(log n)\n\n\tEquivalence to random quicksort\n\n\tBook, 12.4:\n\tE[height(T)] <= 3 log_2(n) + o(log n)\n\n\tMuch more is known:\n\t\tw.h.p. max height =~ 4.31107 ln n\n\n\t\tdistribution of # nodes at heights\n\t\t(grows polynomially to O(n/sqrt log n), plateaus, shrinks)\n\n\ntreap (Aragon Seidel 1989):\n\twhen each item inserted, choose random \"priority\" -- real in [0,1]\n\n\tbinary search tree on item values + heap property on priorities\n\t\t=> same as if items inserted in that order\n\t\t(so priorities random => same quality as random bst)\n\n\tinsert: bst-insert, choose priority, bubble up (rotate)\n\tdelete: set priority=1, bubble-down (compare and rotate), remove\n\n\tW.H.P. all operations take O(log n) time\n\n\nAnswers to homeworks: exercise 20.2-5; probs 10-2, 11-2, 20-2\n", "encoding": "ascii"}