{"url": "https://www.ics.uci.edu/~kay/courses/i41/hw/lab8.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\" />\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\" />\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Tuesday, November 22, 2005 5:38 AM\" />\n<TITLE>Lab Assignment 8</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"D21ADA26\" />\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 1, CS1, assignment, Scheme\" />\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"An assignment for ICS H21, an honors first-quarter course in computer science in Information and Computer Science, UC Irvine, using How to Design Programs by Matthias Felleisen et al.\" />\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2001 by David G. Kay.  All rights reserved.\" />\n<link href=\"/~kay/courses/i41/code.css\" rel=\"stylesheet\" type=\"text/css\" />\n<style type=\"text/css\">\n<!--\n.style1 {font-family: \"Goudy Old Style\"}\n.style2 {font-family: \"Courier New\", Courier, monospace;\n\tfont-size: 10pt;\n}\n-->\n</style>\n\n</head><BODY BGCOLOR=\"#FFFFFF\">\n<P><FONT size=\"2\" FACE=\"Goudy Old Style\">INFORMATICS 41 &bull; DAVID G. KAY &bull; UC IRVINE &bull; FALL 2011</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\" SIZE=6><B>Lab Assignment 8 </B></FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">This assignment is due at the end of lab on\nWednesday, November 23, which is the day before Thanksgiving. </FONT></P>\n<P>\n<FONT FACE=\"Goudy Old Style\">Choose a partner for this twelve-day assignment, someone\nyou haven&#39;t worked with already. Choose someone whose Thanksgiving schedule is compatible with yours; if you won't be here for lab on the day before Thanksgiving (when the lab is due), pick someone who's able to work with you for a few extra out-of-lab hours before then.</FONT></P>\n<P><font face=\"Goudy Old Style\"><B>(a)</B> We have <a href=\"http://www.ics.uci.edu/~kay/scheme/infx-tunes.rkt\">posted some code</a> to implement parts of a music-playing application like iTunes.  This is similar to the code we developed in class. You should download, install, and run this code now. And then you should read it. Reading code is an important skill,  one that beginning programmers ignore all too often. Sure, code isn't as easy to read as a novel; you need to go over it carefully and ask yourself what it does and how it works. Don't let this intimidate you! Just take it one function at a time.</font></P>\n<P><font face=\"Goudy Old Style\">We used  the following data definitions to define a music collection in the form of \"albums of songs\":</font></P>\n<BLOCKQUOTE>\n  <P><font face=\"Goudy Old Style\"> A <I>music collection</I> is a list of albums.<BR />\n    An <I>album</I> is a number (a unique ID number), a string (the artist's name), a string (the title), a number (the year), and a list of songs.<BR />\n    A <I>song</I> is a  number (the track number), a string (the title), a number (the length in seconds), and a number (the play count, indicating how many times the song has been played).</font></P>\n  <p><FONT FACE=\"Goudy Old Style\">These data definitions led us to write these structure definitions:</FONT></p>\n  <p class=\"style2\">(define-struct album (id artist title year songs))<br />\n    (define-struct song (track-num title length play-count))</P>\n</BLOCKQUOTE>\n<P><FONT FACE=\"Goudy Old Style\"><B>(a.1)</B> We wrote a function called <TT class=\"style2\">top-10-songs</TT>, which finds the songs in a music collection that have the ten highest play counts.  Generalize this function as <TT class=\"style2\">top-n-songs</TT>, which takes a number <I>n</I> and a list of albums and returns a list of the <i>n</i> songs with the highest play count.  This is simple given the existing code.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(a.2)</B> Write a function <TT class=\"style2\">unplayed-songs</TT>, which takes a list of albums and returns a list of the songs that have never been played.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(a.3)</B> Write a function <TT class=\"style2\">favorite-album</TT>, which takes a list of albums and returns the album that is the \"favorite.\"  We'll define the \"favorite\" album to be the one that the user has spent the most time listening to.  (Hint: The total time the user has spent listening to an album is a function of the play counts and song lengths.)</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\">Try to work out this function out together; that's how you learn. Use the following hints only if you're totally stuck (and then take them just one at a time): (i) Write a function <code>song-listening-time</code>, which takes a single song and returns the total number of seconds the user has spent listening to it (see the hint above). (ii) Write a function <code>album-listening-time</code>, which returns the total listening time for all the songs in an album together. (iii) Write a function <code>album-listening-time&gt;?</code>, which takes two albums and returns true if the total listening time of the first album is greater than the total listening time of the second. (iv) Use <code>quicksort</code> and <code>first-n</code> and the functions you defined to implement <code>favorite-album</code>.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(a.4)</B> Time spent listening to an album isn't the only metric for defining a \"favorite\" album.  Generalize your <TT class=\"style2\">favorite-album</TT> function so that it takes another argument, a \"favorite measurement function\"; that way, <TT class=\"style2\">favorite-album</TT> can be called with any metric for determining the favorite.  (Before you get too far, consider what the appropriate contract for the favorite function might be, if the goal is to find the one and only favorite, rather than a list of many albums that the user likes.)  Add a comment after your generalized function that suggests, in English, at least two other ways to define a favorite album; show, for each of your suggestions, how you would call your generalized function to find the favorite album according to your suggestion.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(a.5)</B> One useful option that iTunes provides is a \"Search\" box, into which you can type a keyword, and iTunes will automatically search your collection for songs containing that keyword in their title, their artist, or their album's title.  Implement a function <TT class=\"style2\">music-search</TT> that does the same, returning a list of matching songs given a string containing the search keyword.  (You'll likely find the <a href=\"http://www.ics.uci.edu/~kay/scheme/strings.scm\">string processing code</a> from Lab 6 helpful; in fact, this entire task is quite similar to a task you did for Lab 6.)</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\">Submit your definitions via Checkmate.</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(b)</B> Three of the five functions you wrote in part <strong>(a)</strong> return a list of songs.  Unfortunately, our \"album of songs\" model for a music collection has a drawback: An individual song by itself doesn't contain enough information to display it usefully (on an iPod screen or on a web page, for example) because the album information is not included.  In the code, we solved this problem by introducing a new structure definition that combines information about a song and the album that contains it.  That definition looks like this:</FONT></P>\n<PRE class=\"style2\">\n    (define-struct song-display (artist a-title year track-num s-title length play-count))\n</PRE>\n<P><span class=\"style2\"><FONT FACE=\"Goudy Old Style\"></FONT></span><FONT FACE=\"Goudy Old Style\">Rewrite <TT class=\"style2\">top-n-songs</TT>, <TT class=\"style2\">unplayed-songs</TT>, and <TT class=\"style2\">music-search</TT> so that they each return a list of song-displays, rather than a list of songs.  (Note that if you solved <TT class=\"style2\">top-n-songs</TT> and <TT class=\"style2\">unplayed-songs</TT> using a similar technique to the one we used for <TT class=\"style2\">top-10-songs</TT>, you'll find that you don't have to change very much of your existing code to make this work.  On the other hand, it's likely that <TT class=\"style2\">music-search</TT> can be significantly simplified.)</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\">Submit your definitions via Checkmate.</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(c)</B> We have talked often in class about how the model (the data structure) that you choose to represent your data can  have a profound impact on how hard it is to operate on that data&mdash;how difficult it will be to write the code and also how much time it will take for the computer to execute it.  Sometimes, the data model you choose may even make some tasks impossible or too inefficient (e.g., you can't search an unordered list in logarithmic time).</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\">Let's consider three ways that we might model a music collection.  (This is hardly an exhaustive list, but it includes three alternatives that are available to us based on what we've learned so far this quarter.)</FONT></P>\n<OL>\n  <LI class=\"style1\">The \"album of songs\" model we used in parts <strong>(a)</strong> and <strong>(b)</strong>, where a music collection is a list of albums, each of which contains a list of songs.</LI>\n  <LI class=\"style1\">The \"list of songs\" model, where a music collection is represented as a list of song-displays, using the definition of song-display from part <strong>(b)</strong>.</LI>\n  <LI class=\"style1\">The \"BST of albums of songs\" model, where a music collection is a binary search tree of albums, each of which contains a list of songs, implemented using the following structure definitions: \n      <PRE class=\"style2\">\n    (define-struct node (value left right))\n    (define-struct album-info (id artist title year songs))\n    (define-struct song-info (track-num title length play-count))</PRE>\n      Each node in the binary search tree contains one album as its value.  The albums are sorted in order by the albums' names.  An empty binary search tree is represented by <span class=\"style2\">empty</span>.</LI>\n</OL>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(c.1)</B> Using the \"albums of songs\" model, write the function <TT class=\"style2\">album-names</TT>, which takes a music collection and returns a list of the names of all albums in the collection.</FONT>\n</p><P> <FONT FACE=\"Goudy Old Style\"><B>(c.2)</B> Write the <TT class=\"style2\">album-names </TT>function again, this time so it takes a music collection in the \"list of songs\" model.  A particular album name should only appear once in the output list.</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(c.3)</B> Write the <TT class=\"style2\">album-names</TT> function one more time, this time so it takes a \"BST of albums of songs.\"</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(c.4)</B> All three of these functions have the same basic contract&mdash;take a music collection as input and return a list of the names of all the albums in the collection&mdash;but they differ in terms of how they expect the collection to be organized.  Will all three functions give the same output if given the same input collection?  If not, what will be different about the output of one as opposed to the others?  What does your answer to these questions suggest about which of the models are appropriate to use in an actual music application like iTunes?</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(c.5)</B> Which of the models would you expect to enable the best implementation of a <TT class=\"style2\">find-album</TT> function, if we measure \"best\" based on which one will run the fastest if given a music collection with tens of thousands of albums in it?  Why?</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\">Collect your definitions and your answers to <strong>(c.4)</strong> and <strong>(c.5)</strong>, expressed as comments, and submit them to Checkmate.</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(d)</B> (optional, but there's a required section after this) A favorite feature of iTunes is the \"smart playlist\" feature.  Rather than selecting songs manually to include into a playlist, a \"smart playlist\" allows you to specify a set of qualities that a song can have&mdash;year of release, play count, artist, and so on&mdash;and then allow iTunes to select them for you, and even keep the list updated as your collection changes over time.  We can implement this easily in Scheme like this:</FONT></P>\n<PRE class=\"style2\">\n    (define smart-playlist\n      (lambda (quality-func collection)\n        (filter quality-func (all-song-displays collection))))\n</PRE>\n<P><FONT FACE=\"Goudy Old Style\">Recall that <TT class=\"style2\">all-song-displays</TT> is a function that takes a music collection and turns it into a list of <TT class=\"style2\">song-display</TT> structures.  (While our version takes an \"albums of songs\" collection and returned a list of song-displays, you could replace <TT class=\"style2\">all-song-displays</TT> with a function that takes a collection implemented using some other model and transforms it into a list of song displays.) The <TT class=\"style2\">quality-func</TT> parameter is a Scheme function that selects songs that have whatever quality defines our smart playlist.</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\">The challenge in implementing a \"smart playlist\" feature in Scheme is handling the quality function.  While you could easily implement a single quality function, the trick is that you'd like users to be able to specify multiple qualities&mdash;say, short songs about love written before 1970. We need a way to combine into one function a series of predicates (here, the length less than, say, 3 minutes; the title containing &quot;love&quot;; and the year less than 1970). One way would be to code up a Scheme function using </FONT><span class=\"style2\">and</span><FONT FACE=\"Goudy Old Style\">. We could do that by hand, but we'd like to design a more automated way.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\">Suppose we already have a user interface that prompts the user for smart playlist qualities.  You've seen this kind of thing: There's a pull-down menu for which field, a pull-down for the comparison operator, and a text field for the value to compare it with, for example. How might that user interface (part of the &quot;view&quot; portion of the program) represent each quality for the &quot;model&quot; part of our program to process? (The &quot;model&quot; part would then have to turn a list of these qualities into Scheme predicates and filter the songs by each item on the list in turn.) One way to represent the qualities (following a common programming idiom) is as &quot;quality-func-options&quot;: Each quality-func-option describs one kind of predicate, one kind of question we can ask about a song. Let's say that each quality-func-option will be one of these structures:</FONT></P>\n<P class=\"style2\"> ;; Songs played by a particular artist.<br />\n  (define-struct quality-func-artist-option (val))</P>\n<P class=\"style2\">;; Songs with a particular title.<br />\n  (define-struct quality-func-title-option (val))</P>\n<P class=\"style2\">;; Songs released between \"from-val\" and \"to-val\". <br />\n  (define-struct quality-func-year-option (from-val to-val))</P>\n<P class=\"style2\">;; Songs played at least a specified number of times. <br />\n  (define-struct quality-func-min-play-count-option (val)) </P>\n<P> <span class=\"style2\"><FONT FACE=\"Goudy Old Style\"></FONT></span><FONT FACE=\"Goudy Old Style\">Write a function called <TT class=\"style2\">make-quality-func</TT> that takes a list of quality-func-options and returns a function that takes a song-display and returns true if it is a \"quality\" song (according to the options given) or false if it's not.  When the list of qualities is empty, the quality function should always return true.  (Hint: The quality function ends up being a chain of functions, each one checking one quality and then calling the next function in the chain; there's one link in the chain for each quality option in the list.)</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\">Submit your definitions to Checkmate.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(e)</B> In DrRacket, vectors are available in the Advanced Student language. Change to that language in DrRacket and use it for the rest of the quarter.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\">As we discussed in class, a vector in Scheme is a linear data structure containing a collection of homogeneous items. Vectors are like lists, except that we can access any element of the vector (the first, the last, any one in between) in O(1) (constant) time. That's not true of lists, where to get to the end of the list we have to work our way down the list element by element, <span class=\"Code-in-Body\">(rest L)</span> after <span class=\"Code-in-Body\">(rest L)</span>; that's O(n) (linear) time. Vectors achieve constant-time access because they're stored in contiguous memory locations, so we can get the address of any element with one calculation (using the starting address of the vector, the element number, and the size of each element). In Scheme and related languages, lists are the most common structure for collections of data. In many other languages, including Java and C++, vectors (also called arrays) are the most commonly used structure for collections. Both language families offer both lists and vectors/arrays; it's just a question of which idiom is most common in which language.</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\">Figures 81 and 82 in the online version of <a href=\"http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-36.html#node_chap_29\">Chapter 29</a> of the <em>How to Design Programs</em> text show code for traversing a vector, processing each of its elements.  The code in the figures adds up the elements of  a vector of numbers, but we can use it as a framework for all kinds of vector processing. </FONT></P>\n<P><font face=\"Goudy Old Style\">Remember that in most modern programming languages, the elements of a vector are numbered starting at zero; we call this zero-based indexing. That means that <span class=\"Code-in-Body\">(vector-ref V 3)</span>, for example, returns the fourth element of V.</font></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(e.1)</B> Figures 81 and 82 show code that sums all the elements in a vector of numbers; Exercise 29.3.6 shows code that sums all the elements in a list of numbers. What's the O-notation for the execution time of the vector-based code? What is it for the list-based code (noting, as the exercise states, that a call to <span class=\"Code-in-Body\">list-ref</span> is O(n))?</FONT></P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(e.2)</B> Define this function:</FONT></P>\n<P class=\"style2\">;; vector-contains-turkey?: vector-of-string -&gt; boolean<br />\n;; Return true if the string &quot;turkey&quot; appears anywhere in the vector, and false otherwise</P>\n<P><span class=\"Code-in-Body\"><FONT FACE=\"Goudy Old Style\">N</FONT><FONT FACE=\"Goudy Old Style\"></FONT></span><FONT FACE=\"Goudy Old Style\">ext, generalize the function to <span class=\"Code-in-Body\">vector-contains?</span> (which might also be called <span class=\"Code-in-Body\">vector-member?</span>):</FONT></P>\n<P class=\"style2\">;; vector-contains?: vector-of-string string -&gt; boolean<br />\n;; Return true if the string appears anywhere in the vector, and false otherwise</P>\n<P><FONT FACE=\"Goudy Old Style\">Next, write a function that says <em>where</em> an item occurs in a vector. It will be easiest if you start at the right end and count downwards.</FONT></P>\n<P class=\"style2\">;; vector-position: vector-of-string string -&gt; number<br />\n;; If the string appears in the vector, return its position number (zero-based).<br />\n  ;; If not, return -1.</P>\n<P><FONT FACE=\"Goudy Old Style\">Finally, write a function that counts the number of times an item occurs in a vector:</FONT></P>\n<P class=\"style2\">;; vector-occurrences: vector-of-string string -&gt; number<br />\n  ;; Return the number of times the string occurs in the vector</P>\n<P><FONT FACE=\"Goudy Old Style\"><B>(e.3)</B> Define the function <span class=\"Code-in-Body\">vector+</span> as described below. The easiest way will be to use <span class=\"Code-in-Body\">build-vector</span>. Think of this function using this scenario:  You have a class of 47 students, each student\n    takes a two-problem quiz, and all the students&#39; scores for a given problem\n    are stored in a 47-element vector (with the score for Student 1 in the first\nelement, Student 2 in the second, and so on).  Then </FONT><font face=\"Courier New\" size=2>vector+</font><font face=\"Goudy Old Style\"> produces a 47-element vector with the total score on the quiz for each student.</font></P>\n<P class=\"style2\">;; vector+: vector-of-number vector-of-number -&gt; vector-of-number<br />\n  ;; Return a vector containing the sum of the corresponding elements in the input vectors</P>\n<P><FONT FACE=\"Goudy Old Style\">Next, define the function </FONT><FONT FACE=\"Courier New\" SIZE=2>total-quiz-scores</FONT><FONT FACE=\"Goudy Old Style\"> that takes as input a list of score vectors as described above (representing\n  the scores on problems 1 through <I>n</I> of some quiz) and returns a vector\n  containing the total scores for each student on the quiz.  [Hint:  What\n  pattern/template do you use to process a list of anything?  Second hint:\nDraw a picture of this data structure to help you see how it&#39;s organized.]</FONT></P>\n<!-- Dropped due to Thanksgiving holiday\n<P>\n<FONT FACE=\"Goudy Old Style\">Finally, define the function </FONT><FONT FACE=\"Courier New\" SIZE=2>weighted-scores</FONT><FONT FACE=\"Goudy Old Style\">\nthat takes a list of score vectors (like the ones above) and a list of numbers\nthat&#39;s the same length as the list of vectors.  If the score vectors\nrepresent, for example, students&#39; overall score on the homeworks, the\nmidterm, and the final, then the number vector might contain 40, 25, and\n35, representing that the assignments are worth 40% of the course grade,\nthe midterm 25%, and the final 35%.  Your function should return a vector\nof overall course scores, computed according to the specified weights. \n(You may assume that the numbers in the number list sum to 100.)</FONT></P>\n-->\n<P> <FONT FACE=\"Goudy Old Style\">Submit your definitions via Checkmate.</FONT></P>\n<P> <FONT FACE=\"Goudy Old Style\"><B>(f)</B> Remember that each partner must\n  complete a partner evaluation form via the Survey tool on <code>eee.uci.edu</code>.  Please\n  do this as soon as you complete and submit the lab.</FONT><BR />\n</P>\n<P> <FONT FACE=\"Helvetica\" SIZE=1>Based in part on ICS H21assignments by David\n  G. Kay; modified by David G. Kay for the Informatics Core Course, Fall 2004, Fall 2005, Fall 2008, Fall 2009, Fall 2010. InfxTunes example by Alex Thornton.</FONT></P>\n<HR />\n<FONT FACE=\"Goudy Old Style\"><A HREF=\"http://www.ics.uci.edu/~kay/\">David G. Kay</A>, <a href=mailto:kay@uci.edu>kay@uci.edu</A> </FONT><span><br />\n<font size=\"2\" face=\"Goudy Old Style\">\n<!-- #BeginDate format:fcAm1a -->Thursday, November 10, 2011 10:15 AM<!-- #EndDate -->\n</font></span>\n</BODY>\n</HTML>\n\n\n", "encoding": "ascii"}