{"url": "https://www.ics.uci.edu/~eppstein/261/s13-hw4-answers.txt", "content": "CS 261, Spring 2013, Homework 4 Due Thursday, May 9\n\n\n1. Suppose that a binary heap contains the four values 1, 2, 3, and 4\n(with smaller numbers meaning higher priority). List all of the\npermutations of these values that represent valid configurations of the\nheap.\n\n    1234, 1243, and 1324\n\n\n2. Suppose that we have a binary heap with n numbers in it, again with\nsmaller numbers meaning higher priority. We know that the minimum of the\nnumbers is in position 0 of the heap. How many different positions could\npossibly hold the maximum of the numbers? (You should assume that all\nthe numbers are different from each other.)\n\n    ceiling(n/2). Using the formulas left child = 2x+1, right child =\n    2x+2, it is easy to see that the final ceiling(n/2) cells of a\n    binary heap are the cells that don't have any children, and the\n    maximum could be in any one of those cells.\n\n\n3. Consider the following naive representation of a priority queue: we\nrepresent the queue as a dynamic array of the data values, with no\nconstraints on how they are ordered. To find the minimum value, we\nsearch through the whole array.\n\n(a) What are the amortized time bounds for the add, decrease priority,\nand delete min operations in this structure? Give your answers in\nO-notation as a function of n, the number of values in the priority\nqueue.\n\n    add: O(1) (just add it to the end)\n    decrease priority: O(1) (assuming you have some way of going\n        from the item whose priority you want decreased to its\n        position, e.g. using a separate hash table).\n    delete min: O(n) (because you have to find the minimum first)\n\n(b) If we are using a priority queue to implement Dijkstra's shortest\npath algorithms, are there graphs for which this naive method would lead\nto a total time bound that is the same as or better than the bound given\nby using Fibonacci heaps? If yes, describe these graphs. If no, explain\nwhy not.\n\n    Yes: the graphs with Omega(n^2) edges. In these graphs,\n    Dijkstra's algorithm takes Theta(n^2) time with either data structure.\n    But (if the priority queue is initialized to contain all vertices)\n    then these are the only graphs for which the naive method is good,\n    because it always takes Theta(n^2) time even for sparser graphs.\n\n    In office hours, one student pointed out a different answer: if the\n    priority queue contains only the vertices on the current frontier\n    (rather than all vertices, as the version of Dijkstra that I\n    described it in class uses) then the path graphs also take O(n) time\n    either way, because there are only O(1) vertices in the priority\n    queue at any time. More generally, the same idea would work whenever\n    the graph has the property that the average frontier size is O(m/n).\n    However, I don't know of a good description of the graphs for which\n    this is always true.\n\n\n4. Suppose that we perform the following two operations on a Fibonacci\nheap: first, create a new heap from a given set of n values, and second,\nperform a single delete-min operation. How many trees will there be in\nthe structure that we finish with, as a function of n?  (Hint: consider\nthe binary representation of n.)\n\n    There was a typo in the question: the last n should be n-1.\n    The answer is: the same as the number of nonzero bits in the\n    binary representation of n-1, because all of the trees have\n    sizes that are distinct powers of two.\n", "encoding": "ascii"}