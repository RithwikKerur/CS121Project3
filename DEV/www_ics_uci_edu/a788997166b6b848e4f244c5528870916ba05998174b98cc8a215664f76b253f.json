{"url": "https://www.ics.uci.edu/~kibler/javacourse/interfaces.html", "content": "<html>\n<head>\n<title>  Interfaces </title>\n</head>\n<body>\n<h1> Interfaces </h1>\n Problem: Suppose we have a collection of shapes and\n we want to sort them by their area.\n\n<p> Solution 1:   expand the definition of shape \n\n<pre>\n  abstract class Shape\n     { \n       double area();\n       double perimeter();\n       boolean lessThan(Shape shape)\n     {\n       return area() < shape.area() ;  // don't forget about implicit this.\n     }\n       void sort(Vector of shapes)\n      {\n          code for sorting\n       }\n     }\n   No changes to other code.\n</pre>\n\n<p>This will work, but now we can only sort shapes. Our same\nsort routine will not work for  addresses or any other objects.\n\n<p> The C++ solution would be to allow multiple inheritance, \n  but Java doesn't have multiple inheritance.\n\n<p>  The Java solution is to use interfaces, which \n    provide a limited type of multiple inheritance.\n\n<h2> Sketch of Java Solution using interfaces </h2>\n\n<pre>\n     interface Sortable\n    {   \n     boolean lessThan(Sortable o);\n     void sort(Sortable objects);\n    }\n     class Shape implements Sortable\n    {\n        \n        \n      ..as before\n      boolean lessThan(Sortable s)\n      {\n         return area() < s.area() ;\n      }\n  \n     no change to other classes\n     }\n</pre>\n\n<h3> Interface Summary </h3>\n<ul>\n   <li> Interfaces support programming by contract, one of the\n    principles in object-oriented design.\n   <li> Interfaces are design artifacts, while classes mix design\n     and implementation.\n   <li> An interface has no member or static member functions, only\n   function prototypes.\n   <li> An interface may have data members, which are automatically\n  static and final but some compilers may require you to declare this.\n   <li> Interfaces provide a limited form of multiple inheritance.\n   <li> Interfaces collect partial similarities between dissimilar objects.\n    It is would be strange to force all sortable objects into a hierarchy.\n   <li> Provides contracts for concrete classes to implement.\n   <li> Promotes hiding of irrelevant procedures.\n   <li> Promotes uniformity of code, increasing simplicity. \n   <li> A class can <em> implement </em> any number of interfaces.\n   <li> You cannot inherit methods from an interface.\n   <li> An interface may extend other interfaces.\n</ul>\n<h3> Standard Interface Enumeration </h3>\n This interface is in java.util.*.\n  <pre>\n\n     public abstract interface Enumeration\n  {\n     public abstract boolean hasMoreElements();\n     public abstract Object nextElement() throws NoSuchElementException;\n  }\n </pre>\n<h3> Example use of Enumeration </h3>\n\n <pre>\n      Vector v = new Vector();\n      ... fill up v with Shape objects\n      Enuermation e = v.elements();\n      while (e.hasMoreElements())\n        {\n          Shape temp = (Shape) v.nextElement();  // note cast\n          ... process temp\n        }\n </pre>\n   \n\n<ul>\n  <li> Interfaces permit increased comprehensibility and code sharing.\n  <li>Any class that implements this interface needs to define the\n   two methods above. \n  <li> StringTokenizer implements Enumeration\n  <li> Vector has a method elements() which returns an Enumeration.\n</ul>\n<h3>Complete Sortable Example  </h3>\nThis code illustrates appropriate commenting style. Comments of\nthe form //.. are explanatory and should not be included in the usual\ncode. This code also illustrates a few of the javadoc commands. Javadoc\ncommands are embedded in the comments and are preceded by @. This will\ngenerate documentation similar to that of Sun's Java.api's.\n\n<pre>\npackage DataStructures;   //.. this allows you bundle related class \n                         //.. and access them via import\npublic interface Sortable\n{\n  /**\n  * Returns 0 if objects equal,\n  * Returns value less than 0, if object is < tobeCompared\n  * Returns value greater than 0, if object is > tobeCompared\n  * @param toBeCompared is the object to be compared\n */\n\n  public double compare(Sortable toBeCompared);\n}\n\npackage DataStructures;\nimport java.util.Vector;   //.. that's all were using from java.util\n\npublic class Sort\n{\n  /*\n   * Sorts a vector using bubbleSort.\n   * Bubble sort is best if number of elements is small or\n   * is elements are \"almost\" sorted.\n   * In worst case, bubble-sort is quadratic in number of elements.\n   * @param toBeStored is vector of sortable objects.\n  */\npublic static void swap(Object o1, Object o2)\n{\n    Object temp = o1.clone();  //.. Why  necessary? Efficiency? \n    o1 = o2;\n    o2 = temp;\n}\n\npublic static void bubbleSort(Vector toBeSorted)\n{\n  int n = tobeSorted.size();\n  for (int i = 0; i < n;  i++)\n     for (int j = i+1; j < n; j++)\n       if ( toBeSorted.elementAt(j).compare(toBeSorted.elementAt(i) ) < 0)  \n              swap(toBeSorted.elementAt(i),toBeSorted.element(j));\n}\n    \npackage DataStructures;\n /*\n * Class that implements sortable double\n */\n\npublic class SortDouble implements Sortable\n{\n  /* Constructs a SortDouble  object\n   * @param val is double value\n  */\n\n  public SortDouble(double val)\n  {\n     this.value = val;\n  }\n  public double val()\n {\n    return value;\n }\n\n public double compare(Sortable toBeCompared)\n {\n   return value - ((SortDouble) toBeCompared).val());\n }\n\n public boolean equals(Object toBeCompared)\n {\n  return value == ((SortDouble) toBeCompare).val();\n }\n\n}\n</pre>\n\n<h3> Packages </h3>\n <ul>\n    <li> A package is a collection of (usually) related classes and interfaces.\n    <li> The package name must be the same as the directory name, and\n      packages follow the directory structure. \n    <li> At  most one package per directory.\n    <li> If you do not define classes to belong to a package, then\n      they belong to an anonymous package common to the current  directory.\n    <li> The java compiler automatically imports the package java.lang.*\n    and the anonymous package.\n    <li> Packages are the method by which Java implements namespaces.\n    <li> The package java.util.* contains a number of miscellaneous\n     useful functions.\n    <li> Packages are created by prepending the line\n<br>   package packagename;\n <br> before your class definition.\n    <li> To use classes provided in JDK, you begin your code with\n      <br> import packagename;\n    <li> For example, the Date class is in java.util. To use this\n    class in your code, you use:\n  <br> import java.util.*;\n    <li> Any class which is designated as belonging to a package X\n    has access to all other classes of package X. It is as if\n    \"package X;\" expanded to \"import X; package X;\".\n   <li> The package java.lang.* contains the classes for\n  Object, Process, String, System, Thread, Wrappers, Boolean, Character, etc.\n  Since these classes are almost always used, java automatically\n   loads this package.\n  <li> Import is not the same as include in C or C++. Import defines\n    where to look for class definitions; none are loaded unless used.\n  <li> In order to share classes that you have created, you need\n   to properly set your CLASSPATH variable. This will be covered in\n  the lab as it is system dependent.\n  </ul>\n\n\n\n</body>", "encoding": "ascii"}