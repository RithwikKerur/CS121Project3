{"url": "https://www.ics.uci.edu/~ejw/authoring/requirements/vers-req-091296.html", "content": "<HTML>\r<HEAD>\r<TITLE>Functional Requirements and Framework for Versioning on the WWW</TITLE>\r</HEAD>\r<BODY>\r\r<H1>Functional Requirements and Framework for Versioning on the WWW</H1>\r<h2>David G. Durand and Fabio Vitali</h2>\r\r<h2>Changes from last version</h2>\r\r<UL>\r<LI>lock durations</LI>\r<LI>separate locking / resource reservation</LI>\r<LI>clarify/reorder points</LI>\r<LI>style-free versioning</LI>\r<LI></LI>\r</UL>\r\r<h2>Abstract</h2>\r\r<P>\rThis document describes the functional requirements for integrating\rversioning into the WWW.  Versioning is the fundamental basis of document\rmanagement systems, with far reaching effects on the semantics of document\ridentity and meaningful operations.  These requirements reflect\rthe basic versioning needs for document management and collaborative\rauthoring.  It does not define the complete set of requirements for these\rdomains where they extend beyond the versioning of resources.\r</P>\r\r<h2>1. Introduction</h2>\r<P>This document discusses why versioning is needed on the WWW, and the\rfunctional requirements for full version support.  We have divided the\rrequirements in three sections.  This discussion enumerates the reqirements\rfor implementing such functionality as a first step to creating a\rspecification that will address these needs.\r\r<p>We first briefly describe the rationale for versioning on the web in\rSection 2.  This rationale enumerates the goals of versioning on the WWW.\rAll specific requirements should support (and certainly should not hinder)\rthe realization of the goals.  Section 3 contains global requirements for\rprotocol development.  These are things we think are technically justified\rand that fulfil the rationale.  They are separated from the other\rrequirements because their acceptance creates further constraints on other\rtechnical requirements.  Finally, In Section 4, we specific functional\rrequirements based on the foundation established in the earlier sections.\r\r<p>We have based this effort on David Fiander's suggestion to separate\rversioning and configuration requirements, and we assume a two-layer\rarchitecture for versioning on the web.  The first layer, whose\rrequirements are defined in this document, will address the simple problem\rof <EM>handling multiple versions of single resources.</EM> The second\rlayer will address the thornier problems of configuration management for\rmultiple resources.  This layering simplifies both discussion and design.\r\r<H2>2. Rationale</H2>\r\r<P>Versioning in the context of the world-wide web offers a variety of\rbenefits:</P>\r\r<ol>\r<LI>It provides infrastructure for efficient and controlled\rmanagement of large evolving web sites.\r<br><br>Modern configuration management systems are built on some form of\rrepository that can track the revision history of individual resources, and\rprovide the higher-levelools to manage those saved versions. Basic\rversioning capabilities are required to support such systems.</li>\r<LI>It allows parallel development and update of single resources\r<br><br>Since versioning systems register change by creating new objects, they\renable simultaneous write access by allowing the creation of variant\rversions. Many also provide merge support to ease the revers operation.</LI>\r\r<LI>It provides a framework for access control over resources.\r<br><br>While specifics vary, most systems provide some method of\rcontrolling or\rtracking access to enable collaborative resource development.</LI>\r\r<LI>It allows browsing through past and alternative versions of a\rresource\r<br><br>Frequently the modification and authorship history of a resource is\rcritical information in itself.</LI>\r\r<LI>It provides stable names that can support externally stored links for\rannotation and link-server support.\r<br><br>Both annotation and link servers frequently need to store stable\rreferences to portions of resources that are not under their direct\rcontrol. By providing stable states of resources, version control systems\rallow not only stable pointers into those resources, but also well-defined\rmethods to determine the relationships of those states of a resource.</LI>\r\r<LI>It allows explicit semantic representation of single resources with\rmultiple states\r<br><br>A versioning system directly represents the fact that a resource\rhas an\rexplicit history, and a persistent identity across the various states it\rhas had during the course of that history.</LI>\r</ol>\r\r<H2>3. Global requirements</H2>\r\r<P>This section covers the overarching contraints that must\rinform and direct detailed requirements for versioning support.  They\rencompass compatibility across different implementations, as well as\rcompatibility with current practice.  Therefore, we believe the following\rto be the general requirements for WWW versioning:\r</P>\r\r<ol>\r<LI><EM>Stableness of versions.</EM>\r<br>\rMost versioning systems are intended to enable an accurate record of the\rhistory of evolution of a document.  This accuracy is ensured by the fact\rthat a version eventually becomes \"frozen\" and immutable.  Once a version\ris frozen, further changes will create new versions rather than modifying\rthe original.  In order for caching and persistent references to be\rproperly maintained, a client must be able to determine that a version has\rbeen frozen.  We require that unlocked resource versions be frozen.  This\renables the common practice of keeping unfrozen \"working versions\".  Any\rsuccessful attempt to retrieve a frozen version of a resource will always\rretrieve exactly the same content, or return an error if that version (or\rthe resource itself) are no longer available.  Since URLs may be\rreassigned at a server's discretion this requirement applies only for that\rperiod of time during which a URL identifies the same resource.\r</li>\r<br>\r<LI><EM>User Agent Interoperability.</EM>\r<br>\rAll versioning-aware user agents should be able to work with any\rversioning-aware HTTP server.  It is acceptable for some user agent/server\rcombinations to provide special features that are not universally\ravailable, but the protocol should be sufficient that a basic level of\rfunctionality will be universal.\r</li>\r<li><em>Style-free Versioning</em>\r<br>\rThe protocol should not unnecessarily restrict version management style to\rany one paradigm.  For instance, locking and version number assignment\rshould be interoperable across servers and clients, even if there are some\rdifferences in their preferred models.\r\r<LI><em>Separation of access to resources and access control</em>\r<br>\rThe protocol must separate the reservation and release of versioned\rresources from their access methods.  Provided that consistency constraints\rare met before, during and after the modification of a versioned resource,\rno \"right way\" to access to a resource is enforced by the protocol.  For\rinstance, a user may request declare an intention to write after a GET, may\rPOST a resource without releasing the lock, and might even request a lock\rvia HTTP connection while getting the document via FTP.</LI>\r\r<LI><EM>Legacy Resource Support.</EM>\r<br>\rThe protocol should enable a versioning aware server to work with existing\rresources and URLs.  Special versioning information should not become a\rmandatory part of HTTP protocols except where it is required.  Special\rversion information that would break existing clients and servers, such as new\rmandatory headers, cannot therefore be required for GET (and possibly also for\rPUT).\r</LI>\r\r<LI><EM>Legacy User Agent Support.</EM>\r<br>\rServers should make versioned resources accessible to versioning-unaware\ruser-agents in a format acceptable to them.\r</LI>\r\r<li><EM>Specific named version URLs that are constructed from a URL\rand an opaque version string</EM>\r<br>\rBecause the notation will be required to operate in the version control\renvironment preferred by the website maintainer, it must be able to\rproperly contain arbitrary strings, which may be used by the VCS as version\ridentifiers.  While version information may be intelligible to the human\roperator, and perhaps to special-purpose clients, the client must be\rable to treat the version specifier as a black box.\r</li>\r</ol>\r\r<H2>4. Functional requirements</H2>\r<p>The following functional reqirements are intended to satisfy the global\rrequirements of Section 3 and enable the benefits listed in Section 2.  The\rmention of possible new HTTP methods is intended to make the discussion\rclearer and more concrete, not to rule out other methods of meeting the\rrequirements.\r\r<P>The protocol should provide:</P>\r\r<ol>\r<LI><em>Access to specific named versions via a URL</em>\r<br>\rThis is required for version-specific linking, and for legacy user-agent\rsupport.</li>\r\r<li><em>A URL to denote a versioned resource itself, rather than specific\rversions of it</em>\r<br>\rThis is more important if URL computations are not allowed, since an\ridentifier is needed for queries about the versioning status of a resource.\rThis is used to perform operations (such as adjusting attributes, changing\rlocks, or reassigning URLs) that affect all versions of a resource, rather\rthan any specific version.\r</li>\r\r<LI><EM>Direct access to a server-defined \"default\", \"current\" or \"tip\" version\rof a resource</EM>\r<br>\rThis is one of the simplest ways to guarantee legacy user-agent\rcompatibility and legacy file compatibility.  If no special version URLs\rare used, the server will provide a default.  This does not rule out the\rpossibility of a server returning an error in case no such default exists.\r</LI>\r\r<LI><em>A way to access common related URLs from a versioned URL,</em>\rwhether by\rserver query, URL computation, or some other way:\r<UL>\r<LI>root version(s) of this document</LI>\r<LI>predecessor version(s) of this document</LI>\r<LI>successor version(s) of this document</LI>\r<LI>default version of this document</LI>\r</UL>\rSome versions of a resource are special.  It must be possible in some way\rfor a versioning-aware client to access common related versions to the one\rit currently is displaying.  Possible solutions include, but are not\rlimited to: the server automatically adding header fields to a versioned\rURL specifying the URL of the common related versions, the server providing\rone or more query methods (\"who is the previous version to this URL?\"), or\ra standardized way to compute related URLs when given a versioned URL. We\rfeel that access to the \"default\" version of a resource is an extremely\rimportant operation, that a browser should be able to perform at any time\rthat a versioned URL is seen.\r</strong></LI>\r\r<LI><EM>A way to retrieve the complete version topology for this resource</EM>\r<br>\rThere should be a way to retrieve information about all versions of a\rresource.  The format for this information must be standardized so that the\rbasic information can be used by all clients.  </LI>\r\r<LI><EM>Some way to determine that a\rURL points to a named version of a resource</EM>\r<br>\rThis might be implemented as part of the URL format, a server query or\radditional headers.\r</li>\r\r<li><EM>Some way to determine a version identification and a resource\ridentification for a versioned resource, given its URL</EM>\r<br>\rThis requirement describe the ability to take the URL of a version of a\rresource and determine:\r<ul>\r<li>a URL for the resource</li>\r<li>a version identifier for the resource.</li>\r</ul>\rNote that this kind of facility supports only some comparison operations: It\renables the determination that two version-containing URLs designate\rversions of the same resource.  However, given the phenomenon of URL\raliasing, it is insufficient to determine that they are <EM>not</EM>\rversions of the same resource.\r<br><br>\rThis is sort of a minimal \"browsing\rthrough time\" requirement.  Tthis requirement allows a browser to tell that a\rversioned resource has been accessed and then to invoke special versioning\ror configuration management operations on the resource.  While client\rperformance will be best if this can be done via URL computation (ie.\rmangling) it could also be done by an extra query and round-trip to\rthe server.</LI>\r\r<LI><EM>A way to request exclusive access to a version of a resource\r(LOCK)</EM>\r<br>\rSince not all systems implement lock-based access there is a\rquestion as how this should be implemented. Client use of this\rmethod could be optional, allowing some relatively strong guarantee on the\rmeaning of acquiring a lock.  Alternatively, clients could be expected to\rtake a lock, but servers might implement different locking policies\r(possible even including implementation of LOCK and UNLOCK as NOPS).\r</LI>\r\r<li><EM>A way to specify a timeout after which a lock will lapse</EM>\r<br>\rIn many cases, locks over a certain duration are due to errors, and their\rstrict enforcement can cause more problems than inadvertent version skew.\rWe should allow locks to have a lifetime.  It <EM>may</EM> prove a good idea to\rhave a finite default lifetime defined by the protocol.  If a universal\rdefault is too constraining, there should be a way for a server to inform\rthe client what the lifetime of a lock is.  Servers should honor client\rlock lifetime requests, or inform them if the request is denied.\r\r<LI><EM>A way to release exclusive acccess to a resource (UNLOCK)</EM>\r<br>\rThis is the inverse of LOCK.</LI>\r\r<li><em>A way for a client to declare an intention to modify a resource\r(RESERVE or CHECKOUT?)</em>\r<br>\rThis operation is required before any versioned update.  Its effects may\rvary depending on server policy, from locking a resource, to forking a new\rvariant, to a NOP on servers that do not track sessions or restrict\rupdates.  If this operation returns a version number, the client is\rrequired to make sure that it uses a copy of the data associated with that\rversion number of the resource for any update operations it carries out.\rServers that wish to enforce a mandatory GET operation before update, should\rsimply use a fresh version identifier on the return from this operation.\r</li>\r\r<li><em>A way to declare the end of an intention to write a resource</em>\r<br>\rThis is the inverse of RESERVE.  Typically, servers will commit\rupdates at this time, and return a final version identifier if possible\rand if it was not already returned.</li>\r\r<LI><EM>A way to submit a new version of a resource (PUT)</EM>\r<br>\rThe server should be able to attach it to the correct part of the version\rtree, based on the version number associated with the resource before its\rmodification.\r</li>\r\r<LI><em>A way for a user-agent to request a version identifier for a checked\rout version.</em>\r<br>\rSuch an identifier will not be used by any other\ruser-agent in the meantime.  The server may refuse the request.</LI>\r\r<li><EM>A way for a client to propose a version identifier upon\rsubmitting a version of a resource</EM>\r<br>\rThe server may refuse to to use the client's suggested version identifier.\r</LI>\r\r<li><em>A way for a Client to supply metatdata to be associated with a\rversion</em>\r<br>\rThe kinds of data supplied here might be simple textual comments or more\rstructured data.  An ability to attach aritrary fields and content is\rprobably required, but a standard set of attributes that would enable\rinteroperation would be useful.  For basic versioning we need only specify,\rfor example, that comments are attached as the message-body of the operation\rthat releases a write intention.  The special formats for structured metadata\rcan then be handled by using content-type negotiation, and the\rcontent-types defined as part of the Configuration Management layer.\r</li>\r<li><em>A way for a server to provide a version identifier to be used for a\rresource in further operations/</em>\r<br>\rThis general requirement notes that version aware clients are responsible\rfor providing the appropriate version identifier for a resource that is\rbeing manipulated.  In particular, if a resource is being modified, any\rserver provided version must be used when submitting an update.  This\rallows servers to track active sessions (however they may be implemented by\rthe server) by assigning version identifiers when documents are retrieved,\rlocked, or reserved.\r</li>\r</ol>\r\r<p>The following discussion of possible implementations of the requirements\rabove is intended to aid understanding of the requirements.  It is\r<em>not</em> a statement that a particular implementation is a requirement\rfor basic versioning, but an explanation of how the separation of concerns\rmight improve the final implementation architecture.\r\r<p>The requirements on reservation and PUT take care some key global\rrequirements: version access is logically separated from access control\r(RESERVE/RELEASE) and updating.  In terms of traditional CM, a CHECKOUT is a\rRESERVE followed by a GET and a CHECKIN is a PUT followed by an RELEASE.  By\rseparating access control (locking and unlocking of resources) from\rmodification of resources, we achieve a great deal of versioning-style\rindependence.\r\r<p>We also have very flexible options for the negotiation of\rversion identifiers depending on server policy.  The version identifier of a\rnew resource can be negotiated between the user-agent and the server at 3\rpoints in time: when a lock is taken, when the lock is released, or when\rthe resource is POSTed.  Session tracking can be implemented by using\rspecial version identifiers for RESERVE and RELEASE.  All version\ridentifier negotiation follows a simple rule: \"the client proposes, but the\rserver disposes.\"\r\r<h2>Acknowledgements</h2>\r<p>This document is a result of the vigorous and valuable discussion on the\rVersioning on the Web <A HREF=\"mailto:www-vers-wg-request@ics.uci.edu\">\r&lt;www-vers-wg-request@ics.uci.edu&gt;</A>, and the Distributed Authoring\r<A\rHREF=\"mailto:w3c-dist-auth-request@w3.org\">&lt;w3c-dist-auth-request@w3.org&\rgt;</A>\rmailing lists.  All the the interactions on these lists have been helpful,\ras have several conversations.\rDavid Fiander's initial requirements got us started and clarified several\rpoints .  Jim Whitehead provided useful criticism, some new points, and\rimpetus to get this thing out the door.  Yaron Golan and Christopher\rSeiwald provided extensive commentary and discussion.\r<p>The following list include the above and others who have also helped\reither with their postings, personal email or face-to-face discussions:\r\r<p>\rDan Connolly, World Wide Web Consortium, connolly@w3.org<br>\rRon Fein, Microsoft, ronfe@microsoft.com<br>\rDavid Fiander, Mortice Kern Systems, davidf@mks.com<br>\rRoy Fielding, U.C. Irvine, fielding@ics.uci.edu<br>\rYaron Goland, Microsoft, yarong@microsoft.com<br>\rDave Long, America Online, dave@sb.aol.com<br>\rHenrik Frystyk Nielsen, World Wide Web Consortium, frystyk@w3.org<br>\rLarry Masinter, Xerox PARC, masinter@parc.xerox.com<br>\rMurray Maloney, SoftQuad, murray@sq.com<br>\rChristopher Seiwald, Perforce Software, seiwald@perforce.com<br>\rJudith Slein, Xerox, slein@wrc.xeroc.com<br>\r</p>\r<h2>To Do</h2>\r\r<P>\rMandatory IETF formatting.  Proofread.  Spell check.  Sanity check.\r</P>\r\r</BODY></HTML>\r\r\r", "encoding": "ascii"}