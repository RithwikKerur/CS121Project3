{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/tuples/tuples.txt", "content": "\t\t\t\tTuples\r\n\r\nIn this lecture we will talk about regular and named tuples. The former is an\r\nimmutable version of lists; the later will be used briefly but superseeded by\r\nclasses we will learn how do define by then end of the quarter. We will also\r\nreview some odd & ends along the way: the .split/.join methods, comprehensions,\r\nand the meaning of *args as a parameter, and tuple assignments.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n.split/.join Review:\r\n\r\nFirst let's review a topic that is strictly about lists and strings: the\r\n.split/.join methods, which interconvert strings and lists in an interesting\r\nway. Let's start by looking at the headers of these methods, which are both\r\ndeclared in the str class.\r\n\r\nstr.split(long : str, splitter : str)   -> [str]\r\nstr.join (sep  : str, items    : [str]) -> str\r\n\r\nNote that we will use the notation [str] to mean a list where every element is\r\na string. Since str is a reference to an object representing the str class, then\r\n[str] really is a list we can write, containing this one value).\r\n\r\nBecause these are methods, we can all them two ways. First we can call .split\r\nas a method in the str class as\r\n\r\n  str.split('1 2 3 4',' ')\r\n\r\nbut we are more likely to call it using\r\n\r\n  '1 2 3 4'.split(' ')\r\n\r\nboth produce the list ['1', '2', '3', '4']. Of cours if the values in the first\r\nstring were separated by commas (or anything else) we could use commas to split\r\nthe values: '1,2,3,4'.split(',') still produces ['1', '2', '3', '4']. \r\n\r\nIn the comprehension section we will review a simple way to create the list\r\n[1, 2, 3, 4] from ['1', '2', '3', '4']: [int(i) for i in '1 2 3 4'.split(' ')]\r\n\r\nNow let's discuss .join, which we can also call two ways. First we can call\r\n.join as a method in the str class as\r\n\r\n  str.join(';',['1', '2', '3', '4'])\r\n\r\nbut we are more likely to call it using\r\n\r\n  ';'.join(['1', '2', '3', '4']).\r\n\r\nboth produce the string '1;2;3;4'. In the comprehension section we will review\r\na simple way to create '1;2;3;4' from [1, 2, 3, 4]:\r\n';'.join([str(i) for i in [1, 2, 3, 4]]).\r\n\r\nPractice using these methods. They are incredibly versatile, especially when\r\nused with comprehensions, which make it easy to interconvert betwee a\r\nlist-of-object and a list-of-str (and produce many other interesting lists).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nTuples:\r\n\r\nA tuple is like an immutable list, written within () instead of []: that pretty\r\nmuch says everything you need to know about tuples, except why do we need an\r\nimmutable version of a list (which we will see next week when we discuss sets\r\nand dictionaries, which require immutable components).\r\n\r\nSo, all the standard things like len, indexing, slicing (both operations still\r\nuse []), checking containment, catenation, mutliplication, and iterability\r\n(items 1-7 in the list lecture) work as you expect with tuple. Also the\r\nfunctions index, count, and choice. But we cannot use any operators or functions\r\nto change/mutate a tuple.\r\n\r\nI will mention a few other needed facts: the first shows how to interconvert\r\nbetween lists and tuple with the same values. We have already examined how to\r\nuse the list function to convert any iterable into a list, for example:\r\n\r\nlist('abc')        is   ['a', 'b', 'c']\r\nlist(range(1,5))   is   [0, 1, 2, 3, 4]\r\n\r\nBecause tuples are iterable, list ((1, 2, 3)) is [1, 2, 3].\r\n\r\nLikewise\r\n\r\ntuple('abc')        is   ('a', 'b', 'c')\r\ntuple(range(1,5))   is   (0, 1, 2, 3, 4)\r\ntuple([1, 2, 3])    is   (1, 2, 3)\r\n\r\nIn all cases, we call the tuple function on something that is iterable, and it\r\nproduces a tuple of all those values.\r\n\r\nAlso, note that (1) is NOT a tuple: it is an expression with 1 in parentheses.\r\nTo write a singleton tuple (a tuple storing a single value: its len is 1) we\r\nmust write (1,); likewise, when Python prints a singleton tuple it prints\r\nthe value single in parentheses, followed by a comma. Verify this fact in the \r\nPython interpreter\r\n\r\nFinally besides creating lists of lists and tuples of tuples, we can create\r\nlists of tuples or tuples of lists, etc.\r\n\r\n  (1, [2, 3], 4)\r\n  [1, (2, 3), 5]\r\n\r\n------------------------------------------------------------------------------\r\n\r\nnamedtuple\r\n\r\nA named tuple is similar to a regular tuple, except that we associate a name\r\nwith every index in the tuple (and use the name instead of the index).\r\n\r\nTo use the namedtuple function we must first import it, typically as follows\r\n\r\nfrom collections import namedtuple\r\n\r\nHere is an example of how we use named tuples.\r\n\r\nPoint = namedtuple('Point', 'x y')\r\norigin = Point(0.,0.)\r\nunit   = Point(1.,1.)\r\nprint(origin,unit)\r\nprint(origin.x,unit.y)\r\nprint(origin[0],unit[0])\r\nprint(origin.z)\r\n\r\nwhich prints:\r\n\r\n   Point(x=0.0,y=0.0) Point(x=1.0,y=1.0)\r\n   0.0 1.0\r\n   0.0 1.0\r\n\r\nand then raises an exception:\r\n\r\n   AttributeError: 'Point' object has no attribute 'z'\r\n\r\nmeaning that when trying to print origin.z, this object (constructed from the\r\n'Point' class, has no such attribute. In fact, origin[2] would raise a similar\r\nexception: IndexError: tuple index out of range because Point tuples contain\r\nonly two values (indexed by 0 and 1)\r\n\r\nAlso, if we try to write origin.x = 1.0 or origin[0] = 1.0 Python will raise an\r\nexception: AttributeError: can't set attribute, because we are dealing with a\r\ntuple which is immutable. But, we can call a function that returns a new\r\nnamedtuple with certain values substituted for others; this is similar to how\r\nfor strings s = 'abc', callins s.upper() doesn't mutate s, it returns 'ABC'.\r\n\r\np1 = origin._replace(x=2)\r\np2 = unit._replace(x=2,y=5)\r\nprint(p1,p2,origin,unit)\r\n\r\nprints:\r\n\r\nPoint(x=2.0,y=0.0) Point(x=2.0,y=5.0) Point(x=0.0,y=0.0) Point(x=1.0,y=1.0)\r\n\r\nSo, the namedtuple function takes two string arguments (the name for the entire\r\ntuple and the names for the fields/indexes in the tuple) and  returns a\r\n\"factory\": an object that we can use to construct namedtuples, by using the\r\nfirst name (here Point) and supplying values for all the fields (here two: x\r\nand y).\r\n\r\nWe conventially bind the result of calling named tuple to the same name that\r\nappears in the string as the first argument.\r\n\r\nThe namedtuples created will print as shown above, and we can index them by\r\nints (as with regular tuples) or names. With ._replace we can create new\r\nnamedtuples that are variants of existing ones.\r\n\r\nAs another example, we could write\r\n\r\nStudent = namedtuple('Student', 'name id year gpa')\r\na_student = Student('Anteater, Peter', 123456789, 2, 3.5)\r\nprint(a_student)\r\n\r\nPrints as: Student(name='Anteater, Peter', id=123456789, year=2, gpa=3.5)\r\n\r\nEven more intersting, we can create a list of students to represent a class\r\n(or a huge list of students to represent a school). Given such a list, we can\r\ncompute the average gpa for all the students in it as follows (using a simple\r\ncomposition of ideas about lists and named tuples). If we had many lists for\r\nmany courses/schools, we could use this function to see which courses/schools\r\nexhibited grade inflation.\r\n\r\ndef gpa_average(students : [Student]) -> float:\r\n    gpa_sum = 0\r\n    for s in students:\r\n        gpa_sum += s.gpa # or gpa_sum += s[3], which is much more cryptic\r\n    return gpa_sum/len(students)\r\n\r\nNotice that if we change the structure of the Student namedtuple to \r\nStudent = namedtuple('Student', 'last_name first_name id year gpa') the code\r\nabove (using s.gpa) would work; but the code using s[3] would now be computing\r\nthe average year in school, which is now the information at index 3 in each\r\nnamed tuple.\r\n\r\nFinally, we can layer lists and namedtuple to build quite complicated data\r\nstructures.\r\n\r\nStudent = namedtuple('Student', 'name id year gpa tests')\r\nClass   = namedtuple('Class',   'name number meeting faculty students')\r\nSchool  = namedtuple('School',  'name address year_started classes')\r\n\r\nWith these (and lists) we can create a list of Schools (for the US), such\r\nthat each School would have list of classes, and each class would have a list\r\nof students, and each student would have a list of tests. \r\n\r\n------------------------------------------------------------------------------\r\n\r\nMore tuple information:\r\n\r\nMost of the list functions we wrote work identically for tuples (but not the\r\nonese that mutate the list/tuple). We can alos return a tuple instead of a list\r\n(as we did in list_min_max).\r\n\r\nIf we specify *args as the name of a parameter, it means to put all the\r\nremaining non-named arguments into a tuple that is bound to args (yes, the *\r\nprefixes the parameter name and has this special  meaning). So, as we saw\r\n(and now we can understand), writing\r\n\r\ndef min(*args):\t     \t \t      def max(*args):\r\n    answer = args[0]\t\t          answer = args[0]\r\n    for x in args[1:]:\t\t\t  for x in args[1:]:\r\n        if x < answer:\t\t\t      if x > answer:\r\n            answer = x\t\t\t          answer = x\r\n    return answer    \t\t\t  return answer\r\n\r\nAllows us to write min(1, 3, 5) then args is bound to (1, 3, 5); both functions\r\niterate over args to find an extremal value. The print function is actually\r\ndefined like\r\n\r\ndef print(*args,sep=' ',end='\\n'):\r\n\r\nWhich allows us to specify any number of values to print (print converts each\r\ninto a str to print it), with the appropriate separation and line ending\r\ninformation.\r\n\r\nFinally we can write\r\n\r\n  (x, y) = (0, 1)\r\n\r\nWhich \"unpacks\" the tuple (0, 1) to bind its individual values to the names x\r\nand y. Thus, we can assign a tuple of values to a tuple of names, so long as\r\nboth tuples have the same length. We can actually simplify this form of\r\nassignment and write it as\r\n\r\n  x, y = (0, 1)\r\n\r\nwhich means the same as\r\n\r\n  x, y = 0, 1\r\n\r\nleaving the () off either the names on the left or value on the right.\r\n\r\nIf fact, this unpacking works for lists as well; we can write \r\n\r\n  [x, y] = [0, 1]\r\n\r\nand we can even mix lists and tuple so long as the lengths are the same. For\r\nexample, we can write\r\n\r\n  (x, y) = [0, 1]\r\n\r\nRecall the list_min_max function which returns a 2-list: the minimum value in\r\nit argument list followed by the maximum value. We can write\r\n\r\n  min, max = list_min_max([6, 3, 6, 2, 8, 7, 1])\r\n\r\nTo unpack the returned list into is min and max values.\r\n\r\nnote, writing\r\n\r\n   x = list_min_max([6, 3, 6, 2, 8, 7, 1])\r\n\r\nwould bind x to a 2-list.\r\n\r\nBut writing\r\n\r\n  x,y,z = list_min_max([6, 3, 6, 2, 8, 7, 1])\r\n\r\nraises an exception, because there are three names on the left but the function\r\nreturns a 2-list: Python doesn't know how to unpack it it. The exception will\r\nprint as\r\n\r\n  ValueError: need more than 2 values to unpack\r\n\r\n------------------------------------------------------------------------------\r\n\r\nComprehension on Tuples\r\n\r\nTuple comprehensions -using () instead of list comprehensions which use []- are\r\nunlike list comprehensions (and any other kinds of comprehensions that we will\r\nlearn about later in Python). Their properties allow for very efficient use of\r\nPython memory (space), but their use is a bit strange (and undestanding why is\r\na bit beyond the scope of this course).\r\n\r\nIf we write the following tuple comprehension -note the use of () not []\r\n\r\n  x = ( i**2 for i in range(0,5) )\r\n\r\nand then print(x), it prints\r\n\r\n  <generator object <genexpr> at 0x02EF3648>\r\n\r\nWhich means a tuple comprehension really is a special kind of function called\r\na generator. If we want, we can use conversion functions or standard for loops\r\nto iterate over such a comprehension:\r\n\r\n  tuple(x) produces the tuple (0, 1, 4, 9, 16)\r\n\r\nor \r\n\r\n  list(x)  produces the tuple [0, 1, 4, 9, 16]\r\n\r\nor \r\n\r\n  for a in x:\r\n      print(a)\r\n\r\nprints\r\n\r\n0\r\n1\r\n4\r\n9\r\n16\r\n\r\nBut, once we have iterated over a tuple comprehension in any way, we cannot\r\niterate over its values again. That is\r\n\r\n  x = (i**2 for i in range(0,5))\r\n  a = list(x)\r\n  b = list(x)\r\n\r\nresults in a = [0, 1, 4, 9, 16], but b = []\r\n\r\nBut, if we use two tuple comprehensions, we have no problem.\r\n\r\n  a = list( i**2 for i in range(0,5) )\r\n  b = list( i**2 for i in range(0,5) )\r\n\r\nresults in a = [0, 1, 4, 9, 16], and again b = [0, 1, 4, 9, 16].\r\n\r\nAlso, writing\r\n\r\n  c = tuple( i**2 for i in range(0,5) )\r\n\r\nresults in c = (0, 1, 4, 9, 16).\r\n\r\nbut notice that in the above we did not write\r\n\r\n  tuple( (i**2 for i in range(0,5)) )\r\n\r\nalthough both are equivalent. In the first, we call the conversion function\r\ntuple(...) and specify the tuple comprehension without an extra ().\r\n\r\nBOTTOM LINE:\r\n\r\nWe will discuss generators and tuple comprehensions much more in ICS-33. For\r\nICS-31, be aware that \r\n\r\n  1) tuple comprehensions are a bit strange (look here for their details)\r\n  2) writing a tuple comprehension inside tuple(...) produces a tuple of the\r\n       correct value (which is probably the only way you need to use tuple\r\n       comprehensions in ICS-31)\r\n\r\n\r\n\r\n", "encoding": "ascii"}