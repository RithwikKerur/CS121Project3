{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/iteratorclasses.txt", "content": "\t\t\tIterators via Classes\r\n\r\n\r\nIn this lecture we will first learn how to fix a problem (related to sharing\r\nobjects) with the prange class that we wrote in the last lecture. We will learn\r\nhow to return an object constructed from a NESTED CLASS inside __iter__ instead\r\nof returning self. Next, we look at a class that stores and manipulates data\r\n(histograms), and also allows iteration over its data. Finally, we will begin\r\nto explore functions and classes that DECORATE iterables: they take an iterable\r\nargument and produce another iterable, related but not the same as their\r\nargument, hence the term \"decorations\" (e.g., sorted and reversed are two\r\nexamples built into Python, but there are many other interesting and useful\r\nones).\r\n\r\nWe will finish the week with a lecture about a special kind of function-like\r\nobject called a generator function, which provides a simple and excellent\r\nmechanism for writing most iterators (and iterators that decorate iterators).\r\nAll this material will become even more important and useful when we spend a\r\nweek talking about inheritance among classes.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFixing a sharing problem with prange\r\n\r\nIn the last lecture, we discussed various classes that implemented the iterator\r\nprotocol (by implementing the methods __iter__ and __next__). Typically in these\r\ncases (for both the Countdown and prange classes) the main purpose of the class\r\nwas to create an object to iterate over once. That is, we processed objects from\r\nthese classes only (or primarily) by iterating over them. Contrast these classes\r\nto the list, tuple, set, and dict class: while we often iterate over these\r\nobjects, we also peform many other useful operations on them too: e.g.,\r\nexamining and/or updating data in them.\r\n\r\nOften we construct an object from Countdown and prange only to use it in a for\r\nloop: e.g., for i in prange(...) : .... We don't even bind this object to a\r\nname, so the objects are used just once in the for loop (which calls __iter__ on\r\nthem to start the iteration), and when the for loop finishes these objects\r\ndisappear, so they cannot be reused (no name refers to them).\r\n\r\nBut at the end of the last lecture we started discussing sharing, and we will\r\nstart our discussion here by looking at another example of sharing, and how to\r\nfix a defect in our first implementation of the prange class (so that it behaves\r\nmore like the real range class). Doing so will involve defining and constructing\r\na class nested in the prange class, whose sole purpose is to construct an\r\nobject for iteration: an object returned by __iter__ on which we can call\r\n__next__ . We will see that when we write iterators for other classes,\r\ncontrolling more complicated data, this same technique works nicely.\r\n\r\nTo illustate the defect, we first define the following function, which uses a\r\ndoubly-iterating comprehension to return all pairs of values produced by its\r\nsingle argument iterators. Here i1 and i2 are two objects that are iterable.\r\n\r\ndef all_pair(i1,i2):\r\n    return [(x,y) for x in i1 for y in i2]\r\n\r\nthis code is equivalent to\r\n\r\ndef all_pair(i1,i2):\r\n    answer = []\r\n    for x in i1:\r\n        for y in i2:\r\n            answer.append((x,y))\r\n    return answer\r\n\r\nSo, in the outer for loop we iterate over i1, and while we are doing this\r\niteration, we iterate over i2 in the inner for loop. The while loop translation\r\nof both for loops call __init__ on i1 and i2 respectively to get started.\r\n\r\nNow let's run this function in various interesting ways, with range/prange (in\r\none case, illustrating a difference in how these classes perform).\r\n\r\nr = range (3)\r\np = prange(3)\r\n\r\nprint(all_pair(r,p))\t# use range and prange\r\nprint(all_pair(p,r))\t# use prange and range\r\nprint(all_pair(r,r))\t# use only range,  but the same range object twice\r\nprint(all_pair(p,p))\t# use only prange, but the same range object twice\r\n\r\nThese four print statements produce the following results. Notice the first\r\nthree result are the same (producing tuples containing all pairs of the values\r\nin the range), but differ from the fourth (producing only the first of the\r\ntuples). The difference occurs when the same prange iterable argument is passed\r\nto both parameters.\r\n\r\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\r\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\r\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\r\n[(0, 0), (0, 1), (0, 2)]\r\n\r\nThe last use of p (using it twice in a call to all_pair) above produces the\r\nwrong results. The problem is that when __iter__ is called on the prange\r\nargument (the same object in the outer loop and innner loop), it returns the\r\nobject itself (self, on which __iter__ was called). So both loops are using\r\nthe SAME OBJECT to iterate over. And that object has just one attribute in\r\nwhich to store the state of the iteration (self.n).\r\n\r\nBoth for loops in the all_pair function share the iterator/object: the outer\r\nloop initializes it and calls next to get its first value (just 0); then the\r\ninner loop re-initializes it and calls next to get the values 0, 1, 2; when the\r\ninner for loop exhausts the iterator, it is also exhausted in the outer for\r\nloop (because the loops SHARE the same object and its n attribute is 3) so the\r\nouter loop immediately terminates too, after producing only 3 tuples from the\r\ninner loop). In summary, the problem is that we are doing nested/multiple\r\niteration on a single object: p.\r\n\r\nPython's standard range function doesn't suffer from problem, and we will fix\r\nour prange to operate likewise: when we call iter on range (and soon on prange)\r\nit will return a new/special object to iterate over. In nested iteration, iter\r\nis called twice so two new/different objects will participate in the iteration.\r\n\r\nAs a reminder, here is how prange defined __iter__ and __next__ in the previous\r\nlecture.\r\n\r\n    def __iter__(self):\r\n        self.n = self.start\r\n        return self          # return an object on which __next__ can be called\r\n    \r\n    def __next__(self):\r\n        if self.step > 0 and self.n >= self.stop or \\\r\n           self.step < 0 and self.n <= self.stop:\r\n            raise StopIteration\r\n        save = self.n\r\n        self.n += self.step\r\n        return save\r\n\r\n__iter__ sets a new attribute self.n (new because __init__ did not set it) and\r\nreturns self; __next__ (written in prange) uses this attribute name and the\r\nstop/step attrributes initialized in __init__ to advance the iterator. The\r\nproblem is that when all_pair tries to doubly iterate over the same prange\r\nobject it will be using the same object in the first/outer iteration as the\r\nsecond/inner iteration. When the second/inner iteration starts it calls __iter__\r\non the same object, it clobbers the state being maintained by the first/outer\r\niteration (because both are using the same prange object). When the inner \r\niteration finishes, Python returns to call __next__ for the outer iterations,\r\nand thinks the outer one is finished too (the one prange object being used has\r\nits self.n set to 3, beyond its last value, which is why the second/innner\r\niteration stopped). So, after generating (0,0), (0,1), and (0,2) and finishing\r\nthe inner iteration, Python thinks that the first/outer iteration has finished\r\ntoo.\r\n\r\nWe will now fix this problem.\r\n\r\nHere is how we do it. We define the local class prange_iter inside the __iter__ \r\nmethod. Every time that we call __iter__ (once in the outer loop, 3 times in the\r\ninner loop) Python creates a new/different object with its OWN STATE, so\r\nmultiple iterations on the same prange object don't interact badly with each\r\nother. Each loop calls __iter__ and each call creates/uses it own prange_iter\r\nobject with its own state. The prange_iter class has just three methods:\r\n__init__  to initialize it with the information needed to iterate over the\r\nprange object, __next__ to advance the iteration of the prange object, and\r\n__iter__: when we call __iter__ on an iterator it just returns that iterator\r\n(self).\r\n\r\nThe __init__ method defines the instance names n, stop, and step (note that\r\nstart is not needed: it is used only to initialize self.n); the __next__ method\r\nhas exactly the same code as the method above (but now applying to the\r\nattributes of the prange_iter object; of course, this code never referred to\r\nself.start). Calling __iter__ on an prange_iter object just returns itself.\r\n\r\nThe second/final line of code in the __iter__ method (after defining the class)\r\njust constructs and returns the necessary prange_iter object using the\r\nattributes of prange:\r\n\r\n  return prange_iter(self.start, self.stop, self.step).\r\n\r\nThis object is constructed from a class that implements __next__ (as required).\r\nThe __next__ defined is the same as before, but now in defined in prange_iter\r\ninstead of prange itself, and operates on the prange_iter attributes initialized\r\nin prange_iter's __init__.\r\n\r\n    def __iter__(self):\r\n\r\n        class prange_iter:\r\n            def __init__(self,start,stop,step):\r\n                self.n    = start\r\n                self.stop = stop\r\n                self.step = step\r\n\r\n            def __next__(self):\r\n                if self.step > 0 and self.n >= self.stop or \\\r\n                   self.step < 0 and self.n <= self.stop:\r\n                    raise StopIteration\r\n                save = self.n\r\n                self.n += self.step\r\n                return save\r\n\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return prange_iter(self.start, self.stop ,self.step)\r\n\r\nThe remaining examples in this lecture will contain code like this, with the\r\n__iter__ method defining a LOCAL or NESTED CLASS (with these classes defining\r\nonly __init__ and__next__ methods) and returning a new object constructed from\r\nthis local/nested class every time __iter__ is called on a prange object.\r\n\r\nThe total amount of code isn't much bigger, but it is certainly more complicated\r\nto define and use the nested class inside the __iter__ method (and think about\r\nit). Now every call to __iter__ on a prange objects returns a different object\r\nthat has a __next__, so two uses of the same prange object (as in all_pair(p,p)\r\nabove) will now work correctly. Note that __iter__ is called automatically\r\nmultiple times: once when each loop starts: 1 time for the outer loop, 3 times\r\nfor the inner loop for prange(2).\r\n\r\nOne more interesting observation: notice the difference between the following\r\n\r\nfor v in prange(10):\t       and           i = iter(prange(10))\r\n    .... \t\t       \t\t     for v in i\r\n    \t\t\t\t\t     \t ....\r\n\r\nWhen the first is translated into a while loop, it automatically calls iter on\r\na prange object; this is as expected. The second automatically calls iter on a\r\nprange_iter object (that is, after all, what iter(prange(10)) returns); this\r\ncall is handled by the __iter__ function defined INSIDE the prange_iter class,\r\nwhich just returns the same iterator created by calling iter(prange(10)).\r\n\r\nAnother approach would be to create a new object with the current values of\r\nprange_iter.\r\n\r\n            def __iter__(self):\r\n                return prange_iter(self.n, self.stop, self.step)\r\n\r\nThe real Python range uses the first approach. We can verify this by executing\r\nthe following code (which executes the first print statement, because i is j).\r\n\r\ni = iter(range(10))\r\nj = iter(i)\r\nif i is j:\r\n  print('__iter__ for range just returns self')\r\nelse: \r\n  print('__iter__ for range returns a new copy of iterator')\r\n\r\nWhat might this inner definition of __iter__ be useful for? Suppose that we\r\nwanted to ignore the first 10 lines in a file, and then print all the\r\nremaining lines. We could write this code using complicated while loops,\r\nbut we can also write it using simpler for loops, as follows:\r\n\r\ni= iter(open('file.txt'))    # iterator for opened file\r\n\r\nfor _ in range(10):          # 10 times\r\n    next(i)                  #   call next to advance iterator\r\n    \r\nfor line in i:               # iter(i) called in while translation returns i;\r\n    print(line.rstrip())     #  for remaining lines in i, print each line\r\n\r\nFinally, we could also write the following code, which declares prange_iter not\r\ninside __iter__ but in the prange class itself. The code for class prange_iter\r\nis identical (except outdented) but the call to __iter__ is now just one line\r\ncalling the constructor for this class.\r\n\r\nclass prange:\r\n    ....def of __init__\r\n\r\n    class prange_iter:\r\n        def __init__(self,start,stop,step):\r\n            self.n    = start\r\n            self.stop = stop\r\n            self.step = step\r\n\r\n        def __next__(self):\r\n            if self.step > 0 and self.n >= self.stop or \\\r\n               self.step < 0 and self.n <= self.stop:\r\n                raise StopIteration\r\n            save = self.n\r\n            self.n += self.step\r\n            return save\r\n\r\n        def __iter__(self):\r\n            return self\r\n        \r\n    def __iter__(self):\r\n        return prange.prange_iter(self.start, self.stop, self.step)\r\n\r\nGenerally, names should be defined in the most restricted place they can be\r\n(inner most scope), to avoid accidental misuse. This rule means that the\r\noriginal definition of prange_iter (defined INSIDE the __iter__ method) is\r\nprobably the BEST location to define it.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nClasses that store interesting data and have iterators over the data\r\n\r\nExamine the definition of the following class that stores and processes\r\nhistograms. For simplicity we will assume it processes percentages (ints from\r\n0 to 100) and places them in 10 bins: 0-9, 10-19, 20-29, ... 80-89, 90-100;\r\nnote that the last bin really represents 11 values, while all the others\r\nrepresent 10 values. Of course we will focus on the how to accomplish iteration\r\nfor objects of this class (iterating over the counts in their bins) but there\r\nare other interesting aspects about this class that we will discuss first (and\r\nwe could always generalize or add methods to make this class even more\r\npowerful). Note both the tally and _tally methods.\r\n\r\nclass Percent_Histogram:\r\n    def __init__(self,init_percents=[]):\r\n        self._histogram = 10*[0]    # [0,0,0,...,0,0] length 10, all 0s\r\n        for p in init_percents:\r\n            self.tally(p)\r\n         \r\n    # Called only when 0<=p<=100: 100//10 is 10 but 100 belongs in index 9\r\n    def _tally(self,p):\r\n        self._histogram[p//10 if p<100 else 9] += 1\r\n    \r\n    def clear(self):\r\n        for i in range(10):         # could write: self._histogram = 10*[0]\r\n            self._histogram[i] = 0\r\n\r\n    # tally allows any number of arguments, collected into a tuple by *args\r\n    def tally(self,*args):\r\n        if len(args) == 0:\r\n            raise IndexError('Percent_Histogram.tally: no value(s) to tally')\r\n        for p in args:\r\n            if 0 <= p <= 100:\r\n                self._tally(p)\r\n            else:\r\n                raise IndexError('Percent_Histogram.tally: '+str(p)+' outside [0,100]')\r\n                # Another approach would be to store/remember all tally failures\r\n\r\n    # allow indexing for bins [0-9]\r\n    # but can mutate these values only through __init__, clear, and tally\r\n    # no __setitem__ defined\r\n    def __getitem__(self,bin_num):\r\n        if 0 <= bin_num <= 9:\r\n            return self._histogram[bin_num]\r\n        else:\r\n            raise IndexError('Percent_Histogram.__getitem__: '+str(bin_num)+' outside [0,9]')\r\n\r\n    # standard __iter__: defines a class with __init__/__next__ and returns\r\n    #   an object from that class\r\n    def __iter__(self):\r\n\r\n        class PH_iter:\r\n            def __init__(self,histogram):\r\n                self._histogram = histogram          # sharing; sees mutation\r\n                # self._histogram = list(histogram)  # copying; doesn't see it\r\n                self._next = 0\r\n\r\n            def __next__(self):\r\n                if self._next == 10:\r\n                    raise StopIteration\r\n                answer = self._histogram[self._next]\r\n                self._next += 1\r\n                return answer\r\n\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return PH_iter(self._histogram)\r\n            \r\n    # To reconstruct a call the __init__ that reproduces the correct counts in\r\n    #   the histogram, we supply the correct number of values, but all at the\r\n    #   start of the bin: e.g., if bin 5 has 3 items, the repr has three 50s\r\n    def __repr__(self):\r\n        param = []\r\n        for i in range(10):\r\n            param += self[i]*[i*10]\r\n        return 'Percent_Histogram('+str(param)+')'\r\n    \r\n    # a 2-dimensional display; do you understand the use of .format here?\r\n    def __str__(self):\r\n        return '\\n'.join(['[{l: >2}-{h: >3}] | {s}'.format(l=10*i,h=10*i+9 if i != 9 else 100,s=self[i]*'*') for i in range(10)])\r\n\r\nNotes:\r\n\r\n0) The __init__ method uses the idiom 10*[0] which you should know. If not,\r\nexperiment with it. An alternative to the loop calling tally is calling\r\ntally(*init_percents), but unfortunately tally requires at least one argument,\r\nand if init_percents in [] the call would appear as tally() which would cause\r\ntally to raise an exception; so better to use the explicity for loop calling\r\ntally, which would be executed 0 times if init_percents is []. Of course, we\r\ncould allow tally() and define it to do nothin.\r\n\r\n1) The _tally function is supposed to be called only by methods defined in this\r\nclass. It does the actual work, putting a number from the range [0,100] into the\r\ncorrect bin, treating 100 specially (it belongs in bin 9, but p//10 would put\r\nit in bin 10, which doesn't exist). The last bin, 90-100 contains 11 values,\r\nwhile all the other bins (e.g., 30-39) contain 10. To work correctly, this\r\nmethod assumes p is legal: 0 <= p <= 100\r\n\r\n2) The clear method sets each bin in the list to 0; we could have allocated a\r\nnew list as shown in the comment, but generally that takes more time and\r\noccupies more space. Better to zero-out existing list.\r\n\r\n3) By using *args, the tally method can have any number (0 or more) of\r\npositional arguments. All arguments are collected into tuple that is iterated \r\nover to process the value individually. If there is not at least one value, or\r\nany value is out of range, this method raises an exception. Instead, we could\r\njust update a list of \"bad tallies\" and write a method that returns this list.\r\nThen, we could call the new method to determine if there were any bad tallys\r\n(in fact, how many, and what attempted tallies failed).\r\n\r\n4) The __getitem__ method allows us to index all the bins, 0-9 inclusive of a\r\nHistogrm object. Note that we can set values into these bins (i.e., mutate the\r\nlist), only via __init__ and tally. So we call this information read-only: we\r\ncan read it but not write/change it (this class defines no __setitem__). Of\r\ncourse, Python actually allows us to write o._histogram but the leading\r\nunderscore indicates only methods in the class should refer to the _histogram\r\nattribute\r\n\r\n5) We use the now standard way to implement __iter__, by defining a local class\r\nthat defines __next__ and returning an object from that class. We will discuss\r\nhow changing self._histogram = histogram vs. self._histogram = list(histogram)\r\nchanges the iterator. This nested class is very similar to the one used for\r\niterating over lists: it is simpler because the list always contains 10 values.\r\n\r\n6) The __repr__ method doesn't know what numbers went into the bins! But we can\r\nuse the lowest number in each bin, repeated by the count in that bin, to specify\r\na list needed to construct an equivalent object (with the equivalent number of\r\nvalues in each bin) with the construtor.\r\n\r\n7) The __str__ method returns a two-dimensional plot of the histogram. Do you\r\nall know how to use the format method for strings? If not you should look it\r\nup (it is described online using something like EBNF) and practice using it. You\r\nshould certainly be able to tell me why the string that .format is called on\r\nproduces the result you'll see.\r\n\r\nWhen Python executes the following script:\r\n\r\nquiz1 = Percent_Histogram([50, 55, 70, 75, 85, 100])\r\nquiz1.tally(20,30,95)\r\nprint(repr(quiz1))\r\nfor count in quiz1:\r\n    print(count,end=' ')\r\nprint('\\n',quiz1,sep='')\r\n\r\nIt prints the following information:\r\n\r\nPercent_Histogram([20, 30, 50, 50, 70, 70, 80, 90, 90])\r\n0 0 1 1 0 2 0 2 1 2 \r\n[ 0-  9] | \r\n[10- 19] | \r\n[20- 29] | *\r\n[30- 39] | *\r\n[40- 49] | \r\n[50- 59] | **\r\n[60- 69] | \r\n[70- 79] | **\r\n[80- 89] | *\r\n[90-100] | **\r\n\r\nNormally we would use this class in a program that reads a file of scores.\r\nNow, what would happen if we executed the following code?\r\n\r\nfor count in quiz1:\r\n    print(count,end=' ')\r\n    quiz1.tally(100)\r\n\r\nIt would print: 0 0 1 1 0 2 0 2 1 11 (and after the loop, quiz1[9] is 12)\r\n\r\nNote that mutating the quiz1 object during each iteration would result in the\r\nnew, accumulated values for the results produce by the iterator (in the last\r\nbin). That is because the PH_iter object refers to (shares) the same list that\r\nthe Histogram class created (and that the tally method increments). So that\r\nsharing results in the iterator always returning the most up-to-date value in\r\nthe list.\r\n\r\nWhat if we wanted to have the iterator produce the values in the histogram WHEN\r\nTHE ITERATION STARTED, and not show any updates after that. The change is\r\ntrivial: in PH_iters's __iter__ method we change\r\n\r\n                self._histogram =  histogram\r\nto \r\n                self._histogram =  list(histogram)\r\n\r\nNow instead of this iterator object sharing the list being using for the\r\nhistogram, it has its own copy: a new/different list, but storing all the\r\noriginal list's values. So, changes to the original list will not change the\r\nself.histogram list and therefore not change the result of the iteration. The\r\ncost: extra space used for the list (not much, because the list always contains\r\njust 10 values) and some extra time to construct the list.\r\n\r\nSo, we need to decide (and document) the semantics for our iterators. Can you\r\ntell (and if so, with what code) what decision was made concerning this issues\r\nfor the list iterator, and discuss why you think the designers made that\r\ndecision?\r\n\r\nIn fact, because there are iterators for lists built-into Python, we could in\r\nfact simplify __iter__ to delegate to the list class:\r\n\r\n    def __iter__(self):\r\n        return iter(self._histogram)\r\n\r\nfor sharing behavior; and for copying behavior\r\n\r\n    def __iter__(self):\r\n        return iter(list(self._histogram))\r\n\r\nbecause the list class supports an __iter__ method, on whose result __next__\r\ncan be called. So defining and advancing our own indexes in the PH_iter class\r\nis not strictly necessary. But this code illustrates how the actual list\r\niterator works (by remembering/using/incrementing the index it is currently at)\r\nand such simplifications are not possible for other classes that store more\r\ncomplicated data structures.\r\n\r\nIteration on other fundamental data structures in Python is different! If we\r\ntry to mutate a list or dict (of course we can't mutated a string or tuple)\r\nthen Python will raise a RuntimeError exception. Try writing/testing some code\r\nexhibiting this behavior.\r\n\r\nBasically, we know the order in which lists are iterated over, so if we mutate\r\nlists we will know whether the mutation has an affect on the iteration: if we\r\nmutated by appending, we will see that value eventually; if we mutate at the\r\nfront (before where we are currently iterating) then we won't. Because sets and\r\ndicts are not iterated over in any fixed order, we cannot predict whether adding\r\nsomething to a set/dict will eventually be seen in the iteration, so Python\r\ndisallows mutating a set/dict while iterating over it.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterable Decorators: Classes that are initialized by/implement iterable\r\n\r\nSince iterators are so important, it is useful to have a grab-bag of classes\r\n(this lecture) and generators (next lecture) that operate on iterables to\r\nproduce other, slightly different iterables. When a class takes as an argument\r\nan object that has methods implementing a certain protocol and returns an\r\nobject that has methods that implement the same protocol, the class is called a\r\nDECORATOR. We will write a bunch of classes that decorate iterables below (and\r\neven more in the next lecture). These are all pretty simple to think about, and\r\nwhile the code is complicated, it is complicated in the same way each time.\r\n\r\nIn all these examples, we will not see an explicit \"raise StopIteration\";\r\ninstead, this exception is raised when calling next on the iterable it is\r\niterating over. That next rasises StopIteration, which may or may not be caught\r\nin this code: if caught, it executes code in the \"except\" block; if not, it\r\npropagates the exception outside the call's context, stopping the iteration.\r\n\r\nHere is a first example of a decorator for iterable and a refinement of it.\r\nThe Repeat class takes an iterable as an argument and implements an __iter__\r\nmethod that repeats that iterator over and over: whenever it runs out of\r\nvalues to produce, the entire sequence of values is produced again.\r\n\r\nWe can test this class with any iterable, and strings are the simplest, so we\r\nwill demonstrate this class using a string. If we run the script\r\n\r\nfor i in Repeat(\"abcde\"):\r\n    print(i,end=''))\r\n\r\nPython would print: abcdeabcdeabcde ... and keep going forever; sometimes it\r\nis useful to have an iterator go forever (typically there will be some if/break\r\nin the loop using it, to eventually stop it).\r\n\r\nHere is that class\r\n\r\nclass Repeat:\r\n    def __init__(self, iterable):\r\n        self._iterable = iterable\r\n        \r\n    def __iter__(self):\r\n        class Repeat_iter:\r\n            def __init__(self, iterable):\r\n                self._iterable = iterable      # remember for restarting in next\r\n                self._iterator = iter(iterable)# remember for direct use in next\r\n            \r\n            def __next__(self):\r\n                try:\r\n                    return next(self._iterator)# return next result in iterator\r\n                except StopIteration:          # but if there is none...\r\n                    self._iterator = iter(self._iterable) # restart iterable\r\n                    return next(self)                     #call next to start\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return Repeat_iter(self._iterable)\r\n\r\nThis uses the same define-a-class-in-the-__iter__-method used in the prange and\r\nHistogram classes above.\r\n\r\nWe can generalize this class to Repeat an iterator either at most some fixed\r\nnumber of times or forever, using the following class. If the second argument\r\nto __init__ is an integer, it repeats the iterable at most that many times; if\r\nthere is no second argumment, the iterator repeats forever (as above). So\r\nmax__times = None means there is no maximum: it repeats forever. Note that\r\nshort-circuit evaluats is necessary in the first if in __next__.\r\n\r\nclass Repeat:\r\n    def __init__(self, iterable, max_times=None):\r\n        self._iterable  = iterable\r\n        self._max_times = max_times\r\n        \r\n    def __iter__(self):\r\n        class Repeat_iter:\r\n            def __init__(self, iterable, max_times):\r\n                self._iterable       = iterable\r\n                self._max_times_left = max_times\r\n                self._iterator       = iter(iterable)\r\n            \r\n            def __next__(self):\r\n                if self._max_times_left != None and self._max_times_left <= 0:\r\n                    raise StopIteration\r\n                else:\r\n                    try:\r\n                        return next(self._iterator)     # StopIteration raised?\r\n                    except StopIteration:\r\n                        if self._max_times_left != None:\r\n                            self._max_times_left -= 1 \r\n                        self._iterator = iter(self._iterable)\r\n                        return next(self)\t\t# StopIteration raised?\r\n\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return Repeat_iter(self._iterable, self._max_times)\r\n\r\nIf we run the script\r\n\r\nfor i in Repeat(\"abcde\",3):\r\n    print(i,end=''))\r\n\r\nPython would print: abcdeabcdeabcde\r\n\r\nWhat does Python produce for the following code in the original version of\r\nRepeat (on the left) and the updated version (on the right)? Why? Is there a\r\nmore reasonable behavior in this case? Note the empty string iterable iterates\r\n0 times.\r\n\r\nfor i in Repeat(\"\"): \t     \t     for i in Repeat(\"\",3):\r\n    print(i) \t\t\t             print(i) \r\n\r\nHere is a second kind of decorator for iterables. It returns all the values in\r\nan iterable, but never the same value twice. We call this class Unique. It works\r\nby keeping a set in each Unique_iter object that remembers and bypasses\r\nreturning any value already returned from that iterator object.\r\n\r\nclass Unique:\r\n    def __init__(self, iterable):\r\n        self._iterable = iterable\r\n        \r\n    def __iter__(self):\r\n        class Unique_iter:\r\n            def __init__(self, iterable):\r\n                self._iterated = set()\r\n                self._iterator = iter(iterable)\r\n            \r\n            def __next__(self):\r\n                answer = next(self._iterator)\t\t# StopIteration raised?\r\n                while answer in self._iterated:\r\n                    answer = next(self._iterator)\t# StopIteration raised?\r\n                self._iterated.add(answer)\r\n                return answer\r\n\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return Unique_iter(self._iterable)\r\n\r\nIf we run the script\r\n\r\nfor i in Unique('Mississippi'):\r\n    print(i,end='')\r\n\r\nPython prints: Misp\r\n\r\nWe can also generalize this class by specifying the maximum number of times a\r\nvalue can be returned (with a default argument of 1, which brings us back to\r\nversion of Unique specified above, since it allows values to be returned only\r\nonce). This is a trivial but interesting example of generalizing classes with\r\nbackward compatibility of use. Here we replace a set of \"iterated-over\" values\r\nby a dictionary with these values as keys associated with the number of times\r\nthis value has been returned: a set doesn't contain the information we need to\r\nimplement this class.\r\n\r\nfrom collections import defaultdict  \r\nclass Unique:\r\n    def __init__(self, iterable, max_times=1):\r\n        self._iterable  = iterable\r\n        self._max_times = max_times\r\n        \r\n    def __iter__(self):\r\n        class Unique_iter:\r\n            def __init__(self, iterable, max_times):\r\n                self._times     = defaultdict(int)\r\n                self._iterator  = iter(iterable)\r\n                self._max_times = max_times\r\n            \r\n            def __next__(self):\r\n                answer = next(self._iterator)\t\t# StopIteration raised?\r\n                while self._times[answer] >= self._max_times:\r\n                    answer = next(self._iterator)       # StopIteration raised?\r\n                self._times[answer] += 1\r\n                return answer\r\n\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return Unique_iter(self._iterable, self._max_times)\r\n\r\nIf we run the script:\r\n\r\nfor i in Unique('Mississippi',2):\r\n    print(i,end='')\r\n\r\nPython prints: Missipp\r\n\r\nAs another example, we will write the Filter class, which is supplied with a\r\npredicate function (of one argument that returns a bool), indicating whether or\r\nnot a value should be produced by the iterable or FILTERED OUT, causing next to\r\nnot return that value, but instead to keep looking at values until it finds a\r\nvalue to return for which the predicate returns True.\r\n\r\nclass Filter:\r\n    def __init__(self, iterable, predicate):\r\n        self._iterable  = iterable\r\n        self._predicate = predicate\r\n        \r\n    def __iter__(self):\r\n        class Filter_iter:\r\n            def __init__(self, iterable, predicate):\r\n                self._iterator  = iter(iterable)\r\n                self._predicate = predicate\r\n            \r\n            def __next__(self):\r\n                answer = next(self._iterator)           # StopIteration raised?\r\n                while self._predicate(answer) == False:\r\n                     answer = next(self._iterator)      # StopIteration raised?\r\n                return answer\r\n\r\n            def __iter__(self):\r\n                return self\r\n\r\n        return Filter_iter(self._iterable, self._predicate)\r\n\r\nIf we run the script:\r\n\r\nfor i in Filter('abcdefghijklmnopqrstuvwxyz',lambda x : x not in 'richardpattis'):\r\n    print(i,end='')           \r\n\r\nPython prints all the letters not in my name: befgjklmnoquvwxyz \r\n\r\nNotice that the Repeat, Unique, and Filter classes all implement their iterators\r\nsimilarly, with the same pattern of code. In the next lecture we will rewrite\r\nthese decorators -and even more decorators- much more simply using generators, \r\nwhich allow us to capture the pattern above much more easily -once we understand\r\nhow generators work.\r\n\r\nHere is a last decorator for iterables. Its calls to next return all the values\r\nin an iterable but in sorted order. In this implementation we collect all the\r\nvalues from the iterator into a list and then sort the list and return its\r\niterator (since the values are all in the correct order). We cannot know what\r\nsmallest value to return until we have seen all the values.\r\n\r\nclass psorted: # pseudo-sorted: works just like sorted\r\n    def __init__(self, iterable, key=None, reverse=False):\r\n        self.result = list(iterable)  # put all values from iterable into a list\r\n        self.result.sort(key=key, reverse=reverse)\r\n        \r\n    def __iter__(self):\r\n        return iter(self.result)\r\n\r\nActually, \"sorted\" in Python is simpler: it is a function that returns a list\r\n(so it still returns something that is iterable). So, psorted might be more\r\nclearly written as just\r\n\r\ndef psorted(iterable, key=None, reverse=False):\r\n    result = list(iterable)                   # put all values in a list\r\n    result.sort(key=key, reverse=reverse)     # calling sort returns None\r\n    return result\t\t\t      # so return in another statement\r\n\r\nFinally, notice how we can combine these decorator classes below. Suppose I\r\nwant to print out all the letters in my name in alphabetical order, with no\r\nrepetition of letters. I can do it with the following script. Note that the\r\nstring argument to psorted is iterable, and psorted itself returns an iterable\r\n(so the argument to Unique is iterable) and finally Unique is iterable as well\r\n(which is needed by the for loop)\r\n\r\nfor i in Unique(psorted('richardpattis')):\r\n    print(i,end='')\r\n\r\nIt prints: acdhiprst\r\n\r\nWhat would the following script print? It reverse the order of the decorator\r\nclasses being constructed.\r\n\r\nfor i in psorted(Unique('richardpattis')):\r\n    print(i,end='')\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n1) Explain what happens (and why) if we write the following loops\r\n\r\n   for c in Repeat(''): ...?\r\n   for c in Repeat('',4): ...?\r\n\r\neach with an empty iterator (produces no values). What alternative (more\r\nreasonable) behavior might you want in these cases? How we can implement it?\r\n\r\n2) Explain what happens in each of the following situations, which uses a list\r\nas the iterable being decorated: will the appended value be printed?\r\n\r\n  l = [...] # some list\r\n  i = 0\r\n  for u in Unique(l):\r\n      print(u)\r\n      i += 1\r\n      if i == 1:\r\n          l.append(...) # append a value to l that is not already there\r\n\r\n  l  = [...] # some list\r\n  ui = Unique(l)\r\n  l.append(...) # append a value to l that is not already there\r\n  for u in ui:\r\n      print(u)\r\n\r\nExplain how we could modify the Unique class to get the opposite behavior.\r\n\r\n3) Here is another way to write the __next__ method in the Filter_iter class.\r\nCompare this loop with the one in the code above as to simplicity/clarity.\r\nWhich would you prefer in your code?\r\n\r\n                while True:\r\n                    answer = next(self.iterator)\r\n                    if self.predicate(answer):\r\n                        return answer\r\n\r\n4) Expain why the iterable passed as an argument to the psorted class must\r\nbe finite. What very big difference is there between calling\r\n\r\nfor i in psorted(Repeat('abc')):\r\n    print(i)\r\n\r\nand \r\n\r\nfor i in Unique(Repeat('abc')):\r\n    print(i)\r\n\r\n5) Define a preversed class similar to the sorted class above, which acts as a\r\ndecorator for iterables. You may not use reversed in your code. Hint: it uses\r\na combination of creating a list from the iterable and the iterator in the\r\nHistogram class (although using a range iterator might simplify the code).\r\n\r\n6) Define a Random class, which acts as a decorator for iterables: it returns\r\neach value with a probability (a float between 0-never- and 1-always) specified\r\nwhen the object is constructed. Account for the fact that the iterator might\r\nproduce an infinite number of values. Write this in a straightforward way, then\r\nwrite it in a simpler way using the Filter class.\r\n\r\n7) Define a Skipping class, which acts as a decorator for iterables: it skips\r\nthe first n values (n is specified as an argument to __init__) and then \r\nproduces the same value as its iterable argument. So the following loop skips\r\nthe first three values when iteratin over the string 'abcdefg'\r\n\r\n  for c in Skipping('abcdefg',3):\r\n      print(c,end='')\r\n\r\nand prints: defg\r\n", "encoding": "ascii"}