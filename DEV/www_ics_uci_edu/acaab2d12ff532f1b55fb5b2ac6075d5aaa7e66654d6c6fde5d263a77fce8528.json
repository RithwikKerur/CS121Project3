{"url": "https://www.ics.uci.edu/~dan/class/165/notes/interrupt.html", "content": "<HTML><HEAD>\n<TITLE> Handling Interrupts\n</TITLE>\n</HEAD><BODY>\n\n<H2> Handling interrupts in C </H2>\n\nPrograms should be able to recover gracefully when run-time errors\noccur, such as illegal arithmetic, I/O problems, etc.&nbsp;\nIn some of these cases, a system library procedure you use\nwill return a value to the caller (your procedure) indicating\nwhether or not it was successful.&nbsp;\nYou are responsible for checking these return values and deciding\nwhat to do if an error is detected.&nbsp;\nYou will need to check the manual entries\nof any procedures you use to determine what returns to look for.\n<P>\nIn other cases, an error is detected by the hardware or operating system\nrather than a library routine you called.&nbsp;\nA \"signal\" is sent to the process (your program) in these cases.&nbsp;\nEvery process has a list of actions to be taken upon receipt\nof various signals.&nbsp;\nFor most signals, the action is to print an error message to\nthe standard error stream, dump core, and abort the process.&nbsp;\nYou will, almost certainly, be plagued by this behavior before\nthis class is through.\n<P>\nYou may, in your program, redefine the actions which are to be taken\nupon receipt of these signals.&nbsp;\nYou are expected to use this facility to have\nyour program recover gracefully from illegal arithmetic errors\n(such as overflow).&nbsp;\nTo do this, first include the file <tt><signal.h></tt>\nand write a procedure of the form:\n<pre>\n\tfloatexception( sig, code )\n\tint sig, code;\n\t{\n\t\t/* your code for exception handling */\n\t}\n</pre>\n<P>\nThen the command:&nbsp; <tt>signal( SIGFPE, floatexception );</tt>\nwill tell the system to execute the procedure <I>floatexception</I>\nwhenever the signal SIGFPE (Floating Point Exception) is received.&nbsp;\nAfter completion of the <I>floatexception</I> procedure\n(if it completes at all;&nbsp; more on this later),\nthe code that caused the signal is continued\nas if nothing happened.&nbsp;\nThe two parameters passed to <I>floatexception</I> by the system\ntell it what signal caused it to be executed (in case you\nhave more than one signal set to call it) and a further integer code\ngiving more details in some cases.&nbsp;\nSee the manual page on <I>signal</I> for more details.\n<P>\nNote that, since your procedures are supposed to be self-contained,\nbefore your procedure quits it must reset any signals back to whatever\nthey were before your procedure changed them.&nbsp;\nThe <I>signal</I> function returns a\npointer to whatever function was the old action to be taken.&nbsp;\nYou must remember this pointer, and use it to reset the signal\nbefore quitting.&nbsp;\nIn the case of a recursive procedure, you\nshould probably use a separate top-level \"bootstrap\"\nprocedure that the user will\ncall, which just sets up the signals, allocates whatever memory will be\nneeded, then calls the recursive procedure.&nbsp;\nThis top-level procedure will then return memory\nand reset signals before returning control to its caller.&nbsp;\nA simplified outline of such a top-level procedure follows:\n<pre>\n\t/* define possible returns of the procedure */\n\ttypedef enum { FAILSIG, FAILMEM, FAILFLOAT, FAILRESETIG, SUCCEED };\n\n\tvoid (*old_sigfpe)(); /* to remember the old action associated with SIGFPE */\n\n\tif ( -1 == (int) ( old_sigfpe = signal( SIGFPE, floatexception ) ) );\n\t\t/* something wrong with the signal system: bail out */\n\t\treturn( FAILSIG );\n\t.\n\t.\t/* allocate memory, call recursive procedure, free memory */\n\t.\n\tif ( -1 == (int) signal( SIGFPE, old_sigfpe ) )\n\t\t/* signal reset failed, but we have otherwise succeeded */\n\t\treturn( FAILRESETSIG );\n\treturn( SUCCEED );\n</pre>\n<P>\nThe typedef should probably be in an include file, so that your calling\nprogram (the tester) can decipher the return status of your procedure.\n<P>\nThe other main problem with interrupt handling is how to abort a\nprocedure when it may be several levels deep in recursion.&nbsp;\nOne technique is to set up a global flag which the procedure checks\nperiodically and exits if the flag is changed.&nbsp;\nIn this case, <I>floatexception</I> would be the one\nto change the flag.&nbsp;\nThis is not great, since the procedure must\nwaste time checking the flag.\n<P>\nA better solution is provided by the C library functions\n<I>setjump</I> and <I>longjmp</I>.&nbsp;\nTo use them, include the file\n<tt><setjmp.h></tt> and define a variable,\nwe will call it <tt>env</tt>, of type <tt>jmp_buf</tt>.&nbsp;\nA call to <I>setjmp</I> will save a copy of the execution stack\nin <tt>env</tt> and return 0.&nbsp;\nA call to <I>longjmp</I> will restore the\nexecution stack to whatever is stored in <tt>env</tt>,\nand will cause <I>setjmp</I>\n(which will then be executing again) to return whatever integer is given\nto <I>longjmp</I>.&nbsp;\nThus, when you call <I>setjmp</I>, your code must check the\nreturn to see if it is actually the first call, or whether you got there\nas a result of an error.&nbsp;\nAt some point in a top-level procedure (like the\n\"bootstrap\" mentioned above) you should have some code looking something\nlike:\n<pre>\n\tif ( x == setjmp( env ) ) {\n\t\t/* code to deal with error x: (probably just clean up and */\n\t\t/* return an error status to caller) */\n\t} else {\n\t\t/* code to continue with the task at hand */\n\t}\n</pre>\n<P>\nIn this case, the code in <I>floatexception</I> should just be:\n<pre>\n\tlongjmp( env, /* some non-zero integer of your choosing */ );\n</pre>\n<P>\n\n<HR>\n<ADDRESS>\n<A HREF=\"http://www.ics.uci.edu/~dan\">\nDan Hirschberg </A> <BR>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3435<BR>\n</ADDRESS>\n<tt>dan (at) ics.uci.edu</tt><br>\nLast modified: Mar 20, 1999\n</BODY></HTML>\n", "encoding": "ascii"}