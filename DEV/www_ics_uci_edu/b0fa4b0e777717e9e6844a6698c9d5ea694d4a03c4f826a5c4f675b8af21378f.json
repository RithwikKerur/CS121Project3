{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/CollSpec032.txt", "content": "WEBDAV Working Group                                     J. Slein, Xerox\nINTERNET DRAFT                                           J. Davis, Xerox\n<draft-ietf-webdav-collection-protocol-03.2>     T. Chihaya, DataChannel\n                                                      G. Clemm, Rational\n                                                         C. Fay, FileNet\n                                           E.J. Whitehead Jr., UC Irvine\n                                                          April 18, 1999\nExpires October 18, 1999\n\n\t\t\tWebDAV Advanced Collections Protocol\n\nStatus of this Memo\n\nThis document is an Internet-Draft and is in full conformance with all \nprovisions of Section 10 of RFC2026. Internet-Drafts are working \ndocuments of the Internet Engineering Task Force (IETF), its areas, and \nits working groups. Note that other groups may also distribute working \ndocuments as Internet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months \nand may be updated, replaced, or obsoleted by other documents at any \ntime. It is inappropriate to use Internet-Drafts as reference material \nor to cite them other than as \"work in progress\".\n\nTo view the list Internet-Draft Shadow Directories, see \nhttp://www.ietf.org/shadow.html.\n\nDistribution of this document is unlimited. Please send comments to the \nDistributed Authoring and Versioning (WebDAV) working group at <w3c-\ndist-auth@w3.org>, which may be joined by sending a message with subject \n\"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\nDiscussions of the WEBDAV working group are archived at URL: \n<http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\nAbstract\n\nThe base WebDAV protocol [WebDAV] provides basic support for \ncollections.  It defines a MKCOL method for creating collections and \nspecifies how other HTTP and WebDAV methods interact with collections.  \nIt supports internal members of collections, which it defines as URIs \nthat are immediately relative to the URI of the collection.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: shared resources and ordering.\n\nThis draft specifies extensions to the base WebDAV protocol to support \nthese more powerful collections.\n\nTable of Contents\n\n1\tNotational Conventions........................................4\n2\tTerminology...................................................4\n3\tIntroduction..................................................5\n4\tShared Resources..............................................6\n4.1\tScope.........................................................6\n\nSlein et al.                                                    Page 1\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n4.1.1\tStrong References out of Scope................................6\n4.1.2\tDirect References out of Scope................................7\n4.2\tOverview......................................................7\n4.3\tCreating Bindings.............................................9\n4.3.1\tThe BIND Method...............................................9\n4.3.2\tStatus Codes..................................................9\n4.3.3\tExample: BIND................................................10\n4.4\tThe Semantics of Bindings....................................10\n4.4.1\tBindings to Collections......................................13\n4.5\tCreating Redirect References.................................13\n4.5.1\tThe MKREF Method.............................................13\n4.5.2\tStatus Codes.................................................13\n4.5.3\tExample: MKREF...............................................14\n4.6\tListing the Redirect References in a Collection..............14\n4.6.1\tExample: PROPFIND on a Collection with Redirect References...15\n4.6.2\tExample: PROPFIND with Passthrough: F on a Collection with \n        Redirect References..........................................16\n4.7\tCopying Redirect References..................................18\n4.7.1\tExample: COPY on a Redirect Reference........................18\n4.7.2\tExample: COPY on a Collection That Contains a Redirect \n        Reference....................................................19\n4.8\tDeleting and Moving Redirect References......................19\n4.9\tLocking Redirect References..................................20\n4.9.1\tLOCK on Redirect References..................................20\n4.9.2\tExample: LOCK on a Redirect Reference........................21\n4.9.3\tExample: LOCK on a Collection That Contains a Redirect \n        Reference, with Passthrough: T...............................22\n4.10\tOther WebDAV Operations on Redirect References...............24\n4.10.1\tExample: PROPPATCH on a Redirect Reference...................24\n4.11\tHTTP Operations on Redirect References.......................24\n4.11.1\tExample: GET on a Redirect Reference.........................25\n4.11.2\tExample: GET on a Redirect Reference with \"Passthrough: F\"...25\n4.12\tOperations on Targets of Redirect References.................25\n4.13\tDiscovering a Target's References............................26\n4.14\tRelative URIs in Ref-Target and DAV:reftarget................27\n4.14.1\tExample: Resolving a Relative URI in Ref-Target..............27\n4.14.2\tExample: Resolving a Relative URI in DAV:reftarget...........27\n4.15\tRedirect References to Collections...........................29\n5\tOrdered Collections..........................................29\n5.1\tOverview.....................................................29\n5.2\tCreating an Ordered Collection...............................30\n5.2.1\tOverview.....................................................30\n5.2.2\tExample: Creating an Ordered Collection......................30\n5.3\tSetting the Position of a Collection Member..................31\n5.3.1\tOverview.....................................................31\n5.3.2\tStatus Codes.................................................31\n5.3.3\tExamples: Setting the Position of a Collection Member........31\n5.4\tChanging the Semantics of a Collection Ordering..............32\n5.5\tChanging the Position of a Collection Member.................32\n5.5.1\tThe ORDERPATCH Method........................................32\n\nSlein et al.                                                    Page 2\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n5.5.2\tStatus Codes.................................................32\n5.5.3\tExample: Changing the Positions of Collection Members in the \n        Ordering.....................................................33\n5.5.4\tExample: Failure of an ORDERPATCH Request....................34\n6\tHeaders......................................................34\n6.1\tRef-Target Entity Header.....................................34\n6.2\tResource-Type Entity Header..................................34\n6.3\tRef-Integrity Request Header.................................35\n6.4\tPassthrough Request Header...................................35\n6.5\tOrdered Entity Header........................................36\n6.6\tPosition Request Header......................................36\n7\tStatus Codes.................................................37\n7.1\t506 Loop Detected............................................37\n8\tProperties...................................................37\n8.1\treftarget Property...........................................37\n8.2\trefintegrity Property........................................38\n8.3\tlocation Property............................................38\n8.4\treferences Property..........................................38\n8.5\torderingtype Property........................................39\n9\tXML Elements.................................................39\n9.1\treference XML Element........................................39\n9.2\tweak XML Element.............................................39\n9.3\tunordered XML Element........................................39\n9.4\tcustom XML Element...........................................39\n9.5\torder XML Element............................................40\n9.6\tordermember XML Element......................................40\n9.7\tposition XML Element.........................................40\n9.8\tfirst XML Element............................................40\n9.9\tlast XML Element.............................................41\n9.10\tbefore XML Element...........................................41\n9.11\tafter XML Element............................................41\n9.12\toptions XML Element..........................................41\n9.13\trefintegrityoptions XML Element..............................41\n9.14\torderingoptions XML Element..................................42\n9.15\tdo-not-enforce XML Element...................................42\n10\tExtensions to the DAV:response XML Element for Multi-Status \n        Responses....................................................42\n11\tCapability Discovery.........................................43\n11.1\tCompliance Classes...........................................43\n11.2\tExample: Discovery of Compliance Classes.....................43\n11.3\tAdditional Advanced Collections Capabilities.................43\n11.4\tExample: Discovery of Referential Integrity Options..........44\n12\tDependencies on Other Specifications.........................45\n13\tSecurity Considerations......................................45\n13.1\tPrivacy Concerns.............................................45\n13.2\tRedirect Loops...............................................45\n13.3\tRedirect References, Bindings, and Denial of Service.........45\n13.4\tPrivate Locations May Be Revealed............................46\n13.5\tDAV:references and Denial of Service.........................46\n13.6\tDAV:references and Malicious Deletion of Resources...........46\n13.7\tDenial of Service and DAV:orderingtype.......................46\n14\tInternationalization Considerations..........................47\n15\tIANA Considerations..........................................47\n16\tCopyright....................................................47\n17\tIntellectual Property........................................47\n\nSlein et al.                                                    Page 3\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n18\tAcknowledgements.............................................47\n19\tReferences...................................................48\n19.1\tNormative References.........................................48\n19.2\tInformational References.....................................48\n20\tAuthors' Addresses...........................................48\n21\tAppendices...................................................49\n21.1\tAppendix 1: Extensions to the WebDAV Document Type Definition49\n\n1 Notational Conventions\n\nSince this document describes a set of extensions to the HTTP/1.1 \nprotocol, the augmented BNF used here to describe protocol elements is \nexactly the same as described in Section 2.1 of [HTTP].  Since this \naugmented BNF uses the basic production rules provided in Section 2.2 of \n[HTTP], these rules apply to this document as well.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this \ndocument are to be interpreted as described in [RFC2119].\n\n2 Terminology\n\nThe terminology used here follows and extends that in the base WebDAV \nprotocol specification [WebDAV].\n\nCollection\n     A resource that contains a set of URIs, termed member URIs, which \n     identify member resources\n\nMember URI\n     A URI which is a member of the set of URIs contained by a \n     collection\n\nReference\n     A mechanism for providing resource sharing, allowing a single \n     resource to be accessed from multiple locations in HTTP \n     namespaces.  The bindings and redirect references defined in this \n     specification are types of references.\n\nBinding\n     An association between a URI and a resource, which makes it \n     possible to submit requests to the resource using the URI as the \n     request-URI.\n\nRedirect Reference\n     A resource whose purpose is to provide access to another resource, \n     and that requires client action before it can be resolved.  The \n     client is aware that this type of reference is mediating between \n     it and the target resource.\n\nOrdinary Resource\n     A resource that is not a reference to another resource\n\nTarget Resource\n     The resource referenced by a referential resource\n\nSlein et al.                                                    Page 4\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nStrong Reference\n     A reference whose referential integrity is enforced by the server\n\nWeak Reference\n     A reference whose referential integrity is not enforced by the \n     server\n\nReferential Integrity\n     The integrity of a reference is preserved as long as it points to \n     the same resource it pointed to when it was created.  Its \n     integrity may be destroyed if the target resource is moved without \n     updating the reference to reflect its new location, or if the \n     target resource is deleted.\n\n3 Introduction\n\nThe simple collections that the base WebDAV specification supports are \npowerful enough to be widely useful.  They provide for the hierarchical \norganization of resources, with mechanisms for creating and deleting \ncollections, copying and moving them, locking them, adding members to \nthem and removing members from them, and getting listings of their \nmembers.  Delete, copy, move, list, and lock operations can be applied \nrecursively, so that a client can operate on whole hierarchies with a \nsingle request.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: shared resources and ordering.  This specification defines \nOPTIONAL extensions to [WebDAV] in both these areas.\n\nIt is useful for the same resource to be accessible from multiple \nlocations in HTTP namespaces.  Different collections, on the same or \ndifferent servers, may need to share the same resource.  For example, \nthe mathematics department at one university might create a collection \nof information on fractals that contains the URIs of some local \nresources, but also provides access to some resources at other \nuniversities.  For many reasons, it may be undesirable to make physical \ncopies of the shared resources on the local server - to conserve disk \nspace, to respect copyright constraints, or to make any changes in the \nshared resources visible automatically.  This protocol provides two \nmechanisms for sharing resources: bindings and redirect references.\n\nIt is useful for many applications to be able to impose an ordering on a \ncollection. Orderings may be based on property values, but they may be \ncompletely independent of any properties on the resources identified by \nthe collection's member URIs.  Orderings based on properties can be \nobtained using a search protocol [DASL], but orderings not based on \nproperties need some other mechanism.  These orderings generally need to \nbe maintained by a human user.  The ordering protocol defined here \nfocuses on support for such human-maintained orderings, but also allows \nfor server-maintained orderings.\n\nSince resource sharing and ordered collections are independent of each \nother, servers may elect to comply with the Shared Resources section of \n\nSlein et al.                                                    Page 5\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nthis specification or with the Ordered Collections section or both.  A \nserver that supports resource sharing provides both bindings and \nredirect references.  A server MUST advertise its compliance with \nparticular parts of this specification through its response to an \nOPTIONS request, as specified in Section 10 below.\n\n4 Shared Resources\n\n4.1 Scope\n\n[CollReq] states requirements for 4 different kinds of references: weak \nreferences, strong references, redirect references, and direct \nreferences.  This specification supports weak references and redirect \nreferences, and is designed so that it can be extended to support strong \nreferences in the future.  The bindings defined here provide many of the \nfeatures of direct references while avoiding some of their complexities.  \nDirect references can also be added in the future.\n\n4.1.1 Strong References out of Scope\n\nStrong references are references whose integrity is enforced by the \nserver; weak references are those whose integrity is not enforced by the \nserver.  Strong references and weak references are both useful in \ndifferent contexts.  Some applications cannot tolerate broken links.  A \nsoftware development application, for example, must be able to rely on \nthe integrity of references to component modules. Such applications must \nbe able to request strong references.  Other applications may want to \nreference target resources on multiple servers, where referential \nintegrity cannot be enforced, and may be less concerned about possible \nbroken references.  Weak references may even be required by some \napplications.  For example, it may be a common occurrence in some \napplications for content to be temporarily removed, so that references \nare temporarily left dangling.\n\nSeveral considerations led to the decision not to support strong \nreferences in the current specification.  First, there are many possible \npolicies that applications and services might use in enforcing \nreferential integrity.  Some examples are:\n\no Delete strong references when their targets are deleted.\no Decline to delete targets of strong references.\no Notify strong references when their targets have been deleted.\no Replace strong references with copies of their targets before \n  deleting the targets.\n\nThere appears to be no common practice in this area.  Moreover, some of \nthe policies have significant security risks.\n\no Moving a target of strong references could be a security risk to the \n  owner of the target by revealing secret locations on the target's \n  server.\no A strong reference could be a security risk to the owner of the \n  reference by revealing secret locations on his server.\no The presence of strong references to resources on a server could make \n  it impossible to reclaim space on that server by moving or deleting \n\nSlein et al.                                                    Page 6\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n  those target resources. \n\nThese considerations together led to the decision not to support strong \nreferences in the short term. \n\n4.1.2 Direct References out of Scope\n\nDirect references would have provided some features that bindings do \nnot.  For example, direct references are resources that can have \nproperties of their own.  In addition, direct references may be weak or \nstrong, and can support a variety of policies for enforcing referential \nintegrity.\n\nHowever, direct references raise a number of design issues that do not \narise for bindings.  It is unclear what the semantics of COPY, MOVE, and \nLOCK should be for direct references, whereas the semantics of all \noperations for bindings have already been defined by [HTTP] and \n[WebDAV].  In addition, behaviors would have to be defined for chains of \ndirect references and for dangling direct references, neither of which \ncan occur in the case of bindings. \n\nThese considerations led to the decision not to support direct \nreferences in the short term.\n\n4.2 Overview\n\nShared resources make the same resource accessible from multiple \nlocations in HTTP namespaces.  This protocol provides two mechanisms for \nsharing resources: bindings and redirect references.\n\nA binding is an association between a URI and a resource, which makes it \npossible to submit requests to the resource using the URI as the \nrequest-URI.  Since bindings already exist in [HTTP] and [WebDAV], this \nspecification merely provides a way for clients to add new bindings to \nexisting resources.  Bindings are an appealing mechanism for resource \nsharing because: \n\no Once created, clients need do nothing special to use them.  They \n  behave just like any other binding, transparently applying operations \n  to the target resource.  \no Servers already provide bindings, so there is little extra work \n  involved in allowing clients to create them.\no The integrity of bindings is guaranteed.  MOVE and DELETE operations \n  cannot leave bindings in an inconsistent state.  \n\nA limitation of bindings is that a server would need proxy capabilities \nin order to support bindings to resources on another server.  In light \nof this complexity, support for cross-server bindings is OPTIONAL.\n\nA redirect reference is a resource whose purpose is to provide access to \nanother resource.  From the client\u2019s point of view, redirect references \nare less convenient to use than bindings, because redirect references \nrequire action by the client before they can be resolved.  Moreover, the \nserver is not required to enforce the integrity of redirect references.  \nHowever, redirect references have a number of advantages: \n\nSlein et al.                                                    Page 7\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\no They are simple for servers to implement.  Servers already provide \n  redirect resources, and the same mechanism can be used for redirect \n  references.\no The same simple implementation works equally well for target \n  resources that reside on the same server and for target resources \n  that reside on a different server.  \no Redirect references have only limited security implications.  \no Since redirect references are resources, they can carry properties of \n  their own.  \no It is possible to ask a server not to enforce referential integrity \n  for a redirect reference.  \n\nTo distinguish redirect references from ordinary resources, a new value \nof the DAV:resourcetype property (defined in [WebDAV]) is added here.  \nThe DAV:resourcetype property of all redirect references MUST have the \nnew value DAV:reference (defined in Section 8.1 below).  \n\nIf the client is aware that it is operating on a redirect reference, it \ncan resolve the reference by retrieving the reference's DAV:reftarget \nproperty (defined in Section 7.1 below), whose value is the URI of the \ntarget resource.  It can then submit requests to the target resource. \nEvery redirect reference MUST have the DAV:reftarget property.\n\nOtherwise, the client submits a request to the redirect reference.  For \nmost operations, the response is a 302 (Moved Temporarily), accompanied \nby the Resource-Type header (defined in Section 6.2 below) with the \nvalue \"DAV:reference\" and the Location header with the URI of the target \nresource.  The client can then resubmit the request to the URI of the \ntarget resource.  A few operations, for reasons that will be explained, \nare exceptions to this general behavior. These exceptional operations \nare applied to the reference itself and do not result in a 302 response.\n\nSince a redirect reference is a resource, it is possible to apply \nmethods to the reference as well as to its target.  The Passthrough \nrequest header (defined in Section 6.4 below) is provided so that \nreferencing-aware clients can control whether an operation is applied to \nthe redirect reference or to its target resource.  The Passthrough \nheader can be used with most requests to redirect references.  This \nheader is particularly useful with PROPFIND, to retrieve the reference's \nown properties.\n\nIdeally, non-referencing clients should be able to use both bindings and \nredirect references.  This goal is more difficult to meet for redirect \nreferences, since client action is required to resolve them.  The \nstrategy of having redirect references respond to most requests with a \n302 (Moved Temporarily), accompanied by the URI of the target resource \nin the Location header, fulfills this goal in most cases.\n\nAlthough strong references are not currently supported, a new property \ncalled DAV:refintegrity is defined in Section 7.2 in anticipation of \nfuture support for strong references.  DAV:refintegrity will allow \nclients to distinguish between weak and strong references.  All redirect \nreferences MUST have this property.  Although the only value currently \ndefined for DAV:refintegrity is DAV:weak, other values may be defined in \n\nSlein et al.                                                    Page 8\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nthe future, and servers MAY use extension values to identify their \npolicy for enforcing referential integrity for that reference.  Since \nservers are required to maintain the integrity of bindings and the \nsemantics for doing so are defined in Section 4.4, no discovery \nmechanism is needed for referential integrity on bindings.\n\n4.3 Creating Bindings\n\n4.3.1 The BIND Method\n\nBindings are created using the BIND method.  The request-URI of the BIND \nrequest is the new URI through which the resource will be accessible \nonce the operation has completed.\n\nSeveral headers defined in this specification are used in BIND requests:  \n\no The Ref-Target header (defined in Section 6.1) MUST be included in \n  every BIND request to identify the target resource of the new \n  binding.  \no The Position request header (defined in Section 6.6) MAY be used in \n  BIND requests to indicate where the new binding is to be placed in \n  its parent collection's ordering.\n\nIn the context of a BIND request, the URI in the Ref-Target header MUST \nhave an existing binding to some resource.  Otherwise, the BIND request \nMUST fail with a 409 (Conflict) status code.\n\nWhen a server receives a BIND request, it looks up the resource that is \nbound to the URI in the Ref-Target header, and creates a new binding of \nthe request-URI to the same resource.  It also adds the request-URI as a \nnew collection member to its parent collection.  The parent collection \nis identified by the request-URI minus its final segment.  If this \nparent collection does not exist, the BIND request MUST fail with a 409 \n(Conflict) status code.\n\nAfter successful processing of a BIND request, it MUST be possible for \nclients to use the request-URI to submit requests to the resource \nidentified by the Ref-Target header, and the request-URI MUST be a \nmember of the collection identified by the request-URI minus its final \nsegment.\n\nIf the server cannot support the semantics for bindings defined in \nSection 4.4 for the Request-URI, it MUST fail the request.\n\nIf a BIND request has a request-URI that identifies an existing binding, \nthe existing resource MUST be overwritten by default.  This behavior is \nanalogous to the behavior of the PUT method [HTTP].  If overwriting an \nexisting binding destroys the last binding to a given resource, that \nresource MUST be deleted.  The default overwrite behavior can be \noverridden using the Overwrite header defined in Section 9.6 of \n[WebDAV].\n\n4.3.2 Status Codes\n\nSome typical client errors for BIND, and the appropriate response status \n\nSlein et al.                                                    Page 9\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\ncodes, include: \n\n400 (Bad Request): The client set an invalid value for the Ref-Target or \nPosition header.\n\n409 (Conflict): Several conditions may produce this response.  There may \nbe no existing binding for the URI specified in Ref-Target.  The request \nmay be attempting to create a binding in a collection that does not \nexist. The request may be attempting to position the binding in an \nunordered collection.\n\n412 (Precondition Failed): The Overwrite header is ?F?, and a binding \nalready exists for the request-URI.\n\n4.3.3 Example: BIND\n\nRequest:\n\nBIND /~whitehead/dav/spec08.txt HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: /i-d/draft-webdav-protocol-08.txt\n\nResponse:\n\nHTTP/1.1 201 Created\n\nBecause the URI in the Ref-Target header was already mapped to the \ndesired target resource, the server was able to look up the target \nresource and create a new binding to it.  The server created the new \nbinding for the request-URI, associating it with the resource identified \nby the Ref-Target header.  Clients can now use the request-URI to submit \nrequests to that resource.  In addition, the server added the request-\nURI to the list of members of collection /~whitehead/dav/.\n\n4.4 The Semantics of Bindings\n\nBindings created with the BIND method are no different from bindings \ncreated in any other way.  All bindings associate a URI with a resource, \nmaking it possible to submit requests to the resource using the URI as \nthe request-URI.  All methods MUST behave the same way for bindings \ncreated with the BIND method as for any other bindings.\n\nConsider a case where there are several bindings to resource R.  Of \nthese bindings, only the one between URI3 and R was created using BIND.\n\n URI1    URI2     URI3 \n   |       |        |\n   |       |        |      <------- Bindings\n   |       |        |\n+---------------------+\n|     Resource R      |\n+---------------------+\n           |\n           |\n           |\n\nSlein et al.                                                    Page 10\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n+---------------------+\n| Chunk of State      |\n| (e.g., file,        |\n|  or multiple files, |\n|  or EEPROM memory,  |\n|  or database record,|\n|  etc.)              |\n+---------------------+\n\n*** Inconsistencies everywhere about whether we distinguish between a \nresource and the chunk of state.\n\nA GET on URI3 MUST produce the same response as a GET on URI1 or URI2, \nas specified in [HTTP], returning an entity response for R.  \n\nA HEAD on URI3 MUST produce the same response as a HEAD on URI1 or URI2, \nas specified in [HTTP], returning the entity headers for R.\n\nA PUT on URI3 MUST produce the same result as a PUT on URI1 or URI2, as \nspecified in [HTTP]. By default it overwrites the state associated with \nR, affecting the GET entity response for all three URIs.\n\nA POST on URI3 MUST produce the same result as a POST on URI1 or URI2, \nas specified in [HTTP].  It may do anything, depending upon the nature \nof R. \n\nAn OPTIONS request on URI3 MUST produce the same description of R\u2019s \ncapabilities as an OPTIONS request on URI1 or URI2, as specified in \n[HTTP].\n\nA DELETE on URI3 MUST delete the binding between URI3 and R, just as a \nDELETE on URI1 would delete the bindings between URI1 and R, or a DELETE \non URI2 would delete the binding between URI2 and R.  If a DELETE \noperation removes the last binding to a resource, the resource MUST be \ndeleted as well.\n\n[Add picture]\n\n[HTTP] states that ?the DELETE method requests that the origin server \ndelete the resource identified by the Request-URI.?  However, we believe \nthat our interpretation of DELETE is consistent with the definition in \n[HTTP].  Because [HTTP] did not distinguish between bindings and \nresources, an HTTP/1.1 client would not be able to distinguish between a \nserver that deleted the resource together with all its bindings and a \nserver that deleted only the binding of the Request-URI.  Consequently, \nit is safe to interpret ?deleting the resource? in [HTTP] as ?removing \nthe binding of the resource to the request-URI?. \n\nA COPY on URI3 with ?Destination: URIX? MUST duplicate R in a new \nresource and the state associated with R in a new chunk of state, and \nthen create a mapping of URIX to the new resource.  The mappings of URI1 \nand URI2 are unaffected.  This is consistent with the definition of COPY \nin [WebDAV].\n\n[Add picture]\n\nSlein et al.                                                    Page 11\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\n*** If R is a collection, the result of COPY URI3 is . . .\n\nA MOVE on URI3 with ?Destination: URIX? MUST be logically equivalent to \nperforming a COPY on URI3 with ?Destination: URIX?, fixing the bindings \nof URI1 and URI2 to associate them with the new resource, and performing \na DELETE on URI3.  In the end, URIX, URI1, and URI2 will all be bound to \nthe new resource, and R together with its binding to URI3 will have been \ndeleted.  This is consistent with the definition of MOVE in [WebDAV], \nwhich allows for consistency maintenance processing between the COPY and \nDELETE operations, but does not define the consistency maintenance \nprocessing.  If the server cannot perform the consistency maintenance \nprocessing, it MUST fail the MOVE request.\n\n[Add picture]\n\nThe MOVE semantics can alternatively be viewed as logically equivalent \nto a BIND of URIX to R, followed by a DELETE of URI3.  In this case, the \nresult would be that URIX, URI1, and URI2 would all be bound to R, and \nURI3 would no longer be bound to R.  Since the state associated with the \nnew resource on the first interpretation is (arguably, with the possible \nexception of some property values) identical to the state associated \nwith R on the second interpretation, the two interpretations are \nequivalent.\n\n[Add picture]\n\n*** If R is a collection, the result of MOVE URI3 is . . .\n\nA LOCK on URI3 MUST produce the same result as a LOCK on URI1 or URI2, \nas specified in [WebDAV]. Resource R is locked, and the lock is visible \nvia all three URIs.  Consistent with the definition of LOCK in [WebDAV], \nif a write lock is created via URI3, it is not possible for anyone \nexcept the lock owner to modify R via any of the URIs bound to it.  Nor \nis it possible for anyone except the lock owner to LOCK any collection \nof which any of those URIs is a member, recursively upward through the \nhierarchy.  Nor is it possible for anyone except the lock owner to MOVE \nor DELETE any collection of which any of those URIs is a member, \nrecursively upward through the hierarchy.\n\nAn UNLOCK on URI3 MUST produce the same result as an UNLOCK on URI1 or \nURI2, as specified in [WebDAV].  The lock is removed from R, and is no \nlonger visible via URI1, URI2, or URI3.\n\nA PROPFIND on URI3 MUST produce the same response as a PROPFIND on URI1 \nor URI2, as specified in [WebDAV]. It retrieves properties of R.  If R \nis a collection, the behavior is still as defined in [WebDAV]: The \nproperties of R and its member resources are returned, to the depth \nrequested.\n\nA PROPPATCH on URI3 MUST produce the same result as a PROPFIND on URI1 \nor URI2, as specified in [WebDAV].  It sets or deletes properties on R.\n\nA MKCOL on URI3 MUST produce the same result as a MKCOL on URI1 or URI2, \nas specified in [WebDAV].  It fails, since a resource is already bound \n\nSlein et al.                                                    Page 12\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nto URI3.\n\nA MKREF on URI3 MUST produce the same result as a MKREF on URI1 or URI2, \nas specified in Section 4.5.1.  By default it overwrites R with a new \nredirect reference.\n\nAn ORDERPATCH on URI3 MUST produce the same result as an ORDERPATCH on \nURI1 or URI2, as specified in 5.5.1.  Assuming that R is a collection \nwith a client-maintained ordering, it modifies the ordering of R\u2019s \nmembers.\n\n4.4.1 Bindings to Collections\n\nBIND can create a binding to a collection resource.  A collection \naccessed through such a binding behaves exactly as would a collection \naccessed through any other binding.  Bindings to collections can result \nin loops, which servers MUST detect when processing \"Depth: infinity\" \nrequests.  When a loop is detected, the server MUST respond with a 506 \n(Loop Detected) status code (defined in Section 7.1).\n\n4.5 Creating Redirect References\n\n4.5.1 The MKREF Method\n\nRedirect references are created using the MKREF method.  Since a \nredirect reference is a resource, the request-URI of the MKREF request \nidentifies the resource to be created.  \n\nSeveral headers defined in this specification are used in MKREF \nrequests:  \n\no The Ref-Target header (defined in Section 6.1) MUST be included in \n  every MKREF request to identify the target resource of the new \n  reference.  \no The Ref-Integrity header (defined in Section 6.3) MUST be included in \n  every MKREF request to indicate whether and how referential integrity \n  should be enforced for the new reference.  \no The Position request header (defined in Section 6.6) MAY be used in \n  MKREF requests to indicate where the new reference is to be placed in \n  its parent collection's ordering.\n\nMKREF requests MAY include an entity body.  This specification does not \ndefine the body, but allows it for extensibility. \n\nIf a MKREF request has a request-URI that identifies an existing \nresource, the existing resource MUST be overwritten by default.  This \nbehavior is analogous to the behavior of the PUT method [HTTP].  The \ndefault behavior can be overridden using the Overwrite header defined in \nSection 9.6 of [WebDAV].\n\n4.5.2 Status Codes\n\nSome typical client errors for MKREF, and the appropriate response \nstatus codes, include: \n\n\nSlein et al.                                                    Page 13\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n400 (Bad Request): The client set an invalid value for the Ref-Target, \nRef-Integrity, or Position header.\n\n409 (Conflict): Several conditions may produce this response.  There may \nbe no resource at the location specified in Ref-Target, on a server that \nprohibits dangling references.  The request may be attempting to create \nthe reference in a collection that does not exist.  The request may be \nattempting to position the reference before or after a resource that is \nnot in the collection, or before or after itself.  The request may be \nattempting to position the reference in an unordered collection.\n\n412 (Precondition Failed): The Overwrite header is \"F\", and a resource \nalready exists at the request-URI.  Or the server does not support the \nspecified Ref-Integrity value for the request-URI.\n\n4.5.3 Example: MKREF\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: /i-d/draft-webdav-protocol-08.txt\nRef-Integrity: do-not-enforce\n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  Its DAV:resourcetype property is \nset to DAV:reference.  Its DAV:reftarget property is set to the URI of \nits target resource.  Since the Ref-Integrity header asks the server not \nto enforce referential integrity for the new reference, the server sets \nits DAV:refintegrity property to the value of DAV:weak, indicating that \nthe server will not enforce referential integrity for the new reference. \n\n4.6 Listing the Redirect References in a Collection\n\nA URI of a redirect reference can be a member of a collection just as \nthe URI of an ordinary resource can.  A listing of the members of a \ncollection shows all of the URIs in the collection, whether they \nidentify redirect references or ordinary resources.  That is, a WebDAV \nPROPFIND request on a collection resource with Depth = 1 or infinity \nMUST return a response XML element for each URI in the collection, \nwhether it identifies an ordinary resource or a referential resource.\n\nFor each redirect reference, the response element MUST contain a 302 \n(Moved Temporarily) status code unless a Passthrough header with the \nvalue \"F\" is included with the PROPFIND request.  The DAV:location and \nDAV:resourcetype properties MUST be included with the 302 status code, \nextending the syntax of the DAV:response element that was defined in \n[WebDAV] as described in Section 9 below.  A referencing-aware client \ncan tell from the DAV:resourcetype property that the collection contains \na redirect reference.  The DAV:location property contains the absolute \n\nSlein et al.                                                    Page 14\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nURI of the target resource.  A referencing-aware client can either use \nthe URI value of the DAV:location property to retrieve the properties of \nthe target resource, or it can submit a PROPFIND to the redirect \nreference with \"Passthrough: F\" to retrieve its properties.  It is \nrecommended that future editors of [WebDAV] define the DAV:location \nproperty in [WebDAV], so that non-referencing clients will also be able \nto use the response to retrieve the properties of the target resource.\n\nIf Depth = infinity in the PROPFIND request, the server MUST NOT follow \nredirect references into any collections to which they may refer.\n\nThe Passthrough header (defined in Section 6.4) MAY be used with a \nPROPFIND request on a collection.  A value of \"F\" in the Passthrough \nheader indicates that the client wants to see the properties of the \nredirect references contained in the collection, not the properties of \ntheir target resources. \n\n4.6.1 Example: PROPFIND on a Collection with Redirect References\n\nSuppose a PROPFIND request with Depth = infinity is submitted to the \nfollowing collection, with the members shown here:\n\nhttp://www.svr.com/MyCollection/\n   (ordinary resource) diary.html\n   (redirect reference) nunavut\n\nRequest:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV: \">\n   <D:prop xmlns:J=\"http://www.svr.com/jsprops/\">\n      <D:resourcetype/>\n      <J:keywords/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\"\n               xmlns:J=\"http://www.svr.com/jsprops/\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n\nSlein et al.                                                    Page 15\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            <D:resourcetype><D:collection/></D:resourcetype>\n            <J:keywords>diary, interests, hobbies</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n            <J:keywords>diary, travel, family, history</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location> \n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:resourcetype>reference</D:resourcetype>\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nIn this example Depth = infinity, and the Passthrough header is not \nused.  The collection contains one URI that identifies a redirect \nreference.  The response element for the redirect reference has a status \nof 302 (Moved Temporarily), and includes a DAV:prop element with the \nDAV:location and DAV:resourcetype properties to allow clients to \nretrieve the properties of its target resource.  (The response element \nfor the redirect reference does not include the requested properties.  \nThe client can submit another PROPFIND request to the URI in the \nDAV:location property to retrieve those properties.) \n\n4.6.2 Example: PROPFIND with Passthrough: F on a Collection with \nRedirect References\n\nSuppose a PROPFIND request with Passthrough = F and Depth = infinity is \nsubmitted to the following collection, with the members shown here:\n\n/MyCollection/\n  (ordinary resource) diary.html\n  (redirect reference) nunavut\n\nRequest:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nPassthrough: F\nContent-Type: text/xml\n\nSlein et al.                                                    Page 16\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n<D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n            <D:reftarget>\n               <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n            </D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n\nSlein et al.                                                    Page 17\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n   </D:response>\n</D:multistatus>\n\nSince the Passthrough header has the value \"F\", the response shows the \nproperties of the redirect reference in the collection rather than the \nproperties of its target. The value of the Passthrough header also \nprevents a 302 response from being returned for the redirect reference.\n\n4.7 Copying Redirect References\n\nA client's intent in performing a COPY operation is to create a new \nresource that is similar to the original resource and behaves like the \noriginal resource, and that can be modified without affecting the \noriginal resource.  For a COPY request to a redirect reference, the \nexpectation would be a 302 response that the client could use to copy \nthe target resource.  This would yield an independent resource that \ncould be modified without affecting the original resource.  For COPY \nrequests to collections that contain redirect references, the situation \nis less clear.  There is tension between two expectations. On the one \nhand, the client may expect the new copy of the collection to behave \nlike the old one (which implies having references where the old one had \nreferences).  On the other hand, the client may expect that it will be \npossible to modify the members of the new collection without affecting \nthe members of the old collection (which implies having copies of the \ntargets where the original collection had references).\n\nFor a COPY request on an individual reference, the response MUST be a \n302 (Move Temporarily) status code, with the URI of the target resource \nin the Location header, and \"Resource-Type: reference\" to distinguish \nthe response from an ordinary HTTP redirect.  This is the normal \nbehavior for redirect references, allowing the client to resubmit the \nrequest to the target resource identified in the Location header.  This \nalso yields intuitively correct behavior for a COPY request to an \nindividual reference.  Reference-aware clients can use the Passthrough \nheader with the value \"F\" to copy the redirect reference itself.\n\nFor COPY on a collection containing redirect references, different \nsemantics may be desirable in different scenarios.  Consequently, we \nhave made a fairly arbitrary choice to take the simplest path.  When a \nCOPY request is submitted to a collection containing redirect \nreferences, the server MUST copy the redirect references to the new \ncollection rather than returning 302 status codes for them.  This will \nresult in a new collection that behaves like the old one, and avoids \nresponding with multiple 302 status codes, each of which the client \nwould have to process separately.  Reference-aware clients can force the \nserver to respond with 302 status codes rather than copying the \nreferences by using the Passthrough header with the value \"T\".\n\n4.7.1 Example: COPY on a Redirect Reference\n\nRequest:\n\nCOPY /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/tuva.html\n\nSlein et al.                                                    Page 18\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nResponse:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Asia/History/tuva.html\nResource-Type: reference\n\nIn this example, the request-URI identifies a redirect reference whose \ntarget resource is identified by \nhttp://www.svr.com/Asia/History/tuva.html.  In this case, the server \nresponded with a 302, and provided the URL of the target resource in the \nLocation header.  The Resource-Type header indicates to a reference-\naware client that this is not an HTTP 1.1 redirect, but a reference to \nthe resource identified by the Location header.  The client can now \nresubmit the COPY request to the target resource, producing the desired \nresult: a duplicate of the original target resource that can be modified \nindependently of the original.\n\n4.7.2 Example: COPY on a Collection That Contains a Redirect Reference\n\nSuppose a COPY request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n     (ordinary resource) diary.html\n     (redirect reference) nunavut with target /Someplace/nunavut.map\n\nRequest:\n\nCOPY /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this case, since /MyCollection/nunavut is a redirect reference, the \nreference itself, and not its target, was copied into the new \ncollection.  So the resulting collection is as follows:\n\n/OtherCollection/\n      (ordinary resource) diary.html\n      (redirect reference) nunavut \n\n4.8 Deleting and Moving Redirect References\n\nThe DELETE method is used to delete redirect references. DELETE MUST \naffect the reference itself, and not its target.  Similarly, when a \nDELETE on a collection encounters a redirect reference in the subtree \nunder that collection, it MUST delete the reference, and not its target.\n\nA MOVE operation on a redirect reference MUST move the reference to a \ndifferent location, and MUST NOT change the location of its target. The \nDAV:reftarget property is unchanged after a MOVE.  Similarly, when a \n\nSlein et al.                                                    Page 19\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nMOVE on a collection encounters a redirect reference in the subtree \nunder that collection, it MUST move the reference, and not its target.\n\nDELETE and MOVE differ from other methods in that they do not alter the \nresource that is being deleted or moved, but rather the collection that \ncontains its URI.  They change the membership of that collection.\n\nWhen a redirect reference is added to a collection, the aim is to make \nit look as if the target resource were a member of that collection.  \nWhen the reference is removed from that collection, the aim is to change \nthe membership of that collection.  Membership of the target in any \nother collections, either internally or by reference, should not be \naffected.  Consequently, DELETE and MOVE do not follow the normal rules \nof behavior for references.  Instead, they are always applied to the \nreference itself, not to its target, and they never result in 302 status \ncodes.\n\n*** Reference-aware clients MAY use the Passthrough header with the \nvalue \"T\" in DELETE and MOVE requests to cause a 302 response, which can \nthen be used to resubmit the request to the target resource. [This would \ncause 302s in multi-status responses for collections.]\n\n4.9 Locking Redirect References\n\nThe semantics of LOCK described here resulted from balancing a set of \nincompatible considerations:\n\no Ideally, a LOCK on a redirect reference should lock both the \n  reference and its target resource.  The owner of an exclusive write \n  lock, for example, would be surprised if anyone else could modify the \n  content of the target resource while he held the lock.  He would also \n  be surprised if anyone else could delete the reference to it, or \n  replace the reference with one pointing to a different target.\no Non-referencing clients should be able to use redirect references \n  without encountering surprising results.\no The basic characteristics of redirect references should be honored.  \n  Redirect references should be simple for servers to implement. In \n  particular, a server should never have to resolve a redirect \n  reference.  A server should not have to provide proxy capabilities in \n  order to implement redirect references.\no There should be consistency between the behavior of LOCK on a single \n  redirect reference and the behavior of LOCK on a collection that \n  contains redirect references.\no The behavior of all requests to redirect references should be as \n  consistent as possible. In the absence of a Passthrough header, all \n  methods should return a 302 when sent to a redirect reference.\no LOCK semantics for redirect references should be consistent with the \n  LOCK semantics defined in [WebDAV].\n\nWe have compromised the intuitive locking behavior and support for non-\nreferencing clients in order to preserve various sorts of consistency. \n\n4.9.1 LOCK on Redirect References\n\nThe behavior of LOCK for redirect references was determined by what is \n\nSlein et al.                                                    Page 20\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\npossible for the case of locking collections that contain redirect \nreferences.  \n\nThe expected behavior for any operation on a redirect reference is that \na 302 (Moved Temporarily) response will be returned, unless the \nPassthrough header with a value of \"F\" is used.  However, this policy \nwould have unacceptable consequences when locking a collection that \ncontains redirect references.  Since [WebDAV] requires LOCK on a \ncollection to be an atomic operation, if a 302 response is received for \nany member of the collection, the entire LOCK must fail.  This would \nmake it impossible to lock any collection that contained a redirect \nreference. \n\nTo avoid this result, a LOCK with Depth > 0 on a collection MUST lock \nany redirect references it encounters, and not return 302 responses for \nthem, unless the Passthrough header with a value of \"T\" is used.  Use of \nthe Passthrough header with a value of \"T\" in a LOCK request on a \ncollection will cause the entire lock to fail if a redirect reference is \nencountered.\n\nThis gives part of the expected default lock behavior without forcing \nthe server to resolve the redirect reference or become a proxy server in \ncases where the target resides on a different server. \n\nThere will be no hint in any response code that there are redirect \nreferences whose targets need to be locked.  The client will most likely \nnot lock any targets until it attempts an operation on the target and \ngets a 302 response.  Non-referencing clients cannot lock the targets of \nthe redirect references and may never realize that the targets have not \nbeen locked.  \n\nClearly, a LOCK with Depth = infinity on a collection MUST NOT follow \nany redirect references whose targets are collections into the target \ncollections; it MUST NOT cause any members of those target collections \nto be locked.\n\nThe behavior of LOCK for individual redirect references is designed to \nbe consistent with LOCK behavior for collections that contain redirect \nreferences.  By default a LOCK on a redirect reference MUST lock only \nthe reference, not its target, and it MUST NOT return a 302 response.  A \nreference-aware client can use the Passthrough header with a value of \n\"T\" to get a 302 response with the URI of the target resource in the \nLocation header.\n\nUNLOCK behaves as specified in [WebDAV], unlocking all resources \nincluded in the lock identified by the Lock-Token header.\n\n4.9.2 Example: LOCK on a Redirect Reference\n\nRequest:\n\nLOCK /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nContent-Type: text/xml\nContent-Length: nnnn\n\nSlein et al.                                                    Page 21\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\nResponse:\n\nHTTP/1.1 200 OK\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:prop xmlns:D=\"DAV:\">\n   <D:lockdiscovery>\n      <D:activelock>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:locktype><D:write/></D:locktype>\n         <D:depth>0</D:depth>\n         <D:owner>\n            <D:href>http://www.svr.com/~jas/contact.html</D:href>\n         </D:owner>\n         <D:locktoken>\n            opaquelocktoken:e71dfae-5dec-22d6-fea5-00a0c91e6be4\n         </D:locktoken>\n      </D:activelock>\n   </D:lockdiscovery>\n</D:prop>\n\nThe request and response look exactly as specified in [WebDAV].  In this \nexample, the request-URI identifies a redirect reference, which was \nsuccessfully locked.  The target resource of the redirect reference is \nnot locked.\n\n4.9.3 Example: LOCK on a Collection That Contains a Redirect Reference, \nwith Passthrough: T\n\nSuppose a LOCK request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n     (ordinary resource) diary.html\n     (redirect reference) nunavut\n\nRequest:\n\nLOCK /MyCollection/ HTTP/1.1\n\nSlein et al.                                                    Page 22\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nHost: www.svr.com\nPassthrough: T\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"Dav:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop><D:lockdiscovery/></D:prop>\n         <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location>\n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:resourcetype>reference</D:resourcetype>\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nThe \"Passthrough: T\" header caused the server to return a 302 response \ncode for the redirect reference in the collection.  Consequently, \nneither the collection nor any of its members were locked.  A \nreferencing-aware client can submit a separate LOCK request to the URI \nin the DAV:location property returned for the redirect reference, and \ncan resubmit the LOCK request with \"Passthrough: F\" to the collection.  \n\nSlein et al.                                                    Page 23\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nAt that point both the reference and its target will be locked (as well \nas the collection and all its other members).\n\n4.10 Other WebDAV Operations on Redirect References\n\nAlthough non-referencing WebDAV clients cannot create referential \nresources, they should be able to use the references created by \nreference-aware WebDAV clients.  They should be able to follow any \nreferences to their targets.  To make this possible, a server that \nreceives a PROPFIND, PROPPATCH, MKCOL, MKREF, BIND, or ORDERPATCH \nrequest made via a redirect reference MUST return a 302 (Moved \nTemporarily) status code. The client and server MUST follow [HTTP] \nSection 10.3.3 \"302 Moved Temporarily,\" but with these additional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Resource-Type header.  This header \n  allows reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nA reference-aware WebDAV client can act on this response in one of two \nways.  It can, like a non-referencing client, resubmit the request to \nthe URI in the Location header in order to operate on the target \nresource.  Alternatively, it can resubmit the request to the URI of the \nredirect reference with the Passthrough header set to \"F\" in order to \noperate on the reference itself.  If the Passthrough header is present \nwith a value of \"F\", the request MUST be applied to the reference \nitself, and a 302 response MUST NOT be returned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, and if the client wants to \napply the method to the reference, it can save the round trip caused by \nthe 302 response by using \"Passthrough: F\" in its initial request to the \nURI.\n\nSince MKCOL fails when applied to existing resources, if the client \nattempts to resubmit the request to the target resource, the request \nMUST fail (unless the reference is a dangling reference).  Similarly, if \nthe client attempts to resubmit the request to the reference with \n\"Passthrough: F\", the request MUST fail.\n\nSince ORDERPATCH applies only to collections, an ORDERPATCH request with \na Passthrough header with the value \"F\" on a redirect reference MUST \nfail.\n\n4.10.1 Example: PROPPATCH on a Redirect Reference\n\nTo Be Supplied\n\n4.11 HTTP Operations on Redirect References\n\nAlthough existing HTTP clients cannot create referential resources, they \nshould be able to use collections created by reference-aware WebDAV \nclients.  They should be able to follow any references identified by \n\nSlein et al.                                                    Page 24\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nURIs in those collections to their targets.  To enable existing HTTP \nclients to use GET, HEAD, PUT, POST, or OPTIONS via redirect references, \na server that receives any of these requests on a redirect reference \nMUST return a 302 (Moved Temporarily).  The client and server MUST \nfollow [HTTP] Section 10.3.3 \"302 Moved Temporarily,\" but with these \nadditional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Resource-Type header.  This header \n  allows reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nReference-aware clients can act on a 302 response in either of two ways.  \nLike plain HTTP clients, they can resubmit the request to the URI in the \nLocation header (the URI of the target resource).  They may, however, \nwant to operate on the reference rather than on its target.  In this \ncase, they may resubmit the request to the URI of the reference and \ninclude the Passthrough header with the value \"F\" in the request.  If \nthe Passthrough header is present with a value of \"F\", the request MUST \nbe applied to the reference itself, and a 302 response MUST NOT be \nreturned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, and if the client wants to \napply the method to the reference, it can save the round trip caused by \nthe 302 response by using \"Passthrough: F\" in its initial request to the \nURI.\n\n\"Passthrough: F\" can be used with GET or HEAD to retrieve the entity \nheaders of a redirect reference.  When \"Passthrough: F\" is used with GET \nor HEAD, the referencing entity headers (Ref-Type and Ref-Target) MUST \nbe returned, along with all HTTP headers that make sense for references \n(at a minimum, Cache-Control, Age, ETag, Expires, and Last-Modified).  \n\n\"Passthrough: F\" can be used with PUT to replace the redirect reference \nwith an ordinary resource.  It can be used with OPTIONS to retrieve the \ncapabilities of a redirect reference.  \n\nClients MUST NOT, however, use \"Passthrough: F\" with POST. Since a \nreference cannot accept another entity as its subordinate, an attempt to \nPOST to a reference with \"Passthrough: F\" will also fail.  If a server \nreceives a POST request with \"Passthrough: F\" on a redirect reference, \nit MUST fail the request with a 400 (Bad Request) status code.\n\n4.11.1 Example: GET on a Redirect Reference\n\nTo Be Supplied\n\n4.11.2 Example: GET on a Redirect Reference with \"Passthrough: F\"\n\nTo Be Supplied\n\n4.12 Operations on Targets of Redirect References\n\nSlein et al.                                                    Page 25\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nIn general, operations on targets of weak redirect references have no \neffect on the reference.  However, servers that choose to maintain the \nintegrity of redirect references are free to make changes to the state \nof redirect references when moving or deleting their targets.\n\nWhen moving a target resource, a server MAY insert an optional step into \nthe semantics of MOVE as defined in [WebDAV] for the purpose of \nmaintaining referential integrity.  Between the copy step and the delete \nstep of a MOVE, the server MAY perform an update step, which changes the \nDAV:reftarget property of any references to the target to reflect its \nnew location.\n\nWhen deleting a target resource, a server MAY perform any internal \noperations necessary to implement its policy on preserving referential \nintegrity.  For example, it might delete any redirect references to the \ndeleted target, or it might flag them as having a deleted target, or it \nmight replace redirect references with copies of the target.\n\n4.13 Discovering a Target's References\n\nAn OPTIONAL DAV:references property on the target resource provides a \nlist of referential resources whose DAV:reftarget property points to \nthat target resource. By retrieving this property, a client can discover \nthe URIs of the references that point to the target, and so can also \ndiscover the collections that contain those URIs as members.  As for all \nDAV: properties, this specification is silent as to how the \nDAV:references property is implemented on the server.\n\nThe DAV:references property is expected to be supported mainly by \nDocument Management Systems (DMSs) and other servers that will maintain \nthe property only for references within their own domain.  It is not in \ngeneral possible for a server to maintain the property for references on \nother servers.  If a reference on a different server points to the \ntarget, the server where the target is located is unlikely to know about \nthat reference.  This protocol provides no mechanism for one server to \nnotify another of the creation of a reference to one of its resources.  \nConsequently, the list of references in DAV:reftarget may be incomplete.\n\nRationale: A number of scenarios require clients to navigate from a \ntarget resource to the references that point to it, and to the \ncollections that contain the URIs of those references.  This capability \nis particularly important for DMSs, which may populate their collections \nentirely by reference.  Their clients may need to determine, for any \nobject in the DMS, what collections contain URIs that identify \nreferences to that object.  It is also important in other contexts.  For \nexample, some servers enforce referential integrity by refusing to \ndelete any resource that is referenced by other resources.  In such an \nenvironment, the client must be able to discover the references in order \nto delete them before attempting to delete the target.\n\nRisks: When deciding whether to support the DAV:references property, \nserver implementers / administrators should balance the benefits it \nprovides against the cost of maintaining the property and the security \nrisks enumerated in Sections 12.5 and 12.6.\n\nSlein et al.                                                    Page 26\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\n*** What to do about this section.  Have a separate DAV:bindings \nproperty?  Have the DAV:references property include both redirect \nreferences and bindings, but distinguish between them?  Part of the \nrationale (having to do with referential integrity) doesn\u2019t apply to \nbindings, but some applications will still want to know what bindings \nthere are to a given resource.  There is no other way to discover \nbindings to a resource, since bindings do not have the DAV:reftarget \npropety.\n\n4.14 Relative URIs in Ref-Target and DAV:reftarget\n\nThe URI in a Ref-Target header MAY be a relative URI.  Similarly, the \nhref in a DAV:reftarget property MAY be a relative URI.  In both cases, \nthe base URI to be used for resolving the relative URI to absolute form \nis the URI of the redirect reference to which the Ref-Target header or \nDAV:reftarget property belongs.  \n\nIn the case of a Ref-Target header, the base URI is constructed as \nfollows: Its scheme component is \"http\", its authority component is the \nvalue of the Host header in the request, and its path component is the \nrequest-URI in the request.  See [URI] Section 5 for a discussion of \nrelative URI references and how to resolve them.\n\nThe DAV:reftarget property appears in the protocol only in the context \nof a Multi-Status response, in a response element that contains a single \nDAV:href element.  The value of this DAV:href element serves as the base \nURI for resolving a relative URI in DAV:reftarget.  The value of \nDAV:href may itself be relative, in which case it must be resolved first \nin order to serve as the base URI for the relative URI in DAV:reftarget.  \nIf the DAV:href element is relative, its base URI is constructed from \nthe scheme component \"http\", the value of the Host header in the \nrequest, and the request-URI.\n\n4.14.1 Example: Resolving a Relative URI in Ref-Target\n\nRequest:\n\nMKREF /north/inuvik HTTP/1.1\nHost: www.somehost.edu\nRef-Target: mapcollection/inuvik.gif\nRef-Integrity: do-not-enforce\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this example, the base URI is http://www.somehost.edu/north/inuvik.  \nThen, following the rules in [URI] Section 5, the relative URI in Ref-\nTarget resolves to the absolute URI \nhttp://www.somehost.edu/north/mapcollection/inuvik.gif. \n\n4.14.2 Example: Resolving a Relative URI in DAV:reftarget\n\nRequest:\n\nSlein et al.                                                    Page 27\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nPROPFIND /geog/ HTTP/1.1\nHost: www.xxsvr.com\nPassthrough: F\nDepth: 1\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1/0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>/geog/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n     </D:propstat>\n     <D:propstat>\n         <D:prop><D:reftarget/></D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n     </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>/geog/stats.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n            <D:reftarget>statistics/population/1997.html</D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nIn this example, the relative URI statistics/population/1997.html is \nreturned as the value of reftarget for the reference identified by href \n/geog/stats.html.  The href is itself a relative URI, which resolves to \nhttp://www.xxsrv.com/geog/stats.html.  This is the base URI for \nresolving the relative URI in reftarget.  The absolute URI of reftarget \nis http://www.xxsrv.com/geog/statistics/population/1997.html.\n\nSlein et al.                                                    Page 28\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\n4.15 Redirect References to Collections\n\nIn a request-URI /segment1/segment2/segment3, any of the three segments \nmay identify a redirect reference.  (See [URI], Section 3.3, for \ndefinitions of \"path\" and \"segment\".)  It will not be possible to \nresolve such URIs unless certain constraints hold.  If any segment of \nthe path except the last identifies a reference, that reference MUST \nultimately resolve to a resource that behaves as a container.  (Examples \nare WebDAV collections, tar files, and some CGI scripts.)  The \nsucceeding segment of the path MUST resolve to a resource that is \nimmediately contained in that container.\n\nConsider request-URI /x/y/z.html.  Suppose that /x/ is a reference whose \ntarget is collection /a/, which contains reference y whose target is \ncollection /b/, which contains reference z.html whose target is \n/c/d.html.  \n\n/x/ -----> /a/\n           /a/y/ -----> /b/\n                        /b/z.html -----> /c/d.html\n\nIt is possible to resolve the request-URI because each segment of the \nURI's path satisfies the constraints stated above.  Except for the final \nsegment, each segment that is a reference resolves to a collection that \ncontains the next segment as an internal member.  The final segment, \nwhich is a reference, does have a target resource. \n\nThe client must follow up three separate 302 responses before finally \nreaching the target resource.  The server responds to the initial \nrequest with a 302 with Location: /a/y/z.html, and the client resubmits \nthe request to /a/y/z.html.  The server responds to this request with a \n302 with Location: /b/z.html, and the client resubmits the request to \n/b/z.html.  The server responds to this request with a 302 with \nLocation: /c/d.html, and the client resubmits the request to /c/d.html.  \nThis final request succeeds.\n\n*** Still needs work and forest of references discussion.\n\n5 Ordered Collections\n\n5.1 Overview\n\nCollections on a compliant server may be ordered, but need not be.  It \nis up to the client to decide whether a given collection is ordered and, \nif so, to specify the semantics to be used for ordering its members.  If \na collection is ordered, each of its members must be in the ordering \nexactly once, and the ordering must not include any resource that is not \na member of the collection.  Only one ordering can be attached to any \ncollection.  Multiple orderings of the same resources can be achieved by \ncreating multiple collections referencing those resources, and attaching \na different ordering to each collection.\n\nThe server is responsible for enforcing these constraints on orderings.  \nThe server MUST remove a member URI from the ordering when it is removed \n\nSlein et al.                                                    Page 29\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nfrom the collection. The server MUST add a member URI to the ordering \nwhen it is added to the collection.\n\nWhen responding to a PROPFIND on a collection, the server MUST order the \nresponse elements according to the ordering defined on the collection.\n\nOrderings may be client-maintained or server-maintained.  This protocol \nprovides support for both types of orderings.\n\n5.2 Creating an Ordered Collection\n\n5.2.1 Overview \n\nWhen a collection is created, the client MAY request that it be ordered \nand specify the semantics of the ordering by using the new Ordered \nheader (defined in Section 6.5) in the MKCOL request.   \n\nFor collections that are ordered, the client SHOULD identify the \nsemantics of the ordering with a URI in the Ordered header.  This URI \nmay identify a server-maintained ordering.  Clients can discover the \navailable server-maintained orderings using the mechanism defined in \nSection 10.3.  The URI may identify a semantics for a client-maintained \nordering, providing the information a human user or software package \nneeds to insert new collection members into the ordering intelligently.  \nAlthough the URI in the Ordered header MAY point to a resource that \ncontains a definition of the semantics of the ordering, clients are \ndiscouraged from accessing that resource, in order to avoid \noverburdening its server.  The client MAY set the header value to \nDAV:custom to indicate that the collection is ordered, but the semantics \nof the ordering are not being advertised.  If the client does not want \nthe collection to be ordered, it may omit the Ordered header, or use it \nwith the value DAV:unordered.\n\nIf the server does not recognize the value of the Ordered header as one \nof its server-maintained orderings, it MUST assume that a client-\nmaintained ordering is intended.  If the value of the Ordered header is \none of the server-maintained orderings that the server supports, it MUST \nmaintain the collection's ordering according to that ordering semantics \nas new members are added.\n\nEvery collection MUST have the new DAV:orderingtype property (defined in \nSection 7.5), which indicates whether the collection is ordered and, if \nso, identifies the semantics of the ordering.  The server sets the \ninitial value of this property based on the value of the Ordering header \nin the MKCOL request.\n\nIf the collection is ordered, the server MUST respond to PROPFIND \nrequests on the collection using the specified ordering. If the \ncollection is unordered, the client cannot depend on the repeatability \nof the ordering of results from a PROPFIND request.\n\n5.2.2 Example: Creating an Ordered Collection\n\nRequest:\n\n\nSlein et al.                                                    Page 30\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nMKCOL /theNorth/ HTTP/1.1\nHost: www.server.org\nOrdered: http://www.server.org/orderings/compass.html\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this example, a new, ordered collection was created.  Its \nDAV:orderingtype property has as its value the URI from the Ordered \nheader.  In this case, the URI identifies the semantics governing a \nclient-maintained ordering.  As new members are added to the collection, \nclients or end users can use the semantics to determine where to \nposition the new members in the ordering. \n\n5.3 Setting the Position of a Collection Member\n\n5.3.1 Overview\n\nWhen a new member is added to a collection with a client-maintained \nordering (for example, with PUT, MKREF, or MKCOL), its position in the \nordering can be set with the new Position header (defined in Section \n6.6).  The Position header allows the client to specify that the member \nshould be first in the collection's ordering, last in the collection's \nordering, before some other collection member in the collection's \nordering, or after some other collection member in the collection's \nordering.\n\n5.3.2 Status Codes\n\nSome likely client errors and the corresponding response status codes \ninclude: \n\n409 (Conflict): The request may be attempting to position the collection \nmember before or after a URI that is not in the collection, or before or \nafter itself, or it may be attempting to position the collection member \nin an unordered collection or in a collection with a server-maintained \nordering.\n\n5.3.3 Examples: Setting the Position of a Collection Member\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: http://www.ics.uci.edu/i-d/draft-webdav-protocol-08.txt\nPosition: After <requirements.html>       \n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  The Position header in this \n\nSlein et al.                                                    Page 31\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nexample caused the server to set its position in the ordering of the \n/~whitehead/dav/ collection immediately after requirements.html.\n\nRequest:\n\nMOVE /i-d/draft-webdav-protocol-08.txt HTTP/1.1\nHost: www.ics.uci.edu\nDestination: http://www.ics.uci.edu/~whitehead/dav/draft-webdav-\n     protocol-08.txt\nPosition: First\n\nResponse:\n\nHTTP/1.1 409 Conflict\n\nIn this case, the server returned a 409 Conflict status code because the \n/~whitehead/dav/ collection is an unordered collection.  Consequently, \nthe server was unable to satisfy the Position header.\n\n5.4 Changing the Semantics of a Collection Ordering\n\nAfter a collection has been created, a client can change its ordering \nsemantics, or change an ordered collection to an unordered collection or \nvice versa, by using PROPPATCH to change the value of its \nDAV:orderingtype property (defined in Section 7.5).  If the new value \nidentifies a client-maintained ordering, the client is then responsible \nfor updating the ordering of the collection members according to the new \nsemantics.  If it identifies a server-maintained ordering, the server \nMUST reorder the collection according to the new semantics.  PROPPATCH \nis defined in [WebDAV], Section 7.2.\n\n5.5 Changing the Position of a Collection Member\n\n5.5.1 The ORDERPATCH Method\n\nTo change the positions of collection members in the collection's \nordering, the client MUST use an ORDERPATCH request with a request body \ncontaining an order XML element.  The request-URI of an ORDERPATCH \nrequest is the URI of the collection whose ordering is to be updated.  \nThe order XML element identifies the member URIs whose positions are to \nbe changed, and describes their new positions in the ordering.  Each new \nposition can be specified as first in the ordering, last in the \nordering, before some other collection member in the ordering, or after \nsome other collection member in the ordering.  \n\nThe server MUST apply the changes in the order they appear in the order \nelement.  The server MUST either apply all the changes or apply none of \nthem.  If any error occurs during processing, all executed changes MUST \nbe undone and a proper error result returned.\n\n5.5.2 Status Codes\n\nSince multiple changes can be requested in a single ORDERPATCH request, \nthe server MUST return a 207 (Multi-Status) response, as defined in \n[WebDAV].\n\nSlein et al.                                                    Page 32\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nThe following are examples of response codes one would expect to be used \nin a 207 (Multi-Status) response for this method: \n\n200 (OK): The change in ordering was successfully made.\n\n409 (Conflict): An attempt was made to position the collection member \nbefore or after a URI that is not in the collection, or before or after \nitself, or an attempt was made to position the collection member in an \nunordered collection or in a collection with a server-maintained \nordering.\n\nA request to reposition a collection member to the same place in the \nordering is not an error. \n\n5.5.3 Example: Changing the Positions of Collection Members in the \nOrdering\n\nConsider a collection /coll-1/ with members ordered as follows:\n\nnunavut.map\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\nnunavut.desc\niqaluit.img\niqaluit.desc\n\nRequest:\n\nORDERPATCH /coll-1/ HTTP/1.1\nHost: www.nunanet.com\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:order xmlns:d=\"DAV:\">\n   <d:ordermember>\n      <d:href>nunavut.desc</d:href>\n      <d:position> \n         <d:after>\n            <d:href>nunavut.map</d:href>\n         </d:after>\n      </d:position>\n   </d:ordermember>\n   <d:ordermember>\n      <d:href>iqaluit.img</d:href>\n      <d:position>\n         <d:last/>\n      </d:position>\n   </d:ordermember>\n</d:order>\n\n\nSlein et al.                                                    Page 33\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/nunavut.desc</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/iqaluit.img</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n</d:multistatus>\n\nIf the href elements are relative URIs, as in this example, they are \ninterpreted relative to the collection that is being reordered.  In this \nexample, after the request has been processed, the collection's ordering \nis as follows:\n\nnunavut.map\nnunavut.desc\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\niqaluit.desc\niqaluit.img\n\n5.5.4 Example: Failure of an ORDERPATCH Request\n\nTo Be Supplied\n\n6 Headers\n\n6.1 Ref-Target Entity Header\n\nRef-Target = \"Ref-Target\" \":\" (absoluteURI | relativeURI)\n\nThe Ref-Target header is used with MKREF requests to identify the target \nresource of the new referential resource being created.  For an example, \nsee Section 4.5.3.\n\nTo comply with the rules specified in [HTTP] for responding to GET and \nHEAD requests, the Ref-Target entity header is also included in \nresponses to GET and HEAD that include the Passthrough header with the \nvalue \"F\".  (See Section 4.11.) \n\n6.2 Resource-Type Entity Header\n\nResource-Type = \"Resource-Type\" \":\" (\"DAV:reference\" | ext-resource-\n\nSlein et al.                                                    Page 34\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\ntype)\next-resource-type = quoted-URL \n\nThe Resource-Type header is defined primarily for use in 302 responses, \nto allow reference-aware clients to distinguish between HTTP 1.1 \nredirects and 302 responses for redirect references(see Sections 4.2, \n4.10, and 4.11).  The possible values of this header are DAV:reference, \nand ext-ref-type. The value ext-ref-type provides extensibility.  \n\nTo comply with the rules specified in [HTTP] for responding to GET and \nHEAD requests, the Ref-Type entity header is also included in responses \nto GET and HEAD that include the Passthrough header with the value \"F\" \n(see Section 4.11).  \n\n6.3 Ref-Integrity Request Header\n\nRef-Integrity = \"Ref-Integrity\" \":\" (\"DAV:do-not-enforce\" | \n                                      ext-ref-integrity)\next-ref-integrity = quoted-URL\n\nThe Ref-Integrity header is defined primarily to allow future support \nfor strong references.  It specifies whether and how the server should \nenforce referential integrity for a referential resource being created \nwith MKREF. \n\nThe value \"DAV:do-not-enforce\" means that the client wants the server \nnot to enforce referential integrity for the newly created reference.  A \nclient might use this value if, for example, it wanted to populate a \ncollection with references before their content was made available on \nthe Web.  If the server cannot honor a Ref-Integrity value of \"DAV:do-\nnot-enforce\" in a MKREF request, it MUST fail the request with status \ncode 412 (Precondition Failed).\n\nClients may use other values of the Ref-Integrity header, to specify the \ndesired policy for enforcing referential integrity.  Clients can \ndiscover the valid values for Ref-Integrity for a given request-URI by \nsubmitting an OPTIONS request to that URI and including the \nDAV:refintegrityoptions element in the request body (see Section 10).  \nIf a server receives an extension value that it does not understand, it \nMUST fail the request with status code 400 (Bad Request).\n\nIf the Ref-Integrity header is not present on a MKREF request, the \nserver MUST fail the request with status code 400 (Bad Request).\n\n6.4 Passthrough Request Header\n\nPassthrough = \" Passthrough\" \":\" (\"T\" | \"F\")\n\nThe optional Passthrough header can be used on any request to a redirect \nreference.  If the Passthrough header has the value \"F\", the request \nMUST be applied to the reference itself, and a 302 response MUST NOT be \nreturned.  If the Passthrough header has the value \"T\", a 302 response \nMUST be returned, with the URI of the target resource in the Location \nheader and the Resource-Type header with a value \"DAV:reference\".  \n\n\nSlein et al.                                                    Page 35\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nIf the Passthrough header is used on a request to any other sort of \nresource besides a reference, the server SHOULD ignore it.  If the \nPassthrough header with the value \"F\" appears in a POST or ORDERPATCH \nrequest to a reference, the server MUST respond with a 400 (Bad \nRequest).\n\nBy default, PROPFIND operations on collections behave as if they \nincluded \"Passthrough: T\".  \"Passthrough: F\" can be used with PROPFIND \nrequests on collections with Depth = infinity.  When it is used in this \nway, the server MUST return the properties of any redirect references in \nthe collection, and not return 302 (Moved Temporarily) status codes for \nthem.  \n\nBy default, LOCK operations on collections with Depth = infinity behave \nas if they included \"Passthrough: F\".  If \"Passthrough: T\" is used with \na LOCK request on a collection with Depth = infinity, and a redirect \nreference is encountered during processing, the server MUST include a \n302 response code for the redirect reference.  Since [WebDAV] defines \nLOCK to be an atomic operation, if any redirect references are \nencountered, the entire LOCK operation fails. \n\nBy default, COPY operations on collections with Depth > 0 behave as if \nthey included \"Passthrough: F\". If \"Passthrough: T\" is used with a COPY \nrequest on a collection with Depth > 0, and a redirect reference is \nencountered during processing, the server MUST include a 302 response \ncode for the redirect reference.  As specified in [WebDAV], the server \nSHOULD complete as much of the COPY operation as it can while preserving \na consistent namespace.\n\n6.5 Ordered Entity Header\n\nOrdered = \"Ordered\" \":\" (\"DAV:unordered\" | \"DAV:custom\" | absoluteURI)\n\nThe Ordered header may be used with MKCOL to request that the new \ncollection be ordered and to specify its ordering semantics.  A value of \n\"DAV:unordered\" indicates that the collection is not ordered. A value of \n\"DAV:custom\" indicates that the collection is to be ordered, but the \nsemantics of the ordering is not being advertised.  Any other \nabsoluteURI value indicates that the collection is ordered, and \nidentifies the semantics of the ordering.  The absoluteURI MAY point to \na resource that contains a definition of the semantics of the ordering.  \n\nIf the Ordered header is present on a MKCOL request, the server MUST set \nthe collection's DAV:orderingtype property to the value of the Ordered \nheader.  If the Ordered header is not present, the server MUST treat the \nrequest as if it had an Ordered header with the value \"DAV:unordered\".  \n\n6.6 Position Request Header\n\nPosition = \"Position\" \":\" (\"First\" | \"Last\" | \n                           ((\"Before\" | \"After\") Generic-Coded-url))\nGeneric-Coded-url = \"<\" (absoluteURI | relativeURI) \">\"\nabsoluteURI and relativeURI are defined in [URI].\n\nThe Position header may be used with any method that adds a member to a \n\nSlein et al.                                                    Page 36\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\ncollection with a client-maintained ordering, to tell the server where \nin the collection ordering to position the new member being added to the \ncollection.  It may be used for both ordinary and referential members.\n\nIf the Coded-url is a relative URL, it is interpreted relative to the \ncollection to which the new member is being added. \n\nThe server MUST insert the new member into the ordering at the location \nspecified in the Position header, if one is present (and if the \ncollection has a client-maintained ordering). \n\nIf the request is replacing an existing resource, and the Position \nheader is present, the server MUST remove the member from its previous \nposition, and then insert it at the requested position.\n\nIf the Position request header is not used when adding a member to a \ncollection with a client-maintained ordering, then:\n\nIf the request is replacing an existing resource, the server MUST \npreserve the present ordering.\n\nIf the request is adding a new member to the collection, the server MUST \nappend the new member to the end of the ordering.\n\nIf an attempt is made to use the Position header on a collection that is \nunordered or that has a server-maintained ordering, the server MUST fail \nthe request with a 409 (Conflict) status code.\n\n7 Status Codes\n\n7.1 506 Loop Detected\n\nThe 506 (Loop Detected) indicates that the server detected an infinite \nloop while processing a request with \"Depth: infinity\".  It is possible \nfor loops to be created by BIND requests that create bindings to \ncollection resources.  This specification does not prohibit such loops \nfrom being created, but does require servers to detect them while \nprocessing requests that encounter loops.\n\n8 Properties\n\n8.1 reftarget Property\n\nName:\t    reftarget\nNamespace:  DAV:\nPurpose:    A property of redirect references that provides an efficient \n            way for clients to discover the URI of the target resource.  \n            This is a read-only property, whose value can only be set by \n            using the Ref-Target header with a MKREF request.\nValue: \t    URI of the target resource.  This value MAY be a relative       \n            URI.  The reftarget property can occur in the entity bodies \n            of responses to PROPFIND requests.  It always occurs in the \n            context of a Multi-Status response, inside a DAV:response \n            element that has a single DAV:href element.  \n\n\nSlein et al.                                                    Page 37\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n<!ELEMENT reftarget href>\n\n8.2 refintegrity Property\n \nName:\t    refintegrity\nNamespace:  DAV:\nPurpose:    A property of a redirect reference that indicates whether \n            and how the server enforces referential integrity for that \n            reference.  The refintegrity property is defined to allow \n            future support for strong references.  The only value \n            currently defined for refintegrity is weak, which means that \n            the server does not enforce referential integrity for the \n            reference.  A server may assign another value to identify \n            its policy for enforcing referential integrity for the \n            reference.  This is a read-only property, set based on the \n            value of the Ref-Integrity header in the MKREF request that \n            created the reference.\nValue:\t    weak or an extension value\n\n<!ELEMENT refintegrity (weak | #PCDATA)>\n\n8.3 location Property\n\nName:       location\nNamespace:  DAV:\nPurpose:    For use with 302 (Moved Temporarily) response codes in \n            Multi-Status responses.  It contains the absolute URI of the \n            temporary location of the resource.  In the context of \n            redirect references, this value is the absolute URI of the \n            target resource.  It is analogous to the Location header in \n            HTTP 302 responses defined in [HTTP] Section 10.3.3 \"302 \n            Moved Temporarily.\"  Including the location property in a \n            Multi-Status response requires an extension to the syntax of \n            the DAV:response element defined in [WebDAV], which is \n            defined in Section 9 below.  This property is not expected \n            to be stored on the reference. It is modeled as a property \n            only so that it can be returned inside a DAV:prop element in \n            a Multi-Status response.\nValue:      href containing the absolute URI of the target resource.\n\n<!ELEMENT location href >\n\n8.4 references Property\n\nName:\t    references\nNamespace:  DAV:\nPurpose:    Enables clients to discover, for any target resource, what \n            references point to it and what collections contain it by \n            reference.  This is an optional property.  If present, it is \n            a read-only property, maintained by the server.\nValue:\t    List of the URIs of the references that point to the target \n            resource.\n\n<!ELEMENT references (href*)>\n\n\nSlein et al.                                                    Page 38\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n8.5 orderingtype Property\n\nName:\t    orderingtype\nNamespace:  DAV:\nPurpose:    Indicates whether the collection is ordered and, if so, \n            uniquely identifies the semantics of the ordering being \n            used.  May also point to an explanation of the semantics in \n            human and / or machine-readable form.  At a minimum, this \n            allows human users who add members to the collection to \n            understand where to position them in the ordering.\nValue:\t    unordered for an unordered collection, or a URI that \n            uniquely identifies the semantics of the collection's \n            ordering.  The value custom indicates that the collection is \n            ordered, but the semantics are not being advertised. \n\n<!ELEMENT orderingtype (unordered | custom | href) >\n\n9 XML Elements\n\n9.1 reference XML Element\n\nName: \t    reference\nNamespace:  DAV:\nPurpose:    A new value of the DAV:resourcetype property that identifies \n            its resource as a referential resource.  \nValue:\t    EMPTY\n\n<!ELEMENT reference EMPTY >\n\n9.2 weak XML Element\n\nName:\t    weak\nNamespace:  DAV:\nPurpose:    A value of the DAV:refintegrity property.  It means that the \n            server does not enforce referential integrity for the \n            reference to which the property belongs.\nValue: \t    EMPTY\n\n<!ELEMENT weak EMPTY >\n\n9.3 unordered XML Element\n\nName:\t    unordered\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is not ordered.  That is, the client cannot \n            depend on the repeatability of the ordering of results from \n            a PROPFIND request.\nValue:\t    EMPTY\n\n<!ELEMENT unordered EMPTY >\n\n9.4 custom XML Element\n\nName: \t    custom\n\nSlein et al.                                                    Page 39\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is ordered, but the semantics of the ordering \n            are not being advertised. \nValue: \t    EMPTY\n\n<!ELEMENT custom EMPTY >\n\n9.5 order XML Element\n        \nName: \t    order\nNamespace:  DAV:\nPurpose:    For use with the new ORDERPATCH method.  Describes a change \n            to be made in a collection ordering.\nValue: \t    A description of the new positions of collection members in \n            the collection's ordering.\n\n<!ELEMENT order (ordermember+) >\n\n9.6 ordermember XML Element\n \nName: \t    ordermember\nNamespace:  DAV:\nPurpose:    Occurs in the order XML Element, and describes the new \n            position of a single collection member in the collection's \n            ordering.\nValue: \t    An href containing a relative URI, and a description of its \n            new position in the ordering.  The href XML element is \n            defined in [WebDAV], Section 11.3.\n\n<!ELEMENT ordermember (href, position) >\n\n9.7 position XML Element\n\nName: \t    position\nNamespace:  DAV:\nPurpose:    Occurs in the member XML element.  Describes the new \n            position in a collection's ordering of one of the \n            collection's members.\nValue: \t    The new position can be described as first in the \n            collection's ordering, last in the collection's ordering, \n            before some other member of the collection, or after some \n            other member of the collection.\n\n<!ELEMENT position (first | last | before | after)>\n\n9.8 first XML Element\n\nName: \t    first\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as first in the collection's \n            ordering.\nValue: \t    EMPTY\n\n\nSlein et al.                                                    Page 40\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n<!ELEMENT first EMPTY >\n\n9.9 last XML Element\n\nName: \t    last\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as last in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT last EMPTY >\n\n9.10 before XML Element\n\nName: \t    before\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming before some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it precedes in the ordering\n\n<!ELEMENT before href >\n\n9.11 after XML Element\n\nName: \t    after\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming after some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it follows in the ordering\n\n<!ELEMENT after href >\n\n9.12 options XML Element\n\nName:       options\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for more detailed     \n            information about capabilities than can be provided in the  \n            DAV: response header.  Used in OPTIONS responses to provide\n            that information.\nValue:      List of elements identifying or providing the additional \n            information desired.\n\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n\n9.13 refintegrityoptions XML Element\n\nName:       refintegrityoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list of referential       \n            enforcement policies that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n\nSlein et al.                                                    Page 41\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            This is the list of valid values for the Ref-Integrity \n            Header for that request-URI.\nValue:      EMPTY on requests.  On responses, it is the list of valid \n            values for Ref-Integrity.\n\n<!ELEMENT refintegrityoptions ( (#PCDATA)+ | EMPTY) >\n\n9.14 orderingoptions XML Element\n\nName:       orderingoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list server-    \n            maintained orderings that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n            These values can be used in the Ordered header or the \n            DAV:orderingtype property to request that a particular  \n            server-maintained ordering be applied to the collection.\nValue:      EMPTY on requests.  On responses, it is the list of server-\n            maintained orderings available for the request-URI.\n\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n\n9.15 do-not-enforce XML Element\n\nName:       do-not-enforce\nNamespace:  DAV:\nPurpose:    Used in responses to OPTIONS requests for \n            refintegrityoptions, to indicate that the server can honor \n            requests that referential integrity not be enforced for the \n            request-URI.  If it is included in an OPTIONS response, then \n            the client can use it as a value of the Ref-Integrity header \n            in a MKREF request to the same URI.\nValue:      EMPTY.\n\n<!ELEMENT do-not-enforce EMPTY >\n\n10 Extensions to the DAV:response XML Element for Multi-Status Responses\n\nAs described in Sections 4.6 and 4.9, the DAV:location property and the \nDAV:reftype property may be returned in the DAV:response element of a \n207 Multi-Status response, to allow clients to resubmit their requests \nto the target resource of a redirect reference.  \n\nWhenever these properties are included in a Multi-Status response, they \nwill be placed in a DAV:prop element associated with the href to which \nthey apply.  This structure provides a framework for future extensions \nby other standards that may need to include additional properties in \ntheir responses.\n\nConsequently, the definition of the DAV:response XML element changes to \nthe following:\n\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n\nSlein et al.                                                    Page 42\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n11 Capability Discovery\n\n11.1 Compliance Classes\n\nThis specification defines OPTIONAL extensions to [WebDAV].  Since \nresource sharing and ordering are independent capabilities, a resource \nMAY support either, both, or neither of these capabilities.  A resource \nthat provides resource sharing MUST support both bindings and redirect \nreferences.  A response to an OPTIONS request MUST indicate which of \nthese capabilities the resource supports.\n\nThis specification defines three new methods: BIND and MKREF in support \nof shared resources, and ORDERPATCH in support of ordering.  The \nresponse MUST indicate which of these methods the resource allows.  In \naddition, the response MUST include the DAV header, as described in \nSections 9.1 and 15 of [WebDAV].  Two new compliance classes are defined \nhere for use with the DAV header: sharing and orderedcoll. \n\nWhen responding to an OPTIONS request, only a collection or a null \nresource can include orderedcoll in the value of the DAV header.  By \nincluding orderedcoll, the resource indicates that its immediate member \nURIs can be ordered.  It implies nothing about whether any collections \nidentified by its member URIs can be ordered.\n\nWhen responding to an OPTIONS request, any type of resource can include \nsharing in the value of the DAV header.  Including sharing indicates \nthat the server permits a redirect reference or a binding at the request \nURI.\n\n11.2 Example: Discovery of Compliance Classes\n\nRequest:\n\nOPTIONS /somecollection/ HTTP/1.1\nHOST: somehost.org\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF, ORDERPATCH\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF, ORDERPATCH\nDAV: 1, 2, sharing, orderedcoll\n\nThis response indicates that the resource /somecollection/ is level 1 \nand level 2 compliant, as defined in [WebDAV].  In addition, \n/somecollection/ supports ordering and is in a part of the server \nnamespace that allows creation of bindings and redirect references. \n\n11.3 Additional Advanced Collections Capabilities\n\n\nSlein et al.                                                    Page 43\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nClients may need detailed information about specific areas of advanced \ncollections functionality.  This information can be requested by sending \nan OPTIONS request with an XML body that includes a DAV:options element.  \nThe DAV:options element contains a list of empty elements identifying \nthe information the client needs.\n\nAs described in Section 4.5, clients are required to include the Ref-\nIntegrity header in any MKREF request to specify the desired referential \nintegrity enforcement policy for the new reference.  The only value of \nRef-Integrity defined in this specification is DAV:do-not-enforce.  If \nthe client wants referential integrity to be enforced, it needs to know \nwhat other values of Ref-Integrity the server can support.  To discover \nwhat values can be used for a particular request-URI, the client \nincludes an empty DAV:refintegrityoptions element in the DAV:options \nelement.  The response will include a DAV:refintegrityoptions element \nwith the list of supported referential integrity enforcement policies.  \nServers MUST advertise the referential integrity enforcement policies \navailable at a URI using this mechanism.\n\nAs described in Section 5.2, servers may offer a set of server-\nmaintained orderings on collections.  Clients can discover the list of \nserver-maintained orderings available for the request-URI by including \nan empty DAV:orderingoptions element in the DAV:options element.  The \nresponse will include a DAV:orderingoptions element with the list of \nsupported server-maintained orderings.  Servers SHOULD advertise the \nserver-maintained orderings available using this mechanism.\n\n11.4 Example: Discovery of Referential Integrity Options\n\nRequest:\n\nOPTIONS /somecollection/fooref HTTP/1.1\nHOST: somehost.org\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:refintegrityoptions/>\n</D:options>\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF\nDAV: 1, sharing\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:refintegrityoptions xmlns:X=\"Xerox:\">\n      <D:do-not-enforce/>\n\nSlein et al.                                                    Page 44\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n      <X:block-deletes/>\n  </D:refintegrityoptions>\n</D:options>\n\nThis response indicates that the resource /somecollection/fooref is \nlevel 1 compliant, as defined in [WebDAV].  In addition, \n/somecollection/fooref is in a part of the server namespace that allows \ncreation of bindings and redirect references.  The client also asked for \na list of the values of Ref-Integrity that are supported for \n/somecollection/fooref.  The response indicates that the values DAV:do-\nnot-enforce and Xerox:block-deletes are supported.\n\n12 Dependencies on Other Specifications\n\nTBD\n\n13 Security Considerations\n\nThis section is provided to detail issues concerning security \nimplications of which WebDAV applications need to be aware. \n\nAll of the security considerations of HTTP/1.1 and the base WebDAV \nprotocol also apply to WebDAV collections.  In addition, referential \nresources and ordered collections introduce several new security \nconcerns and increase the risk of some existing threats.  These issues \nare detailed below.\n\n13.1 Privacy Concerns\n\nBy creating redirect references on a trusted server, it is possible for \na hostile agent to induce users to send private information to a target \non a different server.   This risk is mitigated somewhat, since clients \nare required to notify the user of the redirection for any request other \nthan GET or HEAD. (See [HTTP], Section 10.3.3 Moved Temporarily.)\n\n13.2 Redirect Loops\n\nAlthough redirect loops were already possible in HTTP 1.1, the \nintroduction of the BIND and MKREF methods creates a new avenue for \nclients to create loops accidentally or maliciously.  If the referential \nresource and its target are on the same server, the server may be able \nto detect MKREF and BIND requests that would create loops. See also \n[HTTP], Section 10.3 \"Redirection 3xx.\"  Servers are required to detect \nloops caused by bindings to collections, during the processing of any \nrequests with \"Depth: infinity\".\n\n13.3 Redirect References, Bindings, and Denial of Service\n\nDenial of service attacks were already possible by posting URLs that \nwere intended for limited use at heavily used Web sites.  The \nintroduction of BIND and MKREF creates a new avenue for similar denial \nof service attacks.  Clients can now create bindings and redirect \nreferences with target resources at heavily used sites to target \nlocations that were not designed for heavy usage.\n\n\nSlein et al.                                                    Page 45\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n13.4 Private Locations May Be Revealed\n\nThere are several ways that redirect references may reveal information \nabout directory structures.  First, the DAV:reftarget property of every \nredirect reference contains the URI of the target resource.  Anyone who \nhas access to the reference can discover the directory path that leads \nto the target resource.   The owner of the target resource may have \nwanted to limit knowledge of this directory structure.\n\nSufficiently powerful access control mechanisms can control this risk to \nsome extent.  Property-level access control could prevent users from \nexamining the DAV:reftarget property.  (The Ref-Target and Location \nheaders, which are returned in most responses to requests on redirect \nreferences, reveal the same information, however.)  In some \nenvironments, the owner of a resource might be able to use access \ncontrol to prevent others from creating references to that resource.\n\nSecond, although this specification does not require servers to maintain \nreferential integrity, it does not prevent them from doing so.  If a \nserver updates a redirect reference\u2019s DAV:reftarget property when its \ntarget resource is moved, there is the risk that a private location will \nbe revealed in the new value of DAV:reftarget.  Clients can avoid this \nrisk by doing a COPY followed by a DELETE rather than a MOVE.\n\nFinally, if backpointers are maintained on the target resource, the \nowners of redirect references and bindings face these same risks.  The \ndirectory structures where references or bindings are located are \nrevealed to anyone who has access to the DAV:references property on a \ntarget resource.  Moving a redirect reference may reveal its new \nlocation to anyone with access to DAV:references on its target resource.\n\n13.5 DAV:references and Denial of Service\n\nIf the server maintains the DAV:references property in response to \nreferences created in other administrative domains, it is exposed to \nhostile attempts to make it devote resources to adding references to the \nlist.\n\n13.6 DAV:references and Malicious Deletion of Resources\n\nServers that support the DAV:references property should insure that \nclients cannot create editable properties with the name DAV:references.  \nAn editable DAV:references property would constitute a security risk on \nservers that enforce referential integrity by deleting redirect \nreferences or bindings when their target is deleted.  These servers \ncould be tricked into deleting a resource by listing it in the \nDAV:references property of some target resource.\n\n13.7 Denial of Service and DAV:orderingtype\n\nThere may be some risk of denial of service at sites that are advertised \nin the DAV:orderingtype property of collections.  However, it is \nanticipated that widely-deployed applications will use hard-coded values \nfor frequently-used ordering semantics rather than looking up the \nsemantics at the location specified by DAV:orderingtype.  In addition, \n\nSlein et al.                                                    Page 46\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nSection 5.2 discourages clients from looking up the semantics at that \nlocation.\n\n14 Internationalization Considerations\n\nThis specification follows the practices of [WebDAV] in encoding all \nhuman-readable content using XML [XML] and in the treatment of names.  \nConsequently, this specification complies with the IETF Character Set \nPolicy [Alvestrand].\n\nWebDAV applications MUST support the character set tagging, character \nset encoding, and the language tagging functionality of the XML \nspecification.  This constraint ensures that the human-readable content \nof this specification complies with [Alvestrand].\n\nAs in [WebDAV}, names in this specification fall into three categories: \nnames of protocol elements such as methods and headers, names of XML \nelements, and names of properties.  Naming of protocol elements follows \nthe precedent of HTTP, using English names encoded in USASCII for \nmethods and headers.  The names of XML elements used in this \nspecification are English names encoded in UTF-8.\n\nFor error reporting, [WebDAV] follows the convention of HTTP/1.1 status \ncodes, including with each status code a short, English description of \nthe code (e.g., 423 Locked).  Internationalized applications will ignore \nthis message, and display an appropriate message in the user's language \nand character set.\n \nFor rationales for these decisions and advice for application \nimplementors, see [WebDAV].\n\n15 IANA Considerations\n\nThis document uses the namespaces defined by [WebDAV] for properties and \nXML elements.  All other IANA considerations mentioned in [WebDAV] also \napply to this document.\n\n16 Copyright\n\nTo be supplied.\n\n17 Intellectual Property\n\nTo be supplied.\n\n18 Acknowledgements\n\nThis draft has benefited from thoughtful discussion by Jim Amsden, Steve \nCarter, Ken Coar, Ellis Cohen, Bruce Cragun, Spencer Dawkins, Mark Day, \nRajiv Dulepet, David Durand, Roy Fielding, Yaron Goland, Fred Hitt, Alex \nHopmann, Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit Khare, \nDaniel LaLiberte, Steve Martin, Larry Masinter, Jeff McAffer, Surendra \nKoduru Reddy, Max Rible, Sam Ruby, Bradley Sergeant, Nick Shelness, John \nStracke, John Tigue, John Turner, and others.\n\n\nSlein et al.                                                    Page 47\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nCcjason, \n\n19 References\n\n19.1 Normative References\n\n[URI] T. Berners-Lee, R. Fielding, L. Masinter, \"Uniform Resource \nIdentifiers (URI): Generic Syntax.\" RFC 2396. MIT/LCS, U.C. Irvine, \nXerox. August, 1998.\n\n[RFC2119] S. Bradner, \"Key words for use in RFCs to Indicate Requirement \nLevels.\"  RFC 2119, BCP 14.  Harvard University.  March, 1997.\n\n[XML] T. Bray, J. Paoli, C.M. Sperberg-McQueen, \"Extensible Markup \nLanguage (XML).\"  World Wide Web Consortium Recommendation REC-xml-\n19980210. http://www.w3.org/TR/1998/REC-xml-19980210.\n\n[HTTP] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-Lee, \n\"Hypertext Transfer Protocol -- HTTP/1.1.\" RFC 2068.  UC Irvine, DEC, \nMIT/LCS.  January, 1997.\n\n[WebDAV] Y. Y. Goland, E. J. Whitehead, Jr., A. Faizi, S. R. Carter, D. \nJensen, \"HTTP Extensions for Distributed Authoring - WebDAV.\" RFC 2518.  \nMicrosoft, U.C. Irvine, Netscape, Novell.  February, 1999.\n\n19.2 Informational References\n\n[DASL] Saveen Reddy, D. Jensen, Surendra Reddy, R. Henderson, J. Davis, \nA. Babich, \"DAV Searching & Locating.\" Draft-reddy-dasl-protocol-03. \nInternet Draft, work in progress. Microsoft, Novell, Oracle, Netscape, \nXerox, Filenet.  November, 1998.\n \n[CollReq] J. Slein, J. Davis, \"Requirements for Advanced Collection \nFunctionality in WebDAV.\" Draft-ietf-webdav-collection-reqts-02. \nInternet Draft, work in progress.  Xerox.  February, 1999.\n\n20 Authors' Addresses\n\nJ. Slein\nXerox Corporation\n800 Phillips Road, 105-50C\nWebster, NY 14580\nEmail: jslein@crt.xerox.com\n\nJ. Davis\nCourseNet Systems\n170 Capp Street\nSan Francisco, CA 94110\nEmail: jrd3@alum.mit.edu\n\nT. Chihaya\nDataChannel, Inc.\n155 108th Ave. N.E., Suite 400\nBellevue, WA 98004\nEmail: Tyson@DataChannel.com\n\nSlein et al.                                                    Page 48\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nG. Clemm\nRational Software Corporation\n20 Maguire Road\nLexington, MA 02173-3104\nEmail: gclemm@rational.com\n\nC. Fay\nFileNet Corporation\n3565 Harbor Boulevard\nCosta Mesa, CA 92626-1420\nEmail: cfay@filenet.com\n\nE.J. Whitehead Jr.\nDept. of Information and Computer Science\nUniversity of California, Irvine\nIrvine, CA 92697-3425\nEmail: ejw@ics.uci.edu\n\n21 Appendices\n\n21.1 Appendix 1: Extensions to the WebDAV Document Type Definition\n\n<!--============= XML Elements from Section 8 =======================-->\n<!ELEMENT reference EMPTY >\n<!ELEMENT weak EMPTY >\n<!ELEMENT unordered EMPTY >\n<!ELEMENT custom EMPTY >\n<!ELEMENT order (ordermember+) >\n<!ELEMENT ordermember (href, position) >\n<!ELEMENT position (first | last | before | after)>\n<!ELEMENT first EMPTY >\n<!ELEMENT last EMPTY >\n<!ELEMENT before href >\n<!ELEMENT after href >\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n<!ELEMENT refintegrityoptions ( (#PCDATA)+ | EMPTY) >\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n<!ELEMENT do-not-enforce EMPTY >\n<!--============= Property Elements from Section 7 ==================-->\n<!ELEMENT reftarget href>\n<!ELEMENT refintegrity (weak | #PCDATA)>\n<!ELEMENT location href>\n<!ELEMENT references (href*)>\n<!ELEMENT orderingtype (arbitrary | custom | href) >\n<!--====== Changes to the DAV:response Element from Section 9 ====-->\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n\nExpires October 18, 1999\n\nSlein et al.                                                    Page 49\n\f", "encoding": "Windows-1252"}