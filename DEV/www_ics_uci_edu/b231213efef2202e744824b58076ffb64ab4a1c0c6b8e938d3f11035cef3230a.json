{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/TkinterBasics/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Tkinter Basics</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Tkinter Basics</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>When we interact with software on our own computers and mobile devices, more often than not, we interact with graphical user interfaces (GUIs).  Programs with GUIs stand in stark contrast to the programs we've built this quarter, which have featured console-mode user interfaces that print text on the console and read text from the keyboard.  While there is plenty of real software out there that uses only the console, we spend a lot of our time in day-to-day use of computers and mobile devices manipulating GUIs instead, so it's natural that we should want to learn how to build GUIs ourselves.  Python can help: Among other things in its standard library, it includes a module called <b>tkinter</b> &mdash; technically, an interface to a GUI toolkit called Tk, which is where it gets its name &mdash; that allows us to build GUIs using Python.  This code example begins our exploration of the <b>tkinter</b> module.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Where to find more information about tkinter</p>\r\n\r\n<p>When you want to know more about the <b>tkinter</b> library, there is a place where you can get a lot of good information.  Almost surely, you'll want to do things in your own GUIs that we didn't end up having time to cover in lecture and don't show up in these examples.  In general, I'm happy to help, though you'll find that my knowledge of this library is not encyclopedic, so there's a chance you'll stump me and I'll send you, most particularly, to a good online <b>tkinter</b> reference linked below.</p>\r\n\r\n<ul>\r\n  <li>The <a href=\"http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html\">tkinter 8.5 Reference</a> from New Mexico Tech Computer Center is a comprehensive reference book &mdash; weighing in at over 160 pages in its <a href=\"http://www.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf\">printable PDF version</a> &mdash; that will tell you absolutely everything you would want to know about <b>tkinter</b>.\r\n    <ul>\r\n      <li>The one thing to be cautious about is that its Python code examples use an older version of the Python language (Python 2) that differs from the version we're using (Python 3) in a number of (mostly minor) ways, so you'll need to be cognizant of these differences.</li>\r\n    </ul>\r\n  </li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Creating an empty GUI window</p>\r\n\r\n<p>As a first step toward learning to build a GUI, we can create a completely empty GUI window using <b>tkinter</b> surprisingly easily.  Fire up a Python interpreter and type these three things into it.</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; import tkinter\r\n&gt;&gt;&gt; window = tkinter.Tk()\r\n&gt;&gt;&gt; window.mainloop()\r\n</pre></blockquote>\r\n\r\n<p>Creating a <b>tkinter.Tk</b> object creates a <b>tkinter</b>-based GUI, which causes a window to pop up on your screen; however, that window will be (more or less) inactive.  Notice that when you call the <b>mainloop()</b> method on the window, the Python interpreter becomes inactive &mdash; you aren't given another prompt to enter your next statement or expression.  However, once you close the window (in the normal way you close a window using your operating system), the Python interpreter will then prompt you for another statement or expression.  While that might seem like an irrelevant detail, it reveals something important about the way that <b>tkinter</b>-based GUIs behave: They are built using <i>event-based programming</i>, which is similar to what we did when we used PyGame, but the difference is that the loop that processes input events is inside of the <b>tkinter</b> library, rather than being something we'll be writing ourselves.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Event-based programming</p>\r\n\r\n<p>We make a <b>tkinter</b> GUI active by calling the <b>mainloop()</b> method on its main window.  The name <b>mainloop</b> actually tells us a lot about what's actually going on.  A <b>tkinter</b> GUI has a <i>main loop</i> (also sometimes called an <i>event loop</i>) that watches for a variety of input events, such as mouse movements, mouse button clicks, or pressing and releasing keys on the keyboard.  This is not only a complex task, but one that all GUIs require, so rather than require every implementor to handle these tasks manually, <b>tkinter</b> handles them automatically.  Unlike in PyGame, <b>tkinter</b> provides the event loop; we don't have to write it.</p>\r\n\r\n<p>That main loop is why calling the <b>mainloop()</b> method causes your own code to stop making progress: the loop doesn't end until the window is dismissed.  This leaves open an interesting question: If <b>tkinter</b> circles through a long-running main loop as long as the window is displayed, how can your code do anything?</p>\r\n\r\n<p>The answer lies in the use of a technique called <i>event-based programming</i>.  While <b>tkinter</b> \"runs the show,\" so to speak, you tell it what events your code would be interested in being told about.  When any of those events happens, a function or method in your code will be called to process that event; when that function or method returns, <b>tkinter</b>'s main loop goes back to watching for inputs.  There are two lessons that we can take from this:</p>\r\n\r\n<ol>\r\n  <li>Unlike the programs we've been writing to date, in a program with a <b>tkinter</b>-based GUI, we don't handle all of the control flow in the program; instead, we create the GUI, \"wire up\" a set of event handlers, and our code is inactive until one of those event handlers is called.</li>\r\n  <li>If we were to write an event-handling function or method that ran for a long time &mdash; say, one that downloaded a large file via the Internet &mdash; the entire GUI will be unresponsive until our event handler returned.  We won't worry about this for now, since our event handlers will be fast in early examples, but it will be a problem worth keeping in mind as we broaden our skills.  (Note that this is the same problem we face in PyGame if we spend too much time in any one iteration of our game loop.  Frames of our animation will then be dropped, our ability to handle inputs will be paused, and so on.  And it's a problem for the same reason: It's getting to the top of our main loop that allows our program to make progress, so doing anything that prevents us from getting to the top of the main loop again for an indeterminate amount of time is problematic.)</li>\r\n</ol>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Widgets and options</p>\r\n\r\n<p>A window in a <b>tkinter</b> GUI contains a collection of building blocks called <i>widgets</i>.  <b>tkinter</b> includes a variety of built-in widgets that will sound familiar when you think about GUI-based programs you've used; examples include buttons, text labels, fields into which you can enter text, checkboxes, menus, and scrollbars.  In addition to using the widgets built into the library, you can also build your own if you need something custom that isn't provided, though that's not a bridge we'll need to cross in our work.</p>\r\n\r\n<p>Each widget has a set of <i>options</i> that can be configured when the widget is first created, by passing keyword arguments to its constructor.  For example, we might create a button this way:</p>\r\n\r\n<blockquote><pre>\r\nbutton = tkinter.Button(master = window, text = 'Hello!', font = ('Helvetica', 20))\r\n</pre></blockquote>\r\n\r\n<p>Here, we've created a button and set three of its options:</p>\r\n\r\n<ul>\r\n  <li><i>master</i>, which is the widget in which the button will be placed.  That could be a window (a <b>Tk</b> object), or it could be another widget.  Aside from the \"main\" window in a GUI, every widget has a master.</li>\r\n  <li><i>text</i>, which is the text that will be displayed inside of the button.  We can set this to a string if we want to set it to display constant text.  If we'd prefer variable text or an image, there are other options we could set instead.</li>\r\n  <li><i>font</i>, which specifies the font in which the button's text should be displayed.  The font is specified as a tuple consisting of at least two elements: the name of the font and the size (in points) of the font.  Here, I've chosen 20-point Helvetica.  It's fine not to set the <i>font</i> option; we'll just get a default setting if we don't.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Layout</p>\r\n\r\n<p>So, as we've seen, a window is a container in which a collection of widgets is displayed.  But if there's a window with a label, several buttons, and a checkbox, where will the widgets be displayed within the window?  This issue is handled by something called a <i>layout manager</i> (also called a <i>geometry manager</i>), whose role is to decide how to arrange widgets within an area, and how that arrangement should change as the area's size changes (e.g., when a window is resized).  There are two layout managers provided by <b>tkinter</b>: <i>pack</i> and <i>grid</i>.  You can also build your own (using a third layout manager called <i>place</i>), though that's well beyond the scope of what we'll do this quarter.</p>\r\n\r\n<p>You can specify the layout rules for each widget by calling one of three methods on it: <b>pack()</b>, <b>grid()</b>, or <b>place()</b>.  <b>pack()</b> is, by far, the simplest, but its simplicity means that it lacks the flexibility to express anything but a very simple layout.  <b>grid()</b> is built around a few relatively straightforward rules, but those rules turn out to be surprisingly flexible; we'll see that as we move forward with this example.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Behaviors and events</p>\r\n\r\n<p>As we talked about above, <b>tkinter</b>'s main loop watches for various inputs and converts them to <i>events</i>.  Your code can register an interest in those events by specifying functions or methods that <b>tkinter</b> will call each time one of those events occur.  (Remember that <b>tkinter</b>'s main loop is \"in charge\" here.  It will call your function or method, then when your code returns, control will flow back into <b>tkinter</b>'s main loop to process the next event.)</p>\r\n\r\n<p>Some widgets have <i>behaviors</i> built into them, which convert lower-level events like keypresses or mouse movement into higher-level behaviors like \"The button was pressed.\"  For example, the <b>Button</b> widget has an option called <b>command</b>; if you set this option to a function that takes no parameters, the function will be called whenever the button is pressed.</p>\r\n\r\n<blockquote><pre>\r\ndef hello_button_pressed() -> None:\r\n    <i># Do whatever you want to do when the button is pressed</i>\r\n    ...\r\n\r\n...\r\n\r\nbutton = tkinter.Button(\r\n    master = window, text = 'Hello!', font = ('Helvetica', 20),\r\n    command = hello_button_pressed)\r\n</pre></blockquote>\r\n\r\n<p>Notice that we're not setting the <b>command</b> option to be the result of calling the <b>hello_button_pressed</b> function (i.e., there are no parentheses after <b>hello_button_pressed</b> when we set the <b>command</b> option).  Instead, we're setting it to the function itself, literally asking <b>tkinter</b> to call this function later, when the button is pressed.  This is the essence of event-based programming: We specify the functions that should be called later when events occur.</p>\r\n\r\n<p class=\"subtitle\">Event binding</p>\r\n\r\n<p>When a widget doesn't expose exactly the behavior you need, you can achieve what you need by instead doing what's called <i>event binding</i>.  Binding to an event on some widget is done by calling the <b>bind()</b> method on that widget.  For example, given the button we created previously, we could bind to the event that's generated when the mouse cursor moves into the button by doing this:</p>\r\n\r\n<blockquote><pre>\r\n<b>def</b> cursor_entered_button(event: tkinter.Event) -> None:\r\n    <i># Do whatever you want to do when the button is entered</i>\r\n    ...\r\n\r\n...\r\n\r\nbutton.bind('&lt;Enter&gt;', cursor_entered_button)\r\n</pre></blockquote>\r\n\r\n<p>The first parameter to <b>bind()</b> is the description of the event (or sequence of events) you're interested in.  In this case, we specified the name <b>'&lt;Enter&gt;'</b>, which is an event that's generated when the mouse cursor moves into a widget.  The second parameter is an <i>event handler function</i>; event handler functions are required to take a single parameter, into which will be passed an <i>event object</i> that describes the event.  Different kinds of events carry different attributes, though they all carry certain ones (e.g., the attribute <b>widget</b>, which specifies which widget the event applied to).  For example, mouse movement events tell you where the mouse was moved to, keyboard events tell you which key was pressed, and so on.  (This is similar to the event objects we saw in PyGame.)</p>\r\n\r\n<p>For more information about what events can be bound, how to specify modifiers, how to combine events into sequences, and what attributes are available within event objects for different kinds of events, check out <a href=\"http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/events.html\">Chapter 54 of the <b>tkinter</b> reference</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">A first example</p>\r\n\r\n<p>To bring all of these concepts together into a single example, the code example below demonstrates a <b>tkinter</b> GUI containing a single button, whose text changes when you move your mouse into and out of it, and which causes a message to be printed to the Python shell when clicked.</p>\r\n\r\n<ul>\r\n  <li><a href=\"simple_window.py\">simple_window.py</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}