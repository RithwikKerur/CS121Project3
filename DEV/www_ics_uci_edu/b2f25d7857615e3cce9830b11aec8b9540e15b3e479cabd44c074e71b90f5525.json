{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_1.html#SEC3", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Introduction</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Introduction\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Introduction\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC1\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_2.html#SEC15\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<A NAME=\"Introduction\"></A>\n<H1> 1. Introduction </H1>\n<!--docid::SEC1::-->\n<P>\n\nWelcome to Pintos.  Pintos is a simple operating system framework for\nthe 80<VAR>x</VAR>86 architecture.  It supports kernel threads, loading and\nrunning user programs, and a file system, but it implements all of\nthese in a very simple way.  In the Pintos projects, you and your\nproject team will strengthen its support in all three of these areas.\nYou will also add a virtual memory implementation.\n</P>\n<P>\n\nPintos could, theoretically, run on a regular IBM-compatible PC.\nUnfortunately, it is impractical to supply every student\na dedicated PC for use with Pintos.  Therefore, we will run Pintos projects\nin a system simulator, that is, a program that simulates an 80<VAR>x</VAR>86\nCPU and its peripheral devices accurately enough that unmodified operating\nsystems and software can run under it.  In class we will use the\n<A HREF=\"http://bochs.sourceforge.net\">Bochs</A> and \n<A HREF=\"http://fabrice.bellard.free.fr/qemu/\">QEMU</A> simulators.  Pintos has also been tested with\n<A HREF=\"http://www.vmware.com/\">VMware Player</A>.\n</P>\n<P>\n\nThese projects are hard.  They have a reputation of taking a lot of\ntime, and deservedly so.  We will do what we can to reduce the workload, such\nas providing a lot of support material, but there is plenty of\nhard work that needs to be done.  We welcome your\nfeedback.  If you have suggestions on how we can reduce the unnecessary\noverhead of assignments, cutting them down to the important underlying\nissues, please let us know.\n</P>\n<P>\n\nThis chapter explains how to get started working with Pintos.  You\nshould read the entire chapter before you start work on any of the\nprojects.\n</P>\n<P>\n\n<A NAME=\"Getting Started\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC2\"></A>\n<H2> 1.1 Getting Started </H2>\n<!--docid::SEC2::-->\n<P>\n\nTo get started, you'll have to log into a machine that Pintos can be\nbuilt on.  \n<!--\nThe CS 318 &quot;officially supported&quot; Pintos development machines are \nthose in the <A HREF=\"https://support.cs.jhu.edu/wiki/Linux_Clients_on_the_CS_Undergrad_Net\">ugrad</A> \nand <A HREF=\"https://support.cs.jhu.edu/wiki/Linux_Clients_on_the_CS_Grad/Research_Net\">grad</A> \nlab machines in the JHU CS department.\nWe will test your code on these machines, and the instructions given\nhere assume this environment.  But you may also want to develop Pintos\non your own machine to be more productive.\n-->\nWe have provided a guide\nfor doing the setup (See <A HREF=\"https://www.ics.uci.edu/~ardalan/project_setup.html\">Project Setup</A>,\nand see section <A HREF=\"pintos_13.html#SEC173\">G. Installing Pintos</A>).\n</P>\n<P>\n\nOnce you've logged into one of these machines, either locally or\nremotely, start out by adding our binaries directory to your <CODE>PATH</CODE>\nenvironment.  \nUnder the <CODE>bash</CODE> login shell, you can do so\nwith this command:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>export PATH=/usr/local/data/cs318/x86_64/bin:$PATH\n</pre></td></tr></table>It is a good idea to add this line to the <Q><TT>.bash_profile</TT></Q> or <Q><TT>.bashrc</TT></Q> file\nin your home directory. Otherwise, you'll have to type it every time\nyou log in. The ugrad lab machines in the CS department use <CODE>tcsh</CODE> login \nshell by default (typing <CODE>echo $SHELL</CODE> will tell), the syntax for setting \nPATH is a bit different. You need to add this line to the <Q><TT>.tcshrc</TT></Q> with\nthis command:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>set path = (/usr/local/data/cs318/x86_64/bin $path)\n</pre></td></tr></table><P>\n\n<A NAME=\"Source Tree Overview\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC3\"></A>\n<H3> 1.1.1 Source Tree Overview </H3>\n<!--docid::SEC3::-->\n<P>\n\n<!--\nNow you can extract the source for Pintos into a directory named\n<Q><TT>pintos/src</TT></Q>, by fetching the <A HREF=\"https://cs.jhu.edu/~huang/cs318/fall18/pintos.tar.gz\">https://cs.jhu.edu/~huang/cs318/fall18/pintos.tar.gz</A>.\nYou can also quickly clone a git repository of pintos. If you are using \nthe JHU CS lab machines, execute \n<TABLE><tr><td>&nbsp;</td><td class=example><pre>git clone file:///usr/local/data/cs318/pintos.git\n</pre></td></tr></table>If you are using your own machines, execute\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>git clone https://github.com/jhu-cs318/pintos.git\n</pre></td></tr></table><P>\n-->\n\nLet's take a look at what's inside.  Here's the directory structure\nthat you should see in <Q><TT>pintos/src</TT></Q>:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>threads/</TT></Q>\n<DD>Source code for the base kernel, which you will modify starting in\nproject 1.\n<P>\n\n</P>\n<DT><Q><TT>userprog/</TT></Q>\n<DD>Source code for the user program loader, which you will modify\nstarting with project 2.\n<P>\n\n</P>\n<DT><Q><TT>vm/</TT></Q>\n<DD>An almost empty directory.  You will implement virtual memory here in\nproject 3.\n<P>\n\n</P>\n<DT><Q><TT>filesys/</TT></Q>\n<DD>Source code for a basic file system.  You will use this file system\nstarting with project 2, but you will not modify it until project 4.\n<P>\n\n</P>\n<DT><Q><TT>devices/</TT></Q>\n<DD>Source code for I/O device interfacing: keyboard, timer, disk, etc.\nYou will modify the timer implementation in project 1.  Otherwise\nyou should have no need to change this code.\n<P>\n\n</P>\n<DT><Q><TT>lib/</TT></Q>\n<DD>An implementation of a subset of the standard C library.  The code in\nthis directory is compiled into both the Pintos kernel and, starting\nfrom project 2, user programs that run under it.  In both kernel code\nand user programs, headers in this directory can be included using the\n<CODE>#include &lt;<small>...</small>&gt;</CODE> notation.  You should have little need to\nmodify this code.\n<P>\n\n</P>\n<DT><Q><TT>lib/kernel/</TT></Q>\n<DD>Parts of the C library that are included only in the Pintos kernel.\nThis also includes implementations of some data types that you are\nfree to use in your kernel code: bitmaps, doubly linked lists, and\nhash tables.  In the kernel, headers in this\ndirectory can be included using the <CODE>#include &lt;<small>...</small>&gt;</CODE>\nnotation.\n<P>\n\n</P>\n<DT><Q><TT>lib/user/</TT></Q>\n<DD>Parts of the C library that are included only in Pintos user programs.\nIn user programs, headers in this directory can be included using the\n<CODE>#include &lt;<small>...</small>&gt;</CODE> notation.\n<P>\n\n</P>\n<DT><Q><TT>tests/</TT></Q>\n<DD>Tests for each project.  You can modify this code if it helps you test\nyour submission, but we will replace it with the originals before we run\nthe tests.\n<P>\n\n</P>\n<DT><Q><TT>examples/</TT></Q>\n<DD>Example user programs for use starting with project 2.\n<P>\n\n</P>\n<DT><Q><TT>misc/</TT></Q>\n<DD><DT><Q><TT>utils/</TT></Q>\n<DD>These files may come in handy if you decide to try working with Pintos\non your own machine.  Otherwise, you can ignore them.\n</DL>\n<P>\n\n<A NAME=\"Building Pintos\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC4\"></A>\n<H3> 1.1.2 Building Pintos </H3>\n<!--docid::SEC4::-->\n<P>\n\nAs the next step, build the source code supplied for\nthe first project.  First, <CODE>cd</CODE> into the <Q><TT>threads</TT></Q>\ndirectory.  Then, issue the <Q><SAMP>make</SAMP></Q> command.  This will create a\n<Q><TT>build</TT></Q> directory under <Q><TT>threads</TT></Q>, populate it with a\n<Q><TT>Makefile</TT></Q> and a few subdirectories, and then build the kernel\ninside.  The entire build should take less than 30 seconds.\n</P>\n<P>\n\nFollowing the build, the following are the interesting files in the\n<Q><TT>build</TT></Q> directory:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>Makefile</TT></Q>\n<DD>A copy of <Q><TT>pintos/src/Makefile.build</TT></Q>.  It describes how to build\nthe kernel.  See  <A HREF=\"pintos_3.html#Adding Source Files\">Adding Source Files</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>kernel.o</TT></Q>\n<DD>Object file for the entire kernel.  This is the result of linking\nobject files compiled from each individual kernel source file into a\nsingle object file.  It contains debug information, so you can run\nGDB (see section <A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A>) or <CODE>backtrace</CODE> (see section <A HREF=\"pintos_11.html#SEC159\">E.4 Backtraces</A>) on it.\n<P>\n\n</P>\n<DT><Q><TT>kernel.bin</TT></Q>\n<DD>Memory image of the kernel, that is, the exact bytes loaded into\nmemory to run the Pintos kernel.  This is just <Q><TT>kernel.o</TT></Q> with\ndebug information stripped out, which saves a lot of space, which in\nturn keeps the kernel from bumping up against a 512 kB size limit\nimposed by the kernel loader's design.\n<P>\n\n</P>\n<DT><Q><TT>loader.bin</TT></Q>\n<DD>Memory image for the kernel loader, a small chunk of code written in\nassembly language that reads the kernel from disk into memory and\nstarts it up.  It is exactly 512 bytes long, a size fixed by the\nPC BIOS.\n</DL>\n<P>\n\nSubdirectories of <Q><TT>build</TT></Q> contain object files (<Q><TT>.o</TT></Q>) and\ndependency files (<Q><TT>.d</TT></Q>), both produced by the compiler.  The\ndependency files tell <CODE>make</CODE> which source files need to be\nrecompiled when other source or header files are changed.\n</P>\n<P>\n\n<A NAME=\"Running Pintos\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC5\"></A>\n<H3> 1.1.3 Running Pintos </H3>\n<!--docid::SEC5::-->\n<P>\n\nWe've supplied a program for conveniently running Pintos in a simulator,\ncalled <CODE>pintos</CODE>.  In the simplest case, you can invoke\n<CODE>pintos</CODE> as <CODE>pintos <VAR>argument</VAR><small>...</small></CODE>.  Each\n<VAR>argument</VAR> is passed to the Pintos kernel for it to act on.\n</P>\n<P>\n\nTry it out.  First <CODE>cd</CODE> into the newly created <Q><TT>build</TT></Q>\ndirectory.  Then issue the command <CODE>pintos run alarm-multiple</CODE>,\nwhich passes the arguments <CODE>run alarm-multiple</CODE> to the Pintos\nkernel.  In these arguments, <CODE>run</CODE> instructs the kernel to run a\ntest and <CODE>alarm-multiple</CODE> is the test to run.\n</P>\n<P>\n\nThis command creates a <Q><TT>bochsrc.txt</TT></Q> file, which is needed for\nrunning Bochs, and then invoke Bochs.  Bochs opens a new window that\nrepresents the simulated machine's display, and a BIOS message briefly\nflashes.  Then Pintos boots and runs the <CODE>alarm-multiple</CODE> test\nprogram, which outputs a few screenfuls of text.  When it's done, you\ncan close Bochs by clicking on the &quot;Power&quot; button in the window's top\nright corner, or rerun the whole process by clicking on the &quot;Reset&quot;\nbutton just to its left.  The other buttons are not very useful for our\npurposes.\n</P>\n<P>\n\n(If no window appeared at all, then you're probably logged in remotely and X\nforwarding is not set up correctly.  In this case, you can fix your X\nsetup, or you can use the <Q><SAMP>-v</SAMP></Q> option to disable X output:\n<CODE>pintos -v -- run alarm-multiple</CODE>.)\n</P>\n<P>\n\nThe text printed by Pintos inside Bochs probably went by too quickly to\nread.  However, you've probably noticed by now that the same text was\ndisplayed in the terminal you used to run <CODE>pintos</CODE>.  This is\nbecause Pintos sends all output both to the VGA display and to the first\nserial port, and by default the serial port is connected to Bochs's\n<CODE>stdin</CODE> and <CODE>stdout</CODE>.  You can log serial output to a file by\nredirecting at the\ncommand line, e.g. <CODE>pintos run alarm-multiple &gt; logfile</CODE>.\n</P>\n<P>\n\nThe <CODE>pintos</CODE> program offers several options for configuring the\nsimulator or the virtual hardware.  If you specify any options, they\nmust precede the commands passed to the Pintos kernel and be separated\nfrom them by <Q><SAMP>--</SAMP></Q>, so that the whole command looks like\n<CODE>pintos <VAR>option</VAR><small>...</small> -- <VAR>argument</VAR><small>...</small></CODE>.  Invoke\n<CODE>pintos</CODE> without any arguments to see a list of available options.\nOptions can select a simulator to use: the default is Bochs, but\n<Q><SAMP>--qemu</SAMP></Q> selects QEMU.  You can run the simulator\nwith a debugger (see section <A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A>).  You can set the amount of memory to give\nthe VM.  Finally, you can select how you want VM output to be displayed:\nuse <Q><SAMP>-v</SAMP></Q> to turn off the VGA display, <Q><SAMP>-t</SAMP></Q> to use your\nterminal window as the VGA display instead of opening a new window\n(Bochs only), or <Q><SAMP>-s</SAMP></Q> to suppress serial input from <CODE>stdin</CODE>\nand output to <CODE>stdout</CODE>.\n</P>\n<P>\n\nThe Pintos kernel has commands and options other than <CODE>run</CODE>.\nThese are not very interesting for now, but you can see a list of them\nusing <Q><SAMP>-h</SAMP></Q>, e.g. <CODE>pintos -h</CODE>.\n</P>\n<P>\n\n<A NAME=\"Debugging versus Testing\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC6\"></A>\n<H3> 1.1.4 Debugging versus Testing </H3>\n<!--docid::SEC6::-->\n<P>\n\nWhen you're debugging code, it's useful to be able to run a\nprogram twice and have it do exactly the same thing.  On second and\nlater runs, you can make new observations without having to discard or\nverify your old observations.  This property is called\n&quot;reproducibility.&quot;  One of the simulators that Pintos supports, Bochs,\ncan be set up for\nreproducibility, and that's the way that <CODE>pintos</CODE> invokes it\nby default.\n</P>\n<P>\n\nOf course, a simulation can only be reproducible from one run to the\nnext if its input is the same each time.  For simulating an entire\ncomputer, as we do, this means that every part of the computer must be\nthe same.  For example, you must use the same command-line argument, the\nsame disks, the same version\nof Bochs, and you must not hit any keys on the keyboard (because you\ncould not be sure to hit them at exactly the same point each time)\nduring the runs.\n</P>\n<P>\n\nWhile reproducibility is useful for debugging, it is a problem for\ntesting thread synchronization, an important part of most of the projects.  In\nparticular, when Bochs is set up for reproducibility, timer interrupts\nwill come at perfectly reproducible points, and therefore so will\nthread switches.  That means that running the same test several times\ndoesn't give you any greater confidence in your code's correctness\nthan does running it only once.\n</P>\n<P>\n\nSo, to make your code easier to test, we've added a feature, called\n&quot;jitter,&quot; to Bochs, that makes timer interrupts come at random\nintervals, but in a perfectly predictable way.  In particular, if you\ninvoke <CODE>pintos</CODE> with the option <Q><SAMP>-j <VAR>seed</VAR></SAMP></Q>, timer\ninterrupts will come at irregularly spaced intervals.  Within a single\n<VAR>seed</VAR> value, execution will still be reproducible, but timer\nbehavior will change as <VAR>seed</VAR> is varied.  Thus, for the highest\ndegree of confidence you should test your code with many seed values.\n</P>\n<P>\n\nOn the other hand, when Bochs runs in reproducible mode, timings are not\nrealistic, meaning that a &quot;one-second&quot; delay may be much shorter or\neven much longer than one second.  You can invoke <CODE>pintos</CODE> with\na different option, <Q><SAMP>-r</SAMP></Q>, to set up Bochs for realistic\ntimings, in which a one-second delay should take approximately one\nsecond of real time.  Simulation in real-time mode is not reproducible,\nand options <Q><SAMP>-j</SAMP></Q> and <Q><SAMP>-r</SAMP></Q> are mutually exclusive.\n</P>\n<P>\n\nThe QEMU simulator is available as an\nalternative to Bochs (use <Q><SAMP>--qemu</SAMP></Q> when invoking\n<CODE>pintos</CODE>).  The QEMU simulator is much faster than Bochs, but it\nonly supports real-time simulation and does not have a reproducible\nmode.\n</P>\n<P>\n\n<A NAME=\"Grading\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC7\"></A>\n<H2> 1.2 Grading </H2>\n<!--docid::SEC7::-->\n<P>\n\nWe will grade your assignments based on test results and design quality,\nwhich comprises 60% and 40% \nof your grade, respectively.\n</P>\n<P>\n\n<A NAME=\"Testing\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC8\"></A>\n<H3> 1.2.1 Testing </H3>\n<!--docid::SEC8::-->\n<P>\n\nYour test result grade will be based on our tests.  Each project has\nseveral tests, each of which has a name beginning with <Q><TT>tests</TT></Q>.\nTo completely test your submission, invoke <CODE>make check</CODE> from the\nproject <Q><TT>build</TT></Q> directory.  This will build and run each test and\nprint a &quot;pass&quot; or &quot;fail&quot; message for each one.  When a test fails,\n<CODE>make check</CODE> also prints some details of the reason for failure.\nAfter running all the tests, <CODE>make check</CODE> also prints a summary\nof the test results.\n</P>\n<P>\n\nFor project 1, the tests will probably run faster in Bochs.  For the\nrest of the projects, they will run much faster in QEMU.\n<CODE>make check</CODE> will select the faster simulator by default, but\nyou can override its choice by specifying <Q><SAMP>SIMULATOR=--bochs</SAMP></Q> or\n<Q><SAMP>SIMULATOR=--qemu</SAMP></Q> on the <CODE>make</CODE> command line.\n</P>\n<P>\n\nYou can also run individual tests one at a time.  A given test <VAR>t</VAR>\nwrites its output to <Q><TT><VAR>t</VAR>.output</TT></Q>, then a script scores the\noutput as &quot;pass&quot; or &quot;fail&quot; and writes the verdict to\n<Q><TT><VAR>t</VAR>.result</TT></Q>.  To run and grade a single test, <CODE>make</CODE>\nthe <Q><TT>.result</TT></Q> file explicitly from the <Q><TT>build</TT></Q> directory, e.g.\n<CODE>make tests/threads/alarm-multiple.result</CODE>.  If <CODE>make</CODE> says\nthat the test result is up-to-date, but you want to re-run it anyway,\neither run <CODE>make clean</CODE> or delete the <Q><TT>.output</TT></Q> file by hand.\n</P>\n<P>\n\nBy default, each test provides feedback only at completion, not during\nits run.  If you prefer, you can observe the progress of each test by\nspecifying <Q><SAMP>VERBOSE=1</SAMP></Q> on the <CODE>make</CODE> command line, as in\n<CODE>make check VERBOSE=1</CODE>.  You can also provide arbitrary options to the\n<CODE>pintos</CODE> run by the tests with <Q><SAMP>PINTOSOPTS='<small>...</small>'</SAMP></Q>,\ne.g. <CODE>make check PINTOSOPTS='-j 1'</CODE> to select a jitter value of 1\n(see section <A HREF=\"pintos_1.html#SEC6\">1.1.4 Debugging versus Testing</A>).\n</P>\n<P>\n\nAll of the tests and related files are in <Q><TT>pintos/src/tests</TT></Q>.\nBefore we test your submission, we will replace the contents of that\ndirectory by a pristine, unmodified copy, to ensure that the correct\ntests are used.  Thus, you can modify some of the tests if that helps in\ndebugging, but we will run the originals.\n</P>\n<P>\n\nAll software has bugs, so some of our tests may be flawed.  If you think\na test failure is a bug in the test, not a bug in your code,\nplease point it out.  We will look at it and fix it if necessary.\n</P>\n<P>\n\nPlease don't try to take advantage of our generosity in giving out our\ntest suite.  Your code has to work properly in the general case, not\njust for the test cases we supply.  For example, it would be unacceptable\nto explicitly base the kernel's behavior on the name of the running\ntest case.  Such attempts to side-step the test cases will receive no\ncredit.  If you think your solution may be in a gray area here, please\nask us about it.\n</P>\n<P>\n\n<A NAME=\"Design\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC9\"></A>\n<H3> 1.2.2 Design </H3>\n<!--docid::SEC9::-->\n<P>\n\nWe will judge your design based on the design document and the source\ncode that you submit.  We will read your entire design document and much\nof your source code.  \n</P>\n<P>\n\nDon't forget that design quality, including the design document, is 40%\nof your project grade.  It\nis better to spend one or two hours writing a good design document than\nit is to spend that time getting the last 5% of the points for tests and\nthen trying to rush through writing the design document in the last 15\nminutes.\n</P>\n<P>\n\n<A NAME=\"Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC10\"></A>\n<H4> 1.2.2.1 Design Document </H4>\n<!--docid::SEC10::-->\n<P>\n\nWe provide a design document template for each project.  For each\nsignificant part of a project, the template asks questions in four\nareas: \n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><STRONG>Data Structures</STRONG>\n<DD><P>\n\nThe instructions for this section are always the same:\n</P>\n<P>\n\n<BLOCKQUOTE>\nCopy here the declaration of each new or changed <CODE>struct</CODE> or\n<CODE>struct</CODE> member, global or static variable, <CODE>typedef</CODE>, or\nenumeration.  Identify the purpose of each in 25 words or less.\n</BLOCKQUOTE>\n<P>\n\nThe first part is mechanical.  Just copy new or modified declarations\ninto the design document, to highlight for us the actual changes to data\nstructures.  Each declaration should include the comment that should\naccompany it in the source code (see below).\n</P>\n<P>\n\nWe also ask for a very brief description of the purpose of each new or\nchanged data structure.  The limit of 25 words or less is a guideline\nintended to save your time and avoid duplication with later areas.\n</P>\n<P>\n\n</P>\n<DT><STRONG>Algorithms</STRONG>\n<DD><P>\n\nThis is where you tell us how your code works, through questions that\nprobe your understanding of your code.  We might not be able to easily\nfigure it out from the code, because many creative solutions exist for\nmost OS problems.  Help us out a little.\n</P>\n<P>\n\nYour answers should be at a level below the high level description of\nrequirements given in the assignment.  We have read the assignment too,\nso it is unnecessary to repeat or rephrase what is stated there.  On the\nother hand, your answers should be at a level above the low level of the\ncode itself.  Don't give a line-by-line run-down of what your code does.\nInstead, use your answers to explain how your code works to implement\nthe requirements.\n</P>\n<P>\n\n</P>\n<DT><STRONG>Synchronization</STRONG>\n<DD><P>\n\nAn operating system kernel is a complex, multithreaded program, in which\nsynchronizing multiple threads can be difficult.  This section asks\nabout how you chose to synchronize this particular type of activity.\n</P>\n<P>\n\n</P>\n<DT><STRONG>Rationale</STRONG>\n<DD><P>\n\nWhereas the other sections primarily ask &quot;what&quot; and &quot;how,&quot; the\nrationale section concentrates on &quot;why.&quot;  This is where we ask you to\njustify some design decisions, by explaining why the choices you made\nare better than alternatives.  You may be able to state these in terms\nof time and space complexity, which can be made as rough or informal\narguments (formal language or proofs are unnecessary).\n</DL>\n<P>\n\nAn incomplete, evasive, or non-responsive design document or one that\nstrays from the template without good reason may be penalized.\nIncorrect capitalization, punctuation, spelling, or grammar can also\ncost points.  See section <A HREF=\"pintos_10.html#SEC152\">D. Project Documentation</A>, for a sample design document\nfor a fictitious project.\n</P>\n<P>\n\n<A NAME=\"Source Code\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC11\"></A>\n<H4> 1.2.2.2 Source Code </H4>\n<!--docid::SEC11::-->\n<P>\n\nYour design will also be judged by looking at your source code.  We will\ntypically look at the differences between the original Pintos source\ntree and your submission, based on the output of a command like\n<CODE>diff -urpb pintos.orig pintos.submitted</CODE>.  We will try to match up your\ndescription of the design with the code submitted.  Important\ndiscrepancies between the description and the actual code will be\npenalized, as will be any bugs we find by spot checks.\n</P>\n<P>\n\nThe most important aspects of source code design are those that specifically\nrelate to the operating system issues at stake in the project.  For\nexample, the organization of an inode is an important part of file\nsystem design, so in the file system project a poorly designed inode\nwould lose points.  Other issues are much less important.  For\nexample, multiple Pintos design problems call for a &quot;priority\nqueue,&quot; that is, a dynamic collection from which the minimum (or\nmaximum) item can quickly be extracted.  Fast priority queues can be\nimplemented many ways, but we do not expect you to build a fancy data\nstructure even if it might improve performance.  Instead, you are\nwelcome to use a linked list (and Pintos even provides one with\nconvenient functions for sorting and finding minimums and maximums).\n</P>\n<P>\n\nPintos is written in a consistent style.  Make your additions and\nmodifications in existing Pintos source files blend in, not stick out.\nIn new source files, adopt the existing Pintos style by preference, but\nmake your code self-consistent at the very least.  There should not be a\npatchwork of different styles that makes it obvious that three different\npeople wrote the code.  Use horizontal and vertical white space to make\ncode readable.  Add a brief comment on every structure, structure\nmember, global or static variable, typedef, enumeration, and function\ndefinition.  Update\nexisting comments as you modify code.  Don't comment out or use the\npreprocessor to ignore blocks of code (instead, remove it entirely).\nUse assertions to document key invariants.  Decompose code into\nfunctions for clarity.  Code that is difficult to understand because it\nviolates these or other &quot;common sense&quot; software engineering practices\nwill be penalized.\n</P>\n<P>\n\nIn the end, remember your audience.  Code is written primarily to be\nread by humans.  It has to be acceptable to the compiler too, but the\ncompiler doesn't care about how it looks or how well it is written.\n</P>\n<P>\n\n<A NAME=\"Legal and Ethical Issues\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC12\"></A>\n<H2> 1.3 Legal and Ethical Issues </H2>\n<!--docid::SEC12::-->\n<P>\n\nPintos is distributed under a liberal license that allows free use,\nmodification, and distribution.  Students and others who work on Pintos\nown the code that they write and may use it for any purpose.\nPintos comes with NO WARRANTY, not even for MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.\nSee section <A HREF=\"pintos_15.html#SEC179\">License</A>, for details of the license and lack of warranty.\n</P>\n<P>\n\nIn the context of UCI CompSci 143A, please respect the spirit\nand the letter of the honor code by refraining from reading any homework\nsolutions available online or elsewhere.  Reading the source code for\nother operating system kernels, such as Linux or FreeBSD, is allowed,\nbut do not copy code from them literally.  Please cite the code that\ninspired your own in your design documentation.\n</P>\n<P>\n\n<A NAME=\"Acknowledgements\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC13\"></A>\n<H2> 1.4 Acknowledgements </H2>\n<!--docid::SEC13::-->\n<P>\n\nThe Pintos core and this documentation were originally written by Ben\nPfaff <A HREF=\"mailto:blp@cs.stanford.edu\">blp@cs.stanford.edu</A>.\n</P>\n<P>\n\nAdditional features were contributed by Anthony Romano\n<A HREF=\"mailto:chz@vt.edu\">chz@vt.edu</A>.\n</P>\n<P>\n\nThe GDB macros supplied with Pintos were written by Godmar Back\n<A HREF=\"mailto:gback@cs.vt.edu\">gback@cs.vt.edu</A>, and their documentation is adapted from his\nwork.\n</P>\n<P>\n\nThe original structure and form of Pintos was inspired by the Nachos\ninstructional operating system from the University of California,\nBerkeley ([ <A HREF=\"pintos_14.html#Christopher\">Christopher</A>]).\n</P>\n<P>\n\nThe Pintos projects and documentation originated with those designed for\nNachos by current and former CS 140 teaching assistants at Stanford\nUniversity, including at least Yu Ping, Greg Hutchins, Kelly Shaw, Paul\nTwohey, Sameer Qureshi, and John Rector.\n</P>\n<P>\n\nExample code for monitors (see section <A HREF=\"pintos_7.html#SEC114\">A.3.4 Monitors</A>) is\nfrom classroom slides originally by Dawson Engler and updated by Mendel\nRosenblum.\n</P>\n<P>\n\n<A NAME=\"Trivia\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC14\"></A>\n<H2> 1.5 Trivia </H2>\n<!--docid::SEC14::-->\n<P>\n\nPintos originated as a replacement for Nachos with a similar design.\nSince then Pintos has greatly diverged from the Nachos design.  Pintos\ndiffers from Nachos in two important ways.  First, Pintos runs on real\nor simulated 80<VAR>x</VAR>86 hardware, but Nachos runs as a process on a\nhost operating system.  Second, Pintos is written in C like most\nreal-world operating systems, but Nachos is written in C++.\n</P>\n<P>\n\nWhy the name &quot;Pintos&quot;?  First, like nachos, pinto beans are a common\nMexican food.  Second, Pintos is small and a &quot;pint&quot; is a small amount.\nThird, like drivers of the eponymous car, students are likely to have\ntrouble with blow-ups.\n<A NAME=\"Project 0--Getting Real\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_1.html#SEC1\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_2.html#SEC15\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}