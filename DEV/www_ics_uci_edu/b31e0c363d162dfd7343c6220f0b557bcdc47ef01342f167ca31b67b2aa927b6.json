{"url": "https://www.ics.uci.edu/~thornton/ics45c/Notes/StandardLibrary/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2019, Notes and Examples: C++ Standard Library</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"../../GradeCalculator\">Grade Calculator</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall s2019<br />\r\n   Notes and Examples: C++ Standard Library</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>Includes a code example with the moniker <b>StandardLibrary</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Like most industrial-strength programming languages, C++ provides a <i>standard library</i> of tools that augment what is built directly into the language.  We've already used some parts of the C++ Standard Library in our work this quarter, such as I/O tools like those declared in the <b>&lt;iostream&gt;</b> header, the <b>std::string</b> type, and a small handful of others.  But the library is more extensive than the parts we've seen, so this example begins exploring parts of the library we've yet to see.</p>\r\n\r\n<p>One of the core parts of the C++ Standard Library is a set of commonly-useful \r\ndata structures and algorithms, which are some of the most immediately valuable \r\npieces of the library when you want to write programs in C++ more quickly; \r\nbroadly, these are sometimes called the <i>Standard Template Library</i> (STL), \r\nthough this name is mostly a historical curiosity nowadays.  The need for common \r\ndata structures like array-based sequences (known in C++ as <i>vectors</i>), \r\nlinked lists (known in C++ as <i>lists</i> or <i>forward_lists</i>), or for \r\ncommon algorithms such as finding the first object in a collection that \r\nsatisfies some requirement or summing the numbers in a collection of numbers, is \r\npervasive; it's hard to imagine very many interesting programs that don't \r\nrequire some kind of data structure or a common algorithm.  So C++ provides a \r\ncollection of these right out of the box &mdash; and that collection has gotten \r\nlarger in recent years, as C++ has undergone its C++11, C++14, and C++17 standardization \r\nefforts, and it will continue to grow as new standards like C++20 are completed \r\nand implemented.</p>\r\n\r\n<p>In this example, we focus our efforts on the data structures and algorithms in the C++ Standard Library.  Rather than exhaustively demonstrating all of them, we aim to show the general design that they have in common with one another.  The C++ Standard Library provides its data structures and algorithms in a portion of the library that is split, roughly, into three interlocking parts: <i>containers</i>, <i>generic algorithms</i>, and <i>iterators</i>.  Once you understand how each of these parts work, and once you understand how they fit together, you'll find it much easier to learn the individual details when you need them.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Containers</p>\r\n\r\n<p>The C++ Standard Library provides a set of what are called <i>containers</i> (or data structures), some examples of which include:</p>\r\n\r\n<ul>\r\n  <li><b>std::vector</b>, an array-based sequence, in the same spirit as the ArrayList class we wrote in a previous example</li>\r\n  <li><b>std::list</b>, a doubly-linked list with head and tail pointers</li>\r\n  <li><b>std::map</b>, a balanced binary search tree of key/value pairs</li>\r\n</ul>\r\n\r\n<p>While each of these containers supports a slightly different set of operations, there are similarities wherever such similarities make sense, so you'll find that learning about one of them will make it easier to learn about the others.</p>\r\n\r\n<p>Interestingly, inheritance is not used to enforce the commonalities between the various containers; in other words, not all container classes inherit from a common base class the way they do in some other object-oriented implementations (such as the Java Collections Framework that's included in Java's standard library).  Instead, the containers are built substantially out of C++ templates, which are able to relate types that have syntactically similar features (e.g., public member functions with the same name or similarly overloaded operators) even if they don't inherit from the same base class.</p>\r\n\r\n<p>The containers are <i>type-generic</i>, meaning that different vectors can be specified to hold different kinds of elements, though each one will be specified to hold a particular kind and, like everything else in C++, this constraint will be enforced by the compiler.  The syntax for this is generally driven by <i>type parameters</i> &mdash; which become part of the container's type &mdash; listed within angle brackets.  So, for example, a <b>std::vector&lt;int&gt;</b> is a vector in which each element is an integer.  We say, then, that <b>std::vector</b> is a <i>class template</i> &mdash; a blueprint from which many classes can be created &mdash; that takes type parameters.  These type parameters are not optional; each time you use the <b>std::vector</b> template (e.g., by declaring a variable that stores a vector), it will be necessary for the compiler to know specifically what type of element will be stored in that vector.  In other words, there's no such thing as a <b>std::vector</b>; there are only <b>std::vector&lt;int&gt;</b>, <b>std::vector&lt;std::string&gt;</b>, and so on.  Each of these separate <i>instantiations</i> of the <b>std::vector</b> template are separate, incompatible types; they're similar but not the same, so you can't assign, say, a <b>std::vector&lt;int&gt;</b> into a <b>std::vector&lt;std::string&gt;</b>.</p>\r\n\r\n<p>All of the containers are \"well-behaved\" in the ways that we've talked about before: They manage their own memory, clean that memory up when they die, can be copied (e.g., passed by value) and subsequent changes to the copy will not affect the original, can be <b>const</b> and still allow you to use them in a read-only fashion, and so on.  That the containers are well-behaved means that you can use the containers as member variables in your classes and not worry about writing a \"Big Three\"; when these member variables are copied or destroyed, the right thing will happen behind the scenes automatically.</p>\r\n\r\n<p class=\"subtitle\">More details about std::vector</p>\r\n\r\n<p>To start to get a feel for the design of the containers in the C++ Standard Library, let's take a quick look at the <b>std::vector</b> container.</p>\r\n\r\n<p>A <b>std::vector</b> stores a sequence of objects.  By <i>sequence</i>, I mean that the objects appear, conceptually, to be stored one after another, and that the order of these objects is considered important.  If we iterate over the objects in the container, then, we'll get them back in that same order.  Like any container, using it effectively requires knowing enough about its underlying implementation that we understand its costs and benefits.  In the case of a vector, the important thing to know is that it stores its elements in an array, just like our ArrayList implementation in a previous example.  While that array isn't directly accessible to us &mdash; one of the key jobs of a vector is to manage that array automatically &mdash; it's the reality, and our understanding of a vector's performance is built on our understanding of how arrays work.</p>\r\n\r\n<p>Since a vector's elements are stored, behind the scenes, in a dynamically-allocated array, some things become immediately apparent:</p>\r\n\r\n<ul>\r\n  <li>A vector must have a notion of a <i>capacity</i>, which is to say that the array must have been created with a particular number of cells.</li>\r\n  <li>A vector stores its elements in array cells, so each element has an index.</li>\r\n  <li>Accessing an element, given its index, is a constant-time operation (i.e., it runs in <i>O</i>(1) time).</li>\r\n  <li>Inserting elements at the beginning of the sequence, removing elements from the middle of the sequence, and so on, are more expensive, requiring a linear number of operations (i.e., <i>O</i>(<i>n</i>), if there are <i>n</i> elements in the vector).</li>\r\n</ul>\r\n\r\n<p>Another thing to understand is that in a vector with capacity <i>c</i> that's currently storing <i>n</i> elements, we would say that the <i>size</i> of the vector is <i>n</i>.  In other words, the size of a vector is determined by how many things we're currently storing in it; its capacity is determined by how many things we <i>can</i> store in it without running out of space in the array.  Note, too, that vectors behave the way our ArrayList class did when you try to add an element and they're out of space: A new array is allocated and the elements are copied from the original array into the new one, then the original array is deleted.  This doesn't happen often and, in fact, one of the guarantees that vector makes is that this cost will be spread evenly across a long sequence of adds (i.e., adding to the end of a vector <i>n</i> times will take a total of <i>O</i>(<i>n</i>) time, even though a few of the operations along the way will be much more expensive than the others because of the reallocations).</p>\r\n\r\n<p>Creating a vector is as simple as obtaining its declaration &mdash; by including a standard header called <b>&lt;vector&gt;</b> &mdash; and declaring a variable of the appropriate type.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;int&gt; v;\r\n</pre></blockquote>\r\n\r\n<p>Adding a new element to the end of the vector, in the cell immediately after the last one that contains an element, can be done by calling the member function <b>push_back</b>.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;int&gt; v;\r\n\r\nfor (unsigned int i = 0; i &lt; 10; i++)\r\n{\r\n    v.push_back(i);\r\n}\r\n</pre></blockquote>\r\n\r\n<p>You can also initialize a vector to contain a predefined sequence of elements, using the same <i>initializer list</i> syntax we saw when we learned about structs previously.  The objects in the initializer list become the vector's elements, while the size of the vector is the number of objects in the initializer list.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;int&gt; v{1, 2, 3, 4, 5};\r\n</pre></blockquote>\r\n\r\n<p>An initializer list used to construct a vector will always be treated this way, but it's worth knowing that you can also call other vector constructors that take other parameters, but you'll need to use an alternate syntax (parentheses instead of curly braces) to differentiate it from the \"initializer list\" syntax.  (It should be noted, too, that using parentheses to call constructors is always legal, though the curly-brace-based syntax has emerged in recent C++ standards as the \"standard\" way to initialize something, with the parentheses-based notation used as a fallback to differentiate it when initializer lists have a special meaning, like in this case.)  For example, this variant creates a vector containing 10 elements that all have the value 100.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;int&gt; v(10, 100);\r\n</pre></blockquote>\r\n\r\n<p>Individual elements are accessible using the same <b>[ ]</b> (indexing) operator that you've seen previously when accessing elements of an array.  This operator has been <i>overloaded</i> to do the appropriate thing on a vector.</p>\r\n\r\n<blockquote><pre>\r\nfor (unsigned int i = 0; i &lt; 10; i++)\r\n{\r\n    v[i] += 10;\r\n    std::cout &lt;&lt; v[i] &lt;&lt; std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Just like arrays, the <b>[ ]</b> operator is not bounds-checked, which means that it misbehaves in the same way that arrays do if you access a cell that doesn't exist (i.e., you get undefined behavior, which might include reading from or writing to memory that's not part of the underlying array).  However, there is a bounds-checked alternative: a member function called <b>at()</b>, which throws an exception when an attempt is made to access an element outside of the boundaries of the vector's size (i.e., outside of the index range [0, size-1]).  Other than the bounds checking, <b>at()</b> is just like the <b>[ ]</b> operator, including the ability to use it to write to a cell.</p>\r\n\r\n<blockquote><pre>\r\nfor (unsigned int i = 0; i &lt; 10; i++)\r\n{\r\n    v.at(i) += 10;\r\n    std::cout &lt;&lt; v.at(i) &lt;&lt; std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>If it looks strange to you that you can assign to the <i>result of calling a function</i>, this isn't as crazy as it looks.  The <b>at()</b> member function returns a <i>reference</i> to the cell in question, as opposed to a copy of it, so that assigning to the result of calling <b>at()</b> is actually assigning directly into a cell of the array.</p>\r\n\r\n<p>Of course, if the vector is <b>const</b>, you won't be able to assign into its cells, since that would constitute a change to the vector's publicly observable state; in fact, anything that changes any element of the vector will be disallowed.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo(const std::vector&lt;int&gt;&amp; v)\r\n{\r\n    v.push_back(15);   // illegal\r\n    v[3] = 50;         // illegal\r\n    v.at(3) = 50;      // illegal\r\n\r\n    for (unsigned int i = 0; i < v.size(); i++)      // legal\r\n    {\r\n        std::cout &lt;&lt; v.at(i) &lt;&lt; std::endl;     // legal\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The loop at the end of the <b>foo()</b> function above is entirely legal, because it only uses the vector in ways that don't change it: asking it for its size and reading the value of one of its elements.  (Notice that the <b>at()</b> member function can be either legal or illegal in the case of a const vector, depending on how you use the result.  This is because the <b>const</b> version of this member function returns a reference to a cell of the array that is itself <b>const</b>-protected.)</p>\r\n\r\n<p>Vectors are \"well-behaved\" in the way that we've understood the term previously.  That's a good thing, in general, because we can assume that it'll clean up its own memory and so on.  However, it's also important to realize that this is not without cost sometimes.  Any time you copy a vector, you're copying the <i>entire vector</i>, including all of its elements; if it's a large vector (imagine, for example, a vector of 1000 strings), this can be quite an expensive operation.  It's wise to recognize, and quite often avoid, operations like this that have such high cost; it's an easy performance-related mistake to make before you realize how important it is.</p>\r\n\r\n<blockquote><pre>\r\n// This function takes a vector by value, which means it will be copied -- along\r\n// with all of its elements -- on the way into the function.  That can make a\r\n// call to this function quite expensive!\r\nvoid blah(std::vector&lt;std::string&gt; v)\r\n{\r\n    // ...\r\n}\r\n\r\nstd::vector&lt;int&gt; v;\r\n// ...\r\nstd::vector&lt;int&gt; w = v;         // copies v into w\r\nv = w;                          // copies w back into v\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">What happens when you don't specify a vector's element type</p>\r\n\r\n<p>As we've seen, whenever you declare a variable or a parameter that is a vector, it's necessary to specify what type of element will be stored in that vector.  There's no such thing as a <b>std::vector</b>; there are only <b>std::vector&lt;int&gt;</b>, <b>std::vector&lt;std::string&gt;</b>, and so on.  The compiler needs to know the element type of every vector and the best way to make sure of that is to specify it directly.</p>\r\n\r\n<p>That said, in the most recent C++ standard (C++17), a feature was introduced that allows you to leave that detail out of a declaration like this (i.e., to use a class template without specifying its arguments), but only if the compiler can unambiguously deduce what you must have wanted.  For example, the following variable declaration turns out to be legal, but it doesn't mean what you might think.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector v1{1, 2, 3, 4, 5};\r\n</pre></blockquote>\r\n\r\n<p>What is the type of <b>v1</b>?  It turns out to be <b>std::vector&lt;int&gt;</b>, even though we didn't say so explicitly, because the compiler was able to deduce from our initializer list that we wanted it to contain integers.</p>\r\n\r\n<p>So, how about this one?</p>\r\n\r\n<blockquote><pre>\r\nstd::vector v2{\"hello\", \"there\"};\r\n</pre></blockquote>\r\n\r\n<p>You might expect that one to be deduced as <b>std::vector&lt;std::string&gt;</b>, but it's actually something else: <b>std::vector&lt;const char*&gt;</b>, because string literals in C++ are implemented as pointers to arrays of constant characters.  (The reason you can initialize a <b>std::string</b> with a string literal is because <b>std::string</b> has a constructor capable of doing the appropriate conversion.)</p>\r\n\r\n<p>And, of course, if the compiler has no way to deduce what we want, it won't allow us to leave out the element type of a <b>std::vector</b> at all.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector v3;             // illegal\r\n\r\nvoid foo(std::vector v4)    // also illegal\r\n{\r\n    // ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>The moral of this story is that C++ compilers have ways to deduce our types for us, but these features weren't added to the language to save us from having to type as much.  They were actually added to provide flexibility in cases where it's difficult to say what we want, such as when we're writing our own templates and want something more flexible than a hard-coded single type.  It's important to remember that your programs aren't intended only to be consumed by a compiler; they're also intended to be read by human beings.  <b>std::vector&lt;int&gt;</b> simply says more than <b>std::vector</b> does.  In short, we don't want to leave things out of a program that would make it easier for a person to read and understand.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Generic algorithms</p>\r\n\r\n<p>In addition to containers, the C++ Standard Library provides a set of <i>generic algorithms</i>, which generalize commonly-occurring operations that you might like to perform, such as these:</p>\r\n\r\n<ul>\r\n  <li>Apply the same function to each of a range of values</li>\r\n  <li>Find a value in a range of values that has a particular, interesting property (e.g., is a positive number, is a student whose age is greater than 21, etc.)</li>\r\n  <li>Remove from a range of values those that have a particular, interesting property</li>\r\n  <li>Shuffle the values in a range of values randomly, so they appear in a different (randomly-determined) order than they did before</li>\r\n  <li>Sort the values in a range of values, possibly given an arbitrary function to compare pairs of values to see which should come first</li>\r\n</ul>\r\n\r\n<p>Algorithms such as these would typically manifest themselves in your programs as loops or more complex functions that you might find yourself having to write.  The generic algorithms in the C++ Standard Library remove the need to write a lot of these kinds of things, shortening and clarifying the programs you write, so that you can not only write them more quickly, but also understand them better when you read them.  The name of an algorithm reads more clearly than its implementation details, and this is especially true when you combine more than one of them.</p>\r\n\r\n<p>The algorithms generally are not aware of what kind of container they're operating on, which means they generally work on all of the containers in the standard library (except for those for which they don't make sense, such as sorting the values in a <b>std::unordered_set</b>).  What's more, if you write a container implementation yourself, you can apply the generic algorithms in the standard library to your container, provided that you follow the typical C++ design for a container.  Similarly, if you write a generic algorithm yourself that's designed like the ones in the standard library, you can apply it to any of the library's containers.</p>\r\n\r\n<p>So how does an algorithm operate on the values in a container without depending on &mdash; or even being aware of &mdash; what kind of container it is?  The answer lies in the third of the interlocking parts: iterators.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Iterators</p>\r\n\r\n<p>In the C++ Standard Library, <i>iterators</i> are the glue between the containers and the generic algorithms.  An iterator is an abstraction for a position in a container, whose main role is the provide access to the value stored at that position (e.g., in a particular cell of a <b>std::vector</b>), while hiding all of the details about the container's underlying implementation.</p>\r\n\r\n<p>Given an iterator, a generic algorithm can access (and potentially modify) the values stored in a container without having to know what kind of container it is, meaning that existing generic algorithms will work with new containers you build, and that new generic algorithms can easily work with the existing containers that have the right characteristics.  This idea makes for quite a flexible arrangement, which depends only on agreeing on how to manipulate iterators.</p>\r\n\r\n<p>Syntactically, iterators behave a lot like pointers.  In some cases, that's what they actually are; in others, they're more complex.  But they support the same basic operators either way.</p>\r\n\r\n<ul>\r\n  <li>You can use the <b>*</b> operator to dereference an iterator, just like you can use the <b>*</b> operator to dereference a pointer.  The effect is the same: Given an iterator <b>i</b> pointing to a position containing a value <b>v</b>, <b>*i</b> would give you access to the value <b>v</b>.  As with pointers, you could do this on either side of an assignment, so you could read the value of <b>*i</b> or you could change it.  Also similar to pointers, the <b>-&gt;</b> operator is available if the values have members.</li>\r\n  <li>The <b>++</b> operator moves an iterator forward (i.e., to the next position in the container).</li>\r\n  <li>The <b>--</b> operator moves an iterator backward (i.e., to the previous position in the container).</li>\r\n  <li>You can sometimes use other kinds of arithmetic (e.g., given an iterator <b>i</b>, writing <b>i + 3</b> or <b>i += 3</b> can be legal), which mirrors the pointer arithmetic we've seen previously.</li>\r\n</ul>\r\n\r\n<p>Iterators support whichever operations are sensible for the kind of container they're iterating, and they are categorized on the basis of which operations they support.  A few examples of those categorizations are:</p>\r\n\r\n<ul>\r\n  <li><i>Forward iterators</i>, which are able to iterate through a container in one direction (forward, one position at a time) but no other.  This means they support <b>*</b> (dereferencing) and <b>++</b> (iterating forward).</li>\r\n  <li><i>Bidirectional iterators</i>, which are able to do everything that forward iterators can do, plus iterate backward (i.e., they also support <b>--</b>).</li>\r\n  <li><i>Random access iterators</i>, which are able to do everything that bidirectional iterators can do, plus arbitrary jumps using pointer-arithmetic-like syntax.</li>\r\n</ul>\r\n\r\n<p>Depending on what kind of container you're iterating, you'll get a different kind of iterator back.  For example, <b>std::vector</b> provides random-access iterators, because the array that underlies a vector provides constant-time access to any cell given its index.  On the other hand, <b>std::list</b> (a doubly-linked list) would provide only a bidirectional iterator, and <b>std::forward_list</b> (a singly-linked list) would provide only a forward iterator, because other operations would be too expensive for an algorithm to reasonably rely on.</p>\r\n\r\n<p class=\"subtitle\">Using iterators to traverse a container</p>\r\n\r\n<p>Recall a loop that we wrote previously to iterate over an array using a technique called <i>pointer arithmetic</i>.</p>\r\n\r\n<blockquote><pre>\r\nint a[10];\r\n\r\nfor (int* p = a; p != a + 10; p++)\r\n{\r\n    *p = 0;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Recall what's being done here.</p>\r\n\r\n<ul>\r\n  <li>The pointer <b>a</b> points to the start of the array (i.e., the array's first cell).</li>\r\n  <li>We calculate an \"end position\" from our knowledge of the array's size: <b>a + 10</b> is a pointer to the cell <i>directly following</i> the last cell in the array.</li>\r\n  <li>We move the traversal pointer <b>p</b> forward by using <b>++</b> (i.e., more pointer arithmetic).</li>\r\n  <li>When we want to access one of the values in the array, we dereference the traversal pointer using the <b>*</b> operator.</li>\r\n</ul>\r\n\r\n<p>While one could argue that this is a fairly obtuse piece of syntax, it turns out to be important to understand it, because iterators in the C++ Standard Library work the same way.  Iterators behave a lot like pointers do.  We use <b>*</b> to dereference them, <b>++</b> to advance them, and calculate \"begin\" and \"end\" positions as a way to traverse the elements.  The only difference is the types at work.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;std::string&gt; s;\r\n\r\n// ...\r\n\r\nfor (std::vector&lt;std::string&gt;::iterator i = s.begin(); i != s.end(); i++)\r\n{\r\n    std::cout &lt;&lt; *i &lt;&lt; std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>And since iterators behave like pointers, we can also use the <b>-&gt;</b> operator to access members of the values they point to, just like pointers.</p>\r\n\r\n<blockquote><pre>\r\nfor (std::vector&lt;std::string&gt;::iterator i = s.begin(); i != s.end(); i++)\r\n{\r\n    std::cout &lt;&lt; i-&gt;length() &lt;&lt; std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">The \"auto\" keyword and type inference</p>\r\n\r\n<p>The technique above is pleasant enough, once you get used to it.  But there's one thing about it that's really an eyesore: <b>std::vector&lt;std::string&gt;::iterator</b> is one heck of a type name!  And, as you might imagine, this is the tip of the iceberg; as the container types get more complex, so do the iterator types.  This, for example, is a legal iterator type for a more complex kind of container: <b>std::map&lt;std::string, std::vector&lt;unsigned int&gt;&gt;::iterator</b>.</p>\r\n\r\n<p>The problem, in general, is that the type information itself is somewhat complex.  Because different kinds of containers have different, incompatible types of iterators, the types have to communicate enough information to differentiate one from another.  While the name of the type is long, none of it is noise; it's all meaningful!  But, of course, this leads us to have to say these things in all their complexity, which makes our programs harder to write and harder to read.  Statically-typed languages like C++ generally require every declaration to be given a type at compile time, but what do we do when the types themselves have names that are long and complex?</p>\r\n\r\n<p>There are a lot of scenarios where a compiler, given contextual information surrounding a declaration, could unequivocally determine <i>exactly</i> what the right type for a declaration would be, without you having to say so.  If, for example, you call <b>begin()</b> on a <b>std::vector&lt;std::string&gt;</b>, the compiler is well aware &mdash; because of the declaration of the <b>begin()</b> member function that was included already from the <b>&lt;vector&gt;</b> header &mdash; that the result will be a <b>std::vector&lt;std::string&gt;::iterator</b>.  Beginning in C++11, C++ compilers include a new feature called <i>type inference</i>, which allows the compiler to deduce the proper type for you automatically, instead of you having to say it.  The way you ask for this behavior is simple: specify the type as <b>auto</b>.</p>\r\n\r\n<blockquote><pre>\r\nfor (auto i = s.begin(); i != s.end(); i++)\r\n{\r\n    std::cout &lt;&lt; i-&gt;length() &lt;&lt; std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Note that this doesn't mean that <b>i</b> has no type, nor does it mean that <b>i</b> can store anything you want, nor that its type will be determined at run time.  Just as it did in our original example, <b>i</b> has a compile-time type of <b>std::vector&lt;std::string&gt;::iterator</b>, and we still won't be allowed to assign a value of any other type into <b>i</b>.  All of the same type checking will be done the same way.  The only thing <b>auto</b> means here is that we'd like the compiler to deduce the type of <b>i</b> for us automatically, so we don't have to write it.</p>\r\n\r\n<p>There's at least some controversy in the broader C++ community about when you should and shouldn't use the <b>auto</b> keyword, and a lot of the benefit doesn't arise until we learn more C++ features (most notably, templates, where we want to write one chunk of code that is capable of working with wildly different types), but it's a good time to discuss this feature now, since it can, at the very least, simplify your uses of the C++ Standard Library.</p>\r\n\r\n<p class=\"subtitle\">Iterators over \"const\" containers</p>\r\n\r\n<p>We've seen previously that you can declare a container to be <b>const</b>, meaning that it's possible to read from it, but not to alter it.  But how does <b>const</b> interact with iterators, which we've seen are capable of both reading from <i>and</i> writing to the values that they point to.</p>\r\n\r\n<p>Let's consider a function that prints all of the elements in a vector of strings.</p>\r\n\r\n<blockquote><pre>\r\nvoid printAll(const std::vector&lt;std::string&gt;&amp; v)\r\n{\r\n    // What would be the appropriate type for i?\r\n    for (??? i = v.begin(); i != v.end(); i++)\r\n    {\r\n        std::cout &lt;&lt; *i &lt;&lt; std::endl;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>As we've seen, the word <b>const</b> can be used in different places and mean different things.  Let's think about some possible ways to write the correct type for <b>i</b>.</p>\r\n\r\n<ul>\r\n  <li><b>std::vector&lt;std::string&gt;::iterator</b> would be incorrect, because the <b>iterator</b> type implies that values can be either read or written, which would violate the constness of the vector.  (Because the vector is const, anything that introduces the <i>possibility</i> of changing the vector will be illegal; an <b>iterator</b> introduces that possibility.)</li>\r\n  <li><b>const std::vector&lt;std::string&gt;::iterator</b> would also be incorrect, because it implies that the iterator itself can't be changed (i.e., you wouldn't be able to advance it forward using <b>++</b>), and that you could still use it to modify the elements of the vector, which would violate the vector's constness.  We don't want the iterator to be constant; we want the elements in the vector to remain constant.</li>\r\n</ul>\r\n\r\n<p>Unfortunately, there isn't anywhere else we could legally add the keyword <b>const</b> to this type declaration to mean something different.  But there is a way to say what we want to say here: use the type <b>const_iterator</b> instead of the type <b>iterator</b>.  A <b>const_iterator</b> is one that can be used to read values from a container but not change them.  So, the proper type for <b>i</b> would be <b>std::vector&lt;std::string&gt;::const_iterator</b>.</p>\r\n\r\n<blockquote><pre>\r\nvoid printAll(const std::vector&lt;std::string&gt;&amp; v)\r\n{\r\n    for (std::vector&lt;std::string&gt;::const_iterator i = v.begin(); i != v.end(); i++)\r\n    {\r\n        std::cout &lt;&lt; *i &lt;&lt; std::endl;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Note, too, that the <b>auto</b> keyword would deduce this automatically, because of the vector's constness, making this code equivalent.  (It's in matters like this where <b>auto</b> really shines.)</p>\r\n\r\n<blockquote><pre>\r\nvoid printAll(const std::vector&lt;std::string&gt;&amp; v)\r\n{\r\n    for (auto i = v.begin(); i != v.end(); i++)\r\n    {\r\n        std::cout &lt;&lt; *i &lt;&lt; std::endl;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Range-based \"for\" loops</p>\r\n\r\n<p>You may have noticed that there is a recurring pattern in these examples:</p>\r\n\r\n<ul>\r\n  <li>Start an iterator where <b>begin()</b> points.</li>\r\n  <li>Obtain each value the iterator points to.</li>\r\n  <li>Advance the iterator forward once per loop iteration until it points where <b>end()</b> points.</li>\r\n</ul>\r\n\r\n<p>In this pattern, the only reason we need the iterator is to track our position as we iterate; it's an implementation detail of our pattern, but is otherwise boilerplate.  For this reason, another kind of <b>for</b> loop &mdash; called a <i>range-based <b>for</b> loop</i> &mdash; was introduced into C++.  The range-based <b>for</b> loop automates precisely this pattern.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;int&gt; v{1, 2, 3, 4, 5};\r\n\r\nfor (int i : v)\r\n{\r\n    std::cout << i << std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Behind the scenes, the range-based <b>for</b> loop is turned into this equivalent:</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;int&gt; v{1, 2, 3, 4, 5};\r\n\r\nfor (std::vector&lt;int&gt;::iterator v_iterator = v.begin(); v_iterator != v.end(); v_iterator++)\r\n{\r\n    int i = *v_iterator;\r\n    std::cout << i << std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>In other words, the iterator will still be there, but we won't be the ones to have to manage it.  All of the boilerplate &mdash; the call to <b>begin()</b>, the comparison to <b>end()</b>, the incrementing, and obtaining the value where the iterator points &mdash; is automated.  It should be noted, too, that the range-based <b>for</b> loop doesn't work only on vectors; it works on anything that looks like a C++ Standard Library container (i.e., it has <b>begin()</b> and <b>end()</b> that return iterators).</p>\r\n\r\n<p>As with the use of <b>auto</b> that we saw previously, constness is handled properly and automatically.  And we can even avoid copying the vector's elements into our loop variable by using techniques like const references.</p>\r\n\r\n<blockquote><pre>\r\nvoid printAll(const std::vector&lt;std::string&gt;&amp; v)\r\n{\r\n    for (const std::string&amp; s : v)\r\n    {\r\n        std::cout &lt;&lt; s &lt;&lt; std::endl;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Of course, if we need the iterator for some reason, then we'll have to do things the old-fashioned way.  But, in my experience, I don't end up needing the iterators very often.  And, in fact, I don't even write all that many of the range-based <b>for</b> loops for common algorithms, because of what we'll see next.</p>\r\n\r\n<p class=\"subtitle\">Using iterators with generic algorithms</p>\r\n\r\n<p>Most of the generic algorithms in the C++ Standard Library are meant to operate on a range of values, so there needs to be a way for them to access the various values in that range.  However, the goal is for the algorithms to be implemented once and work on many different kinds of containers.  It shouldn't matter whether you're using a <b>std::vector</b>, a <b>std::list</b>, or a <b>std::map</b>; if it's possible to iterate through it, many of the generic algorithms should be legal to use on it.  Examples of generic algorithms include:</p>\r\n\r\n<ul>\r\n  <li><b>std::for_each</b>, which calls a function on every value in a range.  It's up to you what function is called; you pass it as a parameter.</li>\r\n  <li><b>std::count_if</b>, which counts how many values in a range meet some criteria.  The criteria is determined by a function, which you pass as a parameter.</li>\r\n  <li><b>std::transform</b>, which is similar to the <b>transform</b> function we wrote in the <a href=\"../FunctionsAndLambdas\">Functions and Lambdas</a> notes previously, except that it can write its output somewhere other than directly on top of its input (so, for example, you could transform the elements of one vector and store the results in a different vector).</li>\r\n  <li><b>std::sort</b>, which sorts values into ascending order.  You can optionally pass a <i>comparison function</i> that determines whether a value is less than another (allowing you to customize the kind of result you get from the sorting, even though the sort algorithm itself stays the same).</li>\r\n</ul>\r\n\r\n<p>There are many others; the above list is just a small sampling of what's available.  But the important thing is that none of these algorithms needs to be specific to a particular container; they should work on lots of different kinds of containers.  But, to do that, they need a way to access the values in that container without knowing how it's implemented.  That's no problem; that's what iterators do!</p>\r\n\r\n<p>The generic algorithms generally take a range of values by accepting two parameters: a <i>begin iterator</i> and an <i>end iterator</i>, with the begin iterator specifying the first input value and the end iterator specifying the value <i>just after</i> the last input value.  Among other things, this means that the <b>begin()</b> and <b>end()</b> member functions on the various containers provide a nice way to pass the entire container into a generic algorithm.</p>\r\n\r\n<p>For example, suppose we wanted to print all of the values in a <b>std::vector&lt;std::string&gt;</b> to the standard output, one per line.  The <b>std::for_each</b> algorithm will make that very simple, indeed.</p>\r\n\r\n<blockquote><pre>\r\n#include &lt;algorithm&gt;   // This is where the generic algorithms are declared\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid printStringLine(const std::string&amp; s)\r\n{\r\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\r\n}\r\n\r\n// ...\r\n\r\nstd::vector&lt;std::string&gt; v;\r\n// ...\r\nstd::for_each(v.begin(), v.end(), printStringLine);\r\n</pre></blockquote>\r\n\r\n<p>The first two arguments to <b>std::for_each</b> specify the range of values that we want to operate on; in this case, we're passing the entire contents of the vector <b>v</b> by using the <b>begin()</b> and <b>end()</b> member functions.  The third argument specifies the function that we want to apply to every value; in this case, we've passed our own <b>printStringLine</b> function, which prints a single string value on a line by itself.</p>\r\n\r\n<p>Note, too, that the generic algorithms that accept functions as arguments actually accept <i>function objects</i>, which means that we can pass anything that can be called as a function, including not only functions that we've written, but also arbitrary objects with overloaded function call operators, including the ones built by lambdas.</p>\r\n\r\n<blockquote><pre>\r\nstd::vector&lt;std::string&gt; v;\r\n// ...\r\nstd::for_each(\r\n    v.begin(), v.end(),\r\n    [](const std::string&amp; s) { std::cout &lt;&lt; s &lt;&lt; std::endl; });\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Finding out more</p>\r\n\r\n<p>After working through this example, it's not a bad idea to spend a little bit of time experimenting with a few of the containers and generic algorithms not discussed here, such as the <b>std::map</b> and <b>std::list</b> containers and the <b>std::find</b> and <b>std::sort</b> algorithms, so you can get a sense of how they work.</p>\r\n\r\n<p>A lot of good information can be found online but, as usual, the trick is to separate what's useful from what's worthless.  I've found that a good place to start is <a href=\"http://cppreference.com/\">cppreference.com</a>, which I find to be the most comprehensive and well-written reference documentation for the C++ Standard Library online.  (You may disagree and, in general, that's fine.  Use what you'd like.  But if you're not sure where to start, use <a href=\"http://cppreference.com/\">cppreference.com</a>.)  This will give you an idea of what's available, and will show you the details of how it works underneath, though you might also want to look in other places to see concrete examples of these details in action.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>StandardLibrary</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download StandardLibrary</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"StandardLibrary.tar.gz\">StandardLibrary.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}