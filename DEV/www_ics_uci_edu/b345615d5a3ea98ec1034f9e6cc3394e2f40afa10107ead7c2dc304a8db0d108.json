{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/dictionaryprocessing/dictionaryprocessing.txt", "content": "\t\t\tFunctions for Dictionary Processing\r\n\r\nExamine the dictionary processing functions in the project accompanying this\r\nlecture. Generally dictionaries are more focused and powerful than lists, so\r\nthere are not as many generally useful dictionary functions. But dictionaries\r\ndo occur in very many interesting programs. Hand simulate these functions, or\r\nrun them (in the debugger) to understand them better. Also see the example uses\r\nin the driver I supplied. Here is some commentary. \r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe count function\r\n\r\nThe count function takes a list of objects as an argument. It creates an empty\r\ndict and binds answer to it. Then it iterates over every value in the list\r\n\r\n  (a) calls answer.get(v,0), which either retrieves the the value associated\r\n        with v (how many times this v has bee processed), or returns 0 if no\r\n        value is associated with v (v hasn't been processed).\r\n  (b) adds 1 to this value\r\n  (c) stores the new value (back) into answer[v], either creating an association\r\n        for the first time (to 1) or changing the association (to a value 1\r\n        bigger than before).\r\n\r\nAfter the loop terminates, it returns all the information accumulate in the \r\ndictionary.\r\n\r\ndef count(alist):\r\n    answer = {}\r\n    for v in alist:\r\n        answer[v] = answer.get(v,0) + 1\r\n    return answer\r\n\r\nWithout using the .get method, we can write the body of the loop more\r\nexplicitly by testing whether or not v is already a key in the answer\r\ndictionary.\r\n\r\n        if v not in answer:\r\n            answer[v] = 1\r\n        else:\r\n            answer[v] += 1\r\n\r\nIf we wrote just answer[v] += 1 inside the loop (remember that this statement\r\nis just shorthand for answer[v] = answer[v]+1), the first iteration (for the\r\nfirst value v in alist) would try to access answer[v] and raise KeyError because\r\nno key with that value is in the dictionary (it starts empty).\r\n\r\nHere is an example of calling this function on a word (in which case count\r\niterates through the letters in the word, not a real list: all that is important\r\nin count is that it can iterate over its argument, processing each value in the\r\ndictionary).\r\n\r\nprint(count('antidisestablishmentarianism'))\r\n\r\nwhich prints\r\n\r\n{'e': 2, 'd': 1, 'a': 4, 'b': 1, 'm': 2, 'l': 1, 'n': 3, 'i': 5, 'h': 1, 't': 3, 's': 4, 'r': 1}\r\n\r\nThis is the actual order when I ran this Python code; remember that\r\ndictionaries are not ordered like list and tuples, so iterating through\r\ndictionaries produces values seemingly at random (although there is an\r\nunderlying order there, it is complicated to explain and not really useful to\r\nknow). See the print_dict method for ensuring the keys are produced in certain\r\norder.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe concordance Function\r\n\r\n\r\nA concordance of a document consists of all the words in the document, each\r\nassociated with a list of line numbers on which each word appears (we will\r\nconvert each word into all lower-case letters for simplicity). We can easily\r\nuse a dictionary whose keys are strings and whose associated values are lists\r\nof integers to keep track of a concordance. As a trivial exampe (but useful to\r\nhand simulate), the file book.txt contains\r\n\r\nSee Spot\r\nSee Spot run\r\nRun Spot run\r\n\r\nand produces a concordance whose dictonary is printed as\r\n\r\n{'run': [2, 3, 3], 'spot': [1, 2, 3], 'see': [1, 2]}\r\n\r\nNotice that the list shows line 3 twice (because Run and run both appear on\r\nline 3; later we will modify our function's code to not append duplicates into\r\nits lists).\r\n\r\nThe concordance function takes an argument that is a string (the name of a file\r\nthat is the document) and produces a dictionary whose keys are strings and\r\nwhose assocated values are lists of integers. Examine it below.\r\n\r\ndef concordance(file_name : str) -> {str:[int]}:\r\n    c = {}\t\t\t\t\t# initialize local names\r\n    line_num = 0\r\n\r\n    for line in open(file_name):\t\t# loop through every line\r\n        line_num += 1\t\t\t\t#   update line_num\r\n        for word in line.rstrip().split(' '):\t#   loop through every word\r\n            word = word.lower()\t\t  \t#     use lower-case\r\n            if word not in c:\t\t\t#     update dictionary\r\n                c[word] = [line_num]\t\t#       assocate word with list\r\n            else:\t  \t\t\t#       or...\r\n                c[word].append(line_num)        #       update list\r\n\r\n    return c\t\t\t\t\t# return result\r\n\r\nNotice the outer loops reads lines from the open file (and uses line_num to\r\nkeep track of  which line has been read: line_num is 1 for the first line,\r\n2 for the second line, etc.).\r\n\r\nEach line is stripped of its '\\n' and split into a list of words, and then\r\niterated over. The inner loop processes each word in the line (in lower-case\r\nform), updating the dictionary for it appropriately: adding a new list if one\r\nis not present; appending to an existing list if one is present. \r\n\r\nNote how the append function mutates the list assocated with each word. It is\r\nfrequently the case in dictionaries that we want to update/mutate the value\r\nassociated with some key (once the key has been put in the dictionary).\r\nBeginning students sometimes write a lot of extra code to perform this simple\r\noperation. Use this code as an example of the easy way to do this.\r\n\r\nFinally, we can enhance this code so that it doesn't put the same line number\r\nin a list twice. There are at least two ways to do this.\r\n\r\ndef concordance(file_name : str) -> {str:[int]}:\r\n    c = {}\t\t\t\t\t# initialize local names\r\n    line_num = 0\r\n\r\n    for line in open('book.txt'):\t\t# loop through every line\r\n        line_num += 1\t\t\t\t#   update line_num\r\n        for word in line.rstrip().split(' '):\t#   loop through every word\r\n            word = word.lower()\t\t  \t#     use lower-case\r\n            if word not in c:\t\t\t#     update dictionary\r\n                c[word] = [line_num]\t\t#       assocate word with list\r\n            else:\t  \t\t\t#       or...\r\n                if line_num not in c[word]:     #       check if line_num absent\r\n                    c[word].append(line_num)    #         update list if so\r\n\r\n    return c\t\t\t\t\t# return result\r\n\r\nWhen Python runs this code on 'book.txt', it prints\r\n\r\n{'see': [1, 2], 'spot': [1, 2, 3], 'run': [2, 3]}\r\n\r\nFinally, since we process line numbers from smallest to biggest, we could\r\nreplace\r\n\r\n  if line_num not in c[word]:\r\n      c[word].append(line_num)\r\n\r\nby the equivalent:\r\n\r\n  if line_num != c[word][-1]:\r\n      c[word].append(line_num)\r\n\r\nwhich checks whether the current line number is not equal to the the last index\r\nin the list associate with word (and if it is not there, it appends it). \r\n\r\nWe can use the print_dict function defined below to print this concordance\r\nmore nicely.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe print_dict Function\r\n\r\nNext is a function that prints a dictionary in a nicer form: its keys are\r\nin alphabetical order, and their values are aligned by computing the maximum\r\nlength of the string representation of keys.\r\n\r\nFor example, it would print the following dictionary produced by count\r\n\r\na         -> 2\r\ncan       -> 1\r\nchuck     -> 2\r\ncould     -> 1\r\nhow       -> 1\r\nif        -> 1\r\nmuch      -> 1\r\nwood      -> 2\r\nwoodchuck -> 2\r\n\r\nand the following dictinary produced by concordance\r\n\r\nrun  -> [2, 3, 3]\r\nsee  -> [1, 2]\r\nspot -> [1, 2, 3]\r\n\r\nLook at the function below. The commented out code shows an alternative way to\r\ncompute the maximum length. We start with max_len at 0and then look at every\r\nkey in adict: if the length of its str is bigger than the max_len, we update\r\nmax_len to its value. After the loop finishes, max_len will store the maximum\r\nstring length of the keys.\r\n\r\nNote that we call str(...) because this function works for all dictionaries,\r\nwith all different types of keys.\r\n\r\nWe can write this code more elegantly by creating a comprehension of the string\r\nlengths of all the keys, and then call the max function on all these values. The\r\nlater approach (which is written in this function) is more Pythonic solution,\r\nbut it harder for beginners to understand. You should try to understand both\r\napproaches to solve this problem; use each to help you understand the other.\r\n\r\ndef print_dict(adict,key=None,reverse=False):\r\n#    max_len = 0\r\n#    for k in adict:\r\n#        if len(str(k)) > max_len:\r\n#            max_len = len(str(k))\r\n    max_len = max( [len(str(k)) for k in adict] )\r\n\r\n    for k,v in sorted(adict.items(), key=key, reverse=reverse):\r\n        print('{k: <{max_len}} -> {v}'.format(k=k, v=v, max_len=max_len))\r\n\r\nLet us show in stages how we wrote all the code for the full second loop, which\r\nactually prints all the values.\r\n\r\n(1) To print all the values in a dict without fancy formatting, we can write\r\njust the following (which iterates over all the keys in adict.\r\n\r\n    for k in adict:\r\n       print(k,'->',addict[k])\r\n\r\n(2) Another way to do this iterates over key-value pairs using adict.items()\r\n\r\n    for k,v in adict.items():\r\n       print(k,'->',v)\r\n\r\n(3) We would like to print this information better formatted so we use the\r\n    format function on following string: {k: <{max_len}} -> {v}', into which we\r\n    substitue the values bound to k and v, and also max_len (I used the same\r\n    names here inside the {} but these names could be different). After\r\n    formatting the string might be 'chuck     -> 2'. Notice that\r\n    {k: <{max_len}} ... substitutes 9 (max_len) into the specification for k,\r\n    so the key is printed in field width of 9, left justified, with spaces\r\n    afterwards).\r\n\r\n    for k,v in adict.items():\r\n        print('{k: <{max_len}} -> {v}'.format(k=k, v=v, max_len=max_len))\r\n\r\n    an equivalent print is the following (but less clear)\r\n\r\n        print('{x: <{y}} -> {z}'.format(x=k, z=v, y=max_len))\r\n\r\n(4) Finally, we would like to iterate through adict.items() in a sorted form,\r\n    using the key and reverse parameters. We know that we can write sorted \r\n    (a function that produces a list we can iterate over). Here it is a list of\r\n    dictionary items, sorted according to key/reverse, which are passed as\r\n    arguments to print_dict and then passed on to sorted). An iterator using\r\n    this information as follows.\r\n\r\n    for k,v in sorted(adict.items(), key=key, reverse=reverse):\r\n\r\n    adict.items produces 2-tuples of key,value pairs, like ('a', 2) then \r\n    ('can', 1) then ('chuck', 2) etc. in any order. The sorted function produces\r\n    a list of these tuple according to key/reverse, which we can iterate over:\r\n    k is bound to each first value in the tuple while v is bound to the second.\r\n\r\nThe project shows various calls to print_dict, both with/without arguments\r\nmatching key/reverse (if omitted, both have default values: None/False, which\r\njust sorts the standard way.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe reverse and reverse_distinct Functions\r\n\r\nThe second function (as the name implies above) is a simple variant of the\r\nfirst. We start by discussing the first, the slight problem with it, and the\r\nfix. To be concrete let's begin by looking at the dictionary we pass to this\r\nfunction as an argument, and then the reversed dictionary that it returns.\r\n\r\nThe argument could look as follows. This dictionary has names of people as its\r\nkeys and lists of names of states as its values (the list of the states each of\r\nthe people lived in): note that these lists can have dupliate values in them, if\r\nthe person lived in the state, moved to another state, and then moved back. The\r\nlists for some people, e.g., 'rich' have this property (he lived in 'PA' and\r\n'CA' twice each); the lists for other people, e.g., 'alex' do not.\r\n\r\noccupancy = {'rich'  : ['IL','PA','CA','WA','PA','CA'],\r\n             'alex'  : ['WA','PA','AZ','CA','NY'],\r\n             'mark'  : ['WA','PA','CA','IN','CA'],\r\n             'ellen' : ['CA','OR','WA','PA','CA'],\r\n             'patty' : ['WA','PA','OR'],\r\n             'david' : ['NY','RI','PA','WA'] }\r\n\r\nIn a \"reversed\" dictionary, they keys are the names of states and the values are\r\nlists of the names of people who have lived in that state. So a reversed\r\ndictionary might look as follows. Note that in the lists in the argument, the\r\norder of the states is important: they tell the movements from state to state\r\nover time of each person; but in the list in the result, the order of the\r\npeople is irrelevant.\r\n\r\nHere I show the results of printing this dictionary with print_dict. If we\r\nwanted to, we could have sorted each of these lists for easier reading, but I\r\ndidn't here.\r\n\r\n  AZ -> ['alex']\r\n  CA -> ['alex', 'rich', 'ellen', 'mark']\r\n  IL -> ['rich']\r\n  IN -> ['mark']\r\n  NY -> ['alex', 'david']\r\n  OR -> ['patty', 'ellen']\r\n  PA -> ['alex', 'rich', 'patty', 'david', 'ellen', 'mark']\r\n  RI -> ['david']\r\n  WA -> ['alex', 'rich', 'patty', 'david', 'ellen', 'mark']\r\n\r\nHere is our first attempt to reverse a dictionary. It would  be very interesting\r\nto single-step this function with the debugger to see how every step worked.\r\n\r\ndef reverse(adict):\r\n    answer = {}\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            if v not in answer:\r\n                answer[v] = []\r\n            answer[v].append(k)\r\n            #code in loop can be replaced by: answer.setdefault(v,[]).append(k)\r\n        #print(answer)  # uncomment this print to see answer being built\r\n\r\n    return answer\r\n\r\nThis function works as follows. First is defines the answer dictionary to be\r\nempty; it will add and update information into this answer dictionary and\r\nultimately return it. In between defining and returning, the OUTER for loop\r\niterates over every item in adict. Each item in adict is a key (person) and\r\nvalue associated with that key (list of states). Here is how each of these\r\nis processed.\r\n\r\nThe INNER for loop iterates over each state in the list of states. Inside the\r\nbody of the inner for loop we have both k, the person, and v, each state the\r\nperson lived in. We want to add that person to the list for that state in the\r\nanswer dictionary. We do that by looking-up the state as a key in answer with\r\n.setdefault: it either returns  the list associated with that state (if that\r\nstate is already a key in the answer dictionary) or it puts the state in as a\r\nkey in answer and associates it with empty list and returns that list; then it\r\nappends the person to the list it found or created.\r\n\r\nSo in the outer loop, when k = 'rich' k_vals = ['IL','PA','CA','WA','PA','CA'];\r\nin the inner loop v is bound to each of these states. For 'IL' it puts 'IL'\r\nin answer with an empty list and appends 'rich' to this list; then it puts 'PA'\r\nin answer with an empty list and appends 'rich' to this list; then it puts 'CA'\r\nin answer with an empty list and appends 'rich' to this list; then it puts 'WA'\r\nin answer with an empty list and appends 'rich' to this list; then it finds 'PA'\r\nalready is a key in answer, so it appends 'rich' to its list ('rich' is now in\r\nthe list twice -an issue we will deal with soon); then it finds 'CA' already is\r\na key in answer, so it appends 'rich' to it list ('rich' is now in that list\r\ntwice too). The inner loop is now finished. Every state that 'rich' lived in is\r\nnow a key in the answer dictionary, and 'rich' is in the list associated with\r\neach key: sometimes twice. Now the outer loop goes to the next person and\r\nand the states that person lived in....\r\n\r\nIt would be interesting to uncomment the print(answer) call after the INNER for\r\nloop, which is executed once for every iteration of the OUTER for loop. It shows\r\nhow the answer dictionary is built, after every person is processed. We could\r\nprint this information in the inner loop, to show even more details about how\r\nthe loop was built.\r\n\r\nWhen this function finally returns answer, it is the following dictionary.\r\nNotice that the list of people who have lived in every state has names that\r\nappear more than once.\r\n\r\n  AZ -> ['alex']\r\n  CA -> ['alex', 'rich', 'rich', 'ellen', 'ellen', 'mark', 'mark']\r\n  IL -> ['rich']\r\n  IN -> ['mark']\r\n  NY -> ['alex', 'david']\r\n  OR -> ['patty', 'ellen']\r\n  PA -> ['alex', 'rich', 'rich', 'patty', 'david', 'ellen', 'mark']\r\n  RI -> ['david']\r\n  WA -> ['alex', 'rich', 'patty', 'david', 'ellen', 'mark']\r\n\r\nSo, how can we fix this problem? Well, before we append a name into a list, we\r\nshould check to see whether or not it is there: if it is there, do nothing; if\r\nit is not there, append. Here is the updated code, in the reverse_disctinct\r\nfunction. This is similar to how we avoided duplicate line numbers in the\r\nconcordance function.\r\n\r\ndef reverse_distinct(adict):\r\n    answer = {}\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            if v not in answer:\r\n                answer[v] = []\r\n            where = answer[v]\r\n            #code above can be replaced by: where = answer.setdefault(v,[])\r\n            if k not in where:\r\n                where.append(k)\r\n        #print(answer)  # uncomment this print to see answer being built\r\n\r\n    return answer\r\n\r\nNotice that everything is the same, except the body of the inner loop, which\r\nbecomes the following.\r\n\r\n     if v not in answer:\r\n         answer[v] = []\r\n     where = answer[v]\r\n     #code above can be replaced by: where = answer.setdefault(v,[])\r\n     if k not in where:\r\n         answer.append(k)\r\n\r\nAgain, this need to add the person into the list associated with a state, but\r\nnot if the person is already in that list.\r\n\r\nFirst, where computes the list for the state: the list associated with the state\r\nif it is already in the answer dictionary; an empty list that becomes associated\r\nwith the state if it is not already in the answer dictionary. Then the if\r\nstatements checks whether the name is in the list, and if not it appends the\r\nname to the list associated with the state (computed and bound to where above).\r\n\r\nWhen this function finally returns answer, it is the following dictionary.\r\nNotice that the list of people who have lived in every state has each name\r\ndistinct: none appears more than once.\r\n\r\n  AZ -> ['alex']\r\n  CA -> ['alex', 'rich', 'ellen', 'mark']\r\n  IL -> ['rich']\r\n  IN -> ['mark']\r\n  NY -> ['alex', 'david']\r\n  OR -> ['patty', 'ellen']\r\n  PA -> ['alex', 'rich', 'patty', 'david', 'ellen', 'mark']\r\n  RI -> ['david']\r\n  WA -> ['alex', 'rich', 'patty', 'david', 'ellen', 'mark']\r\n\r\nIn reality, what we want is to associate each key with a set, which by its\r\ndefintion has no duplicates. That would simplify our code. We will discuss sets\r\nin the next lecture and revisit the reverse functions.\r\n\r\nFinally, the following code sorts each list of names associated with a state\r\nbefore returning the dictionary.\r\n\r\n\r\ndef reverse_distinct(adict):\r\n    answer = {}\r\n    for k,k_vals in adict.items():\r\n        for v in k_vals:\r\n            if v not in answer:\r\n                answer[v] = []\r\n            where = answer[v]\r\n            #code above can be replaced by: where = answer.setdefault(v,[])\r\n            if k not in where:\r\n                where.append(k)\r\n        #print(answer)  # uncomment this print to see answer being built\r\n\r\n    for v in answer.values():    # examine every value/list in the dictionary\r\n        v.sort()\t\t  # and sort it (mutate it)\r\n    return answer\r\n\r\nThe result printed with print_dict would be\r\n\r\nAZ -> ['alex']\r\nCA -> ['alex', 'ellen', 'mark', 'rich']\r\nIL -> ['rich']\r\nIN -> ['mark']\r\nNY -> ['alex', 'david']\r\nOR -> ['ellen', 'patty']\r\nPA -> ['alex', 'david', 'ellen', 'mark', 'patty', 'rich']\r\nRI -> ['david']\r\nWA -> ['alex', 'david', 'ellen', 'mark', 'patty', 'rich']\r\n\r\nNow the lines (key/value pairs) are sorted by state and the lists are sorted\r\nby names.\r\n\r\n\r\n", "encoding": "ascii"}