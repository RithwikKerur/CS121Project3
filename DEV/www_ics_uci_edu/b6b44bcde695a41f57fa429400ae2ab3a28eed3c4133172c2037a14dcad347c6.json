{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_7.html", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Reference Guide</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Reference Guide\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Reference Guide\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC100\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_6.html#SEC85\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_8.html#SEC141\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> A. Reference Guide </H1>\n<!--docid::SEC100::-->\n<P>\n\nThis chapter is a reference for the Pintos code.  The reference guide\ndoes not cover all of the code in Pintos, but it does cover those\npieces that students most often find troublesome.  You may find that\nyou want to read each part of the reference guide as you work on the\nproject where it becomes important.\n</P>\n<P>\n\nWe recommend using &quot;tags&quot; to follow along with references to function\nand variable names (see section <A HREF=\"pintos_12.html#SEC169\">F.1 Tags</A>).\n</P>\n<P>\n\n<A NAME=\"Pintos Loading\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC101\"></A>\n<H2> A.1 Loading </H2>\n<!--docid::SEC101::-->\n<P>\n\nThis section covers the Pintos loader and basic kernel\ninitialization.\n</P>\n<P>\n\n<A NAME=\"Pintos Loader\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC102\"></A>\n<H3> A.1.1 The Loader </H3>\n<!--docid::SEC102::-->\n<P>\n\nThe first part of Pintos that runs is the loader, in\n<Q><TT>threads/loader.S</TT></Q>.  The PC BIOS loads the loader into memory.\nThe loader, in turn, is responsible for finding the kernel on disk,\nloading it into memory, and then jumping to its start.  It's\nnot important to understand exactly how the loader works, but if\nyou're interested, read on.  You should probably read along with the\nloader's source.  You should also understand the basics of the\n80<VAR>x</VAR>86 architecture as described by chapter 3, &quot;Basic Execution\nEnvironment,&quot; of [ <A HREF=\"pintos_14.html#IA32-v1\">IA32-v1</A>].\n</P>\n<P>\n\nThe PC BIOS loads the loader from the first sector of the first hard\ndisk, called the <EM>master boot record</EM> (MBR).  PC conventions\nreserve 64 bytes of the MBR for the partition table, and Pintos uses\nabout 128 additional bytes for kernel command-line arguments.  This\nleaves a little over 300 bytes for the loader's own code.  This is a\nsevere restriction that means, practically speaking, the loader must\nbe written in assembly language.\n</P>\n<P>\n\nThe Pintos loader and kernel don't have to be on the same disk, nor\ndoes is the kernel required to be in any particular location on a\ngiven disk.  The loader's first job, then, is to find the kernel by\nreading the partition table on each hard disk, looking for a bootable\npartition of the type used for a Pintos kernel.\n</P>\n<P>\n\n<A NAME=\"Low-Level Kernel Initialization\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC103\"></A>\n<H3> A.1.2 Low-Level Kernel Initialization </H3>\n<!--docid::SEC103::-->\n<P>\n\nThe loader's last action is to transfer control to the kernel's entry\npoint, which is <CODE>start()</CODE> in <Q><TT>threads/start.S</TT></Q>.  The job of\nthis code is to switch the CPU from legacy 16-bit &quot;real mode&quot; into\nthe 32-bit &quot;protected mode&quot; used by all modern 80<VAR>x</VAR>86 operating\nsystems.\n</P>\n<P>\n\nThe startup code's first task is actually to obtain the machine's\nmemory size, by asking the BIOS for the PC's memory size.  The\nsimplest BIOS function to do this can only detect up to 64 MB of RAM,\nso that's the practical limit that Pintos can support.  The function\nstores the memory size, in pages, in global variable\n<CODE>init_ram_pages</CODE>.\n</P>\n<P>\n\nThe first part of CPU initialization is to enable the A20 line, that\nis, the CPU's address line numbered 20.  For historical reasons, PCs\nboot with this address line fixed at 0, which means that attempts to\naccess memory beyond the first 1 MB (2 raised to the 20th power) will\nfail.  Pintos wants to access more memory than this, so we have to\nenable it.\n</P>\n<P>\n\nNext, the loader creates a basic page table.  This page table maps\nthe 64 MB at the base of virtual memory (starting at virtual address\n0) directly to the identical physical addresses.  It also maps the\nsame physical memory starting at virtual address\n<CODE>LOADER_PHYS_BASE</CODE>, which defaults to <TT>0xc0000000</TT> (3 GB).  The\nPintos kernel only wants the latter mapping, but there's a\nchicken-and-egg problem if we don't include the former: our current\nvirtual address is roughly <TT>0x20000</TT>, the location where the loader\nput us, and we can't jump to <TT>0xc0020000</TT> until we turn on the\npage table, but if we turn on the page table without jumping there,\nthen we've just pulled the rug out from under ourselves.\n</P>\n<P>\n\nAfter the page table is initialized, we load the CPU's control\nregisters to turn on protected mode and paging, and set up the segment\nregisters.  We aren't yet equipped to handle interrupts in protected\nmode, so we disable interrupts.  The final step is to call <CODE>main()</CODE>.\n</P>\n<P>\n\n<A NAME=\"High-Level Kernel Initialization\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC104\"></A>\n<H3> A.1.3 High-Level Kernel Initialization </H3>\n<!--docid::SEC104::-->\n<P>\n\nThe kernel proper starts with the <CODE>main()</CODE> function.  The\n<CODE>main()</CODE> function is written in C, as will be most of the code we\nencounter in Pintos from here on out.\n</P>\n<P>\n\nWhen <CODE>main()</CODE> starts, the system is in a pretty raw state.  We're\nin 32-bit protected mode with paging enabled, but hardly anything else is\nready.  Thus, the <CODE>main()</CODE> function consists primarily of calls\ninto other Pintos modules' initialization functions.\nThese are usually named <CODE><VAR>module</VAR>_init()</CODE>, where\n<VAR>module</VAR> is the module's name, <Q><TT><VAR>module</VAR>.c</TT></Q> is the\nmodule's source code, and <Q><TT><VAR>module</VAR>.h</TT></Q> is the module's\nheader.\n</P>\n<P>\n\nThe first step in <CODE>main()</CODE> is to call <CODE>bss_init()</CODE>, which clears\nout the kernel's &quot;BSS&quot;, which is the traditional name for a\nsegment that should be initialized to all zeros.  In most C\nimplementations, whenever you\ndeclare a variable outside a function without providing an\ninitializer, that variable goes into the BSS.  Because it's all zeros, the\nBSS isn't stored in the image that the loader brought into memory.  We\njust use <CODE>memset()</CODE> to zero it out.\n</P>\n<P>\n\nNext, <CODE>main()</CODE> calls <CODE>read_command_line()</CODE> to break the kernel command\nline into arguments, then <CODE>parse_options()</CODE> to read any options at\nthe beginning of the command line.  (Actions specified on the\ncommand line execute later.)\n</P>\n<P>\n\n<CODE>thread_init()</CODE> initializes the thread system.  We will defer full\ndiscussion to our discussion of Pintos threads below.  It is called so\nearly in initialization because a valid thread structure is a\nprerequisite for acquiring a lock, and lock acquisition in turn is\nimportant to other Pintos subsystems.  Then we initialize the console\nand print a startup message to the console.\n</P>\n<P>\n\nThe next block of functions we call initializes the kernel's memory\nsystem.  <CODE>palloc_init()</CODE> sets up the kernel page allocator, which\ndoles out memory one or more pages at a time (see section <A HREF=\"pintos_7.html#SEC122\">A.5.1 Page Allocator</A>).\n<CODE>malloc_init()</CODE> sets\nup the allocator that handles allocations of arbitrary-size blocks of\nmemory (see section <A HREF=\"pintos_7.html#SEC123\">A.5.2 Block Allocator</A>).\n<CODE>paging_init()</CODE> sets up a page table for the kernel (see section <A HREF=\"pintos_7.html#SEC125\">A.7 Page Table</A>).\n</P>\n<P>\n\nIn projects 2 and later, <CODE>main()</CODE> also calls <CODE>tss_init()</CODE> and\n<CODE>gdt_init()</CODE>.\n</P>\n<P>\n\nThe next set of calls initializes the interrupt system.\n<CODE>intr_init()</CODE> sets up the CPU's <EM>interrupt descriptor table</EM>\n(IDT) to ready it for interrupt handling (see section <A HREF=\"pintos_7.html#SEC118\">A.4.1 Interrupt Infrastructure</A>), then <CODE>timer_init()</CODE> and <CODE>kbd_init()</CODE> prepare for\nhandling timer interrupts and keyboard interrupts, respectively. \n<CODE>input_init()</CODE> sets up to merge serial and keyboard input into one\nstream.  In\nprojects 2 and later, we also prepare to handle interrupts caused by\nuser programs using <CODE>exception_init()</CODE> and <CODE>syscall_init()</CODE>.\n</P>\n<P>\n\nNow that interrupts are set up, we can start the scheduler\nwith <CODE>thread_start()</CODE>, which creates the idle thread and enables\ninterrupts.\nWith interrupts enabled, interrupt-driven serial port I/O becomes\npossible, so we use\n<CODE>serial_init_queue()</CODE> to switch to that mode.  Finally,\n<CODE>timer_calibrate()</CODE> calibrates the timer for accurate short delays.\n</P>\n<P>\n\nIf the file system is compiled in, as it will starting in project 2, we\ninitialize the IDE disks with <CODE>ide_init()</CODE>, then the\nfile system with <CODE>filesys_init()</CODE>.\n</P>\n<P>\n\nBoot is complete, so we print a message.\n</P>\n<P>\n\nFunction <CODE>run_actions()</CODE> now parses and executes actions specified on\nthe kernel command line, such as <CODE>run</CODE> to run a test (in project\n1) or a user program (in later projects).\n</P>\n<P>\n\nFinally, if <Q><SAMP>-q</SAMP></Q> was specified on the kernel command line, we\ncall <CODE>shutdown_power_off()</CODE> to terminate the machine simulator.  Otherwise,\n<CODE>main()</CODE> calls <CODE>thread_exit()</CODE>, which allows any other running\nthreads to continue running.\n</P>\n<P>\n\n<A NAME=\"Physical Memory Map\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC105\"></A>\n<H3> A.1.4 Physical Memory Map </H3>\n<!--docid::SEC105::-->\n<P>\n\n</P>\n<TABLE>\n@headitem Memory Range\n</TD><TD> Owner\n</TD><TD> Contents\n\n<TR><TD><TT>00000000</TT>--<TT>000003ff</TT> </TD><TD> CPU </TD><TD> Real mode interrupt table.</TD>\n</TR>\n<TR><TD><TT>00000400</TT>--<TT>000005ff</TT> </TD><TD> BIOS </TD><TD> Miscellaneous data area.</TD>\n</TR>\n<TR><TD><TT>00000600</TT>--<TT>00007bff</TT> </TD><TD> -- </TD><TD> ---</TD>\n</TR>\n<TR><TD><TT>00007c00</TT>--<TT>00007dff</TT> </TD><TD> Pintos </TD><TD> Loader.</TD>\n</TR>\n<TR><TD><TT>0000e000</TT>--<TT>0000efff</TT> </TD><TD> Pintos</TD>\n</TD><TD> Stack for loader; kernel stack and <CODE>struct thread</CODE> for initial\nkernel thread.\n</TR>\n<TR><TD><TT>0000f000</TT>--<TT>0000ffff</TT> </TD><TD> Pintos</TD>\n</TD><TD> Page directory for startup code.\n</TR>\n<TR><TD><TT>00010000</TT>--<TT>00020000</TT> </TD><TD> Pintos</TD>\n</TD><TD> Page tables for startup code.\n</TR>\n<TR><TD><TT>00020000</TT>--<TT>0009ffff</TT> </TD><TD> Pintos</TD>\n</TD><TD> Kernel code, data, and uninitialized data segments.\n</TR>\n<TR><TD><TT>000a0000</TT>--<TT>000bffff</TT> </TD><TD> Video </TD><TD> VGA display memory.</TD>\n</TR>\n<TR><TD><TT>000c0000</TT>--<TT>000effff</TT> </TD><TD> Hardware</TD>\n</TD><TD> Reserved for expansion card RAM and ROM.\n</TR>\n<TR><TD><TT>000f0000</TT>--<TT>000fffff</TT> </TD><TD> BIOS </TD><TD> ROM BIOS.</TD>\n</TR>\n<TR><TD><TT>00100000</TT>--<TT>03ffffff</TT> </TD><TD> Pintos </TD><TD> Dynamic memory allocation.</TD>\n</TR></TABLE>\n<P>\n\n<A NAME=\"Threads\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC106\"></A>\n<H2> A.2 Threads </H2>\n<!--docid::SEC106::-->\n<P>\n\n<A NAME=\"struct thread\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC107\"></A>\n<H3> A.2.1 <CODE>struct thread</CODE> </H3>\n<!--docid::SEC107::-->\n<P>\n\nThe main Pintos data structure for threads is <CODE>struct thread</CODE>,\ndeclared in <Q><TT>threads/thread.h</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX24\"></A>\n</P>\n<DL>\n<DT><U>Structure:</U> <B>struct thread</B>\n<DD>Represents a thread or a user process.  In the projects, you will have\nto add your own members to <CODE>struct thread</CODE>.  You may also change or\ndelete the definitions of existing members.\n<P>\n\nEvery <CODE>struct thread</CODE> occupies the beginning of its own page of\nmemory.  The rest of the page is used for the thread's stack, which\ngrows downward from the end of the page.  It looks like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>                  4 kB +---------------------------------+\n                       |          kernel stack           |\n                       |                |                |\n                       |                |                |\n                       |                V                |\n                       |         grows downward          |\n                       |                                 |\n                       |                                 |\n                       |                                 |\n                       |                                 |\n                       |                                 |\n                       |                                 |\n                       |                                 |\n                       |                                 |\nsizeof (struct thread) +---------------------------------+\n                       |              magic              |\n                       |                :                |\n                       |                :                |\n                       |              status             |\n                       |               tid               |\n                  0 kB +---------------------------------+\n</pre></td></tr></table><P>\n\nThis has two consequences.  First, <CODE>struct thread</CODE> must not be allowed\nto grow too big.  If it does, then there will not be enough room for the\nkernel stack.  The base <CODE>struct thread</CODE> is only a few bytes in size.  It\nprobably should stay well under 1 kB.\n</P>\n<P>\n\nSecond, kernel stacks must not be allowed to grow too large.  If a stack\noverflows, it will corrupt the thread state.  Thus, kernel functions\nshould not allocate large structures or arrays as non-static local\nvariables.  Use dynamic allocation with <CODE>malloc()</CODE> or\n<CODE>palloc_get_page()</CODE> instead (see section <A HREF=\"pintos_7.html#SEC121\">A.5 Memory Allocation</A>).\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX25\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> tid_t <B>tid</B>\n<DD>The thread's thread identifier or <EM>tid</EM>.  Every thread must have a\ntid that is unique over the entire lifetime of the kernel.  By\ndefault, <CODE>tid_t</CODE> is a <CODE>typedef</CODE> for <CODE>int</CODE> and each new\nthread receives the numerically next higher tid, starting from 1 for\nthe initial process.  You can change the type and the numbering scheme\nif you like.\n</DL>\n<P>\n\n<A NAME=\"IDX26\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> enum thread_status <B>status</B>\n<DD><A NAME=\"Thread States\"></A>\nThe thread's state, one of the following:\n<P>\n\n<A NAME=\"IDX27\"></A>\n</P>\n<DL>\n<DT><U>Thread State:</U> <B><CODE>THREAD_RUNNING</CODE></B>\n<DD>The thread is running.  Exactly one thread is running at a given time.\n<CODE>thread_current()</CODE> returns the running thread.\n</DL>\n<P>\n\n<A NAME=\"IDX28\"></A>\n</P>\n<DL>\n<DT><U>Thread State:</U> <B><CODE>THREAD_READY</CODE></B>\n<DD>The thread is ready to run, but it's not running right now.  The\nthread could be selected to run the next time the scheduler is\ninvoked.  Ready threads are kept in a doubly linked list called\n<CODE>ready_list</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX29\"></A>\n</P>\n<DL>\n<DT><U>Thread State:</U> <B><CODE>THREAD_BLOCKED</CODE></B>\n<DD>The thread is waiting for something, e.g. a lock to become\navailable, an interrupt to be invoked.  The thread won't be scheduled\nagain until it transitions to the <CODE>THREAD_READY</CODE> state with a\ncall to <CODE>thread_unblock()</CODE>.  This is most conveniently done\nindirectly, using one of the Pintos synchronization primitives that\nblock and unblock threads automatically (see section <A HREF=\"pintos_7.html#SEC110\">A.3 Synchronization</A>).\n<P>\n\nThere is no <I>a priori</I> way to tell what a blocked thread is waiting\nfor, but a backtrace can help (see section <A HREF=\"pintos_11.html#SEC159\">E.4 Backtraces</A>).\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX30\"></A>\n</P>\n<DL>\n<DT><U>Thread State:</U> <B><CODE>THREAD_DYING</CODE></B>\n<DD>The thread will be destroyed by the scheduler after switching to the\nnext thread.\n</DL>\n</DL>\n<P>\n\n<A NAME=\"IDX31\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> char <B>name[16]</B>\n<DD>The thread's name as a string, or at least the first few characters of\nit.\n</DL>\n<P>\n\n<A NAME=\"IDX32\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> uint8_t *<B>stack</B>\n<DD>Every thread has its own stack to keep track of its state.  When the\nthread is running, the CPU's stack pointer register tracks the top of\nthe stack and this member is unused.  But when the CPU switches to\nanother thread, this member saves the thread's stack pointer.  No\nother members are needed to save the thread's registers, because the\nother registers that must be saved are saved on the stack.\n<P>\n\nWhen an interrupt occurs, whether in the kernel or a user program, an\n<CODE>struct intr_frame</CODE> is pushed onto the stack.  When the interrupt occurs\nin a user program, the <CODE>struct intr_frame</CODE> is always at the very top of\nthe page.  See section <A HREF=\"pintos_7.html#SEC117\">A.4 Interrupt Handling</A>, for more information.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX33\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> int <B>priority</B>\n<DD>A thread priority, ranging from <CODE>PRI_MIN</CODE> (0) to <CODE>PRI_MAX</CODE>\n(63).  Lower numbers correspond to lower priorities, so that\npriority 0 is the lowest priority and priority 63 is the highest.\nPintos as provided ignores thread priorities, but you will implement\npriority scheduling in project 1 (see section <A HREF=\"pintos_3.html#SEC36\">3.2.3 Priority Scheduling</A>).\n</DL>\n<P>\n\n<A NAME=\"IDX34\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> <CODE>struct list_elem</CODE> <B>allelem</B>\n<DD>This &quot;list element&quot; is used to link the thread into the list of all\nthreads.  Each thread is inserted into this list when it is created\nand removed when it exits.  The <CODE>thread_foreach()</CODE> function should \nbe used to iterate over all threads.\n</DL>\n<P>\n\n<A NAME=\"IDX35\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> <CODE>struct list_elem</CODE> <B>elem</B>\n<DD>A &quot;list element&quot; used to put the thread into doubly linked lists,\neither <CODE>ready_list</CODE> (the list of threads ready to run) or a list of\nthreads waiting on a semaphore in <CODE>sema_down()</CODE>.  It can do double\nduty because a thread waiting on a semaphore is not ready, and vice\nversa.\n</DL>\n<P>\n\n<A NAME=\"IDX36\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> uint32_t *<B>pagedir</B>\n<DD>Only present in project 2 and later.  See section <A HREF=\"pintos_5.html#SEC69\">5.1.2.3 Page Tables</A>.\n</DL>\n<P>\n\n<A NAME=\"IDX37\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct thread</CODE>:</U> unsigned <B>magic</B>\n<DD>Always set to <CODE>THREAD_MAGIC</CODE>, which is just an arbitrary number defined\nin <Q><TT>threads/thread.c</TT></Q>, and used to detect stack overflow.\n<CODE>thread_current()</CODE> checks that the <CODE>magic</CODE> member of the running\nthread's <CODE>struct thread</CODE> is set to <CODE>THREAD_MAGIC</CODE>.  Stack overflow\ntends to change this value, triggering the assertion.  For greatest\nbenefit, as you add members to <CODE>struct thread</CODE>, leave <CODE>magic</CODE> at\nthe end.\n</DL>\n<P>\n\n<A NAME=\"Thread Functions\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC108\"></A>\n<H3> A.2.2 Thread Functions </H3>\n<!--docid::SEC108::-->\n<P>\n\n<Q><TT>threads/thread.c</TT></Q> implements several public functions for thread\nsupport.  Let's take a look at the most useful:\n</P>\n<P>\n\n<A NAME=\"IDX38\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_init</B> (void)\n<DD>Called by <CODE>main()</CODE> to initialize the thread system.  Its main\npurpose is to create a <CODE>struct thread</CODE> for Pintos's initial thread.\nThis is possible because the Pintos loader puts the initial\nthread's stack at the top of a page, in the same position as any other\nPintos thread.\n<P>\n\nBefore <CODE>thread_init()</CODE> runs,\n<CODE>thread_current()</CODE> will fail because the running thread's\n<CODE>magic</CODE> value is incorrect.  Lots of functions call\n<CODE>thread_current()</CODE> directly or indirectly, including\n<CODE>lock_acquire()</CODE> for locking a lock, so <CODE>thread_init()</CODE> is\ncalled early in Pintos initialization.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX39\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_start</B> (void)\n<DD>Called by <CODE>main()</CODE> to start the scheduler.  Creates the idle\nthread, that is, the thread that is scheduled when no other thread is\nready.  Then enables interrupts, which as a side effect enables the\nscheduler because the scheduler runs on return from the timer interrupt, using\n<CODE>intr_yield_on_return()</CODE> (see section <A HREF=\"pintos_7.html#SEC120\">A.4.3 External Interrupt Handling</A>).\n</DL>\n<P>\n\n<A NAME=\"IDX40\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_tick</B> (void)\n<DD>Called by the timer interrupt at each timer tick.  It keeps track of\nthread statistics and triggers the scheduler when a time slice expires.\n</DL>\n<P>\n\n<A NAME=\"IDX41\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_print_stats</B> (void)\n<DD>Called during Pintos shutdown to print thread statistics.\n</DL>\n<P>\n\n<A NAME=\"IDX42\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> tid_t <B>thread_create</B> (const char *<VAR>name</VAR>, int <VAR>priority</VAR>, thread_func *<VAR>func</VAR>, void *<VAR>aux</VAR>)\n<DD>Creates and starts a new thread named <VAR>name</VAR> with the given\n<VAR>priority</VAR>, returning the new thread's tid.  The thread executes\n<VAR>func</VAR>, passing <VAR>aux</VAR> as the function's single argument.\n<P>\n\n<CODE>thread_create()</CODE> allocates a page for the thread's\n<CODE>struct thread</CODE> and stack and initializes its members, then it sets\nup a set of fake stack frames for it (see section <A HREF=\"pintos_7.html#SEC109\">A.2.3 Thread Switching</A>).  The\nthread is initialized in the blocked state, then unblocked just before\nreturning, which allows the new thread to\nbe scheduled (see  <A HREF=\"pintos_7.html#Thread States\">Thread States</A>).\n</P>\n<P>\n\n<A NAME=\"IDX43\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>void thread_func (void *<VAR>aux</VAR>)</B>\n<DD>This is the type of the function passed to <CODE>thread_create()</CODE>, whose\n<VAR>aux</VAR> argument is passed along as the function's argument.\n</DL>\n</DL>\n<P>\n\n<A NAME=\"IDX44\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_block</B> (void)\n<DD>Transitions the running thread from the running state to the blocked\nstate (see  <A HREF=\"pintos_7.html#Thread States\">Thread States</A>).  The thread will not run again until\n<CODE>thread_unblock()</CODE> is\ncalled on it, so you'd better have some way arranged for that to happen.\nBecause <CODE>thread_block()</CODE> is so low-level, you should prefer to use\none of the synchronization primitives instead (see section <A HREF=\"pintos_7.html#SEC110\">A.3 Synchronization</A>).\n</DL>\n<P>\n\n<A NAME=\"IDX45\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_unblock</B> (struct thread *<VAR>thread</VAR>)\n<DD>Transitions <VAR>thread</VAR>, which must be in the blocked state, to the\nready state, allowing it to resume running (see  <A HREF=\"pintos_7.html#Thread States\">Thread States</A>).\nThis is called when the event that the thread is waiting for occurs,\ne.g. when the lock that \nthe thread is waiting on becomes available.\n</DL>\n<P>\n\n<A NAME=\"IDX46\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct thread *<B>thread_current</B> (void)\n<DD>Returns the running thread.\n</DL>\n<P>\n\n<A NAME=\"IDX47\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> tid_t <B>thread_tid</B> (void)\n<DD>Returns the running thread's thread id.  Equivalent to\n<CODE>thread_current ()-&gt;tid</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX48\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> const char *<B>thread_name</B> (void)\n<DD>Returns the running thread's name.  Equivalent to <CODE>thread_current\n()-&gt;name</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX49\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_exit</B> (void) <CODE>NO_RETURN</CODE>\n<DD>Causes the current thread to exit.  Never returns, hence\n<CODE>NO_RETURN</CODE> (see section <A HREF=\"pintos_11.html#SEC158\">E.3 Function and Parameter Attributes</A>).\n</DL>\n<P>\n\n<A NAME=\"IDX50\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_yield</B> (void)\n<DD>Yields the CPU to the scheduler, which picks a new thread to run.  The\nnew thread might be the current thread, so you can't depend on this\nfunction to keep this thread from running for any particular length of\ntime.\n</DL>\n<P>\n\n<A NAME=\"IDX51\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>thread_foreach</B> (thread_action_func *<VAR>action</VAR>, void *<VAR>aux</VAR>)\n<DD>Iterates over all threads <VAR>t</VAR> and invokes <CODE>action(t, aux)</CODE> on each.\n<VAR>action</VAR> must refer to a function that matches the signature \ngiven by <CODE>thread_action_func()</CODE>:\n<P>\n\n<A NAME=\"IDX52\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>void thread_action_func (struct thread *<VAR>thread</VAR>, void *<VAR>aux</VAR>)</B>\n<DD>Performs some action on a thread, given <VAR>aux</VAR>.\n</DL>\n</DL>\n<P>\n\n<A NAME=\"IDX53\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> int <B>thread_get_priority</B> (void)\n<DD><A NAME=\"IDX54\"></A>\n<DT><U>Function:</U> void <B>thread_set_priority</B> (int <VAR>new_priority</VAR>)\n<DD>Stub to set and get thread priority.  See section <A HREF=\"pintos_3.html#SEC36\">3.2.3 Priority Scheduling</A>.\n</DL>\n<P>\n\n<A NAME=\"IDX55\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> int <B>thread_get_nice</B> (void)\n<DD><A NAME=\"IDX56\"></A>\n<DT><U>Function:</U> void <B>thread_set_nice</B> (int <VAR>new_nice</VAR>)\n<DD><A NAME=\"IDX57\"></A>\n<DT><U>Function:</U> int <B>thread_get_recent_cpu</B> (void)\n<DD><A NAME=\"IDX58\"></A>\n<DT><U>Function:</U> int <B>thread_get_load_avg</B> (void)\n<DD>Stubs for the advanced scheduler.  See section <A HREF=\"pintos_8.html#SEC141\">B. 4.4<ACRONYM>BSD</ACRONYM> Scheduler</A>.\n</DL>\n<P>\n\n<A NAME=\"Thread Switching\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC109\"></A>\n<H3> A.2.3 Thread Switching </H3>\n<!--docid::SEC109::-->\n<P>\n\n<CODE>schedule()</CODE> is responsible for switching threads.  It\nis internal to <Q><TT>threads/thread.c</TT></Q> and called only by the three\npublic thread functions that need to switch threads:\n<CODE>thread_block()</CODE>, <CODE>thread_exit()</CODE>, and <CODE>thread_yield()</CODE>.\nBefore any of these functions call <CODE>schedule()</CODE>, they disable\ninterrupts (or ensure that they are already disabled) and then change\nthe running thread's state to something other than running.\n</P>\n<P>\n\n<CODE>schedule()</CODE> is short but tricky.  It records the\ncurrent thread in local variable <VAR>cur</VAR>, determines the next thread\nto run as local variable <VAR>next</VAR> (by calling\n<CODE>next_thread_to_run()</CODE>), and then calls <CODE>switch_threads()</CODE> to do\nthe actual thread switch.  The thread we switched to was also running\ninside <CODE>switch_threads()</CODE>, as are all the threads not currently\nrunning, so the new thread now returns out of\n<CODE>switch_threads()</CODE>, returning the previously running thread.\n</P>\n<P>\n\n<CODE>switch_threads()</CODE> is an assembly language routine in\n<Q><TT>threads/switch.S</TT></Q>.  It saves registers on the stack, saves the\nCPU's current stack pointer in the current <CODE>struct thread</CODE>'s <CODE>stack</CODE>\nmember, restores the new thread's <CODE>stack</CODE> into the CPU's stack\npointer, restores registers from the stack, and returns.\n</P>\n<P>\n\nThe rest of the scheduler is implemented in <CODE>thread_schedule_tail()</CODE>.  It\nmarks the new thread as running.  If the thread we just switched from\nis in the dying state, then it also frees the page that contained the\ndying thread's <CODE>struct thread</CODE> and stack.  These couldn't be freed\nprior to the thread switch because the switch needed to use it.\n</P>\n<P>\n\nRunning a thread for the first time is a special case.  When\n<CODE>thread_create()</CODE> creates a new thread, it goes through a fair\namount of trouble to get it started properly.  In particular, the new\nthread hasn't started running yet, so there's no way for it to be\nrunning inside <CODE>switch_threads()</CODE> as the scheduler expects.  To\nsolve the problem, <CODE>thread_create()</CODE> creates some fake stack frames\nin the new thread's stack:\n</P>\n<P>\n\n<UL>\n<LI>\nThe topmost fake stack frame is for <CODE>switch_threads()</CODE>, represented\nby <CODE>struct switch_threads_frame</CODE>.  The important part of this frame is\nits <CODE>eip</CODE> member, the return address.  We point <CODE>eip</CODE> to\n<CODE>switch_entry()</CODE>, indicating it to be the function that called\n<CODE>switch_entry()</CODE>.\n<P>\n\n</P>\n<LI>\nThe next fake stack frame is for <CODE>switch_entry()</CODE>, an assembly\nlanguage routine in <Q><TT>threads/switch.S</TT></Q> that adjusts the stack\npointer,<A NAME=\"DOCF4\" HREF=\"pintos_fot.html#FOOT4\">(4)</A>\ncalls <CODE>thread_schedule_tail()</CODE> (this special case is why\n<CODE>thread_schedule_tail()</CODE> is separate from <CODE>schedule()</CODE>), and returns.\nWe fill in its stack frame so that it returns into\n<CODE>kernel_thread()</CODE>, a function in <Q><TT>threads/thread.c</TT></Q>.\n<P>\n\n</P>\n<LI>\nThe final stack frame is for <CODE>kernel_thread()</CODE>, which enables\ninterrupts and calls the thread's function (the function passed to\n<CODE>thread_create()</CODE>).  If the thread's function returns, it calls\n<CODE>thread_exit()</CODE> to terminate the thread.\n</UL>\n<P>\n\n<A NAME=\"Synchronization\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC110\"></A>\n<H2> A.3 Synchronization </H2>\n<!--docid::SEC110::-->\n<P>\n\nIf sharing of resources between threads is not handled in a careful,\ncontrolled fashion, the result is usually a big mess.\nThis is especially the case in operating system kernels, where\nfaulty sharing can crash the entire machine.  Pintos provides several\nsynchronization primitives to help out.\n</P>\n<P>\n\n<A NAME=\"Disabling Interrupts\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC111\"></A>\n<H3> A.3.1 Disabling Interrupts </H3>\n<!--docid::SEC111::-->\n<P>\n\nThe crudest way to do synchronization is to disable interrupts, that\nis, to temporarily prevent the CPU from responding to interrupts.  If\ninterrupts are off, no other thread will preempt the running thread,\nbecause thread preemption is driven by the timer interrupt.  If\ninterrupts are on, as they normally are, then the running thread may\nbe preempted by another at any time, whether between two C statements\nor even within the execution of one.\n</P>\n<P>\n\nIncidentally, this means that Pintos is a &quot;preemptible kernel,&quot; that\nis, kernel threads can be preempted at any time.  Traditional Unix\nsystems are &quot;nonpreemptible,&quot; that is, kernel threads can only be\npreempted at points where they explicitly call into the scheduler.\n(User programs can be preempted at any time in both models.)  As you\nmight imagine, preemptible kernels require more explicit\nsynchronization.\n</P>\n<P>\n\nYou should have little need to set the interrupt state directly.  Most\nof the time you should use the other synchronization primitives\ndescribed in the following sections.  The main reason to disable\ninterrupts is to synchronize kernel threads with external interrupt\nhandlers, which cannot sleep and thus cannot use most other forms of\nsynchronization (see section <A HREF=\"pintos_7.html#SEC120\">A.4.3 External Interrupt Handling</A>).\n</P>\n<P>\n\nSome external interrupts cannot be postponed, even by disabling\ninterrupts.  These interrupts, called <EM>non-maskable interrupts</EM>\n(NMIs), are supposed to be used only in emergencies, e.g. when the\ncomputer is on fire.  Pintos does not handle non-maskable interrupts.\n</P>\n<P>\n\nTypes and functions for disabling and enabling interrupts are in\n<Q><TT>threads/interrupt.h</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX59\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>enum intr_level</B>\n<DD>One of <CODE>INTR_OFF</CODE> or <CODE>INTR_ON</CODE>, denoting that interrupts are\ndisabled or enabled, respectively.\n</DL>\n<P>\n\n<A NAME=\"IDX60\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> enum intr_level <B>intr_get_level</B> (void)\n<DD>Returns the current interrupt state.\n</DL>\n<P>\n\n<A NAME=\"IDX61\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> enum intr_level <B>intr_set_level</B> (enum intr_level <VAR>level</VAR>)\n<DD>Turns interrupts on or off according to <VAR>level</VAR>.  Returns the\nprevious interrupt state.\n</DL>\n<P>\n\n<A NAME=\"IDX62\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> enum intr_level <B>intr_enable</B> (void)\n<DD>Turns interrupts on.  Returns the previous interrupt state.\n</DL>\n<P>\n\n<A NAME=\"IDX63\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> enum intr_level <B>intr_disable</B> (void)\n<DD>Turns interrupts off.  Returns the previous interrupt state.\n</DL>\n<P>\n\n<A NAME=\"Semaphores\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC112\"></A>\n<H3> A.3.2 Semaphores </H3>\n<!--docid::SEC112::-->\n<P>\n\nA <EM>semaphore</EM> is a nonnegative integer together with two operators\nthat manipulate it atomically, which are:\n</P>\n<P>\n\n<UL>\n<LI>\n&quot;Down&quot; or &quot;P&quot;: wait for the value to become positive, then\ndecrement it.\n<P>\n\n</P>\n<LI>\n&quot;Up&quot; or &quot;V&quot;: increment the value (and wake up one waiting thread,\nif any).\n</UL>\n<P>\n\nA semaphore initialized to 0 may be used to wait for an event\nthat will happen exactly once.  For example, suppose thread <VAR>A</VAR>\nstarts another thread <VAR>B</VAR> and wants to wait for <VAR>B</VAR> to signal\nthat some activity is complete.  <VAR>A</VAR> can create a semaphore\ninitialized to 0, pass it to <VAR>B</VAR> as it starts it, and then\n&quot;down&quot; the semaphore.  When <VAR>B</VAR> finishes its activity, it\n&quot;ups&quot; the semaphore.  This works regardless of whether <VAR>A</VAR>\n&quot;downs&quot; the semaphore or <VAR>B</VAR> &quot;ups&quot; it first.\n</P>\n<P>\n\nA semaphore initialized to 1 is typically used for controlling access\nto a resource.  Before a block of code starts using the resource, it\n&quot;downs&quot; the semaphore, then after it is done with the resource it\n&quot;ups&quot; the resource.  In such a case a lock, described below, may be\nmore appropriate.\n</P>\n<P>\n\nSemaphores can also be initialized to values larger than 1.  These are\nrarely used.\n</P>\n<P>\n\nSemaphores were invented by Edsger Dijkstra and first used in the THE\noperating system ([ <A HREF=\"pintos_14.html#Dijkstra\">Dijkstra</A>]).\n</P>\n<P>\n\nPintos' semaphore type and operations are declared in\n<Q><TT>threads/synch.h</TT></Q>.  \n</P>\n<P>\n\n<A NAME=\"IDX64\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct semaphore</B>\n<DD>Represents a semaphore.\n</DL>\n<P>\n\n<A NAME=\"IDX65\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>sema_init</B> (struct semaphore *<VAR>sema</VAR>, unsigned <VAR>value</VAR>)\n<DD>Initializes <VAR>sema</VAR> as a new semaphore with the given initial\n<VAR>value</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX66\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>sema_down</B> (struct semaphore *<VAR>sema</VAR>)\n<DD>Executes the &quot;down&quot; or &quot;P&quot; operation on <VAR>sema</VAR>, waiting for\nits value to become positive and then decrementing it by one.\n</DL>\n<P>\n\n<A NAME=\"IDX67\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>sema_try_down</B> (struct semaphore *<VAR>sema</VAR>)\n<DD>Tries to execute the &quot;down&quot; or &quot;P&quot; operation on <VAR>sema</VAR>,\nwithout waiting.  Returns true if <VAR>sema</VAR>\nwas successfully decremented, or false if it was already\nzero and thus could not be decremented without waiting.  Calling this\nfunction in a\ntight loop wastes CPU time, so use <CODE>sema_down()</CODE> or find a\ndifferent approach instead.\n</DL>\n<P>\n\n<A NAME=\"IDX68\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>sema_up</B> (struct semaphore *<VAR>sema</VAR>)\n<DD>Executes the &quot;up&quot; or &quot;V&quot; operation on <VAR>sema</VAR>,\nincrementing its value.  If any threads are waiting on\n<VAR>sema</VAR>, wakes one of them up.\n<P>\n\nUnlike most synchronization primitives, <CODE>sema_up()</CODE> may be called\ninside an external interrupt handler (see section <A HREF=\"pintos_7.html#SEC120\">A.4.3 External Interrupt Handling</A>).\n</P>\n</DL>\n<P>\n\nSemaphores are internally built out of disabling interrupt\n(see section <A HREF=\"pintos_7.html#SEC111\">A.3.1 Disabling Interrupts</A>) and thread blocking and unblocking\n(<CODE>thread_block()</CODE> and <CODE>thread_unblock()</CODE>).  Each semaphore maintains\na list of waiting threads, using the linked list\nimplementation in <Q><TT>lib/kernel/list.c</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"Locks\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC113\"></A>\n<H3> A.3.3 Locks </H3>\n<!--docid::SEC113::-->\n<P>\n\nA <EM>lock</EM> is like a semaphore with an initial value of 1\n(see section <A HREF=\"pintos_7.html#SEC112\">A.3.2 Semaphores</A>).  A lock's equivalent of &quot;up&quot; is called\n&quot;release&quot;, and the &quot;down&quot; operation is called &quot;acquire&quot;.\n</P>\n<P>\n\nCompared to a semaphore, a lock has one added restriction: only the\nthread that acquires a lock, called the lock's &quot;owner&quot;, is allowed to\nrelease it.  If this restriction is a problem, it's a good sign that a\nsemaphore should be used, instead of a lock.\n</P>\n<P>\n\nLocks in Pintos are not &quot;recursive,&quot; that is, it is an error for the\nthread currently holding a lock to try to acquire that lock.\n</P>\n<P>\n\nLock types and functions are declared in <Q><TT>threads/synch.h</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX69\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct lock</B>\n<DD>Represents a lock.\n</DL>\n<P>\n\n<A NAME=\"IDX70\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>lock_init</B> (struct lock *<VAR>lock</VAR>)\n<DD>Initializes <VAR>lock</VAR> as a new lock.\nThe lock is not initially owned by any thread.\n</DL>\n<P>\n\n<A NAME=\"IDX71\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>lock_acquire</B> (struct lock *<VAR>lock</VAR>)\n<DD>Acquires <VAR>lock</VAR> for the current thread, first waiting for\nany current owner to release it if necessary.\n</DL>\n<P>\n\n<A NAME=\"IDX72\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>lock_try_acquire</B> (struct lock *<VAR>lock</VAR>)\n<DD>Tries to acquire <VAR>lock</VAR> for use by the current thread, without\nwaiting.  Returns true if successful, false if the lock is already\nowned.  Calling this function in a tight loop is a bad idea because it\nwastes CPU time, so use <CODE>lock_acquire()</CODE> instead.\n</DL>\n<P>\n\n<A NAME=\"IDX73\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>lock_release</B> (struct lock *<VAR>lock</VAR>)\n<DD>Releases <VAR>lock</VAR>, which the current thread must own.\n</DL>\n<P>\n\n<A NAME=\"IDX74\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>lock_held_by_current_thread</B> (const struct lock *<VAR>lock</VAR>)\n<DD>Returns true if the running thread owns <VAR>lock</VAR>,\nfalse otherwise.\nThere is no function to test whether an arbitrary thread owns a lock,\nbecause the answer could change before the caller could act on it.\n</DL>\n<P>\n\n<A NAME=\"Monitors\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC114\"></A>\n<H3> A.3.4 Monitors </H3>\n<!--docid::SEC114::-->\n<P>\n\nA <EM>monitor</EM> is a higher-level form of synchronization than a\nsemaphore or a lock.  A monitor consists of data being synchronized,\nplus a lock, called the <EM>monitor lock</EM>, and one or more\n<EM>condition variables</EM>.  Before it accesses the protected data, a\nthread first acquires the monitor lock.  It is then said to be &quot;in the\nmonitor&quot;.  While in the monitor, the thread has control over all the\nprotected data, which it may freely examine or modify.  When access to\nthe protected data is complete, it releases the monitor lock.\n</P>\n<P>\n\nCondition variables allow code in the monitor to wait for a condition to\nbecome true.  Each condition variable is associated with an abstract\ncondition, e.g. &quot;some data has arrived for processing&quot; or &quot;over 10\nseconds has passed since the user's last keystroke&quot;.  When code in the\nmonitor needs to wait for a condition to become true, it &quot;waits&quot; on\nthe associated condition variable, which releases the lock and waits for\nthe condition to be signaled.  If, on the other hand, it has caused one\nof these conditions to become true, it &quot;signals&quot; the condition to wake\nup one waiter, or &quot;broadcasts&quot; the condition to wake all of them.\n</P>\n<P>\n\nThe theoretical framework for monitors was laid out by C. A. R.\nHoare ([ <A HREF=\"pintos_14.html#Hoare\">Hoare</A>]).  Their practical usage was later elaborated in a\npaper on the Mesa operating system ([ <A HREF=\"pintos_14.html#Lampson\">Lampson</A>]).\n</P>\n<P>\n\nCondition variable types and functions are declared in\n<Q><TT>threads/synch.h</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"IDX75\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct condition</B>\n<DD>Represents a condition variable.\n</DL>\n<P>\n\n<A NAME=\"IDX76\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>cond_init</B> (struct condition *<VAR>cond</VAR>)\n<DD>Initializes <VAR>cond</VAR> as a new condition variable.\n</DL>\n<P>\n\n<A NAME=\"IDX77\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>cond_wait</B> (struct condition *<VAR>cond</VAR>, struct lock *<VAR>lock</VAR>)\n<DD>Atomically releases <VAR>lock</VAR> (the monitor lock) and waits for\n<VAR>cond</VAR> to be signaled by some other piece of code.  After\n<VAR>cond</VAR> is signaled, reacquires <VAR>lock</VAR> before returning.\n<VAR>lock</VAR> must be held before calling this function.\n<P>\n\nSending a signal and waking up from a wait are not an atomic operation.\nThus, typically <CODE>cond_wait()</CODE>'s caller must recheck the condition\nafter the wait completes and, if necessary, wait again.  See the next\nsection for an example.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX78\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>cond_signal</B> (struct condition *<VAR>cond</VAR>, struct lock *<VAR>lock</VAR>)\n<DD>If any threads are waiting on <VAR>cond</VAR> (protected by monitor lock\n<VAR>lock</VAR>), then this function wakes up one of them.  If no threads are\nwaiting, returns without performing any action.\n<VAR>lock</VAR> must be held before calling this function.\n</DL>\n<P>\n\n<A NAME=\"IDX79\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>cond_broadcast</B> (struct condition *<VAR>cond</VAR>, struct lock *<VAR>lock</VAR>)\n<DD>Wakes up all threads, if any, waiting on <VAR>cond</VAR> (protected by\nmonitor lock <VAR>lock</VAR>).  <VAR>lock</VAR> must be held before calling this\nfunction.\n</DL>\n<P>\n\n<HR SIZE=\"6\">\n<A NAME=\"SEC115\"></A>\n<H4> A.3.4.1 Monitor Example </H4>\n<!--docid::SEC115::-->\n<P>\n\nThe classical example of a monitor is handling a buffer into which one\nor more\n&quot;producer&quot; threads write characters and out of which one or more\n&quot;consumer&quot; threads read characters.  To implement this we need,\nbesides the monitor lock, two condition variables which we will call\n<VAR>not_full</VAR> and <VAR>not_empty</VAR>:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>char buf[BUF_SIZE];     /* Buffer. */\nsize_t n = 0;           /* 0 &lt;= n &lt;= <VAR>BUF_SIZE</VAR>: # of characters in buffer. */\nsize_t head = 0;        /* <VAR>buf</VAR> index of next char to write (mod <VAR>BUF_SIZE</VAR>). */\nsize_t tail = 0;        /* <VAR>buf</VAR> index of next char to read (mod <VAR>BUF_SIZE</VAR>). */\nstruct lock lock;       /* Monitor lock. */\nstruct condition not_empty; /* Signaled when the buffer is not empty. */\nstruct condition not_full; /* Signaled when the buffer is not full. */\n\n<small>...</small>initialize the locks and condition variables<small>...</small>\n\nvoid put (char ch) {\n  lock_acquire (&amp;lock);\n  while (n == BUF_SIZE)            /* Can't add to <VAR>buf</VAR> as long as it's full. */\n    cond_wait (&amp;not_full, &amp;lock);\n  buf[head++ % BUF_SIZE] = ch;     /* Add <VAR>ch</VAR> to <VAR>buf</VAR>. */\n  n++;\n  cond_signal (&amp;not_empty, &amp;lock); /* <VAR>buf</VAR> can't be empty anymore. */\n  lock_release (&amp;lock);\n}\n\nchar get (void) {\n  char ch;\n  lock_acquire (&amp;lock);\n  while (n == 0)                  /* Can't read <VAR>buf</VAR> as long as it's empty. */\n    cond_wait (&amp;not_empty, &amp;lock);\n  ch = buf[tail++ % BUF_SIZE];    /* Get <VAR>ch</VAR> from <VAR>buf</VAR>. */\n  n--;\n  cond_signal (&amp;not_full, &amp;lock); /* <VAR>buf</VAR> can't be full anymore. */\n  lock_release (&amp;lock);\n}\n</pre></td></tr></table><P>\n\nNote that <CODE>BUF_SIZE</CODE> must divide evenly into <CODE>SIZE_MAX + 1</CODE>\nfor the above code to be completely correct.  Otherwise, it will fail\nthe first time <CODE>head</CODE> wraps around to 0.  In practice,\n<CODE>BUF_SIZE</CODE> would ordinarily be a power of 2.\n</P>\n<P>\n\n<A NAME=\"Optimization Barriers\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC116\"></A>\n<H3> A.3.5 Optimization Barriers </H3>\n<!--docid::SEC116::-->\n<P>\n\nAn <EM>optimization barrier</EM> is a special statement that prevents the\ncompiler from making assumptions about the state of memory across the\nbarrier.  The compiler will not reorder reads or writes of variables\nacross the barrier or assume that a variable's value is unmodified\nacross the barrier, except for local variables whose address is never\ntaken.  In Pintos, <Q><TT>threads/synch.h</TT></Q> defines the <CODE>barrier()</CODE>\nmacro as an optimization barrier.\n</P>\n<P>\n\nOne reason to use an optimization barrier is when data can change\nasynchronously, without the compiler's knowledge, e.g. by another\nthread or an interrupt handler.  The <CODE>too_many_loops()</CODE> function in\n<Q><TT>devices/timer.c</TT></Q> is an example.  This function starts out by\nbusy-waiting in a loop until a timer tick occurs:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* Wait for a timer tick. */\nint64_t start = ticks;\nwhile (ticks == start)\n  barrier ();\n</pre></td></tr></table><P>\n\nWithout an optimization barrier in the loop, the compiler could\nconclude that the loop would never terminate, because <CODE>start</CODE> and\n<CODE>ticks</CODE> start out equal and the loop itself never changes them.\nIt could then &quot;optimize&quot; the function into an infinite loop, which\nwould definitely be undesirable.\n</P>\n<P>\n\nOptimization barriers can be used to avoid other compiler\noptimizations.  The <CODE>busy_wait()</CODE> function, also in\n<Q><TT>devices/timer.c</TT></Q>, is an example.  It contains this loop:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>while (loops-- &gt; 0)\n  barrier ();\n</pre></td></tr></table><P>\n\nThe goal of this loop is to busy-wait by counting <CODE>loops</CODE> down\nfrom its original value to 0.  Without the barrier, the compiler could\ndelete the loop entirely, because it produces no useful output and has\nno side effects.  The barrier forces the compiler to pretend that the\nloop body has an important effect.\n</P>\n<P>\n\nFinally, optimization barriers can be used to force the ordering of\nmemory reads or writes.  For example, suppose we add a &quot;feature&quot;\nthat, whenever a timer interrupt occurs, the character in global\nvariable <CODE>timer_put_char</CODE> is printed on the console, but only if\nglobal Boolean variable <CODE>timer_do_put</CODE> is true.  The best way to\nset up <Q><SAMP>x</SAMP></Q> to be printed is then to use an optimization barrier,\nlike this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>timer_put_char = 'x';\nbarrier ();\ntimer_do_put = true;\n</pre></td></tr></table><P>\n\nWithout the barrier, the code is buggy because the compiler is free to\nreorder operations when it doesn't see a reason to keep them in the\nsame order.  In this case, the compiler doesn't know that the order of\nassignments is important, so its optimizer is permitted to exchange\ntheir order.  There's no telling whether it will actually do this, and\nit is possible that passing the compiler different optimization flags\nor using a different version of the compiler will produce different\nbehavior.\n</P>\n<P>\n\nAnother solution is to disable interrupts around the assignments.\nThis does not prevent reordering, but it prevents the interrupt\nhandler from intervening between the assignments.  It also has the\nextra runtime cost of disabling and re-enabling interrupts:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>enum intr_level old_level = intr_disable ();\ntimer_put_char = 'x';\ntimer_do_put = true;\nintr_set_level (old_level);\n</pre></td></tr></table><P>\n\nA second solution is to mark the declarations of\n<CODE>timer_put_char</CODE> and <CODE>timer_do_put</CODE> as <Q><SAMP>volatile</SAMP></Q>.  This\nkeyword tells the compiler that the variables are externally observable\nand restricts its latitude for optimization.  However, the semantics of\n<Q><SAMP>volatile</SAMP></Q> are not well-defined, so it is not a good general\nsolution.  The base Pintos code does not use <Q><SAMP>volatile</SAMP></Q> at all.\n</P>\n<P>\n\nThe following is <EM>not</EM> a solution, because locks neither prevent\ninterrupts nor prevent the compiler from reordering the code within the\nregion where the lock is held:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>lock_acquire (&amp;timer_lock);     /* INCORRECT CODE */\ntimer_put_char = 'x';\ntimer_do_put = true;\nlock_release (&amp;timer_lock);\n</pre></td></tr></table><P>\n\nThe compiler treats invocation of any function defined externally,\nthat is, in another source file, as a limited form of optimization\nbarrier.  Specifically, the compiler assumes that any externally\ndefined function may access any statically or dynamically allocated\ndata and any local variable whose address is taken.  This often means\nthat explicit barriers can be omitted.  It is one reason that Pintos\ncontains few explicit barriers.\n</P>\n<P>\n\nA function defined in the same source file, or in a header included by\nthe source file, cannot be relied upon as a optimization barrier.\nThis applies even to invocation of a function before its\ndefinition, because the compiler may read and parse the entire source\nfile before performing optimization.\n</P>\n<P>\n\n<A NAME=\"Interrupt Handling\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC117\"></A>\n<H2> A.4 Interrupt Handling </H2>\n<!--docid::SEC117::-->\n<P>\n\nAn <EM>interrupt</EM> notifies the CPU of some event.  Much of the work\nof an operating system relates to interrupts in one way or another.\nFor our purposes, we classify interrupts into two broad categories:\n</P>\n<P>\n\n<UL>\n<LI>\n<EM>Internal interrupts</EM>, that is, interrupts caused directly by CPU\ninstructions.  System calls, attempts at invalid memory access\n(<EM>page faults</EM>), and attempts to divide by zero are some activities\nthat cause internal interrupts.  Because they are caused by CPU\ninstructions, internal interrupts are <EM>synchronous</EM> or synchronized\nwith CPU instructions.  <CODE>intr_disable()</CODE> does not disable internal\ninterrupts.\n<P>\n\n</P>\n<LI>\n<EM>External interrupts</EM>, that is, interrupts originating outside the\nCPU.  These interrupts come from hardware devices such as the system\ntimer, keyboard, serial ports, and disks.  External interrupts are\n<EM>asynchronous</EM>, meaning that their delivery is not\nsynchronized with instruction execution.  Handling of external interrupts\ncan be postponed with <CODE>intr_disable()</CODE> and related functions\n(see section <A HREF=\"pintos_7.html#SEC111\">A.3.1 Disabling Interrupts</A>).\n</UL>\n<P>\n\nThe CPU treats both classes of interrupts largely the same way,\nso Pintos has common infrastructure to handle both classes.\nThe following section describes this\ncommon infrastructure.  The sections after that give the specifics of\nexternal and internal interrupts.\n</P>\n<P>\n\nIf you haven't already read chapter 3, &quot;Basic Execution Environment,&quot;\nin [ <A HREF=\"pintos_14.html#IA32-v1\">IA32-v1</A>], it is recommended that you do so now.  You might\nalso want to skim chapter 5, &quot;Interrupt and Exception Handling,&quot; in\n[ <A HREF=\"pintos_14.html#IA32-v3a\">IA32-v3a</A>].\n</P>\n<P>\n\n<A NAME=\"Interrupt Infrastructure\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC118\"></A>\n<H3> A.4.1 Interrupt Infrastructure </H3>\n<!--docid::SEC118::-->\n<P>\n\nWhen an interrupt occurs, the CPU saves\nits most essential state on a stack and jumps to an interrupt\nhandler routine.  The 80<VAR>x</VAR>86 architecture supports 256\ninterrupts, numbered 0 through 255, each with an independent\nhandler defined in an array called the <EM>interrupt\ndescriptor table</EM> or IDT.\n</P>\n<P>\n\nIn Pintos, <CODE>intr_init()</CODE> in <Q><TT>threads/interrupt.c</TT></Q> sets up the\nIDT so that each entry points to a unique entry point in\n<Q><TT>threads/intr-stubs.S</TT></Q> named <CODE>intr<VAR>NN</VAR>_stub()</CODE>, where\n<VAR>NN</VAR> is the interrupt number in\nhexadecimal.  Because the CPU doesn't give\nus any other way to find out the interrupt number, this entry point\npushes the interrupt number on the stack.  Then it jumps to\n<CODE>intr_entry()</CODE>, which pushes all the registers that the processor\ndidn't already push for us, and then calls <CODE>intr_handler()</CODE>, which\nbrings us back into C in <Q><TT>threads/interrupt.c</TT></Q>.\n</P>\n<P>\n\nThe main job of <CODE>intr_handler()</CODE> is to call the function\nregistered for handling the particular interrupt.  (If no\nfunction is registered, it dumps some information to the console and\npanics.)  It also does some extra processing for external\ninterrupts (see section <A HREF=\"pintos_7.html#SEC120\">A.4.3 External Interrupt Handling</A>).\n</P>\n<P>\n\nWhen <CODE>intr_handler()</CODE> returns, the assembly code in\n<Q><TT>threads/intr-stubs.S</TT></Q> restores all the CPU registers saved\nearlier and directs the CPU to return from the interrupt.\n</P>\n<P>\n\nThe following types and functions are common to all\ninterrupts.\n</P>\n<P>\n\n<A NAME=\"IDX80\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>void intr_handler_func (struct intr_frame *<VAR>frame</VAR>)</B>\n<DD>This is how an interrupt handler function must be declared.  Its <VAR>frame</VAR>\nargument (see below) allows it to determine the cause of the interrupt\nand the state of the thread that was interrupted.\n</DL>\n<P>\n\n<A NAME=\"IDX81\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct intr_frame</B>\n<DD>The stack frame of an interrupt handler, as saved by the CPU, the interrupt\nstubs, and <CODE>intr_entry()</CODE>.  Its most interesting members are described\nbelow.\n</DL>\n<P>\n\n<A NAME=\"IDX82\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>edi</B>\n<DD><A NAME=\"IDX83\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>esi</B>\n<DD><A NAME=\"IDX84\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>ebp</B>\n<DD><A NAME=\"IDX85\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>esp_dummy</B>\n<DD><A NAME=\"IDX86\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>ebx</B>\n<DD><A NAME=\"IDX87\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>edx</B>\n<DD><A NAME=\"IDX88\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>ecx</B>\n<DD><A NAME=\"IDX89\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>eax</B>\n<DD><A NAME=\"IDX90\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint16_t <B>es</B>\n<DD><A NAME=\"IDX91\"></A>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint16_t <B>ds</B>\n<DD>Register values in the interrupted thread, pushed by <CODE>intr_entry()</CODE>.\nThe <CODE>esp_dummy</CODE> value isn't actually used (refer to the\ndescription of <CODE>PUSHA</CODE> in [ <A HREF=\"pintos_14.html#IA32-v2b\">IA32-v2b</A>] for details).\n</DL>\n<P>\n\n<A NAME=\"IDX92\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>vec_no</B>\n<DD>The interrupt vector number, ranging from 0 to 255.\n</DL>\n<P>\n\n<A NAME=\"IDX93\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> uint32_t <B>error_code</B>\n<DD>The &quot;error code&quot; pushed on the stack by the CPU for some internal\ninterrupts.\n</DL>\n<P>\n\n<A NAME=\"IDX94\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> void <B>(*eip)</B> (void)\n<DD>The address of the next instruction to be executed by the interrupted\nthread.\n</DL>\n<P>\n\n<A NAME=\"IDX95\"></A>\n</P>\n<DL>\n<DT><U>Member of <CODE>struct intr_frame</CODE>:</U> void *<B>esp</B>\n<DD>The interrupted thread's stack pointer.\n</DL>\n<P>\n\n<A NAME=\"IDX96\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> const char *<B>intr_name</B> (uint8_t <VAR>vec</VAR>)\n<DD>Returns the name of the interrupt numbered <VAR>vec</VAR>, or\n<CODE>&quot;unknown&quot;</CODE> if the interrupt has no registered name.\n</DL>\n<P>\n\n<A NAME=\"Internal Interrupt Handling\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC119\"></A>\n<H3> A.4.2 Internal Interrupt Handling </H3>\n<!--docid::SEC119::-->\n<P>\n\nInternal interrupts are caused directly by CPU instructions executed by\nthe running kernel thread or user process (from project 2 onward).  An\ninternal interrupt is therefore said to arise in a &quot;process context.&quot;\n</P>\n<P>\n\nIn an internal interrupt's handler, it can make sense to examine the\n<CODE>struct intr_frame</CODE> passed to the interrupt handler, or even to modify\nit.  When the interrupt returns, modifications in <CODE>struct intr_frame</CODE>\nbecome changes to the calling thread or process's state.  For example,\nthe Pintos system call handler returns a value to the user program by\nmodifying the saved EAX register (see section <A HREF=\"pintos_4.html#SEC62\">4.5.2 System Call Details</A>).\n</P>\n<P>\n\nThere are no special restrictions on what an internal interrupt\nhandler can or can't do.  Generally they should run with interrupts\nenabled, just like other code, and so they can be preempted by other\nkernel threads.  Thus, they do need to synchronize with other threads\non shared data and other resources (see section <A HREF=\"pintos_7.html#SEC110\">A.3 Synchronization</A>).\n</P>\n<P>\n\nInternal interrupt handlers can be invoked recursively.  For example,\nthe system call handler might cause a page fault while attempting to\nread user memory.  Deep recursion would risk overflowing the limited\nkernel stack (see section <A HREF=\"pintos_7.html#SEC107\">A.2.1 <CODE>struct thread</CODE></A>), but should be unnecessary.\n</P>\n<P>\n\n<A NAME=\"IDX97\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>intr_register_int</B> (uint8_t <VAR>vec</VAR>, int <VAR>dpl</VAR>, enum intr_level <VAR>level</VAR>, intr_handler_func *<VAR>handler</VAR>, const char *<VAR>name</VAR>)\n<DD>Registers <VAR>handler</VAR> to be called when internal interrupt numbered\n<VAR>vec</VAR> is triggered.  Names the interrupt <VAR>name</VAR> for debugging\npurposes.\n<P>\n\nIf <VAR>level</VAR> is <CODE>INTR_ON</CODE>, external interrupts will be processed\nnormally during the interrupt handler's execution, which is normally\ndesirable.  Specifying <CODE>INTR_OFF</CODE> will cause the CPU to disable\nexternal interrupts when it invokes the interrupt handler.  The effect\nis slightly different from calling <CODE>intr_disable()</CODE> inside the\nhandler, because that leaves a window of one or more CPU instructions in\nwhich external interrupts are still enabled.  This is important for the\npage fault handler; refer to the comments in <Q><TT>userprog/exception.c</TT></Q>\nfor details.\n</P>\n<P>\n\n<VAR>dpl</VAR> determines how the interrupt can be invoked.  If <VAR>dpl</VAR> is\n0, then the interrupt can be invoked only by kernel threads.  Otherwise\n<VAR>dpl</VAR> should be 3, which allows user processes to invoke the\ninterrupt with an explicit INT instruction.  The value of <VAR>dpl</VAR>\ndoesn't affect user processes' ability to invoke the interrupt\nindirectly, e.g. an invalid memory reference will cause a page fault\nregardless of <VAR>dpl</VAR>.\n</P>\n</DL>\n<P>\n\n<A NAME=\"External Interrupt Handling\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC120\"></A>\n<H3> A.4.3 External Interrupt Handling </H3>\n<!--docid::SEC120::-->\n<P>\n\nExternal interrupts are caused by events outside the CPU.\nThey are asynchronous, so they can be invoked at any time that\ninterrupts have not been disabled.  We say that an external interrupt\nruns in an &quot;interrupt context.&quot;\n</P>\n<P>\n\nIn an external interrupt, the <CODE>struct intr_frame</CODE> passed to the\nhandler is not very meaningful.  It describes the state of the thread\nor process that was interrupted, but there is no way to predict which\none that is.  It is possible, although rarely useful, to examine it, but\nmodifying it is a recipe for disaster.\n</P>\n<P>\n\nOnly one external interrupt may be processed at a time.  Neither\ninternal nor external interrupt may nest within an external interrupt\nhandler.  Thus, an external interrupt's handler must run with interrupts\ndisabled (see section <A HREF=\"pintos_7.html#SEC111\">A.3.1 Disabling Interrupts</A>).\n</P>\n<P>\n\nAn external interrupt handler must not sleep or yield, which rules out\ncalling <CODE>lock_acquire()</CODE>, <CODE>thread_yield()</CODE>, and many other\nfunctions.  Sleeping in interrupt context would effectively put the\ninterrupted thread to sleep, too, until the interrupt handler was again\nscheduled and returned.  This would be unfair to the unlucky thread, and\nit would deadlock if the handler were waiting for the sleeping thread\nto, e.g., release a lock.\n</P>\n<P>\n\nAn external interrupt handler\neffectively monopolizes the machine and delays all other activities.\nTherefore, external interrupt handlers should complete as quickly as\nthey can.  Anything that require much CPU time should instead run in a\nkernel thread, possibly one that the interrupt triggers using a\nsynchronization primitive.\n</P>\n<P>\n\nExternal interrupts are controlled by a\npair of devices outside the CPU called <EM>programmable interrupt\ncontrollers</EM>, <EM>PICs</EM> for short.  When <CODE>intr_init()</CODE> sets up the\nCPU's IDT, it also initializes the PICs for interrupt handling.  The\nPICs also must be &quot;acknowledged&quot; at the end of processing for each\nexternal interrupt.  <CODE>intr_handler()</CODE> takes care of that by calling\n<CODE>pic_end_of_interrupt()</CODE>, which properly signals the PICs.\n</P>\n<P>\n\nThe following functions relate to external\ninterrupts.\n</P>\n<P>\n\n<A NAME=\"IDX98\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>intr_register_ext</B> (uint8_t <VAR>vec</VAR>, intr_handler_func *<VAR>handler</VAR>, const char *<VAR>name</VAR>)\n<DD>Registers <VAR>handler</VAR> to be called when external interrupt numbered\n<VAR>vec</VAR> is triggered.  Names the interrupt <VAR>name</VAR> for debugging\npurposes.  The handler will run with interrupts disabled.\n</DL>\n<P>\n\n<A NAME=\"IDX99\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>intr_context</B> (void)\n<DD>Returns true if we are running in an interrupt context, otherwise\nfalse.  Mainly used in functions that might sleep\nor that otherwise should not be called from interrupt context, in this\nform:\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>ASSERT (!intr_context ());\n</pre></td></tr></table></DL>\n<P>\n\n<A NAME=\"IDX100\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>intr_yield_on_return</B> (void)\n<DD>When called in an interrupt context, causes <CODE>thread_yield()</CODE> to be\ncalled just before the interrupt returns.  Used\nin the timer interrupt handler when a thread's time slice expires, to\ncause a new thread to be scheduled.\n</DL>\n<P>\n\n<A NAME=\"Memory Allocation\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC121\"></A>\n<H2> A.5 Memory Allocation </H2>\n<!--docid::SEC121::-->\n<P>\n\nPintos contains two memory allocators, one that allocates memory in\nunits of a page, and one that can allocate blocks of any size.\n</P>\n<P>\n\n<A NAME=\"Page Allocator\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC122\"></A>\n<H3> A.5.1 Page Allocator </H3>\n<!--docid::SEC122::-->\n<P>\n\nThe page allocator declared in <Q><TT>threads/palloc.h</TT></Q> allocates\nmemory in units of a page.  It is most often used to allocate memory\none page at a time, but it can also allocate multiple contiguous pages\nat once.\n</P>\n<P>\n\nThe page allocator divides the memory it allocates into two pools,\ncalled the kernel and user pools.  By default, each pool gets half of\nsystem memory above 1 MB, but the division can be changed with the\n<Q><SAMP>-ul</SAMP></Q> kernel\ncommand line\noption (see  <A HREF=\"pintos_5.html#Why PAL_USER?\">Why PAL_USER?</A>).  An allocation request draws from one\npool or the other.  If one pool becomes empty, the other may still\nhave free pages.  The user pool should be used for allocating memory\nfor user processes and the kernel pool for all other allocations.\nThis will only become important starting with project 3.  Until then,\nall allocations should be made from the kernel pool.\n</P>\n<P>\n\nEach pool's usage is tracked with a bitmap, one bit per page in\nthe pool.  A request to allocate <VAR>n</VAR> pages scans the bitmap\nfor <VAR>n</VAR> consecutive bits set to\nfalse, indicating that those pages are free, and then sets those bits\nto true to mark them as used.  This is a &quot;first fit&quot; allocation\nstrategy (see  <A HREF=\"pintos_14.html#Wilson\">Wilson</A>).\n</P>\n<P>\n\nThe page allocator is subject to fragmentation.  That is, it may not\nbe possible to allocate <VAR>n</VAR> contiguous pages even though <VAR>n</VAR>\nor more pages are free, because the free pages are separated by used\npages.  In fact, in pathological cases it may be impossible to\nallocate 2 contiguous pages even though half of the pool's pages are free.\nSingle-page requests can't fail due to fragmentation, so\nrequests for multiple contiguous pages should be limited as much as\npossible.\n</P>\n<P>\n\nPages may not be allocated from interrupt context, but they may be\nfreed.\n</P>\n<P>\n\nWhen a page is freed, all of its bytes are cleared to <TT>0xcc</TT>, as\na debugging aid (see section <A HREF=\"pintos_11.html#SEC167\">E.8 Tips</A>).\n</P>\n<P>\n\nPage allocator types and functions are described below.\n</P>\n<P>\n\n<A NAME=\"IDX101\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>palloc_get_page</B> (enum palloc_flags <VAR>flags</VAR>)\n<DD><A NAME=\"IDX102\"></A>\n<DT><U>Function:</U> void *<B>palloc_get_multiple</B> (enum palloc_flags <VAR>flags</VAR>, size_t <VAR>page_cnt</VAR>)\n<DD>Obtains and returns one page, or <VAR>page_cnt</VAR> contiguous pages,\nrespectively.  Returns a null pointer if the pages cannot be allocated.\n<P>\n\nThe <VAR>flags</VAR> argument may be any combination of the following flags:\n</P>\n<P>\n\n<A NAME=\"IDX103\"></A>\n</P>\n<DL>\n<DT><U>Page Allocator Flag:</U> <B><CODE>PAL_ASSERT</CODE></B>\n<DD>If the pages cannot be allocated, panic the kernel.  This is only\nappropriate during kernel initialization.  User processes\nshould never be permitted to panic the kernel.\n</DL>\n<P>\n\n<A NAME=\"IDX104\"></A>\n</P>\n<DL>\n<DT><U>Page Allocator Flag:</U> <B><CODE>PAL_ZERO</CODE></B>\n<DD>Zero all the bytes in the allocated pages before returning them.  If not\nset, the contents of newly allocated pages are unpredictable.\n</DL>\n<P>\n\n<A NAME=\"IDX105\"></A>\n</P>\n<DL>\n<DT><U>Page Allocator Flag:</U> <B><CODE>PAL_USER</CODE></B>\n<DD>Obtain the pages from the user pool.  If not set, pages are allocated\nfrom the kernel pool.\n</DL>\n</DL>\n<P>\n\n<A NAME=\"IDX106\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>palloc_free_page</B> (void *<VAR>page</VAR>)\n<DD><A NAME=\"IDX107\"></A>\n<DT><U>Function:</U> void <B>palloc_free_multiple</B> (void *<VAR>pages</VAR>, size_t <VAR>page_cnt</VAR>)\n<DD>Frees one page, or <VAR>page_cnt</VAR> contiguous pages, respectively,\nstarting at <VAR>pages</VAR>.  All of the pages must have been obtained using\n<CODE>palloc_get_page()</CODE> or <CODE>palloc_get_multiple()</CODE>.\n</DL>\n<P>\n\n<A NAME=\"Block Allocator\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC123\"></A>\n<H3> A.5.2 Block Allocator </H3>\n<!--docid::SEC123::-->\n<P>\n\nThe block allocator, declared in <Q><TT>threads/malloc.h</TT></Q>, can allocate\nblocks of any size.  It is layered on top of the page allocator\ndescribed in the previous section.  Blocks returned by the block\nallocator are obtained from the kernel pool.\n</P>\n<P>\n\nThe block allocator uses two different strategies for allocating memory.\nThe first strategy applies to blocks that are 1 kB or smaller\n(one-fourth of the page size).  These allocations are rounded up to the\nnearest power of 2, or 16 bytes, whichever is larger.  Then they are\ngrouped into a page used only for allocations of that size.\n</P>\n<P>\n\nThe second strategy applies to blocks larger than 1 kB.\nThese allocations (plus a small amount of overhead) are rounded up to\nthe nearest page in size, and then the block allocator requests that\nnumber of contiguous pages from the page allocator.\n</P>\n<P>\n\nIn either case, the difference between the allocation requested size\nand the actual block size is wasted.  A real operating system would\ncarefully tune its allocator to minimize this waste, but this is\nunimportant in an instructional system like Pintos.\n</P>\n<P>\n\nAs long as a page can be obtained from the page allocator, small\nallocations always succeed.  Most small allocations do not require a\nnew page from the page allocator at all, because they are satisfied\nusing part of a page already allocated.  However, large allocations\nalways require calling into the page allocator, and any allocation\nthat needs more than one contiguous page can fail due to fragmentation,\nas already discussed in the previous section.  Thus, you should\nminimize the number of large allocations in your code, especially\nthose over approximately 4 kB each.\n</P>\n<P>\n\nWhen a block is freed, all of its bytes are cleared to <TT>0xcc</TT>, as\na debugging aid (see section <A HREF=\"pintos_11.html#SEC167\">E.8 Tips</A>).\n</P>\n<P>\n\nThe block allocator may not be called from interrupt context.\n</P>\n<P>\n\nThe block allocator functions are described below.  Their interfaces are\nthe same as the standard C library functions of the same names.\n</P>\n<P>\n\n<A NAME=\"IDX108\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>malloc</B> (size_t <VAR>size</VAR>)\n<DD>Obtains and returns a new block, from the kernel pool, at least\n<VAR>size</VAR> bytes long.  Returns a null pointer if <VAR>size</VAR> is zero or\nif memory is not available.\n</DL>\n<P>\n\n<A NAME=\"IDX109\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>calloc</B> (size_t <VAR>a</VAR>, size_t <VAR>b</VAR>)\n<DD>Obtains a returns a new block, from the kernel pool, at least\n<CODE><VAR>a</VAR> * <VAR>b</VAR></CODE> bytes long.  The block's contents will be\ncleared to zeros.  Returns a null pointer if <VAR>a</VAR> or <VAR>b</VAR> is zero\nor if insufficient memory is available.\n</DL>\n<P>\n\n<A NAME=\"IDX110\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>realloc</B> (void *<VAR>block</VAR>, size_t <VAR>new_size</VAR>)\n<DD>Attempts to resize <VAR>block</VAR> to <VAR>new_size</VAR> bytes, possibly moving\nit in the process.  If successful, returns the new block, in which case\nthe old block must no longer be accessed.  On failure, returns a null\npointer, and the old block remains valid.\n<P>\n\nA call with <VAR>block</VAR> null is equivalent to <CODE>malloc()</CODE>.  A call\nwith <VAR>new_size</VAR> zero is equivalent to <CODE>free()</CODE>.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX111\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>free</B> (void *<VAR>block</VAR>)\n<DD>Frees <VAR>block</VAR>, which must have been previously returned by\n<CODE>malloc()</CODE>, <CODE>calloc()</CODE>, or <CODE>realloc()</CODE> (and not yet freed).\n</DL>\n<P>\n\n<A NAME=\"Virtual Addresses\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC124\"></A>\n<H2> A.6 Virtual Addresses </H2>\n<!--docid::SEC124::-->\n<P>\n\nA 32-bit virtual address can be divided into a 20-bit <EM>page number</EM>\nand a 12-bit <EM>page offset</EM> (or just <EM>offset</EM>), like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>               31               12 11        0\n              +-------------------+-----------+\n              |    Page Number    |   Offset  |\n              +-------------------+-----------+\n                       Virtual Address\n</pre></td></tr></table><P>\n\nHeader <Q><TT>threads/vaddr.h</TT></Q> defines these functions and macros for\nworking with virtual addresses:\n</P>\n<P>\n\n<A NAME=\"IDX112\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PGSHIFT</B>\n<DD><A NAME=\"IDX113\"></A>\n<DT><U>Macro:</U> <B>PGBITS</B>\n<DD>The bit index (0) and number of bits (12) of the offset part of a\nvirtual address, respectively.\n</DL>\n<P>\n\n<A NAME=\"IDX114\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PGMASK</B>\n<DD>A bit mask with the bits in the page offset set to 1, the rest set to 0\n(<TT>0xfff</TT>).\n</DL>\n<P>\n\n<A NAME=\"IDX115\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PGSIZE</B>\n<DD>The page size in bytes (4,096).\n</DL>\n<P>\n\n<A NAME=\"IDX116\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> unsigned <B>pg_ofs</B> (const void *<VAR>va</VAR>)\n<DD>Extracts and returns the page offset in virtual address <VAR>va</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX117\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uintptr_t <B>pg_no</B> (const void *<VAR>va</VAR>)\n<DD>Extracts and returns the page number in virtual address <VAR>va</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX118\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>pg_round_down</B> (const void *<VAR>va</VAR>)\n<DD>Returns the start of the virtual page that <VAR>va</VAR> points within, that\nis, <VAR>va</VAR> with the page offset set to 0.\n</DL>\n<P>\n\n<A NAME=\"IDX119\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>pg_round_up</B> (const void *<VAR>va</VAR>)\n<DD>Returns <VAR>va</VAR> rounded up to the nearest page boundary.\n</DL>\n<P>\n\nVirtual memory in Pintos is divided into two regions: user virtual\nmemory and kernel virtual memory (see section <A HREF=\"pintos_4.html#SEC47\">4.1.4 Virtual Memory Layout</A>).  The\nboundary between them is <CODE>PHYS_BASE</CODE>:\n</P>\n<P>\n\n<A NAME=\"IDX120\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PHYS_BASE</B>\n<DD>Base address of kernel virtual memory.  It defaults to <TT>0xc0000000</TT> (3\nGB), but it may be changed to any multiple of <TT>0x10000000</TT> from\n<TT>0x80000000</TT> to <TT>0xf0000000</TT>.\n<P>\n\nUser virtual memory ranges from virtual address 0 up to\n<CODE>PHYS_BASE</CODE>.  Kernel virtual memory occupies the rest of the\nvirtual address space, from <CODE>PHYS_BASE</CODE> up to 4 GB.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX121\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>is_user_vaddr</B> (const void *<VAR>va</VAR>)\n<DD><A NAME=\"IDX122\"></A>\n<DT><U>Function:</U> bool <B>is_kernel_vaddr</B> (const void *<VAR>va</VAR>)\n<DD>Returns true if <VAR>va</VAR> is a user or kernel virtual address,\nrespectively, false otherwise.\n</DL>\n<P>\n\nThe 80<VAR>x</VAR>86 doesn't provide any way to directly access memory given\na physical address.  This ability is often necessary in an operating\nsystem kernel, so Pintos works around it by mapping kernel virtual\nmemory one-to-one to physical memory.  That is, virtual address\n<CODE>PHYS_BASE</CODE> accesses physical address 0, virtual address\n<CODE>PHYS_BASE</CODE> + <TT>0x1234</TT> accesses physical address <TT>0x1234</TT>, and\nso on up to the size of the machine's physical memory.  Thus, adding\n<CODE>PHYS_BASE</CODE> to a physical address obtains a kernel virtual address\nthat accesses that address; conversely, subtracting <CODE>PHYS_BASE</CODE>\nfrom a kernel virtual address obtains the corresponding physical\naddress.  Header <Q><TT>threads/vaddr.h</TT></Q> provides a pair of functions to\ndo these translations:\n</P>\n<P>\n\n<A NAME=\"IDX123\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>ptov</B> (uintptr_t <VAR>pa</VAR>)\n<DD>Returns the kernel virtual address corresponding to physical address\n<VAR>pa</VAR>, which should be between 0 and the number of bytes of physical\nmemory.\n</DL>\n<P>\n\n<A NAME=\"IDX124\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uintptr_t <B>vtop</B> (void *<VAR>va</VAR>)\n<DD>Returns the physical address corresponding to <VAR>va</VAR>, which must be a\nkernel virtual address.\n</DL>\n<P>\n\n<A NAME=\"Page Table\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC125\"></A>\n<H2> A.7 Page Table </H2>\n<!--docid::SEC125::-->\n<P>\n\nThe code in <Q><TT>pagedir.c</TT></Q> is an abstract interface to the 80<VAR>x</VAR>86\nhardware page table, also called a &quot;page directory&quot; by Intel processor\ndocumentation.  The page table interface uses a <CODE>uint32_t *</CODE> to\nrepresent a page table because this is convenient for accessing their\ninternal structure.\n</P>\n<P>\n\nThe sections below describe the page table interface and internals.\n</P>\n<P>\n\n<A NAME=\"Page Table Creation Destruction Activation\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC126\"></A>\n<H3> A.7.1 Creation, Destruction, and Activation </H3>\n<!--docid::SEC126::-->\n<P>\n\nThese functions create, destroy, and activate page tables.  The base\nPintos code already calls these functions where necessary, so it should\nnot be necessary to call them yourself.\n</P>\n<P>\n\n<A NAME=\"IDX125\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uint32_t *<B>pagedir_create</B> (void)\n<DD>Creates and returns a new page table.  The new page table contains\nPintos's normal kernel virtual page mappings, but no user virtual\nmappings.\n<P>\n\nReturns a null pointer if memory cannot be obtained.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX126\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>pagedir_destroy</B> (uint32_t *<VAR>pd</VAR>)\n<DD>Frees all of the resources held by <VAR>pd</VAR>, including the page table\nitself and the frames that it maps.\n</DL>\n<P>\n\n<A NAME=\"IDX127\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>pagedir_activate</B> (uint32_t *<VAR>pd</VAR>)\n<DD>Activates <VAR>pd</VAR>.  The active page table is the one used by the CPU to\ntranslate memory references.\n</DL>\n<P>\n\n<A NAME=\"Page Tables Inspection and Updates\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC127\"></A>\n<H3> A.7.2 Inspection and Updates </H3>\n<!--docid::SEC127::-->\n<P>\n\nThese functions examine or update the mappings from pages to frames\nencapsulated by a page table.  They work on both active and inactive\npage tables (that is, those for running and suspended processes),\nflushing the TLB as necessary.\n</P>\n<P>\n\n<A NAME=\"IDX128\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>pagedir_set_page</B> (uint32_t *<VAR>pd</VAR>, void *<VAR>upage</VAR>, void *<VAR>kpage</VAR>, bool <VAR>writable</VAR>)\n<DD>Adds to <VAR>pd</VAR> a mapping from user page <VAR>upage</VAR> to the frame identified\nby kernel virtual address <VAR>kpage</VAR>.  If <VAR>writable</VAR> is true, the\npage is mapped read/write; otherwise, it is mapped read-only.\n<P>\n\nUser page <VAR>upage</VAR> must not already be mapped in <VAR>pd</VAR>.\n</P>\n<P>\n\nKernel page <VAR>kpage</VAR> should be a kernel virtual address obtained from\nthe user pool with <CODE>palloc_get_page(PAL_USER)</CODE> (see  <A HREF=\"pintos_5.html#Why PAL_USER?\">Why PAL_USER?</A>).\n</P>\n<P>\n\nReturns true if successful, false on failure.  Failure will occur if\nadditional memory required for the page table cannot be obtained.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX129\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>pagedir_get_page</B> (uint32_t *<VAR>pd</VAR>, const void *<VAR>uaddr</VAR>)\n<DD>Looks up the frame mapped to <VAR>uaddr</VAR> in <VAR>pd</VAR>.  Returns the\nkernel virtual address for that frame, if <VAR>uaddr</VAR> is mapped, or a\nnull pointer if it is not.\n</DL>\n<P>\n\n<A NAME=\"IDX130\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>pagedir_clear_page</B> (uint32_t *<VAR>pd</VAR>, void *<VAR>page</VAR>)\n<DD>Marks <VAR>page</VAR> &quot;not present&quot; in <VAR>pd</VAR>.  Later accesses to\nthe page will fault.\n<P>\n\nOther bits in the page table for <VAR>page</VAR> are preserved, permitting\nthe accessed and dirty bits (see the next section) to be checked.\n</P>\n<P>\n\nThis function has no effect if <VAR>page</VAR> is not mapped.\n</P>\n</DL>\n<P>\n\n<A NAME=\"Page Table Accessed and Dirty Bits\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC128\"></A>\n<H3> A.7.3 Accessed and Dirty Bits </H3>\n<!--docid::SEC128::-->\n<P>\n\n80<VAR>x</VAR>86 hardware provides some assistance for implementing page\nreplacement algorithms, through a pair of bits in the page table entry\n(PTE) for each page.  On any read or write to a page, the CPU sets the\n<EM>accessed bit</EM> to 1 in the page's PTE, and on any write, the CPU\nsets the <EM>dirty bit</EM> to 1.  The CPU never resets these bits to 0,\nbut the OS may do so.\n</P>\n<P>\n\nProper interpretation of these bits requires understanding of\n<EM>aliases</EM>, that is, two (or more) pages that refer to the same\nframe.  When an aliased frame is accessed, the accessed and dirty bits\nare updated in only one page table entry (the one for the page used for\naccess).  The accessed and dirty bits for the other aliases are not\nupdated.\n</P>\n<P>\n\nSee section <A HREF=\"pintos_5.html#SEC74\">5.1.5.1 Accessed and Dirty Bits</A>, on applying these bits in implementing\npage replacement algorithms.\n</P>\n<P>\n\n<A NAME=\"IDX131\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>pagedir_is_dirty</B> (uint32_t *<VAR>pd</VAR>, const void *<VAR>page</VAR>)\n<DD><A NAME=\"IDX132\"></A>\n<DT><U>Function:</U> bool <B>pagedir_is_accessed</B> (uint32_t *<VAR>pd</VAR>, const void *<VAR>page</VAR>)\n<DD>Returns true if page directory <VAR>pd</VAR> contains a page table entry for\n<VAR>page</VAR> that is marked dirty (or accessed).  Otherwise,\nreturns false.\n</DL>\n<P>\n\n<A NAME=\"IDX133\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>pagedir_set_dirty</B> (uint32_t *<VAR>pd</VAR>, const void *<VAR>page</VAR>, bool <VAR>value</VAR>)\n<DD><A NAME=\"IDX134\"></A>\n<DT><U>Function:</U> void <B>pagedir_set_accessed</B> (uint32_t *<VAR>pd</VAR>, const void *<VAR>page</VAR>, bool <VAR>value</VAR>)\n<DD>If page directory <VAR>pd</VAR> has a page table entry for <VAR>page</VAR>, then\nits dirty (or accessed) bit is set to <VAR>value</VAR>.\n</DL>\n<P>\n\n<A NAME=\"Page Table Details\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC129\"></A>\n<H3> A.7.4 Page Table Details </H3>\n<!--docid::SEC129::-->\n<P>\n\nThe functions provided with Pintos are sufficient to implement the\nprojects.  However, you may still find it worthwhile to understand the\nhardware page table format, so we'll go into a little detail in this\nsection.\n</P>\n<P>\n\n<A NAME=\"Page Table Structure\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC130\"></A>\n<H4> A.7.4.1 Structure </H4>\n<!--docid::SEC130::-->\n<P>\n\nThe top-level paging data structure is a page called the &quot;page\ndirectory&quot; (PD) arranged as an array of 1,024 32-bit page directory\nentries (PDEs), each of which represents 4 MB of virtual memory.  Each\nPDE may point to the physical address of another page called a\n&quot;page table&quot; (PT) arranged, similarly, as an array of 1,024\n32-bit page table entries (PTEs), each of which translates a single 4\nkB virtual page to a physical page.\n</P>\n<P>\n\nTranslation of a virtual address into a physical address follows\nthe three-step process illustrated in the diagram\nbelow:<A NAME=\"DOCF5\" HREF=\"pintos_fot.html#FOOT5\">(5)</A>\n</P>\n<P>\n\n<OL>\n<LI>\nThe most-significant 10 bits of the virtual address (bits 22<small>...</small>31)\nindex the page directory.  If the PDE is marked &quot;present,&quot; the\nphysical address of a page table is read from the PDE thus obtained.\nIf the PDE is marked &quot;not present&quot; then a page fault occurs.\n<P>\n\n</P>\n<LI>\nThe next 10 bits of the virtual address (bits 12<small>...</small>21) index\nthe page table.  If the PTE is marked &quot;present,&quot; the physical\naddress of a data page is read from the PTE thus obtained.  If the PTE\nis marked &quot;not present&quot; then a page fault occurs.\n<P>\n\n</P>\n<LI>\nThe least-significant 12 bits of the virtual address (bits 0<small>...</small>11)\nare added to the data page's physical base address, yielding the final\nphysical address.\n</OL>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre> 31                  22 21                  12 11                   0\n+----------------------+----------------------+----------------------+\n| Page Directory Index |   Page Table Index   |    Page Offset       |\n+----------------------+----------------------+----------------------+\n             |                    |                     |\n     _______/             _______/                _____/\n    /                    /                       /\n   /    Page Directory  /      Page Table       /    Data Page\n  /     .____________. /     .____________.    /   .____________.\n  |1,023|____________| |1,023|____________|    |   |____________|\n  |1,022|____________| |1,022|____________|    |   |____________|\n  |1,021|____________| |1,021|____________|    \\__\\|____________|\n  |1,020|____________| |1,020|____________|       /|____________|\n  |     |            | |     |            |        |            |\n  |     |            | \\____\\|            |_       |            |\n  |     |      .     |      /|      .     | \\      |      .     |\n  \\____\\|      .     |_      |      .     |  |     |      .     |\n       /|      .     | \\     |      .     |  |     |      .     |\n        |      .     |  |    |      .     |  |     |      .     |\n        |            |  |    |            |  |     |            |\n        |____________|  |    |____________|  |     |____________|\n       4|____________|  |   4|____________|  |     |____________|\n       3|____________|  |   3|____________|  |     |____________|\n       2|____________|  |   2|____________|  |     |____________|\n       1|____________|  |   1|____________|  |     |____________|\n       0|____________|  \\__\\0|____________|  \\____\\|____________|\n                           /                      /\n</pre></td></tr></table><P>\n\nPintos provides some macros and functions that are useful for working\nwith raw page tables:\n</P>\n<P>\n\n<A NAME=\"IDX135\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTSHIFT</B>\n<DD><A NAME=\"IDX136\"></A>\n<DT><U>Macro:</U> <B>PTBITS</B>\n<DD>The starting bit index (12) and number of bits (10), respectively, in a\npage table index.\n</DL>\n<P>\n\n<A NAME=\"IDX137\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTMASK</B>\n<DD>A bit mask with the bits in the page table index set to 1 and the rest\nset to 0 (<TT>0x3ff000</TT>).\n</DL>\n<P>\n\n<A NAME=\"IDX138\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTSPAN</B>\n<DD>The number of bytes of virtual address space that a single page table\npage covers (4,194,304 bytes, or 4 MB).\n</DL>\n<P>\n\n<A NAME=\"IDX139\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PDSHIFT</B>\n<DD><A NAME=\"IDX140\"></A>\n<DT><U>Macro:</U> <B>PDBITS</B>\n<DD>The starting bit index (22) and number of bits (10), respectively, in a\npage directory index.\n</DL>\n<P>\n\n<A NAME=\"IDX141\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PDMASK</B>\n<DD>A bit mask with the bits in the page directory index set to 1 and other\nbits set to 0 (<TT>0xffc00000</TT>).\n</DL>\n<P>\n\n<A NAME=\"IDX142\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uintptr_t <B>pd_no</B> (const void *<VAR>va</VAR>)\n<DD><A NAME=\"IDX143\"></A>\n<DT><U>Function:</U> uintptr_t <B>pt_no</B> (const void *<VAR>va</VAR>)\n<DD>Returns the page directory index or page table index, respectively, for\nvirtual address <VAR>va</VAR>.  These functions are defined in\n<Q><TT>threads/pte.h</TT></Q>.\n</DL>\n<P>\n\n<A NAME=\"IDX144\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> unsigned <B>pg_ofs</B> (const void *<VAR>va</VAR>)\n<DD>Returns the page offset for virtual address <VAR>va</VAR>.  This function is\ndefined in <Q><TT>threads/vaddr.h</TT></Q>.\n</DL>\n<P>\n\n<A NAME=\"Page Table Entry Format\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC131\"></A>\n<H4> A.7.4.2 Page Table Entry Format </H4>\n<!--docid::SEC131::-->\n<P>\n\nYou do not need to understand the PTE format to do the Pintos\nprojects, unless you wish to incorporate the page table into your\nsupplemental page table (see section <A HREF=\"pintos_5.html#SEC72\">5.1.4 Managing the Supplemental Page Table</A>).\n</P>\n<P>\n\nThe actual format of a page table entry is summarized below.  For\ncomplete information, refer to section 3.7, &quot;Page Translation Using\n32-Bit Physical Addressing,&quot; in [ <A HREF=\"pintos_14.html#IA32-v3a\">IA32-v3a</A>].\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre> 31                                   12 11 9      6 5     2 1 0\n+---------------------------------------+----+----+-+-+---+-+-+-+\n|           Physical Address            | AVL|    |D|A|   |U|W|P|\n+---------------------------------------+----+----+-+-+---+-+-+-+\n</pre></td></tr></table><P>\n\nSome more information on each bit is given below.  The names are\n<Q><TT>threads/pte.h</TT></Q> macros that represent the bits' values:\n</P>\n<P>\n\n<A NAME=\"IDX145\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTE_P</B>\n<DD>Bit 0, the &quot;present&quot; bit.  When this bit is 1, the\nother bits are interpreted as described below.  When this bit is 0, any\nattempt to access the page will page fault.  The remaining bits are then\nnot used by the CPU and may be used by the OS for any purpose.\n</DL>\n<P>\n\n<A NAME=\"IDX146\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTE_W</B>\n<DD>Bit 1, the &quot;read/write&quot; bit.  When it is 1, the page\nis writable.  When it is 0, write attempts will page fault.\n</DL>\n<P>\n\n<A NAME=\"IDX147\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTE_U</B>\n<DD>Bit 2, the &quot;user/supervisor&quot; bit.  When it is 1, user\nprocesses may access the page.  When it is 0, only the kernel may access\nthe page (user accesses will page fault).\n<P>\n\nPintos clears this bit in PTEs for kernel virtual memory, to prevent\nuser processes from accessing them.\n</P>\n</DL>\n \n<A NAME=\"IDX148\"></A>\n<DL>\n<DT><U>Macro:</U> <B>PTE_A</B>\n<DD>Bit 5, the &quot;accessed&quot; bit.  See section <A HREF=\"pintos_7.html#SEC128\">A.7.3 Accessed and Dirty Bits</A>.\n</DL>\n<P>\n\n<A NAME=\"IDX149\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTE_D</B>\n<DD>Bit 6, the &quot;dirty&quot; bit.  See section <A HREF=\"pintos_7.html#SEC128\">A.7.3 Accessed and Dirty Bits</A>.\n</DL>\n<P>\n\n<A NAME=\"IDX150\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTE_AVL</B>\n<DD>Bits 9<small>...</small>11, available for operating system use.\nPintos, as provided, does not use them and sets them to 0.\n</DL>\n<P>\n\n<A NAME=\"IDX151\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <B>PTE_ADDR</B>\n<DD>Bits 12<small>...</small>31, the top 20 bits of the physical address of a frame.\nThe low 12 bits of the frame's address are always 0.\n</DL>\n<P>\n\nOther bits are either reserved or uninteresting in a Pintos context and\nshould be set to@tie{}0.\n</P>\n<P>\n\nHeader <Q><TT>threads/pte.h</TT></Q> defines three functions for working with\npage table entries:\n</P>\n<P>\n\n<A NAME=\"IDX152\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uint32_t <B>pte_create_kernel</B> (uint32_t *<VAR>page</VAR>, bool <VAR>writable</VAR>)\n<DD>Returns a page table entry that points to <VAR>page</VAR>, which should be a\nkernel virtual address.  The PTE's present bit will be set.  It will be\nmarked for kernel-only access.  If <VAR>writable</VAR> is true, the PTE will\nalso be marked read/write; otherwise, it will be read-only.\n</DL>\n<P>\n\n<A NAME=\"IDX153\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uint32_t <B>pte_create_user</B> (uint32_t *<VAR>page</VAR>, bool <VAR>writable</VAR>)\n<DD>Returns a page table entry that points to <VAR>page</VAR>, which should be\nthe kernel virtual address of a frame in the user pool (see  <A HREF=\"pintos_5.html#Why PAL_USER?\">Why PAL_USER?</A>).  The PTE's present bit will be set and it will be marked to\nallow user-mode access.  If <VAR>writable</VAR> is true, the PTE will also be\nmarked read/write; otherwise, it will be read-only.\n</DL>\n<P>\n\n<A NAME=\"IDX154\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void *<B>pte_get_page</B> (uint32_t <VAR>pte</VAR>)\n<DD>Returns the kernel virtual address for the frame that <VAR>pte</VAR> points\nto.  The <VAR>pte</VAR> may be present or not-present; if it is not-present\nthen the pointer returned is only meaningful if the address bits in the PTE\nactually represent a physical address.\n</DL>\n<P>\n\n<A NAME=\"Page Directory Entry Format\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC132\"></A>\n<H4> A.7.4.3 Page Directory Entry Format </H4>\n<!--docid::SEC132::-->\n<P>\n\nPage directory entries have the same format as PTEs, except that the\nphysical address points to a page table page instead of a frame.  Header\n<Q><TT>threads/pte.h</TT></Q> defines two functions for working with page\ndirectory entries:\n</P>\n<P>\n\n<A NAME=\"IDX155\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uint32_t <B>pde_create</B> (uint32_t *<VAR>pt</VAR>)\n<DD>Returns a page directory that points to <VAR>page</VAR>, which should be the\nkernel virtual address of a page table page.  The PDE's present bit will\nbe set, it will be marked to allow user-mode access, and it will be\nmarked read/write.\n</DL>\n<P>\n\n<A NAME=\"IDX156\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> uint32_t *<B>pde_get_pt</B> (uint32_t <VAR>pde</VAR>)\n<DD>Returns the kernel virtual address for the page table page that\n<VAR>pde</VAR>, which must be marked present, points to.\n</DL>\n<P>\n\n<A NAME=\"Hash Table\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC133\"></A>\n<H2> A.8 Hash Table </H2>\n<!--docid::SEC133::-->\n<P>\n\nPintos provides a hash table data structure in <Q><TT>lib/kernel/hash.c</TT></Q>.\nTo use it you will need to include its header file,\n<Q><TT>lib/kernel/hash.h</TT></Q>, with <CODE>#include &lt;hash.h&gt;</CODE>.\nNo code provided with Pintos uses the hash table, which means that you\nare free to use it as is, modify its implementation for your own\npurposes, or ignore it, as you wish.\n</P>\n<P>\n\nMost implementations of the virtual memory project use a hash table to\ntranslate pages to frames.  You may find other uses for hash tables as\nwell.\n</P>\n<P>\n\n<A NAME=\"Hash Data Types\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC134\"></A>\n<H3> A.8.1 Data Types </H3>\n<!--docid::SEC134::-->\n<P>\n\nA hash table is represented by <CODE>struct hash</CODE>.\n</P>\n<P>\n\n<A NAME=\"IDX157\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct hash</B>\n<DD>Represents an entire hash table.  The actual members of <CODE>struct hash</CODE>\nare &quot;opaque.&quot;  That is, code that uses a hash table should not access\n<CODE>struct hash</CODE> members directly, nor should it need to.  Instead, use\nhash table functions and macros.\n</DL>\n<P>\n\nThe hash table operates on elements of type <CODE>struct hash_elem</CODE>.\n</P>\n<P>\n\n<A NAME=\"IDX158\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct hash_elem</B>\n<DD>Embed a <CODE>struct hash_elem</CODE> member in the structure you want to include\nin a hash table.  Like <CODE>struct hash</CODE>, <CODE>struct hash_elem</CODE> is opaque.\nAll functions for operating on hash table elements actually take and\nreturn pointers to <CODE>struct hash_elem</CODE>, not pointers to your hash table's\nreal element type.\n</DL>\n<P>\n\nYou will often need to obtain a <CODE>struct hash_elem</CODE> given a real element\nof the hash table, and vice versa.  Given a real element of the hash\ntable, you may use the <Q><SAMP>&amp;</SAMP></Q> operator to obtain a pointer to its\n<CODE>struct hash_elem</CODE>.  Use the <CODE>hash_entry()</CODE> macro to go the other\ndirection.\n</P>\n<P>\n\n<A NAME=\"IDX159\"></A>\n</P>\n<DL>\n<DT><U>Macro:</U> <VAR>type</VAR> *<B>hash_entry</B> (struct hash_elem *<VAR>elem</VAR>, <VAR>type</VAR>, <VAR>member</VAR>)\n<DD>Returns a pointer to the structure that <VAR>elem</VAR>, a pointer to a\n<CODE>struct hash_elem</CODE>, is embedded within.  You must provide <VAR>type</VAR>,\nthe name of the structure that <VAR>elem</VAR> is inside, and <VAR>member</VAR>,\nthe name of the member in <VAR>type</VAR> that <VAR>elem</VAR> points to.\n<P>\n\nFor example, suppose <CODE>h</CODE> is a <CODE>struct hash_elem *</CODE> variable\nthat points to a <CODE>struct thread</CODE> member (of type <CODE>struct hash_elem</CODE>)\nnamed <CODE>h_elem</CODE>.  Then, <CODE>hash_entry@tie{</CODE>(h, struct thread, h_elem)}\nyields the address of the <CODE>struct thread</CODE> that <CODE>h</CODE> points within.\n</P>\n</DL>\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC138\">A.8.5 Hash Table Example</A>, for an example.\n</P>\n<P>\n\nEach hash table element must contain a key, that is, data that\nidentifies and distinguishes elements, which must be unique\namong elements in the hash table.  (Elements may\nalso contain non-key data that need not be unique.)  While an element is\nin a hash table, its key data must not be changed.  Instead, if need be,\nremove the element from the hash table, modify its key, then reinsert\nthe element.\n</P>\n<P>\n\nFor each hash table, you must write two functions that act on keys: a\nhash function and a comparison function.  These functions must match the\nfollowing prototypes:\n</P>\n<P>\n\n<A NAME=\"IDX160\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>unsigned hash_hash_func (const struct hash_elem *<VAR>element</VAR>, void *<VAR>aux</VAR>)</B>\n<DD>Returns a hash of <VAR>element</VAR>'s data, as a value anywhere in the range\nof <CODE>unsigned int</CODE>.  The hash of an element should be a\npseudo-random function of the element's key.  It must not depend on\nnon-key data in the element or on any non-constant data other than the\nkey.  Pintos provides the following functions as a suitable basis for\nhash functions.\n<P>\n\n<A NAME=\"IDX161\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> unsigned <B>hash_bytes</B> (const void *<VAR>buf</VAR>, size_t *<VAR>size</VAR>)\n<DD>Returns a hash of the <VAR>size</VAR> bytes starting at <VAR>buf</VAR>.  The\nimplementation is the general-purpose\n<A HREF=\"http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash\">Fowler-Noll-Vo\nhash</A> for 32-bit words.\n</DL>\n<P>\n\n<A NAME=\"IDX162\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> unsigned <B>hash_string</B> (const char *<VAR>s</VAR>)\n<DD>Returns a hash of null-terminated string <VAR>s</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX163\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> unsigned <B>hash_int</B> (int <VAR>i</VAR>)\n<DD>Returns a hash of integer <VAR>i</VAR>.\n</DL>\n<P>\n\nIf your key is a single piece of data of an appropriate type, it is\nsensible for your hash function to directly return the output of one of\nthese functions.  For multiple pieces of data, you may wish to combine\nthe output of more than one call to them using, e.g., the <Q><SAMP>^</SAMP></Q>\n(exclusive or)\noperator.  Finally, you may entirely ignore these functions and write\nyour own hash function from scratch, but remember that your goal is to\nbuild an operating system kernel, not to design a hash function.\n</P>\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC139\">A.8.6 Auxiliary Data</A>, for an explanation of <VAR>aux</VAR>.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX164\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>bool hash_less_func (const struct hash_elem *<VAR>a</VAR>, const struct hash_elem *<VAR>b</VAR>, void *<VAR>aux</VAR>)</B>\n<DD>Compares the keys stored in elements <VAR>a</VAR> and <VAR>b</VAR>.  Returns\ntrue if <VAR>a</VAR> is less than <VAR>b</VAR>, false if <VAR>a</VAR> is greater than\nor equal to <VAR>b</VAR>.\n<P>\n\nIf two elements compare equal, then they must hash to equal values.\n</P>\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC139\">A.8.6 Auxiliary Data</A>, for an explanation of <VAR>aux</VAR>.\n</P>\n</DL>\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC138\">A.8.5 Hash Table Example</A>, for hash and comparison function examples.\n</P>\n<P>\n\nA few functions accept a pointer to a third kind of\nfunction as an argument:\n</P>\n<P>\n\n<A NAME=\"IDX165\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>void hash_action_func (struct hash_elem *<VAR>element</VAR>, void *<VAR>aux</VAR>)</B>\n<DD>Performs some kind of action, chosen by the caller, on <VAR>element</VAR>.\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC139\">A.8.6 Auxiliary Data</A>, for an explanation of <VAR>aux</VAR>.\n</P>\n</DL>\n<P>\n\n<A NAME=\"Basic Hash Functions\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC135\"></A>\n<H3> A.8.2 Basic Functions </H3>\n<!--docid::SEC135::-->\n<P>\n\nThese functions create, destroy, and inspect hash tables.\n</P>\n<P>\n\n<A NAME=\"IDX166\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>hash_init</B> (struct hash *<VAR>hash</VAR>, hash_hash_func *<VAR>hash_func</VAR>, hash_less_func *<VAR>less_func</VAR>, void *<VAR>aux</VAR>)\n<DD>Initializes <VAR>hash</VAR> as a hash table with <VAR>hash_func</VAR> as hash\nfunction, <VAR>less_func</VAR> as comparison function, and <VAR>aux</VAR> as\nauxiliary data.\nReturns true if successful, false on failure.  <CODE>hash_init()</CODE> calls\n<CODE>malloc()</CODE> and fails if memory cannot be allocated.\n<P>\n\nSee section <A HREF=\"pintos_7.html#SEC139\">A.8.6 Auxiliary Data</A>, for an explanation of <VAR>aux</VAR>, which is\nmost often a null pointer.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX167\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>hash_clear</B> (struct hash *<VAR>hash</VAR>, hash_action_func *<VAR>action</VAR>)\n<DD>Removes all the elements from <VAR>hash</VAR>, which must have been\npreviously initialized with <CODE>hash_init()</CODE>.\n<P>\n\nIf <VAR>action</VAR> is non-null, then it is called once for each element in\nthe hash table, which gives the caller an opportunity to deallocate any\nmemory or other resources used by the element.  For example, if the hash\ntable elements are dynamically allocated using <CODE>malloc()</CODE>, then\n<VAR>action</VAR> could <CODE>free()</CODE> the element.  This is safe because\n<CODE>hash_clear()</CODE> will not access the memory in a given hash element\nafter calling <VAR>action</VAR> on it.  However, <VAR>action</VAR> must not call\nany function that may modify the hash table, such as <CODE>hash_insert()</CODE>\nor <CODE>hash_delete()</CODE>.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX168\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>hash_destroy</B> (struct hash *<VAR>hash</VAR>, hash_action_func *<VAR>action</VAR>)\n<DD>If <VAR>action</VAR> is non-null, calls it for each element in the hash, with\nthe same semantics as a call to <CODE>hash_clear()</CODE>.  Then, frees the\nmemory held by <VAR>hash</VAR>.  Afterward, <VAR>hash</VAR> must not be passed to\nany hash table function, absent an intervening call to <CODE>hash_init()</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX169\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> size_t <B>hash_size</B> (struct hash *<VAR>hash</VAR>)\n<DD>Returns the number of elements currently stored in <VAR>hash</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX170\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> bool <B>hash_empty</B> (struct hash *<VAR>hash</VAR>)\n<DD>Returns true if <VAR>hash</VAR> currently contains no elements,\nfalse if <VAR>hash</VAR> contains at least one element.\n</DL>\n<P>\n\n<A NAME=\"Hash Search Functions\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC136\"></A>\n<H3> A.8.3 Search Functions </H3>\n<!--docid::SEC136::-->\n<P>\n\nEach of these functions searches a hash table for an element that\ncompares equal to one provided.  Based on the success of the search,\nthey perform some action, such as inserting a new element into the hash\ntable, or simply return the result of the search.\n</P>\n<P>\n\n<A NAME=\"IDX171\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct hash_elem *<B>hash_insert</B> (struct hash *<VAR>hash</VAR>, struct hash_elem *<VAR>element</VAR>)\n<DD>Searches <VAR>hash</VAR> for an element equal to <VAR>element</VAR>.  If none is\nfound, inserts <VAR>element</VAR> into <VAR>hash</VAR> and returns a null pointer.\nIf the table already contains an element equal to <VAR>element</VAR>, it is\nreturned without modifying <VAR>hash</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX172\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct hash_elem *<B>hash_replace</B> (struct hash *<VAR>hash</VAR>, struct hash_elem *<VAR>element</VAR>)\n<DD>Inserts <VAR>element</VAR> into <VAR>hash</VAR>.  Any element equal to\n<VAR>element</VAR> already in <VAR>hash</VAR> is removed.  Returns the element\nremoved, or a null pointer if <VAR>hash</VAR> did not contain an element\nequal to <VAR>element</VAR>.\n<P>\n\nThe caller is responsible for deallocating any resources associated with\nthe returned element, as appropriate.  For example, if the hash table\nelements are dynamically allocated using <CODE>malloc()</CODE>, then the caller\nmust <CODE>free()</CODE> the element after it is no longer needed.\n</P>\n</DL>\n<P>\n\nThe element passed to the following functions is only used for hashing\nand comparison purposes.  It is never actually inserted into the hash\ntable.  Thus, only key data in the element needs to be initialized, and\nother data in the element will not be used.  It often makes sense to\ndeclare an instance of the element type as a local variable, initialize\nthe key data, and then pass the address of its <CODE>struct hash_elem</CODE> to\n<CODE>hash_find()</CODE> or <CODE>hash_delete()</CODE>.  See section <A HREF=\"pintos_7.html#SEC138\">A.8.5 Hash Table Example</A>, for\nan example.  (Large structures should not be\nallocated as local variables.  See section <A HREF=\"pintos_7.html#SEC107\">A.2.1 <CODE>struct thread</CODE></A>, for more\ninformation.)\n</P>\n<P>\n\n<A NAME=\"IDX173\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct hash_elem *<B>hash_find</B> (struct hash *<VAR>hash</VAR>, struct hash_elem *<VAR>element</VAR>)\n<DD>Searches <VAR>hash</VAR> for an element equal to <VAR>element</VAR>.  Returns the\nelement found, if any, or a null pointer otherwise.\n</DL>\n<P>\n\n<A NAME=\"IDX174\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct hash_elem *<B>hash_delete</B> (struct hash *<VAR>hash</VAR>, struct hash_elem *<VAR>element</VAR>)\n<DD>Searches <VAR>hash</VAR> for an element equal to <VAR>element</VAR>.  If one is\nfound, it is removed from <VAR>hash</VAR> and returned.  Otherwise, a null\npointer is returned and <VAR>hash</VAR> is unchanged.\n<P>\n\nThe caller is responsible for deallocating any resources associated with\nthe returned element, as appropriate.  For example, if the hash table\nelements are dynamically allocated using <CODE>malloc()</CODE>, then the caller\nmust <CODE>free()</CODE> the element after it is no longer needed.\n</P>\n</DL>\n<P>\n\n<A NAME=\"Hash Iteration Functions\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC137\"></A>\n<H3> A.8.4 Iteration Functions </H3>\n<!--docid::SEC137::-->\n<P>\n\nThese functions allow iterating through the elements in a hash table.\nTwo interfaces are supplied.  The first requires writing and supplying a\n<VAR>hash_action_func</VAR> to act on each element (see section <A HREF=\"pintos_7.html#SEC134\">A.8.1 Data Types</A>).\n</P>\n<P>\n\n<A NAME=\"IDX175\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>hash_apply</B> (struct hash *<VAR>hash</VAR>, hash_action_func *<VAR>action</VAR>)\n<DD>Calls <VAR>action</VAR> once for each element in <VAR>hash</VAR>, in arbitrary\norder.  <VAR>action</VAR> must not call any function that may modify the hash\ntable, such as <CODE>hash_insert()</CODE> or <CODE>hash_delete()</CODE>.  <VAR>action</VAR>\nmust not modify key data in elements, although it may modify any other\ndata.\n</DL>\n<P>\n\nThe second interface is based on an &quot;iterator&quot; data type.\nIdiomatically, iterators are used as follows:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>struct hash_iterator i;\n\nhash_first (&amp;i, h);\nwhile (hash_next (&amp;i))\n  {\n    struct foo *f = hash_entry (hash_cur (&amp;i), struct foo, elem);\n    <small>...</small>do something with <I>f</I><small>...</small>\n  }\n</pre></td></tr></table><P>\n\n<A NAME=\"IDX176\"></A>\n</P>\n<DL>\n<DT><U>Type:</U> <B>struct hash_iterator</B>\n<DD>Represents a position within a hash table.  Calling any function that\nmay modify a hash table, such as <CODE>hash_insert()</CODE> or\n<CODE>hash_delete()</CODE>, invalidates all iterators within that hash table.\n<P>\n\nLike <CODE>struct hash</CODE> and <CODE>struct hash_elem</CODE>, <CODE>struct hash_elem</CODE> is opaque.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX177\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> void <B>hash_first</B> (struct hash_iterator *<VAR>iterator</VAR>, struct hash *<VAR>hash</VAR>)\n<DD>Initializes <VAR>iterator</VAR> to just before the first element in\n<VAR>hash</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX178\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct hash_elem *<B>hash_next</B> (struct hash_iterator *<VAR>iterator</VAR>)\n<DD>Advances <VAR>iterator</VAR> to the next element in <VAR>hash</VAR>, and returns\nthat element.  Returns a null pointer if no elements remain.  After\n<CODE>hash_next()</CODE> returns null for <VAR>iterator</VAR>, calling it again\nyields undefined behavior.\n</DL>\n<P>\n\n<A NAME=\"IDX179\"></A>\n</P>\n<DL>\n<DT><U>Function:</U> struct hash_elem *<B>hash_cur</B> (struct hash_iterator *<VAR>iterator</VAR>)\n<DD>Returns the value most recently returned by <CODE>hash_next()</CODE> for\n<VAR>iterator</VAR>.  Yields undefined behavior after <CODE>hash_first()</CODE> has\nbeen called on <VAR>iterator</VAR> but before <CODE>hash_next()</CODE> has been\ncalled for the first time.\n</DL>\n<P>\n\n<A NAME=\"Hash Table Example\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC138\"></A>\n<H3> A.8.5 Hash Table Example </H3>\n<!--docid::SEC138::-->\n<P>\n\nSuppose you have a structure, called <CODE>struct page</CODE>, that you\nwant to put into a hash table.  First, define <CODE>struct page</CODE> to include a\n<CODE>struct hash_elem</CODE> member:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>struct page\n  {\n    struct hash_elem hash_elem; /* Hash table element. */\n    void *addr;                 /* Virtual address. */\n    /* <small>...</small>other members<small>...</small> */\n  };\n</pre></td></tr></table><P>\n\nWe write a hash function and a comparison function using <VAR>addr</VAR> as\nthe key.  A pointer can be hashed based on its bytes, and the <Q><SAMP>&lt;</SAMP></Q>\noperator works fine for comparing pointers:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* Returns a hash value for page <VAR>p</VAR>. */\nunsigned\npage_hash (const struct hash_elem *p_, void *aux UNUSED)\n{\n  const struct page *p = hash_entry (p_, struct page, hash_elem);\n  return hash_bytes (&amp;p-&gt;addr, sizeof p-&gt;addr);\n}\n\n/* Returns true if page <VAR>a</VAR> precedes page <VAR>b</VAR>. */\nbool\npage_less (const struct hash_elem *a_, const struct hash_elem *b_,\n           void *aux UNUSED)\n{\n  const struct page *a = hash_entry (a_, struct page, hash_elem);\n  const struct page *b = hash_entry (b_, struct page, hash_elem);\n\n  return a-&gt;addr &lt; b-&gt;addr;\n}\n</pre></td></tr></table><P>\n\n(The use of <CODE>UNUSED</CODE> in these functions' prototypes suppresses a\nwarning that <VAR>aux</VAR> is unused.  See section <A HREF=\"pintos_11.html#SEC158\">E.3 Function and Parameter Attributes</A>, for information about <CODE>UNUSED</CODE>.  See section <A HREF=\"pintos_7.html#SEC139\">A.8.6 Auxiliary Data</A>, for an explanation of <VAR>aux</VAR>.)\n</P>\n<P>\n\nThen, we can create a hash table like this:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>struct hash pages;\n\nhash_init (&amp;pages, page_hash, page_less, NULL);\n</pre></td></tr></table><P>\n\nNow we can manipulate the hash table we've created.  If <CODE><VAR>p</VAR></CODE>\nis a pointer to a <CODE>struct page</CODE>, we can insert it into the hash table\nwith:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>hash_insert (&amp;pages, &amp;p-&gt;hash_elem);\n</pre></td></tr></table><P>\n\nIf there's a chance that <VAR>pages</VAR> might already contain a\npage with the same <VAR>addr</VAR>, then we should check <CODE>hash_insert()</CODE>'s\nreturn value.\n</P>\n<P>\n\nTo search for an element in the hash table, use <CODE>hash_find()</CODE>.  This\ntakes a little setup, because <CODE>hash_find()</CODE> takes an element to\ncompare against.  Here's a function that will find and return a page\nbased on a virtual address, assuming that <VAR>pages</VAR> is defined at file\nscope:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* Returns the page containing the given virtual <VAR>address</VAR>,\n   or a null pointer if no such page exists. */\nstruct page *\npage_lookup (const void *address)\n{\n  struct page p;\n  struct hash_elem *e;\n\n  p.addr = address;\n  e = hash_find (&amp;pages, &amp;p.hash_elem);\n  return e != NULL ? hash_entry (e, struct page, hash_elem) : NULL;\n}\n</pre></td></tr></table><P>\n\n<CODE>struct page</CODE> is allocated as a local variable here on the assumption\nthat it is fairly small.  Large structures should not be allocated as\nlocal variables.  See section <A HREF=\"pintos_7.html#SEC107\">A.2.1 <CODE>struct thread</CODE></A>, for more information.\n</P>\n<P>\n\nA similar function could delete a page by address using\n<CODE>hash_delete()</CODE>.\n</P>\n<P>\n\n<A NAME=\"Hash Auxiliary Data\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC139\"></A>\n<H3> A.8.6 Auxiliary Data </H3>\n<!--docid::SEC139::-->\n<P>\n\nIn simple cases like the example above, there's no need for the\n<VAR>aux</VAR> parameters.  In these cases, just pass a null pointer to\n<CODE>hash_init()</CODE> for <VAR>aux</VAR> and ignore the values passed to the hash\nfunction and comparison functions.  (You'll get a compiler warning if\nyou don't use the <VAR>aux</VAR> parameter, but you can turn that off with\nthe <CODE>UNUSED</CODE> macro, as shown in the example, or you can just ignore\nit.)\n</P>\n<P>\n\n<VAR>aux</VAR> is useful when you have some property of the data in the\nhash table is both constant and needed for hashing or comparison,\nbut not stored in the data items themselves.  For example, if\nthe items in a hash table are fixed-length strings, but the items\nthemselves don't indicate what that fixed length is, you could pass\nthe length as an <VAR>aux</VAR> parameter.\n</P>\n<P>\n\n<A NAME=\"Hash Synchronization\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC140\"></A>\n<H3> A.8.7 Synchronization </H3>\n<!--docid::SEC140::-->\n<P>\n\nThe hash table does not do any internal synchronization.  It is the\ncaller's responsibility to synchronize calls to hash table functions.\nIn general, any number of functions that examine but do not modify the\nhash table, such as <CODE>hash_find()</CODE> or <CODE>hash_next()</CODE>, may execute\nsimultaneously.  However, these function cannot safely execute at the\nsame time as any function that may modify a given hash table, such as\n<CODE>hash_insert()</CODE> or <CODE>hash_delete()</CODE>, nor may more than one function\nthat can modify a given hash table execute safely at once.\n</P>\n<P>\n\nIt is also the caller's responsibility to synchronize access to data in\nhash table elements.  How to synchronize access to this data depends on\nhow it is designed and organized, as with any other data structure.\n</P>\n<P>\n\n<A NAME=\"4.4BSD Scheduler\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_7.html#SEC100\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_8.html#SEC141\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}