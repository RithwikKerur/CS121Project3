{"url": "https://www.ics.uci.edu/~dvk/code/Grid.html", "content": "<html>\r\n<HEAD>\r\n<TITLE>Source Code | Grid Code</TITLE>\r\n<META NAME=\"description\"\r\n CONTENT = \"Grid Source Code, Continuous Range Queries, Moving Objects, Grid-based\">\r\n<META NAME=\"keywords\"\r\n CONTENT = \"Grid Source Code, Continuous Range Queries, Moving Objects, Grid-based\">\r\n\r\n<style type=\"text/css\">\r\ntable.sample {\r\n    border-width: 1px;\r\n    border-spacing: ;\r\n    border-style: solid;\r\n    border-color: grey;\r\n    border-collapse: collapse;\r\n    background-color: ;\r\n\r\n}\r\ntable.sample th {\r\n    border-width: 0px;\r\n    padding: 10px;\r\n    border-style: none;\r\n    border-color: blue;\r\n    background-color: #faf0e6;\r\n    -moz-border-radius: ;\r\n\r\n}\r\ntable.sample td {\r\n    border-width: 0px;\r\n    padding: 10px;\r\n    border-style: none;\r\n    border-color: blue;\r\n    background-color: ##f5f5f5;\r\n    -moz-border-radius: ;\r\n    font-family: Arial,Helvetica;\r\n    font-size: 11pt;\r\n}\r\n\r\nh2 {\r\nfont-family: \"Arial,Helvetica\";\r\ncolor: #818501;\r\n}\r\n\r\nh3 {\r\nfont-family: \"Arial,Helvetica\";\r\ncolor: #818501;\r\nfont-size: 16pt;\r\n}\r\n\r\nh4 {\r\nfont-family: \"Arial,Helvetica\";\r\nfont-weight: normal;\r\ncolor: #818501;\r\nfont-size: 14pt;\r\n}\r\n\r\nfont {\r\nfont-family: Arial,Helvetica;\r\nfont-size: 11pt;\r\n}\r\n</style>\r\n\r\n</HEAD>\r\n\r\n<body text=\"#000000\" vlink=\"#4f4f4f\" alink=\"#818501\" link=\"#818501\" bgcolor=\"#ffffff\">\r\n\r\n<p align=\"center\">\r\n        <TABLE width=\"800\" border=\"0\" bgcolor=\"#f5f5f5\" cellspacing=\"10\" ID=\"Table1\" class=\"sample\">\r\n        <TBODY>\r\n        <TR>\r\n        <TD>\r\n\r\n<H3>\"Grid\" Source Code</H3>\r\n\r\n<font color=\"grey\">Last updated: 2/13/2013</font> \r\n\r\n<H4>Introduction</H4>\r\n</center>\r\n\r\n<p align =justify >\r\n\r\nOur <font color=\"blue\">\"Grid\"</font> code is a very fast and efficient implementation of a classic problem of handling continuous range queries on top of s large number of moving objects. Even though the code has been implemented some time ago, we are unaware of any other solution that is faster.<br>\r\n<br>\r\nIn the setup of the problem, the assumption is that one or multiple servers track the locations of moving-objects. \r\nThe number of objects can be very high, e.g., millions. The users issue on top of \r\nthe spatial domain a large number of <em>continuous</em> (monitoring) queries. \r\nUnlike one-time queries, continuous queries are executed over a certain period of time, \r\nupdating their results as the situation changes and objects move. For location-based serves, \r\ncontinuous <em>range</em> query (CRQ) is one of the most important query types. \r\nThe main challenge is to develop an <em>efficient</em> and <em>scalable</em> CRQ solution.<br> \r\n<br>\r\nThe traditional approach for processing CRQs is to build an index on the objects (data) \r\nand utilize it for the query processing. In a moving object environment that approach \r\nsuffers from the need for frequent index updates and thereby often results in poor performance.<br>\r\n<br>\r\nTo solve the efficiency and scalability challenges of the problem, we have proposed a \r\nnovel algorithmic technique called Query Indexing (QI). Query Indexing relies on reversing \r\nthe role of queries and data. Namely, a spatial index (QIndex) is built on the continuous queries, \r\nand no index is built on the objects (data). The query results are computed by issuing \r\npoint-queries (i.e., the object locations) to the QIndex and finding matches between objects and queries.<br>\r\n<br>\r\nWe have realized that the CRQ problem can (and should) be solved in-memory for moving objects. \r\nThis is since by keeping only the necessary info in main memory and the rest on disk, \r\nthe data fits into the memory of an average workstation.  We have showed that very different \r\ntypes of indexes perform better in memory. Specifically, we have developed the <b>Grid</b> indexing \r\ntechniques for processing queries in moving object databases, resulting in \r\norders of magnitude of improvement over competing strategies. \r\nNowadays, of course, many research efforts use in-memory grid-based solutins as the norm.<br> \r\n<br>\r\nAn interesting aspect of our solution is that, unlike many other techniques, it does not \r\nimpose many of the common constraints, such as restriction on object speeds and trajectories, \r\nmaking it of much wider applicability.\r\n</p>\r\n\r\n<H4>How to Cite</H4>\r\nWhen using our code please cite it as:<br/>\r\n<br/>\r\n<ol>\r\n    <LI>\r\n      <B>Main memory evaluation of monitoring queries over moving objects.</B><BR>\r\n      <B>Dmitri V. Kalashnikov</B>, S. Prabhakar, and S. Hambrusch.<BR>\r\n      In <EM><font color=blue>Distributed and Parallel Databases</font>, An International Journal (DAPD)</EM>, 15(2):117-135, March 2004<BR>\r\n      [<A href=\"http://www.ics.uci.edu/~dvk/pub/DAPD04_dvk.html\">Download Paper</A>]<BR>\r\n      <BR>\r\n\r\n\r\n\t<LI>\r\n      <B>Efficient evaluation of continuous range queries on moving objects.</B><BR>\r\n      <B>Dmitri V. Kalashnikov</B>, Sunil Prabhakar, Susanne Hambrusch, and Walid Aref.<BR>\r\n      In <EM>Proc. of Int'l Conf. on Database and Expert Systems Applications (<font color=blue>DEXA</font>)</EM>,\r\n      Sep 2-6, 2002.<BR>\r\n      [<A href=\"http://www.ics.uci.edu/~dvk/pub/DEXA02_dvk.html\">Download Paper</A>]<BR>\r\n      <BR>\r\n\r\n</ol>\r\n<br/>\r\nThe above publications describe our Grid-based approach in detail. BibTeX entries for these publications are:\r\n\r\n<pre>\r\n@article{DAPD04::dvk,\r\n   author    = {Dmitri V. Kalashnikov and Sunil Prabhakar and Susanne Hambrusch},\r\n   title     = {Main memory evaluation of monitoring queries over moving objects},\r\n   journal   = {Distributed and Parallel Databases, An International Journal},\r\n   volume    = 15, number = 2, pages = {117--135}, month = mar, year = 2004\r\n} \r\n\r\n@inproceedings{DEXA02::dvk,\r\n   author    = {Dmitri V. Kalashnikov and Sunil Prabhakar and \r\n                Susanne Hambrusch and Walid Aref},\r\n   title     = {Efficient Evaluation of Continuous Range Queries on Moving Objects},\r\n   booktitle = {Proc. of Int'l Conf. on Database and Expert Systems \r\n                Applications (DEXA 2002)},\r\n   year      = {2002}, month = {September 2--6}, address = {Aix en Provence, France}\r\n}\r\n</pre>\r\n\r\n<H4>Downloading Code</H4>\r\n<list>\r\n\t<li>The code can de downloaded from here: \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/Grid_code.zip\">Grid_code.zip</A>] \r\n\t[<A href=\"http://www.ics.uci.edu/~dvk/code/License.txt\">License</A>] \r\n\t<li>The solution is implemented in C++.</li>\r\n\t<li>The code is designed for UNIX in general.</li> \r\n\t<li>The code has been tested under Solaris, Linux, Mac OS X.</li>\r\n\t<li>GCC has been used to compile the code (last tested with GCC 4.7).</li> \r\n\t<li>We recommend using the latest version of GCC C++, as it is often generates faster code.</li>\r\n\t<li>The code is single-threaded and could be sped up by implementing a parallel multi-threaded version.</li>\r\n\t<li>The code will report the <dfn>cycle time</dfn> on each iteration.</li> \r\n\t<li>The cycle time is the time needed to move all the objects and process all the queries.</li>\r\n\t<li>The idea is to minimize the cycle time.</li> \r\n</list>\r\n\r\n<H4>Compiling Code</H4>\r\n<list>\r\n\t<li>Unzip <tt>Grid_code.zip</tt> file. The code is inside <tt>Code</tt> folder. The main file is <tt>test.cpp</tt>.</li>\r\n\t<li><tt>Code</tt> folder and its subfolders will contains <tt>./mak</tt> batch files\r\n\t<li>Edit those <tt>./mak</tt> files: change the path of GCC's C++ compiler (<tt>g++</tt>) to where it is located in your system.</li>  \r\n\t<li>To compile, run <tt>./mak</tt> inside <tt>Code</tt> folder.</li>\r\n\t<li>Compilation will produce executable file called <tt>index</tt>.</li>\r\n\r\n            \r\n<H4>Running Code</H4>\r\n            \r\n<tt>./index nXcell nYcell query_perc query_sz skewed num_point num_query navq_sz nav_stepX</tt>\r\n\r\n            \r\n<H4>Options</H4>\r\n<table width=\"100%\">\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>nXcell</tt></td>\r\n\t\t<td width=\"75%\">The number of cells per X-dimension (nXcell by nYcell grid). Good values to try are: 100, 200, 500, 1000.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>nYcell</tt></td>\r\n\t\t<td width=\"75%\">The number of cells per Y-dimension (nXcell by nYcell grid). Good value is <tt>nYcell=nXcell</tt>.</td>\r\n\t</tr>\r\n\t\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>query_perc</tt></td>\r\n\t\t<td width=\"75%\">Not used, unless the moving-query part is uncommented in code. Needed to specify the percentage of queries that will move on each iteration. Set it to 0 (zero).</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>query_sz</tt></td>\r\n\t\t<td width=\"75%\">Specifies query size, e.g., when it is set to 0.01, all queries will be of size 0.01 x 0.01. </td>\r\n\t</tr>\r\n\t\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>skew</tt></td>\r\n\t\t<td width=\"75%\">Parameter <tt>skew</tt> can be set to 0, 1, or 2 to mean (see papers above for the exact meaning):<font size=4><br><br></font>\r\n\t\t\t<tt>0</tt> - uniform: code will generate points and queries that are distributed uniformly in [0,1].<br>\r\n\t\t\t<tt>1</tt> - normal : code will generate points and queries that are distributed normally in [0,1].<br>\r\n\t\t\t<tt>2</tt> - hyper-skew: code will generate points and queries that are hyper-skewed in [0,1].\r\n\t\t</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>num_point</tt></td>\r\n\t\t<td width=\"75%\">The number of points to generate in thousands, e.g. 25 means 25,000.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>num_query</tt></td>\r\n\t\t<td width=\"75%\">The number of queries to generate in thousands, e.g. 15 means 15,000.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>navq_sz</tt></td>\r\n\t\t<td width=\"75%\">Not used, unless the moving-query part is uncommented in code. Needed to specify the size of the navigational (i.e., moving) query. Set it to 0.01.</td>\r\n\t</tr>\r\n\t<tr height=40>\r\n\t\t<td width=\"25%\"><tt>nav_stepX</tt></td>\r\n\t\t<td width=\"75%\">Not used, unless the moving-query part is uncommented in code. Needed to specify the step each navigational (i.e., moving) query makes. Set it to 0.001.</td>\r\n\t</tr>\r\n</table>\r\n            \r\n            \r\n\r\n<H4>Examples</H4>\r\n1) Running the code for 1 Million moving objects and 100,000 continuos range queries of size 0.01x0.01 each using 1000x1000 grid.<br>  \r\n<br>\r\n<tt>./index 1000 1000 0 0.01 0 1000 100 0.001 0.0001</tt><br>\r\n            <br>\r\n            <br>\r\n<br>\r\n2) Running the code for 500,000 moving objects and 25,000 continuos range queries of size 0.01x0.01 each using 100x100 grid.<br>  \r\n<br>\r\n<tt>./index 100 100 0 0.01 0 500 25 0.001 0.0001</tt><br\r\n\r\n<IMG SRC=\"https://students.ics.uci.edu/~dvk/fig.cgi?Grid_code\" width=1 height=1>\r\n</p>\r\n<BR>\r\n<BR>\r\n<A href=\"http://www.ics.uci.edu/~dvk/index.html\">Back to Kalashnikov's homepage</A>\r\n<BR>\r\n<BR>\r\n<center><font face=\"Arial,Helvetica\" style=\"font-SIZE: 8pt\" color=\"gray\"> Copyright &copy; 2013 Dmitri V. Kalashnikov. All Rights Reserved.</font></center>\r\n</html> ", "encoding": "ascii"}