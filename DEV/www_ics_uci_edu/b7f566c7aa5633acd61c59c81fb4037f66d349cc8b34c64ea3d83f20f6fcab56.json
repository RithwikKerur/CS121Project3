{"url": "https://www.ics.uci.edu/~dsm/compose/compose_design.html", "content": "<html>\r\n\r\n<head>\r\n<meta http-equiv=\"Content-Language\" content=\"en-us\">\r\n<meta name=\"GENERATOR\" content=\"Microsoft FrontPage 5.0\">\r\n<meta name=\"ProgId\" content=\"FrontPage.Editor.Document\">\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\">\r\n<title>Introduction</title>\r\n</head>\r\n\r\n<body>\r\n\r\n<table border=\"0\" cellpadding=\"5\" cellspacing=\"5\" style=\"border-collapse: collapse\" id=\"AutoNumber1\">\r\n  <tr>\r\n    <td align=\"center\">\r\n    <table border=\"0\" cellpadding=\"5\" cellspacing=\"5\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber9\">\r\n      <tr>\r\n        <td><img border=\"0\" src=\"t1.jpg\" width=\"114\" height=\"62\"></td>\r\n        <td><img border=\"0\" src=\"chead.jpg\" width=\"275\" height=\"55\"></td>\r\n        <td><img border=\"0\" src=\"t2.jpg\" width=\"114\" height=\"62\"></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n    <a name=\"top\"> </a>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber3\">\r\n      <tr>\r\n        <td>&nbsp;</td>\r\n      </tr>\r\n      <tr>\r\n        <td bgcolor=\"#CCFFCC\"><a href=\"#intro\">Introduction</a> | <a href=\"#tlam\">TLAM</a> | \r\n    <a href=\"#reso\">Resource \r\n    Management</a> | <a href=\"#refl\">Reflective Communication</a> | \r\n    <a href=\"#arch\">Architecture</a></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    </a>\r\n  </tr>\r\n  <tr>\r\n    <td bordercolor=\"#FFFFF2\">\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber4\">\r\n      <tr>\r\n        <td bgcolor=\"#FFFFF2\">\r\n    <a name=\"intro\"><b>\r\n    <font size=\"5\" face=\"Times New Roman\">\r\n    Introduction</font></b></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td bordercolor=\"#FFFFF2\">&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"justify\"><font face=\"Times New Roman\">CompOSE|Q is a customizable and \r\n    safe distributed systems middleware infrastructure, built to provide cost \r\n    effective QoS-based distributed resource management. It allows concurrent \r\n    execution of multiple resource management policies in a distributed system \r\n    in a safe and correct manner. </font>\r\n    <span style=\"font-family: Times New Roman\">This allows safe integration of \r\n    resource management mechanisms for services such mobility, load balancing, \r\n    fault tolerance and end-to-end QoS management. It is based on a two level \r\n    meta-architectural model that facilitates specifying and reasoning about the \r\n    composability of multiple resource management services in Open distributed \r\n    systems. The CompOSE|Q reflective framework uses Actors, a distributed \r\n    computing paradigm that uses a model of concurrent active objects </span>\r\n    <font face=\"Times New Roman\">and has a built-in notion of encapsulation and \r\n    interaction among the concurrent components of an Open Distributed System</font><span style=\"font-family: Times New Roman\">.\r\n    </span><font face=\"Times New Roman\">In the actor paradigm, the universe \r\n    contains computational agents called <i>actors</i>, distributed over a \r\n    network. Traditional passive objects encapsulate state and a set of \r\n    procedures that manipulate the state; actors extend this by encapsulating a \r\n    thread of control as well. Each actor potentially executes in parallel with \r\n    other actors and may communicate with other actors via asynchronous message \r\n    passing. Using Actors, we define a meta-architecture framework that permits \r\n    customization of resource management mechanisms such as placement, \r\n    scheduling and synchronization.</font></p>\r\n    <p><span style=\"font-family: Times New Roman\">The CompOSE|Q<b> </b>architecture \r\n    contains:</span></p>\r\n    <ul type=\"square\">\r\n      <li><span style=\"font-family: Times New Roman\">The basic composable core \r\n      services - Remote Creation, Distributed Snapshot and Directory Services \r\n      with interaction constraints that ensure their concurrent execution with \r\n      each other and other meta level services.</span></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul type=\"square\">\r\n      <li><span style=\"font-family: Times New Roman\">Services built using core \r\n      services - Actor migration, replication of services and data, actor \r\n      scheduling, distributed garbage collection, name services etc. Each of \r\n      these services has its own interface definitions and interaction \r\n      constraints.</span></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul type=\"square\">\r\n      <li><span style=\"font-family: Times New Roman\">QoS enforcement mechanisms.</span></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td><p align=\"right\">| <a href=\"#top\">back to top</a> \r\n    | </td>\r\n  </tr>\r\n  <tr>\r\n    </a>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber5\">\r\n      <tr>\r\n        <td bgcolor=\"#FFFFF2\">\r\n    <a name=\"tlam\">\r\n    <span style=\"font-family: Times New Roman; font-weight: 700\"><font size=\"5\">\r\n    The Two Level Meta Architectural Model (TLAM)</font></span></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"justify\"><span style=\"font-family: Times New Roman\">Ensuring \r\n    correctness in a purely reflective model involves reasoning about system \r\n    level interactions by characterizing the semantics of shared distributed \r\n    resources and understanding what correctness of the overall system means.&nbsp; \r\n    The <b>TLAM </b>(Two Level Actor Machine) model was presented as a first \r\n    step towards providing a formal semantics for specifying and reasoning about \r\n    properties of and interactions between components of ODSs. In the <b>TLAM</b>, \r\n    a system is composed of two kinds of actors, <b><i>base actors</i></b> and\r\n    <b><i>meta actors</i></b>, distributed over a network of processing nodes. \r\n    Base level actors carry out application level computation, while meta-actors \r\n    are part of the runtime system, which manages system resources and controls \r\n    the runtime behavior of the base level.&nbsp; Meta-actors communicate with each \r\n    other via message passing as do base level actors, but they may also examine \r\n    and modify the state of the base actors located on the same node.&nbsp; </span>\r\n    <span style=\"font-family: Times New Roman; layout-grid-mode: line\">The TLAM \r\n    uses reification (base object state as data at the meta object level) and \r\n    reflection (modification of base object state by meta objects) with support \r\n    for implicit invocation of meta objects in response to changes of base level \r\n    state. It provides for full actor-style interaction of meta level objects.\r\n    </span><span style=\"font-family: Times New Roman\">In the TLAM model, meta-level \r\n    controllers define protocols and mechanisms that customize various aspects \r\n    of distributed systems management. In practice, multiple system and \r\n    application activities occur concurrently in a distributed system, e.g. \r\n    scheduling, protocol processing, stream synchronization etc., and can \r\n    therefore interfere with each other. </span></p>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber2\">\r\n      <tr>\r\n        <td><img border=\"0\" src=\"coreserv.jpg\" width=\"339\" height=\"345\"></td>\r\n        <td>&nbsp;</td>\r\n        <td>\r\n        <p align=\"justify\">\r\n    <font face=\"Times New Roman\">To ensure non-interference and manage the \r\n        complexity of reasoning about components of ODSs in general, our \r\n        strategy is to identify key system services where non-trivial \r\n        interactions between the application and system occur, i.e. base-meta \r\n        interactions.&nbsp; We refer to these key services as <i>core services</i>.&nbsp; \r\n        Core services are used in specifying and implementing more complex \r\n        activities within the framework as purely meta-level interactions.&nbsp; \r\n        The development of suitable non-interference requirements allows us to \r\n        reason about the composition of multiple system services; these services \r\n        have constraints that must be obeyed to maintain composability (i.e. \r\n        safe concurrent execution). We use commonly observed patterns in \r\n        distributed systems to identify three meta level core activities (See \r\n        Figure): Remote Creation (for migration, replication &amp; load balancing), \r\n        Distributed Snapshot (for check-pointing, distributed garbage \r\n        collection, etc.) and Directory Services ( for access control, resource \r\n        discovery and group communication).</font></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"right\">| <a href=\"#top\">back to top</a> | </td>\r\n  </tr>\r\n  <tr>\r\n    </a>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber6\">\r\n      <tr>\r\n        <td bgcolor=\"#FFFFF2\">\r\n    <a name=\"reso\">\r\n    <span style=\"font-family: Times New Roman; font-weight: 700\"><font size=\"5\">\r\n    The Resource Management Services</font></span></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"justify\"><span style=\"font-family: Times New Roman\">Implementation of \r\n    sophisticated policies and mechanisms for QoS management is made possible by \r\n    providing support for common services in CompOSE|Q. For instance, object \r\n    scheduling mechanisms use the basic remote creation core service to assign \r\n    newly created objects/actors on nodes with adequate resources.&nbsp; Using \r\n    generalized state capture facilities, we are developing a checkpointing \r\n    service for capturing causal orders of executions in the system that can be \r\n    used for monitoring and debugging distributed computations. </span>\r\n    <font face=\"Times New Roman\">A state broadcast mechanism is used to implement a \r\n    clock synchronization service, which informs nodes about a global time value \r\n    that can be used for time related services. </font></p>\r\n    <p>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul type=\"circle\">\r\n      <li>\r\n      <p class=\"Textbody\" align=\"justify\"><font face=\"Times New Roman\"><b>\r\n      Remote creation</b> : Remote creation is the process \r\n      by which actor creation occurs on a specified node other than the node \r\n      from which creation is being initiated.&nbsp; Remote creation is a basic \r\n      facility that can be used in other resource management activities like \r\n      load-balancing, replication and migration.&nbsp; By encapsulating the \r\n      interactions between the application and system level actors within the \r\n      remote creation service, we can state requirements that ensure safe and \r\n      correct composition of other resource management activities with remote \r\n      creation. In a real TLAM based implementation, the control activities of \r\n      remote creation are managed by remote creation meta-actors (RCM) residing \r\n      on every node in the system. A remote creation request has four parameters \r\n      - a description of the fragment <i>desc</i> to be migrated, the remote \r\n      node <i>(N),</i> any initial state the <i>desc</i> has to be set to and \r\n      the initiating-actor '</font><span style=\"font-family: Times New Roman\">b</span><font face=\"Times New Roman\">'. \r\n      The initiator actor '</font><span style=\"font-family: Times New Roman\">b</span><font face=\"Times New Roman\">' \r\n      is maintained by the RCM to ensure composability with other meta-level \r\n      services[V98]. If the requester needs to know that the request has been \r\n      completed, or the names of some of the newly created actors, then this can \r\n      be achieved by specifying appropriate messages as part of the requested \r\n      fragment, and observing their delivery.</font></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul type=\"circle\">\r\n      <li>\r\n      <p align=\"justify\"><b>\r\n      <span style=\"font-family: Times New Roman; layout-grid-mode: line\">\r\n      Distributed Snapshot Services:</span></b><span style=\"font-family: Times New Roman; layout-grid-mode: line\"> \r\n      Global properties like the number of application-actors, the current \r\n      reachability graph of distributed actors, number of messages being \r\n      processed and task queue sizes help in making runtime decisions like load \r\n      balancing, migration and garbage collection, leading to efficient runtime \r\n      management of a distributed system.&nbsp; To fully represent the global state \r\n      of the distributed system, we need a mechanism for recording the state of \r\n      all nodes including the portion of node state being communicated in the \r\n      network channels.&nbsp; As state information is accessible explicitly only in \r\n      nodes, a snapshot mechanism must ensure that node state information in \r\n      channels are </span><font face=\"Times New Roman\">\r\n      <span style=\"layout-grid-mode:line\">recorded at some node in the system \r\n      (possibly the target node itself). The snapshot mechanisms we have devised \r\n      are such that application-level computation and system level services \r\n      proceed concurrently with the snapshot, thereby preserving application and \r\n      service semantics. In order to initiate snapshot recording on every node \r\n      and force messages in channels to reach a node, we have defined two wave \r\n      protocols for message propagation that (a) visit all nodes exactly once, \r\n      capturing node-resident information and (b) traverse all links in the \r\n      system exactly once forcing messages on channels to reach nodes (where \r\n      their state can be recorded). </span></font></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul type=\"circle\">\r\n      <li>\r\n      <p align=\"justify\"><b><span style=\"font-family: Times New Roman\">\r\n      Migration:&nbsp; </span></b>\r\n      <span style=\"font-family: Times New Roman\">By using remote creation as the \r\n      basis for migration, we have ensured composability of migration with other \r\n      meta-level services such as reachability snapshots and distributed \r\n      check-pointing. Migration is the process by which actors move from one \r\n      node to another.&nbsp; The migration service allows for relocation of actors \r\n      for easier access, availability and load balancing.&nbsp; A migration request \r\n      is given by a pair (&#945;,</span><font face=\"Times New Roman\">n)</font><span style=\"font-family: Times New Roman\">, \r\n      where &#945; is the actor to be migrated, and n is the destination node.&nbsp; This \r\n      is interpreted as a request to move the computation carried out by &#945; to \r\n      the node n. In order to state explicitly invariants maintained by the \r\n      system during the migration process, we classify the migration process \r\n      into 3 phases with respect to the actor being migrated and the node to \r\n      which it is being migrated. The first phase is the initiation phase and \r\n      specifies the state of the system when the migration request received can \r\n      be processed. It determines the computation to be migrated by suspending \r\n      the computation of the actor and noting its current description. In the \r\n      second configuration the actual actor migration is performed using the RC \r\n      service. The last configuration finalizes the migration process and \r\n      establishes transparent access to the migrated actor.</span></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul type=\"circle\">\r\n      <li>\r\n      <p align=\"justify\"><b><span style=\"font-family: Times New Roman\">QoS \r\n      Brokerage Service: </span></b><span style=\"font-family: Times New Roman\">\r\n      This work illustrates the use of TLAM services in the design of mechanisms \r\n      and policies needed to enforce QoS constraints in the actor-based runtime \r\n      environment. We extend the basic meta-architectural framework to provide \r\n      QoS based services to applications.&nbsp; The base level component of the meta \r\n      architecture implements the functionality of the distributed session and \r\n      deals with (a) data, which includes objects of varying media, types, e.g., \r\n      video and audio files and (b) requests to access this data via sessions. \r\n      The meta-level component deals with the coordination of multiple requests \r\n      and sharing of existing resources among multiple requests.&nbsp; To provide \r\n      coordination at the highest level and perform admission control for new \r\n      incoming sessions, a meta-level entity called the <i>QoS broker</i> is \r\n      being developed. The organization of the meta-level services in CompOSE|Q \r\n      is illustrated in the Figure.</span></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td valign=\"top\">\r\n    <img border=\"0\" src=\"Qosbroker.jpg\" align=\"left\" width=\"600\" height=\"307\"></td>\r\n  </tr>\r\n  <tr>\r\n    <td valign=\"top\">\r\n    <p align=\"justify\"><font face=\"Times New Roman\">The two main functions of \r\n    the QoS broker are (a) data management and (b) request management. The <i>\r\n    data management</i> component decides the placement of data in the \r\n    distributed system, i.e. it decides when and where to create additional \r\n    replicas of data. It also determines when additional replicas of data actors \r\n    are no longer needed and can be garbage collected/dereplicated.&nbsp; We \r\n    implement adaptive admission control mechanisms in the \r\n    request-scheduling module that assigns requests to servers and ensures \r\n    cost-effective utilization of resources. The <i>message-scheduling</i> \r\n    module ensures QoS constraint satisfaction of requests that have already \r\n    been initiated. The data and request management functions in turn require \r\n    auxiliary services such as clock synchronization, replication, dereplication \r\n    and migration.&nbsp; So far, we have focused on the following services:<i> </i></font>\r\n    <ul>\r\n      <li>\r\n    <p align=\"justify\"><font face=\"Times New Roman\"><i>Replication:</i> to \r\n    replicate data and request actors using adaptive and predictive techniques \r\n    for selecting where, when and how fast replication should proceed.</font></li>\r\n      <li>\r\n    <p align=\"justify\"><font face=\"Times New Roman\"><i>Dereplication:</i> to dereplicate/garbage-collect \r\n    data or request actors and optimize utilization of distributed storage based \r\n    on current system load and expected future demands for the object.</font></li>\r\n      <li>\r\n    <p align=\"justify\"><font face=\"Times New Roman\"><i>Migration:</i> \r\n    to migrate data or requests for load balancing, availability and locality.&nbsp; \r\n    The interaction of migration with timing based QoS constraints is an \r\n    interesting issue since it can introduce playback jitter in MM applications \r\n    caused by explicit teardown and re-establishment of network connections.</font></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"justify\"><font face=\"Times New Roman\">The auxiliary services described above are \r\n    developed using one or more of the core services - remote creation, \r\n    distributed snapshot and the directory service.&nbsp;\r\n    <span style=\"layout-grid-mode:line\">In order to ensure non-interference \r\n    among the auxiliary services that are used to provide QoS, the specific \r\n    mechanisms implemented for placement and scheduling must be designed not to \r\n    conflict with each other. Currently, placement and dereplication operate on \r\n    the basis of a (conservative) snapshot of the current resource allocation \r\n    and use.&nbsp; The placement and dereplication services do not consider the exact \r\n    times at which requests arrive; in contrast, an adaptive request scheduling \r\n    process makes decisions based on the exact arrival times of requests. \r\n    However, without appropriate constraints on the usage of these services, \r\n    inconsistencies can arise due to their interaction.&nbsp; The broker coordinates \r\n    the service interaction by constraining the behavior of the auxiliary \r\n    placement and scheduling services.&nbsp; For instance, the dereplication service \r\n    does not dereplicate a replica that the request scheduling process is making \r\n    an assignment to. Furthermore a replica assigned to an active request should \r\n    not be physically dereplicated.&nbsp; The broker also ensures that the \r\n    dereplication and placement metalevel services do not cancel one another \r\n    out.&nbsp; While the interaction between dereplication and placement is not a \r\n    functional correctness issue, it has to do with cost-effective performance \r\n    of the overall system. </span></font></td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"right\">| <a href=\"#top\">back to top</a> | </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber7\">\r\n      <tr>\r\n        <td bgcolor=\"#FFFFF2\">\r\n    <b>\r\n    <a name=\"refl\">\r\n    <font size=\"5\">\r\n    The Reflective Communication Service Architecture</font></a></b></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p class=\"MsoPlainText\" align=\"justify\"><font face=\"Times New Roman\">In order \r\n    to provide correct composition of communication services to QoS-based \r\n    applications in a transparent and scalable fashion, while ensuring \r\n    correctness of basic middleware services in a meta level architecture for \r\n    distributed resource management (<i>e.g.</i> garbage collection, remote \r\n    creation), the TLAM model is extended with a composable reflective \r\n    communication framework (CRCF), which customizes the base level \r\n    communication services among a group of objects as follows . Each base level \r\n    actor has a meta level actor, called <i>messenger</i>, which serves as the \r\n    customized and transparent mail queue for that base level actor.&nbsp; There is \r\n    one <i>communication manager</i> in every node of the distributed system, \r\n    which implements and controls the correct composition of communication \r\n    services specified by the messenger. The messenger has four message queues: \r\n    the up and down queues are used to communicate with its base level actor, \r\n    serving as the actor\u2019s send buffer and customized mail queue respectively, \r\n    while the in and out queues are used for interaction with the communication \r\n    manager, requesting communication services that satisfy QoS constraints. The \r\n    up and down queues hold raw messages from and to base level actors, while \r\n    the out and in queues hold processed messages, which are messages with the \r\n    required protocols enforced. Furthermore, the communication manager has a \r\n    set of communication protocol actors, each of them implementing a particular \r\n    communication service provided by the framework (<i>e.g.</i> reliable \r\n    protocol, in-order protocol). </font>\r\n    <span style=\"font-family: Times New Roman\">Communication services can be added \r\n    (<i>plugged in</i>) or removed (<i>plugged out</i>) dynamically without side \r\n    effects. The above scheme allows us to abstract a core set of communication \r\n    services and share it between the different messengers on a node, \r\n    simplifying the synchronization and composition process, while encouraging \r\n    separation of concerns in the process of message transmission and reception. \r\n    In order to maintain accurate semantics and provide an efficient \r\n    implementation of the architecture, the communication manager implements a \r\n    set of meta level representatives, called <i>pool-actors</i>. At any \r\n    instance, the pool-actor handles the communication services requested by a \r\n    messenger for an individual message.&nbsp; In other words, every message \r\n    requiring communication services is assigned a pool actor.&nbsp; The pool actor \r\n    assures the correct order of composition of required services and provides a \r\n    coordination mechanism between the messenger that requires the services and \r\n    the protocols that provide it. This concept of reusable pool-actors is an \r\n    efficient way to handle the service request of each messenger without having \r\n    to pay the bottleneck associated with the centralization of the services in \r\n    the node communication manager.&nbsp; In summary, the notion of pool actors \r\n    provides separation of concerns and manageable concurrency in the \r\n    communication process.</span></p>\r\n    <p align=\"right\">| <a href=\"#top\">back to top</a> | </td>\r\n  </tr>\r\n  <tr>\r\n    </a>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" style=\"border-collapse: collapse\" bordercolor=\"#111111\" id=\"AutoNumber8\">\r\n      <tr>\r\n        <td bgcolor=\"#FFFFF2\">\r\n    <a name=\"arch\"><b>\r\n    <font face=\"Times New Roman\" size=\"5\">\r\n    CompOSE|Q Runtime Architecture</font></b></td>\r\n      </tr>\r\n    </table>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p class=\"Standard\" style=\"text-align:justify\">\r\n    <span style=\"font-family: Times New Roman\">The current middleware environment \r\n    has been implemented using Java, due to its many favorable features such as \r\n    its portability across a wide variety of platforms, wide user base and \r\n    support for flexibility through introspection. In our approach, we suitably \r\n    'constrain' the Java programming language to achieve Actor semantics. In \r\n    order to assist the three core services in achieving their task easily and \r\n    efficiently, the run-time system consists of:</span></p>\r\n    <ol>\r\n      <li>\r\n      <p class=\"Standard\" style=\"text-align:justify\">\r\n      <font face=\"Times New Roman\">A \r\n      NodeManager that manages and coordinates various components on a node.</font></li>\r\n      <li>\r\n      <p class=\"Standard\" style=\"text-align:justify\">\r\n      <font face=\"Times New Roman\">A \r\n      NodeInfoManager that manages information needed by the local actors and \r\n      interfaces with the directory service.</font></li>\r\n      <li>\r\n      <p class=\"Standard\" style=\"text-align:justify\">\r\n      <font face=\"Times New Roman\">A \r\n      communication sub-system that handles messaging between actors.</font></li>\r\n    </ol>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <img border=\"0\" src=\"cpose_des1.jpg\" align=\"left\" width=\"750\" height=\"489\"><p>&nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    &nbsp;</td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul>\r\n      <li>\r\n      <p class=\"Standard\" style=\"text-align:justify\"><b>\r\n      <span style=\"font-family: Times New Roman\">The NodeManager:</span></b><span style=\"font-family: Times New Roman\"> \r\n      Each node running CompOSE|Q has one NodeManager to manage actors on that \r\n      node, as well as to start-up and shutdown various other modules of the \r\n      run-time system.&nbsp; When a new actor is created it registers itself with the NodeManager and is identified by an Actor ID (aid).&nbsp; The NodeManager \r\n      enters the new actor into a local-table which helps keep track of the \r\n      actor for activities such as node checkpointing and node shutdown and \r\n      notifies the MessageQmanager entity, which allocates a message queue that \r\n      serves as the \u201cin\u201d Queue for the actor. The MessageQManager is responsible \r\n      for managing mail queues for all actors on a node. To start CompOSE|Q on a \r\n      node, the NodeManager has to be started first.&nbsp; It in turn, initiates the \r\n      various other modules and communication components.</span></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul>\r\n      <li>\r\n      <p class=\"Standard\" style=\"text-align:justify\"><b>\r\n      <span style=\"font-family: Times New Roman\">The NodeInfoManager:<i> </i>\r\n      </span></b><span style=\"font-family: Times New Roman\">The NodeInfoManager is \r\n      a repository of information as well as an interface to the main directory \r\n      service in the distributed architecture. Currently, the NodeInfoManager \r\n      implements basic functionality to: 1) Register an actor with the directory \r\n      service so that it is accessible to all other nodes 2) Search for a \r\n      particular actor to find out which node that actor is currently on and 3) \r\n      Search for an actor object given the class name (a rudimentary naming \r\n      service). </span><font face=\"Times New Roman\">The NodeInfoManager has a \r\n      local-table, which contains references to all local actors (updated and \r\n      maintained by the NodeManager) and a remote-actor cache that contains \r\n      information about recently accessed remote actors.</font></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <ul>\r\n      <li>\r\n      <p align=\"justify\"><b><span style=\"font-family: Times New Roman\">The \r\n      Communication Subsystem:<i> </i></span></b>\r\n      <span style=\"font-family: Times New Roman\">The communication transport layer \r\n      and the CRCF module(above the transport layer), together compose the node \r\n      communication subsystem. The message transport layer provides a framework \r\n      for sending the outgoing messages to the appropriate node (routing) and \r\n      resolving incoming messages to their appropriate actor queues \r\n      (message-resolution). The CRCF module is responsible for the \r\n      implementation of communication services (and their composition). \r\n      Separation of these layers allows for independent customization of \r\n      protocol implementations and the messaging runtime. This facilitates \r\n      correct composition of protocols without interfering with the runtime \r\n      communication semantics. </span><font face=\"Times New Roman\">The \r\n      communication transport layer consists of the following components: a <i>\r\n      Router</i>, a <i>Postman</i> and a <i>RemoteMessageReceiver</i>. <i>&nbsp;</i>The \r\n      transport layer maintains two message queues on a node for incoming and \r\n      outgoing messages (on that node) called <i>SendPot</i> and <i>ReceivePot</i> \r\n      respectively. The <i>Router</i> consults the<i> NodeInfoManager</i> to \r\n      obtain the current location (node) of the target actor. If the location of \r\n      the target actor is local (i.e. on the same node), the <i>Router</i> puts \r\n      the message directly into the node's <i>ReceivePot</i>. Otherwise, it \r\n      sends the message to the remote node. The <i>RemoteMessageReceiver</i> (RMR) \r\n      on the target node extracts the incoming message and puts it into the \r\n      node's ReceivePot.&nbsp; The <i>Postman</i> then picks up the message and adds \r\n      it to the target actor's \u201cin\u201d Queue. </font>\r\n      <span style=\"font-family: Times New Roman\">The communication manager is \r\n      instantiated in each node during system startup.<span style=\"color:black\"> \r\n      When an actor is created and protocol composition services are not desired \r\n      or required </span></span><font face=\"Times New Roman\">\r\n      <span style=\"color: black\">ts <i>messenger</i> is not created and</span> \r\n      the actor sends and receives raw messages using the transport layer<span style=\"color:black\">. \r\n      When flexible communication is required or desired, an independent <i>\r\n      messenger</i> is created for every base level actor and the entire CRCF \r\n      functionality is invoked. The overhead of the CRCF module is minimized in \r\n      case of communications with no protocols attached. In this scenario, we \r\n      tunnel raw messages through the actor's messenger directly to the \r\n      transport layer.</span></font></li>\r\n    </ul>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>\r\n    <p align=\"right\">| <a href=\"#top\">back to top</a> | </td>\r\n  </tr>\r\n  <tr>\r\n    <td>&nbsp;</td>\r\n  </tr>\r\n</table>\r\n\r\n</body>\r\n\r\n</html>", "encoding": "Windows-1252"}