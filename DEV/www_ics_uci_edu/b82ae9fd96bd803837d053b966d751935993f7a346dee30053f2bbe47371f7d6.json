{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/morejava/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>More Java</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>More Java</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III\r\n<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this short lecture, we will clarify some points about the meaning of\r\n    <b>final</b> in variable declarations, introduce two operators used in\r\n    <b>conditional expressions</b> and discuss <b>short-circuit</b> evaluation\r\n    in logical operators\r\n  All these features allow us to write more compact and understandable code,\r\n    once we understand these language features.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Final -->\r\n\r\n<a name=\"Final\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>More on final</b></td>\r\n<td width =\"80%\">\r\n  In the real world, a constant is a named value that never changes. \r\n  Examples of constants are &pi; (pi), e, the speed of light, the mass of a\r\n    proton (we think?) etc.\r\n  In programs, a constant is a variable whose value never changes within its\r\n    scope (i.e., during the time the variable is declared).\r\n  This is a slightly more liberal definition.\r\n  So, any real-world constant is a program constant, but a program constant\r\n    doesn't have to be a real-world constant.\r\n  <p>\r\n  For example, to compute a mortgage, a program uses the current interest rate.\r\n  This value is not a real-world constant, because its value changes daily.\r\n  But, once the program starts computing the mortgage payments, the current\r\n    interest rate is a constant in that program.\r\n  <p>\r\n  We have seen that we can declare local variables as constants, by using the\r\n     <b>final</b> access modifier (recall that <b>final</b> restricts how we\r\n     can access the variable).\r\n  When a variable is declared <b>final</b> it must be intialized, its value\r\n    can be examined in subsequent expressions, but its value can never be\r\n    changed by a state-change operator.\r\n  We will use the terms <b>constant</b> and <b>final variable</b> \r\n    interchangably.\r\n  If we write code that tries to change a constant, the Java compiler detects\r\n    and reports a syntax constraint error.\r\n  In fact, we can use this rule to get some interesting information from the\r\n    compiler: every statement where we change the state of a variable.\r\n  We do so by changing it from a variable to a constant, and then let the \r\n    compiler locate all the \"errors\" where we try to change its state.\r\n  <p>\r\n  When we write programs, we should declare constants instead of using \"magic\"\r\n     literals.\r\n  The names of the constants will help us remember what the constant means\r\n    (without having to see its values: what is <b>6.022141E23</b> or\r\n    <b>2.99792458E8</b>?).\r\n  Using constants instead of variables makes our programs less prone to error:\r\n    if we use a variable, we might accidentally change what value it stores\r\n    -this is impossible with constants.\r\n  <p>\r\n  Using constants also makes it easier to change our programs: in the upcoming\r\n    Rocket program we can write <b>.01</b> in lots of places, but if we\r\n     needed to change that value to <b>.001</b> (for a more accurate\r\n     simulation), we might have to search our code carefully to make the\r\n     correct changes (there might be other <b>.01</b>s in our program not \r\n    refering to the time increment).\r\n  If instead we declared <b>final double dT = .01;</b> (here <b>dT</b>\r\n    stands for delta/change-in time) in our program, and then used the\r\n    constant <b>dT</b> throughout our code, to change this value\r\n    requires editing just this one line of code, and then recompiling the\r\n    program.\r\n  <p>\r\n  Although use of <b>final</b> in the example below may be a bit confusing, it\r\n     is perfectly legal.\r\n  <pre><b>  int count = 0;\r\n  int sum   = 0;\r\n  for (;;) {\r\n    final int score = Prompt.forInt(\"Enter score (-1 to terminate)\");\r\n    if (score == -1)\r\n      break;\r\n    count++;\r\n    sum += score;\r\n  }\r\n  System.out.println(\"Average = \" + sum/count);</b></pre>\r\n  In this example, <b>score</b> is declared <b>final</b> and indeed, its value\r\n    (once initialized) never changes in its scope: the block in which\r\n    <b>score</b> is declared.\r\n  When the block finishes, <b>score</b> becomes undeclared; then the <b>for</b>\r\n    loop re-executes the block, redeclaring and reinitializing the <b>score</b>\r\n    constant all over again.\r\n  So, our use of <b>score</b> meets all the technical requirements for a \r\n    constant.\r\n  Some programmers would pronounce this code excellent; others would say that\r\n    indicating <b>final</b> is not worth it.\r\n  What do you think?\r\n  <p>\r\n  Most constants specify an initializer in their declaration; but surprsingly,\r\n    this is not necessary.\r\n  If the initializer is omitted, it is called a <b>blank final</b> variable.\r\n  The Java compiler is smart enought to ensure\r\n    <ul>\r\n      <li>a blank final variable is eventually assigned an initial value\r\n      <li>a blank final variable is not used until after it is assigned a value\r\n      <li>a blank final variable it is never reassigned another one value.\r\n    </ul>\r\n  So, it is OK to write code like<pre><b>  final double d;     //blank final\r\n  ...code...          //cannot refer to the constant d\r\n  if (whatever)       //value is assigned to constant d in one if branch\r\n    d = ...\r\n  else\r\n    d = ...\r\n  ...more code...     //care refer to but not change the constant d</b></pre>\r\n  Any further attempt to store a value into <b>d</b> will be detected and\r\n    reported as an error by the Java compiler.\r\n  When we learn how to write instance variables in classes, we will see more\r\n    reasonable uses of blank final.\r\n  <!---\r\n  <p>\r\n  Should be in object discussion: see problem too.\r\n  Finally, recall that when we declare a constant for a reference type, we must\r\n    be a bit careful of its meaning.\r\n  A reference variable stores a reference (as its state) which refers to an\r\n     object (which stores its own state).\r\n  So, using <b>final</b> with a reference variable DOES mean that once we store\r\n    a reference into that variable, it always refers to the same object.\r\n  It DOES NOT mean that the state of the object remains unchanged: we can still\r\n    call mutator/command methods on a final variable, changing not its \r\n    state (WHICH object it refers to) but the state IN the object it refers to.\r\n   So, if we declare <b>final DiceEnsemble d = new DiceEnsemble(2,6);</b> we\r\n     CAN write <b>d.roll();</b>, but we CANNOT write\r\n     <b>d = new DiceEnsemble(1,6);</b>\r\n   Again, the difference between what is stored in a variable (a reference)\r\n     and what is stored in the object it refers to (its state) is crucial to\r\n     understanding this distinction.\r\n  --->\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Conditional Operators -->\r\n\r\n<a name=\"ConditionalOperators\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Conditional Operators ? and :</b></td>\r\n<td width =\"80%\">\r\n  There are two operators that work together in Java, helping us to condense\r\n    our code by allowing us to write short expressions instead of longer\r\n    statements.\r\n  These two operators, <b>?</b> and <b>:</b> constitute what is called a\r\n    <b>conditional expression</b>.\r\n  Please constrast this with <b>if</b> statements, which are sometimes \r\n    called <b>conditional statements</b>: the distinction between\r\n    <b>expression</b> and <b>statement</b> is important.\r\n  The EBNF rule for a conditional expression is\r\n  <p>\r\n&nbsp &nbsp <i>conditional-expression</i> <= <i>expression</i> ? <i>expression</i> : <i>expression</i>\r\n  <p>\r\n  As a syntax constraint, the first <i>expression</i> must return a \r\n    <b>boolean</b> result, and the second two <i>expression</i>s\r\n    must return a result of the same type (it can be any type, but they must\r\n    match).\r\n  <p>\r\n  We will write conditional expressions using the following form (almost\r\n    always putting them in parentheses, which makes reading them easier)\r\n  <b><pre>  (test ? expression<sub>T</sub> : expression<sub>F</sub>)</pre></b>\r\n  Together, <b>?</b> and <b>:</b> are called <b>ternary</b> operators (not\r\n    unary or binary: they have three operands); they are called <b>distfix</b>\r\n    because the operators are <b>dis</b>tributed around their operands\r\n    (not prefix, infix, or postfix).\r\n  <p>\r\n  Semantically, Java first evaluates <b>test</b>, if it is <b>true</b> the\r\n    result of the conditional expression is the result of evaluating\r\n    <b>expression<sub>T</sub></b>; if it is <b>false</b> the result of the\r\n    conditional expression is the result of evaluating\r\n    <b>expression<sub>F</sub></b>.\r\n  So, only two of the three expressions are ever evaluated.\r\n  Because each conditional expression must have a unique result type, and\r\n    because its value can be computed by either <b>expression<sub>T</sub></b>\r\n    or <b>expression<sub>F</sub></b>, the Java compiler has a syntax constraint\r\n    that requires these expressions to have the same type. \r\n  <p>\r\n  Let's look at three concrete examples of conditional expressions and the\r\n    <b>if</b> statements that they condense.\r\n  One can often simplify short <b>if</b> statements with even shorter\r\n    conditional expressions, but large <b>if</b> statements often cannot\r\n    be simplified.\r\n  <b><pre>  if (n > 0)         x = (n>0 ? 0 : 1);\r\n    x = 0;\r\n  else\r\n    x = 1;\r\n\r\n\r\n  if (pennies == 1)\r\n    System.out.println(\"1 penny\");\r\n  else\r\n    System.out.println(pennies + \" pennies\");\r\n\r\n  System.out.println(pennies + (pennies==1 ? \" penny\" : \" pennies\"));\r\n\r\n\r\n  if (n%2 == 0)\r\n    System.out.println(n + \" is even\");\r\n  else\r\n    System.out.println(n + \" isn't even\");\r\n\r\n  System.out.println(n + (n%2==0 ? \" is\" : \" isn't\") + \" even\");</pre></b>\r\n  Upon reading this code, many students think that the <b>if</b> statements are\r\n    simpler; but that is because they are more familiar with <b>if</b>\r\n    statements, and less familiar with conditional expressions.\r\n  Most experience programmers think that the conditional expressions are\r\n    simpler.\r\n  Of course, which form you ultimately use is a matter of taste.\r\n  But it is important that you understand conditional expressions, and can\r\n    switch back and forth between them and simple <b>if</b> statements,\r\n    when it is possible.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Short Circuit Evaluation -->\r\n\r\n<a name=\"ShortCircuit\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Short-Circuit Evaluation</b></td>\r\n<td width =\"80%\">\r\n  We have learned that binary infix operators evaluate both their operands \r\n   first, and then compute their resulting value.\r\n  Actually, this ordering is correct for all but the <b>&&</b> and <b>||</b>\r\n     logical operators.\r\n  Instead, these operators use <b>short-circuit</b> evaluation: they always\r\n    evaluate their left operand first; if they can compute their resulting \r\n   value from this operand alone, they do so without evaluating their right\r\n   operand; if they cannot determine the resulting value from the left operand\r\n    alone, then they evaluate their right operand and compute the resulting\r\n    value\r\n  <p>\r\n  Note that if the left operand of <b>&&</b> evaluates to <b>false</b>, the\r\n    result must be <b>false</b>: <b>false && false</b> as well as\r\n    <b>false && true</b> evaluate to <b>false</b>, so the value of the right\r\n    operand is irrelevant.\r\n  Note that if the left operand of <b>||</b> evaluates to <b>true</b>, the\r\n    result must be <b>true</b>: <b>true || false</b> as well as\r\n    <b>true || true</b> evaluate to <b>true</b>, so again the value of the\r\n    right operand is irrelevant.\r\n  <p>\r\n  To see how we can use this short-circuit property when programming, assume\r\n    that a program declares <b>int totalParts = 0, badParts = 0;</b> and\r\n    increments the appropriate variables when a part is tested.\r\n  Next, assume that if the ratio of bad parts to total parts is ever over 5%\r\n   (or <b>.05</b>) we want to recognize this problem and display a message.\r\n  Because we have short-circuit evaluation, we can simply write<b><pre>\r\n  if ( totalParts != 0 && (double)badParts/(double)totalParts > .05)\r\n    System.out.println(\"Too many bad parts\");</pre></b>\r\n  Notice that if <b>totalParts</b> is zero, then the left operand of <b>&&</b>\r\n    is <b>false</b>, so Java doesn't bother to evaluate the right operand.\r\n  Without short-circuit evaluation, Java would evaluate the right operand too,\r\n    causing an exception to be thrown because of division by zero.\r\n  Also, if we had written the second conjunct first, Java would do the division\r\n    BEFORE comparing <b>totalParts</b> to zero, which could also throw an\r\n    exception.\r\n  So, the operands to the <b>&&</b> and <b>||</b> operators are not symmetric\r\n    because short-circuit evaluation is used.\r\n  <p>\r\n  In a programming language without short-circuit evaluation, we would have to\r\n    write the following, more complicated code, to achieve safety from division\r\n    by zero.\r\n <b><pre>  if (totalParts != 0)\r\n    if ((double)badParts/(double)totalParts > .05)\r\n      System.out.println(\"Too many bad parts\");</pre></b>\r\n  which requires two, nested <b>if</b> statements, instead of one.\r\n  <p>\r\n  As a final example, suppose that we are writing a game-playing program, and\r\n    the user must terminate the bet-play loop if his/her purse is 0 or if\r\n    he/she elects to quit (if the former is true, the user shouldn't even be\r\n     prompted about electively quitting; he/she must quit because he/she has\r\n     no more money).\r\n  With short-circuit evaluation, we can write one <b>if</b> statement that\r\n    captures all these semantics\r\n  <b><pre>  if (purse == 0 || Prompt.forBoolean(\"Quit?\"))\r\n    break;</pre></b>\r\n  Because of short-circuit evaluation, if purse is zero, the <b>if</b>'s test\r\n    will evaluate to <b>true</b> before prompting the user; only if purse is\r\n    not zero will the user be prompted about quitting.\r\n  <p>\r\n  Again, in a programming language without short-circuit evaluation, we could\r\n    safely write the following, more complicated code\r\n  <b><pre>  if (purse == 0)\r\n    break;\r\n  if (Prompt.forBoolean(\"Quit?\"))\r\n    break;</pre></b>\r\n  which requires two, sequential <b>if</b> statements, instead of one.\r\n  <p>\r\n  Finally, short-circuit evaluation actually works in conditional expressions\r\n     too.\r\n  For example, if we write the conditional expresson <b>(true ? 1 : 1/0)</b>\r\n    Java's result is <b>1</b>; because the expression evaluates to <b>true</b>\r\n    Java evaluates only the expression <b>1</b> and not the expression\r\n    <b>1/0</b>.\r\n  If Java fully evaluated all expressions first, it would throw an exception.\r\n  Recall the semantics of the conditional expression:\r\n  Java first evaluates the <b>test</b>, if it is <b>true</b> the result of the\r\n    conditional expression is the result of evaluating\r\n    <b>expression<sub>T</sub></b>; if it is <b>false</b> the result of the\r\n     conditional expression is the result of evaluating\r\n     <b>expression<sub>F</sub></b>.\r\n  So, it uses <b>test</b> to determine which other expression to evaluate, and\r\n    only evaluates that one other expression.\r\n  It always evaluates two of the three expressions.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, or any other student.\r\n\r\n  <ol> \r\n     <li>Assume that we declared <b>final int maxClassSize = 50;</b> which\r\n           of the following statements would cause the Java compiler to detect\r\n           and report an error. Also assume <b>int x;</b>\r\n         <ul>\r\n           <li><b>maxClassSize++;</b>\r\n           <li><b>System.out.println(maxClassSize);</b>\r\n           <li><b>maxClassSize = 50;</b>\r\n           <li><b>maxClassSize += 10;</b>\r\n           <li><b>x = maxClassSize + 2;</b>\r\n         </ul>\r\n     <p>\r\n     \r\n     <li>Assume that we declared <b>final StringTokenizer st = new StringTokenizer(\"A man, a plan, a canal: Panama\");</b> which\r\n           of the following statements would cause the Java compiler to detect\r\n           and report an error. Also assume <b>int x;</b>\r\n         <ul>\r\n           <li><b>String s = st.nextToken();</b>\r\n           <li><b>x = st.countTokens();</b>\r\n           <li><b>st = new StringTokenizer(\"Another string\");</b>\r\n         </ul>\r\n     <p>\r\n     \r\n\r\n     <li>Examine the two code fragments below.\r\n         For each, say whether it is legal and why (or why not).\r\n         Rewrite the <b>if</b> statement using a conditional expression.\r\n<pre><b>\r\n  int x = Prompt.forInt(\"Enter x\");\r\n  if (x != 0)\r\n    final int y = 0;\r\n  else\r\n    final int y = 1;\r\n  System.out.println(y);\r\n\r\n  int x = Prompt.forInt(\"Enter x\");\r\n  final int y;\r\n  if (x != 0)\r\n    y = 0;\r\n  else\r\n    y = 1;\r\n  System.out.println(y);</pre></b>\r\n<p>\r\n     \r\n     <li>Assume that we declare <b>int x;</b> what is wrong with the following\r\n           conditional expression:\r\n          <b>System.out.println(x==0 ? 0 : \"non-zero\");</b>\r\n     <p>\r\n     \r\n     <li>Translate the following <b>if</b> statement into an equivalent\r\n           conditional expression (see above).\r\n         <b><pre>  if (x>y)\r\n    max = x;\r\n  else\r\n    max = y;</pre></b>\r\n     <p>\r\n\r\n     <li>Assume that we declare <b>int minute;</b> and assign it a value\r\n           between <b>0</b> and <b>59</b>.\r\n         Write a conditional expression whose values is always a two digit\r\n           <b>String</b> representing a <b>minute</b>: e.g.,\r\n           if <b>x</b> stores <b>5</b> its result is <b>\"05\"</b>;\r\n           if <b>x</b> stores <b>25</b> its result is <b>\"25\"</b>.\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}