{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/CollSpec031.txt", "content": "WEBDAV Working Group                                     J. Slein, Xerox\nINTERNET DRAFT                                           J. Davis, Xerox\n<draft-ietf-webdav-collection-protocol-03.1>     T. Chihaya, DataChannel\n                                                      G. Clemm, Rational\n                                                         C. Fay, FileNet\n                                           E.J. Whitehead Jr., UC Irvine\n                                                           April 5, 1999\nExpires October 5, 1999\n\n\t\t\tWebDAV Advanced Collections Protocol\n\nStatus of this Memo\n\nThis document is an Internet-Draft and is in full conformance with all \nprovisions of Section 10 of RFC2026. Internet-Drafts are working \ndocuments of the Internet Engineering Task Force (IETF), its areas, and \nits working groups. Note that other groups may also distribute working \ndocuments as Internet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months \nand may be updated, replaced, or obsoleted by other documents at any \ntime. It is inappropriate to use Internet-Drafts as reference material \nor to cite them other than as \"work in progress\".\n\nTo view the list Internet-Draft Shadow Directories, see \nhttp://www.ietf.org/shadow.html.\n\nDistribution of this document is unlimited. Please send comments to the \nDistributed Authoring and Versioning (WebDAV) working group at <w3c-\ndist-auth@w3.org>, which may be joined by sending a message with subject \n\"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\nDiscussions of the WEBDAV working group are archived at URL: \n<http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\nAbstract\n\nThe base WebDAV protocol [WebDAV] provides basic support for \ncollections.  It defines a MKCOL method for creating collections and \nspecifies how other HTTP and WebDAV methods interact with collections.  \nIt supports internal members of collections, which it defines as URIs \nthat are immediately relative to the URI of the collection.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: referential resources and ordering.\n\nThis draft specifies extensions to the base WebDAV protocol to support \nthese more powerful collections.\n\nTable of Contents\n\n1\tNotational Conventions......................................4\n2\tTerminology.................................................4\n3\tIntroduction................................................5\n4\tReferential Resources.......................................6\n4.1\tScope.......................................................6\n\nSlein et al.                                                    Page 1\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n4.2\tOverview....................................................6\n4.3\tCreating Referential Resources..............................8\n4.3.1\tThe MKREF Method............................................8\n4.3.2\tStatus Codes................................................8\n4.3.3\tExample: MKREF..............................................9\n4.4\tListing Referential Members of a Collection.................9\n4.4.1\tExample: PROPFIND on a Collection with References..........10\n4.4.2\tExample: PROPFIND with No-Passthrough on a Collection with \n        References.................................................12\n4.5\tCopying Referential Resources..............................15\n4.5.1\tCOPY for Direct References.................................15\n4.5.2\tCOPY for Redirect References...............................16\n4.5.3\tExample: COPY on a Direct Reference........................16\n4.5.4\tExample: COPY on a Redirect Reference......................16\n4.5.5\tExample: COPY on a Collection That Contains a Direct Reference \n        and a Redirect Reference...................................17\n4.6\tDeleting and Moving Referential Resources..................17\n4.7\tLocking Referential Resources..............................18\n4.7.1\tLOCK on Direct References..................................19\n4.7.2\tLOCK on Redirect References................................19\n4.7.3\tExample: LOCK on a Direct Reference........................20\n4.7.4\tExample: LOCK on a Redirect Reference......................21\n4.7.5\tExample: LOCK on a Collection That Contains a Direct Reference \n        and a Redirect Reference...................................21\n4.8\tOther WebDAV Operations on Redirect Referential Resources..22\n4.8.1\tExample: PROPPATCH on a Redirect Reference.................23\n4.9\tOther WebDAV Operations on Direct Referential Resources....23\n4.9.1\tExample: PROPPATCH on a Direct Reference...................23\n4.10\tHTTP Operations on Redirect Referential Resources..........23\n4.10.1\tExample: GET on a Redirect Reference.......................24\n4.10.2\tExample: GET on a Redirect Reference with No-Passthrough...24\n4.11\tHTTP Operations on Direct Referential Resources............24\n4.11.1\tExample: GET on a Direct Reference.........................25\n4.11.2\tExample: GET on a Direct Reference with No-Passthrough.....25\n4.12\tOperations on Targets of Referential Resources.............25\n4.13\tDiscovering a Target's References..........................25\n4.14\tBehavior of Dangling Direct References.....................26\n4.14.1\tExample: PROPFIND on a Collection with a Dangling Direct \n        Reference..................................................27\n4.15\tChains of Direct References................................27\n4.16\tRelative URIs in Ref-Target and DAV:reftarget..............28\n4.16.1\tExample: Resolving a Relative URI in Ref-Target............28\n4.16.2\tExample: Resolving a Relative URI in DAV:reftarget.........29\n4.17\tURIs and References........................................30\n5\tOrdered Collections........................................30\n5.1\tOverview...................................................31\n5.2\tCreating an Ordered Collection.............................31\n5.2.1\tOverview...................................................31\n5.2.2\tExample: Creating an Ordered Collection....................32\n\nSlein et al.                                                    Page 2\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n5.3\tSetting the Position of a Collection Member................32\n5.3.1\tOverview...................................................32\n5.3.2\tStatus Codes...............................................32\n5.3.3\tExamples: Setting the Position of a Collection Member......32\n5.4\tChanging the Semantics of a Collection Ordering............33\n5.5\tChanging the Position of a Collection Member...............33\n5.5.1\tThe ORDERPATCH Method......................................33\n5.5.2\tStatus Codes...............................................34\n5.5.3\tExample: Changing the Positions of Collection Members in the \n        Ordering...................................................34\n6\tHeaders....................................................35\n6.1\tRef-Target Entity Header...................................35\n6.2\tRef-Type Entity Header.....................................36\n6.3\tRef-Integrity Request Header...............................36\n6.4\tNo-Passthrough Request Header..............................37\n6.5\tOrdered Entity Header......................................37\n6.6\tPosition Request Header....................................38\n7\tProperties.................................................38\n7.1\treftarget Property.........................................38\n7.2\trefintegrity Property......................................39\n7.3\treftype Property...........................................39\n7.4\tlocation Property..........................................39\n7.5\treferences Property........................................40\n7.6\torderingtype Property......................................40\n8\tXML Elements...............................................40\n8.1\treference XML Element......................................40\n8.2\tdirect XML Element.........................................40\n8.3\tredirect XML Element.......................................41\n8.4\tweak XML Element...........................................41\n8.5\tunordered XML Element......................................41\n8.6\tcustom XML Element.........................................41\n8.7\torder XML Element..........................................41\n8.8\tordermember XML Element....................................42\n8.9\tposition XML Element.......................................42\n8.10\tfirst XML Element..........................................42\n8.11\tlast XML Element...........................................42\n8.12\tbefore XML Element.........................................42\n8.13\tafter XML Element..........................................43\n8.14\toptions XML Element........................................43\n8.15\trefintegrityoptions XML Element............................43\n8.16\torderingoptions XML Element................................43\n8.17\tdo-not-enforce XML Element.................................44\n9\tExtensions to the DAV:response XML Element for Multi-Status \n        Responses..................................................44\n10\tCapability Discovery.......................................44\n10.1\tCompliance Classes.........................................44\n10.2\tExample: Discovery of Compliance Classes...................45\n10.3\tAdditional Advanced Collections Capabilities...............45\n10.4\tExample: Discovery of Referential Integrity Options........46\n11\tDependencies on Other Specifications.......................47\n12\tSecurity Considerations....................................47\n12.1\tPrivacy Concerns...........................................47\n12.2\tRedirect Loops.............................................47\n12.3\tReferences and Denial of Service...........................47\n12.4\tReferences May Reveal Private Locations....................47\n\nSlein et al.                                                    Page 3\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n12.5\tDAV:references and Denial of Service.......................48\n12.6\tDAV:references and Malicious Deletion of Resources.........48\n12.7\tDenial of Service and DAV:orderingtype.....................48\n13\tInternationalization Considerations........................48\n14\tIANA Considerations........................................49\n15\tCopyright..................................................49\n16\tIntellectual Property......................................49\n17\tAcknowledgements...........................................49\n18\tReferences.................................................49\n18.1\tNormative References.......................................49\n18.2\tInformational References...................................50\n19\tAuthors' Addresses.........................................50\n20\tAppendices.................................................51\n20.1\tAppendix 1: Extensions to the WebDAV Document Type \n        Definition.................................................51\n20.2\tAppendix 2: Summary of Method Semantics for References.....51\n\n1 Notational Conventions\n\nSince this document describes a set of extensions to the HTTP/1.1 \nprotocol, the augmented BNF used here to describe protocol elements is \nexactly the same as described in Section 2.1 of [HTTP].  Since this \naugmented BNF uses the basic production rules provided in Section 2.2 of \n[HTTP], these rules apply to this document as well.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this \ndocument are to be interpreted as described in [RFC2119].\n\n2 Terminology\n\nThe terminology used here follows and extends that in the base WebDAV \nprotocol specification [WebDAV].\n\nCollection\n     A resource that contains a set of URIs, termed member URIs, which \n     identify member resources\n\nMember URI\n     A URI which is a member of the set of URIs contained by a \n     collection\n\nReferential Resource (or Reference)\n     A resource that has no body of its own (though it does have \n     properties), but rather is a reference to another resource\n\nOrdinary Resource\n     A resource that is not a reference to another resource\n\nTarget Resource\n     The resource referenced by a referential resource\n\nDirect Reference\n     A reference that is resolved by the server without any client \n     action, giving the client the illusion that it is operating \n     directly on the target resource\n\nSlein et al.                                                    Page 4\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nRedirect Reference\n     A reference that requires client action before it can be resolved, \n     so that the client is aware that a reference is mediating between \n     it and the target resource\n\nStrong Reference\n     A reference whose referential integrity is enforced by the server\n\nWeak Reference\n     A reference whose referential integrity is not enforced by the \n     server\n\nReferential Integrity\n     The integrity of a reference is preserved as long as it points to \n     the same resource it pointed to when it was created.  Its \n     integrity may be destroyed if the target resource is moved without \n     updating the reference to reflect its new location, or if the \n     target resource is deleted.\n\n3 Introduction\n\nThe simple collections that the base WebDAV specification supports are \npowerful enough to be widely useful.  They provide for the hierarchical \norganization of resources, with mechanisms for creating and deleting \ncollections, copying and moving them, locking them, adding members to \nthem and removing members from them, and getting listings of their \nmembers.  Delete, copy, move, list, and lock operations can be applied \nrecursively, so that a client can operate on whole hierarchies with a \nsingle request.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: references and ordering.\n\nReferences make it possible for many collections, on the same or \ndifferent servers, to share the same resource.  Because the collections \nshare the resource by referencing it, only one physical copy of the \nresource need exist, and any changes made in the resource are visible \nfrom all the collections that reference it.\n\nIt is useful for many applications to be able to impose an ordering on a \ncollection. Orderings may be based on property values, but they may be \ncompletely independent of any properties on the resources identified by \nthe collection's member URIs.  Orderings based on properties can be \nobtained using a search protocol [DASL], but orderings not based on \nproperties need some other mechanism.  These orderings generally need to \nbe maintained by a human user.  The ordering protocol defined here \nfocuses on support for such human-maintained orderings, but also allows \nfor server-maintained orderings.\n\nSince these two areas are independent of each other, servers may elect \nto comply with the Referential Resources section of this specification \nor with the Ordered Collections section or both.  A server that supports \nreferencing MUST support redirect references, and MAY support direct \n\nSlein et al.                                                    Page 5\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nreferences.  A server MUST advertise its compliance with particular \nparts of this specification through its response to an OPTIONS request, \nas specified in Section 10 below.\n\n4 Referential Resources\n\n4.1 Scope\n\n[CollReq] states requirements for 4 different kinds of references: weak \nreferences, strong references, redirect references, and direct \nreferences.  This specification supports weak references, direct \nreferences, and redirect references, and is designed so that it can be \nextended to support strong references in the future.\n\nStrong references are references whose integrity is enforced by the \nserver; weak references are those whose integrity is not enforced by the \nserver.  Strong references and weak references are both useful in \ndifferent contexts.  Some applications cannot tolerate broken links.  A \nsoftware development application, for example, must be able to rely on \nthe integrity of references to component modules. Such applications must \nbe able to request strong references.  Other applications may want to \nreference target resources on multiple servers, where referential \nintegrity cannot be enforced, and may be less concerned about possible \nbroken references.  \n\nSeveral considerations led to the decision not to support strong \nreferences in the current specification.  First, there are many possible \npolicies that applications and services might use in enforcing \nreferential integrity.  Some examples are:\n\no Delete strong references when their targets are deleted.\no Decline to delete targets of strong references.\no Notify strong references when their targets have been deleted.\no Replace strong references with copies of their targets before \n  deleting the targets.\n\nThere appears to be no common practice in this area.  Moreover, some of \nthe policies have significant security risks.\n\no Moving a target of strong references could be a security risk to the \n  owner of the target by revealing secret locations on the target's \n  server.\no A strong reference could be a security risk to the owner of the \n  reference by revealing secret locations on his server.\no The presence of strong references to resources on a server could make \n  it impossible to reclaim space on that server by moving or deleting \n  those target resources. \n\nThese considerations together led to the decision not to support strong \nreferences in the short term. \n\n4.2 Overview\n\nA referential resource is a resource that has no body of its own, but \ninstead references another resource.  The resource it references may \n\nSlein et al.                                                    Page 6\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nhave a URI in the same collection as the reference, or in any other \ncollection.  This target resource may be a collection or a simple \nresource or another reference, or any other sort of resource that may be \ndefined in the future.  A resource may be the target of any number of \nreferential resources.  To make it possible to distinguish references \nfrom ordinary resources, a new value of the DAV:resourcetype property \n(defined in [WebDAV]) is added here.  The DAV:resourcetype property of \nall references MUST have the new value DAV:reference (defined in Section \n8.1 below).  \n\nRedirect references are references that require action by the client \nbefore they can be resolved.  They are simple for servers to implement, \nstraightforward for clients to use, and have only limited security \nimplications.  Any server that complies with WebDAV referencing MUST \nprovide redirect references.\n\nIf the client is aware that it is operating on a redirect reference, it \ncan resolve the reference by retrieving the reference's DAV:reftarget \nproperty (defined in Section 7.1 below), whose value is the URI of the \ntarget resource.  It can then submit requests to the target resource.\n\nOtherwise, the client submits a request to the redirect reference.  For \nmost operations, the response is a 302 (Moved Temporarily), accompanied \nby the Ref-Type header (defined in Section 6.2 below) with the value \n\"DAV:redirect\" and the Location header with the URI of the target \nresource.  The client can then resubmit the request to the URI of the \ntarget resource.  A few operations, for reasons that will be explained, \nare exceptions to this general behavior. These exceptional operations \nare applied to the reference itself and do not result in a 302 response.\n\nDirect references, in contrast, are resolved automatically by the \nserver.  They give the client the illusion that it is operating directly \non the target resource.  These references are more complex for the \nserver to implement, and raise additional security issues.  \nConsequently, servers are not required to provide direct references in \norder to be compliant with WebDAV referencing. \n\nThe default behavior of a direct reference is to apply most operations \ndirectly to its target, so that the client is not aware that a reference \nis mediating between it and the target resource.  The exceptions are \noperations that affect membership in a collection rather than the state \nof the target resource.  At present, the operations that fall into this \ncategory are DELETE and MOVE.  These operations are applied to the \nreference itself rather than to its target, so that only the collection \ncontaining the reference is affected.\n\nThe No-Passthrough request header (defined in Section 6.4 below) is also \nprovided, to force an operation to be applied to the reference itself \nrather than its target.  It can be used with most requests to direct or \nredirect references.  This header is particularly useful with PROPFIND, \nto allow clients to view the reference's own properties.\n\nIdeally, non-referencing clients should be able to use both direct and \nredirect references.  This goal is more difficult to meet for redirect \nreferences, since client action is required to resolve them.  The \n\nSlein et al.                                                    Page 7\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nstrategy of having redirect references respond to most requests with a \n302 (Moved Temporarily), accompanied by the URI of the target resource \nin the Location header, fulfills this goal in most cases.\n\nTo distinguish between direct and redirect references, a new property \ncalled DAV:reftype is defined in Section 7.3, with the values DAV:direct \nand DAV:redirect.  Every referential resource MUST have the DAV:reftype \nproperty.  The DAV:reftype property of a direct reference MUST have the \nvalue DAV:direct.  The DAV:reftype property of a redirect reference MUST \nhave the value DAV:redirect.\n\nEvery referential resource MUST have the DAV:reftarget property (defined \nin Section 7.1), whose value is the URI of the reference\u2019s target \nresource.\n\nAlthough strong references are not currently supported, a new property \ncalled DAV:refintegrity is defined in Section 7.2 in anticipation of \nfuture support for strong references.  DAV:refintegrity will allow \nclients to distinguish between weak and strong references.  All \nreferential resources MUST have this property.  Although the only value \ncurrently defined for DAV:refintegrity is DAV:weak, other values may be \ndefined in the future, and servers MAY use extension values to identify \ntheir policy for enforcing referential integrity for that resource.\n\n4.3 Creating Referential Resources\n\n4.3.1 The MKREF Method\n\nReferential resources are created using the MKREF method.  The request-\nURI of the MKREF request identifies the resource to be created.  \n\nSeveral new headers are defined in this specification for use in MKREF \nrequests:  \n\no The Ref-Target header (defined in Section 6.1) MUST be included in \n  every MKREF request to identify the target resource of the new \n  reference.  \no The Ref-Integrity header (defined in Section 6.3) MUST be included in \n  every MKREF request to indicate whether and how referential integrity \n  should be enforced for the new reference.  \no The Ref-Type header (defined in Section 6.2) MAY be included in MKREF \n  requests to indicate whether a direct reference or a redirect \n  reference is being created.\no The Position request header (defined in Section 6.6) MAY be used in \n  MKREF requests to indicate where the new reference is to be placed in \n  its parent collection's ordering.\n\nMKREF requests MAY include an entity body.  This specification does not \ndefine the body, but allows it for extensibility. \n\nIf a MKREF request has a request-URI that identifies an existing \nresource, the request MUST fail.  This behavior is analogous to the \nbehavior of the MKCOL method [WebDAV].  \n\n4.3.2 Status Codes\n\nSlein et al.                                                    Page 8\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nClient errors, and the appropriate response status codes, for MKREF \ninclude: \n\n400 (Bad Request): The client attempted to send content with the \nrequest, or set an invalid value for the Ref-Target, Ref-Integrity, Ref-\nType, or Position header.\n \n405 (Method Not Allowed): A resource already exists at the request-URI.\n\n409 (Conflict): Several conditions may produce this response.  There may \nbe no resource at the location specified in Ref-Target, on a server that \nprohibits dangling references.  The request may be attempting to create \nthe reference in a collection that does not exist.  The request may be \nattempting to position the reference before or after a resource that is \nnot in the collection, or before or after itself.  The request may be \nattempting to position the reference in an unordered collection.\n\nXxx: The server does not support the Ref-Integrity value \"DAV:do-not-\nenforce\" for the request-URI.\n\n4.3.3 Example: MKREF\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: /i-d/draft-webdav-protocol-08.txt\nRef-Integrity: do-not-enforce\n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  Its DAV:resourcetype property is \nset to DAV:reference.  Its DAV:reftarget property is set to the URI of \nits target resource.  Since the Ref-Integrity header asks the server not \nto enforce referential integrity for the new reference, the server sets \nits DAV:refintegrity property to the value of DAV:weak, indicating that \nthe server will not enforce referential integrity for the new reference.  \nIts DAV:reftype property is set to the default value of DAV:redirect.\n\n4.4 Listing Referential Members of a Collection\n\nA URI of a referential resource can be a member of a collection just as \nthe URI of an ordinary resource can.  A listing of the members of a \ncollection shows all of the URIs in the collection, whether they \nidentify references or ordinary resources.  That is, a WebDAV PROPFIND \nrequest on a collection resource with Depth = 1 or infinity MUST return \na response XML element for each URI in the collection, whether it \nidentifies an ordinary resource or a referential resource.\n\nFor each direct reference, the properties returned by the PROPFIND MUST \n\nSlein et al.                                                    Page 9\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nbe the properties of the target resource unless the No-Passthrough \nheader is included with the PROPFIND request.\n\nFor each redirect reference, the response element MUST contain a 302 \n(Moved Temporarily) status code unless the No-Passthrough header is \nincluded with the PROPFIND request.  The DAV:location and DAV:reftype \nproperties MUST be included with the 302 status code, extending the \nsyntax of the DAV:response element that was defined in [WebDAV] as \ndescribed in Section 9 below.  A referencing-aware client can tell from \nthe DAV:reftype property that the collection contains a redirect \nreference.  The DAV:location property contains the absolute URI of the \ntarget resource.  A referencing-aware client can either use the URI \nvalue of the DAV:location property to retrieve the properties of the \ntarget resource, or it can submit a PROPFIND to the redirect reference \nwith the No-Passthrough header to retrieve its properties.  It is \nrecommended that future editors of [WebDAV] define the DAV:location \nproperty in [WebDAV], so that non-referencing clients will also be able \nto use the response to retrieve the properties of the target resource.\n\nIf Depth = infinity in the PROPFIND request, the server MUST NOT follow \nredirect references into any collections to which they may refer.\n\nIf Depth = infinity in the PROPFIND request, the server MUST follow \ndirect references into any collections to which they may refer unless \nthe No-Passthrough header is used with the request.  That is, if the \ntarget resource is a collection, the server MUST list the members of \nthat collection.\n\nThe No-Passthrough header (defined in Section 6.4) MAY be used with a \nPROPFIND request on a collection.  If present, it indicates that the \nclient wants to see the properties of the references contained in the \ncollection, not the properties of their target resources. \n\n4.4.1 Example: PROPFIND on a Collection with References\n\nSuppose a PROPFIND request with Depth = infinity is submitted to the \nfollowing collection, with the members shown here:\n\nhttp://www.svr.com/MyCollection/\n   (ordinary resource) diary.html\n   (direct reference) tuva\n   (redirect reference) nunavut\n\nThe target of http://www.svr.com/MyCollection/tuva is the following \ncollection:\n\nhttp://www.svr.com/feynman/tuva/\n   (ordinary resource) history.html\n   (ordinary resource) music.html\n\nRequest:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\n\nSlein et al.                                                    Page 10\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV: \">\n   <D:prop xmlns:J=\"http://www.svr.com/jsprops/\">\n      <D:resourcetype/>\n      <J:keywords/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\"\n               xmlns:J=\"http://www.svr.com/jsprops/\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n            <J:keywords>diary, interests, hobbies</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n            <J:keywords>diary, travel, family, history</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/tuva</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n            <J:keywords>history, music, throat-singing</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/tuva/history.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n\nSlein et al.                                                    Page 11\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            <J:keywords>history, language, culture</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/tuva/music.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n            <J:keywords>music, throat-singing</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location> \n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:reftype>redirect</D:reftype>\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nIn this example, Depth = infinity and the No-Passthrough header is not \nused.  The collection contains one URI that identifies a redirect \nreference.  The response element for the redirect reference has a status \nof 302 (Moved Temporarily), and includes a DAV:prop element with the \nDAV:location and DAV:reftype properties to allow clients to retrieve the \nproperties of its target resource.  (The response element for the \nredirect reference does not include the requested properties.  The \nclient can submit another PROPFIND request to the URI in the \nDAV:location property to retrieve those properties.)  The collection \nalso contains one URI that identifies a direct reference.  The response \nelement for the direct reference contains the properties of its target \ncollection.  There are also response elements for each member of its \ntarget collection.\n\n4.4.2 Example: PROPFIND with No-Passthrough on a Collection with \nReferences\n\nSuppose a PROPFIND request with a No-Passthrough header and Depth = \ninfinity is submitted to the following collection, with the members \nshown here:\n\n/MyCollection/\n   (collection) photos/ \n      (ordinary resource) family.gif\n      (ordinary resource) trip.gif\n   (ordinary resource) diary.html\n   (direct reference) tuva\n   (redirect reference) nunavut\n\nSlein et al.                                                    Page 12\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nRequest:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nNo-Passthrough:\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftype/> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/photos/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftype/> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/photos/family.gif</D:href>\n\nSlein et al.                                                    Page 13\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftype/> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/photos/trip.gif</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftype/> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftype/> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/tuva</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n            <D:reftype>direct</D:reftype>\n            <D:reftarget>\n               <D:href>http://www.feynman.com/tuva/</D:href>\n            </D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n\nSlein et al.                                                    Page 14\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            <D:reftype>redirect</D:reftype>\n            <D:reftarget>\n               <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n            </D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nSince the No-Passthrough header is present, the response shows the \nproperties of the references in the collection rather than the \nproperties of their targets.  Even though Depth = infinity, the No-\nPassthrough header prevents the server from listing the members of the \ncollection that is the target of the direct reference.  No-Passthrough \nalso prevents a 302 response from being returned for the redirect \nreference.\n\n4.5 Copying Referential Resources\n\nIn determining the semantics of COPY, the desire to provide intuitively \ncorrect behavior was weighed against consistency considerations.\n\nA client's intent in performing a COPY operation is to create a new \nresource that is similar to the original resource and behaves like the \noriginal resource, and that can be modified without affecting the \noriginal resource.  For references to ordinary resources, the \nexpectation would be that the target resource be copied.  This would \nyield an independent resource that could be modified without affecting \nthe original resource.  For collections the situation is less clear.  \nThere is tension between two expectations. On the one hand, the client \nmay expect the new copy of the collection to behave like the old one \n(which implies having references where the old one had references).  On \nthe other hand, the client may expect that it will be possible to modify \nthe members of the new collection without affecting the members of the \nold collection (which implies having copies of the targets where the \noriginal collection had references).\n\n4.5.1 COPY for Direct References\n\nCOPY follows the general principle that operations on direct references \nare applied to the target resource unless the No-Passthrough header is \nused.  A COPY on a direct reference MUST be applied to its target \nresource unless the No-Passthrough header is used.  If the No-\nPassthrough header is used, then the COPY MUST be applied to the direct \nreference rather than to its target.\n\nFor consistency, the same is true when a COPY request is sent to a \ncollection, and direct references are encountered inside the collection.  \nUnless the No-Passthrough header is present on the request, the targets \nof the direct references MUST be copied into the new collection.  If the \nNo-Passthrough header is used, then the direct references, and not their \ntargets, MUST be copied into the new collection.\n\nThese semantics yield intuitively correct results when a COPY request is \n\nSlein et al.                                                    Page 15\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nsent to an individual reference.  It is less clear that the results are \nintuitive when a COPY request is sent to a collection containing direct \nreferences, but consistency dictates that we follow the same semantics \nfor this case.  A design principle that is followed throughout this \nspecification is that a method behaves the same when it is sent to the \nURI of a reference as it does when it is sent to a the URI of a \ncollection and encounters a reference inside that collection.\n\n4.5.2 COPY for Redirect References\n\nFor redirect references, the normal behavior would be to respond to a \nrequest with a 302 (Moved Temporarily) status code, allowing the client \nto resubmit the request to the target resource identified in the \nLocation header.  This would also yield intuitively correct behavior for \nCOPY.  However, it seems undesirable to respond to a COPY request on a \ncollection with a Multi-Status including a 302 response for each \nredirect reference.  To avoid this sort of response, the following rules \napply when COPY is sent to redirect references:\n\nA COPY on a redirect reference MUST be applied to the reference itself, \nwhether or not the No-Passthrough header is present.\n\nThe same is true when a COPY request is sent to a collection, and \nredirect references are encountered inside the collection.  Whether or \nnot the No-Passthrough header is present on the request, the redirect \nreferences themselves are copied into the new collection, and 302 status \ncodes are not returned for them.\n\n4.5.3 Example: COPY on a Direct Reference\n\nRequest:\n\nCOPY /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/tuva.html\n\nResponse:\n\nHTTP/1.1 204 No Content\n\nIn this example, the request-URI identifies a direct reference whose \ntarget resource is identified by \nhttp://www.svr.com/Asia/History/tuva.html.  This target resource was \ncopied to the destination location in the Destination header, \nhttp://www.svr.com/OtherCollection/tuva.html.  \n\n4.5.4 Example: COPY on a Redirect Reference\n\nRequest:\n\nCOPY /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/tuva.html\n\nResponse:\n\nSlein et al.                                                    Page 16\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nHTTP/1.1 204 No Content\n\nIn this example, the request-URI identifies a redirect reference whose \ntarget resource is identified by \nhttp://www.svr.com/Asia/History/tuva.html.  In this case, the redirect \nreference was copied to the destination location in the Destination \nheader, http://www.svr.com/OtherCollection/tuva.html.  \n\nThe result would have been exactly the same, and the response would have \nbeen exactly the same, had the No-Passthrough header been used in the \nrequest.\n\n4.5.5 Example: COPY on a Collection That Contains a Direct Reference and \na Redirect Reference\n\nSuppose a COPY request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n   (ordinary resource) diary.html\n   (direct reference) tuva with target /Someplace/tuva.html\n   (redirect reference) nunavut with target /Someplace/nunavut.map\n\nRequest:\n\nCOPY /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this case, since /MyCollection/tuva is a direct reference, its target \nresource was copied into the new collection.  Since \n/MyCollection/nunavut is a redirect reference, the reference itself, and \nnot its target, was copied into the new collection.  So the resulting \ncollection is as follows:\n\n/OtherCollection/\n   (ordinary resource) diary.html\n   (ordinary resource) tuva.html\n   (redirect reference) nunavut \n\n4.6 Deleting and Moving Referential Resources\n\nThe DELETE method is used to delete referential resources.  For both \ndirect and redirect references, DELETE MUST affect the reference itself, \nand not its target.  Similarly, when a DELETE on a collection encounters \na reference in the subtree under that collection, it MUST delete the \nreference, and not its target.\n\nA MOVE operation on a referential resource MUST move the referential \nresource to a different location, and MUST NOT change the location of \n\nSlein et al.                                                    Page 17\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nits target. The DAV:reftarget property is unchanged after a MOVE.  \nSimilarly, when a MOVE on a collection encounters a reference in the \nsubtree under that collection, it MUST move the reference, and not its \ntarget.\n\nDELETE and MOVE differ from other methods in that they do not alter the \nresource that is being deleted or moved, but rather the collection that \ncontains its URI.  They change the membership of that collection.\n\nWhen a reference is added to a collection, the aim is to make it look as \nif the target resource were a member of that collection.  When the \nreference is removed from that collection, the aim is to change the \nmembership of that collection.  Membership of the target in any other \ncollections, either internally or by reference, should not be affected.  \nConsequently, DELETE and MOVE do not follow the normal rules of behavior \nfor references.  Instead, they are always applied to the reference \nitself, not to its target, and they never result in 302 status codes.\n\nAlthough clients MAY use the No-Passthrough header with DELETE and MOVE \nrequests, the header has no effect on their behavior.  Whether the No-\nPassthrough header is present or not, they are always applied to the \nreference.\n\n[WebDAV] defines MOVE to be logically equivalent to COPY followed by \nDELETE.  For direct references, MOVE is logically equivalent to COPY \nwith the No-Passthrough header followed by DELETE. \n\n4.7 Locking Referential Resources\n\nThe semantics of LOCK described here resulted from balancing a set of \nincompatible considerations:\n\no Ideally, a LOCK on a reference should lock both the reference and its \n  target resource.  The owner of an exclusive write lock, for example, \n  would be surprised if anyone else could modify the content of the \n  target resource while he held the lock.  He would also be surprised \n  if anyone else could delete the reference to it, or replace the \n  reference with one pointing to a different target.\no Non-referencing clients should be able to use both direct and \n  redirect references without encountering surprising results.\no Preserve the clear distinction between redirect and direct \n  references.  Redirect references should be simple for servers to \n  implement. In particular, a server should never have to resolve a \n  redirect reference.  A server should not have to provide proxy \n  capabilities in order to implement redirect references.  Direct \n  references rely on more sophisticated server capabilities to give \n  clients the illusion of operating directly on the target resource.\no There should be consistency between the behavior of LOCK on a single \n  referential resource and the behavior of LOCK on a collection that \n  contains referential resources.\no Keep the behavior of all requests to references as consistent as \n  possible.  Try to adhere to the general rule that in the absence of a \n  No-Passthrough header, all methods return a 302 when sent to a \n  redirect reference and are applied to the target when sent to a \n  direct reference.\n\nSlein et al.                                                    Page 18\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\no Be consistent with the LOCK semantics defined in [WebDAV].\n\nWe have compromised the intuitive locking behavior and support for non-\nreferencing clients in order to preserve various sorts of consistency. \n\n4.7.1 LOCK on Direct References \n\nLOCK follows the general principle that operations on direct references \nare applied to the target resource unless the No-Passthrough header is \nused.  When a LOCK request is sent to a direct reference without the No-\nPassthrough header, the target resource MUST be locked.  When a LOCK \nrequest with the No-Passthrough header is sent to a direct reference, \nthe reference itself MUST be locked.\n\nA principle followed throughout this specification is that behavior when \na reference is encountered during an operation on a collection must be \nthe same as behavior when operating on an individual reference.  When a \nLOCK request with Depth > 0 is sent to a collection, the targets of any \ndirect references encountered MUST be locked, unless the No-Passthrough \nheader is used.  If the No-Passthrough header is present on a LOCK \nrequest with Depth > 0 to a collection, then any direct references \nencountered MUST themselves be locked.\n\nAs was noted above, more intuitive results would have been obtained by \nrequiring that both the reference and its target to be locked in \nresponse to a LOCK request.  Reference-aware clients can obtain this \nresult by performing two LOCK operations, one with the No-Passthrough \nheader and one without.  Non-referencing clients cannot do so.  This \nmeans that for non-referencing clients there is always the risk that a \nreferencing client may delete or replace the reference that was used to \nlock a target resource while the non-referencing client has the target \nlocked.  To insure intuitive results for non-referencing clients, \nreferencing clients SHOULD be designed to check whether the target \nresource is locked before replacing, moving, or deleting a direct \nreference.\n\nUNLOCK behaves as specified in [WebDAV], unlocking all resources \nincluded in the lock identified by the Lock-Token header.\n\n4.7.2 LOCK on Redirect References\n\nThe behavior of LOCK for redirect references was determined by what is \npossible for the case of locking collections that contain redirect \nreferences.  \n\nThe expected behavior for any operation on a redirect reference is that \na 302 (Moved Temporarily) response will be returned, unless the No-\nPassthrough header is used.  However, this policy would have \nunacceptable consequences when locking a collection that contains \nredirect references.  Since [WebDAV} requires LOCK on a collection to be \nan atomic operation, if a 302 response is received for any member of the \ncollection, the entire LOCK must fail.  This would make it impossible to \nlock any collection that contained a redirect reference. \n\nTo avoid this result, a LOCK on a collection with Depth > 0 MUST lock \n\nSlein et al.                                                    Page 19\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nany redirect references it encounters, and not return 302 responses for \nthem, whether or not the No-Passthrough header is used.\n\nThis gives part of the expected lock behavior without forcing the server \nto resolve the redirect reference or become a proxy server in cases \nwhere the target resides on a different server. \n\nThere will be no hint in any response code that there are redirect \nreferences whose targets need to be locked.  The client will most likely \nnot lock any targets until it attempts an operation on the target and \ngets a 302 response.  Non-referencing clients cannot lock the targets of \nthe redirect references and may never realize that the targets have not \nbeen locked.  \n\nClearly, a LOCK with Depth = infinity on a collection MUST NOT follow \nany redirect references whose targets are collections into the target \ncollections; it MUST NOT cause any members of those target collections \nto be locked.\n\nThe behavior of LOCK for individual redirect references is designed to \nbe consistent with LOCK behavior for collections that contain redirect \nreferences.  Whether or not a No-Passthrough header is present, a LOCK \non a redirect reference MUST lock only the reference, not its target, \nand it MUST NOT return a 302 response.  The response MUST include the \nRef-Type and Ref-Target headers, so that a referencing client can lock \nthe target resource if it wishes.  \n\nUNLOCK behaves as specified in [WebDAV], unlocking all resources \nincluded in the lock identified by the Lock-Token header.\n\n4.7.3 Example: LOCK on a Direct Reference\n\nRequest:\n\nLOCK /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\nResponse:\n\nHTTP/1.1 200 OK\n\nSlein et al.                                                    Page 20\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:prop xmlns:D=\"DAV:\">\n   <D:lockdiscovery>\n      <D:activelock>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:locktype><D:write/></D:locktype>\n         <D:depth>0</D:depth>\n         <D:owner>\n            <D:href>http://www.svr.com/~jas/contact.html</D:href>\n         </D:owner>\n         <D:locktoken>\n            opaquelocktoken:e71dfae-5dec-22d6-fea5-00a0c91e6be4\n         </D:locktoken>\n      </D:activelock>\n   </D:lockdiscovery>\n</D:prop>\n\nIn this example, the request-URI identifies a direct reference whose \ntarget resource is identified by \nhttp://www.svr.com/Asia/History/tuva.html.  This target resource was \nsuccessfully locked.\n\n4.7.4 Example: LOCK on a Redirect Reference\n\nIn this example, the request and response would look identical to those \nin the previous section.  However, the request-URI in this case \nidentifies a redirect reference.  Since the request-URI identifies a \nredirect reference, the reference itself, and not its target, was \nlocked.\n\n4.7.5 Example: LOCK on a Collection That Contains a Direct Reference and \na Redirect Reference\n\nSuppose a LOCK request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n   (ordinary resource) diary.html\n   (direct reference) tuva\n   (redirect reference) nunavut\n\nRequest:\n\nLOCK /MyCollection/ HTTP/1.1\nHost: www.svr.com\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n\nSlein et al.                                                    Page 21\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\nResponse:\n\nHTTP/1.1 200 OK\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:prop xmlns:D=\"DAV:\">\n   <D:lockdiscovery>\n      <D:activelock>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:locktype><D:write/></D:locktype>\n         <D:depth>Infinity</D:depth>\n         <D:owner>\n            <D:href>http://www.svr.com/~jas/contact.html</D:href>\n         </D:owner>\n         <D:locktoken>\n            opaquelocktoken:e71dfae-5dec-22d6-fea5-00a0c91e6be4\n         </D:locktoken>\n      </D:activelock>\n   </D:lockdiscovery>\n</D:prop>\n\nThe collection was successfully locked.  In this case, since \n/MyCollection/tuva is a direct reference, its target resource was \nlocked.  Since /MyCollection/nunavut is a redirect reference, the \nreference itself, and not its target, was locked.  The ordinary resource \n/MyCollection/diary.html was successfully locked.\n\n4.8 Other WebDAV Operations on Redirect Referential Resources\n\nAlthough non-referencing WebDAV clients cannot create referential \nresources, they should be able to use the references created by \nreference-aware WebDAV clients.  They should be able to follow any \nreferences to their targets.  To make this possible, a server that \nreceives a PROPFIND, PROPPATCH, MKCOL, or MKREF request made via a \nredirect reference MUST return a 302 (Moved Temporarily) status code. \nThe client and server MUST follow [HTTP] Section 10.3.3 \"302 Moved \nTemporarily,\" but with these additional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Ref-Type header.  This header allows \n  reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nSlein et al.                                                    Page 22\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nA reference-aware WebDAV client can act on this response in one of two \nways.  It can, like a non-referencing client, resubmit the request to \nthe URI in the Location header in order to operate on the target \nresource.  Alternatively, it can resubmit the request to the URI of the \nredirect reference with the No-Passthrough header in order to operate on \nthe reference itself.  If the No-Passthrough header is present, the \nrequest MUST be applied to the reference itself, and a 302 response MUST \nNOT be returned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, it can save the round trip \ncaused by the 302 response by using No-Passthrough in its initial \nrequest to the URI.\n\nSince MKCOL and MKREF fail when applied to existing resources, if the \nclient attempts to resubmit the request to the target resource, the \nrequest MUST fail (unless the reference is a dangling reference).  \nSimilarly, if the client attempts to resubmit the request to the \nreference with a No-Passthrough header, the request MUST fail.\n\n4.8.1 Example: PROPPATCH on a Redirect Reference\n\n4.9 Other WebDAV Operations on Direct Referential Resources\n\nWith the exception of DELETE and MOVE, which were discussed above, \noperations on direct references affect the target resource, not the \nreference, unless the No-Passthrough header is used.  Specifically:\n\nUnless the No-Passthrough header is used, a PROPPATCH on a direct \nreference MUST modify the properties of its target resource, not the \nproperties of the reference itself. \n\nUnless the No-Passthrough header is used, a PROPFIND on a direct \nreference MUST return the properties of its target resource, not the \nproperties of the reference itself.\n\nIf the No-Passthrough header is used with a PROPPATCH or PROPFIND \nrequest on a direct reference, the operation MUST be applied to the \nreference itself rather than to its target resource.\n\nMKCOL and MKREF fail if their request-URI identifies an existing \nresource of any kind.  Consequently, when submitted to a target resource \nvia a direct reference, they MUST fail unless the reference is a \ndangling reference.  If they are submitted to an existing direct \nreference with the No-Passthrough header, they MUST also fail.\n\n4.9.1 Example: PROPPATCH on a Direct Reference\n\n4.10 HTTP Operations on Redirect Referential Resources\n\nAlthough existing HTTP clients cannot create referential resources, they \nshould be able to use collections created by reference-aware WebDAV \nclients.  They should be able to follow any references identified by \nURIs in those collections to their targets.  To enable existing HTTP \n\nSlein et al.                                                    Page 23\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nclients to use GET, HEAD, PUT, POST, or OPTIONS via redirect references, \na server that receives any of these requests on a redirect reference \nMUST return a 302 (Moved Temporarily).  The client and server MUST \nfollow [HTTP] Section 10.3.3 \"302 Moved Temporarily,\" but with these \nadditional rules: \n\no The Location response header MUST contain the target URI of the \n  reference.  \n\no The response MUST include the Ref-Type header.  This header allows \n  reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nReference-aware clients can act on a 302 response in either of two ways.  \nLike plain HTTP clients, they can resubmit the request to the URI in the \nLocation header (the URI of the target resource).  They may, however, \nwant to operate on the reference rather than on its target.  In this \ncase, they may resubmit the request to the URI of the reference and \ninclude the No-Passthrough header with the request.  If the No-\nPassthrough header is present, the request MUST be applied to the \nreference itself, and a 302 response MUST NOT be returned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, it can save the round trip \ncaused by the 302 response by using No-Passthrough in its initial \nrequest to the URI.\n\nThe No-Passthrough header can be used with GET or HEAD to retrieve the \nentity headers of a redirect reference.  When No-Passthrough is used \nwith GET or HEAD, the referencing entity headers (Ref-Type and Ref-\nTarget) MUST be returned, along with all HTTP headers that make sense \nfor references (at a minimum, Cache-Control, Age, ETag, Expires, and \nLast-Modified).  \n\nThe No-Passthrough header can be used with PUT to replace the redirect \nreference with an ordinary resource.  It can be used with OPTIONS to \nretrieve the capabilities of a redirect reference.  \n\nClients MUST NOT, however, use the No-Passthrough header with POST. \nSince a reference cannot accept another entity as its subordinate, an \nattempt to POST to a reference with No-Passthrough will also fail.  If a \nserver receives a POST request with the No-Passthrough header on a \nredirect reference, it MUST fail the request with a 400 (Bad Request) \nstatus code.\n\n4.10.1 Example: GET on a Redirect Reference\n\n4.10.2 Example: GET on a Redirect Reference with No-Passthrough\n\n4.11 HTTP Operations on Direct Referential Resources\n\nGET, HEAD, PUT, POST, and OPTIONS on direct references are automatically \npassed through to their target resources.  GET MUST return the content \nand headers of the target resource, HEAD MUST return the headers of the \ntarget resource, PUT MUST replace the content of the target resource, \n\nSlein et al.                                                    Page 24\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nPOST MUST perform the expected function at the target resource, and \nOPTIONS MUST report the communication options available at the target \nresource.\n\nThe No-Passthrough request header MAY be used with GET, HEAD, PUT, or \nOPTIONS to view the headers or capabilities of the reference, rather \nthan its target.  \n\nThe No-Passthrough request header MUST NOT be used with POST, which \ncannot be applied to references.  If a server receives a POST request on \na direct reference with the No-Passthrough header, it MUST fail the \nrequest with a 400 (Bad Request) status code.\n\n4.11.1 Example: GET on a Direct Reference\n\n4.11.2 Example: GET on a Direct Reference with No-Passthrough\n\n4.12 Operations on Targets of Referential Resources\n\nIn general, operations on targets of weak referential resources have no \neffect on the referential resource.  However, servers that choose to \nmaintain the integrity of references are free to make changes to the \nstate of references when moving or deleting their targets.\n\nWhen moving a target resource, a server MAY insert an optional step into \nthe semantics of MOVE as defined in [WebDAV] for the purpose of \nmaintaining referential integrity.  Between the copy step and the delete \nstep of a MOVE, the server MAY perform an update step, which changes the \nDAV:reftarget property of any references to the target to reflect its \nnew location.\n\nWhen deleting a target resource, a server MAY perform any internal \noperations necessary to implement its policy on preserving referential \nintegrity.  For example, it might delete any references to the deleted \ntarget, or it might flag them as having a deleted target, or it might \nreplace references with copies of the target.\n\n4.13 Discovering a Target's References\n\nAn OPTIONAL DAV:references property on the target resource provides a \nlist of referential resources whose DAV:reftarget property points to \nthat target resource. By retrieving this property, a client can discover \nthe URIs of the references that point to the target, and so can also \ndiscover the collections that contain those URIs as members.  As for all \nDAV: properties, this specification is silent as to how the \nDAV:references property is implemented on the server.\n\nThe DAV:references property is expected to be supported mainly by \nDocument Management Systems (DMSs) and other servers that will maintain \nthe property only for references within their own domain.  It is not in \ngeneral possible for a server to maintain the property for references on \nother servers.  If a reference on a different server points to the \ntarget, the server where the target is located is unlikely to know about \nthat reference.  This protocol provides no mechanism for one server to \nnotify another of the creation of a reference to one of its resources.  \n\nSlein et al.                                                    Page 25\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nConsequently, the list of references in DAV:reftarget may be incomplete.\n\nRationale: A number of scenarios require clients to navigate from a \ntarget resource to the references that point to it, and to the \ncollections that contain the URIs of those references.  This capability \nis particularly important for DMSs, which may populate their collections \nentirely by reference.  Their clients may need to determine, for any \nobject in the DMS, what collections contain URIs that identify \nreferences to that object.  It is also important in other contexts.  For \nexample, some servers enforce referential integrity by refusing to \ndelete any resource that is referenced by other resources.  In such an \nenvironment, the client must be able to discover the references in order \nto delete them before attempting to delete the target.\n\nRisks: When deciding whether to support the DAV:references property, \nserver implementers / administrators should balance the benefits it \nprovides against the cost of maintaining the property and the security \nrisks enumerated in Sections 12.4 and 12.5.\n\n4.14 Behavior of Dangling Direct References\n\nWhenever the No-Passthrough header accompanies a request on a dangling \ndirect reference, the request succeeds.  Since No-Passthrough causes the \nrequest to be applied to the reference rather than to its target, it \ndoes not matter that the target resource does not exist.  The client \nwill not be informed that the reference points to a nonexistent target.\n\nIn the absence of the No-Passthrough header, the responses MUST be as \nfollows:\n\nGET, HEAD, OPTIONS, POST, PROPFIND, PROPPATCH, LOCK, UNLOCK, and COPY \nrespond with 404 (Not Found), but the Ref-Type and Ref-Target headers \nare included in the response, so that the client can tell that it is the \ntarget, and not the reference, that was not found.\n\nIf, however, a PROPFIND, LOCK, UNLOCK, or COPY with Depth header greater \nthan 0 on a collection encounters a dangling direct reference inside the \ncollection, the response is a 207 (Multi-Status).  The DAV:response \nelement for the dangling reference will have a status of 404 (Not \nFound). The DAV:reftype and DAV:reftarget properties of the references \nare included in the response.  Their presence informs the client that it \nis the target, not the reference, that was not found.  Including these \ntwo properties requires an extension to the DAV:response element as \ndefined in {WEBDAV].  This extension is defined in Section 9 below.\n\nPUT succeeds, creating a new resource at the location specified by the \nreference's DAV:reftarget property.\n\nMKREF and MKCOL succeed, since there is no existing resource at the \ntarget URI.\n\nMOVE and DELETE succeed, since they always affect the reference rather \nthan its target.  For MOVE, the reference at the destination will be \nbroken, just as the reference at the source was.\n\n\nSlein et al.                                                    Page 26\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n4.14.1 Example: PROPFIND on a Collection with a Dangling Direct \nReference\n\nRequest:\n\nPROPFIND /collection1/ HTTP/1.1\nHost: www.somehost.com\nDepth: 1\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop xmlns:X=\"http://www.somehost.com/schemas/x\">\n      <X:author/>\n      <X:title/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.somehost.com/collection1/</D:href>\n      <D:propstat>\n         <D:prop xmlns:X=http://www.somehost.com/schemas/x>\n            <X:author>Smith, J.H.</X:author>\n            <X:title>My Working Collection</X:title>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.somehost.com/collection1/directref7</D:href>\n      <D:status>HTTP/1.1 404 Not Found</D:status>\n      <D:prop>\n         <D:reftype><D:direct/></D:reftype>\n         <D:reftarget>\n            <D:href>/collection2/file19</D:href>\n         </D:reftarget>\n      </D:prop>\n      <D:responsedescription>Target resource not found.      \n      </D:responsedescription>\n   </D:response>\n</D:multistatus>\n\n4.15 Chains of Direct References\n\nUnless a No-Passthrough header is present, any operation on a direct \nreference that is part of a chain of direct references MUST get passed \n\nSlein et al.                                                    Page 27\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nthrough to the target of the last reference in the chain.\n\nA server cannot tell whether a dangling reference once pointed to an \nordinary resource or to another reference in a chain of direct \nreferences.  When a break occurs before the end of a chain of direct \nreferences, the server's behavior will be the same as for any other \ndangling direct reference, as described in Section 4.13.  For example, a \nPUT will create the new resource at the location specified by the \nDAV:reftarget property of the broken reference, even if that is in the \nmiddle of what was once a chain of direct references.\n\n4.16 Relative URIs in Ref-Target and DAV:reftarget\n\nThe Generic-Coded-url in a Ref-Target header MAY be a relative URI.  \nSimilarly, the href in a DAV:reftarget property MAY be a relative URI.  \nIn both cases, the base URI to be used for resolving the relative URI to \nabsolute form is the URI of the reference to which the Ref-Target header \nor DAV:reftarget property belongs.  \n\nIn the case of a Ref-Target header in a request, the base URI is \nconstructed as follows: Its scheme component is \"http\", its authority \ncomponent is the value of the Host header in the request, and its path \ncomponent is the request-URI in the request.  See [URI] Section 5 for a \ndiscussion of relative URI references and how to resolve them.\n\nWhen a single Ref-Target header is included in a response, its base URI \nis constructed in the same way.  However, if multiple Ref-Target headers \nare included, as in the chain of references in Section 4.15, the \nsituation is more complicated.  The base URI for the Ref-Target at hop 0 \nis constructed from the scheme component \"http\", the value of the Host \nheader in the request, and the request-URI.  But the base URI for the \nRef-Target at each succeeding hop is the absolute-URI of the reference \nat the preceding hop.\n\nThe DAV:reftarget property appears in the protocol only in the context \nof a Multi-Status response, in a response element that contains a single \nDAV:href element.  The value of this DAV:href element serves as the base \nURI for resolving a relative URI in DAV:reftarget.  (The value of \nDAV:href may itself be relative, in which case it must be resolved first \nin order to serve as the base URI for the relative URI in \nDAV:reftarget.)  If the DAV:href element is relative, its base URI is \nconstructed from the scheme component \"http\", the value of the Host \nheader in the request, and the request-URI.\n\n4.16.1 Example: Resolving a Relative URI in Ref-Target\n\nRequest:\n\nMKREF /north/inuvik HTTP/1.1\nHost: www.somehost.edu\nRef-Type: direct\nRef-Target: mapcollection/inuvik.gif\nRef-Integrity: do-not-enforce\n\nResponse:\n\nSlein et al.                                                    Page 28\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nHTTP/1.1 201 Created\n\nIn this example, the base URI is http://www.somehost.edu/north/inuvik.  \nThen, following the rules in [URI] Section 5, the relative URI in Ref-\nTarget resolves to the absolute URI \nhttp://www.somehost.edu/north/mapcollection/inuvik.gif. \n\n4.16.2 Example: Resolving a Relative URI in DAV:reftarget\n\nRequest:\n\nPROPFIND /geog/ HTTP/1.1\nHost: www.xxsvr.com\nNo-Passthrough:\nDepth: 1\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1/0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>/geog/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n     </D:propstat>\n     <D:propstat>\n         <D:prop><D:reftype/> <D:reftarget/>/D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n     </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>/geog/stats.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:reference/></D:resourcetype>\n            <D:reftype>direct</D:reftype>\n\nSlein et al.                                                    Page 29\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            <D:reftarget>statistics/population/1997.html</D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 ok</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nIn this example, the relative URI statistics/population/1997.html is \nreturned as the value of reftarget for the reference identified by href \n/geog/stats.html.  The href is itself a relative URI, which resolves to \nhttp://www.xxsrv.com/geog/stats.html.  This is the base URI for \nresolving the relative URI in reftarget.  The absolute URI of reftarget \nis http://www.xxsrv.com/geog/statistics/population/1997.html.\n\n4.17 URIs and References\n\nIn a request-URI /segment1/segment2/segment3, any of the three segments \nmay identify a reference.  (See [URI], Section 3.3, for definitions of \n\"path\" and \"segment\".)  Servers will be unable to resolve such URIs \nunless certain constraints hold.  If any segment of the path identifies \na reference, that reference MUST ultimately resolve to a resource that \nbehaves as a container.  (Examples are WebDAV collections, tar files, \nand some CGI scripts.)  The succeeding segment of the path MUST resolve \nto a resource that is immediately contained in that container.\n\nConsider request-URI /x/y/z.html.  Suppose that /x/ is a reference whose \ntarget is collection /a/, which contains reference y whose target is \ncollection /b/, which contains reference z.html whose target is \n/c/d.html.  \n\n/x/ -----> /a/\n           /a/y/ -----> /b/\n                        /b/z.html -----> /c/d.html\n\nThe server is able to resolve the request-URI because each segment of \nthe URI's path satisfies the constraints stated above.  Except for the \nfinal segment, each segment that is a reference resolves to a collection \nthat contains the next segment as an internal member.  The final \nsegment, which is a reference, does have a target resource. \n\nIf the references are direct references, the server automatically \napplies the request to the ultimate target, /c/d.html.\n\nIf the references are redirect references, the client must follow up \nthree separate 302 responses before finally reaching the target \nresource.  The server responds to the initial request with a 302 with \nLocation: /a/y/z.html, and the client resubmits the request to \n/a/y/z.html.  The server responds to this request with a 302 with \nLocation: /b/z.html, and the client resubmits the request to /b/z.html.  \nThe server responds to this request with a 302 with Location: /c/d.html, \nand the client resubmits the request to /c/d.html.  This final request \nsucceeds.\n\n5 Ordered Collections\n\n\nSlein et al.                                                    Page 30\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n5.1 Overview\n\nCollections on a compliant server may be ordered, but need not be.  It \nis up to the client to decide whether a given collection is ordered and, \nif so, to specify the semantics to be used for ordering its members.  If \na collection is ordered, each of its members must be in the ordering \nexactly once, and the ordering must not include any resource that is not \na member of the collection.  Only one ordering can be attached to any \ncollection.  Multiple orderings of the same resources can be achieved by \ncreating multiple collections referencing those resources, and attaching \na different ordering to each collection.\n\nThe server is responsible for enforcing these constraints on orderings.  \nThe server MUST remove a member URI from the ordering when it is removed \nfrom the collection. The server MUST add a member URI to the ordering \nwhen it is added to the collection.\n\nWhen responding to a PROPFIND on a collection, the server MUST order the \nresponse elements according to the ordering defined on the collection.\n\nOrderings may be client-maintained or server-maintained.  This protocol \nprovides support for both types of orderings.\n\n5.2 Creating an Ordered Collection\n\n5.2.1 Overview \n\nWhen a collection is created, the client MAY request that it be ordered \nand specify the semantics of the ordering by using the new Ordered \nheader (defined in Section 6.5) in the MKCOL request.   \n\nFor collections that are ordered, the client SHOULD identify the \nsemantics of the ordering with a URI in the Ordered header.  This URI \nmay identify a server-maintained ordering.  Clients can discover the \navailable server-maintained orderings using the mechanism defined in \nSection 10.3.  The URI may identify a semantics for a client-maintained \nordering, providing the information a human user or software package \nneeds to insert new collection members into the ordering intelligently.  \nAlthough the URI in the Ordered header MAY point to a resource that \ncontains a definition of the semantics of the ordering, clients are \ndiscouraged from accessing that resource, in order to avoid \noverburdening its server.  The client MAY set the header value to \nDAV:custom to indicate that the collection is ordered, but the semantics \nof the ordering are not being advertised.  If the client does not want \nthe collection to be ordered, it may omit the Ordered header, or use it \nwith the value DAV:unordered.\n\nIf the server does not recognize the value of the Ordered header as one \nof its server-maintained orderings, it MUST assume that a client-\nmaintained ordering is intended.  If the value of the Ordered header is \none of the server-maintained orderings that the server supports, it MUST \nmaintain the collection's ordering according to that ordering semantics \nas new members are added.\n\nEvery collection MUST have the new DAV:orderingtype property (defined in \n\nSlein et al.                                                    Page 31\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nSection 7.6), which indicates whether the collection is ordered and, if \nso, identifies the semantics of the ordering.  The server sets the \ninitial value of this property based on the value of the Ordering header \nin the MKCOL request.\n\nIf the collection is ordered, the server MUST respond to PROPFIND \nrequests on the collection using the specified ordering. If the \ncollection is unordered, the client cannot depend on the repeatability \nof the ordering of results from a PROPFIND request.\n\n5.2.2 Example: Creating an Ordered Collection\n\nRequest:\n\nMKCOL /theNorth/ HTTP/1.1\nHost: www.server.org\nOrdered: http://www.server.org/orderings/compass.html\n\nResponse:\n\nHTTP/1.1 201 Created\n\nIn this example, a new, ordered collection was created.  Its \nDAV:orderingtype property has as its value the URI from the Ordered \nheader.  In this case, the URI identifies the semantics governing a \nclient-maintained ordering.  As new members are added to the collection, \nclients or end users can use the semantics to determine where to \nposition the new members in the ordering. \n\n5.3 Setting the Position of a Collection Member\n\n5.3.1 Overview\n\nWhen a new member is added to a collection with a client-maintained \nordering (for example, with PUT, MKREF, or MKCOL), its position in the \nordering can be set with the new Position header (defined in Section \n6.6).  The Position header allows the client to specify that the member \nshould be first in the collection's ordering, last in the collection's \nordering, before some other collection member in the collection's \nordering, or after some other collection member in the collection's \nordering.\n\n5.3.2 Status Codes\n\nSome likely client errors and the corresponding response status codes \ninclude: \n\n409 (Conflict): The request may be attempting to position the collection \nmember before or after a URI that is not in the collection, or before or \nafter itself, or it may be attempting to position the collection member \nin an unordered collection or in a collection with a server-maintained \nordering.\n\n5.3.3 Examples: Setting the Position of a Collection Member\n\n\nSlein et al.                                                    Page 32\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nRequest:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: http://www.ics.uci.edu/i-d/draft-webdav-protocol-08.txt\nPosition: After <requirements.html>       \n\nResponse:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  The Position header in this \nexample caused the server to set its position in the ordering of the \n/~whitehead/dav/ collection immediately after requirements.html.\n\nRequest:\n\nMOVE /i-d/draft-webdav-protocol-08.txt HTTP/1.1\nHost: www.ics.uci.edu\nDestination: http://www.ics.uci.edu/~whitehead/dav/draft-webdav-\n     protocol-08.txt\nPosition: First\n\nResponse:\n\nHTTP/1.1 409 Conflict\n\nIn this case, the server returned a 409 Conflict status code because the \n/~whitehead/dav/ collection is an unordered collection.  Consequently, \nthe server was unable to satisfy the Position header.\n\n5.4 Changing the Semantics of a Collection Ordering\n\nAfter a collection has been created, a client can change its ordering \nsemantics, or change an ordered collection to an unordered collection or \nvice versa, by using PROPPATCH to change the value of its \nDAV:orderingtype property (defined in Section 7.6).  If the new value \nidentifies a client-maintained ordering, the client is then responsible \nfor updating the ordering of the collection members according to the new \nsemantics.  If it identifies a server-maintained ordering, the server \nMUST reorder the collection according to the new semantics.  PROPPATCH \nis defined in [WebDAV], Section 7.2.\n\n5.5 Changing the Position of a Collection Member\n\n5.5.1 The ORDERPATCH Method\n\nTo change the positions of collection members in the collection's \nordering, the client MUST use an ORDERPATCH request with a request body \ncontaining an order XML element.  The request-URI of an ORDERPATCH \nrequest is the URI of the collection whose ordering is to be updated.  \nThe order XML element identifies the member URIs whose positions are to \nbe changed, and describes their new positions in the ordering.  Each new \n\nSlein et al.                                                    Page 33\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nposition can be specified as first in the ordering, last in the \nordering, before some other collection member in the ordering, or after \nsome other collection member in the ordering.  The server MUST apply the \nchanges in the order they appear in the order element.\n\n5.5.2 Status Codes\n\nSince multiple changes can be requested in a single ORDERPATCH request, \nthe server MUST return a 207 (Multi-Status) response, as defined in \n[WebDAV].\n\nThe following are examples of response codes one would expect to be used \nin a 207 (Multi-Status) response for this method: \n\n200 (OK): The change in ordering was successfully made.\n\n409 (Conflict): An attempt was made to position the collection member \nbefore or after a URI that is not in the collection, or before or after \nitself, or an attempt was made to position the collection member in an \nunordered collection or in a collection with a server-maintained \nordering.\n\nA request to reposition a collection member to the same place in the \nordering is not an error. \n\n5.5.3 Example: Changing the Positions of Collection Members in the \nOrdering\n\nConsider a collection /coll-1/ with members ordered as follows:\n\nnunavut.map\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\nnunavut.desc\niqaluit.img\niqaluit.desc\n\nRequest:\n\nORDERPATCH /coll-1/ HTTP/1.1\nHost: www.nunanet.com\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:order xmlns:d=\"DAV:\">\n   <d:ordermember>\n      <d:href>nunavut.desc</d:href>\n      <d:position> \n         <d:after>\n            <d:href>nunavut.map</d:href>\n         </d:after>\n\nSlein et al.                                                    Page 34\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n      </d:position>\n   </d:ordermember>\n   <d:ordermember>\n      <d:href>iqaluit.img</d:href>\n      <d:position>\n         <d:last/>\n      </d:position>\n   </d:ordermember>\n</d:order>\n\nResponse:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/nunavut.desc</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/iqaluit.img</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n</d:multistatus>\n\nIf the href elements are relative URIs, as in this example, they are \ninterpreted relative to the collection that is being reordered.  In this \nexample, after the request has been processed, the collection's ordering \nis as follows:\n\nnunavut.map\nnunavut.desc\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\niqaluit.desc\niqaluit.img\n\n6 Headers\n\n6.1 Ref-Target Entity Header\n\nRef-Target = \"Ref-Target\" \":\" (absoluteURI | relativeURI)\n\nThe Ref-Target header is used with MKREF requests to identify the target \nresource of the new referential resource being created.  For an example, \nsee Section 4.3.3.\n\nTo comply with the rules specified in [HTTP] for responding to GET and \nHEAD requests, the Ref-Target entity header is also included in \n\nSlein et al.                                                    Page 35\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nresponses to GET and HEAD that include the No-Passthrough header.  (See \nSections 4.10 and 4.11.) The Ref-Target header is also included in 404 \nerror responses for dangling references.  (See Section 4.14.)\n\n6.2 Ref-Type Entity Header\n\nRef-Type = \"Ref-Type\" \":\" (\"DAV:direct\" | \"DAV:redirect\" | ext-ref-type)\next-ref-type = quoted-URL \n\nThe Ref-Type header is defined to distinguish between direct and \nredirect references.  The possible values of this header are DAV:direct, \nDAV:redirect, and ext-ref-type. The value ext-ref-type provides \nextensibility.  \n\nThis header may be included in MKREF requests to tell the server what \nsort of reference to create.  If the header is not present on a MKREF \nrequest, the server MUST treat the request as if it has a Ref-Type \nheader with the value DAV:redirect.  \n\nTo comply with the rules specified in [HTTP] for responding to GET and \nHEAD requests, the Ref-Type entity header is also included in responses \nto GET and HEAD that include the No-Passthrough header (see Sections \n4.10 and 4.11).  \n\nThe Ref-Type header is also included in 404 error responses for dangling \nreferences (see Section 4.14) to distinguish this case from the case \nwhere the reference itself is not found.  It is included in 302 \nresponses for redirect references (see Sections 4.2, 4.8, and 4.10) to \ndistinguish these responses from ordinary HTTP 1.1 redirects.\n\n6.3 Ref-Integrity Request Header\n\nRef-Integrity = \"Ref-Integrity\" \":\" (\"DAV:do-not-enforce\" | \n                                      ext-ref-integrity)\next-ref-integrity = quoted-URL\n\nThe Ref-Integrity header is defined primarily to allow future support \nfor strong references.  It specifies whether and how the server should \nenforce referential integrity for a referential resource being created \nwith MKREF. \n\nThe value \"DAV:do-not-enforce\" means that the client wants the server \nnot to enforce referential integrity for the newly created reference.  A \nclient might use this value if, for example, it wanted to populate a \ncollection with references before their content was made available on \nthe Web.  If the server cannot honor a Ref-Integrity value of \"DAV:do-\nnot-enforce\" in a MKREF request, it MUST fail the request with status \ncode ???.\n\nClients may use other values of the Ref-Integrity header, to specify the \ndesired policy for enforcing referential integrity.  Clients can \ndiscover the valid values for Ref-Integrity for a given request-URI by \nsubmitting an OPTIONS request to that URI and including the \nDAV:refintegrityoptions element in the request body (see Section 10).  \nIf a server receives an extension value that it does not understand, it \n\nSlein et al.                                                    Page 36\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nMUST fail the request with status code 400 (Bad Request).\n\nIf the Ref-Integrity header is not present on a MKREF request, the \nserver MUST fail the request with status code 400 (Bad Request).\n\n6.4 No-Passthrough Request Header\n\nNo-Passthrough = \"No-Passthrough\" \":\"\n\nThe optional No-Passthrough header can be used on any request to a \nreference except POST.  For a direct reference, if the No-Passthrough \nheader is present, the request MUST be applied to the reference itself \nrather than to its target.  For a redirect reference, if the No-\nPassthrough header is present, the request MUST be applied to the \nreference itself, and a 302 response MUST NOT be returned.  If the No-\nPassthrough header is used on a request to any other sort of resource \nbesides a reference, the server SHOULD ignore it.  If the No-Passthrough \nheader is used with a POST request to a reference, the server MUST \nrespond with a 400 (Bad Request).\n\nThe No-Passthrough header can be used with PROPFIND requests on \ncollections with Depth = infinity.  When it is used in this way, the \nserver MUST return the properties of any redirect references in the \ncollection, and not return 302 (Moved Temporarily) status codes for \nthem.  It MUST also return the properties of any direct references in \nthe collection (not the properties of their targets), and it MUST NOT \nfollow any direct references to collections into their target \ncollections.\n\nThe No-Passthrough header can be used with LOCK requests on collections \nwith Depth = infinity.  When it is used in this way, the server MUST \nlock any redirect references in the collection, just as it would if the \nNo-Passthrough header were absent.  It MUST also lock any direct \nreferences in the collection (not their target resources), and it MUST \nNOT follow any direct references to collections into their target \ncollections.\n\nThe No-Passthrough header can be used with COPY requests on collections \nwith Depth > 0.  When it is used in this way, the server MUST copy any \nredirect references in the collection, just as it would if the No-\nPassthrough header were absent.  It MUST also copy any direct references \nin the collection (not their target resources), and it MUST NOT follow \nany direct references to collections into their target collections.\n\n6.5 Ordered Entity Header\n\nOrdered = \"Ordered\" \":\" (\"DAV:unordered\" | \"DAV:custom\" | absoluteURI)\n\nThe Ordered header may be used with MKCOL to request that the new \ncollection be ordered and to specify its ordering semantics.  A value of \n\"DAV:unordered\" indicates that the collection is not ordered. A value of \n\"DAV:custom\" indicates that the collection is to be ordered, but the \nsemantics of the ordering is not being advertised.  Any other \nabsoluteURI value indicates that the collection is ordered, and \nidentifies the semantics of the ordering.  The absoluteURI MAY point to \n\nSlein et al.                                                    Page 37\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\na resource that contains a definition of the semantics of the ordering.  \n\nIf the Ordered header is present on a MKCOL request, the server MUST set \nthe collection's DAV:orderingtype property to the value of the Ordered \nheader.  If the Ordered header is not present, the server MUST treat the \nrequest as if it had an Ordered header with the value \"DAV:unordered\".  \n\n6.6 Position Request Header\n\nPosition = \"Position\" \":\" (\"First\" | \"Last\" | \n                           ((\"Before\" | \"After\") Generic-Coded-url))\nGeneric-Coded-url = \"<\" (absoluteURI | relativeURI) \">\"\nabsoluteURI and relativeURI are defined in [URI].\n\nThe Position header may be used with any method that adds a member to a \ncollection with a client-maintained ordering, to tell the server where \nin the collection ordering to position the new member being added to the \ncollection.  It may be used for both ordinary and referential members.\n\nIf the Coded-url is a relative URL, it is interpreted relative to the \ncollection to which the new member is being added. \n\nThe server MUST insert the new member into the ordering at the location \nspecified in the Position header, if one is present (and if the \ncollection has a client-maintained ordering). \n\nIf the request is replacing an existing resource, and the Position \nheader is present, the server MUST remove the member from its previous \nposition, and then insert it at the requested position.\n\nIf the Position request header is not used when adding a member to a \ncollection with a client-maintained ordering, then:\n\nIf the request is replacing an existing resource, the server MUST \npreserve the present ordering.\n\nIf the request is adding a new member to the collection, the server MUST \nappend the new member to the end of the ordering.\n\nIf an attempt is made to use the Position header on a collection that is \nunordered or that has a server-maintained ordering, the server MUST fail \nthe request with a 409 (Conflict) status code.\n\n7 Properties\n\n7.1 reftarget Property\n\nName:\t    reftarget\nNamespace:  DAV:\nPurpose:    A property of referential resources that provides an \n            efficient way for clients to discover the URI of the target \n            resource.  This is a read-only property, whose value can \n            only be set by using the Ref-Target header with a MKREF \n            request.\nValue: \t    URI of the target resource.  This value MAY be a relative       \n\nSlein et al.                                                    Page 38\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            URI.  The reftarget property can occur in the entity bodies \n            of responses to a variety of requests.  It always occurs in \n            the context of a Multi-Status response, inside a \n            DAV:response element that has a single DAV:href element.  \n\n<!ELEMENT reftarget href>\n\n7.2 refintegrity Property\n \nName:\t    refintegrity\nNamespace:  DAV:\nPurpose:    A property of a referential resource that indicates whether \n            and how the server enforces referential integrity for that \n            reference.  The refintegrity property is defined to allow \n            future support for strong references.  The only value \n            currently defined for refintegrity is weak, which means that \n            the server does not enforce referential integrity for the \n            reference.  A server may assign another value to identify \n            its policy for enforcing referential integrity for the \n            reference.  This is a readonly property, set based on the \n            value of the Ref-Integrity header in the MKREF request that \n            created the reference.\nValue:\t    weak or an extension value\n\n<!ELEMENT refintegrity (weak | #PCDATA)>\n\n7.3 reftype Property\n\nName:       reftype\nNamespace:  DAV:\nPurpose:    A property of a referential resource that identifies the        \n            reference as direct or redirect.  This is a read-only \n            property, whose value can only be set by using the Ref-Type \n            header with a MKREF request.\nValue:      direct, redirect, or an extension value\n\n<!ELEMENT reftype (direct | redirect | #PCDATA)>\n\n7.4 location Property\n\nName:       location\nNamespace:  DAV:\nPurpose:    For use with 302 (Moved Temporarily) response codes in \n            Multi-Status responses.  It contains the absolute URI of the \n            temporary location of the resource.  In the context of \n            redirect references, this value is the absolute URI of the \n            target resource.  It is analogous to the Location header in \n            HTTP 302 responses defined in [HTTP] Section 10.3.3 \"302 \n            Moved Temporarily.\"  Including the location property in a \n            Multi-Status response requires an extension to the syntax of \n            the DAV:response element defined in [WebDAV], which is \n            defined in Section 9 below.  This property is not expected \n            to be stored on the reference. It is modeled as a property \n            only so that it can be returned inside a DAV:prop element in \n            a Multi-Status response.\n\nSlein et al.                                                    Page 39\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nValue:      href containing the absolute URI of the target resource.\n\n<!ELEMENT location href >\n\n7.5 references Property\n\nName:\t    references\nNamespace:  DAV:\nPurpose:    Enables clients to discover, for any target resource, what \n            references point to it and what collections contain it by \n            reference.  This is an optional property.  If present, it is \n            a read-only property, maintained by the server.\nValue:\t    List of the URIs of the references that point to the target \n            resource.\n\n<!ELEMENT references (href*)>\n\n7.6 orderingtype Property\n\nName:\t    orderingtype\nNamespace:  DAV:\nPurpose:    Indicates whether the collection is ordered and, if so, \n            uniquely identifies the semantics of the ordering being \n            used.  May also point to an explanation of the semantics in \n            human and / or machine-readable form.  At a minimum, this \n            allows human users who add members to the collection to \n            understand where to position them in the ordering.\nValue:\t    unordered for an unordered collection, or a URI that \n            uniquely identifies the semantics of the collection's \n            ordering.  The value custom indicates that the collection is \n            ordered, but the semantics are not being advertised. \n\n<!ELEMENT orderingtype (unordered | custom | href) >\n\n8 XML Elements\n\n8.1 reference XML Element\n\nName: \t    reference\nNamespace:  DAV:\nPurpose:    A new value of the DAV:resourcetype property that identifies \n            its resource as a referential resource.  \nValue:\t    EMPTY\n\n<!ELEMENT reference EMPTY >\n\n8.2 direct XML Element\n\nName:\t    direct\nNamespace:  DAV:\nPurpose:    A value for the DAV:reftype property that identifies its \n            resource as a direct reference.\nValue:      EMPTY\n\n<!ELEMENT direct EMPTY >\n\nSlein et al.                                                    Page 40\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\n8.3 redirect XML Element\n\nName:\t    redirect\nNamespace:  DAV:\nPurpose:    A value for the DAV:reftype property that identifies its \n            resource as a redirect reference.\nValue:      EMPTY\n\n<!ELEMENT redirect EMPTY >\n\n8.4 weak XML Element\n\nName:\t    weak\nNamespace:  DAV:\nPurpose:    A value of the DAV:refintegrity property.  It means that the \n            server does not enforce referential integrity for the \n            reference to which the property belongs.\nValue: \t    EMPTY\n\n<!ELEMENT weak EMPTY >\n\n8.5 unordered XML Element\n\nName:\t    unordered\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is not ordered.  That is, the client cannot \n            depend on the repeatability of the ordering of results from \n            a PROPFIND request.\nValue:\t    EMPTY\n\n<!ELEMENT unordered EMPTY >\n\n8.6 custom XML Element\n\nName: \t    custom\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is ordered, but the semantics of the ordering \n            are not being advertised. \nValue: \t    EMPTY\n\n<!ELEMENT custom EMPTY >\n\n8.7 order XML Element\n        \nName: \t    order\nNamespace:  DAV:\nPurpose:    For use with the new ORDERPATCH method.  Describes a change \n            to be made in a collection ordering.\nValue: \t    A description of the new positions of collection members in \n            the collection's ordering.\n\n<!ELEMENT order (ordermember+) >\n\nSlein et al.                                                    Page 41\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\n8.8 ordermember XML Element\n \nName: \t    ordermember\nNamespace:  DAV:\nPurpose:    Occurs in the order XML Element, and describes the new \n            position of a single collection member in the collection's \n            ordering.\nValue: \t    An href containing a relative URI, and a description of its \n            new position in the ordering.  The href XML element is \n            defined in [WebDAV], Section 11.3.\n\n<!ELEMENT ordermember (href, position) >\n\n8.9 position XML Element\n\nName: \t    position\nNamespace:  DAV:\nPurpose:    Occurs in the member XML element.  Describes the new \n            position in a collection's ordering of one of the \n            collection's members.\nValue: \t    The new position can be described as first in the \n            collection's ordering, last in the collection's ordering, \n            before some other member of the collection, or after some \n            other member of the collection.\n\n<!ELEMENT position (first | last | before | after)>\n\n8.10 first XML Element\n\nName: \t    first\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as first in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT first EMPTY >\n\n8.11 last XML Element\n\nName: \t    last\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as last in the collection's \n            ordering.\nValue: \t    EMPTY\n\n<!ELEMENT last EMPTY >\n\n8.12 before XML Element\n\nName: \t    before\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n\nSlein et al.                                                    Page 42\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            collection member's position as coming before some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it precedes in the ordering\n\n<!ELEMENT before href >\n\n8.13 after XML Element\n\nName: \t    after\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Describes the \n            collection member's position as coming after some other \n            collection member in the collection's ordering.\nValue: \t    href of the member it follows in the ordering\n\n<!ELEMENT after href >\n\n8.14 options XML Element\n\nName:       options\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for more detailed     \n            information about capabilities than can be provided in the  \n            DAV: response header.  Used in OPTIONS responses to provide\n            that information.\nValue:      List of elements identifying or providing the additional \n            information desired.\n\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n\n8.15 refintegrityoptions XML Element\n\nName:       refintegrityoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list of referential       \n            enforcement policies that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n            This is the list of valid values for the Ref-Integrity \n            Header for that request-URI.\nValue:      EMPTY on requests.  On responses, it is the list of valid \n            values for Ref-Integrity.\n\n<!ELEMENT refintegrityoptions ( (#PCDATA)+ | EMPTY) >\n\n8.16 orderingoptions XML Element\n\nName:       orderingoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list server-    \n            maintained orderings that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n            These values can be used in the Ordered header or the \n            DAV:orderingtype property to request that a particular  \n            server-maintained ordering be applied to the collection.\nValue:      EMPTY on requests.  On responses, it is the list of server-\n\nSlein et al.                                                    Page 43\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n            maintained orderings available for the request-URI.\n\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n\n8.17 do-not-enforce XML Element\n\nName:       do-not-enforce\nNamespace:  DAV:\nPurpose:    Used in responses to OPTIONS requests for \n            refintegrityoptions, to indicate that the server can honor \n            requests that referential integrity not be enforced for the \n            request-URI.  If it is included in an OPTIONS response, then \n            the client can use it as a value of the Ref-Integrity header \n            in a MKREF request to the same URI.\nValue:      EMPTY.\n\n<!ELEMENT do-not-enforce EMPTY >\n\n9 Extensions to the DAV:response XML Element for Multi-Status Responses\n\nAs described in Sections 4.5 and 4.6, the DAV:location property and the \nDAV:reftype property may be returned in the DAV:response element of a \n207 Multi-Status response, to allow clients to resubmit their requests \nto the target resource of a redirect reference.  \n\nAs described in Section 4.13, the DAV:reftype and DAV:reftarget \nproperties may be returned in the DAV:response element of a 207 Multi-\nStatus response, to indicate that a problem is not with a direct \nreference, but with its target resource.\n\nWhenever these properties are included in a Multi-Status response, they \nwill be placed in a DAV:prop element associated with the href to which \nthey apply.  This structure provides a framework for future extensions \nby other standards that may need to include additional properties in \ntheir responses.\n\nConsequently, the definition of the DAV:response XML element changes to \nthe following:\n\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n10 Capability Discovery\n\n10.1 Compliance Classes\n\nSince referencing and ordering are independent capabilities, a resource \nMAY support either or both.  A resource that provides referencing MUST \nsupport redirect references, and MAY in addition support direct \nreferences.  A response to an OPTIONS request MUST indicate which of \nthese capabilities the resource supports.\n\nThis specification defines two new methods: MKREF in support of \nreferencing, and ORDERPATCH in support of ordering.  The response MUST \nindicate which of these methods the resource allows.  In addition, the \n\nSlein et al.                                                    Page 44\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nresponse MUST include the DAV header, as described in Sections 9.1 and \n15 of [WebDAV].  Three new compliance classes are defined here for use \nwith the DAV header: basicref, directref, and orderedcoll. \n\nWhen responding to an OPTIONS request, only a collection or a null \nresource can include orderedcoll in the value of the DAV header.  By \nincluding orderedcoll, the resource indicates that its immediate member \nURIs can be ordered.  It implies nothing about whether any collections \nidentified by its member URIs can be ordered.\n\nWhen responding to an OPTIONS request, any type of resource can include \nbasicref or directref in the value of the DAV header.  Including \nbasicref indicates that the server permits a redirect reference at the \nrequest URI.  Including directref indicates that the server permits a \ndirect reference at the request URI.\n\n10.2 Example: Discovery of Compliance Classes\n\nRequest:\n\nOPTIONS /somecollection/ HTTP/1.1\nHOST: somehost.org\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, MKREF, ORDERPATCH\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, MKREF, ORDERPATCH\nDAV: 1, 2, basicref, directref, orderedcoll\n\nThis response indicates that the resource /somecollection/ is level 1 \nand level 2 compliant, as defined in [WebDAV].  In addition, \n/somecollection/ supports ordering and is in a part of the server \nnamespace that allows creation of redirect and direct references.  (In \nlight of the semantics of MKREF, the resource currently at \n/somecollection/ would have to be deleted before a reference could be \ncreated at that URI.) \n\n10.3 Additional Advanced Collections Capabilities\n\nClients may need detailed information about specific areas of advanced \ncollections functionality.  This information can be requested by sending \nan OPTIONS request with an XML body that includes a DAV:options element.  \nThe DAV:options element contains a list of empty elements identifying \nthe information the client needs.\n\nAs described in Section 4.3, clients are required to include the Ref-\nIntegrity header in any MKREF request to specify the desired referential \nintegrity enforcement policy for the new reference.  The only value of \nRef-Integrity defined in this specification is DAV:do-not-enforce.  If \n\nSlein et al.                                                    Page 45\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nthe client wants referential integrity to be enforced, it needs to know \nwhat other values of Ref-Integrity the server can support.  To discover \nwhat values can be used for a particular request-URI, the client \nincludes an empty DAV:refintegrityoptions element in the DAV:options \nelement.  The response will include a DAV:refintegrityoptions element \nwith the list of supported referential integrity enforcement policies.  \nServers MUST advertise the referential integrity enforcement policies \navailable at a URI using this mechanism.\n\nAs described in Section xxx, servers may offer a set of server-\nmaintained orderings on collections.  Clients can discover the list of \nserver-maintained orderings available for the request-URI by including \nan empty DAV:orderingoptions element in the DAV:options element.  The \nresponse will include a DAV:orderingoptions element with the list of \nsupported server-maintained orderings.  Servers SHOULD advertise the \nserver-maintained orderings available using this mechanism.\n\n10.4 Example: Discovery of Referential Integrity Options\n\nRequest:\n\nOPTIONS /somecollection/fooref HTTP/1.1\nHOST: somehost.org\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:refintegrityoptions/>\n</D:options>\n\nResponse:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, MKREF\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, MKREF\nDAV: 1, basicref\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:refintegrityoptions xmlns:X=\"Xerox:\">\n      <D:do-not-enforce/>\n      <X:block-deletes/>\n  </D:refintegrityoptions>\n</D:options>\n\nThis response indicates that the resource /somecollection/fooref is \nlevel 1 compliant, as defined in [WebDAV].  In addition, \n/somecollection/fooref is in a part of the server namespace that allows \ncreation of redirect references.  The client also asked for a list of \nthe values of Ref-Integrity that are supported for \n/somecollection/fooref.  The response indicates that the values DAV:do-\n\nSlein et al.                                                    Page 46\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nnot-enforce and Xerox:block-deletes are supported.\n\n11 Dependencies on Other Specifications\n\nTBD\n\n12 Security Considerations\n\nThis section is provided to detail issues concerning security \nimplications of which WebDAV applications need to be aware. \n\nAll of the security considerations of HTTP/1.1 and the base WebDAV \nprotocol also apply to WebDAV collections.  In addition, referential \nresources and ordered collections introduce several new security \nconcerns and increase the risk of some existing threats.  These issues \nare detailed below.\n\n12.1 Privacy Concerns\n\nBy creating references on a trusted server, it is possible for a hostile \nagent to induce users to send private information to a target on a \ndifferent server.   This risk is mitigated somewhat for redirect \nreferences, since clients are required to notify the user of the \nredirection for any request other than GET or HEAD. (See [HTTP], Section \n10.3.3 Moved Temporarily.)  For direct references, clients can determine \nthe resource type, reference type, and target location before sending a \nrequest, but are not required to notify users if the target is on \nanother server. \n\n12.2 Redirect Loops\n\nAlthough redirect loops were already possible in HTTP 1.1, the \nintroduction of referential resources creates a new avenue for clients \nto create loops accidentally or maliciously.  If the referential \nresource and its target are on the same server, the server may be able \nto detect MKREF requests that would create loops. See also [HTTP], \nSection 10.3 \"Redirection 3xx.\" \n\n12.3 References and Denial of Service\n\nDenial of service attacks were already possible by posting URLs that \nwere intended for limited use at heavily used Web sites.  The \nintroduction of referential resources creates a new avenue for similar \ndenial of service attacks.  Clients can now create references at heavily \nused sites to target locations that were not designed for heavy usage.\n\n12.4 References May Reveal Private Locations\n\nThere are several ways that the referencing mechanisms described here \nmay reveal information about directory structures.  First, the \nDAV:reftarget property of every reference contains the URI of the target \nresource.  Anyone who has access to the reference can discover the \ndirectory path that leads to the target resource.   The owner of the \ntarget resource may have wanted to limit knowledge of this directory \nstructure.\n\nSlein et al.                                                    Page 47\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n\nSufficiently powerful access control mechanisms can control this risk to \nsome extent.  Property-level access control could prevent users from \nexamining the DAV:reftarget property.  (The Ref-Target header, which is \nreturned in most responses to requests on direct references, reveals the \nsame information, however.)  In some environments, the owner of a \nresource might be able to use access control to prevent others from \ncreating references to that resource.\n\nSecond, although this specification does not require servers to maintain \nreferential integrity, it does not prevent them from doing so.  If a \nserver updates a reference\u2019s DAV:reftarget property when its target \nresource is moved, there is the risk that a private location will be \nrevealed in the new value of DAV:reftarget.  Clients can avoid this risk \nby doing a COPY followed by a DELETE rather than a MOVE.\n\nFinally, if backpointers are maintained on the target resource, the \nowners of references face these same risks.  The directory structures \nwhere references are located are revealed to anyone who has access to \nthe DAV:references property on a target resource.  Moving a reference \nmay reveal its new location to anyone with access to DAV:references on \nits target resource.\n\n12.5 DAV:references and Denial of Service\n\nIf the server maintains the DAV:references property in response to \nreferences created in other administrative domains, it is exposed to \nhostile attempts to make it devote resources to adding references to the \nlist.\n\n12.6 DAV:references and Malicious Deletion of Resources\n\nServers that support the DAV:references property should insure that \nclients cannot create editable properties with the name DAV:references.  \nAn editable DAV:references property would constitute a security risk on \nservers that enforce referential integrity by deleting references when \ntheir target is deleted.  These servers could be tricked into deleting a \nresource by listing it in the DAV:references property of some target \nresource.\n\n12.7 Denial of Service and DAV:orderingtype\n\nThere may be some risk of denial of service at sites that are advertised \nin the DAV:orderingtype property of collections.  However, it is \nanticipated that widely-deployed applications will use hard-coded values \nfor frequently-used ordering semantics rather than looking up the \nsemantics at the location specified by DAV:orderingtype.\n\n13 Internationalization Considerations\n\nThis specification follows the practices of [WebDAV] in encoding all \nhuman-readable content using XML [XML] and in the treatment of names.  \nConsequently, this specification complies with the IETF Character Set \nPolicy [Alvestrand].\n\n\nSlein et al.                                                    Page 48\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nWebDAV applications MUST support the character set tagging, character \nset encoding, and the language tagging functionality of the XML \nspecification.  This constraint ensures that the human-readable content \nof this specification complies with [Alvestrand].\n\nAs in [WebDAV}, names in this specification fall into three categories: \nnames of protocol elements such as methods and headers, names of XML \nelements, and names of properties.  Naming of protocol elements follows \nthe precedent of HTTP, using English names encoded in USASCII for \nmethods and headers.  The names of XML elements used in this \nspecification are English names encoded in UTF-8.\n\nFor error reporting, [WebDAV] follows the convention of HTTP/1.1 status \ncodes, including with each status code a short, English description of \nthe code (e.g., 423 Locked).  Internationalized applications will ignore \nthis message, and display an appropriate message in the user's language \nand character set.\n \nFor rationales for these decisions and advice for application \nimplementors, see [WebDAV].\n\n14 IANA Considerations\n\nThis document uses the namespaces defined by [WebDAV] for properties and \nXML elements.  All other IANA considerations mentioned in [WebDAV] also \napply to this document.\n\n15 Copyright\n\nTo be supplied.\n\n16 Intellectual Property\n\nTo be supplied.\n\n17 Acknowledgements\n\nThis draft has benefited from thoughtful discussion by Jim Amsden, Steve \nCarter, Ken Coar, Ellis Cohen, Bruce Cragun, Spencer Dawkins, Mark Day, \nRajiv Dulepet, David Durand, Roy Fielding, Yaron Goland, Fred Hitt, Alex \nHopmann, Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit Khare, \nDaniel LaLiberte, Steve Martin, Larry Masinter, Jeff McAffer, Surendra \nKoduru Reddy, Max Rible, Sam Ruby, Bradley Sergeant, Nick Shelness, John \nStracke, John Tigue, John Turner, and others.\n\nCcjason, \n\n18 References\n\n18.1 Normative References\n\n[URI] T. Berners-Lee, R. Fielding, L. Masinter, \"Uniform Resource \nIdentifiers (URI): Generic Syntax.\" RFC 2396. MIT/LCS, U.C. Irvine, \nXerox. August, 1998.\n\n\nSlein et al.                                                    Page 49\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n[RFC2119] S. Bradner, \"Key words for use in RFCs to Indicate Requirement \nLevels.\"  RFC 2119, BCP 14.  Harvard University.  March, 1997.\n\n[XML] T. Bray, J. Paoli, C.M. Sperberg-McQueen, \"Extensible Markup \nLanguage (XML).\"  World Wide Web Consortium Recommendation REC-xml-\n19980210. http://www.w3.org/TR/1998/REC-xml-19980210.\n\n[HTTP] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-Lee, \n\"Hypertext Transfer Protocol -- HTTP/1.1.\" RFC 2068.  UC Irvine, DEC, \nMIT/LCS.  January, 1997.\n\n[WebDAV] Y. Y. Goland, E. J. Whitehead, Jr., A. Faizi, S. R. Carter, D. \nJensen, \"HTTP Extensions for Distributed Authoring - WebDAV.\" RFC 2518.  \nMicrosoft, U.C. Irvine, Netscape, Novell.  February, 1999.\n\n18.2 Informational References\n\n[DASL] Saveen Reddy, D. Jensen, Surendra Reddy, R. Henderson, J. Davis, \nA. Babich, \"DAV Searching & Locating.\" Draft-reddy-dasl-protocol-03. \nInternet Draft, work in progress. Microsoft, Novell, Oracle, Netscape, \nXerox, Filenet.  November, 1998.\n \n[CollReq] J. Slein, J. Davis, \"Requirements for Advanced Collection \nFunctionality in WebDAV.\" Draft-ietf-webdav-collection-reqts-02. \nInternet Draft, work in progress.  Xerox.  February, 1999.\n\n19 Authors' Addresses\n\nJ. Slein\nXerox Corporation\n800 Phillips Road, 105-50C\nWebster, NY 14580\nEmail: jslein@crt.xerox.com\n\nJ. Davis\nCourseNet Systems\n170 Capp Street\nSan Francisco, CA 94110\nEmail: jrd3@alum.mit.edu\n\nT. Chihaya\nDataChannel, Inc.\n155 108th Ave. N.E., Suite 400\nBellevue, WA 98004\nEmail: Tyson@DataChannel.com\n\nG. Clemm\nRational Software Corporation\n20 Maguire Road\nLexington, MA 02173-3104\nEmail: gclemm@rational.com\n\nC. Fay\nFileNet Corporation\n3565 Harbor Boulevard\n\nSlein et al.                                                    Page 50\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\nCosta Mesa, CA 92626-1420\nEmail: cfay@filenet.com\n\nE.J. Whitehead Jr.\nDept. of Information and Computer Science\nUniversity of California, Irvine\nIrvine, CA 92697-3425\nEmail: ejw@ics.uci.edu\n\n20 Appendices\n\n20.1 Appendix 1: Extensions to the WebDAV Document Type Definition\n\n<!--============= XML Elements from Section 8 =======================-->\n<!ELEMENT reference EMPTY >\n<!ELEMENT direct EMPTY >\n<!ELEMENT redirect EMPTY >\n<!ELEMENT weak EMPTY >\n<!ELEMENT unordered EMPTY >\n<!ELEMENT custom EMPTY >\n<!ELEMENT order (ordermember+) >\n<!ELEMENT ordermember (href, position) >\n<!ELEMENT position (first | last | before | after)>\n<!ELEMENT first EMPTY >\n<!ELEMENT last EMPTY >\n<!ELEMENT before href >\n<!ELEMENT after href >\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n<!ELEMENT refintegrityoptions ( (#PCDATA)+ | EMPTY) >\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n<!ELEMENT do-not-enforce EMPTY >\n<!--============= Property Elements from Section 7 ==================-->\n<!ELEMENT reftarget href>\n<!ELEMENT refintegrity (weak | #PCDATA)>\n<!ELEMENT reftype (direct | redirect | #PCDATA)>\n<!ELEMENT location href>\n<!ELEMENT references (href*)>\n<!ELEMENT orderingtype (arbitrary | custom | href) >\n<!--====== Changes to the DAV:response Element from Section 9 ====-->\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n20.2 Appendix 2: Summary of Method Semantics for References\n\nThis section summarizes the semantics of each HTTP and WebDAV method \nwhen the request-URI identifies a reference.  The normative statements \nthat are summarized here can be found in Sections 4.3 - 4.10.\n\nFor each method, there are four cases to consider: \n\no Request-URI identifies a redirect reference, and the No-Passthrough \n  header is not used\no Request-URI identifies a redirect reference, and the No-Passthrough \n  header is present\no Request-URI identifies a direct reference, and the No-Passthrough \n\nSlein et al.                                                    Page 51\n\fINTERNET-DRAFT           WebDAV Collections Protocol         April 1999\n\n  header is not used\no Request-URI identifies a direct reference, and the No-Passthrough \n  header is present\n\nWhen the No-Passthrough header is used, the situation is simple.  For \nall methods, the request is applied to the reference, not to its target \nresource.\n\nThe following table summarizes behavior for the cases where the No-\nPassthrough header is not used:\n\nMETHOD    | REDIRECT REFERENCE           | DIRECT REFERENCE\n---------------------------------------------------------------------\nGET       | Respond with 302 status code | Apply method to target\n---------------------------------------------------------------------\nHEAD      | Respond with 302 status code | Apply method to target\n---------------------------------------------------------------------\nOPTIONS   | Respond with 302 status code | Apply method to target\n---------------------------------------------------------------------\nPUT       | Respond with 302 status code | Apply method to target\n---------------------------------------------------------------------\nPOST      | Respond with 302 status code | Apply method to target\n---------------------------------------------------------------------\nMKCOL     | Respond with 302 status code | Apply method to target\n          |                              | (fails unless dangling)\n---------------------------------------------------------------------\nMKREF     | Respond with 302 status code | Apply method to target\n          |                              | (fails unless dangling)\n---------------------------------------------------------------------\nPROPPATCH | Respond with 302 status code | Apply method to target\n---------------------------------------------------------------------\nPROPFIND  | Respond with 302 status code | Apply method to target\n=====================================================================\nDELETE    | Apply method to reference    | Apply method to reference\n---------------------------------------------------------------------\nMOVE      | Apply method to reference    | Apply method to reference\n=====================================================================\nCOPY      | Apply method to reference    | Apply method to target\n---------------------------------------------------------------------\nLOCK      | Apply method to reference    | Apply method to target\n---------------------------------------------------------------------\nUNLOCK    | Apply method to reference    | Apply method to target\n\nPROPFIND, DELETE, MOVE, COPY, LOCK, and UNLOCK can be applied to \ncollections.  In cases where the collection contains references, \nbehavior for the references in the collection follows the same rules as \nthe table describes for individual references.  So, for example, if a \nPROPFIND encounters a redirect reference within a collection, it returns \na 302 status code for that redirect reference in the Multi-Status \nresponse.  If the PROPFIND encounters a direct reference, it returns the \nproperties of the direct reference\u2019s target resource in the Multi-Status \nresponse.\n\nExpires October 5, 1999\n\nSlein et al.                                                    Page 52\n\f", "encoding": "Windows-1252"}