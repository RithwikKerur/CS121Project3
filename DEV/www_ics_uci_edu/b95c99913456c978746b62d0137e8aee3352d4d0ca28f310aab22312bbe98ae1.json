{"url": "https://www.ics.uci.edu/~thornton/ics45c/Notes/SingleDimensionArrays/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 45C Fall 2019, Notes and Examples: Single-Dimension Arrays</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 45C Fall 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"../../GradeCalculator\">Grade Calculator</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 45C Fall 2019<br />\r\n   Notes and Examples: Single-Dimension Arrays</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<p class=\"center\"><i>Includes a code example with the moniker <b>SingleDimensionArrays</b></i></p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Background</p>\r\n\r\n<p>Of course, you don't need to dream very big to dream up a program that has the need to store a <i>collection</i> of objects instead of just a single one: a collection of students enrolled in a course, a collection of financial instruments in an investment portfolio, a collection of statements in a function (if you're writing a compiler), and so on.  Collections are, practically speaking, one of the hallmarks of a programming language's usability.  If there's a built-in set of the obviously useful ones, and if it's reasonably straightforward to build your own when you need something more exotic, it's going to be much easier to write real programs that solve real problems.</p>\r\n\r\n<p>It's quite common to need to store a <i>homogeneous collection</i>, in which each element has the same type.  Like most programming languages, C++ provides mechanisms for solving this problem.  The most basic of these mechanisms is called an <i>array</i> &mdash; or, more completely, a <i>single-dimension array</i> &mdash; which is our focus in this example.</p>\r\n\r\n<p>As we'll see later this quarter, there are cleaner mechanisms available besides arrays, but arrays serve as the raw materials for how some of those other mechanisms are built.  Our focus early in this course is to understand the underpinnings of C++, so we can build a good, reasonably complete mental model of what happens while a C++ program executes.  For that reason, it's a good idea for us to start with the raw materials and work our way up.  So we'll begin our exploration of collections by looking at arrays in some depth, then pivot to other, easier-to-use, less error-prone mechanisms later.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What is an array?</p>\r\n\r\n<p>An <i>array</i> is a sequence of <i>cells</i> that live contiguously &mdash; one directly following another &mdash; in memory.  Each cell has an index, with the first cell having the index 0, the second cell having the index 1, and so on.  The cells are all of the same type (e.g., <b>int</b>, <b>std::string</b>, or whatever) and, hence, they all have the same size.  (The latter part is actually really important: That the cells of an array are uniformly sized is why accessing an array cell, given its index, is relatively inexpensive.)</p>\r\n\r\n<p>When an array is created, it is given a size, which specifies the number of cells it has.  It retains that size for the rest of its lifetime, with no language-level mechanism available to extend the size of an array once it's been created.  From the very beginning, each cell contains an object of the specified type &mdash; so, for example, in an array of <b>int</b>s, each cell contains an <b>int</b> object.  Additionally, there is no standard, generally-applicable construct in C++ to ask an array its size; if you want to keep track of an array's size, you'll have to do so separately.</p>\r\n\r\n<p>As we'll see, there are C++ expressions that will allow you to access individual cells in an array, and it is also possible to manipulate them in whole (e.g., by passing an entire array as an argument to a function).  But there are a few conceptual hurdles we'll need to cross before we get to these.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Statically-allocated arrays</p>\r\n\r\n<p>As with every other kind of object we've seen in C++, we have a choice about how our arrays are to be allocated and where they will be stored, with the most common two choices being static allocation on the run-time stack (via a local variable in a function) or dynamic allocation on the heap (using pointers and the <b>new</b> operator).  Of these, static allocation is the simplest, which we tend to prefer because it gives us a couple of important benefits:</p>\r\n\r\n<ul>\r\n  <li>Automatic deallocation when the array falls out of scope</li>\r\n  <li>A likelihood of the array being in cache a lot of the time, as the current stack frame is accessed often and, hence, likely to be cached\r\n</ul>\r\n\r\n<p>However, statically allocating an array also leaves us with disadvantages, moreso than some other kinds of variables that we might statically allocate:</p>\r\n\r\n<ul>\r\n  <li>Run-time stacks are generally limited in size, given that most programs don't tend to need function calls that nest to an incredibly deep level.  But this imposes a limitation on how much data you can store in local variables; at some point, a stack frame will simply be too big to be practical.  (And, of course, the larger it is, the less benefit you'll see from caching.)</li>\r\n  <li>Arrays must be given a size at the time they're created.  Statically-allocated objects are given a size at compile time, so a statically-allocated array must have a size that is known to the compiler (e.g., a hard-coded constant or another expression calculated only from constants).  Quite often, though, we use data structures whose sizes vary depending on run-time factors such as user input; this would be impossible with a statically-allocated array.</li>\r\n  <li>Statically-allocated objects have fixed lifetimes; for example, local variables in a function die when the function ends.  When we want more open-ended lifetimes, we can't use static allocation.</li>\r\n</ul>\r\n\r\n<p>Nonetheless, there are substantial use cases where we can statically allocate arrays &mdash; namely, when we have small arrays of known size at compile time whose lifetimes match up nicely with the duration of some function call &mdash; so we'll start there.</p>\r\n\r\n<p>We allocate arrays statically by declaring them as variables; we make a variable into an array by following its name with a size surrounded by brackets.</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int a[10];\r\n    // ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Having declared the variable <b>a</b> this way, it will be statically allocated, meaning that the entire array &mdash; all 10 integer objects &mdash; will be on the run-time stack.  On the ICS 45C VM, integers are four bytes each, so that means we've got 40 bytes of integer data stored on the run-time stack.  40 bytes isn't a lot, so this is certainly no problem, but it's important to realize that there's no other kind of indirection here, and there is no overhead; this is exactly equivalent, in terms of storage, to having 10 integer variables.</p>\r\n\r\n<p>Accessing individual cells &mdash; to read their values or to write them &mdash; is done using a similar bracket-based syntax.  When you write an expression comprised of the name of an array, followed by an index surrounded by brackets, the result is a <i>reference</i> to some cell in that array, meaning that you can both read from that cell and write to it, just as you would a variable of that cell's type (e.g., in the case of <b>a</b> above, each cell is an <b>int</b>).</p>\r\n\r\n<blockquote><pre>\r\nvoid foo()\r\n{\r\n    int a[10];\r\n    a[3] = 4;\r\n    std::cout &lt;&lt; a[3] &lt;&lt; std::endl;\r\n}\r\n</pre></blockquote>\r\n\r\n<p>From a language perspective, C++ arrays do not appear to know how big they are; there's simply no universal syntax to ask the question \"How many cells does this array have?\"  Furthermore, no checking is done to ensure that accesses to array cells are legal.  Given the array <b>a</b> above, accesses to individual cells such as <b>a[12]</b> or <b>a[-3]</b> would be legal &mdash; in the sense that they would compile, at worst, with warnings &mdash; but nonsensical, quite possibly dangerous, and would result in undefined behavior (i.e., there's no guarantee what will happen, and it may be different on different operating systems, different compilers, or even different versions of the same compiler).  It's up to us as C++ programmers to avoid these out-of-bounds accesses, but it's  important to realize that they will be allowed, and may lead to such undesirable consequences as assigning values willy-nilly into memory that lives outside of the array's boundaries, changing the guts of some other object (that might well have a completely different type!), or even writing over some of a program's machine code while it runs.</p>\r\n\r\n<p>When the function <b>foo()</b> ends, the array <b>a</b> will be destroyed automatically, taking with it all of the objects in the array; no special cleanup will be needed.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Dynamically-allocated arrays</p>\r\n\r\n<p>When a statically-allocated array can't be used &mdash; because you don't know the appropriate size at compile time, because you know the array is too large to reasonably fit on the run-time stack, because you need the array to outlive the function in which it's created &mdash; there exists the option of a <i>dynamically-allocated array</i> instead.  Dynamically allocating an array involves the use of the <b>new</b> operator, similar to dynamic allocation of other objects; the difference is that an array requires us, additionally, to specify a size.</p>\r\n\r\n<p>Dynamically allocating an array is done using a <b>new</b> expression, which dynamically allocates enough memory to store the entire array, then returns a pointer to the array's first cell.</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[10];\r\n</pre></blockquote>\r\n\r\n<p>The expression <b>new int[10]</b> allocates a block of memory on the heap large enough to store 10 integers &mdash; on the ICS 45C VM, that would be 40 bytes &mdash; and returns a pointer to the first one.  The location of the second directly follows the first, the third directly follows the second, and so on, and all of the cells are the same type.  So given a pointer to the first cell and an index, it is possible, behind the scenes, to calculate the index of any given cell using the following calculation:</p>\r\n\r\n<ul>\r\n  <li><i>address of cell i = (address of cell 0) + (sizeof(int) * i)</i></li>\r\n</ul>\r\n\r\n<p>Note that it's no more expensive to calculate the address of a cell with a large index than with a small one.  This calculation is simply a multiplication and an addition; if we were to assume that memory access takes constant time given an address, accessing any cell in an array would take constant time.  (In practice, memory access times can vary due to effects like caching, though you can reasonably think of main memory accesses &mdash; those that aren't already in cache &mdash; as taking constant time.)</p>\r\n\r\n<p>Interestingly, the type of pointer you get back doesn't specify anything about an array.  When we allocated an array of <b>int</b>s dynamically, what we got back was an <b>int*</b>, i.e., a pointer to an <b>int</b>.  Arrays, in general, are implemented as pointers to their first cells, and it's up to us to know whether a particular <b>int*</b> is pointing to a single <b>int</b> or an array of <b>int</b>s (and, in fact, there's no standard way to ask!).</p>\r\n\r\n<p>Once you have a pointer to an array, you can access its cells similarly to those of a statically-allocated array:</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[10];\r\na[3] = 4;\r\nstd::cout &lt;&lt; a[3] &lt;&lt; std::endl;\r\n</pre></blockquote>\r\n\r\n<p>The expression <b>a[3]</b> is equivalent to the hypothetical expression <b>*q</b>, where <b>q</b> is a pointer to an <b>int</b> located three cells (on the ICS 45C VM, 12 bytes) beyond the one that <b>a</b> points to.  In other words, <b>a[3]</b> gives you the integer in that cell (technically, a reference to it), rather than a pointer to that cell.</p>\r\n\r\n<p>When you're done with a dynamically-allocated array, you would need to explicitly deallocate it, just as you would any other dynamically-allocated object.  However, it's important to note that you use a different operator, <b>delete[ ]</b>, to do so.  Like <b>delete</b>, you give <b>delete[ ]</b> a pointer to an array, and it deallocates the entire array (and all of the objects in all of its cells) for you.</p>\r\n\r\n<blockquote><pre>\r\ndelete[] a;\r\n</pre></blockquote>\r\n\r\n<p>It's up to you to know which pointers point to arrays, and to use <b>delete[ ]</b> when it's warranted.  Using <b>delete</b> on a pointer to an array instead of <b>delete[ ]</b>, or using <b>delete[ ]</b> on a pointer to a single value instead of <b>delete</b>, results in \"undefined behavior\" (which means that compiler writes can generate any code they'd like in this case; some do the right thing, but others don't).</p>\r\n\r\n<p>Just like uses of <b>delete</b> that we've seen previously, the pointer <b>a</b> is unaffected, though it is now pointing to unallocated memory, so it is now <i>dangling</i> and should no longer be used.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Passing arrays as parameters to functions</p>\r\n\r\n<p>The simplest way to pass an array as a parameter to a function, regardless of how the array was allocated, is to pass a pointer to its first element.  But since there's no way for the function to ask the array's size, you would also need to pass its size as a separate parameter.  For example, consider this function, which completely fills an array of <b>int</b>s with zeroes.</p>\r\n\r\n<blockquote><pre>\r\nvoid zeroFill(int* a, unsigned int size)\r\n{\r\n    for (unsigned int i = 0; i &lt; size; ++i)\r\n    {\r\n        a[i] = 0;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Note that this function will gleefully write as many zeroes into memory as you tell it to, regardless of the actual underlying size of the array that <b>a</b> points to.  In other words, this would be legal (though obviously erroneous):</p>\r\n\r\n<blockquote><pre>\r\nint* x = new int[10];\r\nzeroFill(x, 50);       // Writes 50 zeroes to memory, starting with the cell where x points!\r\n</pre></blockquote>\r\n\r\n<p>It's up to us to handle these details correctly, and, in general, we'll receive no help from the compiler to ensure this.  In some cases, we might get warnings (though, in this case, I'd expect that to be rare-to-nonexistent).  In others, we'll get crashes.  In still others, the program will continue muddling forward with potentially bizarre behavior, with a bunch of 0-bits having been written to memory that was storing some other value we may have been intending to use.</p>\r\n\r\n<p>(The moral of this story is partly that arrays are a difficult mechanism to use correctly, so we're wise to use cleaner, safer ones when we can afford them.  We'll cross that bridge a little later this quarter.)</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Pointer arithmetic</p>\r\n\r\n<p>Pointers are memory addresses, and memory addresses are numbers.  So it's not entirely nonsensical to think that you can perform certain kinds of arithemtic on pointers, similar to the arithemtic you can perform on <b>int</b>s.  In C++, which allows this kind of thing, it is called <i>pointer arithmetic</i>.  Pointer arithmetic is more limited than the arithmetic you can do on <b>int</b>s.  For example, multiplication and division are not supported.  Addition involves a pointer and an integer.  Subtraction might involve a pointer and a constant integer, or it might involve two pointers.</p>\r\n\r\n<p>Consider the following short example, which demonstrates a few ways that pointer arithmetic works in C++:</p>\r\n\r\n<blockquote><pre>\r\nint a[10];                           // a is effectively a pointer to the first element of the array\r\nint b[10];                           // b is also effectively a pointer\r\nstd::cout &lt;&lt; a &lt;&lt; std::endl;         // writes the address of <b>a[0]</b>\r\nstd::cout &lt;&lt; (a + 1) &lt;&lt; std::endl;   // writes the address of <b>a[1]</b>\r\n*(a + 1) = 3;                        // stores 3 in <b>a[1]</b>\r\nstd::cout &lt;&lt; (a - 1) &lt;&lt; std::endl;   // writes the address of <b>a[-1]</b>\r\nstd::cout &lt;&lt; (a - b) &lt;&lt; std::endl;   // writes the distance in memory between <b>a[0]</b> and <b>b[0]</b> (divided by the size of an <b>int</b>)\r\n</pre></blockquote>\r\n\r\n<p>In general, we can see that pointer arithmetic works by considering the type of object the pointers are said to point to.  For example, <b>a + 1</b> doesn't just add the integer value 1 to the address of <b>a</b>; instead, it adds the <i>size of an integer</i> to the address of <b>a</b> or, in other words, calculates a position <i>one integer beyond where <b>a</b> points</i>.  In that sense, pointer arithmetic is very much like array indexing and, in fact, the array-indexing operations you write are ultimately translated by a compiler into the corresponding pointer arithemtic operations instead.</p>\r\n\r\n<p>Given this technique, we can write some kinds of code differently; for example, our function above that zero-fills an array could be written this way:</p>\r\n\r\n<blockquote><pre>\r\nvoid zeroFill(int* a, int size)\r\n{\r\n    int* end = a + size;\r\n\r\n    for (int* p = a; p != end; ++p)\r\n    {\r\n        *p = 0;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>In this version of the function, <b>p</b> iterates over the array that <b>a</b> points to, visiting each cell.  <b>a + size</b> is the address of the cell just beyond the last cell in the array, which makes an effective stopping point for the loop.  <b>++p</b> means \"Move p so that it points to the next integer after the one that p points to now.\"</p>\r\n\r\n<p>Given a naively-implemented compiler, a pointer-based solution like this one is potentially faster than its array-indexing counterpart, because it replaces the array index calculation (a multiplication and an addition) in each step with a simple addition (the increment operation) instead.  However, I should point out that compilers with strong optimizers built into them might well recognize the pattern in the original version of our zero-filling function and transform it into the pointer arithmetic version for us.  For example, as of this writing, when optimizations are turned on in our compiler (Clang), both versions of <b>zeroFill</b> above are translated into identical code: a call to the C standard library function <b>memset</b>.</p>\r\n\r\n<p>My general rule is to start by writing code that's clear, then replace it with code with optimizations if (a) I find that I need them (i.e., some frequently-used part of my code is running slower than I need it to), and (b) the optimization isn't being performed automatically.  Knowing the lower-level tools lets me hand-optimize things when I need to.  But there is still a lot of premium to be placed on writing code that reads more clearly.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>The official moniker for this code example is <b>SingleDimensionArrays</b>, so your best bet is to do this:</p>\r\n\r\n<ul>\r\n  <li>Create a new project using the <b>example</b> project template.</li>\r\n  <li>Change into the project directory.</li>\r\n  <li>Issue the command <b>./download SingleDimensionArrays</b> to download the code example into your project directory's <b>app</b> directory.</li>\r\n</ul>\r\n\r\n<p>Alternatively, you can click the link to the tarball below:</p>\r\n\r\n<ul>\r\n  <li><a href=\"SingleDimensionArrays.tar.gz\">SingleDimensionArrays.tar.gz</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}