{"url": "https://www.ics.uci.edu/~eppstein/180a/990202a.html", "content": "<HTML>\n<HEAD>\n<TITLE>ICS 180, February 2, 1999</TITLE>\n<META name=\"Owner\" value=\"eppstein\">\n<META name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</HEAD><BODY>\n<IMG SRC=\"icslogo2.gif\" WIDTH=472 HEIGHT=72 ALT=\"\"><P>\n<A HREF=\"index.html\">\n<H1>ICS 180, Winter 1999:<BR>\nStrategy and board game programming</H1></A>\n\n<H2>Lecture notes for February 2, 1999<BR>\nForcing progress in Winning Positions</H2>\n\nIf the game reaches a point where a win can be forced,\nalpha-beta search will find it.  But, paradoxically, making a winning move at each turn \nis not always enough to win the game.  The problem is in games like \ncheckers or chess, one can make a sequence of moves that each lead to a \nforced win, but that don't cause the win to get any closer.\n\n<P>For example, consider the following chess position:\n<P><CENTER><IMG SRC=\"990202a.gif\" WIDTH=292 HEIGHT=292\nALT=\"White: Kd6, Qa7; Black: Ke8\"></CENTER>\n\n<P>White to move can win immediately by moving the queen to square e7,\ncheckmating the black queen.  But white also has other moves that win more \nslowly; in fact there is only one move white can make that does not win.\nFor instance, suppose white moves his king to e6; black's only moves are d8 \nand f8, after either of which white still has a checkmate possible.\nIf black moves to d8, white can still win by moving back to d6.\nBut after the sequence of moves 1. Ke6 Kd8 2. Kd6 Ke8 we are back where we \nstarted!  White is making winning moves, but he isn't making progress to a \nwin.\n\n<P>If an alpha-beta search gives the same evaluation to any winning \nposition, it can easily fall into this trap.  To prevent this, we need to \nchange the evaluation of winning positions, so that a win in fewer moves \nis counted slightly better than a delayed win.  The code is \nstraightforward: if we keep a variable \"ply\" denoting how far the current \nposition is from the root of the search, we can adjust the score for a \nwinning position by subtracting the ply.  The following pseudocode assumes \nthat we have defined a constant \"WIN\" which refers to the maximum score \npossible in a game (in chess, a typical value for WIN would be 100 or 1000 times \nthe value of a pawn).\n\n<PRE>\n    // Alpha-beta search with WIN scores adjusted for ply\n\n    int ply;    // global variable initialized to zero at start of search\n    int alphabeta(int depth, int alpha, int beta)\n    {\n        if (game over and current player has won) return WIN - ply;\n        else if (game over and current player has lost) return -WIN + ply;\n        else if (depth <= 0) return eval();\n        ply++;\n        for (each possible move m) {\n            make move m;\n            alpha = max(alpha, -alphabeta(depth - 1, -beta, -alpha);\n            unmake move m;\n            if (alpha >= beta) break;\n        }\n        ply--;\n        return alpha;\n    }\n</PRE>\n\nNow in the example above, the immediate checkmate is seen at ply=1,\nand gets a score of 999 (WIN-1), while moving the king to e8 forces a win \nat ply=3, with a score of 997.  The program will move to the position \nmaximizing its score, and take the immediate checkmate.\n\n<P>For some games, such as Othello, there is a natural limit to the length of \nthe game: each move adds a piece to the board, so there can be at most 64 \nmoves before the game finishes.  For those games, there is no way to get \ninto the same sort of infinite loop, and we can just use a score of WIN \nor -WIN without worrying about the ply adjustment.\n\n<P>\nThere is one further complication with this ply adjustment trick: how does \nit interact with the hash table?  The problem is that the ply may differ \nbetween the time we store a move in the hash table, and the time we \nretrieve it. In order to make the retrieved score's ply adjustment correct, \nwe should store scores in the hash table adjusted relative to the \n<I>current</I> position, rather than the position at the root of the \nsearch.\n\n<P>That is, when storing a position in the hash table,\nuse something like the following pseudocode,\nwhere MAX_PLY is a constant defined to be greater than the maximum depth \npossible in a search (WIN=1000 and MAX_PLY=100 might be reasonable).\nThe variable x is just the index of the current position in the hash table.\n<PRE>\n    if (score > WIN - MAX_PLY) hash[x].score = score + ply;\n    else if (score < -WIN + MAX_PLY) hash[x].score = score - ply;\n    else hash[x].score = score;\n</PRE>\n\n<P>When retrieving a position from the hash table, the opposite adjustment \nneeds to be made:\n<PRE>\n    if (hash[x].score > WIN - MAX_PLY) score = hash[x].score - ply;\n    else if (hash[x].score < -WIN + MAX_PLY) score = hash[x].score + ply;\n    else score = hash[x].score;\n</PRE>\n\n<P><HR>\n<A HREF=\"/~eppstein/\">David Eppstein,\n<A HREF=\"/\">Dept. Information & Computer Science</A>,\n<A HREF=\"http://www.uci.edu/\">UC Irvine</A>.\n</BODY></HTML>\n", "encoding": "ascii"}