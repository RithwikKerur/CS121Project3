{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/linkedlists.txt", "content": "\t\t\t\tLinked Lists\r\n\r\nICS-46 is concerned with studying the lower-level data structures that are used\r\nin Python to represent lists/tuples, dicts, sets/frozensets, and other\r\nnot-built-into Python named data-types: stacks, queues, priority-queues, \r\nequivalence classes, and graphs. There are two primary components to all these\r\ndata-types: arrays (a simpler version of Python lists; in fact Python's lists\r\nare built from arrays) and self-referential data-structures. Linked lists are\r\nthe simplest kind of self-referential data-structures; trees (we will study\r\nbinary search trees later this week) are more complex self-referential\r\ndata-structures.\r\n \r\nLanguages like Java/C++ don't build-in most of Python's useful data-types, but\r\ninstead provide them in standard libraries, which are a bit more awkward to use\r\nthan these data-types in Python. These data-type libraries are built on arrays\r\nand self-referential structures. This week is a peek at self-referential\r\nstructures: linked lists and binary search trees.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHere is the trivial class that serves as the basis for all our linked list code\r\n(and the tree class covered later this week isn't much different). LN stands for\r\nList Node: a linked list is a sequence of zero or more list nodes, with each one\r\nexplicitly referring to the next LN in the list, if there is one (via an\r\nattribute that is the next reference).\r\n\r\nclass LN:\r\n    def __init__(self : \"LN\", value : object, next : \"LN or NoneType\" = None):\r\n        self.value = value\r\n        self.next  = next\r\n\r\nWe write \"LN\" in the annotations above, because when defining LN we cannot use\r\nLN for an annotation yet (because it hasn't been completely defined yet); we can\r\nuse it after the definition of the LN class.\r\n\r\nBasically the class allows us to create objects with two attribute names: value\r\nrefers to some object (of any class), but next should either refer to an object\r\nconstructed from the LN class or refer to the special value None (its default\r\nvalue in __init__ above): type(None) is NoneType.\r\n\r\nIn this way we describe LN as a self-referential class: each of its objects\r\nrefers to another one of its objects (although None will serve to stop this\r\nrecursive definition from being infinite: it will be the base case in our\r\nrecursive functions that process linked lists). None represents a linked\r\nlist with no/0 nodes. Generally, a linked list is a sequential list of values,\r\nwith their order being important.\r\n\r\nSo a linked list is like a standard Python list (implemented by a simpler\r\nstructuire named arrays, which you'll learn tons about in ICS-45J/ICS-45C and\r\nICS-46, but are hidden in Python). Here, and much more in these other courses,\r\nwe will learn many details concerning the objects that implement linked lists\r\nand how we can use linked list to implement the kinds of operations we perform\r\non standard Python lists. In ICS-46 we will focus the the performance tradeoffs\r\n(speed/space) for array vs. linked structures for representing lists and other\r\ndata types.\r\n\r\nWe already know a lot about objects storing attributes that refer to objects\r\nconstructed from OTHER classes. Now we will study objects storing attributes\r\nthat refer to objects constructed from the SAME class,  storing attributes that\r\nrefer to objects  constructed from the same class, ... That is something new to\r\nlearn about and explore.\r\n\r\nWe will start with pictures, because pictures are essential to understanding\r\nand manipulating these data structures. In lecture, I will show some detailed\r\ndiagrams of linked lists built with LN objects; then I will remove much\r\nredundant information to show more concise and easy-to-draw pictures. See the\r\nextra materials shown on the Weekly Schedule page for this lectuer\r\n\r\n     I will show detailed pictures here in lecture.\r\n\r\nHere is an abbreviated picture: name x refers to an LN object whose value\r\nattribute is 5 and whose next attribute is a reference to another LN object\r\nwhose value attribute is 3 and whose next attribute is a reference to another\r\nLN object whose value attribute is 8 and whose next attribute is .....\r\n\r\nA reference in the next attribute to the value None is represented symbolically\r\nby the symbol /. \r\n\r\n  x\r\n+---+    +---+---+    +---+---+    +---+---+    +---+---+    +---+---+\r\n| --+--->| 5 | --+--->| 3 | --+--->| 8 | --+--->| 2 | --+--->| 4 | / |\r\n+---+    +---+---+    +---+---+    +---+---+    +---+---+    +---+---+\r\n\r\nNote that the tails of the arrows (references) are put INSIDE a box representing\r\na place where a name's value is stored. The heads of the arrows refer to an\r\nentire LN object, not any particular attribute name/value in it.\r\n\r\nNote that with this notation, we show a value like 3 inside a box for\r\nsimplicity, instead of a reference to the int object 3 inside the box. Often,\r\nthe intersting part of linked-list programming has more to do with the next\r\nattributes of the object than the value attributes.\r\n\r\nIn the code below, whenever we see a .name it means \"follow the arrow to the\r\nobject it refers to (all arrows refer to objects) and select the name attribute\r\n(in LN objects, all attributes store data). Read the following carefully;\r\neverything we do later with linked lists is built on understanding the meaning\r\nof .name (something we've been doing with class objects for a while, even if\r\njust doing something like writing print(self.name) or self.name = value.\r\n  (1) x stores a reference to the first LN object\r\n  (2) x.value stores a reference to the int object 5 in this first LN object\r\n  (3) x.next stores a reference to the second LN object\r\n  (4) x.next.value stores a reference to the int object 3 in this second LN\r\n        object\r\n  (5) x.next.next stores a reference to the third LN object\r\n  (6) x.next.next.value stores a reference to the int object 8 in this third\r\n         LN object\r\n\r\nDon't memorize this information; understand what .name means and carefully be\r\nable to analyze each of these expressions, and any others using .next and\r\n.value too.\r\n\r\nTypically we will look at classes for a list/tree data structure as representing\r\njust data and no methods. So, we will examine functions defined outside of LN,\r\nnot methods defined inside the LN class (although most of these functions can be\r\neasily written as methods). We will discuss both iterative and recursive\r\nversions of most functions, as appropriate.\r\n\r\nSee the download that contains all these functions and a simple driver that you\r\ncan use to test them.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunctions that query/access linked lists\r\n\r\nOne of the main operations we perform on linked lists (as we do with lists)\r\nis to iterate over them, processing all their values. The following function\r\ncomputes the sum of all the values in a linked list ll.\r\n\r\ndef sum_ll(ll):\t    \t    \t      \tdef sum_ll(ll):\r\n    sum = 0\t\t\t\t   sum = 0\r\n    while ll != None:\t\t\t   while True:\r\n        sum += ll.value\t\t\t       if ll == None:\r\n        ll  =  ll.next\t\t\t           break;\r\n    return sum \t\t\t\t       sum += ll.value\r\n    \t   \t\t\t\t       ll  =  ll.next\r\n\t\t\t\t\t   return sum\r\n\r\nLots of code that traverses (iterates over) linked lists looks similar. In class\r\nwe will cover (hand simulate) how this code processes the linked list above,\r\nwith the call sum_ll(x) and see exactly how it is that we visit each node in\r\nthe linked list and stop processing it at the end (when ll goes beyond the last\r\nLN in the linked list and takes on the value None.\r\n\r\nThere is no special iterator for LN objects (unless we create one, as we will\r\nat the end of this lecture); LN is just like any other Python class that we\r\nwrite.\r\n\r\nWe can also define linked lists recursively and use such a definition to help\r\nus write functions that recursively process linked lists. \r\n\r\n  (1) None is the smallest linked list: it contains no nodes\r\n  (2) A list node (LN) whose next refers to a linked list is also linked list\r\n\r\nSo None is a linked list (of 0 values); a list node whose next attribute is None\r\nis a linked list (of 1 value); a list node whose next attribute is a list node\r\nwhose next attribute is None is a linked list (of 2 values); etc.\r\n\r\nSo, we can recursively process a linked list by processing its first LN and then\r\nrecursively processing the (one smaller) linked list its next attribute refers\r\nto; recursion ends at None (which is the base case: the smallest linked list).\r\nWe can recursively compute the sum of linked list by\r\n\r\ndef sum_ll_r(ll):\r\n    if ll == None:              # Could also test: type(ll) is NoneType\r\n        return 0\r\n    else:\r\n        return ll.value + sum_ll_r(ll.next)\r\n\r\nBack to the three rules we studied to prove a recursive functions correct:\r\n\r\n(1) It recognizes and computes the correct result for the smallest (None, no LN)\r\n      linked list: it returns 0 which is the sum of no nodes.\r\n\r\n(2) Each recursive call is on a smaller linked list, which is closer to the\r\n      base case: The recursive call is on ll.next, which is a linked list with\r\n      one fewer nodes. It is similar to the call l[1:] when l is Python list.\r\n\r\n(3) Assuming sum_ll_r(ll.next) computes the sum of all values after the node\r\n      representing the start of the linked list to be processed, this function\r\n      returns the sum of all the nodes in this linked list: if we add the value\r\n      of this first node to the sum of the values in all the following nodes in\r\n      the linked list, then we have computed the sum of all the nodes in the\r\n      linked list. It is elephants all the way down.\r\n\r\n-----\r\nAside: Efficiency in Time and Space\r\n\r\nIn tuples/lists, using a slice to skip the first value in a recursive\r\ncall is INEFFICIENT in both time and space. It must COPY the entire tuple/list.\r\nBut using ll.next to skip the first value in a recursive call is EFFICIENT in\r\nboth time and space.\r\n-----\r\n\r\nAn even simpler traversal of linked lists computes their length. Here are the \r\niterative and recursive functions.\r\n\r\ndef len_ll(ll):\r\n    count = 0\r\n    while ll != None:\r\n        count += 1\r\n        ll = ll.next\r\n    return count\r\n\r\ndef len_ll_r(ll):\r\n    if ll == None:\r\n        return 0\r\n    else:\r\n        return 1 + len_ll_r(ll.next)\r\n \r\nThese are simpler than the sum_ll functions: rather than adding the value of\r\neach list node, these add 1 to a count for each list node, ultimately computing\r\nthe number of list nodes in the entire linked list: its length.\r\n\r\nNext lets look at computing a string representation for a list. There is no\r\nstandard for how linked lists are represented as strings. We could convert them\r\nto look like a normal list: [...] but instead we will use the following form\r\n'5->3->8->2->4->None'. Here are the iterative and recursive functions to produce\r\nsuch strings.\r\n\r\nIn the iterative method, for each node in the list we concatenate its value\r\nfollowed by '->', and concatenate just the value 'None' at the end, before\r\nreturning.\r\n\r\ndef str_ll(ll):\r\n    answer = ''\r\n    while ll != None:\r\n        answer += str(ll.value) + '->'\r\n        ll = ll.next\r\n    return answer + 'None'\r\n\r\nIn the recursive version, we return 'None' as the base-case, concatenating the\r\nvalue and '->' in front of the result returned on each recursive call.\r\n\r\ndef str_ll_r(ll):\r\n    if ll == None:\r\n        return 'None'\r\n    else:\r\n        return str(ll.value) + '->' + str_ll_r(ll.next)\r\n\r\nIn all these examples, the iterative and recursive code have approximately the\r\nsame complexity. Let's now look at two other functions: one that converts a\r\nstandard Python list into a linked list, and one that copies a linked list,\r\nobserving that the recursive versions are a bit simpler to write and understand.\r\nBUT, you should hand simulate the iterative methods to understand how/why they\r\nwork too.\r\n\r\nFirst: two functions to convert a standard Python list into a linked list.\r\n\r\nIn list_to_ll we must treat an empty list specially, returning None: otherwise\r\n(for a non-empty list) we can access the first value: l[0]. We make two names\r\n(front and rear) to refer to the LN constructed with that value (in this LN its\r\nnext is None). We will not change front and eventually return its value\r\n(returning a reference to the front of all the list nodes in our list). We add\r\neach new value at the end of the list of nodes by extending the node rear\r\nrefers to: changing its next from None to an actual list node (whose next is\r\nNone), and then re-adjusting rear to refer to this new end-of-the-list node,\r\nextending it as many times as necessary.\r\n\r\ndef list_to_ll(l):\r\n    if l == []:\r\n        return None\r\n    front = rear = LN(l[0])   # next parameter is implicitly None in LN\r\n\r\n    for v in l[1:]:\r\n        rear.next = LN(v)     # next parameter is implicitly None in LN\r\n        rear = rear.next\r\n    return front\r\n\r\nThe recursive version of this function is simpler, and looks pretty much like\r\nall the recursive functions that we have seen for linked lists. One interesting\r\nfeature of note: the recursive call is the second argument to LN's constructor.\r\nIt calls this recursive function and passes a reference to the copied list to\r\nthe constructor.\r\n\r\ndef list_to_ll_r(l):\r\n    if l == []:\r\n        return None\r\n    else:\r\n        return LN( l[0], list_to_ll_r(l[1:]) )\r\n\r\nHere is the proof this function is correct\r\n\r\n(1) It recognizes and computes the correct result for the smallest (empty) list:\r\n    it returns None, which is the smallest (empty) linked list.\r\n\r\n(2) Each recursive call is on a smaller list, which is closer to the base case:\r\n      The recursive call is on l[1:], the standard one-smaller list.\r\n\r\n(3) Assuming list_to_ll(l[1:]) returns a linked list with all the values in the\r\n      l[1:], this function returns a linked list of all the values in the\r\n      parameter list: it returns a reference to a new list node with the first\r\n      value in the list (l[0]) and whose .next refers to a linked list with\r\n      all the values in l[1:].\r\n\r\nTo find a value in a linked list (returning a reference to the node that\r\ncontains that value; if the value appears in the list multiple times, it returns\r\na reference to the first node that it is in), we write an iterative method and\r\ntwo recursive variants. Each returns None if the value is not found in the\r\nlinked list.\r\n\r\nIteratively, we use ll to traverse the list, looking for avalue: we either find\r\nit or \"run off the end of the list by reaching None\" and return None.\r\n\r\ndef find_ll(ll, avalue):\r\n    while ll != None:\r\n        if ll.value == avalue:\r\n            return ll\r\n        ll = ll.next\r\n    return None\r\n\r\nWe can also write this more simply as follows (see code below), combining the\r\ntwo conditions for returning a value; when the loop terminates, the test\r\n\r\n  ll != None and ll.value != avalue\r\n\r\nis False when the while loop ends, so either ll == None or ll.value == avalue;\r\nin both cases returning ll is correct. Note that the short-circuit evaluation\r\nof the and operator (and the order of the conjuncts) is critical: we should not\r\nfollow the reference in ll (with ll.value) until we are sure that ll does not\r\nrefer to the None object; if it does, ll.value would raise an exception.\r\n\r\nDeMorgan's law in boolean algebra is very important in programming. It says that\r\nnot (A and B) == not (A) or not (B); also, not (A or B) == not (A) and not (B).\r\nEach part is negated and the connector flips: and -> or; or -> and.\r\n\r\nSo the loop above terminates when its test is False: when not (test) is True.\r\n  not (ll != None and ll.value != avalue)\r\nis equivalent to terminating when\r\n  not (ll != None)  or  not(ll.value != avalue)\r\nremoving the double negative we get\r\n  ll == None  or  ll.value == avalue\r\nWe could have also written the continuation test for this loop as \r\n  not (ll == None or ll.value == avalue)\r\nor the entire function using while True: as\r\n\r\ndef find_ll(ll, avalue):\r\n    while True:\r\n        if  ll == None or ll.value == avalue:   # short-circuit is critical\r\n            return ll\r\n        ll = ll.next\r\n\r\nFor the recursive functions, the first uses the simplest base case/non-base case\r\nform. If the linked list isn't empty\r\n\r\ndef find_ll_r(ll, avalue):\r\n    if ll == None:\r\n        return None\r\n    else:\r\n        if ll.value == avalue:\r\n            return ll\r\n        else:\r\n            return find_ll_r(ll.next, avalue)\r\n\r\nWe could replace this entire body by one complicated conditional expression:\r\n\r\nreturn (None if ll==None else ll if ll.value==avalue else find_ll_r(ll.next,avalues)\r\n\r\nBut this version is very hard to read, and not in the standard recursive form\r\nthat we have been using.\r\n\r\nAs a slight variant (and similar to what we did in the while loop version) we\r\ncan test both ll == None or ll.value == avalue and in both cases return ll\r\n(returning either None of a reference to a list node). Note that if ll == None\r\nis True, short-circuit evaluation of \"or\" means that the expression\r\nll.value == avalue will not need to be evaluated: good thing, too, because\r\naccessing ll.value when ll is None would raise an exception.\r\n\r\ndef find_ll_r2(ll, avalue):\r\n    if ll == None or ll.value == avalue: # short-circuit or is critical\r\n        return ll\r\n    else:\r\n        return find_ll_r(ll.next, avalue)\r\n\r\nNote that this function is tail-recursive and could automatically be written\r\niteratively (as the code above shows). Most of the previous functions are also\r\nnot tail-recursive, but we could convert them into tail-recursive functions that\r\naccumulate their answers in an additional parameter, and then convert them to\r\nbe iterative.\r\n\r\nWe have already examined code that returned the linked list equivalent of a\r\nstandard Python list. Here is similar code that copies a linked list:\r\nconstructs new nodes with the same values, arranged in the same order, for a\r\nlinked list. In the iterative version we again use front/rear to remember the\r\nfront of the list and extend the rear for each values we traverse in ll.\r\n\r\ndef copy_ll(ll): \r\n    if ll == None:\r\n        return None\r\n    front = rear = LN(ll.value)     # next parameter is implicitly None in LN\r\n\r\n    while ll.next != None:\r\n        ll = ll.next\r\n        rear.next = LN(ll.value)    # next parameter is implicitly None in LN\r\n        rear = rear.next\r\n    return front\r\n\r\nAs we expect, the recursive version is more elegant, and similar to the other\r\nrecursive code that processes linked lists. It is similar to the code we wrote\r\nto translate a Python list into a linked list. Again here the recursive calls is\r\nthe second argument to LN's constructor. So, for ll it builds a node whose\r\nvalue attribute is ll.value and whose next attribute is a copy of all linked\r\nlist values after the first, therefore copying the entire linked list: each\r\nrecursive calls creates a new LN for its ll's value attribute.\r\n \r\ndef copy_ll_r(ll):\r\n    if ll == None:\r\n        return None\r\n    else:\r\n        return LN(ll.value, copy_ll_r(ll.next))\r\n\r\nFinally, languages like Java/C++ don't easily support generators. But because\r\nPython does, we can easily write a generator that produces all the values in a\r\nlinked list.\r\n\r\ndef iterator(ll):\r\n    while ll != None:\r\n        yield ll.value\r\n        ll = ll.next\r\n\r\nWith this code, we could print every value in a linked list by simply writing\r\n\r\n  for v in iterator(ll):\r\n      print(v)\r\n\r\nIn fact, we could put a variant of this code in the __iter__ method in the LN\r\nclass itself:\r\n\r\n  def __iter__(self):\r\n    current = self\r\n    while current != None:\r\n        yield current.value\r\n        current = current.next\r\n\r\nWith this method, we could simply write just\r\n\r\n  for v in ll:\r\n      print(v)\r\n\r\nalthough this code (unlike the generator above) will not work when ll refers\r\nto None, because there is no __iter__ method in NoneType that would return\r\nimmediately. But if ll refers to an LN object, the __iter__ code above will\r\niterate through its values. When writing a linked list class using full\r\nObject Oriented Programming, we define both a list node class and list empty\r\nclass: iterations on a list empty class would just immediately raise\r\nStopIteration.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunctions that command/mutate linked lists\r\n\r\nAll the functions above queried/accessed/created but did not mutate linked\r\nlists: no changes were made to .value or .next of any LN object.\r\n\r\nIf x refers to the first LN in a linked list, we can add a new value at the\r\nfront of the linked list by the simple code:\r\n\r\n  x = LN(new_value, x)\r\n\r\nNow x refers to a new list node, whose value is new_value, and whose next\r\nattribute refers to the LN that x used to refer to: all the nodes in the\r\noriginal linked list x. Draw a picture with x = None originally or x refering\r\nto the linked list above, when this assignment is executed.\r\n\r\nThis operation takes the same amount of time, regardless of how long the linked\r\nlist is: it just constructs an LN object and fills-in its two attributes. If l\r\nis a regular Python list, inserting a new_value at its front position\r\n(l.insert(0,new_value)) take more time the longer the list is: it inserts a new\r\nvalue after moving every value back one in the list. Linked lists are more\r\nefficient that regular lists for some operations, including isertion at the\r\nfront.\r\n\r\nWe can write the following iterative/recursive functions to append a value at\r\nthe end of the linked list. In both cases the list is mutated: the last list\r\nnode has its next attribute changed to refer to a new list node containing the\r\nnew value (and whose .next is None). But, to handle the case where x is\r\ninitially empty (stores None), the iterative/recursive functions must return a\r\nreference to the front of the list (maybe x itself, or if x stored None, a\r\nreference to a one-node linked list storing new_value). We call these functions\r\nlike\r\n\r\n  x = append_ll(x, new_value)\r\n\r\nand\r\n\r\n  x = append_ll_r(x, new_value)\r\n\r\nAs with list_to_ll and copy, the iterative version needs to remember the front\r\nwhile using ll to traverse down the list, to find the last list node to extend.\r\n\r\ndef append_ll(ll,value):\r\n    if ll == None:\t    # special case for an empty list\r\n        return LN(value)\r\n\r\n    front = ll\r\n    while ll.next != None:  # while ll does not refer to the last node...\r\n        ll = ll.next        #   advance: terminates when ll.next == None\r\n\r\n    ll.next = LN(value)     # (at end: ll.next == None) put value after end node\r\n    return front            # return reference to original front of ll (still front)\r\n\r\nThe recursive method is again simpler to write.\r\n\r\ndef append_ll_r(ll,value):\r\n    if ll == None:\r\n        return LN(value)\r\n    else:\r\n        ll.next = append_ll_r(ll.next,value)\r\n        return ll\r\n\r\nHere is the proof this function is correct\r\n\r\n(1) It recognizes and computes the correct result for the smallest (empty)\r\n      linked list: it returns a reference to a linked list with one node\r\n     (storing value: it is both the front and end of the new list)\r\n\r\n(2) Each recursive call is on a smaller linked list, which is closer to the\r\n      base case of None: the recursive call is on ll.next.\r\n\r\n(3) Assuming append_ll_r(ll.next,value) returns a reference to a linked list\r\n      that is one longer than ll.next containing all its list nodes followed by\r\n      value in the last list node, this function returns a linked list that is\r\n      one longer than ll containing all its list nodes followed by value in the\r\n      last list node (by storing in ll.next a reference to the extended linked\r\n      list and returning the original reference to ll).\r\n\r\nICS-46 studies the execution times of various code applied to data structures.\r\nWe will do a bit of this analysis in ICS-33, in week 8. Lists in Python allow\r\nus to add a value at the end very quickly, but adding a value at the front of a\r\nlong list takes much more time: Python must first move the value at index 0\r\ninto index 1; the value at index 1 to index 2; ...For linked lists, adding a\r\nvalue at the front is very quick, while adding a value at the rear requires\r\ntraversing every value in the list (to find the end). Depending on how often we\r\nperform these two operations, it might be faster to use a list or a linked list.\r\nIf we frequently update the information at the end of a linked list, we can\r\nkeep (cache) a reference to it, so we can immediately find the last node in a\r\nlinked, to speed up our functions.\r\n\r\nHere are two simple functions (not iterative or recursive) to mutate a list by\r\nadding/removing a value directly after the one referred to by their argument.\r\nBoth functions return None implicitly.\r\n\r\ndef add_after_ll(ll,value):\r\n    # raises an exception if ll is None; otherwise splice value after ll\r\n    ll.next = LN(value,ll.next)\r\n\r\ndef remove_after_ll(ll):\r\n    # raises exception if ll (no list) or ll.next (no value to remove) is None\r\n    # excise value after ll\r\n    ll.next = ll.next.next\r\n\r\nNote that to remove the first value in a linked list, we write\r\n\r\n  x = x.next\r\n\r\nFinally, we could write an append method in the LN class itself, which scanned\r\nto the end of the linked list containing the LN, and appending the value there.\r\nAs with generator/__iter__, this method won't work for an empty linked list,\r\nbecause its class is NoneType, not LN.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems\r\n\r\n1) Define a recursive function that converts a linked list of values into a\r\nstandard Python list?\r\n\r\n2) To really understand how low-level linked list code works, use the list\r\nshown above execute the call.\r\n\r\nx = magic(x)\r\n\r\nIt actually mutates the list in a complicated way and returns a reference to\r\none of its nodes. Hand simulate the results (calling the function to see the\r\nresult produced before trying to hand simulate it has zero educational value.\r\nI don't care whether you know the answer; I care whether you can hand simulate\r\nthis code and code like it that you might write.\r\n\r\ndef magic(ll): \r\n    answer = None\r\n    while ll != None:\r\n        t_m      = ll\r\n        ll       = ll.next\r\n        t_m.next = answer\r\n        answer   = t_m \r\n    return answer\r\n\r\n3) Define a function named select with two arguments: a linked list (ll) and a\r\nnon-negative integer (n); it returns the value of the nth value in the list\r\nor raises an exception if there are too few values in the list. Write this\r\nfunction iteratively and recursively.\r\n\r\n4) Define a function named append, with two linked list arguments; it returns\r\na reference to the first node in a new linked list (lots of new LN objects)\r\nwith all the values in the first followed by all the values in the second. This\r\nmethod does not mutate the arguments lists, it copies every list node in each.\r\nWrite this function iteratively and recursively.\r\n\r\n5) Define a function named append, with two linked list arguments; it returns\r\na reference to the first node in a linked list (no new LN objects) that contains\r\nall the values in the first followed by all the values in the second.  This\r\nmethod mutates the arguments lists (by making the next of the last node in the\r\nfirst list refer to the first in the second list; but be careful about empty\r\nlists). Write this function iteratively and recursively.\r\n\r\n6) Define a function named interleave, with two linked list arguments; it\r\nreturns a reference to the first node in a new linked list (lots of new LN\r\nobjects) with all the values in the first interleaved with all the values in\r\nthe second. This method does not mutate the arguments lists. Write this function\r\nrecursively. If one list is longer than the other, just copy all the leftover\r\nnodes from the longer list at the end of the result.\r\n\r\n7) Define a function named interleave, with two linked list arguments; it\r\nreturns a reference to the first node in a linked list (no new LN objects) that\r\ncontains all the values in the first interleaved with all the values in the\r\nsecond.  This method mutates the arguments lists. Write this function\r\nrecursively. If one list is longer than the other, just refer to all the\r\nleftover nodes from the longer list at the end of the result.\r\n\r\n8) Define a function named reverse, with one linked list argument; it returns\r\na reference to the first node in a new linked (lots of new LN objects) with all\r\nthe values in their reverse order. Write this function iteratively and\r\nrecursively.\r\n\r\n9) Define a function named reverse, with one linked list argument; it returns\r\na reference to the first node in a linked (no new LN objects) with all the\r\nvalues in their reverse order. This method mutates the argument list. Write\r\nthis iteratively and recursively\r\n\r\n10) For the recursive functions written in 8 and 9, rewrite them to use a helper\r\nmethod with an extra value that accumulates the reversed linked list. Such\r\nfunctions will be tail recursive; translate their code to iterative functions.\r\n\r\n11) Define a function named is_ordered, with one linked list argument; it\r\nreturns whether or not the list values are in non-decreasing order (each one\r\nmust be <= its successor).\r\n\r\n12) Define a function named insert_ordered, with two argumets: one an ordered\r\nlinked list (see problem 11) and one value; it returns a reference to a linked\r\nlist with all the original values and the new one added so the linked list is\r\nstill ordered.\r\n\r\n13) Define the __iter__ method in LN such that we can iterate over the nodes\r\n(not the values) in a linked list. Hint: either return  a nested class\r\nimplementing __next__ or return a generator (simpler) to do the job. To sum\r\nall the values in a linked list using such an iterator, we would write\r\n\r\n  for r in ll:\r\n      print(r.value)\r\n\r\n14) Reread the definition of list_to_ll above. Why doesn't the following code\r\nwork equivalently?\r\n\r\ndef list_to_ll(l):\r\n    if l == []:\r\n        return None\r\n    front = rear = LN(l[0])   # next parameter is implicitly None in LN\r\n\r\n    for v in l[1:]:\r\n        rear = rear.next = LN(v)\r\n    return front\r\n\r\nHint: chaining the equal sign (as in rear = rear.next = LN(v)) works differently\r\nin Python than in C++; what result would the call list_to_ll([1,2,3,4,5]))\r\nproduce for the code above? Can you change the code to produce the correct\r\nresult?\r\n", "encoding": "ascii"}