{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/list/list.txt", "content": "\t\t\t\tLists\r\n\r\nThere is a special class name list in Python, similar to the str class. We can\r\n\r\n  (1) write list literals\r\n  (2) call functions with list arguments\r\n  (3) call methods using the form name.method(other arguments)\r\n\r\nFor example for strings, s.replace('a','b') means return a new string that\r\ncontains the contents of s with every 'a' replaced by 'b'. So s = 'banana' then\r\ns = s.replace('a','b') means s refers to the string 'bbnbnb'.\r\n\r\nHere are the bare bones. I will demonstrate lists in class. The next lecture\r\nwill show lots of functions we can write on lists. The reality of understanding\r\nlists is understanding the basic operations that we can perform on lists, and\r\nhow to combine them with control structures to solve more complicated problems.\r\n\r\nIt is an excellent idea to actually type in the lists shown below and try the\r\noperations to observe their result. Typing these expressions and observing\r\ntheir results will help you remember these operations, rather than just reading\r\nabout them.\r\n\r\nList are most like strings: they contain a sequence of values. In fact, thinking\r\nabout strings can give us useful insights into the meaning of lists and how\r\nthey work, while we are learning them.\r\n\r\nBut lists, unlike strings, have two properties that make them much more\r\ninteresting\r\n\r\n  (1) the values in a list can be of any type: we can have lists of ints,\r\n      lists of strings, lists of mixed types, even lists of lists.\r\n\r\n  (2) we can change/mutate the contents of a list, adding, replacing,and\r\n      removing values\r\n\r\nList have literals too: any number of values (including 0), separated by commas,\r\nin brackets. So, the empty list is written [] (similar to the empty string '').\r\nHere are some examples of lists.\r\n\r\na = [0,1,2,3,4] is a list of numbers;\r\n\r\nb = ['abc','def','ghi'] is a list of strings;\r\n\r\nc = [1,'abc',2,3,'xyz'] is a mixed list;\r\n\r\nd = [1,['abc','def'],3] is a list that contains another list.\r\n\r\n\r\nList operations (again, think about their string equivalents)\r\n\r\n(1) len: we can compute the length of a list (# of values at the top-level of\r\n    the list). For the examples above, len(a) is 5; len(b) is 3; len(c) is 5,\r\n    len(d) is 3: it has an int, followed by a list, followed by an int: so\r\n    there are 3 top-level values in this list.\r\n\r\n(2) Indexing: we can refer to each value in a list by its index, starting at 0\r\n    a[0] is 0; b[0] is 'abc'; c[4] is 'xyz', d[1] is ['abc','def']\r\n    note that c[4][0] is 'x'; d[1][1] is 'def'; d[1][1][1] is 'e'; d[-1] is 3.\r\n    So if a simple name or any expression using that name refers to a list, we\r\n    can index it. Note a[10] raises IndexError exception, meaning the list\r\n    index out of range; recall that a[len(a)] always raises an exception,\r\n    because legal indexes are 0 to len(a)-1\r\n\r\n(3) Slicing: we can refer to sublists by slicing\r\n    a[1:] is [1,2,3,4]; a[1:-1] is [1,2,3]; etc.\r\n\r\n(4) Checking containment: the in/not in operators\r\n    1 in a is True; 'ghi' in b is True; 5 in c is False; 'abc' in d is False\r\n      (because in checks values at the top-level of the list, not inside; but\r\n      'abc' in d[1] is True because d[1] is ['abc','def']).\r\n\r\n(5) Concatenation: joining two lists to create a new one (think strings)\r\n    [1,2,3]+['ab','cd'] is [1,2,3,'ab','cd']\r\n    a + a is [0,1,2,3,4,0,1,2,3,4] (just like 'abc'+'abc' is 'abcabc')\r\n    In both cases a new list/string\r\n\r\n(6) Multiplication: Think of 3*'abc' as 3 concatenations: 'abc' + 'abc' + 'abc'\r\n      or the result 'abcabcabc'\r\n    3 * [0] is [0]+[0]+[0] is [0,0,0] (the most commonly used form of list *)\r\n    2 * [1,2] is [1,2,1,2]\r\n    2 * d is [1,['abc','def'],3,1,['abc','def'],3]\r\n\r\n(7) Iterability: for i in a:  produces all the top-level values in a\r\n       (there are len(a) of them):\r\n    for i in a:\r\n        print(i,end='')\r\n    prints: 01234\r\n\r\n    for i in d:\r\n        print(i,end='')\r\n    prints: 1['abc','def']3\r\n\r\n    for i in d[1]:\r\n        print(i,end='')\r\n    prints: abcdef\r\n\r\n\r\nList (mutation) operations\r\n\r\nThese have no string equivalents, because strings are immutable. If s = 'aBc',\r\nthen s.upper() produces a new string ('ABC') but does not change s. We could\r\nwrite s = s.upper() to rebind s to refer to 'ABC'. In the examples below the\r\nlist objects referred to are changed/mutated.\r\n\r\n(a) Assignment\r\n\r\n   suppose x = [0,1,2,3,4]\r\n   x[1] = 'a'\r\n   now x is [0,'a',2,3,4]; the value in index 1 is changed to 'a'\r\n   x[0] = [10,11]\r\n   now x is [[10,11],'a',2,3,4]; the value in index 0 is changed to [10,11]\r\n\r\n   in fact, we can even do assignment and slicing (although not used much)\r\n   suppose x = [0,1,2,3,4]\r\n   x[1:3] = ['a','b']\r\n   now x is [0, 'a', 'b', 3, 4]; the values in index 1-2 have 'a','b'\r\n      inserted\r\n\r\n(b) alist.append(avalue)\r\n    Appends a value at the end of the list: its len increases by 1\r\n    Note, this method call returns None! (see below)\r\n\r\n    Statement  \t      \t   \tPrints\r\n  -------------------------------------------------\r\n    print(a,len(a))\t\t[0,1,2,3,4] 5\r\n    a.append(5)\r\n    print(a,len(a))\t\t[0,1,2,3,4,5] 6\r\n   \r\n    Note that alist.append(avalue) is a simpler/faster way to do\r\n\r\n    alist = alist + [avalue]     or     alist += [avalue]\r\n\r\n    Note what happens if we print (a.append(5)): it prints None, but it still\r\n    appends 5 at the end of the list object a refers to.\r\n\r\n    Statement  \t      \t   \tPrints\r\n  -------------------------------------------------\r\n    print(a,len(a))\t\t[0,1,2,3,4] 5\r\n    print(a.append(5))\t\tNone\r\n    print(a,len(a))\t\t[0,1,2,3,4,5] 6\r\n    \r\n    IMPORTANT: NEVER WRITE l = l.append(value)\r\n    Doing so apppends value to l, but then rebinds l to None.\r\n    Why? l.append(value) changes the list object l refers to, but this\r\n    method call returns None, which l is rebound to by using the = delimiter.\r\n\r\n    alist.extend(alist2) is a simpler/fater way to do\r\n\r\n    for v in alist2: \r\n        alist.append(v)  \r\n\r\n      or\r\n\r\n    alist = alist + alist2\r\n\r\n      or\r\n\r\n    alist += alist2\r\n\r\n    All four forms result in alist referring to a list object that has all\r\n    the values from the original alist followed by all the values in alist2\r\n    (and alist2 remains unchanged).\r\n\r\n(c) del form: del alist[index] or del alist[slice] (a statement)\r\n    a = ['a','b','c','d','e']\r\n    del a[2]\t\t\ta is now ['a','b','d','e'], with len(a) == 4\r\n    del a[1:-1]                 a is now ['a','e'], with len(a) == 2\r\n\r\n\r\n(d) alist.pop(index)\r\n    Removes the value at a[index] and returns it as the value of this expression\r\n    A negative value for index removes from the end: alist.pop(-1) removes the\r\n      last value in the list.\r\n\r\n    Statement  \t      \t   \tPrints\r\n  -------------------------------------------------\r\n    print(a,len(a))\t\t['a','b','c','d','e'] 5\r\n    temp = a.pop(2)\r\n    print(temp,a,len(a)\t\t'c' ['a','b','d','e'] 4\r\n   \r\n    temp = a.pop(2) is equivalent to temp = a[2] followed by del a[2]\r\n\r\n    Note taht alist.pop() -calling this method without an argument- is the same\r\n    as calling alist.pop(0) -popping the value at index 0.\r\n\r\nCritically important code: the following prompts the user for a sequence of\r\nvalues and puts them in the list, in that order. We can also read a file of\r\nvalues and build a list of those values by appended them into a list\r\n\r\n  l = []\r\n  while True:\r\n      x = prompt.for_int('Enter next score (-1 to terminate)')\r\n      if x == -1:\r\n          break;\r\n      l.append(x)\r\n\r\n\r\n(e) alist.sort(key,reverse) you must name these parameter if you use them\r\n      default for key is None; reverse is False\r\n\r\nl = ['c','e','b','d','a']\r\nl.sort()\r\nprint(l)\r\nl.sort(reverse=True)\r\nprint(l)\r\n\r\nprints\r\n  ['a','b','c','d','e']\r\n  ['e','d','c','b','a']\r\n\r\nl = ['dog', 'cat', 'mouse', 'frog', 'bird','gerbil', 'fish', 'iguana']\r\nl.sort()\r\nprint(l)\r\nl.sort(reverse=True)\r\nprint(l)\r\nl.sort(key=(lambda x : x[1]))     # key uses the 2nd letter in the word\r\nprint(l)\r\nl.sort(key=(lambda x : x[::-1]))  # key uses the reverse of the word\r\nprint(l)\r\n\r\nprints\r\n\r\n  ['bird', 'cat', 'dog', 'fish', 'frog', 'gerbil', 'iguana', 'mouse']\r\n  ['mouse', 'iguana', 'gerbil', 'frog', 'fish', 'dog', 'cat', 'bird']\r\n  ['cat', 'gerbil', 'iguana', 'fish', 'bird', 'mouse', 'dog', 'frog']\r\n  ['iguana', 'bird', 'mouse', 'dog', 'frog', 'fish', 'gerbil', 'cat']\r\n\r\nBasically, when a key is specified, values are compared by using their keys,\r\nnot by the values themselves. So with a key of (lambda x : x[1]) Python\r\ncompares 'bird' and 'cat' not by comparing these strings directly, but by\r\ncomparing 'i' and 'a' (the letter in index 1 of each). So for sorting purposes\r\nusing this lambda, Python considers 'bird' > 'cat' because 'i' > 'a'.\r\n\r\nSorting is a power and subtle operations. Note that like append, sort mutates\r\nits list operand but returns None.\r\n\r\nExperiment: can you write a lambda that sorts words by their length?\r\n\r\n\r\n(f) index, count, and remove (by value):\r\n\r\nCalling alist.index(avalue) returns the index of the first occurrence of avalue\r\nin alist; if avalue does not occur anywhere in alist, then this function\r\nreturns -1; the index function for lists is similar to the find function for\r\nstrings.\r\n\r\nCalling alist.count(avalue) returns the number of times that avalue appears at\r\nthe top level of alist: it returns a value >= 0.  So,\r\n['a','c','d','a','b'].count('a') returns 2; ['a','c','d','a','b'].count('x')\r\nreturns 0.\r\n\r\nCalling alist.remove(avalue) removes the first occurrence of avalue from alist;\r\nif avalue does not occur anywere in alist, calling remove raises the ValueError\r\nexception. remove (like sort and append) returns the values None.\r\n\r\nNote that if avalue appears in alist, then alist.pop(alist.index(avalue)) has\r\nthe same affect as alist.remove(avalue). If avalue does not appear in alist,\r\nthe first expression removes the last value in the list, the second raises the\r\nValueError exception.\r\n\r\n\r\n(g) choice and shuffle: two functions in the random module\r\n\r\nThe choice function chooses a random value from a list (with each value in the\r\nlist chosen with equal probablility) and the shuffle function mutates the\r\nlist by randomizing the order of its values and returns the value None.\r\n\r\nfrom random import choice,shuffle\r\nprint(choice(l))\r\nshuffle(l)\r\nprint(l)\r\n\r\nprints (they are based on randomness; your results may vary)\r\n\r\n  dog\r\n  ['fish', 'gerbil', 'cat', 'mouse', 'bird', 'iguana', 'frog', 'dog']\r\n\r\nIn fact, we can use the random.randint(low,high) function to write choice\r\nourselves:\r\n\r\ndef choice(alist : list):\r\n    return alist[ random.randint(0,len(alist)-1) ]\r\n\r\nNote that if we don't know what kind of values are in a list parameter, we\r\nannotate it by just list; if we do know (say int), we annotate it by [int].\r\n\r\n\r\n(h) list: converting any iteratable into a list of its values\r\n\r\nWe can use list as a conversion function: its argument is anything that we can\r\niterate over. The result is a list containing every value produced by the\r\niteration. This is similar (but without the notion of iterable) to how we can\r\nuse str as a conversion functions: str(5) returns the string '5'. What can we\r\niterate over? str, range/irange, and open (files), and of course now, lists. \r\n\r\nFor example\r\n  x = list('abcde') binds x to ['a', 'b', 'c', 'd', 'e']\r\n  x = list(irange(1,10)) binds x to [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n  x = list(open('file-name')) binds x to a list of every line in the file\r\n        (note that each line contains '\\n' at the end)\r\nand\r\n  x = [1, 2, 3, 4, 5]\r\n  y = list(x) binds y to a different list object with the values 1-5 (a copy)\r\n\r\nSee the discussioin below about sharing.\r\n\r\nWe can think about the list function in terms of what we know about lists and\r\ncontrol structures.\r\n  s = ...some string\r\n  x = list(s)\r\n\r\nis like executing the code\r\n\r\n  x = []\r\n  for c in s:\r\n    x.append(c)\r\n\r\nThe end result is a list x, whose values are a sequence of all the things\r\nproduced by iterating over s.\r\n\r\n\r\n(i) split and join\r\n\r\nThese important and useful functions are inverses: split converts a string into\r\nlists of strings; join converts and a list of strings into a string.\r\n\r\n  'a,b,c,d'.split(',')           returns ['a', 'b', 'c', 'd']\r\n  ','.join(['a', 'b', 'c', 'd']) returns 'a,b,c,d'\r\n\r\nWe will see applications of these functions soon.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nImportant note about sharing\r\n\r\n   suppose x = [0,1,2,3,4]\r\n   then we execute z = x\r\n   now x and z share the same list object\r\n   \r\n   if we del x[0], x and z still refer to the same object, but it has mutated\r\n     and it would print as [1,2,3,4]\r\n\r\n   if instead we wrote z = list(x) then z instead refers to a copy of the list\r\n      x: a new list object, but with the same values in its indexes.\r\n   if we del x[0], x would print as [1,2,3,4] but z would print as [0,1,2,3,4]:\r\n      the copy was not mutated\r\n\r\n   Recall the difference between the \"is\" operator (object identity) and the\r\n   \"==\" operator.\r\n   The code\r\n     x = [0,1,2,3,4]\r\n     y = x\r\n     print(x is y, x == y)\r\n   prints True True\r\n\r\n   while the code\r\n     x = [0,1,2,3,4]\r\n     y = [0,1,2,3,4]\r\n     print(x is y, x == y)\r\n   prints False True\r\n\r\n\r\nComing: functions that process lists\r\n\r\n\r\n\r\n", "encoding": "ascii"}