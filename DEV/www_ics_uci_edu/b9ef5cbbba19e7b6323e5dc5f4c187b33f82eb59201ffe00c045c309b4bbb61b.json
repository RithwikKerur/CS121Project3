{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/generaltrees.txt", "content": "\t\t\tGeneral and Special Trees\r\n\r\n\r\nIn this lecture we will look at generalizations of simple binary trees (beyond\r\nBSTs, Heaps, and AVL trees). Specifically, we will see N-ary trees, for storing\r\nnodes that have an arbitrary number of childen; expression trees, for storing\r\nformulas, quadtrees for storing pictures, and digital trees for storing\r\ndictionaries (and Sets and Maps). In these trees we will also see examples of\r\nhow to store a node's children by using the set, queue, priority queue, and map\r\ntemplated classes, and even by using just two pointers in a very special way\r\n(so, as in binary trees: a surprising result).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nN-ary Trees with Templated Classes:\r\n\r\nTo start, we will examine a simple way to store N-ary trees: trees that can\r\nhave any number (N) of children.  Each parent can have a differnt number of\r\nchildren. Examples of information that we can represent in N-ary trees are\r\nsimple inheritance hierarchies (where each derived class can be extended by any\r\nnumber of classes, but each class still has a unique base class: smalltalk and\r\nJava use this kind of inheritance) and file structures (each folder can contain\r\nan arbitrary number of files and other folders). To store the later we might\r\ndeclare\r\n\r\nclass Folder_or_File {\r\n  public:\r\n    Folder_or_File\r\n      (bool item_is_file, std::string item_name, std::string item_contents)\r\n        : is_file(item_is_file), name(item_name), contents(item_contents),\r\n          children()\r\n    {}\r\n\r\n    bool                          is_file;\r\n    std::string                   name;     //for file or folder\r\n\r\n    std::string                   contents; //used if is_file\r\n    ics::ArraySet<Folder_or_File> children; //used if !is_file\r\n};\r\n\r\nwhich can represent an arbitrary file structure. There are actually few things\r\nmissing from this class (like a default constructor, operator== and operator<<\r\nthat are required for instantiating the ArraySet, but let's not worry about\r\nthese details now; in fact, this is a good place to use a union structure).\r\n\r\nAn example of how we can process such a structure, say to print all the names\r\n(files and folders) inside a folder (including names inside folders inside that\r\nfolder, etc. indented for each folder level), is shown below: basically it\r\nimplements a preorder traversal of an N-ary tree: process root before all\r\nchildren. \r\n\r\nNote the use of both interation (over the set) and recursion (for each value in\r\nthe set)\r\n\r\nvoid print_names (const Folder_or_File& ff, std::string indent = \"\") {\r\n  if (is_file)\r\n    std::cout << indent << ff.name;\r\n  else {\r\n    std::cout << indent << ff.name;\r\n    for (Folder_or_File f :  ff.children)\r\n      print_names(f, indent+\"  \");\r\n  }\r\n}\r\n\r\nHere there is no nullptr base case, becaue there are no pointers. The base \r\ncase is a leaf: a file, which has no children (its children set is empty, so\r\nthe loop immediately stops without processing any children). We can\r\n\"top-factor\" the output (print in true/false parts of if) and simplify this\r\ncode to \r\n\r\nvoid print_names (const Folder_or_File& ff, std::string indent = \"\") {\r\n  std::cout << indent << ff.name;\r\n  if (!is_file)\r\n    for (Folder_or_File f :  ff.children)\r\n      print_names(f, indent+\"  \");\r\n}\r\n\r\nIn fact, because for anything that is a file, the set of children is always\r\nempty, we could simplify this code to the following (removing the if), where\r\nthe loop would always execute 0 times for a file (because children.empty()\r\nis true).\r\n\r\nvoid print_names (const Folder_or_File& ff, std::string indent = \"\") {\r\n  std::cout << indent << ff.name;\r\n  for (Folder_or_File f :  ff.children)\r\n    print_names(f, indent+\"  \");\r\n}\r\n\r\nIf we wanted to store/print the children in alphabetical order, we could use a\r\nPriorityQueue instead of Set (or a Queue or Stack if simpler orders are\r\nappropriate) to organize the children. The for-each loop in the code above in\r\nprint_names works regardless of the  kind of templated class we use to\r\nimplement children, because all template classes have similar-working iterators.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nN-ary Trees embedded as Binary Trees:\r\n\r\nInterestingly enough, we can use a strange kind of binary tree (it has enough\r\ncomplexity) to store all the information in an N-ary tree! We would define such\r\na class as follows\r\n\r\ntemplate<class T>\r\nclass NTN_Binary {\r\n  public:\r\n    NTN_Binary ()\r\n      : first_child(nullptr), next_sibling(nullptr)\r\n    {}\r\n\r\n    NTN_Binary (const NTN_Binary<T>& n)\r\n      : value(n.value), first_child(n.first_child), next_sibling(n.next_sibling)\r\n    {}\r\n\r\n    NTN_Binary (T value,\r\n                NTN_Binary<T>* fc = nullptr, NTN_Binary<T>* ns = nullptr)\r\n      : value(value), first_child(fc), next_sibling(ns)\r\n    {}\r\n\r\n  T              value;\r\n  NTN_Binary<T>* first_child;     //First for a linked list of children\r\n  NTN_Binary<T>* next_sibling;    //Next in linked list of siblings\r\n};\r\n\r\nHere we use the two \"recursive\" pointers differently than in a binary tree\r\n(where we represent pointers to left and right subtrees) and differently than\r\nin a doubly-linked list (where we represent previous and next pointers). So,\r\nthis is a third, and different, two-pointer data structure.\r\n\r\nEach node points to its FIRST child and to its NEXT sibling. We can find all\r\nthe children of a parent node by examining its first child and then examining\r\nall its siblings. Note that the root node is guaranteed to have no siblings,\r\nbut all other nodes can have siblings (but don't have to: each can be an only\r\nchild or just the last child in the sibling linked list).\r\n\r\nIt is interesting to think about how a node with two pointers can be used to\r\nrepresent three such different structures as doubly-linked lists, binary trees,\r\nand N-ary trees, each with a very different uses of it pointers than the others.\r\n\r\nThe picture accompanying this lecture shows the equivalent of a small directory\r\nrepresented with the NTN_Binary data structure.\r\n\r\nAs a translation of the printing example above, we can write code that will \r\nprint all values inside an NTN_Binary tree, indented, by using a preorder\r\ntraversal of an N-ary tree). Here we print the value for a node, and then all\r\nthe values reachable from its children.\r\n\r\ntemplate<class T>\r\nvoid print_values (NTN_Binary<T>* root, std::string indent = \"\") {\r\n  if (root == nullptr)\r\n    return;\r\n  else {\r\n    std::cout << indent << root->value;\r\n    for (NTN_Binary<T>* c= root->first_child; c != nullptr; c = c->next_sibling)\r\n      print_values(c,indent+\"  \");\r\n  }\r\n}\r\n\r\nHere we return to a data structure with pointers, so we have nullptr (an empty\r\ntree) as the base case. It prints its n subtrees by combining iterating over\r\nthe n children of root (the first child and its siblings) with recursively\r\nprinting each child of the root (and all its subtree information).\r\n\r\nIn fact, we can rewrite this function purely recusively, which traverses the\r\ntrees in the same (prefix: every node before its children) order.\r\n\r\ntemplate<class T>\r\nvoid print_values (NTN_Binary<T>* root, std::string indent = \"\") {\r\n  if (root == nullptr)\r\n    return;\r\n  else {\r\n    std::cout << indent << root->value;\r\n    print_values(root->first_child,indent+\"  \");\r\n    print_values(root->next_sibling,indent);\r\n  }\r\n}\r\n\r\nHere we continue to check the base case root == nullptr, to terminate both\r\nrecursive calls (the subtree call and the sibling call, which is checked as\r\nc != nullptr in the for loop above). Each node prints its own name, all the\r\nnames reachable from its first child, and all the names reachable from its next\r\nsibling (which will include the next sibling's children, etc.).\r\n\r\nIt might also be useful to add a parent pointer in the NTN_Binary class, so\r\nthat every node could know/point to its unique parent. With such pointers we\r\ncan traverse the tree in more interesting patterns (much like adding a prev\r\npointer to a linear linked list to get a doubly-linked list).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nQuad Trees:\r\n\r\nWe next will briefly discuss Quad trees, which we can use to represent pictures\r\nthat are rendered (drawn) on the screen NOT from top to bottom, but from fuzzy\r\nto sharp. Also, for pictures that contain large areas of the same color, a Quad\r\ntree can store a picture more compactly than an array of pixels.\r\n\r\nIn a Quad tree, each node has exactly 4 children. We can represent a quad tree\r\nto store a picture by\r\n\r\nclass QTN {\r\n  public:\r\n    QTN (){}\r\n\r\n    QTN (int s, int r, int g, int b, bool is_leaf)\r\n      : size(s), avg_red(r), avg_green(g), avg_blue(b) {\r\n      if (!is_leaf)\r\n         children = new QTN[4];\r\n    }   \r\n\r\n    int   size      = 0;      //represents a patch: size x size\r\n    int   avg_red   = 0;      //  with a computed average RGB\r\n    int   avg_green = 0;      //  intensity of all the pixels\r\n    int   avg_blue  = 0;\r\n    QTN*  children  = nullptr;//nullptr or points to an array of 4 children\r\n  }\r\n\r\nEach Quad tree node represent a square (we could store rectangles, but let's use\r\nsquares to simplify things) of size^2 pixels. If the entire square has a\r\nuniform color, then the \"avg\" instance variables store its exact red, green,\r\nand blue pixel components, and the children field stores nullptr. Actually,\r\neven if the square is not one uniform color, the \"avg\" instances store the\r\naverage amount of red, green, and blue for pixels). If the square is not a\r\nuniform color, the children divide the square into four quadrants (numbered\r\n0-3), where each represents one quadrant of a child, whose vertical and\r\nhorizontal size is 1/2 that of its parent (each of the 4 quadrants is\r\n1/2 * 1/2 = 1/4 the size of its parent).\r\n\r\n  +--------+--------+\r\n  |        |        |\r\n  |   0    |   1    |\r\n  |        |        |\r\n  +--------+--------+\r\n  |        |        |\r\n  |   2    |   3    |\r\n  |        |        |\r\n  +--------+--------+\r\n\r\nThis process of creating children to represent the picture continues, at each\r\nlevel breaking its picture into four 1/4-sized pictures, until a child QTN is\r\nall one color. This might be because the quadrant is ONE SINGLE PIXEL (its base\r\ncase), or it might be because the quadrant is a square of pixels with a UNIFORM\r\nCOLOR, so no further subdivision is useful.\r\n\r\nBy using a Quad tree we can render a picture, not so much top to bottom in full\r\ndetail, but by refining each quadrant, quadrants in a quadrant, etc. until the\r\nentire picture is rendered. In this way the picture starts out as a blur at the\r\nroot, but with the right approximate color distribution, and the picture gets\r\nsharper and sharper as we process each subtree (breadth first) in the picture,\r\nfilling in more of its its details.\r\n\r\nThis is accomplished with a breadth first traversal of the Quad tree, where we\r\nrender the picture completely with one color at depth 0, then render each\r\nquadrant a depth 1 (four different color squares), then each quadrant of a\r\nquadrant a depth 2, etc. Each increase in depth can increase the number of\r\nsquares by a factor of 4 and can improve the resolution by a factor of 4.\r\nEventually we render squares that are a uniform color (either being 1x1 pixel\r\nor more pixels that are all a uniform color).\r\n\r\nObviously, storing all the information in this tree can take more space than\r\njust storing all the pixels, but the space requirements can be less if many\r\nsmall (or a few large) squares store the same color.\r\n\r\nLet's do a simple analysis. We will assume the picture has N pixels and is an\r\nMxM square, where M is perfect power of 2. So, for example, M might be 2^10\r\n(about 1,000), so N is 2^10 x 2^10 or 2^20 (about 1 million). Furthermore, lets\r\nassume adjacent pixels are always different (so the tree is full: each internal\r\nnode has 4 children). There is no space saving; that would be the \"worst case\".\r\n\r\nThe first question is, \"how many depths can be in the tree\": remember, the root\r\nis at depth 0. Well, there is 1 node at depth 0, 4 nodes at depth 1, 16 nodes\r\nat depth 2, etc. Generally, the number of nodes at depth d is 4^d. So, we want\r\nto know for what depth d, 4^d = N meaning every pixel appears by itself in a\r\nleaf node. Solving here, d = Log4 N. Likewise, the size of the square rendered\r\nat depth 0 is N; the size of each of the 4 squares rendered at depth 1, is\r\nN/2 x N/2 (or N/4 pixels), ...., the size of each square rendered at depth d is\r\nN/(4^d), so  again, we get a rendering size of 1 (a single pixel) when N = 4^d,\r\nor d = Log4 N.\r\n\r\nEvery node stores a red, green, and blue value (along with its rendering size,\r\nand 4 pointers to its subtrees). When we do a breadth first traversal of this\r\ntree, every node renders by duplicating its red, green, blue pixel values in a\r\nsquare of size. So the next question is, \"how many renderings occur\". This\r\nquestion is just asking how many internal and leaf nodes are in a quadtree of\r\ndepth d (where every depth is fully filled). The answer is a sum of the number\r\nof nodes at each depth, or\r\n\r\n  nodes = 1 +  4 + 16 + 64 + ....  + 4^d-1 + 4^d\r\n\r\nIf we multiply each side of this equality by 4, we get\r\n\r\n4*nodes = 4 + 16 + 64 + .... + 4^d + 4^d+1\r\n\r\nby subtracting the first equation from the second (each side) all but the first\r\nand last terms cancel, so we get.\r\n\r\n3*nodes = 4^d+1 - 1, or\r\n  nodes = (4^d+1 -1)/3\r\n\r\nBut, we know N = 4^d, so nodes = (4N-1)/3\r\n\r\nAssuming N is big, we ignore the -1 and, nodes ~ 4N/3; certainly we can say\r\nthe total number of nodes in a quadtree is O(N).\r\n\r\nSo, to render all the nodes in the tree is 1/3 more work than rendering all N\r\npixels (in the leaf nodes). Recall that in a full binary tree about 1/2 the\r\nnodes are leaves; in a quad tree (remember 4^d = N) \r\n\r\n  number of leaf nodes/total number of nodes =\r\n  4^d / (4N-1)/3  ~ 4^d / 4N/3 =  N / 4N/3 = 3/4\r\n\r\nSo, most (3/4 ths) of the number of nodes in a full quadtree are leaf nodes. The\r\noverhead of rendering the intermediate/internal nodes is just a fraction of the\r\ntotal number of pixels that are rendered in the final picture.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nExpression Trees:\r\n\r\nCompilers first PARSE a program (using the syntax of the language) by\r\nconverting it into a tree representing its syntactic structures/components. In\r\nthis section we will use expression trees to represent and process expression.\r\n\r\nFor example, given an expression we can use operator precedence and a stack to\r\ntranslate it into an expression tree and use a different stack to evaluate the\r\ntree easily: compute what value the tree represents. In the example below, we\r\nuse just one class to store and process such trees; in reality, it would be\r\nuseful to have a subclass for each different operator, but those many classes\r\nwould obscure the main point I'm trying to make here.\r\n\r\ntypedef TN<std::string> Expr_Tree;\r\n\r\nHere std::string is either an operator (\"*\") or the string representation of\r\nan integer (\"3\"). Expression trees are drawn in the standard way (although we\r\nsimplify things a bit by writing just * and 3 instead of their strings values.\r\n\r\nNote that when converting an expression to an Expr_Tree, the later an operator\r\nis applied, the higher it appears in the tree. So, we have the following\r\nexamples. I have written all the character strings without quotes.\r\n\r\n  2 + 3 * 5          (2+3) * 5          1 + 2 + 3\r\n\r\n      +                  *                  +\r\n    /   \\              /   \\              /    \\\r\n   2    *             +     5            +      3\r\n       /  \\          /  \\               /  \\\r\n      3    5        2    3             1   2\r\n\r\nNotice in the last example, because + is \"left associative\", the first + is\r\nevaluated before the second one. To be completely accurate in drawing\r\nexpression trees, you must follow associativity rules for equal precendence\r\noperators. Note that there are no empty (nullptr) expression trees: the smallest\r\nexpression a tree contains a value: e.g., new Expr_Tree(\"3\",nullptr,nullptr).\r\n\r\nWe will discuss in class, for a uniprocessor, that the number of time steps it\r\ntakes to evaluate such an expression is equal to the number of internal nodes\r\n(each internal node specifies an operation) in the tree; for a multiprocessor\r\nwith enough cores, it is the height of the tree (using the multiprocessor to\r\nsimultaneously evaluate all nodes at a depth, going upward).\r\n\r\nLet us see some simple recursive code to evaluate an expression. Note that we\r\ncan recognize an Expr_Tree as a base case value, if nullptr stored is stored in\r\nits left and right subexpressions. Note that if we introduced unary operators,\r\nthe left subexpression for one would be nullptr but the right subexpression\r\nwould refer to the value the unary operator operated on. I assume a function\r\nnamed str_to_int converts a string (like \"3\") to an int equivalent (3).\r\n\r\nint evaluate (Expr_Tree* e) {\r\n  if (e->left == nullptr && e->right == nullptr)\r\n    return str_to_int(e->value);\r\n\r\n  else {\r\n    if (e->value == \"+\")\r\n      return evaluate(e->left) + evaluate(e->right);\r\n\r\n    if (e->value == \"-\")\r\n      return evaluate(e->left) - evaluate(e->right);\r\n\r\n    if (e->value == \"*\")\r\n      return evaluate(e->left) * evaluate(e->right);\r\n\r\n    if (e->value == \"/\")\r\n      return evaluate(e->left) / evaluate(e->right);\r\n\r\n    throw IllegalOperatorException(e->value + \"is not an operator\");\r\n  }\r\n}\r\n\r\nThis code performs is a postorder traversal of a tree: computing the values of\r\nthe left and right subtrees, then using knowledge of the operator at the root\r\nof the tree to return the correct result for the operator at the root applied\r\nto the values of the subtrees.\r\n\r\nGiven a function is_int (which determines whether a string represents an int)\r\nwe could extend this function to be able to process trees that specify strings\r\nrepresenting variable names (any string that isn't representing an int).\r\n\r\nTo compute the value of the variable, we could use a\r\nMap<std::string,std::string>, where the keys in this map are variable names and\r\nthe values in this map are the values stored in these variables.\r\nSuch a map is called an \"environment\"; we can rewrite our evaluate code as\r\nfollows:\r\n\r\nint evaluate (Expr_Tree* e, ArrayMap<std::string,std::string>& env) {\r\n  if (e->left == nullptr && e->right == nullptr)\r\n    if (is_int(e->value))\r\n      return str_to_int(e->value);           //->value represents int: e.g., \"3\"\r\n    else\r\n      return str_to_int(env[e->value]);      //->value represent name: e.g., \"x\"\r\n \r\n  else {\r\n    if (e->value == \"+\")\r\n      return evaluate(e->left) + evaluate(e->right);\r\n\r\n    if (e->value == \"-\")\r\n      return evaluate(e->left) - evaluate(e->right);\r\n\r\n    if (e->value == \"*\")\r\n      return evaluate(e->left) * evaluate(e->right);\r\n\r\n    if (e->value == \"/\")\r\n      return evaluate(e->left) / evaluate(e->right);\r\n\r\n    throw IllegalOperatorException(e->value + \"is not an operator\");\r\n   }\r\n}         \r\n\r\nProblem: What if we allowed the = operator (which changes the value assocciated\r\nwith a variable and results in that new value); how could we update evaluate to\r\ninclude the semantics/meaning of this other operator? We could add the\r\nfollowing code at the bottom of the operator-decoding if statements. Assume\r\nis_var determines if a string is a legal variable name and int_to_str returns\r\nthe string representation of an int: int_to_str(3) returns \"3\".\r\n\r\n    if (e->value == \"=\")                                //var = val\r\n      if (!is_var(e->left->value) || !env.has_key(e->left->value))\r\n        throw IllegalVariableException(e->left->value + \" is not a variable\");\r\n      else {\r\n        int right_value = evaluate(e->right);           //computer rhs\r\n        env[e->left->value] = int_to_str(right_value);  //env[var] = val\r\n        return right_value;   \t\t\t\t//return val\r\n      }\r\n\r\nWe would require something similar for other state-change operators, like ++.\r\n\r\nWe can also use variants of such trees (often with inheritance) to store code/\r\nstatements in a language: like a block class to store a sequence of statements;\r\nand if class to store a boolean expression, and two block classes (for what to\r\nexecute when the test is true, and what to execute when the test is false). \r\nWe could write function like evaluate (say, named execute) to execute the code\r\nwe store as such trees.\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDigital Trees:\r\n\r\nFinally, we will examine Digital Trees (also known as \"tries\", pronounced as\r\nin the word reTRIEval -so just like \"tree\"). As an example we can use digital\r\ntrees to store a dictionary of words for a spelling correction utility. The\r\nstandard way to store such a structure would be as a Set of legal words. So\r\nfar, the most efficient way we have seen to store such a collection is an AVL\r\ntree. Recall that an AVL tress is a special kind of BST that is guaranteed to\r\nbe well balanced, so the time to search for a word (and add one and remove one)\r\nwould be at worst O(Log N).\r\n\r\nUsing a digital tree, we can reduce the complexity of many of its important\r\noperations (find, add, and remove) to O(1)! The time doesn't depend on the\r\nNUMBER OF WORDS stored in the digital tree; but it does depend on HOW MANY\r\nLETTERS ARE STORED in the word we are adding, removing, or inserting). So, we\r\nmight say if a word contained M letters in a digital tree containing N values,\r\nthe time to add/remove/insert is O(M), which is independent of N.\r\n\r\nUsing this new way to characterize words, since each comparison in the AVL tree\r\nmight requiring looking at all M letters in a word (string comparisons are\r\nletter by letter comparisons until there is a letter mismatch or one of the\r\nstrings runs out of letters), we would then have to list the AVL tree's\r\ncomplexity, if using the same metric, as O(M Log N). So digital trees do save\r\na factor of Log N. Although, the digital tree very often requires looking at ALL\r\nM characters, while comparisons in BSTs often find a difference in the first\r\nfew letters. \r\n\r\nA digital tree means the value that we want to look up can be broken down into\r\nits \"digits\". For example, to look up the integer 153 we look at the digit 1,\r\nthen the digit 5, then the digit 3; likewise, to look up the string \"yes\" we\r\nlook at the \"digit\" \"y\", then the \"digit\" \"e\", then the \"digit\" \"s\". So, the\r\ncharacters are the \"digits\" for a string. \r\n\r\nTo store a digital tree for processing Strings, we might represent it as\r\nfollows. Note here, the children are collected in an ArrayMap, with each key a\r\nchar and each value another DTN.\r\n\r\nclass DTN {\r\n  public:\r\n    DTN (bool iw, std::string wth) :\r\n      is_word(iw), word_to_here(wth), children()\r\n    {}\r\n\r\n    bool                is_word;\r\n    std::string         word_to_here; //Cache this value; can computed from root\r\n    ArrayMap<char,DTN>  children;\r\n  }\r\n\r\nHow do we add a word into a digital tree?\r\n\r\nWe always start with a root DTN (whose is_word is alway false and whose\r\nword_to_here is \"\": the empty string). It represents a word of 0 characters (of\r\nwhich there aren't any!). To add a word, say \"ant\", we start at the root.\r\n\r\n  If its children map contains the first letter, \"a\", we find the value DTN\r\n  assocated with this letter: a subtree containing all the words starting with\r\n  the letter \"a\". We then repeat this process again from there, with the next\r\n  letter, \"n\". If we get to the end of the word and we have not needed to\r\n  create a new DTN to reach that spot, we set is_word of that DTN is true.\r\n\r\n  If at any time a DTN's children map does not contain the letter we need, we\r\n  put that new letter into the map (with a value that is a DTN with its is_word\r\n  false and its word_to_here containing all the needed letters) and follow it.\r\n  So, if the root's children map DOES NOT contain the first letter, \"a\", we add\r\n  to that map a key of \"a\" with a value DTN whose is_word is false and\r\n  word_to_here is \"\"+\"a\" (the word_to_here of its parent, extended by its\r\n  letter). We use this DTN to represent the root of a subtree whose children\r\n  are all the words starting with \"a\". Then we repeat this process with all\r\n  subsequent letters: for the last DTD, we set its is_word to true (since we\r\n  have processed all the letters in a word)\r\n\r\nNote that each map will contain at most 26 entries, one for each possible\r\nletter in a word: we'll assume only lowercase letters; of course we could use\r\nboth cases and increase the map's size at most to 52). In fact, we could use\r\nan array to store these 26 pointers: to look up character c we use the array\r\nindexed at c-'a' (C++ subtracts from the ASCII value of c the ASCII value of\r\n'a': 'a'-'a' = 0, 'b'-'a' = 1, ... 'z'-'a' = 25. Using an array would be faster\r\nthan any kind of map.\r\n\r\nThus, the word \"anteater\" and \"anthem\" share the structure \"ant\", then\r\nin the children map for \"ant\", the key \"e\" leads to a DTN on the path to\r\n\"anteater\" and the key \"h\" leads to a different DTN on the path to \"anthem\".\r\nThis sharing is illustrated in the picture below.\r\n\r\n                          root\r\n                            |a\t\t\t\t  a -> node\r\n                         \"a\" false\r\n                            |n\t\t\t\t  n -> node\r\n                         \"an\" false (unless \"an\" added)\r\n                            |t\t\t\t\t  t -> node\r\n                         \"ant\" false (unless \"ant\" added)\r\n                    /e          \\h\t\t\t  e -> node; h -> node\r\n             \"ante\" false     \"anth\" false\r\n               |a               |e\t\t\t  ...\r\n             \"antea\" false    \"anthe\" false\r\n               |t               |m\t\t\t  ...\r\n             \"anteat\" false   \"anthem\" true\r\n               |e\t\t\t\t\t  ...\r\n             \"anteate\" false\r\n               |r\t\t\t\t\t  ...\r\n             \"anteater\" true\r\n\r\nNote that there is one true for every word. If we put \"a\" in the digital tree\r\nabove, the only change would be change the is_word from false to true in the\r\nchild of the root.\r\n             \r\nTo search for a word, we use each of its letters, in sequence, to \"get\" the\r\nnext DTN, until we either (a) cannot find a subtree with that key (word is not\r\npresent), (b) run off the bottom of the tree (word is not present) or (c) get\r\nto the last letter of the word -in which case is_word tells whether or not it\r\nreally is a word in the dictionary. That is, in the above example, looking up\r\n\"anq\" would return false (not in the three); \"ant\" would return true (in the\r\ntree, marked as a word); \"anthemly\" would  return false (not in the tree);\r\n\"anthe\" would also return false (in the tree but not marked as a word).\r\n\r\nThe function for this is easy to write.\r\n\r\nbool is_a_word (const DTN& root, std::string remaining_letters) {\r\n  if (remaining_letters.empty())\r\n    return root.is_word;          //all letters in tree; is it a word?\r\n  else if (root.children.has_key(remaining_letters[0]) == false)\r\n    return false;                 //some letters not in tree: it isn't a word\r\n  else\r\n    return is_a_word(root.children[remaining_letters[0]], //check the subtree\r\n                     remaining_letters.substr(1));        //for the next letter\r\n  }\r\n\r\nHere remaining_letters[0] is a char that is the first letter (the key to the\r\nmap, used to get to one of its subtrees), and remaining_letters.substr(1) is a\r\nstd::string containing all but the first letter: both the tree and the string\r\nare getting \"smaller\" in each recursive call: the tree getting closer to a leaf\r\nbase case; the string getting closer to the empty (\"\") base case. One will\r\nwill be reached first.\r\n\r\nThe algorithm for removing a word is a bit more subtle: we can search for the\r\nword and set its is_word to false; we can actually remove its DTN from the tree,\r\nbut only if it has no children (otherwise removing the DTN would remove all its\r\nchildren, some of which might be words); we can do the same with its ancestors\r\nthat are not words until we find a DTN whose is_word is true or a DTN that has\r\nother children or the root; from that point on we must leave this DTN in the\r\ntree so it and all its children words can be found. Note that there are lots of\r\nDTNs in a tree that don't represent words.\r\n\r\nSo, in the tree above, if we remove \"ant\", we set its is_word to false and that\r\nis all we can do. But if we then remove \"anteater\", we get rid of DTNs with the\r\nwords \"anteater\", \"anteate\", \"anteat\", \"antea\", \"ante\", but must stop there,\r\nbecause if we deleted the DTN with \"ant\", the digital tree would not store the\r\nword \"anthem\".\r\n\r\nWe can use digital trees to represent sets and maps (for maps, instead of\r\nis_word, use an instance variable for the value associated with a key) and very\r\nquickly add/lookup/remove words in an N word tree, all in O(1) - or O(M) where\r\nthe word we are processing has M letters.\r\n\r\nFinally, we will review the difference between a data type and a data structure.\r\nRecall that a data type is most like an abstract class in C++. It specifies the\r\noperations that one can perform, but makes no commitment as to how the\r\ninformation is represented or how the operations are accomplished. A data\r\nstructure is most like a concrete class in C++. There can be many data\r\nstructures that implement a data type, each using a different way to encode the\r\ndata and perform the operations.\r\n\r\nOnce a programmer solves a problem using data types, he/she can use any data\r\nstructures implementing them to actually run the program. All data structures\r\nshould produce the same result, but some will run faster than others, depending\r\non the complexity class of their operations. Note that in the case of\r\niteration, there is nothing specified about the order the values will be\r\niterated over: we specify only that every value will be iterated over once. Of\r\ncourse if we need an order, we can use a priority queue to establish one.\r\n\r\nAt the start, this course was all about Data Types (templated classes: Queue,\r\nStack, PriorityQueue, Set, Map): we learned to solve problems using compositions\r\nof these data types, modeling the needed data and operations; then the course\r\nswitched focus and we started studying the various ways to implement them\r\n(Arrays, Linked Lists, Heaps, Binary Search Trees, AVL trees, Digital Trees,\r\nand coming soon Hash Tables) where we also characterize these data structures\r\nby the complexity classes of their operations. Once we solve problems thinking\r\nabout the needed data types (as in Program #1), we can easily interchange\r\ndifferent data structures that implement these data types to find one that\r\nperforms the best: typically we just replace information in an #include and\r\ntypedef: typdef ArraySet<...> SetClass; with typdef BSTSet<...> SetClass; and\r\nuse SetClass as the type for variables and parameters.\r\n\r\nBut, note that constructors might be different too: an ArraySet has a\r\nconstructor that specifies an int: how large of an array to allocate initially\r\nfor storing the set. A LinkedSet would not have a constructor specifying an int\r\nvalue.\r\n", "encoding": "ascii"}