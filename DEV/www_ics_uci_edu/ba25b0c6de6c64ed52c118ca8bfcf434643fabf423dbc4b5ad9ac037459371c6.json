{"url": "https://www.ics.uci.edu/~kay/courses/141/hw/hw2.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\">\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\">\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Wednesday, January 19, 2000 3:55 PM\">\n<TITLE>Asst. 2 * Functional Programming</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"644ECB4B\">\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"Programming languages, homework, functional programming\">\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"Assignment 2 on functional programming for ICS 141, an undergraduate course in the concepts of programming languages taught by David G. Kay in the Department of Information and Computer Science, University of California, Irvine.\">\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 1999 by David G. Kay.  All rights reserved.\">\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<A NAME=\"_top\"></A>\n<P>\n<IMG SRC=\"asst_2_functional_pgmg_files/sidebar_73.gif\" WIDTH=468 HEIGHT=78>\n<BR>\n<FONT FACE=\"AGaramond\" SIZE=4>This assignment is due on Monday, January\n31; deposit your assignment in the locking drop box in room CS 189.  Try\nto finish the assignment by Friday morning so you can ask questions about\nit in discussion.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>Summary:</B>  In the last lab, you became\ncomfortable (or at least conversant) with the Scheme interpreter, with Scheme\nsyntax, and with the recursive style of list processing.  In this assignment\nyou will work with list structures and explore some programming techniques\nusing higher-order functions.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(a)</B>  Draw box-and-pointer diagrams\n(as shown on page 579 of Sebesta) for the following expressions.  For the\nempty list, use an empty cell (rather than a cell pointing to the symbol\n</FONT><FONT FACE=\"Courier New\">NIL</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nas Sebesta does).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; *  </FONT><FONT FACE=\"Courier New\">(Franz\n() Klefstad)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; *  </FONT><FONT FACE=\"Courier New\">((Pratt\nMehrotra Baldi))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; *  </FONT><FONT FACE=\"Courier New\">((Pratt\nGennari) (Venkatasubramanian Mehrotra) (Mark Kobsa))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; *  </FONT><FONT FACE=\"Courier New\">(Ackerman\n(King (Grudin (Kling))))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; *  </FONT><FONT FACE=\"Courier New\">(define\nfact (lambda (x) (if (&lt;= 0 x) 1 (* x (fact (- x 1))))))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(b)</B>  Write the Scheme expression that\ncorresponds to each of the two box-and-pointer diagrams below. </FONT></P>\n<P>\n<IMG SRC=\"asst_2_functional_pgmg_files/picture_21.gif\" WIDTH=322 HEIGHT=71 ALT=\"\">\n</P>\n<BR><BR>\n<P>\n<IMG SRC=\"asst_2_functional_pgmg_files/picture_20.gif\" WIDTH=286 HEIGHT=126 ALT=\"\">\n</P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c)</B>  Sebesta defines the function </FONT><FONT FACE=\"Courier New\">mapcar</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nmore commonly called </FONT><FONT FACE=\"Courier New\">map</FONT><FONT FACE=\"AGaramond\" SIZE=4>:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(map</FONT><FONT>\n</FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>action</U></I></FONT><FONT> </FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>list</U></I></FONT><FONT FACE=\"Courier New\">)</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich returns a list, each of whose elements is the result of applying <I><U>action</U></I>\n(a function) to the corresponding element of <I><U>list</U></I>.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Another function that takes another function\nas an argument is </FONT><FONT FACE=\"Courier New\">filter</FONT><FONT FACE=\"AGaramond\" SIZE=4>:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(filter\n</FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>test?</U></I></FONT><FONT> </FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>list</U></I></FONT><FONT FACE=\"Courier New\">)</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich returns a list of those elements in <I><U>list</U></I> that satisfy\n<I><U>test?</U></I> (which is a predicate--a function that returns true\nor false, given an element of <I>list.</I>)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Write a definition of </FONT><FONT FACE=\"Courier New\">filter</FONT><FONT FACE=\"AGaramond\" SIZE=4>.\n Check the Notes on Scheme handout, which contains a function that does\nthe same task.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>Now look at this third function:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; *  </FONT><FONT FACE=\"Courier New\">(accumulate\n</FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>action</U></I></FONT><FONT> </FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>initial-value</U></I></FONT><FONT>\n</FONT><FONT FACE=\"AGaramond\" SIZE=4><I><U>list</U></I></FONT><FONT FACE=\"Courier New\">)</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwhich is defined as follows:<A NAME=\"_14_1935\"></A>\n<BR>\n</FONT><CODE><FONT FACE=\"Courier New\">&#160;&#160; \n<BR>\n(define accumulate\n<BR>\n&#160;&#160; (lambda (action initial-value list)\n<BR>\n&#160;&#160;  &#160; (cond\n<BR>\n&#160;&#160;  &#160;  &#160; ((null? list) initial-value)\n<BR>\n&#160;&#160;  &#160;  &#160; (else (action (first list) \n<BR>\n&#160;&#160;  &#160;  &#160;  &#160;  &#160;  &#160;      (accumulate action\ninitial-value (rest list)))))))</FONT></CODE></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.1)</B>  What is the result of evaluating\neach of these expressions?  Try them by hand before typing them in to check\nyour answer; you won&#39;t have a Scheme interpreter on the exams.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(accumulate\n+ 0 &#39;(1 2 3 4 5))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(accumulate\n(lambda (a b) (+ b (if (even? a) a 0))) 0 &#39;(1 2 3 4 5))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(accumulate\ncons &#39;() &#39;(Huey Dewey Louie))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(accumulate\nmax -1 &#39;(1953 1956 1949 1991 1964))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.2)</B>  Assume you have a function </FONT><FONT FACE=\"Courier New\">(interval\na b)</FONT><FONT FACE=\"AGaramond\" SIZE=4> that returns a list of all the\nintegers between </FONT><FONT FACE=\"Courier New\">a</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nand </FONT><FONT FACE=\"Courier New\">b</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\ninclusive (so that </FONT><FONT FACE=\"Courier New\">(interval 5 10)</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nwould return </FONT><FONT FACE=\"Courier New\">(5 6 7 8 9 10)</FONT><FONT FACE=\"AGaramond\" SIZE=4>).\n (Re-)write the function </FONT><FONT FACE=\"Courier New\">factorial</FONT><FONT FACE=\"AGaramond\" SIZE=4>\nusing </FONT><FONT FACE=\"Courier New\">accumulate</FONT><FONT FACE=\"AGaramond\" SIZE=4>\n(and </FONT><FONT FACE=\"Courier New\">interval</FONT><FONT FACE=\"AGaramond\" SIZE=4>),\nwithout any explicit recursion.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.3)</B>  Now, think back to the restaurant\ndatabase and assume we have a standard Lisp list (called </FONT><FONT FACE=\"Courier New\">RL</FONT><FONT FACE=\"AGaramond\" SIZE=4>)\nof the restaurant objects as we described.  For each of the following expressions,\ndescribe in one English sentence what value it returns.  Don&#39;t just\nsay, &quot;It does an accumulate of plus and zero to a map of ... ;&quot;\ngive a description of what the expression <I>means,</I> something you could\nput in a software catalog so that a prospective buyer could find what he\nor she wanted.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(accumulate\n+ 0 (map (lambda (R) 1) RL))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(filter\n(lambda (R)(equal? &#39;Ethiopian (rest-cuisine R))) RL)</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(/\n(accumulate + 0 (map (lambda (R) (rest-price R)) RL))\n<BR>\n&#160;&#160;  &#160;   (accumulate + 0 (map (lambda (R) 1) RL)))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * </FONT><FONT FACE=\"Courier New\">(let\n((PRL (filter (lambda (R) (equal? 'pizza (rest-dish R))) RL)))\n<BR>\n&#160;&#160;  &#160;  (/ (accumulate + 0\n<BR>\n&#160;           (map (lambda (R) (rest-price R)) PRL))\n<BR>\n&#160;        (accumulate + 0 (map (lambda (R) 1) PRL))))</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4><B>(c.4)</B>  Using </FONT><FONT FACE=\"Courier New\">map</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\n</FONT><FONT FACE=\"Courier New\">filter</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nand </FONT><FONT FACE=\"Courier New\">accumulate</FONT><FONT FACE=\"AGaramond\" SIZE=4>,\nwrite an expression to return each of the following values without using\nexplicit recursion:</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * a list of all the French and\nItalian restaurants in RL</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * a list of all the <I>names</I>\nof the French and Italian restaurants in RL</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * a list of all the restaurants\nin RL whose best dish costs between $10.00 and $20.00 (inclusive).</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * the name of the lowest-priced\nFrench restaurant in RL</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>&#160;&#160; * (extra credit) a list of all\nthe restaurants in RL, where every French restaurant whose best dish&#39;s\nprice is less than the average (price of best dishes at French restaurants)\nhas its price changed to that average price.</FONT></P>\n<P>\n<FONT FACE=\"AGaramond\" SIZE=4>You aren&#39;t required to code up and run\nthe solutions to this problem; you can do them with pencil and paper.  However,\ncoding them up is good practice, it can help you verify that your solutions\nare right, and it might earn you a bit of extra credit.</FONT></P>\n<BR CLEAR=ALL>\n</BODY>\n</HTML>\n", "encoding": "ascii"}