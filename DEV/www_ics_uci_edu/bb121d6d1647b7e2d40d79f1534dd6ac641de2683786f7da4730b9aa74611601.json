{"url": "https://www.ics.uci.edu/~kibler/javacourse/event.html", "content": "<html>\n<head>\n<title>  Event Handing </title>\n</head>\n\n<h1> Event Handling </h1>\n<h2>The problem: connecting user events to code execution.</h2>\n<P> User events: mouse click, mouse down, mouse up, mouse drag, mouse\nwithin a component (focus), key pressed, particular key pressed, etc.\n<p> Solution 1: have controls listen to all events, check whether\n they should respond, and then respond. Roughly this was the\n JDK 1.0 model.\n<p> Solution 2: Tell controls what events they can respond to\nand have them direct messages to appropriate actions (methods within\nobject) . This is the \"delegation\" model of JDK 1.1 and is more efficient.\n<p> Model: <br>\n     user action --> source object (control) ----> target object (listener)\n<p> What we need to do is:\n <ol>\n  <li> identify (turn on) controls that will respond to events\n  <li> For these controls, connect them to appropriate listeners. \n      This is called registration. Note multiple actions can take place\n   for each event, and these are not synchronized. Also any object\n   can be a listener if it implements the appropriate interface.\n </ol>\n<p> So what do we need to do?\n   <ol>\n   <li> To the control c, execute  c.addSomeListener(some obj).\n <p> This makes c respond to the event by sending a message to the object.\n  <li> Make obj an event listener, i.e. by\n      <ol>\n       <li> declaring that it implement the appropriate Listener Interface\n       <li> defining the methods of the Interface.\n      </ol>\n</ol>\n</ul>\n<h3>Abstract Example: Making object c of  Foo  respond to Button b; </h3>\n\n<pre>\n      Foo c = new Foo();\n      Button b = new Button(\"clear\");\n      b.addActionListener(c);       //.. buttons generate action events\n     ...\n      // ActionListener has only 1 method, actionPerformed\n     ..\n      class Foo implements ActionListener\n\n   {\n    ...\n        public void  actionPerformed()\n     {\n        whatever foo should do when button is pressed\n     }\n    ...\n   }\n</pre>\n\n<h3> Four Designs </h3>\n\n<br> This program allows the user to draw lines, clear the screen, and\n change colors. \n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n// Design 1:  Everyone talks to applet and gets messages from applet.\n//   Applet acts as god class.  This is usually the simpliest design.\n\n\nclass MyCanvas extends Canvas\n{\n  Color linecolor= Color.black;  \n\n  public void paint(Graphics g)  \n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n   //.. repaint() schedules update(). update() (typically) calls paint().\n }\n\n  public void changeColor()\n {\n   Color[] colors ={Color.red,Color.black,Color.blue,Color.magenta};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n\n}\n\npublic class MouseTest extends Applet\n  implements ActionListener, MouseListener\n{\n  Panel top;\n  Button clear;\n  Button change;\n  MyCanvas mycanvas;\n  Point begin,end;\n\n  public void init()\n {\n   top = new Panel();\n   clear = new Button(\"Clear\");\n   clear.addActionListener(this);\n   change = new Button(\"Change Color\");\n   change.addActionListener(this);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas = new MyCanvas();\n   mycanvas.addMouseListener(this);\n   add(mycanvas,\"Center\");\n }\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear ) mycanvas.clear();\n    else if (arg == change) mycanvas.changeColor();\n }\n\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    mycanvas.drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n     mycanvas.drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n}\n</pre>\n\nIn the next design we group related activities more finely.\nThe code is longer, but may allow easier changes.\nCode is simpliest when its structure reflects\nthe organization of the computation. \n\n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n\nclass MyCanvas extends Canvas\n{\n  Color linecolor= Color.black;  \n\n\n  public void paint(Graphics g)  // why doesn't this work?\n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n }\n\n  public void changeColor()\n {\n   Color[] colors ={Color.red,Color.black,Color.blue,Color.magenta};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n\n}\n\nclass ClearButton extends Button\n{\n   ClearButton(MouseTest mt)\n  {\n    super(\"Clear\");\n    addActionListener(mt);\n  }\n\n}\nclass ChangeButton extends Button\n{\n   ChangeButton(MouseTest mt)\n  {\n   super(\"Change Color\");\n   addActionListener(mt);\n  }\n}\n\n\n\npublic class MouseTest extends Applet\n  implements ActionListener, MouseListener\n{\n  Panel top;\n  ClearButton clear;\n  ChangeButton change;\n  MyCanvas mycanvas;\n  Point begin,end;\n\n  public void init()\n {\n   top = new Panel();\n   clear = new ClearButton(this);\n   change = new ChangeButton(this);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas = new MyCanvas();\n   mycanvas.addMouseListener(this);\n   add(mycanvas,\"Center\");\n}\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear ) mycanvas.clear();\n    else if (arg == change) mycanvas.changeColor();\n }\n\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    mycanvas.drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n     mycanvas.drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n}\n\n</pre>\n\nIn this design we examine the interactions between the events.\n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n/* Design 2: here we analyze the objects and see where message are going\n The  Listener for the message must be able to see the object generating\n the message. \nMessage Diagram:\n                 clearbutton --> canvas  \n                  changebutton --> canvas\n                  canvas -->(mouse clicks) -->canvas\nSo the buttons will still need to be mediated by the applet, while\nthe canvas can talk to itself.\n*/\t\t  \n\n\nclass MyCanvas extends Canvas\n     implements  MouseListener\n{\n  Color linecolor= Color.black;  //ugh\n  Point begin,end;\n\n\n\n  public void paint(Graphics g)  \n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n }\n\n  public void changeColor()\n {\n   Color[] colors =\n            {Color.red,Color.black,Color.blue,Color.magenta,Color.green};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n    drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n\n}\n\n\npublic class MouseTest extends Applet\n  implements ActionListener\n{\n  Panel top;\n  Button clear;\n  Button change;\n  MyCanvas mycanvas;\n\n\n  public void init()\n {\n   mycanvas = new MyCanvas();  \n   top = new Panel();\n   clear = new Button(\"Clear\");\n   clear.addActionListener(this);\n   change = new Button(\"Change Color\");\n   change.addActionListener(this);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas.addMouseListener(mycanvas);\n   add(mycanvas,\"Center\");\n }\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear) mycanvas.clear();\n    else if (arg == change) mycanvas.changeColor();\n }\n}\n\n\n\n</pre>\n<h3> Example redone with Inner Classes </h3>\n Inner classes are a recent addition to Java.\n<br> Each inner class is local to the class but has access to all\n   the members of the class.\n<br> Inner classes seem to violate the principle of information hiding.\n<br> Inner classes are not the same as nested classes in C++.\n\n<pre>\nimport java.applet.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n// Version using inner classes. Arguable bad style.\n\npublic class MouseTest extends Applet\n \n{\n  Panel top;\n  Button clear;\n  Button change;\n  MyCanvas mycanvas;\n\n  public void init()\n {\n   mycanvas = new MyCanvas();  \n   top = new Panel();\n   clear = new Button(\"clear\");\n   clear.addActionListener(mycanvas);\n   change = new Button(\"Change Color\");\n   change.addActionListener(mycanvas);\n   top.add(new Label(\"Mouse click to draw lines\"));\n   top.add(clear);\n   top.add(change);\n   setLayout(new BorderLayout());\n   add(top,\"North\");\n   mycanvas.addMouseListener(mycanvas);\n   add(mycanvas,\"Center\");\n }\n\n\nclass MyCanvas extends Canvas\n     implements  MouseListener, ActionListener //.. note: inner class\n{\n  Color linecolor= Color.black; \n  Point begin,end;\n\n\n  public void paint(Graphics g)\n  {\n      Dimension d = getSize();\n      g.drawRect(2,2,d.width-4,d.height-4);\n  }\n\n\n  public void clear()\n {\n   Graphics g = getGraphics();\n   Dimension d = getSize();\n   Color c = getBackground();\n   g.setColor(c);\n   g.fillRect(0,0,d.width,d.height);\n   repaint();\n }\n\n  public void changeColor()\n {\n   Color[] colors =\n            {Color.red,Color.black,Color.blue,Color.magenta,Color.green};\n   linecolor = colors[random(colors.length)]; \n }\n \n public int random(int i)\n  {\n     return (int) Math.floor(Math.random()*i);\n  }\n\n  public void drawLine(Point p, Point q)\n  {\n   Graphics g = getGraphics();\n   g.setColor(linecolor);\n   g.drawLine(p.x,p.y,q.x,q.y);\n   g.drawOval(q.x,q.y,2,2);\n  }\n\n public void drawOval(Point p)\n  {\n    Graphics g = getGraphics();\n    g.drawOval(p.x,p.y,2,2);\n  }\n   public void mousePressed(MouseEvent me)\n {\n    begin = me.getPoint();\n    drawOval(begin);\n }\n    public void mouseReleased(MouseEvent me )\n  {\n     end = me.getPoint();\n    drawLine(begin,end);\n   }\n\n   public void mouseClicked(MouseEvent me)\n  {}\n\n   public void mouseEntered(MouseEvent me)\n  {}\n\n  public void mouseExited(MouseEvent me)\n {}\n\n  public void actionPerformed(ActionEvent actevt)\n {\n   Object arg = actevt.getSource();\n   if (arg == clear) clear();\n    else if (arg == change) changeColor();\n }\n}\n}\n\n</pre>\n\n<h3> Event processing, in review </h3>\n\n <ul>\n  <li> Event sources (controls) are objects that respond to user actions\n  Examples are buttons, scrollbars etc.\n  <li> An event source sends a message to an event listener.\n  <li> Any object can be an event listener, if it implements the\n   appropriate interface.\n  <li> Several objects may respond to the same event,\n   but there is no stipulation about  which will respond first.\n  <li> Currently there are 11 types of event listeners.\n  <li> Event sources registers its event listeners, via\n   the method add...Listener(..), e.g. addActionListener(this).\n </ul>\n<h3> Recipe for making object2 responds to events in object1 </h3>\n  <ul>\n   <li> add to object1 (source)  add...Listener(object2).\n      The ... corresponds to the type of event object1 can respond to.\n   <li> make object2 a Listener, i.e. say\n      <ul>\n         <li> implements ...Listener\n         <li> add the methods designated by ...Listener\n         <li> Or, extend an Adapter for the Listener\n      </ul>\n    <li> Some of these complications occur because Java does\n   not support full multiple inheritance.\n  </ul>\n\n<h3> Controls, Listeners, and interface method </h3> \n\n<table border>\n<tr>\n <td> <b> Control</b> </td>\n <td> <b>Registers Interest </b>  </td>\n <td> <b> Receives Event </b></td>\n</tr>\n<hr>\n<tr>\n <td>  Button </td>\n <td rowspan=4> addActionListener(..) </td>\n <td rowspan=4> actionPerformed </td>\n</tr>\n<tr> <td> List </td> </tr>\n<tr> <td> MenuItem </td> </tr>\n<tr> <td> TextField </td> </tr>\n<tr> \n <td> Checkbox </td>\n <td rowspan=4> addItemListener </td>\n <td rowspan=4> itemStateChanged </td>\n</tr>\n<tr>  <td> Choice </td> </tr>\n<tr>   <td> List </td> </tr>\n<tr> <td> CheckBoxMenuItem </td> </tr>\n<tr>\n  <td rowspan=7> Dialog Frame </td> \n  <td rowspan=7> addWindowListener </td>\n  <td> windowClosing </td>\n</tr>\n<tr> <td> windowOpening </td> </tr>\n<tr> <td> windowIconified </td> </tr>\n<tr> <td> windowDeiconified </td> </tr>\n<tr> <td> windowClosed </td> </tr>\n<tr> <td> windowActivated </td> </tr>\n<tr> <td> windowDeactivated </td> </tr>\n<tr>\n  <td rowspan=4> Dialog Frame </td> \n  <td rowspan=4> addComponentListener </td>\n  <td>componentMoved </td>\n</tr>\n<tr><td> componentHidden </td></tr>\n<tr><td> componentResized </td></tr>\n<tr><td> componentShown </td></tr>\n<tr>\n  <td> ScrollBar </td> \n  <td > addAdjustmentListener </td>\n  <td> adjustmentValueChanged </td>\n</tr>\n<tr>\n  <td> Canvas </td> \n  <td rowspan=5 > addMouseListener </td>\n  <td> mousePressed</td>\n</tr>\n<tr><td> Dialog </td> <td> mouseReleased </td> </tr>\n<tr><td> Frame </td> <td> mouseEntered </td> </tr>\n<tr><td> Panel </td> <td> mouseExited </td> </tr>\n<tr><td> Window </td> <td> mouseClicked </td> </tr>\n\n<tr>\n  <td> Canvas </td> \n  <td rowspan=5 > addMouseMotionListener </td>\n  <td> mouseDragged</td>\n</tr>\n<tr> <td> Dialog </td> <td rowspan=4> mouseMoved</td></tr>\n<tr> <td> Frame </td></tr>\n<tr> <td> Panel </td></tr>\n<tr> <td> Window </td></tr>\n\n<tr>\n  <td rowspan=3> Component </td> \n  <td  rowspan=3> addKeyListener </td>\n  <td> keyPressed</td>\n<tr> <td> keyReleased </td></tr>\n<tr> <td> keyTyped </td></tr>\n</tr>\n<tr>\n  <td rowspan=2> Component </td> \n  <td rowspan=2 > addFocusListener </td>\n  <td> focusGained</td>\n<tr> <td> focusLost </td></tr>\n</tr>\n<tr>\n  <td> TextComponent </td> \n  <td > addTextListener </td>\n  <td> textValueChanged</td>\n</tr>\n\n\n\n\n</table>\n\n<h3> Table Use </h3>\nThe  first column names the control.\n<br> The second column tells how to awaken control on\n  a particular event and who to send the message to when\n  the event takes place.\n<br> The third column tells what method(s) needs to implemented\n  by the object which is responded to the message.\n<br> Focus is the component that can accept user input.", "encoding": "ascii"}