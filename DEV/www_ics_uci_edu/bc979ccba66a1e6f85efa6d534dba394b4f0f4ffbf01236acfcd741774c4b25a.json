{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/05.bst-motivation", "content": "Next couple weeks:\nBinary search tree like data structures\n\nToday:\nMotivation and preliminaries\n\nBinary search in sorted list\n    test existence of search key, but better to use hash table\n    nearest neighbor classification -- can't be done by hash table\n\nWhat about nearest neighbor classification with dynamic data?\n    adding into array and preserving sorted order not possible quickly\n    need more complex data structures\n\n\nSecond example: plane sweep\nTest whether any two line segments in input intersect, if so find a crossing\n    (plane sweep approach, 33.2)\n    - single crossing:\n\tsort list of endpoints by x-coordinates\n\tinitialize sorted list of segments in order by y-coord of sweep point\n\tfor each endpoint in input:\n\t\tif it's a left endpoint:\n\t\t\tinsert in sorted list\n\t\t\ttest for crossing with pred and with succ\n\t\telse if it's a right endpoint:\n\t\t\tremove from sorted list\n\t\t\ttest for pred-succ crossing\n\n    - list all crossings, y-coords of sweep points change order @ cross\n        make priority queue of event points, ordered by x-coord\n\tinitialize queue with all segment endpoints\n\tfor each priority queue event:\n\t\tif it's a left endpoint:\n\t\t\tinsert in sorted list\n\t\t\tadd potential crossing event w/pred and succ\n\t\t\tremove potential pred-succ crossing event\n\t\telse if it's a right endpoint:\n\t\t\tremove from sorted list\n\t\t\tremove potential crossings w/pred and succ\n\t\t\tadd potential pred-succ crossing\n\t\telse if it's a crossing event:\n\t\t\treport it\n\t\t\tswap order in event queue\n\t\t\tremove two and add two potential crossings\n\nData structures:\n    (1) event queue: priority queues from last time\n    (2) y-ordered crossing points: data structure w/ins,del,succ,pred\n\n\nBasic binary search tree structure\n    representation: item in each node; left and right children (no parents)\n\t(will later see trees with additional info per node)\n\n    search for largest item <= x:\n\tdef search(T,x):\n\t\tif not T:\n\t\t\treturn None\n\t\telif T.item > x:\n\t\t\treturn search(T.left, x)\n\t\telif T.item < x and T.right:\n\t\t\treturn search(T.right, x)\n\t\telse:\n\t\t\treturn T\n\n    similar search for predecessor, successor, etc.\n\n    insert x:\n\tsearch for largest item <= x\n\tif not found exactly, result has no right child, add new one there\n\n    delete:\n\tfind parent\n\tcases:\n\t\t0 children - remove\n\t\t1 child - splice out\n\t\t2 children - find successor (has no left), splice, replace\n\n\nAnalysis of random search trees\n\tmodel: insert according to random permutation\n\n\tE[height(x)] = Sum_y P(y is anc.) <= 2 H_n = O(log n)\n\n\tEquivalence to random quicksort\n\n\tBook, 12.4:\n\tE[height(T)] <= 3 log_2(n) + o(log n)\n\n\tTheorem (Lynch, 1965):\n\tE[# external nodes at level k] = 2^k/n! [n k]\n\t(Stirling number [n+1 k] = n[n k] + [n k-1]; [0 0]=1 [0 k]=0 [n 0]=0)\n\n\t1 0 0 0\n\t0 1 0 0\n\t0 1 1 0\n\t0 2 3 1\n\t0 6 11 6 1\n\t0 24 50 35 10 1\n\n\t=> bounds on length of unsuccessful search;\n\t   high probability bounds on max height of tree\n\t(both O(log n))\n", "encoding": "ascii"}