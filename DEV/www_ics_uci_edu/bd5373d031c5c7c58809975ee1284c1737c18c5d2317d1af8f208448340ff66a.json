{"url": "https://www.ics.uci.edu/~eppstein/junkyard/random-n-gon.html", "content": "<HR><PRE>\n<B>From:</B>           <A HREF=\"mailto:lambert@cse.unsw.edu.au\">lambert@silver.cs.umanitoba.ca</A> (Tim Lambert)\n<B>Newsgroups:</B>     sci.math\n<B>Subject:</B>        Random convex n-gon\n<B>Summary:</B>        I'll know one when I see one\n<B>Date:</B>           1 Jul 91 19:01:49 GMT\n<B>Organization:</B>   Department of Computer Science, University of Manitoba\n</PRE><HR><PRE>\nIn article &lt;LAMBERT.91Jun24202803@silver.cs.umanitoba.ca&gt; I wrote:\n&gt;Can you define a random convex polygon with n vertices?  Assume if you\n&gt;like a distribution from which you are to choose the vertices.  (For\n&gt;example, uniform on unit square.)  Obviously, there is more than one\n&gt;way to define this.  Which definition seems most intuitive?\n\nHere is the promised summary of responses.  My comments are in\nbrackets [like this].  I reveal my computer science bias by\nconsidering the time taken by an algorithm to generate a \"randon n-gon\".\n\nMany thanks to everyone who replied.\n</PRE><HR><PRE>\n<B>From:</B>           Dan Hoey &lt;<A HREF=\"mailto:hoey@etl.army.mil\">hoey@etl.army.mil</A>&gt;\n</PRE><HR><PRE>\nYou might want to choose vertices from your distribution until the\nconvex hull is an N-gon.  I think for nice distributions this\nterminates with probability one.\n\n[ For N points chosen uniformly from inside a circle the expected\n[ number of vertices on the convex hull is O(N^(1/3)) [1].  So we would\n[ have to pick O(N^3) points to generate a convex N-gon.  This gives an\n[ obvious O(N^4) algorithm.  If I generate points outside the convex\n[ hull of the points generated so far,  I find that I only have to\n[ generate about 3N points to get an N-gon, so this seems to be an O(N)\n[ algorithm. ]\n\nThe problem is that the distribution of vertices that results is not\nthe original one--the points near the center are less likely.\n\n[ Yes.  If I take a large number of points from inside a circle then\n[ their convex hull will closely approximate the circle.  This does not\n[ seem very random. ]\n\nI don't know if there's any way to pick them so that you end up with\na desired distribution.\n</PRE><HR><PRE>\n<B>From:</B>           <A HREF=\"mailto:ccrwest!ed@UCSD.EDU\">ccrwest!ed@UCSD.EDU</A> (Ed Bender)\n</PRE><HR><PRE>\nThree thoughts come to mind, none very good in terms of randomness.\n\n1. Continue choosing points until their convex hull is an n-gon.\n\n2. Choose n rays from the origin so that every open half plane contains a\n   ray---easy to do by choosing sets of n at random until a set is okay.\n   Proceeding around the rays in a clockwise manner choose a point on each\n   ray to be the vertex of a convex n-gon that contains the origin.  The\n   first two points are arbitrary and then the previous two points (and also\n   first two when choosing the nth) may put a simple upper bound on how far out\n   the next point can be.\n\n[ You also need a lower bound on how far out the next point is, to\n[ ensure that it is outside the convex hull of the points selected so\n[ far.  Later points have far less freedom than earlier points.  This\n[ doesn't seem very random. ]\n\n3. Choose n angles at random summing to 360 degrees.  These are the angles\n   to rotate through when moving from one side to the next.  Choose the first\n   two n-2 side lengths at random.  The lengths of the two remaining sides\n   are determined and, if you are lucky, they will not be negative.  If a\n   negative side arises, try again.  I have no idea what the probability of\n   failure is.\n</PRE><HR><PRE>\n<B>From:</B>           Marshall Bern &lt;<A HREF=\"mailto:bern@parc.xerox.com\">bern@parc.xerox.com</A>&gt;\n</PRE><HR><PRE>\nHere's a sketch of an idea due to Thurston (who told David Dobkin\nwho told me):  Start with a regular n-gon.  Pick a random velocity\n(direction uniform on [0, 2 pi ], magnitude uniform on [0,1]) for\neach vertex.  Now let each vertex move at its velocity.  When three\nconsecutive vertices, a, b, c, become co-linear, you \"bounce\" b\noff the segment ac.  To do this, you could consider the frame of reference\nin which b is the origin and segment ac is fixed and horizontal, and\nthen change the velocity of b to its reflection across the y-axis.\n\n[ Cool idea.  It would even make a pretty display on your screen if you\n[ animated it.  You do the bouncing in a non-inertial frame of\n[ reference, so the total energy of the system isn't fixed, but I guess\n[ that doesn't matter.  Implement with time O(log n) per bounce.\n[ Presumably you need O(n) bounces to get things random enough, so\n[ O(n log n).  A cheaper way to get a similar effect would be to\n[ randomly pick vertices and move them so as not to destroy the\n[ convexity. (If ABCDE are five consecutive vertices then we can move\n[ C anywhere inside the triangle BDI where I is the intersection of\n[ the rays AB and ED.)\n\nThurston told Dobkin that in the limit, \"every convex n-gon is\nequally likely\".  I'm not sure what the proper mathematical statement\nwould be.  You'd have to define a measure on the space of convex polygons.\n\n[ It doesn't converge to a limit.  Maybe you should do some simulating\n[ annealing kind of stuff and gradually cool the system down so that\n[ the vertices eventually grind to a halt.]\n</PRE><HR><PRE>\n<B>From:</B>           <A HREF=\"mailto:David.Handscomb@na.oxford.ac.uk\">David.Handscomb@na.oxford.ac.uk</A>\n</PRE><HR><PRE>\nThe definition that springs first to my mind is described by the\nfollowing algorithm:\n\nrepeat:\nchoose n points from given distribution;\nif any one lies within triangle formed by any other three then go to repeat\nelse accept last n points chosen;\n\n[ Or in other words \"Pick n points.  Reject if their convex hull does\n[ not have n points.\"\n\nThis is equally valid in d&gt;2 dimensions, replacing \"triangle\" by\n\"simplex\" and \"three\" by \"d+1\".\n\nIt is a nice problem to determine how many repetitions are required on\naverage to generate one polygon.  For n=4, d=2, with points chosen from\na uniform distribution on a square, the number appears experimentally to\nbe around 1.44 - could possibly be worked out exactly.\n\n[ Sylvester's problem [2] is \"Find the probability that four random\n[ points from a convex set form a convex quadrilateral.\"  For a\n[ parallelogram the answer is 25/36, so the expected number of\n[ repetitions is _exactly_ 1.44 -- your experiment was spot on!\n\nThe number must increase as n increases, but at what (asymptotic) rate?\n\n[ Good question.  Anyone know the answer? ]\n\nWhen n is large, is there a more efficient way of generating\nconvex polygons from the same distribution?\n\n[ I'm glad you asked.  First pick three points.  Now if the the next\n[ point is inside the triangle or the wedges opposite its corners we'll\n[ have to reject and start again.  Let p = probability of rejection.\n[ Rather than risk rejection, we'll pick a point outside the rejection\n[ region and multiply the probability of the polygon by (1-p).\n[ Continue until you get an n-gon and a probability of getting there.\n[ Time is O(n).  We can use the probability to weight whatever\n[ measurements we make an the n-gon.\n</PRE><HR><PRE>\n<B>From:</B>           \"William F. Eddy\" &lt;<A HREF=\"mailto:bill+@andrew.cmu.edu\">bill+@andrew.cmu.edu</A>&gt;\n</PRE><HR><PRE>\nPerhaps the easiest way to generate random convex polygons is to\ngenerate random samples of points and just take the convex hull.  There\nhas been a fair amount of work over the last twenty five years or so\nworking out properties of the resulting convex hulls under various\nsampling assumptions.   This method does not allow you to prespecify\nthe number of vertices (except for various particular sampling\ndistributions) so you have to reject all those not having the specified\nnumber.\n\n[ i.e. pick a random integer k between 1 and infinity.  Reject if the\n[ convex hull of k points does not form an n-gon.  This seems to be\n[ closely related to \"keep taking points until the convex hull is an\n[ n-gon\".  Maybe you should keep going to see if you ever get an n-gon\n[ again, and randomly choose amongst the n-gons you get.\n\nI can provide additional details and references if you wish.\n</PRE><HR><PRE>\n<B>From:</B>           <A HREF=\"mailto:mic@theory.lcs.mit.edu\">mic@theory.lcs.mit.edu</A> (Michelangelo Grigni)\n</PRE><HR><PRE>\nHere is an idea, using random sides rather than points.\n\nFirst a simple version, for a random centrally symmetric 2n-gon:\n\n1) Choose n \"random\" vectors v1, v2, ... vn,\n   by your favorite random point distribution (say normal).\n2) Change signs of the vectors if necessary so that they all\n   point in the positive x direction.\n3) Sort the vectors by increasing slope.\n4) Now start at some arbitrary starting point (say the origin), and\n   make the following relative moves, tracing out a 2n-sided polygon:\n            +v1, +v2, +v3, ..., +vn, -v1, -v2, ..., -vn.   \n   This returns you to where you started.\n\n[ You can implement this in time O(n) (even though the sort would\n[ take O(n log n) ]\n\nThis actually has a few nice properties.  Let H be the set of 2^n\npoints obtained by summing subsets of the v's.  Then the polygon we\ntraced out is the convex hull of H, and furthermore all step 2 did was\ntranslate H, so we see the distribution of polygon shapes is\nrotationally symmetric, assuming our original point distribution was.\n\nNow for a random convex n-gon, you would need the same basic idea but\nwith the constraint v1+v2+...+vn=0.  In general I don't know how you\nmight do this.  One idea: to get n random real variables summing to 0,\nso that each has the same normal distribution, first take n\nindependent normal variables, then orthogonally project them to the\nconstraint plane.\n\n[ Yes.  And if you want them from the uniform distribution on the n-1\n[ dimensional hypersphere formed by the intersection of the constraint\n[ plane and the n-dim unit ball, you can pick a point from the\n[ (n-1)-dim unit ball and rotate it onto the constraint plane.  This\n[ is the simplest to implement.  Time is O(n log n) (because you have\n[ to sort the vectors). ]\n</PRE><HR><PRE>\n<B>From:</B>           \"Matti Siivola (KTTL) puh. 4346609, 8744283\" &lt;<A HREF=\"mailto:MSIIVOLA@cc.Helsinki.FI\">MSIIVOLA@cc.Helsinki.FI</A>&gt;\n</PRE><HR><PRE>\nMy idea would be to first create \"star-shaped\" n-polygon by choosing n\nangles from 0 to 2*pi and n distances from origin.  Then I would swap\nany two adjanced edges which common end is \"inside\" to \"outside\".\nRepeating this will provide a convex polygon.\n\n[ Hmm.  You would have to do the swap so that the angle of the moved\n[ vertex did not change, so that it is still star-shaped.  I'm not\n[ sure how quickly this would converge.  It seems to me you might need\n[ O(n^2) swaps.\n\nAnother way is to start with a random triangle (it is always convex).\nThen cut away a randomly chosen corner at random points on the edges.\nThis gives 4-gon.  Repeat until a n-gon is obtained.\n\n[ This is dual to the method I described that selects points subject\n[ to the constaint that the convex hull of n points be an n-gon.\n</PRE><HR><PRE>\n<B>From:</B>           <A HREF=\"mailto:gutest5%blekul11.bitnet@utcs.utoronto.ca\">gutest5%blekul11.bitnet@utcs.utoronto.ca</A> (Lieven)\n</PRE><HR><PRE>\nHow about smallest convex set that contains all n points.\nI seem to remember that Rudin defines a general triangle in\na Banach space in such a matter.\n\n[ Lieven means \"Pick n points.  Reject if their convex hull does not\n[ have n points.\"\n</PRE><HR><PRE>\n<B>From:</B>           Anil Joshi &lt;<A HREF=\"mailto:joshi@cs.uiuc.edu\">joshi@cs.uiuc.edu</A>&gt;\n</PRE><HR><PRE>\nI too am interested in these definitions. May be a generalization of\nthat would be something like \"Define a n vertex random polytope\nbelonging to R^M\".\n\n--------------------\nReferences\n[1] \"Computational Geometry: An Introduction\" F.P. Preparata M.I. Shamos\n[2] \"Integral geometry and geometric probability\" L.A. Santalo\n</PRE><HR><PRE>\n<B>From:</B>           <A HREF=\"mailto:rsm@math.arizona.edu\">rsm@math.arizona.edu</A> (Robert S. Maier)\n<B>Newsgroups:</B>     sci.math\n<B>Subject:</B>        Re: Random convex n-gon\n<B>Date:</B>           1 Jul 91 23:52:26 GMT\n<B>Organization:</B>   Mathematics Department, University of Arizona\n</PRE><HR><PRE>\nTo probabilists, there is a natural way of defining random convex\npolygons.  A random convex polygon is a polygon selected from a random\ntessellation of the plane.  A random tessellation is most easily\ndefined by randomly drawing lines in the plane, according to a\ntranslation-invariant, isotropic `line process'.\n\nTo explain what I mean by this, consider the 1-dimensional analogue.\nIn 1-d we can `randomly choose points' (i.e. define the standard\nPoisson point process) as follows.  Fix one point at the origin, and\nlet the distance to the next point on either side be an exponential\nrandom variable.  Continue ad infinitum.  (Actually this yields a\nconditioned Poisson process, since the first point is tied down at the\norigin.  With a bit more work, we can define a stationary, i.e.\ntranslation-invariant Poisson process, or more general renewal\nprocesses.)\n\nThese randomly chosen points partition the line into intervals; they\nare `random intervals'.  If we require the left end of a random\ninterval to be the origin, then it will be [0,x], with x exponentially\ndistributed.\n\nThe generalization to 2 dimensions is simple but not obvious.  We need\nto define a `line process', i.e. we need to draw lines randomly, in a\ntranslation-invariant, isotropic way.  It is left as exercise to the\nreader to show that the following construction will suffice.\n\nDistribute points along the x axis, according to the standard Poisson\nprocess.  Draw a line through each point, but choose its orientation\nrandomly.  Denote by theta the angle that it makes with the x axis.\nThen the appropriate probability density is proportional to the square\nof the sine of theta.\n\nIt is not hard to show that if we choose any fixed line in the plane,\nthe intersections of our randomly chosen lines with it will form a\nPoisson point process.  So our line process is a natural 2-D\ngeneralization of the 1-D point process.  (The Poisson process seems\nto be the only renewal process that will work here.)\n\nWe may define a `random convex polygon' as a minimal convex polygon\nformed by the crossing of our random lines.  If we require that one of\nits vertices be the origin, we can use the conditioned Poisson process\nrather than the unconditioned Poisson process.\n\nThis definition of random convex polygon is unusual because it does\nnot fix n, the number of vertices of the polygon.  It is also a bit\ndifficult to implement.  In principle one would have to generate all\nthe random points along the x axis, and their associated lines, in\norder to determine the number of edges of the convex polygons touching\nthe origin.  That is because parts of their boundaries could be formed\nby lines emanating from points on the x-axis arbitrarily far away.\n\nBut this is a very elegant way of defining random convex polygons.\nCan anyone think of a simple way of conditioning on n, i.e. imposing\nthe condition that the generated polygon have only n edges?\n\n-- \nRobert S. Maier   | Internet: <A HREF=\"mailto:rsm@math.arizona.edu\">rsm@math.arizona.edu</A>, <A HREF=\"mailto:rsm@cs.arizona.edu\">rsm@cs.arizona.edu</A>\nDept. of Math.    | UUCP: uunet!arizona!amethyst!rsm\nUniv. of Arizona  | Bitnet: <A HREF=\"mailto:maier@arizrvax\">maier@arizrvax</A>\nTucson, AZ  85721 | FAX: +1 602 621 8322\nU.S.A.            | Voice(POTS): +1 602 621 6893  /  +1 602 621 2617\n</PRE>\n<HR><PRE>\n<B>From:</B>           Jeff Erickson &lt;<A HREF=\"mailto:jeffe@cs.uiuc.edu\">jeffe@CS.Duke.EDU</A>&gt;\n<B>Date:</B>           Fri, 18 Apr 1997 19:35:11 -0400\n<B>Newsgroups:</B>     sci.math.research\n<B>Subject:</B>        Re: random simple polygons (2D)\n</PRE><HR><PRE>\n[Since the original posting brings up some open algorithmic and\nmathematical questions, I've added comp.theory and sci.math.research to\nthe distribution list.]\n\nKenneth Sloan wrote: \n&gt;     0) when I say \"random simple polygon\" - what do you think I mean?\n&gt;        Randomizing the vertices is simple enough - but how about\n&gt;        the order of the vertices?\n\nI would define a \"random simple n-gon\" as the output of one of the\nfollowing random processes.\n\n(a) Generate a sequence p_1, p_2, ... p_n of n points uniformly at\nrandom in the unit square (or whatever domain you want).  Repeat until\nthe \"polygon\" p_1p_2...p_n is simple.  Output the polygon p_1p_2...p_n.\n\n(b) Generate a set {p_1,p_2,...p_n} of n points uniformly at random from\nthe unit square (or whatever domain you want).  Generate the list of all\nsimple polygons with vertices p_1,p_2,...,p_n in some order.  Output a\nrandomly chosen polygon from this list.\n\nI would be VERY surprised if these two processes generated the same\nprobability distribution.  I'll let somebody else decide which\ndistribution is the \"right\" one.\n\nObviously, both of these procedures will take a LONG time.  It is an\nopen question whether there is a polynomial-time algorithm that\ngenerates a random polygon with the same distribution as either of the\ntwo processes above, or to uniformly generate a simple polygon with a\ngiven set of vertices, or to determine how many simple polygons there\nare with a given vertex set.  Even the following question is open: What\nis the largest number of simple polygons that use the same set of n\nvertices, as a function of n?  (If you replace \"largest\" with\n\"smallest\", the answer is 1; consider n points on a circle.)\n\nThere are polynomial-time algorithms for other similar random polygon\nproblems: generating random convex polygons [P. Valtr, The probability\nthat n random points are in convex position, Disc. Comput. Geom.\n13:637-643, 1995], random monotone polygons using a given vertex set [C.\nZhu, G. Sundharam, J. Snoeyink, and J.S.B. Mitchell, Generating random\npolygons with given vertices, Comput. Geom. Theory Appl. 6:277-290,\n1996], and random star-shaped polygons using a given vertex set [T. Auer\nand M. Held, Heuristics for the generation of random polygons, In Proc.\n8th Canad. Conf. Comput. Geom., pp.38-44, 1996].\n\nThomas Auer and Martin Held have a piece of software that implements\nseveral heuristics for generating random polygons:\n\t<A HREF=\"http://www.cosy.sbg.ac.at/~held/projects/rpg/rpg.html\">http://www.cosy.sbg.ac.at/~held/projects/rpg/rpg.html</A>\nYou can download the full version of their CCCG paper, which explains\nthe heuristics they use, from the same Web page.\n\nHeidi Burgiel and Michelle Raymond have written a Java applet that\ncounts the number of simple polygons with a given vertex set:\n\t<A HREF=\"http://www.geom.umn.edu/~burgiel/Java/Ngons/ngons.html\">http://www.geom.umn.edu/~burgiel/Java/Ngons/ngons.html</A>\nThe source code isn't available, but based on the speed of the applet, I\nsuspect it essentially tries all possible permutations and looks for\nintersections.\n\n&gt; An alternate approach is to generate the random vertices, and then\n&gt; *construct* a simple polygon using those vertices.  The problem is that\n&gt; the construction method is likely to bias the type of polygon generated.\n&gt; That is, some of the polygons generated by the specification above may\n&gt; show up much, much less frequently, and others will be over-represented\n&gt; in the sample.\n\nYup.  This is discussed in the papers by Auer+Held and by Zhu et al. \nFor example, Zhu et al. consider a Markov chain heuristic that starts\nwith an arbitrary simple polygon and performs random \"2OPT moves\" --\ndelete a pair of edges and reconnect the two resulting pieces the only\nother possible way, but backtrack if you get something nonsimple.  They\nshow that for a certain set of 6 points (the vertices of two nested\ntriangles), some polygons are more likely than others in the limit.\n\n&gt; As an extreme example, one might start with the convex\n&gt; hull, and push in the polygon until all vertices are visible.  This\n&gt; produces simple polygons - but probably will not produce very\n&gt; complicated ones.  For example, you won't get any spirals.\n\nI suppose it depends on what you mean by \"push in the polygon\".  If a\n\"pushing step\" consists of deleting a random edge of the polygon and\nconnecting its endpoints to a random point on the \"inside\" of the\ndeleted edge, you can get spirals.\n \n&gt;      1) suppose I claim to be producing \"random simple polygons\" - how\n&gt;         would you test my claim?  That is - what are good measures,\n&gt;         and what are the right values, which characterize\n&gt;         \"random simple polygons\"\n&gt; \n&gt; Possibilities include the distributions of internal angles, lengths of\n&gt; segments, lengths of left- and right-turning \"runs\", etc.\n\nWell...the only test that would really satisfy me would be to examine\nyour algorithm and prove it.  \n\nYou could certainly define distributions on random polygons based on the\nmeasures you suggest.  For example: uniformly generate a set of n real\nnumbers in the interval (-pi,pi) whose sum is 2pi, and then (somehow)\ngenerate a simple poylgon with those turning angles.  Or: uniformly\ngenerate a set of n numbers between 0 and 1, and then (somehow) generate\na simple polygon with those edge lengths.  Of course, these are\ndifferent distributions than the \"uniform\" distributions described\nearlier.\n\nThis brings up all sort of icky complexity-theoretic issues about\ndistinguishing pseudorandomness from randomness.\n\n&gt; I have what I think is a nice method of producing \"random simple\n&gt; polygons\" which runs fast enough to be useful, and has no *obvious* (to\n&gt; me) bias - but I don't really believe there isn't any bias; I'm  just\n&gt; afraid that I'm not clever enough to discover the bias that is there.\n\nSo what is it?!!\n \n&gt; But - just to stir the pot, I'll also ask:\n&gt; \n&gt;     2) give an efficient algorithm for generating a set of\n&gt;        random simple polygons which passes your test of \"randomness\"\n&gt;        above.\n\nThis is wide open.\n\n&gt;     3) suppose we generate N points uniformly distributed over the unit\n&gt;        disk (square?) and connect them to form a polygon.  What is the\n&gt;        expected number of intersections?\n\nIt suffices to compute the probability that the segments pq and rs\nintersect, where p,q,r,s are generated uniformly in the unit square, and\nthen multiply by n(n-3)/2, the number of nonadjacent pairs of edges.\n\nThe probability that p,q,r,s are in convex position is 25/36.  [For a\nproof of this fact, see H. Solomon, Geometric Probability, SIAM,\nPhiladeplhia, 1987.]  If p,q,r,s are in convex position, then pq\nintersects rs with probability 2/3.  If the points are not in convex\nposition, ie, one point is inside the convex hull of the other three,\nthen the two segments cannot intersect.  So the probability of\nintersection is exactly 25/36 * 2/3 = 25/54.\n\nSo the expected number of intersections is 25n(n-3)/108.\n\n--\nJeff Erickson                         Center for Geometric Computing\n<A HREF=\"mailto:jeffe@cs.uiuc.edu\">jeffe@cs.duke.edu</A>\t\t\t             Duke University\n<A HREF=\"http://sal.cs.uiuc.edu/~jeffe\">http://sal.cs.uiuc.edu/~jeffe</A>\n</PRE>\n", "encoding": "ascii"}