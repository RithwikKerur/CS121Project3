{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/class.txt", "content": "\t\t\t\tPython Classes\r\n\r\n\r\nThis lecture reviews basic material that you should know about defining and\r\nusing classes, although it also presents some new (hopefully easy to understand)\r\nmaterial that you may have not seen. Primarily this lecture discusses how to\r\nuse the namespaces in class objects and the namespaces of their instance objects\r\nto store data as well as functions/methods.\r\n\r\nMost data is stored in the namespace of an object constructed from a class.\r\nMost methods are stored in the namespace of class the object is constructed\r\nfrom (and accessed via the Fundamental Equation of Object Oriented programming:\r\nreview that from the first week's lectures). \r\n\r\nFundamentally this lecture is about two things.\r\n\r\n  1) The name spaces for classes and instances (objects constructed from \r\n     classes): how they are initialized, stored, and accessed/updated.\r\n\r\n  2) Accessing attributes (both for methods and data) in instance and classes:\r\n     the 2-step algorithm (which we will extend/generalize when we cover\r\n     inheritance among classes)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDefining Classes:\r\n\r\nWhen we define a class in a Python, we are binding the class name to an object\r\nrepresenting the entire class. That class object contains mostly method\r\ndefinitions, but it can also contain data that is common to all the objects\r\nconstructed from the class (common to examine/common to update). We call the\r\nclass object to create a new object that is an instance of the class: Python\r\nconstructs an empty instance object and then calls the __init__ method defined\r\nin the class, (passing the new/empty instance object to its self parameter) to\r\ninitialize the state of the instance object. Recall that all names in Python\r\nrefer/are-bound to objects; so defining\r\n\r\n   class C:\r\n       ...\r\n\r\ncreates the name C and binds it to an object representing the class C. We must\r\nclearly be able to talk about both the class object, and (instance) objects\r\nconstructed from class objects.\r\n\r\nWhat names are attributes defined in a class object's namespace? I'm not\r\ntalking about the instance objects that will be constructed from the class C,\r\nbut the names in the namespace of the class object itself. Mostly, a class\r\ndefines names that are bound to its methods (e.g., __init__), but later in this\r\nlecture we will also discuss names representing other class attributes: data.\r\n\r\nWhen we want to construct an object that is an instance of a class, we refer to\r\na class object (typically by the name bound to it when it is defined) followed\r\nby () and possibly arguments in these parentheses. Writing o = C(arguments)\r\ndefines the name o to refer/bind to an instance object created from class C.\r\n\r\nPython does three things when constructing new instance objects:\r\n\r\n(1) It calls a special function that creates an object that is a new instance of\r\n    the class. Note that this object automatically has an dictionary associated\r\n    with it, with the name __dict__, and that dictionary starts empty.\r\n\r\n(2) It calls the __init__ method for the class, passing the empty object created\r\n    in (1) to the first parameter of __init__ (by convention, called self), and\r\n    following this with all the other argument values in the parentheses used\r\n    in the call to initialize the states of attrributes in this instance.\r\n    Typically __init__ assigns values to the self/instance variables, which\r\n    stores the name/binding in __dict__ for the self object. It often checks\r\n    arguments for validity as well, raising an exception if the object cannot\r\n    be correctly constructed.\r\n\r\n(3) A reference to the object that was created in (1) and initialized in (2) is\r\n    returned as the result of constructing the object: most likely this\r\n    reference will be bound to some name: e.g., o = C(...) which means o refers\r\n    to a newly constructed/initialized object, constructed from class C (again,\r\n    the new object is called an instance of class C).\r\n\r\nSo if we call o = C(1,2) Python calls\r\n  C.__init__(reference to a new object with empty __dict__, 1, 2)\r\nand binds o to refer to the newly constructed object (from class C) somehow\r\ninitialized (see the body of __init__) by the arguments 1 and 2.\r\n\r\nNote that we can define other names that can bind to/share the same class\r\nobject. For example:\r\n\r\nclass C:\r\n    def __init__(self, p1):\r\n        print('instance of C object initialized')\r\n        self.a = 'starting' # initialize an instance/attribute name\r\n        self.b = p1         # initialize an instance/attribute name\r\n\r\nD = C    # Names C and D refer to (share) the same class object\r\nx = C(1) # Use C to construct a first instance of a class C object (direct)\r\ny = D(2) # Use D to construct another instance of a class C object (via sharing)\r\n\r\nprint(C,D,x,y)\r\nprint(type(x), type(y), type(C), type(type(x)))\r\n\r\nRunning this script produces the following: the first two lines from calling\r\n__init__ twice, the next two from calling the two print statements above\r\n\r\n  instance of C object initialized\r\n  instance of C object initialized\r\n  <class '__main__.C'> <class '__main__.C'> <__main__.C object at 0x027B0E10> <__main__.C object at 0x02889C50>\r\n  <class '__main__.C'> <class '__main__.C'> <class 'type'> <class 'type'>\r\n\r\nThe prefix '__main__' appears in front of '.C' because I executed the code\r\nabove in a script (as the main module Python is executing).  That is where the\r\nclass C is defined.\r\n\r\nFinally, if we print(x.a, x.b) it prints: starting 1. if we print (y.a, y.b) it\r\nprints: starting 2. The attribute a is always bound to \"starting\"; the attribute\r\nb is bound to the value of the argument passed to __init__ whenever an object of\r\ntype C is constructed.\r\n\r\nWe can use the type function to determine the type of any object: the class from\r\nwhich it was constructed. The objects  that x and y refer to are instances of\r\nthe class C, defined in the main script. C (and all classes that we define) are\r\ninstances of a special class called 'type'). So in the example above, x is an\r\ninstance of C, and C is an instance of 'type'.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nManipulating an object's namespace (and __init__):\r\n\r\nAll objects have namespaces, which are dictionaries, in which the attribute\r\nnames defined in that object are bound-to/associated-with values. To define an\r\nattribute in the namespace of the object that self is bound to, we write\r\nsomething like:\r\n\r\n  self.name = value\r\n\r\nin the __init__, or any other method in the class, to define an attribute name\r\nin the dictionary of the object self refers to, and bind that name (or update\r\nan exsting binding) to refer to value.\r\n\r\nNow we illustrate a lower-level way to add attribute names to the namespace of\r\nan object. This way is not recommended for now, but it furthers our\r\nunderstanding of objects and their namespaces in Python, and we will find\r\ninteresting/concrete uses for this understanding later in the course. Given\r\nclass C defined above, we can write\r\n\r\no = C(1)                       # defines a/b attributs\r\nprint(o.__dict__)              #1\r\no.x = 1                        # defined x attribute\r\no.y = 'two'                    # defined y attribute\r\no.__dict__['z'] = 3            # defined z attribute by __dict__ directly\r\nprint(o.__dict__)              #2\r\nprint(o.a, o.b, o.x, o.y, o.z) #3\r\n\r\nRunning this script produces\r\n\r\n  instance of C object initialized                      # from __init__\r\n  {'a': 'starting', 'b': 1}\t\t\t\t#1\r\n  {'a': 'starting', 'b': 1, 'x': 1, 'y': 'two', 'z': 3} #2\r\n  starting 1 1 two 3\t    \t    \t \t     \t#3\r\n\r\nSo, we have used two different forms for adding three attribute names to the\r\nnamespace/dictionary for the object that o refers to (which initially stores\r\nthe name a initialized by self.a = 'starting' and b initialized by self.b = p1).\r\nAdding names updates the object's __dict__.  Writing object.name = value is\r\nequivalent to writing object.__dict__['name'] = value: note that each __dict__'s\r\nkey is a string representing the attribute name.\r\n\r\nThe object o has a __dict__ attribute that stores its namespace's bindings.\r\nEach identifier/name for which we define an attribute in the object appears as a\r\nstring key in __dict__.\r\n\r\nMostly, we don't initialize the namespace of an object this way: outside of\r\n__init__; instead we use the automatically-called __init__ method and its self\r\nparameter to do the initialization. But really, the same thing is happening in\r\n__init__ below as was shown above.\r\n\r\nclass C:\r\n    def __init__(self, init_x, init_y):\r\n        print('instance of C object initialized')\r\n        self.x = init_x\t\t# value depends on the argument matching init_x\r\n        self.y = init_y\t\t# value depends on the argument matching init_y\r\n        self.z = 3\t\t# always the same object: 3\r\n\r\nc = C(1,'two')\r\nprint(c.__dict__)\r\n\r\nRunning this script produces the same results.\r\n\r\n  instance of C object initialized\r\n  {'z': 3, 'y': 'two', 'x': 1}\r\n\r\nThe purpose of the __init__ method is to create all the attribute names needed\r\nby the object's methods and initialize them appropriately. Typically, once\r\n__init__ is called, no new attribute names are added to the object's namespace\r\n(although Python allows additions, as illustrated in the prior section: e.g.,\r\no.x = 1) and some useful examples are illustrated later in this lecture as\r\nwell). Every object constructed is likely to need exactly the same attribute\r\nnames: all these attribute names are used in the methods defined in the class\r\n-methods that process instance objects of the class. The __init__ method, which\r\nis automatically called by Python when an object is constructed, is a\r\nconvenient place to localize the creation and initialization of all these\r\nattribute names.\r\n\r\nSo, for every assignment statement\r\n\r\n  self.name = value\r\n\r\nPython puts an entry into the self object's namespace (self.__dict_) with the\r\nkey 'name' (keys are strings) associated with value. We can (and mostly) do\r\nthis in the __init__ method or after the object is constructed: both ways are\r\nshown above. When self.name appears in an expression (e.g., a = self.name),\r\nPython substitutes the expression self.__dict__['name'] for the right hand side\r\nof the =, to retrieve the value of that name from the self object's\r\nnamespace/dictionary. Note how name in self.name becomes 'name' in \r\nself.__dict__['name'].\r\n\r\nIf we try to access a non-existing attribute name (o.mumble, for objects\r\nconstructed from the class C above, which is translated into\r\no.__dict__['mumble']), Python raises an exception. Attempting to access o.mumble\r\nprints the exception as follows\r\n\r\n  AttributeError: 'C' object has no attribute 'mumble'\r\n\r\nSo, it DOES NOT raise a key error in the __dict__ but raises an AttributeError\r\ninstead. So if we accidentally try to access a non-existing attribute, this is\r\nhow Python detects and reports the error.\r\n\r\nNote that some names defined in __init__ (z above) always receive the SAME\r\nINITIALIZATION, so we don't need to define a parameter in __init__ to\r\ninitialize them. But often names need to be initialized to different values\r\nwhen different objects are constructed, so typically we add just enough\r\nparameters to the __init__  method to allow us to specify how those names with\r\ndifferent values should be initialized.\r\n\r\n----------Assert\r\nInterlude: assert in initialization\r\n\r\nSometimes __init__ will contain code that ensures that a parameter is matched\r\nto an argument that stores a legal/reasonable value for it; if not, Python will\r\nraise an exception to indicate that the object being constructed cannot be\r\nproperly initialized. Sometimes it raises an exception explicitly, using an if\r\nstatement that tests for an illegal value. Sometimes it uses an assert\r\nstatement for this purpose. Remember that the form of assert is:\r\n\r\n  assert boolean-test, string\r\n\r\nwhich is equivalent to the slightly more verbose\r\n\r\n  if not boolean-test:\r\n      raise AssertionError(string)\r\n\r\nI suggest that the string argument to AssertionError should always contain 4\r\nparts:\r\n\r\n  (1) The name of the class (if the problem occurs in the method of a class) or\r\n      the name of the module (if the problem occurs in a function in a module)\r\n\r\n  (2) The name of the method/function that detects the problem (here __init__)\r\n\r\n  (3) A short description of the problem...\r\n\r\n  (4) ...including the value(s) of the argument(s) causing the problem\r\n\r\nFor example, if class C included an  __init__ method that required x's argument\r\nto be a positive integer, we could write __init__ as follows. We typically check\r\nall the arguments FIRST in this method, before binding any self/instance names.\r\n\r\n  def __init__(self,x):\r\n      assert type(x) is int and x > 0, 'C.__init__: x('+str(x)+') must be an int and positive'\r\n      ...\r\n\r\nor\r\n\r\n  def __init__(self,x):\r\n      assert type(x) is int and x > 0, 'C.__init__: x({v}) must be an int and positive'.format(v=x)\r\n      ...\r\n\r\nor\r\n\r\n  def __init__(self,x):\r\n      assert type(x) is int and x > 0, f'C.__init__: x({x}) must be an int and positive'\r\n      ...\r\n\r\nWe construct the information strings by concatenation, the format function, or\r\nby using f-strings. Note that for concatenation we must explicitly convert\r\nvalues to strings; but the format function (like the print function) and\r\nf-strings  automatically converts all its arguments to strings. Some languages\r\ndefine + to also automatically convert its arguments to strings, but Python\r\ndoes not.\r\n\r\nIf so, calling C(-1) would result in the error message\r\n\r\n   C.__init__: x(-1) must be an int and positive\r\n\r\nand calling C('abc') would result in the error message\r\n\r\n   C.__init__: x(abc) must be an int and positive\r\n\r\nSuch a message provides useful information to whomever is writing/debugging a\r\nprogram using this class. In a well-written program, someone just using the\r\nprogram (possible not a programmer) should not have to read/interpret such a\r\nmessage.\r\n\r\nQuestion: if we wrote the assert as just x > 0, what exception would be raised\r\nby calling C('abc') and why? Why is the given assertion \"better\", even though\r\nit takes more work to check?\r\n\r\nWe could be even more descriptive and write two different error messages, one\r\nfor each part of the assertion.\r\n  def __init__(self,x):\r\n      assert type(x) is int, 'C.__init__: x({v}) must be an int'.format(v=x)\r\n      assert x > 0, 'C.__init__: int x({v}) must be positive'.format(v=x)\r\n\r\nNote that int refers to the int class (NOT an instance of an int class: e.g.,\r\nnot a number), so writing \"type(x) is int\" is checking whether the type of the\r\nobject x refers to is the same as the object int refers to: meaning x is bound\r\nto an object that is constructed from the int class.\r\n\r\n-----More truth\r\nMore truth/details about assert:\r\n\r\nIn fact, assert boolean-test, string is equivalent to\r\n\r\n  if __debug__ and not boolean-test:\r\n      raise AssertionError(string)\r\n\r\nwhere __debug__ is a special keyword defined in the builtins module. Whenever\r\nit is False, the if's entire boolean expression is False (it doesn't even take\r\ntime to evaluate not boolean-test: we will discuss short-circuit operators\r\nsoon), so no exception is raised. Although we cannot directly store into\r\n__debug__, we can run Python code \"optimized\" which sets __debug__ to False. In\r\nthis way we can quickly bypass all the assertion checking, which will speed up\r\nthe code. With this approach asserts are used mostly for internal consistency\r\nchecking, when the code is being developed...\r\n\r\n...but if the running code bypasses such assert statements, and bad things\r\nhappen, then they can go undetected (although that often leads to other bad\r\nthings happening, causing Python to raise exceptions that cannot be turned off).\r\nSo turning off assertions is not recommended unless they were designed to be\r\nturned off, and turning them off also accrues a large speed advantage.\r\n\r\nThis leads to a big discussion of who checks preconditions (the caller of a\r\nfunction/method or the function/method itself) which is a bit beyond the scope\r\nof this class, but I cover in ICS-46 in more detail.\r\n-----End More truth\r\n\r\n----------End assert\r\n\r\nOnce an object is constructed and initialized, typically we use it by calling\r\nit methods (or possibly passing it to another function/method that calls its\r\nmethods). We call an object's method using the syntax object.method(arguments);\r\nrecall the Fundamental Equation of Object-Oriented Programming.\r\n\r\n    o.m(...) is translated into type(o).m(o,...) if m is not an attribute in o\r\n\r\nThis means, call the method m in the class specifying the type of object o, and\r\nthe object o used to call the method is passed to the method as the first\r\nargument (matching the self parameter). For example, the method call\r\n\r\n 'a;b;c'.split(';')\r\n\r\nis translated into the call \r\n\r\n  type('a;b;c').split('a;b;c', ';')\r\n\r\nwhich is equivalent to the call\r\n\r\n  str.split('a;b;c', ';')\r\n\r\nbecause type('a;b;c') is str: that is, they both refer to the same object: the\r\nstr class object.\r\n\r\nTo execute the original method call, ultimately Python calls the split method\r\ndefined in the str class with the arguments 'a;b;c' (matching the self\r\nparameter) and ';' (matching the second parameter). It calls this method by its\r\nfunction name: str.split (split in the str class)\r\n\r\nLikewise, Python translates accesses to data attributes\r\n    o.a      is translated into type(o).a        if a is not an attribute in o\r\n\r\nBefore finishing the discussion of objects and their dictionaries, recall that\r\nC refers to a class object. As an object, it also has a __dict__ that stores its\r\nnamespace. Here is some code that shows what names are defined in the C object.\r\n\r\nfor (k,v) in C.__dict__.items():\r\n    print(k,'->',v)\r\n\r\nAnd here is what it prints.\r\n\r\n__weakref__ -> <attribute '__weakref__' of 'C' objects>\r\n__dict__ -> <attribute '__dict__' of 'C' objects>\r\n__doc__ -> None\r\n__init__ -> <function C.__init__ at 0x03197618>\r\n__qualname__ -> C\r\n__module__ -> __main__\r\n\r\nNote that __init__ is the only function that we defined, and it is there (on\r\nthe 4th line). The other attributes are defined automatically. Because I ran\r\nthis code as a script (the main module), its __module__ variable is bound to\r\n'__main__', which you should know something about, because you should have\r\nwritten (and understood) code like\r\n\r\n  if __name__ == '__main__':\r\n      ...\r\n\r\nIf a module were imported, the __module__ key would be associated with the\r\nfile/module name it was written in. Likewise, the __name__ variable in a module\r\nis bound to '__main__' in a started script, but it is bound to the module's name\r\nin any module that is imported into another module.\r\n\r\n...For example, if module m1.py contained\r\n\r\nprint('in m1',__name__)\r\nif __name__ == '__main__':\r\n    print('m1 is running')\r\n\r\n...then running it would produce\r\n\r\nin m1 __main__\r\nm1 is running\r\n\r\n...If in addition module m2.py contained\r\n\r\nimport m1\r\nprint('in m2',__name__)\r\nif __name__ == '__main__':\r\n    print('m2 is running')\r\n\r\n...then running it would produce\r\n\r\nin m1 m1\r\nin m2 __main__\r\nm2 is running\r\n\r\nNote here the code printing 'm1 is running' is not executed.\r\n\r\nIn fact, if we wrote\r\n\r\nimport m1\r\nprint('in m2',__name__)\r\nif __name__ == '__main__':\r\n    import m1\r\n    print('m2 is running')\r\n\r\n...then running it would still produce\r\n\r\nin m1 m1\r\nin m2 __main__\r\nm2 is running\r\n\r\nbecause if Python has already imported a module, it will not re-execute the\r\nmodule's code when it is imported again: the module and its namespace,\r\ninitialized the first time it is imported, will remain the same on reimportation\r\n(unless the programmer uses importlib.reload(m1), in which case it will\r\nre-execute all the code in m1).\r\n\r\nSo, we can test __name__ to so our code will run the script only when its\r\nmodule is run, not when its module is only imported by another module. The if\r\naccomplishes this behavior. When I test/grade your code, I import its module, so\r\nany code remaining after \"if __name__ == '__main__':\" is not executed, which is\r\nwhy you can leave code there and it won't interfere with program grading.\r\n\r\nIf I had defined C with a docstring it would appear as an attribute of __doc__.\r\nDon't worry about __weakref__,  or __qualname__ or __module__.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDifferent kinds of names/attributes: definition and use\r\n\r\nLet's discuss four different kinds of names in relation to classes. We will\r\ncall all these names attributes (and sometimes variables).\r\n\r\n  (1) local variables: defined and used inside functions/methods to help with\r\n      the computation; parameter variables are typically considered local\r\n      variables too.  These are created during the execution of the\r\n      function/method; they disappear when the function/method terminates\r\n      (unless the function defines and returns a local function object, which\r\n      can be called later and still refer to the local variables that existed\r\n      when the inner function was created).\r\n\r\n  (2) instance attributes/variables of an object: typically defined inside\r\n      __init__ and used inside class methods (we saw other ways to define them\r\n      above too).  These are referred to as self.name. These exist so long as\r\n      the object  exists.\r\n\r\n  (3) class attributes/variables: typically defined in classes (at same level\r\n      as methods, not inside methods) and typically used in methods; we use a\r\n      class attribute to store information COMMON to all objects of a class\r\n      (rather than putting the same instance attribuates in each object\r\n      constructed from the class). Methods are actually class attributes, bound\r\n      to function objects.\r\n\r\n      All class attributes are defined in the class object and they are found by\r\n      the Fundamental Equation of Object-Oriented Programming through instances\r\n      of that class. That is, if class C defines an attribute a (method or\r\n      data) and o refers to an object constructed from class C, then o.a will\r\n      find the value of attribute a in class C, but only if it is not stored\r\n      directly in o (in o's __dict__). For class attributes, that is typically\r\n      what we want.\r\n\r\n      Whenever we write o.a = value, it binds/rebinds attribute a stored in\r\n      object o to value (whether or not attribute a is stored in object o or\r\n      the class of object o).\r\n\r\n      We can write C.a = value to bind/rebind attribute a stored in class C.\r\n\r\n  (4) global variables: typically defined in modules (outside of functions and\r\n      classes) and used inside functions and/or class methods; we typically\r\n      avoid using them (don't use global variables), and when we do use them,\r\n      we do so in a cautious and limited manner.\r\n\r\nYou should know how to use all these kinds of attributes/variables (and their\r\nsemantics). Use local variables and instance attributes as needed (most\r\nfunction/methods have the former, and most classes define the later in __init__\r\nand use them in its methods). Class attributes are sometimes useful to solve\r\ncertain kinds of problems where common information/dat is stored among all the\r\ninstances, by storing them just once in their common class object.\r\n\r\nFor example, if we are storing a Person class,\r\n\r\nclass Person:\r\n    fingers = 10\r\n    def __init__(...):\r\n        ...\r\n        NO setting of self.fingers\r\n\r\nPerson.fingers has the value 10. If we define bob = Person(...) then bob.fingers\r\n(by FEEOP) has the value 10.\r\n\r\n    fingers is not an attribute in the instance object bob refers to, so\r\n    bob.fingers is translated into type(bob).fingers and then Person.fingers,\r\n    which is defined here as 10.\r\n\r\nLet's assume bob had an accident and lost a finger :( We could write\r\n  bob.fingers = 9\r\nand then bob's object's __dict__ would now contain the fingers attribute,\r\nassociated with the value 9. When we specified bob.fingers, Python would find\r\n'fingers' in the __dict__ for bob's object and return the value 9, not ever\r\nneeding to apply the FEOOP, and therefore NOT returning 10.\r\n\r\nIf a surgery reattached bob's finger :) so he was back to having 10, we could\r\nupdate the namespace of bob's object in two different ways to reflect this\r\nchange.\r\n\r\n1)  We could write: bob.fingers = 10\r\nand then bob's object's __dict__ changes its fingers attribute to now be\r\nassociated with the value 10. When we specified bob.fingers, Python would still\r\nfind 'fingers' in the __dict__ for bob's object and return the value 10.\r\n\r\nOR\r\n\r\n2) We could write: del bob.fingers\r\nand then bob's object's __dict__ removes the fingers attribute from its keys.\r\nNow, when we specified bob.fingers, Python would once again not find it in\r\nbob's object's __dict__, so it would again use the FEEOP to translate\r\nbob.fingers into type(bob).fingers and then Person.fingers, which is still\r\ndefined as 10.\r\n\r\nGenerally, using class attributes for common information saves space, but it\r\ntakes a bit longer to find the value associated with the attribute (needs the\r\nsecond FEEOP step). Using object attributes takes extra space, but saves some\r\ntime. This is a classing time-for-space tradeoff in programming.\r\n\r\nGlobal variables are fine to use in scripts, but are often frowned upon when\r\ndeclared in modules that are imported (although they too have their uses there,\r\nbut in more advanced settings). Define/use global variables sparingly. Be able\r\nto justify their use.\r\n\r\nThe following script uses each kind of attribute/variable, appropriately named.\r\nEnsure that you understand how each use of these works. The use of the command\r\nnamed 'global' (see the two lines with #comments) is explained in more detail\r\nbelow.\r\n\r\nglobal_var = 0\r\n\r\nclass C:\r\n\r\n    class_attr = 0\r\n\r\n    def __init__(self,init_ instance_attr):\r\n        self.instance_attr = init_instance_attr\r\n\r\n    def bump(self,name):\r\n        print(name,'bumped')\r\n        #global_var = 100    # comment out this line or the next\r\n        global global_var    # comment out this line or the previous \r\n        global_var += 1 \r\n        C.class_attr += 1    # self.class_attr by FEOOP is C.class_attr too\r\n        self.instance_attr += 1\r\n\r\n    def report(self, attr_name):\r\n        print('instance referred to by', attr_name,\r\n              ': global_var =', global_var,\r\n              '/class_attr =',  self.class_attr,  # could write as C._class_attr\r\n              '/instance_attr=', self.instance_attr)\r\n\r\no=C(10)\r\no.report('o')\r\no.bump('o')\r\no.report('o')\r\nprint()\r\n\r\nprints\r\n  instance referred to by o : global_var = 0 /class_attr = 0 /instance_attr= 10\r\n  o bumped\r\n  instance referred to by o : global_var = 1 /class_attr = 1 /instance_attr= 11\r\n\r\nprint('x = o')\r\nx = o\r\nx.bump('x')\r\no.report('o')\r\nx.report('x')\r\nprint()\r\n\r\nprints\r\n  x = o\r\n  x bumped\r\n  instance referred to by o : global_var = 2 /class_attr = 2 /instance_attr= 12\r\n  instance referred to by x : global_var = 2 /class_attr = 2 /instance_attr= 12\r\n\r\nprint('x = C(20)')\r\nx = C(20)\r\nx.bump('x')\r\nx.report('x')\r\nprint()\r\n\r\nprints\r\n  x = C(20)\r\n  x bumped\r\n  instance referred to by x : global_var = 3 /class_attr = 3 /instance_attr= 21\r\n\r\nC.report(o,'o')       # same as o.report('o') by the Fundamental Equation of OOP\r\ntype(o).report(o,'o') # ditto: the meaning of the Fundamental Equation of OOP\r\nprint()\r\n\r\nprints\r\n  instance referred to by o : global_var = 3 /class_attr = 3 /instance_attr= 12\r\n  instance referred to by o : global_var = 3 /class_attr = 3 /instance_attr= 12\r\n\r\n\r\nprint(C.class_attr, o.class_attr)  # discussed below\r\nprint(o.instance_attr)\r\n\r\nprints\r\n  3 3\r\n  12\r\n\r\nSo, the global variable is changing every time, as is the class attribute,\r\nbecause there is just one of each. But each object that is an instance of C\r\nhas its own instance attribute, which changes only when bump is called on that\r\ninstance.\r\n\r\nIf we instead commented as follows\r\n  \r\n        global_var = 100     # comment out this line or the next\r\n        #global global_var   # comment out this line or the previous \r\n\r\nrunning the script would have the following result: By removing the statement\r\nglobal global_var, then the statement global_var = 100 actually defines a LOCAL\r\nvariable in the bump method -despite its name- so its increment does not affect\r\nthe true global_var, which stays at zero.\r\n\r\nRecall, if a variable defined in a function/method has NOT been declared global,\r\nthen it is created as a local variable inside the function/procedure.\r\n\r\nNote that one can REFER to the value of a global_var inside methods of class C\r\nWITHOUT a global declaration (see the report method), but if a method wants to\r\nCHANGE global_var it must declare it global (then all references and changes are\r\nto the real global variable). With no global global_var, the assignment\r\nglobal_var = 100 creates a new name local to the bump method and always binds\r\nit to 100.\r\n\r\n  instance referred to by o : global_var = 0 /class_attr = 0 /instance_attr= 10\r\n  o bumped\r\n  instance referred to by o : global_var = 0 /class_attr = 1 /instance_attr= 11\r\n\r\n  x = o\r\n  x bumped\r\n  instance referred to by o : global_var = 0 /class_attr = 2 /instance_attr= 12\r\n  instance referred to by x : global_var = 0 /class_attr = 2 /instance_attr= 12\r\n\r\n  x = C(20)\r\n  x bumped\r\n  instance referred to by x : global_var = 0 /class_attr = 3 /instance_attr= 21\r\n\r\n  instance referred to by o : global_var = 0 /class_attr = 3 /instance_attr= 12\r\n  instance referred to by o : global_var = 0 /class_attr = 3 /instance_attr= 12\r\n\r\n3 3\r\n12\r\n\r\nFinally, it is clear what C.class_attr and x.instance_attr refer to, but what\r\nabout x.class_attr? As shown above this prints 3 just as C.class_attr does. This\r\nmeaning is a result of the Fundamental Equation of Object Oriented Programming\r\n(but applied to variable attributes, not method attributes).\r\n  \r\n-----IMPORTANT\r\nTechnically, when specifying o.attr, any access to an attribute name in object o\r\n(whether a variable or method) Python first tries to find attr in the object o;\r\nif it is not defined in o's namespace/__dict__ Python uses the FEOOP to try to\r\nfind it by checking type(o).attr, which attempts to find attr in type(o)'s\r\nnamespace/__dict__. So when trying to find x.class_attr if fails to find\r\nclass_attr in o's namespace/__dict__, so it tries type(o).class_attr or\r\nC.class_attr and finds the class_attr attribute in C's namespace/__dict__.\r\n\r\nWhen we study inheritance, we will learn more about how Python searches for\r\nall attributes by extending/generalizing this rule: if it is not in an instance,\r\nthen it tries in the class that instance was constructed from, and if not in\r\nthat class, it tries in its base/super classes, and if not in its base/super\r\nclasses....\r\n\r\nBut for now remember: to find an attribute for an object: o.a\r\n  1) First look in the namespace of the object (o.__dict__)\r\n  2) If it isn't there, then use FEOOP to look in the namespace of the class\r\n      that the object was constructed from. (type(o).__dict__)\r\n  3) Remember if we are calling a method attribute, FEOOP translates the call\r\n     o.m(...) into the call type(o).m(o,...)\r\n-----\r\n\r\n------------------------------------------------------------------------------\r\n\r\nStrange Python (but now understandable):\r\n  1) Definin/Redefining/Using a method for a class, AFTER the class has been\r\n       declared:\r\n\r\n  2) Defining a method for an instance (but not the whole class) after the\r\n       instance has been constructed:\r\n\r\n1) Defining/Redefining/Using a method for a class, AFTER the class has been\r\ndeclared: We will now discuss one more interesting capability that a dynamic\r\nlanguage like Python has (but languages like Java and C++ do not). We can\r\nchange the meaning of a class as a program is running. Let's go back to a very\r\nsimple class C, that stores one instance attribute, but has no methods that\r\nchange it. The report method prints the value of this instance attribute.\r\n\r\nclass C:\r\n    def __init__(self, init_instance_attr):\r\n        self.instance_attr = init_instance_attr\r\n\r\n    def report(self, attr_name):\r\n        print('instance referred to by', attr_name,\r\n              '/instance_attr=', self.instance_attr)\r\n\r\nNow look at the following code. It defines o to refer to an object constructed\r\nfrom the class C, which defines only a report method (and then it calls that\r\nmethod to report). Next it defines the bump function with a  first parameter\r\nnamed self: its body increments the instance_attr in self's namespace\r\ndictionary. We call bump with o and it updates o's instance_attr (as seen by the\r\nreport).\r\n\r\no = C(10)\r\no.report('o') # By FEOOP, exactly the same as calling C.report(o,'o')\r\nprint()\r\n\r\nprints\r\n  instance referred to by o /instance_attr= 10\r\n\r\n\r\n# Define function bump\r\n# Strange, because this function uses \"self\"\r\n# But we can use any names for parameters\r\n\r\ndef bump(self,name):          \r\n    print(name,'bumped')      \r\n    self.instance_attr += 1\r\n\r\nbump(o,'o')   # Call function bump\r\no.report('o') # By FEOOP, exactly the same as calling C.report(o,'o')\r\nprint()\r\n\r\nprints\r\n  o bumped\r\n  instance referred to by o /instance_attr= 11\r\n\r\nSo, here we call the bump function, passing o as the argument matching self.\r\n\r\nThen we do something strange. We add the bump function into the namespace of\r\nC's class object with the name cbump (that is just the same as writing\r\nC.__dict__['cbump'] = bump, putting the cbump method in the namespace of the\r\nclass). We could have called it just bump, but instead we use a slightly\r\ndifferent name. Then, we can call o.cbump('o') which by the Fundamental\r\nEquation of OOP is the same as calling C.cbump(o,'o') and because we just made\r\nthe cbump attribute of the object representing class C refer to the bump\r\nfunction, its meaning is to call the same function object that bump refers to.\r\n\r\nC.cbump = bump; # put bump in the namespace of C, with the name cbump\r\no.cbump('o')    # By FEOOP, exactly the same as calling C.cbump(o,'o')\r\no.report('o')\r\nprint()\r\n\r\nprints\r\n  o bumped\r\n  instance referred to by o /instance_attr= 12\r\n\r\nx = C(20)\r\nx.cbump('x')\r\nx.report('x')\r\n\r\nprints\r\n  x bumped\r\n  instance referred to by x /instance_attr= 21\r\n\r\nSo, even AFTER THE CLASS C HAS BEEN DEFINED, we can still ADD A METHOD TO ITS\r\nNAMESPACE and then can CALL IT using any object that has already been (or will\r\nbe) constructed from the class C. That is, we can CHANGE THE MEANING of a class\r\nC dynamically (AFTER THE PROGRAM IS RUNNING), and all the objects constructed\r\nfrom the class will respond to the change through the FEOOP. Likewise, we can\r\nchange the meaning of a method in a class by rebinding the class attribute.\r\n\r\nRecall that the del command gets rid of an association in a dict. If we wrote\r\ndel C.cbump, then if we tried to call that method by o.cbump('o') the result\r\nwould be that Python raises \r\n\r\n  AttributeError: 'C' object has no attribute 'cbump'\r\n\r\nSo we can both ADD and REMOVE names from a class object's namespace!\r\n\r\nNote that we could have defined/written bump as follows (note use of p not self\r\nas the first parameter of bump: any name will do)\r\n\r\ndef  bump(p,name):\r\n    print(name,'bumped')\r\n    p.instance_attr += 1\r\n\r\nand nothing changes, so long as every occurrence of self is changed to p inside\r\nthe bump function (as is done). We could likewise write\r\n\r\ndef report(p, var):\r\n    ...\r\n\r\ninside the C class itself. The parameter name \"self\" is just the standard name \r\nused in Python code; but there is nothing magical about this name, and we can\r\nsubstitute whatever name we want for the first parameter. This parameter will\r\nbe matched with the object used to call the method. Although any name is\r\nallowed, I strongly recommend always following Python's convention and using\r\nthe name self. Eclipse always supplies the name self automatically as the first\r\nparameter to any methods we define.\r\n\r\n------------------------------\r\n\r\n2) Defining a method for an instance (but not the whole class) after the\r\n     instance has been constructed:\r\n\r\nIn fact, Python also allows us to add a reference to the bump method to a single\r\ninstance of an object constructed from class C, not the class itself. Therefore\r\nunlike the example above, bump is callable only on the one object that it was\r\nadded to, not on all the other instances of that class. We can also use this\r\ntechnique to add a method to an object that is different than the one defined\r\nin the object's class.\r\n\r\nStart with the class C as defined above, defining just __init__ and report.\r\nThen\r\n\r\ndef bump(self, name):\r\n    print(name,'bumped')\r\n    self.instance_attr += 1\r\n\r\no = C(0)\r\nx = C(100)\r\n\r\no.bump = bump;\r\n\r\no.bump(o,'o')     # o.bump directly calls bump method defined above\r\no.bump(o,'o')     #   (not using FEOOP) because that attribute is stored for o\r\no.report('o')\r\n\r\nx.bump(x,'x')     # fails because there is no bump attribute in the object x\r\nx.report('x')     #    refers to, either directly in x or in x's class C\r\n\r\nNote that calling o.bump(..) finds the bump method in o's namespace, without\r\nneeding to translate it using the Fundamental Equation of Object-Oriented\r\nProgramming. Without the translation, we explicitly need to pass the o argument\r\nwhich becomes bump's self parameter.\r\n\r\nGenerally when looking up the attribute o.attr (whether attr is a data or\r\nmethod name), Python first looks in the namespace of the object o refers to,\r\nand if it doesn't find attr, it next uses FEOOP and looks in the namespace of\r\nthe object type(o) refers to.\r\n\r\nWhen run, this script produces:\r\n\r\no bumped\r\no bumped\r\ninstance referred to by  o /instance_attr= 2\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\pattis\\Desktop\\python32\\test\\script.py\", line 21, in <module>\r\n    x.bump(x,'x')     # fails because there is no bump attribute in the object x\r\nAttributeError: 'C' object has no attribute 'bump'\r\n\r\nThe error message mentions C because after failing to find the bump attribute\r\nin the object y refers to, it looks in the object C refers to; when it fails\r\nthere too, the raised exception reports the error.\r\n\r\nSo, we can add methods to\r\n\r\n  (a) classes: methods that all the instances of that class can use, via  FEEOP\r\n\r\n  (b) an instance of the class, such that only that instance can call the method\r\n      (and their self parameter must also be passed as an explicit argument),\r\n      since FEOOP is not used.\r\n\r\n------------------------------\r\n\r\nCombining both worlds using delegation\r\n\r\nSuppose that we wanted to be able to call methods attached to objects, but do\r\nso using the standard object.method(...) syntax, as we did in the first part of\r\nthis section. In the second part of this section, we had to duplicate the\r\nobject, e.g., calling o.bump(o,'o') instead of just o.bump('o'). We will see\r\nhow to return to this simpler behavior using the concept of delegation in\r\nPython.\r\n\r\nWe start by defining C as follows, adding the bump function below\r\n\r\nclass C:\r\n    def __init__(self,init_instance_attr):\r\n        self.instance_attr = init_instance_attr\r\n\r\n    def report(self, attr):\r\n        print('instance referred to by', attr,\r\n              '/instance_attr=', self.instance_attr)\r\n\r\n    def bump(self,name):\r\n        try:\r\n            self.object_bump(self,name)\r\n        except AttributeError:\r\n            print('could not bump',name) # or just pass to handle the exception;\r\n                                         # or omit try/except altogther\r\n\r\nIn this definition of C, there is a bump method defined in the class C, for all\r\ninstances constructed from this class to execute, findable by FEEOP.\r\n\r\nWhen bump is called here, it tries to call a method named object_bump on the\r\ninstance it was supplied, passing the object itself to object_bump (doing\r\nexplicitly what FEOOP does implicitly/automatically). If that instance defines\r\nan object_bump function, it is executed; if not, Python raises an attribute\r\nexception, which at present prints a message, but if replaced by pass would\r\njust silently fail. Of course, we could also remove the entire try/except so an\r\nattribute failure would raise an exception and stop execution.\r\n\r\nNote that in the call o.bump(...) Python uses the Fundamental Equation of OOP\r\nto translate this call into C.bump(o,'o'), which calls the equivalent of\r\no.object_bump(o,'o').\r\n\r\nIn the world of programming, this is called delegation (which we will see more\r\nof): the bump method delegates to the object_bump method (if present) to get\r\nits work done.\r\n\r\nHere is a script, using this class. It attaches different object_bump methods\r\nto the instance o refers to, and the instance x refers to, but not to the\r\ninstance z refers to (nor to the class C). It calls this object_bump method not\r\ndirectly, but through delegation by calling bump in the C class.\r\n\r\no = C(10)\r\nx = C(20)\r\nz = C(30)\r\n\r\ndef bump1(self, name):\r\n    print('bump1',name)\r\n    self.instance_attr += 1\r\n\r\ndef bump2(self, name):\r\n    print('bump2',name)\r\n    self.instance_attr += 2\r\n    \r\no.object_bump = bump1\r\nx.object_bump = bump2\r\n# No binding of z.object_bump\r\n\r\no.report('o')\r\no.bump('o')\r\no.report('o')\r\nprint()\r\n\r\nprints\r\n  instance referred to by o /instance_attr= 10\r\n  bump1 o\r\n  instance referred to by o /instance_attr= 11\r\n\r\nx.report('x')\r\nx.bump('x')\r\nx.report('x')\r\nprint()\r\n\r\nprints\r\n  instance referred to by x /instance_attr= 20\r\n  bump2 x\r\n  instance referred to by x /instance_attr= 22\r\n\r\nz.report('z')\r\nz.bump('z')\r\nz.report('z')\r\n\r\nprints\r\n  instance referred to by z /instance_attr= 30\r\n  could not bump z\r\n  instance referred to by z /instance_attr= 30\r\n\r\n------------------------------------------------------------------------------\r\n\r\nRedefinition of Function Names (or anything else, really)\r\n\r\nNote that we can redefine a function or class. For example, we can write\r\n\r\ndef f():\r\n    return 0\r\n\r\ndef f():\r\n    return 1\r\n\r\nprint(f())\r\n\r\nCalling f() would return 1. Eclipse gets upset about this, and marks the\r\nsecond definition as an error (duplicate signature), but there is nothing\r\ntechnically wrong with this code (although the first definition is useless,\r\nand there may be a mistake in the spelling of one of these functions). Python\r\nwill run the script. We can also write the following script, which Eclipse\r\nwon't complain about, and runs the same.\r\n\r\ndef f():\r\n    return 0\r\n\r\ndef g():\r\n    return 1\r\n\r\nf = g\r\nprint(f())\r\n\r\nCalling f() returns 1. Again, def just makes a name refer to a function object;\r\nif, as in the case of the two definitions of the f name above, the name already\r\nrefers to an object, the binding of f is just changed to refer to the function\r\nobject g refers to.\r\n\r\nConceptually, it is no different than writing x = 1 and then x = 2 (changing\r\nwhat x refers to from the int object 1 to the int object 2).\r\n\r\nWe can do the same thing for classes, as we saw with the names C and D in the\r\nfirst example in these notes.\r\n\r\nIn summary, def f or class C just define a name and binds it to a function/class\r\nobject. We can call the function or the class's constructor. We can rebind that\r\nname later to any other object. We can even write\r\n\r\ndef f():\r\n    return 0\r\n\r\nf = 0\r\n\r\nNow f is bound to an int instance object, not a function object.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nAccessor/Mutator Methods (or query/command methods) and Instance Attributes\r\n  ...single/double underscore prefix\r\n\r\nIf calling o.method(...) returns information about an o's state but does not\r\nchange o's state, it is called an ACCESSOR (or QUERY). If o.method(...) changes\r\no's state and returns None (all functions/methods must return some value), it\r\nis called a MUTATOR (or COMMAND). Some method calls do both: they change o's\r\nstate but also return a non-None value.\r\n\r\nA design question arises. Suppose that we know that an object o of a class C\r\nhas an instance attribute name ia: should we directly refer to o.ia? Should we\r\nuse its value by writing o.ia and change it by writing o.ia = ....? The high\r\nroad says, no: a class should hide the actual instance attribute from the\r\nclients/users of the class; they should provide query and command methods to\r\nmanipulate the objects under control of the class. What instance attributes we\r\nneed to implement a class might change over time, but the methods that define\r\nthe behavior of objects created from that class should stay the same and always\r\nwork correctly with whatever instance attributes we are using.\r\n\r\nPython is a bit at odds with this philosophy. Some languages (Java/C++) have a\r\nmechanism whereby instance attributes can be tagged PRIVATE, so that they are\r\naccessible only from methods defined in the class itself; these languages do\r\nnot allow new instance attributes to be created after the class is constructed,\r\nnor do they allow new methods to be added dynamically to objects (as we showed\r\nabove). Python allows both.\r\n\r\nPython's philosophy is a bit more open to accessing instance attributes outside\r\nof the class methods. But there is danger in doing so, and beginners often use\r\nthis convenience and end up taking longer to get their code to work correctly,\r\nand also make it harder to understand and change the code, because they are\r\naccessing information that is not guaranteed to be there in future changes to\r\nthe code.\r\n\r\nIn fact, Python does have a weaker form of tagging PRIVATE names, which we can\r\nuse for names that should not be referred to outside the methods in the\r\nobject's class. Below we explain the meaning of instance attribute names that\r\nbegin with one or two underscores (but don't have two trailing underscores, so\r\nare unlike __init__).\r\n\r\n-----\r\nSingle Underscore Prefix: \r\n\r\nWhen a programmer uses a single underscore to prefix a name in a class (for\r\ndata or a method), he/she is indicating  that the name should NOT BE ACCESSED\r\noutside of the methods in the class. But, there is nothing in the Python\r\ninterpreter that stops anyone from accessing that name. We can use this\r\nconvention for private data and helper methods.\r\n\r\nclass C:\r\n    def __init__(self):\r\n        self._ia = 1\r\n\r\n    def _f(self):\r\n        return self._ia == 1\r\n    \r\no =  C()\r\nprint(o._ia, o._f())\r\n\r\nWhen run, this script produces: 1 True\r\n\r\nStill, if a class is written with names prefixed by a single underscore, it\r\nindicates that objects constructed from that class should NOT access those\r\nnames outside of the methods defined inside the class. This is a message from\r\nthe programmer who wrote the class to a programmer who is using the class: do\r\nnot access these attributes directly. They might disappear, or their names\r\nmight be changed in a later version of that class, or they might store/do\r\nsomething different.\r\n\r\n-----\r\nDouble Underscore Prefix:\r\n\r\nIf a Python name in a class begins with two underscores, it can be referred to\r\nby that name in the class, but not easily outside the class: but it can still be\r\nreferred to outside the class, but with a \"mangled\" name that includes the name\r\nof the class. If a class C defines a name __ia then the name outside the class\r\ncan be referred to as _C__ia. This is called a \"mangled\" name.\r\n\r\nSo, if we changed the code in the class C above by writing _ia as __ia and _f as\r\n__f, and tried to execute\r\n\r\no =  C()\r\nprint(o.__ia, o.__f())\r\n\r\nPython would complain by raising an AttributeError exception for the first\r\nvalue in the print statement\r\n\r\n  AttributeError: 'C' object has no attribute '__ia'\r\n\r\nIf o.__ia was removed, Python would complain about o.__f(), indicating the\r\nobject has no attribute '__f'.  \r\n\r\nBut given class C defines __ia, and __f we could execute the following code\r\n\r\no =  C()\r\nprint(o._C__ia, o._C__f())\r\n\r\nby writing the mangled names explicitly. When we run this script it again\r\nproduces: 1 True\r\n\r\nIn fact, if we printed the dictionary for o, it would show '_C__ia' as a key,\r\nwhich is the true name of these functions outside of the module.\r\n\r\nprint(o.__dict__) would print: {'_C__ia': 1}\r\n\r\nSo, Python does contain two conventions for hiding names: the first (one\r\nunderscore prefix) is purely suggestive; the second (two underscore prefix)\r\nactually makes it harder to refer to such names outside of a class.\r\n\r\nBut neither truly prohibits accessing the information by referring to the name.\r\n\r\nWhen we discuss operator overloading (later this week) and inheritance (later\r\nin the quarter) we will learn more about controlling access to names defined\r\nin objects and classes.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDefining classes in unconventional places:\r\n\r\nWe normally define classes in modules, and often a module does nothing but\r\ndefine just one class (although some define multiple, related classes). Other\r\nmodules define lots of functions. All such modules are called library modules\r\n(not scripts) because they typically don't run code themselves, but we import\r\nthem to gain access to the names (of classes and functions) that they define.\r\n(If they do run code, it is inside the code if __module__ == '__main__': and\r\noften the code there allows us to test the class or module, not use it to solve\r\nany intereresting problem).\r\n\r\nWe have seen that we can define local functions inside functions (and sometimes\r\neven return references to these locally defined functions).\r\n\r\nWe can also declare a class inside a function and call the function to return an\r\nobject constructed from the class (and even use the returned object if we know \r\nits defined instance attributes).\r\n\r\ndef f(x):\r\n    class C:\r\n        def __init__(self,x):  self.val = x\r\n        def double  (self)  :  return 2*self.val  \r\n    return C(x)\r\n\r\no = f(1)                     # o refers to an object constructed from class C\r\nprint(o, o.val, o.double())\r\n\r\nWhen run, this script prints the following.\r\n\r\n<__main__.f.<locals>.C object at 0x02829170> 1 2\r\n\r\nThe first value indicates (reading the first word after the left angle-bracket,\r\nfrom back to front) that class C is defined local to function f, which\r\nis in the script we ran (named by Python to be __main__); o.val refers to the\r\ninstance attribute inside o's names space; o.double() calls the double function\r\n(found by FEOOP) which returns twice o's val attribute.\r\n\r\nWe can also declare a class inside a class, and call some method in the class to\r\nreturn an object constructed from the inner class (and even use the object if\r\nwe know its defined instance attributes).\r\n\r\nclass C:\r\n    def __init__(self,x,y):\r\n        self.x = x\r\n        self.y = y\r\n    class Cinner:\r\n        def __init__(self,x):  self.val = x\r\n        def double  (self)  :  return 2*self.val  \r\n    def identity(self)   : return (self.x, self.y)\r\n    def x_construct(self): return C.Cinner(self.x)\r\n    def y_construct(self): return C.Cinner(self.y)\r\n\r\no = C(1,2)\r\na = o.x_construct()\r\nb = o.y_construct()\r\nprint( o, a, b,sep='\\n')\r\nprint(o.identity(), a.double(), b.double())\r\n\r\nWhen run this script prints:\r\n  <__main__.C object at 0x02A36310>\r\n  <__main__.C.Cinner object at 0x02A36290>\r\n  <__main__.C.Cinner object at 0x02A36E70>\r\n  (1, 2) 2 4\r\n\r\no.x_construct() returns a reference to an instance of class C.Cinner, that was\r\ninitialized by the x attribute defined in the __init__ method. When we call\r\na.double(), the double method defined in Cinner() returns twice the value it was\r\ninitialized with.\r\n\r\nIn fact, instead of the x_construct and y_construct functions, we could define\r\na more general construct function that takes either 'x' or 'y as arguments and\r\nconstructs an object for self.x or self.y. The first way to do this uses the\r\nparameter (matching 'x' or 'y') as a key to access __dict__\r\n\r\n    def construct(self,which): return C.Cinner(self.__dict__[which])\r\n\r\nSo, o.construct('x') returns C.Cinner(self.__dict__['x']) = C.Cinner(1)\r\n\r\nThe second way to do this uses the eval function, whose argument is either\r\n'self.x' or 'self.y' depending on the value of which.\r\n\r\n    def construct(self,which): return C.Cinner(eval('self.'+which))\r\n\r\nSo, o.construct('x') returns C.Cinner(eval('self.'+'x'))\r\n = C.Cinner(eval('self.x')) = C.Cinner(self.x) = C.Cinner(1)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDefining/Using Static Methods in Classes\r\n\r\nA method defined in a class is considered \"static\" if it does not have a self\r\nparameter. Sometimes it is useful to write methods in a class that have this\r\nproperty. \r\n\r\nFor example, suppose that we wanted to declare a Point2d class for storing the\r\nx,y coordinates for Points in 2-d space. The __init__ method would take two such\r\narguments. But suppose that we also wanted to create Point2d objects by\r\nspecifying polar coordinates (i.e, using a distance and angle in radians). We\r\ncould write such a class (with this static method) as follows.\r\n\r\nimport math\r\n\r\nClass Point2d:\r\n    def __init__(self,x,y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    @staticmethod\r\n    def from_polar(dist,angle):\r\n        return Point2d( dist*math.cos(angle), dist*math.sin(angle) )\r\n\r\n    ...more code\r\n\r\nThis method is preceded by @staticmethod (a decorator: we will discuss\r\ndecorators generally later). This method is meant to be called from outside\r\nthe class, to create Point2d objects from polar coordinates. We can write calls\r\nlike\r\n\r\n  a = Point2d(0., 1.)\r\n  b = Point2d.from_polar(1.0, math.pi/4)\r\n\r\nNotice that we call Point2d.from_polar outside of the class by using the class\r\nname Point2d and the static method name from_polar defined in that class (which\r\nhas no self parameter). Of course, the static class name is just an attribute\r\nof the Point2d class.\r\n\r\nLikewise, suppose that we wanted to write a helper function for computing the\r\ndistance between two Point2d objects as a static method in this class. We could\r\nwrite it as\r\n\r\n    @staticmethod\r\n    def _distance(x1,y1,x2,y2):\r\n        return math.sqrt( (x1-x2)**2 + (y1-y2)**2 )\r\n\r\n    def dist(self,another):\r\n        return Point2d._distance(self.x, self.y, another.x, another.y)\r\n\r\nHere this helper function is meant to be called only by the dist method in\r\nthis class, so we write its name with a leading underscore. Note that again we\r\ncall it using Point2d. Because of FEOOP, we could also call this helper as\r\nself._distance(self.x, self.y, another.x, another.y) because type(self) is\r\nPoint2d. But, because it is decorated with @staticmethod, Python translates the\r\ncall slightly differently when using FEOOP: WITHOUT putting self as the first\r\nargument: it just passes the 4 arguments given.\r\n\r\nFinally, we could also write this helper function as a global function defined\r\noutside Point2d, in the module that Point2d is defined in. But it is better to\r\nminimize any kinds of global names; so, it is better to define this name inside\r\nthe class. In this way it won't conflict with any other name the importing\r\nmodule has defined.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nLook at my Dice class (in dice.py in the courselib). It has many interesting\r\nsimple class features; it doesn't use many of the features discussed here.\r\n\r\nLater during this week, we will learn how to use methods to overload operators\r\nthat allow us to take advantage of Python's syntactic features. We will learn\r\nabout many other special functions named like __init__  with double underscores\r\nfront and back.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n0) What does the following script print?\r\n\r\nclass C:\r\n    def __init__(self):\r\n        print('C object created')\r\nD = C\r\ndef C():\r\n  print('C function called')\r\n\r\nx = C()\r\ny = D()\r\n\r\n\r\n1) What does the following script print?\r\n\r\nclass Person:\r\n    fingers = 10\r\n    def __init__(self, name, fingers):\r\n        self.name = name\r\n        if fingers != self.fingers:\r\n            self.fingers = fingers\r\n    \r\nbobby = Person('Bobby', 9)\r\ncarol = Person('Carol', 10)\r\nprint(bobby.__dict__, bobby.fingers)\r\nprint(carol.__dict__, carol.fingers)\r\n\r\nWill it print differently if we write the if as fingers != Person.fingers:\r\n\r\n2) What does the following script print? Draw a picture of the object x refers\r\nto using the graphical form for representing objects we learned during Week #1.\r\n\r\nclass C:\r\n    def __init__(self,a):\r\n        self.a = a\r\n\r\nx = C(1)\r\nC.__init__(x,2)\r\nprint(x.a)\r\n\r\n\r\n3) Write a class C whose __init__ method has a self parameter, followed by low\r\nand high. __init__ should store these values in self's dictionary using the\r\nsame names, but do so only if low is strictly less than high (otherwise it\r\nshould raise the AssertionError exception with an appropriate string.\r\n\r\n\r\n4) Explain why each of the following code fragments does what it does: two\r\nexecute (printing different results) and two raise an exception.\r\n\r\ng = 0\t\t\tg = 0\t\t\tg = 0\t\tg = 0\r\ndef f():\t\tdef f():\t\tdef f():\tdef f():\t\r\n  print(g)\t\t  global g\t\t  print(g)\t  print(g)\t\r\n  \t\t\t  print(g)\t\t  g += 1          global g\r\n  \t\t\t  g += 1 \t\t                  g += 1\r\n\r\nf()\t\t\tf()  \t\t\tf()\r\ng += 1\t\t\tg += 1\t\t\tg += 1\r\nf()\t\t\tf()  \t\t\tf()\r\n\r\n\r\n5) Write a class C that uses a class attribute to keep track of how many objects\r\nare created from C (remember that each object creation calls __init__)\r\n\r\nThat is, for a class C\r\n\r\na = C(...)\r\nb = C(...)\r\nprint(C.instance_count) prints 2\r\nc = C(...)\r\nprint(C.instance_count) prints 3\r\n\r\n\r\n6) What would the following script print; explain why. Also, explain why the\r\ncall self.object_bump(name) in bump is not self.object_bump(self,name) as it\r\nwas in the notes.\r\n\r\nclass C:\r\n    def __init__(self,init_instance_attr):\r\n        self.instance_attr = init_instance_attr\r\n\r\n    def report(self,attr):\r\n        print('instance referred to by', attr,\r\n              '/instance_attr=', self.instance_attr)\r\n\r\n    def bump(self,name):\r\n        try:\r\n            self.object_bump(name)\r\n        except AttributeError:\r\n            print('could not bump',name) # or just pass to handle the exception\r\n\r\nx = C(10)\r\ny = C(20)\r\n\r\ndef bump(self,name):\r\n    print('bumped',name)\r\n    self.instance_attr += 1\r\n    \r\nC.object_bump = bump    \r\n\r\nx.report('x')\r\nx.bump('x')\r\nx.report('x')\r\n\r\ny.report('y')\r\ny.bump('y')\r\ny.report('y')\r\n\r\n\r\n7) The function print is bound to a function object. What is printed by the\r\nfollowing script (and why)?\r\n\r\nprint = 1\r\nprint(print)\r\n\r\n", "encoding": "ascii"}