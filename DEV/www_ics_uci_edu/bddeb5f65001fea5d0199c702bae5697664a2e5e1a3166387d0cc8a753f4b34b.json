{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/constructdebug/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program Constuction and Debugging</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program Construction and Debugging</h1>\r\n<p>\r\n<h2>ICS-31: Introduction to Programming\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\nIn this lecture we will learn some general information about\r\n  iterative-enhancement as as technique for designing, coding, testing,\r\n  and debugging programs.\r\nThen, we will discuss debugging both syntax errors and  execution/runtime\r\n   errors in Python.\r\nDebugging is a skill that you will become more adept at as the quarter\r\n  progresses (because you will be doing so much of it).\r\nThis lecture is coupled with a handout that includes practical\r\n  information about learning and using the\r\n  <a href=\"../../../common/handouts/debugger/debugger.pdf\">\r\n     Eclipse Debugger Perspective</a>; \r\n  please read it and follow its instructions.\r\nOnce we have learned to operate this tool, we can explore how to use\r\n  it for debugging.\r\n<p>\r\nThis tool is not only useful for debugging programs, but it is also useful\r\n  for understanding Python control structures, function/method calls (and their\r\n  parameters and local variables), and objects (and their instance\r\n  variables).\r\nSo, we will use it in the classroom repeated during the quarter (and\r\n  you should use it to explore these topics, even if you don't use it to\r\n  debug your programs).\r\n<p>\r\nAs a warmup for debugging, please read the\r\n  <a href=\"../../../common/handouts/bugs.html\">Bugs in Programming</a>\r\n  web page.\r\nMost programmers write code that is about 80% correct.\r\nThe mark of a good programmer is that he/she systematically locates and\r\n  corrects each bug in the program until it is 100% correct; in contrast, a\r\n  poor programmer randomly changes the program (without knowing the cause of\r\n  the bug or the implications of the changes) and will actually REDUCE the\r\n  correctness of the code.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Iterative Enhancement -->\r\n\r\n<a name=\"IterativeEnhancement\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Program Construction via Iterative Enhancement (Design for Debugging)</b></td>\r\n<td width =\"80%\">\r\nPrograms/scripts are almost always written based on some <i>divide and\r\n  conquer</i>  approach to problem solving.\r\nSuch approaches rely on the belief that it is harder to solve one large\r\n  problem than to solve a sequence of smaller subproblems (which lead to the\r\n  solution of the large problem).\r\nSo, in designing a program, we must determine how to divide the larger problem\r\n  into a sequence of smaller subproblems, and then conquer/solve each one\r\n  individually.\r\nIn industry, a team of programmers working on the same project may solve\r\n  these problems in parallel.\r\n<p>\r\nThe divide and conquer approach that we will use mostly is \r\n  <b>Iterative-Enhancement</b>.\r\nGiven a problem (a specification of a program to write)\r\n<ul>\r\n  <li>We start by writing a <b>kernel</b> program that meets some\r\n        dramatically simplified version of the specification.\r\n  <li>We extend the kernel by writing a sequence of programs, each an \r\n        enhancement to the previous one (each is called a <i>phase</i>),\r\n        which includes more and more of the specification.\r\n  <li>We eventually reach the final phase, which is the last program in the\r\n        sequence; it meets the entire specification and solves the entire\r\n        problem.\r\n</ul>\r\nBy analogy, think of trying to cross a river; we could try to jump it in a\r\n  single bound, or we could try to find a path of stones in the river bed,\r\n  and jump from stone to stone, getting closer and closer to our destination,\r\n  until we reach the other side.\r\nEach phase in the enhancement is like a stepping stone.\r\n<p>\r\nIn addition, this approach allows us to gauge our progress, with each\r\n  finished phase acting as a milestone.\r\nIf it has taken us 3 hours to finish the first 4 phases of a project, and\r\n  there are 4 more phases to go (and we assume each phase takes about the \r\n  same amount of work), we can predict that it will take us about another 3\r\n  hours to finish.\r\nSuch an estimate is crude, but it is better than no estimate at all.\r\n<p>\r\nPictorially, we can look at the process as follows.\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/iterative.gif\"></mage>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nWe will practice this method, on a small scale, in our early programming\r\n  assignments.\r\nIt requires some perspective (and experience) to take a complicated program\r\n  specification and identify a good kernel and design a good sequence of\r\n  enhancements.\r\n<ul>\r\n  <li>The kernel should capture something essential about the problem,\r\n        without getting bogged down in details.\r\n      Often the kernel captures the information needed to construct the main\r\n        loop in a program.\r\n  <li>Each phase should be a reasonable amount of work, focusing on one\r\n        different aspect of the problem, adding in more details.\r\n</ul> \r\nhe phases involve designing, coding, testing, and debugging a small amount of\r\n  related code to create an enhanced program.\r\nIt is critical that each such program is testable, so that we can verify that\r\n  it meets its enhanced specification and that we are truly making progress\r\n  towards our ultimate goal.\r\nIf any design element or its code fails to work, we will discover it quickly\r\n  and fix it immediately; we won't spend lots of time building other parts of\r\n  the code that depend on a wrong decision, and then have to undo that work.\r\n<p>\r\nTo start on a program, we need a good -but not perfect- understanding of the\r\n  problem being solved.\r\nSo, we should try to understand as much as we can before starting, but we \r\n  don't need to  understand everything; don't be afraid to begin.\r\nDuring the process of writing our program, we will learn more and more\r\n  details about the problem, as we tackle more and more details in the\r\n  enhancements.\r\nOur \"understanding\" of the problem willl increase, the more we work on\r\n  writing a program to solve it.\r\nEventually we will acquire an understanding of every detail of the problem,\r\n  because we have implemented every detail in our program, telling the computer\r\n  how to accomplish it, in the terms the computer understands.\r\n<p>\r\nWhen we learn how to write our own functions, we will be able to associate\r\n    an action (some code) with a name.\r\nThen, by just referring to the name, we can execute the code.\r\nSometimes the discovery of functions is bottom-up: we realize that we\r\n  are performing the same computation over and over again, so we write a\r\n  method for it.\r\nSometimes the discovery is top-down: before we even write any code we\r\n  realize that certain functions can act as useful building blocks, so we write\r\n  them.\r\n<p>\r\nWhen we learn how to write our own classes, we will apply the same\r\n  bottom-up and top-down processes, but on a larger scale.\r\nFirst we identify useful classes and all the methods that they define.\r\nNext we test each class independently, by testing its individual methods.\r\nOnce each class is working, we can test combinations of classes, as we use\r\n  them to build the entire application program.\r\nThus, we are always employing some kind of divide-and-conquer approach to\r\n  solve our programming problems.\r\n<p>\r\nAnother key feature of iterative enhancement is <b>focus</b>.\r\nEach enhancement focuses on designing and coding a small number of additions\r\n  or modifications to an already working program.\r\nWhen debugging a phase, we typically need to focus on only the small amount\r\n  of code that we recently added/changed.\r\nIn this way, we can effectively build large programs by focussing on one\r\n   piece at a time.\r\nThe biggest problem is then making sure the pieces all fit together.\r\n<p>\r\nThe human brain can only keep track of so many details at a time; if we wrote\r\n  a huge amount of code and tried to debug it all, it could easily overload\r\n  our mental capacity.\r\nOften engineers talk about the KISS principle: Keep It Simple, Stupid.\r\nIterative-enhancement lets us keep each task simple.\r\n<p>\r\nFinally, at the end of each phase we should <b>simplify</b> our code\r\n  as much as possible: step back and try to come up with equivalent code\r\n  that is easier to understand (and often smaller).\r\nBecause we are building on our code, and making it more complicated by\r\n  further enhancing it, we want to always start each enhancement with the\r\n  simplest working code possible.\r\nSimplifying during iterative enhancement will be much more effective\r\n  (because of focus) than trying to simplify an entire program after\r\n  it is written.\r\nTime spent simplifying code will pay for itself with time saved in later\r\n  enhancements.\r\n<p>\r\nWhat makes programming a difficult activity is controlling complexity.\r\nWhen programs become too complex, we cannot easily fix or enhance them.\r\nNow that we have learned all the control structures of Python, our next\r\n  focus will be how to reduce their complexity by writing functions and\r\n  classes (and using the classes already provided in the Python library.\r\nHere is a relevant quote that emphasizes this issue: the \"skill of the creator\"\r\n  means the creator's ability to control complexity.\r\n<blockquote>\r\nComputer Science is the first engineering discipline in which the complexity of\r\n  the objects created is limited solely by the skill of the creator,\r\n   and not by the strength of raw materials.-B. Reid\r\n</blockquote>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Testing -->\r\n\r\n<a name=\"Testing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Testing Software</b></td>\r\n<td width =\"80%\">\r\nTesting is the process of running software looking for errors (meaning \r\n  actively trying to make the program fail by testing it in many -even\r\n  unexpected- way): failure of the program to produce correct output from\r\n  some correct input.\r\nOnce testing shows the presence of a bug, debugging begins (the process of\r\n  fixing errors found during testing).\r\nBefore discussing the process of debugging, let's look a bit at the process\r\n  of testing.\r\n<p>\r\nProfessional software testers acquire great skill and intuition at thinking-up\r\n  \"good\" inputs  on which to test programs.\r\nThey are valued members of a product team.\r\nFor example, Microsoft employs about one tester for each programmer.\r\nSometimes these testers work in teams separate from the programmers; at other\r\n  times a tester will pair up with a programmer.\r\nWhen the programmer finishes some part of the code, the tester begins testing\r\n  it while the programmer proceeds to the next part of the code.\r\nIf the tester finds any bugs, the programmer must fix them before continuing.\r\nAs you can imagine, programmers often dislike testers because the latter are\r\n  always pointing out mistakes made by the former!\r\n<p>\r\nBut, it is better to have the mistake pointed out by your coworker than by\r\n  your boss (or a customer).\r\nNo programmer wants to believe that his/her code contains errors; but they\r\n  all do contain errors.\r\nSome would argue that the programmer, intimiate with the code he/she has\r\n  written, is the best person to test it.\r\nBut, having a programmer test his/her own code might be bad from a\r\n  psychological point of view:  he/she might not test the code as rigorously,\r\n  because he/she doesn't really want to find any errors.\r\nHaving a separate tester addresses this problem.\r\n<p>\r\nBut even this approach can cause problems: if a programmer knows an\r\n  independent tester will be examining his/her code after it is written,\r\n  the programmer may write code carelessly, knowing it is someone else's\r\n  job to spot problems.\r\nThus, there is a real tangle of incentives when writing and testing code.\r\nHow Microsoft produces software (an overview accessible to students in this\r\n  course) is discussed in Cusumano and Shelby\r\n    <a href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0684855313/qid=1031956797/sr=1-4/ref=sr_1_4/002-9542912-5644017?v=glance&s=books\" target=\"_blank\">\r\n  Microsoft Secrets: How the World's Most Powerful Software Company Creates\r\n    Technology, Shapes Markets, and Manages People</a>, Free Press, 1995.\r\n<p>\r\nIn <b>Agile</b> programming methods (which includes Extreme Programming,\r\n  which includes Pair Programming) programming is test-driven.\r\nBefore doing any coding, a programmer or tester develops an extensive suite\r\n  of tests that the code must pass.\r\nOnly then is the code written: and the programmer's progress is judged by\r\n  the number of tests in the suite that it passes (which is a bit like\r\n  using iterative enhancment to judge the progress of programming).\r\nIf the code is modified later, it must repass all these tests.\r\nWe will discuss unit testing when we learn about writing functions (functions\r\n  are the smallest unit we can test), which helps automate test-driven\r\n  programming.\r\n<p>\r\nThere are two general categories of testing.\r\nIn <b>black-box</b> testing, testers write test-cases based only on the\r\n  specifications for what the code is supposed to accomplish; they are not\r\n  allowed to look at the code itself.\r\nIn <b>white-box</b> testing, testers write test-cases based both on knowledge\r\n  of the specifications and the code itself: certain kinds of tests might\r\n  suggest themselves if the tester examines the code.\r\nOf course, black-box tests can be developed before or while the code is\r\n  written, but white-box tests can be developed only after the code is\r\n  written.\r\n<p>\r\nIndustry testers often write/use long scripts when they\r\n  <b>regression test</b> programs.\r\nEach time a program is changed, the tester executes the script to ensure that\r\n    no bugs were introduced in old features (it still works as it always has).\r\nThen the script is extended for the new features being tested.\r\nMuch of the work in regression testing can be automated: often the result of\r\n   such tools is either a message confirming that all tests were passed, or\r\n   a list of outputs (and their inputs) that differed between the original\r\n   program and the one now being tested.\r\n<p>\r\nFinally, <b>integration tests</b> determine whether software components,\r\n  written and tested separately (in <b>component</b> or <b>unit</b> tests),\r\n  work together correctly in a program.\r\nIt is much easier to test/debug each component by itself, than in a system\r\n   comprising many components.\r\nIn systems, even simple bugs can manifest themselves in hard to understand\r\n  situations.\r\nMany features added to programming languages at the end of the 1990s were\r\n  designed to simplify software integration\r\n<p>\r\nWe will discuss many of these aspects of testing in more detail in a later\r\n  lecture, focusing on Python's ability to write unit tests inside the functions\r\n  and classes they are testing.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Debugging -->\r\n\r\n<a name=\"Debugging\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Debugging</b></td>\r\n<td width =\"80%\">\r\nOnce testing has found an error, we can begin debugging: trying to locate\r\n  the source of the error and fix it.\r\nDebugging is also a task suited to solution by divide-and-conquer techniques.\r\nWe don't need to remove all the bugs from a program all at once; instead, if we\r\n  can remove one bug, then another, etc. we will eventually remove them all.\r\nAlso, when we are looking for the location of a bug in a program, we can\r\n  divide the program into regions and search for the bug in smaller and\r\n  smaller regions until we find it.\r\nThe key idea is to continually make progress, never getting stuck for too\r\n  long on one problem (maybe switching to solve another if we run dry on the\r\n  ways to fix the first).\r\n<p>\r\nWe will divide debugging into syntax bugs and execution/runtime bugs.\r\nSyntax bugs are often diagnosed and reported by Eclipse, which shows\r\n  their location (or a close approximation) and a description of the error\r\n  (or a close approximation).\r\nExecution/runtime bugs are much more difficult to fix, primarily because WE\r\n  must first notice them and then find which statements in the program cause\r\n  them: it is much easier when Eclipse tells us there is an error and near\r\n  which line.\r\nThe hardest part of debugging is tracking down the location of an error: once\r\n  we have accomplished this task, actually fixing the bug is often much\r\n  simpler.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Syntax Errors -->\r\n\r\n<a name=\"SyntaxErrors\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Syntax Bugs</b></td>\r\n<td width =\"80%\">\r\nAs we learned in our first lecture, the earlier a problem is discovered,\r\n  the less time/money it will take to fix it.\r\nSyntax errors are discovered very early.\r\nThe Eclipse detects and reports these before running the program; so they are\r\n  much easier to fix than execution/runtime errors.\r\nIn fact, some programming languages, with even stricter rules than Python, spot\r\n   even more errors as syntax errors; errors which in Python become apparent\r\n   only at runtime (when actually running the program).\r\nParadoxically, we should be happy whenever Eclipse reports a syntax bug:\r\n  given that the program has an error, Eclipse saves us from having to run and\r\n  locate the error later, at runtime (a more complicated process).\r\n<p>\r\nNever say that a program is correct until it contains neither kinds of\r\n   errors.\r\nMany introductory programming students say, \"My program has no errors but it\r\n  is not working correctly\", when they should be saying, \"My program has no\r\n   syntax errors, but it still has execution/runtime errors\".\r\nAlthough no one likes to be told of syntax errors in their programs, Eclipse\r\n  focuses our attention to fix these errors before running our programs, and\r\n  thus eliminates many harder-to-debug execution/runtime errors that would\r\n  otherwise occur.\r\nA well designed programming language is one that allows errors to be\r\n  detected as early a possible.\r\n<p>\r\nTechnically, Eclipse detects and reports a syntax error when it examines a\r\n  token that cannot legally appear next in the code.\r\nThus, either that token is wrong, or some recent one that preceded it was.\r\nSo, first check the token itself, and then those immediately preceding it.\r\nUnderstand what you are trying to accomplish with these tokens and use this\r\n  knowledge to help determine what is wrong with what you wrote.\r\nA great help in fixing subtle syntax errors is working code (in some other\r\n  program) that uses the same language features correctly; compare the two \r\n  to find the problem; sometimes you have to do this comparison very carefully.\r\n<p>\r\nCommon errors include missing colons, mismatched delimiters (parentheses,\r\n  brackets, and braces), misspelled names, and the wrong number/type of\r\n  arguments to operators and functions.\r\nEclipse uses the Python interpreter to find some of these early (as syntax\r\n  errors) while finding others later, as runtime/execution errors.\r\nSometimes it does a relatively good job of explaining the syntax errors that it\r\n  finds, but sometimes its messages are cryptic (or even just plain wrong);\r\n  it takes a bit of intuition to interpret these messages (a skill that we\r\n  will continue to acquire as we debug more and more of our programs; in\r\n  fact, we can acquire this skill while helping to debug other people's\r\n  programs too: that is why teachers are so good at debugging).\r\n<p>\r\nThe best strategy is to try to fix the first syntax error reported.\r\nSometimes you might scan the first few syntax errors and be able to fix more\r\n  than one at a time; other times you may be confused by the first syntax\r\n  error but be able to fix a later one.\r\nIn fact, sometimes fixing one syntax error eliminates others, because they\r\n  all have the same root cause: imagine you misspell a name the first time you\r\n  use and, and then spell it correctly later.\r\nEclipse might show many syntax errors, all fixed by correcting the initial\r\n  misspelling.\r\n<p>\r\nIf you cannot fix a syntax error, seek help; when you understand what you\r\n  did wrong, write down the problem, the error message, and the solution in\r\n  an error log, which you can consult whenever you have hard-to-fix syntax\r\n  errors; learn from experience.\r\n<p>\r\nIncorrectly matching delimiters can cause very many syntax error messages that\r\n  are not indicative of the real problem.\r\nFor this reason, whenever you type an opening delimiter (e.g., a parenthesis or\r\n  quote), Eclipse will automatically type a matching closing delimiter position\r\n  the cursor inbetween the two for you to continue typing.\r\n<p>\r\nPython's use of indenting to delimit blocks is a feature not supported by many\r\n  other programming languages: others require the statements in a block appear\r\n  between {} - open/close brace characters, which are not as easy to see.\r\nSo Python helps programmers cut down on their errors (which is good; it is\r\n  excellent for beginning programmers who are easily confused about blocks).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Execution/Runtime Errors -->\r\n\r\n<a name=\"ExecutionErrors\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Execution Bugs</b></td>\r\n<td width =\"80%\">\r\nIf we run a program with no syntax errors, it might still be incorrect.\r\nThe program may or may not behave as it should: a simple program may not\r\n  compute and display the correct results; a more complicated one may not\r\n  do the right thing when you click its buttons.\r\nIf either case, it has an execution/runtime error.\r\nTechnically, an <b>execution/runtime error</b> is something that Python detects\r\n  arnd reports (like raising an exception when dividing by 0); an\r\n  <b>intent error</b> goes undetected by Python, which finishes the program\r\n  without an execution/runtime error, but nevertheless computes an incorrect\r\n  result.\r\nIn the discussion below, we will refer to both kinds of errors as execution\r\n  errors.\r\n<p>\r\nDebugging execution errors is hard: we have to leave our ego at the door,\r\n  admit that WE put an error in our program, and then systematically locate\r\n   and fix the problem.\r\nThe golden rule of debugging is to find the <b>simplest</b> input on which\r\n  a program consistently produces an error (this makes debugging much\r\n  easier).\r\nWe can apply the techniques described below most effectively when debugging\r\n  the program on the simplest input causing an error.\r\nSo, if we find an input that causes the program to fail, we should keep\r\n  trying simpler inputs (fewer values, smaller values, etc.) until we find\r\n  the simplest one on which it fails.\r\nOnly then do we start debubugging.\r\n<p>\r\nJob #1 in debugging is finding the location of the error.\r\nOnce we know which statement contains a wrong instruction (wrong not\r\n  because of syntax, but because it is not the right statement for the\r\n  program to execute), finding how to fix it is often much simpler.\r\nThe typical way to find the problem is to <b>instrument</b> the program with\r\n  calls to <b>print</b> that display the current state of the \"relevant\"\r\n  objects bound to names.\r\nWe can build complicated programs that trace themselves: we can use an\r\n  <b>if</b> statement testing a <b>trace</b> variable to determine whether\r\n  to print information (for a <b>boolean</b>) or what level of information\r\n  (for an <b>int</b> trace level) to print as the program executes.\r\nEventually, we will find that some name is bound to the wrong value and that\r\n  is the location of the error.\r\n<p>\r\nWhen we write programs using iterative enhancement, each phase should display\r\n  the names that it defines and/or changes, so we can see if the new\r\n  parts of the program are binding names to objects correctly.\r\n<p>\r\nSometimes a program gets into an infinite loop: the test controling\r\n  termination of a <b>while</b> loop is wrong and the loop never terminates.\r\nIf we put a call to <b>print</b>  inside the body of the loop, and the loop\r\n  becomes infinite, we will easily spot the error because that information\r\n  will print out over and over and over again, indicating an infinite loop.\r\nTypically such print functions print the values bound to names that are being\r\n  used to determine when to terminate a loop.\r\n<p>\r\nSometimes we write call <b>print</b> functions displaying no names, just\r\n  literals.:\r\n <b>print('About to execute critical statement')</b>\r\nbut more frequently, they look like\r\n    <b>print('After update: x =',x);</b>\r\nAlways uniquely label your prints so you know from where in the program each\r\n  piece of information is printed.\r\nThe amount of time you spend typing-in such statements is dwarfed by the\r\n  amount of time you spend studying them; so make the the effort to show the\r\n  output clearly.\r\n<p>\r\nPrinted values will always appear in the order the program executed them.\r\nBut sometimes Python will show the results of a call to print and ther result\r\n  of unhandled exception in a muddled order.\r\nSo don't get too confused by such lack of sequentiality.\r\n<p>\r\nOnce we find a bug (the hard part), it is often takes much less work to fix\r\n  it.\r\nOften, we do some oval-diagram or hand-simulation to more closely analyze the\r\n   problem.\r\nWhenever we fix a bug, we should immediately hand simulate (or rerun) the\r\n  new code to ensure that it now works correctly.\r\nIf it does not perform as expected, undo the change and go back to the old\r\n  code to look for a different fix.\r\nOften students first ideas are best, they just need a bit of polish.\r\nWe should not keep any change in our code unless we observe that the change\r\n  improves the code: one change may not completely correct the code, but it\r\n  should improve it.\r\nIf we make lots of changes that don't improve the code, we will degrade the\r\n  code and make it harder to fix it: we will lose the original thread-of-thought\r\n  we had when we wrote the code.\r\n<p>\r\nAgain, the first effort of a programmer is often 80% correct.\r\nStudents have a tendancy to make unsupported changes in code they are\r\n  debugging, often taking code from being close to correct to being further\r\n   away.\r\nGood programmers verify that each change improves their code; if a\r\n  change does not improve things, remove it and go back to the original code.\r\nThey keep making improvements until the code is correct.\r\nThe measure of a good programmer is not necessarily how many bugs are\r\n  initially present in his/her code, but how quickly he/she removes those\r\n  bugs that are present.\r\n<p>\r\nHere are a few simple debugging tips.\r\nOf course, using the Debug Perspective can help us do all of these tasks.\r\nThere are the kinds of things Sherlock Holmes would say when trying to track\r\n  down a criminal.\r\n<ul>\r\n  <li>Eliminate obvious errors first: make sure the data is being read\r\n       correctly from a file before trying to debug the code that processes\r\n       it (if the data is not being read correctly, of course the processing\r\n       code will produce incorrect results).\r\n  <li>Ensure that every name is bound to a reasonable value before its value\r\n        is used the first time.\r\n  <li>If an expression is computing an incorrect value, display the values of\r\n         all the names used in the expression (one of them may be wrong).\r\n  <li>If you are unsure which part of an <b>if/else</b> is executing, put\r\n        something like the following at the top of a block containing the\r\n        statements the <b>if/else</b> controls:\r\n<pre><b>  if test:\r\n      print('if (test): test was True');\r\n      real statements to do for True test\r\n  else:\r\n      print('if (test): test was False');\r\n      realstatements to do for False test</b></pre>\r\n  </ul>\r\nOf course we can use single stepping to see how Python is executing our code\r\n  in the Program window and see the values bound to the names in the Variables\r\n  window.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- The Eclipse Debugger -->\r\n\r\n<a name=\"EclipseDebugger\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Eclipse Debug Perspective</b></td>\r\n<td width =\"80%\">\r\nThe Eclipse Debug perspective helps automate some of the hand simulation\r\n  and program instrumentation needed to debug programs.\r\nIt allows us to do the equivalent of these without entering more code and\r\n    then rerunning our programs.\r\nDebuggers contain many powerful features allowing us to monitor the\r\n  execution of a program: both the location of the statement that it is\r\n  being executing, and the values bound to any names declared in the program.\r\n<p>\r\nSome programmers prefer to avoid using a debugger and instead instrument\r\n  their code carefully as they write it.\r\nOthers prefer to master the debugger, which they can use quickly to locate and\r\n   help correct many kinds of errors.\r\nA blend of the two approaches is probably best (but it takes some experience\r\n   to do that well).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  No problems for this lecture.\r\n  See the \r\n    <a href=\"../../../common/handouts/debugger.doc\">Eclipse Debugger</a>\r\n    handout for problems (the last page).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}