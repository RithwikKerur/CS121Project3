{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_6.html#SEC96", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Project 4--File Systems</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Project 4--File Systems\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Project 4--File Systems\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC85\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_5.html#SEC63\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_7.html#SEC100\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> 6. Project 4: File Systems </H1>\n<!--docid::SEC85::-->\n<P>\n\nIn the previous two assignments, you made extensive use of a\nfile system without actually worrying about how it was implemented\nunderneath.  For this last assignment, you will improve the\nimplementation of the file system.  You will be working primarily in\nthe <Q><TT>filesys</TT></Q> directory.\n</P>\n<P>\n\nYou may build project 4 on top of project 2 or project 3.  In either\ncase, all of the functionality needed for project 2 must work in your\nfilesys submission.  If you build on project 3, then all of the project\n3 functionality must work also, and you will need to edit\n<Q><TT>filesys/Make.vars</TT></Q> to enable VM functionality. You can receive up\nto 5% extra credit if you do enable VM.\n</P>\n<P>\n\n<A NAME=\"Project 4 Background\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC86\"></A>\n<H2> 6.1 Background </H2>\n<!--docid::SEC86::-->\n<P>\n\n<A NAME=\"File System New Code\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC87\"></A>\n<H3> 6.1.1 New Code </H3>\n<!--docid::SEC87::-->\n<P>\n\nHere are some files that are probably new to you.  These are in the\n<Q><TT>filesys</TT></Q> directory except where indicated:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>fsutil.c</TT></Q>\n<DD>Simple utilities for the file system that are accessible from the\nkernel command line.\n<P>\n\n</P>\n<DT><Q><TT>filesys.h</TT></Q>\n<DD><DT><Q><TT>filesys.c</TT></Q>\n<DD>Top-level interface to the file system.  See section <A HREF=\"pintos_4.html#SEC45\">4.1.2 Using the File System</A>,\nfor an introduction.\n<P>\n\n</P>\n<DT><Q><TT>directory.h</TT></Q>\n<DD><DT><Q><TT>directory.c</TT></Q>\n<DD>Translates file names to inodes.  The directory data structure is\nstored as a file.\n<P>\n\n</P>\n<DT><Q><TT>inode.h</TT></Q>\n<DD><DT><Q><TT>inode.c</TT></Q>\n<DD>Manages the data structure representing the layout of a\nfile's data on disk.\n<P>\n\n</P>\n<DT><Q><TT>file.h</TT></Q>\n<DD><DT><Q><TT>file.c</TT></Q>\n<DD>Translates file reads and writes to disk sector reads\nand writes.\n<P>\n\n</P>\n<DT><Q><TT>lib/kernel/bitmap.h</TT></Q>\n<DD><DT><Q><TT>lib/kernel/bitmap.c</TT></Q>\n<DD>A bitmap data structure along with routines for reading and writing\nthe bitmap to disk files.\n</DL>\n<P>\n\nOur file system has a Unix-like interface, so you may also wish to\nread the Unix man pages for <CODE>creat</CODE>, <CODE>open</CODE>, <CODE>close</CODE>,\n<CODE>read</CODE>, <CODE>write</CODE>, <CODE>lseek</CODE>, and <CODE>unlink</CODE>.  Our file\nsystem has calls that are similar, but not identical, to these.  The\nfile system translates these calls into disk operations.  \n</P>\n<P>\n\nAll the basic functionality is there in the code above, so that the\nfile system is usable from the start, as you've seen\nin the previous two projects.  However, it has severe limitations\nwhich you will remove.\n</P>\n<P>\n\nWhile most of your work will be in <Q><TT>filesys</TT></Q>, you should be\nprepared for interactions with all previous parts.\n</P>\n<P>\n\n<A NAME=\"Testing File System Persistence\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC88\"></A>\n<H3> 6.1.2 Testing File System Persistence </H3>\n<!--docid::SEC88::-->\n<P>\n\nBy now, you should be familiar with the basic process of running the\nPintos tests.  See section <A HREF=\"pintos_1.html#SEC8\">1.2.1 Testing</A>, for review, if necessary.\n</P>\n<P>\n\nUntil now, each test invoked Pintos just once.  However, an important\npurpose of a file system is to ensure that data remains accessible from\none boot to another.  Thus, the tests that are part of the file system\nproject invoke Pintos a second time.  The second run combines all the\nfiles and directories in the file system into a single file, then copies\nthat file out of the Pintos file system into the host (Unix) file\nsystem.\n</P>\n<P>\n\nThe grading scripts check the file system's correctness based on the\ncontents of the file copied out in the second run.  This means that your\nproject will not pass any of the extended file system tests until the\nfile system is implemented well enough to support <CODE>tar</CODE>, the\nPintos user program that produces the file that is copied out.  The\n<CODE>tar</CODE> program is fairly demanding (it requires both extensible\nfile and subdirectory support), so this will take some work.  Until\nthen, you can ignore errors from <CODE>make check</CODE> regarding the\nextracted file system.\n</P>\n<P>\n\nIncidentally, as you may have surmised, the file format used for copying\nout the file system contents is the standard Unix &quot;tar&quot; format.  You\ncan use the Unix <CODE>tar</CODE> program to examine them.  The tar file\nfor test <VAR>t</VAR> is named <Q><TT><VAR>t</VAR>.tar</TT></Q>.\n</P>\n<P>\n\n<A NAME=\"Project 4 Suggested Order of Implementation\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC89\"></A>\n<H2> 6.2 Suggested Order of Implementation </H2>\n<!--docid::SEC89::-->\n<P>\n\nTo make your job easier, we suggest implementing the parts of this\nproject in the following order:\n</P>\n<P>\n\n<OL>\n<LI>\nBuffer cache (see section <A HREF=\"pintos_6.html#SEC94\">6.3.4 Buffer Cache</A>).  Implement the buffer cache and\nintegrate it into the existing file system.  At this point all the\ntests from project 2 (and project 3, if you're building on it) should\nstill pass.\n<P>\n\n</P>\n<LI>\nExtensible files (see section <A HREF=\"pintos_6.html#SEC92\">6.3.2 Indexed and Extensible Files</A>).  After this\nstep, your project should pass the file growth tests.\n<P>\n\n</P>\n<LI>\nSubdirectories (see section <A HREF=\"pintos_6.html#SEC93\">6.3.3 Subdirectories</A>).  Afterward, your project\nshould pass the directory tests.\n<P>\n\n</P>\n<LI>\nRemaining miscellaneous items.\n</OL>\n<P>\n\nYou can implement extensible files and subdirectories in parallel if\nyou temporarily make the number of entries in new directories fixed.\n</P>\n<P>\n\nYou should think about synchronization throughout.\n</P>\n<P>\n\n<A NAME=\"Project 4 Requirements\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC90\"></A>\n<H2> 6.3 Requirements </H2>\n<!--docid::SEC90::-->\n<P>\n\n<A NAME=\"Project 4 Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC91\"></A>\n<H3> 6.3.1 Design Document </H3>\n<!--docid::SEC91::-->\n<P>\n\nBefore you turn in your project, you must copy <A HREF=\"filesys.tmpl\">the\nproject 4 design document template</A> into your source tree under the name\n<Q><TT>pintos/src/filesys/DESIGNDOC</TT></Q> and fill it in.  We recommend that\nyou read the design document template before you start working on the\nproject.  See section <A HREF=\"pintos_10.html#SEC152\">D. Project Documentation</A>, for a sample design document\nthat goes along with a fictitious project.\n</P>\n<P>\n\n<A NAME=\"Indexed and Extensible Files\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC92\"></A>\n<H3> 6.3.2 Indexed and Extensible Files </H3>\n<!--docid::SEC92::-->\n<P>\n\nThe basic file system allocates files as a single extent, making it\nvulnerable to external fragmentation, that is, it is possible that an\n<VAR>n</VAR>-block file cannot be allocated even though <VAR>n</VAR> blocks are\nfree.  Eliminate this problem by\nmodifying the on-disk inode structure.  In practice, this probably means using\nan index structure with direct, indirect, and doubly indirect blocks.\nYou are welcome to choose a different scheme as long as you explain the\nrationale for it in your design documentation, and as long as it does\nnot suffer from external fragmentation (as does the extent-based file\nsystem we provide).\n</P>\n<P>\n\nYou can assume that the file system partition will not be larger than\n8 MB.  You must\nsupport files as large as the partition (minus metadata).  Each inode is\nstored in one disk sector, limiting the number of block pointers that it\ncan contain.  Supporting 8 MB files will require you to implement\ndoubly-indirect blocks.\n</P>\n<P>\n\nAn extent-based file can only grow if it is followed by empty space, but\nindexed inodes make file growth possible whenever free space is\navailable.  Implement file growth.  In the basic file system, the file\nsize is specified when the file is created.  In most modern file\nsystems, a file is initially created with size 0 and is then expanded\nevery time a write is made off the end of the file.  Your file system\nmust allow this.\n</P>\n<P>\n\nThere should be no predetermined limit on the size of a file, except\nthat a file cannot exceed the size of the file system (minus metadata).  This\nalso applies to the root directory file, which should now be allowed\nto expand beyond its initial limit of 16 files.\n</P>\n<P>\n\nUser programs are allowed to seek beyond the current end-of-file (EOF).  The\nseek itself does not extend the file.  Writing at a position past EOF\nextends the file to the position being written, and any gap between the\nprevious EOF and the start of the write must be filled with zeros.  A\nread starting from a position past EOF returns no bytes.\n</P>\n<P>\n\nWriting far beyond EOF can cause many blocks to be entirely zero.  Some\nfile systems allocate and write real data blocks for these implicitly\nzeroed blocks.  Other file systems do not allocate these blocks at all\nuntil they are explicitly written.  The latter file systems are said to\nsupport &quot;sparse files.&quot;  You may adopt either allocation strategy in\nyour file system.\n</P>\n<P>\n\n<A NAME=\"Subdirectories\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC93\"></A>\n<H3> 6.3.3 Subdirectories </H3>\n<!--docid::SEC93::-->\n<P>\n\nImplement a hierarchical name space.  In the basic file system, all\nfiles live in a single directory.  Modify this to allow directory\nentries to point to files or to other directories.\n</P>\n<P>\n\nMake sure that directories can expand beyond their original size just\nas any other file can.  \n</P>\n<P>\n\nThe basic file system has a 14-character limit on file names.  You may\nretain this limit for individual file name components, or may extend\nit, at your option.  You must allow full path names to be\nmuch longer than 14 characters.\n</P>\n<P>\n\nMaintain a separate current directory for each process.  At\nstartup, set the root as the initial process's current directory.\nWhen one process starts another with the <CODE>exec</CODE> system call, the\nchild process inherits its parent's current directory.  After that, the\ntwo processes' current directories are independent, so that either\nchanging its own current directory has no effect on the other.\n(This is why, under Unix, the <CODE>cd</CODE> command is a shell built-in,\nnot an external program.)\n</P>\n<P>\n\nUpdate the existing system calls so that, anywhere a file name is\nprovided by the caller, an absolute or relative path name may used.\nThe directory separator character is forward slash (<Q><SAMP>/</SAMP></Q>).\nYou must also support special file names <Q><TT>.</TT></Q> and <Q><TT>..</TT></Q>, which\nhave the same meanings as they do in Unix.\n</P>\n<P>\n\nUpdate the <CODE>open</CODE> system call so that it can also open directories.\nOf the existing system calls, only <CODE>close</CODE> needs to accept a file\ndescriptor for a directory.\n</P>\n<P>\n\nUpdate the <CODE>remove</CODE> system call so that it can delete empty\ndirectories (other than the root) in addition to regular files.\nDirectories may only be deleted if they do not contain any files or\nsubdirectories (other than <Q><TT>.</TT></Q> and <Q><TT>..</TT></Q>).  You may decide\nwhether to allow deletion of a directory that is open by a process or in\nuse as a process's current working directory.  If it is allowed, then\nattempts to open files (including <Q><TT>.</TT></Q> and <Q><TT>..</TT></Q>) or create new\nfiles in a deleted directory must be disallowed.\n</P>\n<P>\n\nImplement the following new system calls:\n</P>\n<P>\n\n<A NAME=\"IDX19\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> bool <B>chdir</B> (const char *<VAR>dir</VAR>)\n<DD>Changes the current working directory of the process to\n<VAR>dir</VAR>, which may be relative or absolute.  Returns true if\nsuccessful, false on failure.\n</DL>\n<P>\n\n<A NAME=\"IDX20\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> bool <B>mkdir</B> (const char *<VAR>dir</VAR>)\n<DD>Creates the directory named <VAR>dir</VAR>, which may be\nrelative or absolute.  Returns true if successful, false on failure.\nFails if <VAR>dir</VAR> already exists or if any directory name in\n<VAR>dir</VAR>, besides the last, does not already exist.  That is,\n<CODE>mkdir(&quot;/a/b/c&quot;)</CODE> succeeds only if <Q><TT>/a/b</TT></Q> already exists and\n<Q><TT>/a/b/c</TT></Q> does not.\n</DL>\n<P>\n\n<A NAME=\"IDX21\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> bool <B>readdir</B> (int <VAR>fd</VAR>, char *<VAR>name</VAR>)\n<DD>Reads a directory entry from file descriptor <VAR>fd</VAR>, which must\nrepresent a directory.  If successful, stores the null-terminated file\nname in <VAR>name</VAR>, which must have room for <CODE>READDIR_MAX_LEN + 1</CODE>\nbytes, and returns true.  If no entries are left in the directory,\nreturns false.\n<P>\n\n<Q><TT>.</TT></Q> and <Q><TT>..</TT></Q> should not be returned by <CODE>readdir</CODE>.\n</P>\n<P>\n\nIf the directory changes while it is open, then it is acceptable for\nsome entries not to be read at all or to be read multiple times.\nOtherwise, each directory entry should be read once, in any order.\n</P>\n<P>\n\n<CODE>READDIR_MAX_LEN</CODE> is defined in <Q><TT>lib/user/syscall.h</TT></Q>.  If your\nfile system supports longer file names than the basic file system, you\nshould increase this value from the default of 14.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX22\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> bool <B>isdir</B> (int <VAR>fd</VAR>)\n<DD>Returns true if <VAR>fd</VAR> represents a directory,\nfalse if it represents an ordinary file.\n</DL>\n<P>\n\n<A NAME=\"IDX23\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> int <B>inumber</B> (int <VAR>fd</VAR>)\n<DD>Returns the <EM>inode number</EM> of the inode associated with <VAR>fd</VAR>,\nwhich may represent an ordinary file or a directory.\n<P>\n\nAn inode number persistently identifies a file or directory.  It is\nunique during the file's existence.  In Pintos, the sector number of the\ninode is suitable for use as an inode number.\n</P>\n</DL>\n<P>\n\nWe have provided <CODE>ls</CODE> and <CODE>mkdir</CODE> user programs, which\nare straightforward once the above syscalls are implemented.  \nWe have also provided <CODE>pwd</CODE>, which is not so straightforward.\nThe <CODE>shell</CODE> program implements <CODE>cd</CODE> internally.\n</P>\n<P>\n\nThe <CODE>pintos</CODE> <Q><SAMP>extract</SAMP></Q> and <Q><SAMP>append</SAMP></Q> commands should now\naccept full path names, assuming that the directories used in the\npaths have already been created.  This should not require any significant\nextra effort on your part.\n</P>\n<P>\n\n<A NAME=\"Buffer Cache\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC94\"></A>\n<H3> 6.3.4 Buffer Cache </H3>\n<!--docid::SEC94::-->\n<P>\n\nModify the file system to keep a cache of file blocks.  When a request\nis made to read or write a block, check to see if it is in the\ncache, and if so, use the cached data without going to\ndisk.  Otherwise, fetch the block from disk into the cache, evicting an\nolder entry if necessary.  You are limited to a cache no greater than 64\nsectors in size.\n</P>\n<P>\n\nYou must implement a cache replacement algorithm that is at least as\ngood as the &quot;clock&quot; algorithm.  We encourage you to account for\nthe generally greater value of metadata compared to data.  Experiment\nto see what combination of accessed, dirty, and other information\nresults in the best performance, as measured by the number of disk\naccesses.\n</P>\n<P>\n\nYou can keep a cached copy of the free map permanently in memory if you\nlike.  It doesn't have to count against the cache size.\n</P>\n<P>\n\nThe provided inode code uses a &quot;bounce buffer&quot; allocated with\n<CODE>malloc()</CODE> to translate the disk's sector-by-sector interface into\nthe system call interface's byte-by-byte interface.  You should get rid\nof these bounce buffers.  Instead, copy data into and out of sectors in\nthe buffer cache directly.\n</P>\n<P>\n\nYour cache should be <EM>write-behind</EM>, that is,\nkeep dirty blocks in the cache, instead of immediately writing modified\ndata to disk.  Write dirty blocks to disk whenever they are evicted.\nBecause write-behind makes your file system more fragile in the face of\ncrashes, in addition you should periodically write all dirty, cached\nblocks back to disk.  The cache should also be written back to disk in\n<CODE>filesys_done()</CODE>, so that halting Pintos flushes the cache.\n</P>\n<P>\n\nIf you have <CODE>timer_sleep()</CODE> from the first project working, write-behind is\nan excellent application.  Otherwise, you may implement a less general\nfacility, but make sure that it does not exhibit busy-waiting.\n</P>\n<P>\n\nYou should also implement <EM>read-ahead</EM>, that is,\nautomatically fetch the next block of a file\ninto the cache when one block of a file is read, in case that block is\nabout to be read.\nRead-ahead is only really useful when done asynchronously.  That means,\nif a process requests disk block 1 from the file, it should block until disk\nblock 1 is read in, but once that read is complete, control should\nreturn to the process immediately.  The read-ahead request for disk\nblock 2 should be handled asynchronously, in the background.\n</P>\n<P>\n\n<STRONG>We recommend integrating the cache into your design early.</STRONG>  In\nthe past, many groups have tried to tack the cache onto a design late in\nthe design process.  This is very difficult.  These groups have often\nturned in projects that failed most or all of the tests.\n</P>\n<P>\n\n<A NAME=\"File System Synchronization\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC95\"></A>\n<H3> 6.3.5 Synchronization </H3>\n<!--docid::SEC95::-->\n<P>\n\nThe provided file system requires external synchronization, that is,\ncallers must ensure that only one thread can be running in the file\nsystem code at once.  Your submission must adopt a finer-grained\nsynchronization strategy that does not require external synchronization.\nTo the extent possible, operations on independent entities should be\nindependent, so that they do not need to wait on each other.\n</P>\n<P>\n\nOperations on different cache blocks must be independent.  In\nparticular, when I/O is required on a particular block, operations on\nother blocks that do not require I/O should proceed without having to\nwait for the I/O to complete.\n</P>\n<P>\n\nMultiple processes must be able to access a single file at once.\nMultiple reads of a single file must be able to complete without\nwaiting for one another.  When writing to a file does not extend the\nfile, multiple processes should also be able to write a single file at\nonce.  A read of a file by one process when the file is being written by\nanother process is allowed to show that none, all, or part of the write\nhas completed.  (However, after the <CODE>write</CODE> system call returns to\nits caller, all subsequent readers must see the change.)  Similarly,\nwhen two processes simultaneously write to the same part of a file,\ntheir data may be interleaved.\n</P>\n<P>\n\nOn the other hand, extending a file and writing data into the new\nsection must be atomic.  Suppose processes A and B both have a given\nfile open and both are positioned at end-of-file.  If A reads and B\nwrites the file at the same time, A may read all, part, or none of what\nB writes.  However, A may not read data other than what B writes, e.g.\nif B's data is all nonzero bytes, A is not allowed to see any zeros.\n</P>\n<P>\n\nOperations on different directories should take place concurrently.\nOperations on the same directory may wait for one another.\n</P>\n<P>\n\nKeep in mind that only data shared by multiple threads needs to be\nsynchronized.  In the base file system, <CODE>struct file</CODE> and <CODE>struct dir</CODE>\nare accessed only by a single thread.\n</P>\n<P>\n\n<A NAME=\"Project 4 FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC96\"></A>\n<H2> 6.4 FAQ </H2>\n<!--docid::SEC96::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>How much code will I need to write?</B>\n<DD><P>\n\nHere's a summary of our reference solution, produced by the\n<CODE>diffstat</CODE> program.  The final row gives total lines inserted\nand deleted; a changed line counts as both an insertion and a deletion.\n</P>\n<P>\n\nThis summary is relative to the Pintos base code, but the reference\nsolution for project 4 is based on the reference solution to project 3.\nThus, the reference solution runs with virtual memory enabled.\nSee section <A HREF=\"pintos_5.html#SEC84\">5.4 FAQ</A>, for the summary of project 3.\n</P>\n<P>\n\nThe reference solution represents just one possible solution.  Many\nother solutions are also possible and many of those differ greatly from\nthe reference solution.  Some excellent solutions may not modify all the\nfiles modified by the reference solution, and some may modify files not\nmodified by the reference solution.\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre> Makefile.build       |    5 \n devices/timer.c      |   42 ++\n filesys/Make.vars    |    6 \n filesys/cache.c      |  473 +++++++++++++++++++++++++\n filesys/cache.h      |   23 +\n filesys/directory.c  |   99 ++++-\n filesys/directory.h  |    3 \n filesys/file.c       |    4 \n filesys/filesys.c    |  194 +++++++++-\n filesys/filesys.h    |    5 \n filesys/free-map.c   |   45 +-\n filesys/free-map.h   |    4 \n filesys/fsutil.c     |    8 \n filesys/inode.c      |  444 ++++++++++++++++++-----\n filesys/inode.h      |   11 \n threads/init.c       |    5 \n threads/interrupt.c  |    2 \n threads/thread.c     |   32 +\n threads/thread.h     |   38 +-\n userprog/exception.c |   12 \n userprog/pagedir.c   |   10 \n userprog/process.c   |  332 +++++++++++++----\n userprog/syscall.c   |  582 ++++++++++++++++++++++++++++++-\n userprog/syscall.h   |    1 \n vm/frame.c           |  161 ++++++++\n vm/frame.h           |   23 +\n vm/page.c            |  297 +++++++++++++++\n vm/page.h            |   50 ++\n vm/swap.c            |   85 ++++\n vm/swap.h            |   11 \n 30 files changed, 2721 insertions(+), 286 deletions(-)\n</pre></td></tr></table><P>\n\n</P>\n<DT><B>Can <CODE>BLOCK_SECTOR_SIZE</CODE> change?</B>\n<DD><P>\n\nNo, <CODE>BLOCK_SECTOR_SIZE</CODE> is fixed at 512.  For IDE disks, this\nvalue is a fixed property of the hardware.  Other disks do not\nnecessarily have a 512-byte sector, but for simplicity Pintos only\nsupports those that do.\n</DL>\n<P>\n\n<A NAME=\"Indexed Files FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC97\"></A>\n<H3> 6.4.1 Indexed Files FAQ </H3>\n<!--docid::SEC97::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>What is the largest file size that we are supposed to support?</B>\n<DD><P>\n\nThe file system partition we create will be 8 MB or smaller.  However,\nindividual files will have to be smaller than the partition to\naccommodate the metadata.  You'll need to consider this when deciding\nyour inode organization.\n</DL>\n<P>\n\n<A NAME=\"Subdirectories FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC98\"></A>\n<H3> 6.4.2 Subdirectories FAQ </H3>\n<!--docid::SEC98::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>How should a file name like <Q><SAMP>a//b</SAMP></Q> be interpreted?</B>\n<DD><P>\n\nMultiple consecutive slashes are equivalent to a single slash, so this\nfile name is the same as <Q><SAMP>a/b</SAMP></Q>.\n</P>\n<P>\n\n</P>\n<DT><B>How about a file name like <Q><SAMP>/../x</SAMP></Q>?</B>\n<DD><P>\n\nThe root directory is its own parent, so it is equivalent to <Q><SAMP>/x</SAMP></Q>.\n</P>\n<P>\n\n</P>\n<DT><B>How should a file name that ends in <Q><SAMP>/</SAMP></Q> be treated?</B>\n<DD><P>\n\nMost Unix systems allow a slash at the end of the name for a directory,\nand reject other names that end in slashes.  We will allow this\nbehavior, as well as simply rejecting a name that ends in a slash.\n</DL>\n<P>\n\n<A NAME=\"Buffer Cache FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC99\"></A>\n<H3> 6.4.3 Buffer Cache FAQ </H3>\n<!--docid::SEC99::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT><B>Can we keep a <CODE>struct inode_disk</CODE> inside <CODE>struct inode</CODE>?</B>\n<DD><P>\n\nThe goal of the 64-block limit is to bound the amount of cached file\nsystem data.  If you keep a block of disk data--whether file data or\nmetadata--anywhere in kernel memory then you have to count it against\nthe 64-block limit.  The same rule applies to anything that's\n&quot;similar&quot; to a block of disk data, such as a <CODE>struct inode_disk</CODE>\nwithout the <CODE>length</CODE> or <CODE>sector_cnt</CODE> members.\n</P>\n<P>\n\nThat means you'll have to change the way the inode implementation\naccesses its corresponding on-disk inode right now, since it currently\njust embeds a <CODE>struct inode_disk</CODE> in <CODE>struct inode</CODE> and reads the\ncorresponding sector from disk when it's created.  Keeping extra\ncopies of inodes would subvert the 64-block limitation that we place\non your cache.\n</P>\n<P>\n\nYou can store a pointer to inode data in <CODE>struct inode</CODE>, but if you do\nso you should carefully make sure that this does not limit your OS to 64\nsimultaneously open files.\nYou can also store other information to help you find the inode when you\nneed it.  Similarly, you may store some metadata along each of your 64\ncache entries.\n</P>\n<P>\n\nYou can keep a cached copy of the free map permanently in memory if you\nlike.  It doesn't have to count against the cache size.\n</P>\n<P>\n\n<CODE>byte_to_sector()</CODE> in <Q><TT>filesys/inode.c</TT></Q> uses the\n<CODE>struct inode_disk</CODE> directly, without first reading that sector from\nwherever it was in the storage hierarchy.  This will no longer work.\nYou will need to change <CODE>inode_byte_to_sector()</CODE> to obtain the\n<CODE>struct inode_disk</CODE> from the cache before using it.\n</DL>\n<A NAME=\"Reference Guide\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_6.html#SEC85\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_7.html#SEC100\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}