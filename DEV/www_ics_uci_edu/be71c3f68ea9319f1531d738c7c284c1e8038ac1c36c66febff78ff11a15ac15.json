{"url": "https://www.ics.uci.edu/~ejw/authoring/webdav-req-00.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<HTML>\n<HEAD>\n   <TITLE>Untitled</TITLE>\n   <META NAME=\"GENERATOR\" CONTENT=\"Mozilla/3.01Gold (WinNT; I) [Netscape]\">\n</HEAD>\n<BODY>\n\n<PRE>WEBDAV Working Group                                            J.A. Slein\nINTERNET-DRAFT                                                  Xerox Corporation\n&lt;draft-slein-www-dist-author-00.txt&gt;                            F. Vitali\n                                                                University of Bologna \n                                                                E.J. Whitehead, Jr.\n                                                                U.C. Irvine\n                                                                D.G. Durand\n                                                                Boston University\n                                                                February 28, 1997\n\nExpires August 28, 1997\n\n\n\n</PRE>\n\n<H2 ALIGN=CENTER>Requirements for Distributed Authoring and Versioning\n</H2>\n\n<H2 ALIGN=CENTER>on the World Wide Web<BR>\n</H2>\n\n<H3>Status of this Memo<BR>\n</H3>\n\n<P>This document is an Internet draft. Internet drafts are working documents\nof the Internet Engineering Task Force (IETF), its areas and its working\ngroups. Note that other groups may also distribute working information\nas Internet drafts.<BR>\n</P>\n\n<P>Internet Drafts are draft documents valid for a maximum of six months\nand can be updated, replaced or obsoleted by other documents at any time.\nIt is inappropriate to use Internet drafts as reference material or to\ncite them as other than as &quot;work in progress&quot;. <BR>\n</P>\n\n<P>To learn the current status of any Internet draft please check the &quot;lid-abstracts.txt&quot;\nlisting contained in the Internet drafts shadow directories on ftp.is.co.za\n(Africa), nic.nordu.net (Europe), munnari.oz.au (Pacific Rim), ds.internic.net\n(US East coast) or ftp.isi.edu (US West coast). Further information about\nthe IETF can be found at URL: http://www.ietf.org/<BR>\n</P>\n\n<P>Distribution of this document is unlimited. Please send comments to\nthe WWW Distributed Authoring and Versioning (WebDAV) mailing list, &lt;w3c-dist-auth@w3.org&gt;,\nwhich may be joined by sending a message with subject &quot;subscribe&quot;\nto &lt;w3c-dist-auth-request@w3.org&gt;. Discussions are archived at URL:\nhttp://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth/. </P>\n\n<H3>Abstract<BR>\n</H3>\n\n<P>Current World Wide Web (WWW or Web) standards provide simple support\nfor applications which allow remote editing of typed data. In practice,\nthe existing capabilities of the WWW have proven inadequate to support\nefficient, scalable remote editing free of overwriting conflicts. This\ndocument presents a list of features in the form of requirements </P>\n\n<P>which, if implemented, would improve the efficiency of common remote\nediting operations, provide a locking mechanism to prevent overwrite conflicts,\nimprove relationship management support between non-HTML data types, provide\na simple attribute-value metadata facility, provide for the creation and\nreading of container data types, and integrate versioning into the WWW.</P>\n\n<H3>1. Introduction<BR>\n</H3>\n\n<P>This document describes functionality which, if standardized in the\ncontext of the WWW, would allow tools for remote loading, editing and saving\n(publishing) of various media types on the WWW to interoperate with any\ncompliant Web server. As much as possible, this functionality is described\nwithout suggesting a proposed implementation, since there </P>\n\n<P>are many ways to perform the functionality within the WWW framework.\nIt could be implemented in extensions to HTTP, in a new protocol to be\nlayered on top of HTTP, in additional MIME types, or some combination of\nthese and other approaches. It is also possible that a single mechanism\ncould simultaneously satisfy several requirements. <BR>\n</P>\n\n<P>This document is intended to reflect the consensus of the WWW Distributed\nAuthoring and Versioning working group (WebDAV) as to the functionality\nthat needs to be standardized to support distributed authoring and versioning\non the Web. However, this version still has some elements that are being\ndebated in the working group. The following elements are still under discussion:\n<BR>\n</P>\n\n<UL>\n<LI>Whether attribute search should be in scope </LI>\n\n<LI>Whether support for partial-resource locking is needed </LI>\n\n<LI>Whether other lock types besides write locks are needed </LI>\n\n<LI>Semantics of locking </LI>\n\n<LI>Semantics of copy / move for resources with attributes or relationships,\nas well as for collections and version graphs </LI>\n\n<LI>Implications of attributes, relationships, collections, and versioning\nfor the HTTP DELETE method </LI>\n\n<LI>Semantics of removing resources from collections </LI>\n\n<LI>How to balance the goal of simplicity for clients against the wish\nto allow versioning servers to implement a variety of versioning policies\n</LI>\n\n<LI>Whether reservations are apart from versioning, or whether they make\nsense only in versioning systems </LI>\n\n<LI>Whether diff / merge are needed </LI>\n\n<LI>Which requirements are mandatory, and which are optional for a server\nto implement in order to be WebDAV-compliant </LI>\n</UL>\n\n<H3>2. Rationale<BR>\n</H3>\n\n<P>Current Web standards contain functionality which enables the editing\nof Web content at a remote location, without direct access to the storage\nmedia via an operating system. This capability is exploited by several\nexisting HTML distributed authoring tools, and by a growing number of mainstream\napplications (e.g., word processors) which allow users to </P>\n\n<P>write (publish) their work to an HTTP server. To date, experience from\nthe HTML authoring tools has shown they are unable to meet their users'\nneeds using the facilities of Web standards. The consequence of this is\neither postponed introduction of distributed authoring capability, or the\naddition of nonstandard extensions to the HTTP protocol [4] or other Web\nstandards. These extensions, developed in isolation, are not interoperable.<BR>\n</P>\n\n<P>Other authoring applications have wanted to access document repositories\nor version control systems through Web gateways, and have been similarly\nfrustrated. Where this access is available at all, it is through nonstandard\nextensions to HTTP or other standards that force clients to use a different\ninterface for each vendor's service. <BR>\n</P>\n\n<P>This document describes requirements for a set of standard extensions\nto the Web that would allow distributed Web authoring tools to provide\nthe functionality their users need by means of the same standard syntax\nacross all compliant servers. The broad categories of functionality that\nneed to be standardized are:<BR>\n</P>\n\n<UL>\n<LI>Attributes </LI>\n\n<LI>Relationships </LI>\n\n<LI>Locking </LI>\n\n<LI>Reservations </LI>\n\n<LI>Retrieval of Unprocessed Source </LI>\n\n<LI>Partial Write </LI>\n\n<LI>Name Space Manipulation </LI>\n\n<LI>Collections </LI>\n\n<LI>Versioning </LI>\n</UL>\n\n<H3>3. Terminology<BR>\n</H3>\n\n<P>Where there is overlap, usage is intended to be consistent with that\nin the HTTP 1.1 specification [4].<BR>\n</P>\n\n<DL>\n<DT>Attribute </DT>\n\n<DD><DFN>Named descriptive information about a resource.</DFN> </DD>\n\n<DT>Client </DT>\n\n<DD><DFN>A program which issues HTTP requests and accepts responses.</DFN>\n</DD>\n\n<DT>Collection </DT>\n\n<DD><DFN>A collection is a resource that contains other resources,either\ndirectly or by reference.</DFN> </DD>\n\n<DT>Distributed Authoring Tool </DT>\n\n<DD><DFN>A program which can retrieve a source entity via HTTP, allow editing\nof this entity, and then save/publish this entity to a server using HTTP.</DFN>\n</DD>\n\n<DT>Entity </DT>\n\n<DD><DFN>The information transferred in a request or response.</DFN> </DD>\n\n<DT>Hierarchical Collection </DT>\n\n<DD><DFN>A hierarchical organization of resources. A hierarchical collection\nis a resource that contains other resources, including collections, either\ndirectly or by reference.</DFN> </DD>\n\n<DT>Lock </DT>\n\n<DD><DFN>A mechanism for preventing anyone other than the owner of the\nlock from accessing a resource.</DFN> </DD>\n\n<DT>Member of Version Graph </DT>\n\n<DD><DFN>A resource that is a node in a version graph, and so is derived\nfrom the resources that precede it in the graph, and is the basis of those\nthat succeed it.</DFN> </DD>\n\n<DT>Relationship </DT>\n\n<DD><DFN>A typed connection between two or more resources.</DFN> </DD>\n\n<DT>Reservation </DT>\n\n<DD><DFN>A declaration to the server that one intends to edit a resource.</DFN>\n</DD>\n\n<DT>Resource </DT>\n\n<DD><DFN>A network data object or service that can be identified by a URI.</DFN>\n</DD>\n\n<DT>Server </DT>\n\n<DD><DFN>A program which receives and responds to HTTP requests.</DFN>\n</DD>\n\n<DT>Server Attribute </DT>\n\n<DD><DFN>An attribute whose value is generated by the server.</DFN> </DD>\n\n<DT>User Agent </DT>\n\n<DD><DFN>The client that initiates a request.</DFN> </DD>\n\n<DT>User Attribute </DT>\n\n<DD><DFN>An attribute whose value is provided by a user or a user agent.\n</DFN></DD>\n\n<DT>Version Graph </DT>\n\n<DD><DFN>A directed acyclic graph with resources as its nodes, where each\nnode is derived from its predecessor(s).</DFN> </DD>\n\n<DT>Write Lock </DT>\n\n<DD><DFN>A lock that prevents anyone except its owner from modifying the\nresource it applies to.</DFN> </DD>\n</DL>\n\n<H3>4. General Principles<BR>\n</H3>\n\n<P>This section describes a set of general principles that the WebDAV extensions\nshould follow. These principles cut across categories of functionality.</P>\n\n<H4>4.1. User Agent Interoperability<BR>\n</H4>\n\n<P>All WebDAV clients should be able to work with any WebDAV-compliant\nHTTP server. It is acceptable for some client/server combinations to provide\nspecial features that are not universally available, but the protocol should\nbe sufficient that a basic level of functionality will be universal. </P>\n\n<H4>4.2. Client Simplicity<BR>\n</H4>\n\n<P>The WebDAV extensions should be designed to allow client implementations\nto be simple. </P>\n\n<H4>4.3. Legacy Client Support<BR>\n</H4>\n\n<P>It should be possible to implement a WebDAV-compliant server in such\na way that it can interoperate with non-WebDAV clients. Such a server would\nbe able to understand any valid HTTP 1.1 request from an ordinary Web client\nwithout WebDAV extensions, and to provide a valid HTTP 1.1 response that\ndoes not require the client to understand the extensions. </P>\n\n<H4>4.4. Data Format Compatibility<BR>\n</H4>\n\n<P>WebDAV-compliant servers should be able to work with existing resources\nand URIs [2]. Special additional information should not become a mandatory\npart of document formats. </P>\n\n<H4>4.5. Replicated, Distributed Systems<BR>\n</H4>\n\n<P>Distribution and replication are at the heart of the Internet. All WebDAV\nextensions should be designed to allow for distribution and replication.\nVersion trees should be able to be split across multiple servers. Collections\nmay have members on different servers. Resources may have attributes on\ndifferent servers. Any resources may be cached or replicated for mobile\ncomputing or other reasons. Consequently, the WebDAV extensions must be\nable to operate in a distributed, replicated environment. </P>\n\n<H4>4.6 Parsimony in Client-Server Interactions <BR>\n</H4>\n\n<P>The WebDAV extensions should keep to a minimum the number of interactions\nbetween the client and the server needed to perform common functions. For\nexample, publishing a document to the Web will often mean publishing content\ntogether with related metadata. A client may often need to find out what\nversion graph a particular resource belongs to, or to find out which resource\nin a version graph is the published one. The extensions should make it\npossible to do these things efficiently. </P>\n\n<H4>4.7. Alternate Transport Mechanisms<BR>\n</H4>\n\n<P>It may be desirable to transport WebDAV requests and responses by other\nmechanisms, particularly EMail, in addition to HTTP. The design of the\nWebDAV extensions should take alternative transports into account. </P>\n\n<H3>5. Requirements<BR>\n</H3>\n\n<P>In the requirement descriptions below, the requirement will be stated,\nfollowed by its rationale. </P>\n\n<H4>5.1. Attributes </H4>\n\n<H4>5.1.1. Functional Requirements<BR>\n</H4>\n\n<P>It must be possible to create, modify, query, read and delete arbitrary\nattributes on resources of any media type.<BR>\n</P>\n\n<P>Attributes are resources that may have attributes of their own, may\nbe subject to content negotiation, etc.<BR>\n</P>\n\n<P>Attributes have implications for the semantics of move, copy, and delete\noperations. See &quot;5.7. Name Space Manipulation&quot; below. </P>\n\n<H4>5.1.2. Rationale <BR>\n</H4>\n\n<P>Attributes describe resources of any media type. They may include bibliographic\ninformation such as author, title, publisher, and subject, constraints\non usage, PICS ratings, etc. These attributes have many uses, such as supporting\nsearches on attribute values, enforcing copyrights, and the creation of\ncatalog entries as placeholders for objects which are not available in\nelectronic form, or which will be available later. </P>\n\n<H4>5.2. Relationships </H4>\n\n<H4>5.2.1. Functional Requirements<BR>\n</H4>\n\n<P>It must be possible to create, modify, query, read and delete typed\nrelationships between resources of any media type.<BR>\n</P>\n\n<P>Relationships have implications for the semantics of move, copy, and\ndelete operations. See &quot;5.7. Name Space Manipulation&quot; below.</P>\n\n<H4>5.2.2. Rationale <BR>\n</H4>\n\n<P>One type of relationship between resources is the hypertext link, which\nis browsable using a hypertext style point-and-click user interface. Relationships,\nwhether they are browsable hypertext links, or simply a means of capturing\na connection between resources, have many purposes. Relationships can support\npushbutton printing of a multi-resource document in a prescribed order,\njumping to the access control page for a resource, and quick browsing of\nrelated information, such as a table of contents, an index, a glossary,\nhelp pages, etc. While relationship support is provided by the HTML &quot;LINK&quot;\nelement, this is limited only to HTML resources [1]. Similar support is\nneeded for bitmap image types, and other non-HTML media types. </P>\n\n<H4>5.3. Locking </H4>\n\n<H4>5.3.1. General Principles<BR>\n</H4>\n\n<P><B>5.3.1.1. Independence of locks.</B> It must be possible to lock a\nresource without re-reading the resource, and without committing to editing\nthe resource.<BR>\n</P>\n\n<P><B>5.3.1.2. Multi-Resource Locking.</B> It must be possible to take\nout a lock on multiple resources in the same action, and this locking operation\nmust be atomic across these resources. <BR>\n</P>\n\n<P><B>5.3.1.3. Partial-Resource Locking.</B> It must be possible to take\nout a lock on a subsection of a resource.<BR>\n</P>\n\n<P><B>5.3.1.4. Optional Server Support for Locking.</B> Some systems use\nother mechanisms besides locking to ensure consistency in environments\nwhere several users may wish to edit a resource at once. These other strategies\nmust be permitted. </P>\n\n<H4>5.3.2. Functional Requirements<BR>\n</H4>\n\n<P><B>5.3.2.1. Write Locks. </B>It must be possible to restrict modification\nof a resource to a specific person.<BR>\n</P>\n\n<P><B>5.3.2.2. Lock Query.</B> It must be possible to find out whether\na given resource has any active modification restrictions, and if so, who\ncurrently has modification permission.<BR>\n</P>\n\n<P><B>5.3.2.3. Unlock.</B> It must be possible to remove a lock. Only the\nowner of a lock or a principal with appropriate access rights may remove\nthe lock. </P>\n\n<H4>5.3.3. Rationale<BR>\n</H4>\n\n<P>At present, the Web provides limited support for preventing two or more\npeople from overwriting each other's modifications when they save to a\ngiven URI. Furthermore, there is no way to discover whether someone else\nis currently making modifications to a resource. This is known as the &quot;lost\nupdate problem,&quot; or the &quot;overwrite problem.&quot; Since there\ncan be significant cost associated with discovering and repairing lost\nmodifications, preventing this problem is crucial for supporting distributed\nauthoring. A write lock ensures that only one person may modify a resource,\npreventing overwrites. Furthermore, locking support is a key component\nof many versioning schemes, a desirable capability for distributed authoring.<BR>\n</P>\n\n<P>An author may wish to lock an entire web of resources even though he\nis editing just a single resource, to keep the other resources from changing.\nIn this way, an author can ensure that if a local hypertext web is consistent\nin his distributed authoring tool, it will then be consistent when he writes\nit to the server. Because of this, it should be possible to take out a\nlock without also causing transmission of the contents of a resource.<BR>\n</P>\n\n<P>It is often necessary to guarantee that a lock or unlock operation occurs\nat the same time across multiple resources, a feature which is supported\nby the multiple-resource locking requirement. This is useful for preventing\na collision between two people trying to establish locks on the same set\nof resources, since with multi-resource locking, one of the two people\nwill get a lock. If this same multiple-resource locking scenario was repeated\nby using atomic lock operations iterated across the resources, the result\nwould be a splitting of the locks between the two people, based on resource\nordering and race conditions.<BR>\n</P>\n\n<P>Partial resource locking provides support for collaborative editing\napplications, where multiple users may be editing the same resource simultaneously.\nPartial resource locking also allows multiple people to simultaneously\nwork on a database type resource. </P>\n\n<H4>5.4. Reservations </H4>\n\n<H4>5.4.1. Functional Requirements <BR>\n</H4>\n\n<P><B>5.4.1.1. Reserve.</B> It must be possible to notify the server that\na resource is about to be edited by a given person.<BR>\n</P>\n\n<P><B>5.4.1.2. Reservation Query.</B> It must be possible to find out whether\na given resource has any active reservations, and if so, who currently\nholds reservations.<BR>\n</P>\n\n<P><B>5.4.1.3. Release Reservation.</B> It must be possible to release\nthe reservation. Only the owner of a reservation or a principal with appropriate\naccess rights may release the reservation. </P>\n\n<H4>5.4.2. Rationale<BR>\n</H4>\n\n<P>Experience from configuration management systems has shown that people\nneed to know when they are about to enter a parallel editing situation.\nOnce notified, they either decide not to edit in parallel with the other\nauthors, or they use out-of-band communication (face-to-face, telephone,\netc.) to coordinate their editing to minimize the difficulty of merging\ntheir results. Reservations are separate from locking, since a write lock\ndoes not necessarily imply a resource will be edited, and a reservation\ndoes not carry with it any access restrictions. This capability supports\nversioning, since a check-out typically involves taking out a write lock,\nmaking a reservation, and getting the resource to be edited. </P>\n\n<H4>5.5. Retrieval of Unprocessed Source for Editing </H4>\n\n<H4>5.5.1. Functional Requirement<BR>\n</H4>\n\n<P>The source of any given resource must be retrievable. </P>\n\n<H4>5.5.2. Rationale<BR>\n</H4>\n\n<P>There are many cases where the source stored on a server does not correspond\nto the actual entity transmitted in response to an HTTP GET. Current known\ncases are server side include directives, and Standard Generalized Markup\nLanguage (SGML) source which is converted on the fly to HyperText Markup\nLanguage (HTML) [1] output entities. There are many possible cases, such\nas automatic conversion of bitmap images into several variant bitmap media\ntypes (e.g. GIF, JPEG), and automatic conversion of an application's native\nmedia type into HTML. As an example of this last case, a word processor\ncould store its native media type on a server which automatically converts\nit to HTML. A GET of this resource would retrieve the HTML. Retrieving\nthe source would retrieve the word processor native format.<BR>\n</P>\n\n<P>This requirement should be met by a general mechanism which can handle\nboth the &quot;single-step&quot; source processing described above, where\nthe source is converted into the transmission entity via a single conversion\nstep, as well as &quot;multi-step&quot; source processing, where there\nare one or more intermediate processing steps and outputs. An example of\nmulti-step source processing is the relationship between an executable\nbinary image, its object files, and its source language files. It should\nbe noted that the relationship between source and transmission entity could\nbe expressed using the relationship functionality described above in &quot;5.2.\nRelationships.&quot; </P>\n\n<H4>5.6. Partial Write. </H4>\n\n<H4>5.6.1. Functional Requirement <BR>\n</H4>\n\n<P>After editing a resource, it must be possible to write only the changes\nto the resource, rather than retransmitting the entire resource. </P>\n\n<H4>5.6.2. Rationale<BR>\n</H4>\n\n<P>During distributed editing which occurs over wide geographic separations\nand/or over low bandwidth connections, it is extremely inefficient and\nfrustrating to rewrite a large resource after minor changes, such as a\none-character spelling correction. Support is needed for transmitting &quot;insert&quot;\n(e.g., add this sentence in the middle of a document) and &quot;delete&quot;\n(e.g. remove this paragraph from the middle of a document) style updates.\nSupport for partial resource updates will make small edits more efficient,\nand allow distributed authoring tools to scale up for editing large documents.</P>\n\n<H4>5.7. Name Space Manipulation </H4>\n\n<H4>5.7.1. Copy </H4>\n\n<H4>5.7.1.1. Functional Requirements <BR>\n</H4>\n\n<P>It must be possible to duplicate a resource without a client loading,\nthen resaving the resource. After the copy operation, the content of the\ndestination resource must be octet for octet identical to the content of\nthe source resource. A modification to either resource must not cause a\nmodification to the other. The copy operation should leave an audit trail.<BR>\n</P>\n\n<P>It must be possible for a client to specify whether a resource's user\nattributes and relationships are to be copied with it, although the server\nmay decline to copy them. It may decline to copy user attributes if the\ndestination namespace supports different attributes from the source namespace,\nfor example. The server may follow whatever policy it likes for copying\nserver attributes.<BR>\n</P>\n\n<P>Copying a collection causes all of the resources that belong to it directly\nto be copied as well. For resources that belong to it by reference, the\nreference is copied. It must be possible for a client to specify whether\nsubcollections should be copied with the collection. <BR>\n</P>\n\n<P>If a version graph is copied, all relationships between nodes in the\ngraph must be changed in the new copy to reflect its new location. </P>\n\n<H4>5.7.1.2. Rationale<BR>\n</H4>\n\n<P>There are many reasons why a resource might need to be duplicated, such\nas changing ownership, preparing for major modifications, or making a backup.\nDue to network costs associated with loading and saving a resource, it\nis far preferable to have a server perform a resource copy than a client.\nIf a copied resource records which resource it is a copy of, then it would\nbe possible for a cache to avoid loading the copied resource if it already\nlocally stores the original. </P>\n\n<H4>5.7.2. Move/Rename </H4>\n\n<H4>5.7.2.1. Functional Requirements <BR>\n</H4>\n\n<P>It must be possible to change the location of a resource without a client\nloading, then resaving the resource under a different name. After the move\noperation, the content of the resource at its new location must be octet\nfor octet identical to the content of the prior resource. It must no longer\nbe possible to access the resource at its original location. The move operation\nshould leave an audit trail. <BR>\n</P>\n\n<P>It must be possible for a client to specify whether a resource's user\nattributes and relationships are to be moved with it, although the server\nmay decline to move them. It may decline to move user attributes if the\ndestination namespace supports different attributes from the source namespace,\nfor example. The server may follow whatever policy it likes for server\nattributes.<BR>\n</P>\n\n<P>Moving a collection causes all of the resources that belong to it directly\nto be moved as well. For resources that belong to it by reference, the\nreference is moved. It must be possible for a client to specify whether\nsubcollections should be moved with the collection. If not, subcollections\nthat belong to the collection directly should be deleted from the source\nlocation.<BR>\n</P>\n\n<P>If a version graph is moved, all relationships between nodes in the\ngraph must be changed in the destination resource to reflect its new location.</P>\n\n<H4>5.7.2.2. Rationale<BR>\n</H4>\n\n<P>It is often necessary to change the name of a resource, for example\ndue to adoption of a new naming convention, or if a typing error was made\nentering the name originally. Due to network costs, it is undesirable to\nperform this operation by loading, then resaving the resource, followed\nby a delete of the old resource. Similarly, a single rename operation is\nmore efficient than a copy followed by a delete operation. Note that moving\na resource is considered the same function as renaming a resource. The\naudit trail makes it possible for the server to redirect client requests\nfor the resource at its old location, perhaps with a &quot;301 Moved Permanently&quot;\nstatus code. </P>\n\n<H4>5.7.3. Delete<BR>\n</H4>\n\n<P>HTTP already provides a DELETE method, but the semantics of DELETE must\nbe reconsidered once attributes, relations, collections, and versions are\nintroduced.<BR>\n</P>\n\n<P>When a resource is deleted, it must be possible for a client to specify\nwhether a its attributes are to be deleted with it. In an environment where\nresources may share the same attributes, the server may decline to delete\nthe attributes.<BR>\n</P>\n\n<P>When a resource is deleted, the relationships in which it participates\nshould also be deleted.<BR>\n</P>\n\n<P>If the resource being deleted is a collection, all resources that belong\nto it directly will be deleted as well. Resources that belong to it by\nreference are unaffected.<BR>\n</P>\n\n<P>If the resource being deleted is a member of a version graph, the predecessor\nand successor relationships in the graph must be updated, and any metadata\nrequired by the versioning server must be supplied. The versioning server\nmay, for example, require a comment explaining the reason for the deletion.</P>\n\n<H4>5.8. Collections<BR>\n</H4>\n\n<P>A collection is a resource that is a container for other resources,\nincluding other collections. A resource may belong to a collection\neither directly or by reference. If a resource belongs to a collection\ndirectly, namespace operations like copy, move, and delete applied to\nthe collection also apply to the resource. If a resource belongs to a\ncollection by reference, namespace operations applied to the\ncollection affect only the reference, not the resource itself. </P>\n\n<H4>5.8.1. Functional Requirements<BR>\n</H4>\n\n<P><B>5.8.1.1. List Collection.</B> A listing of all resources in a specific\ncollection must be accessible.<BR>\n</P>\n\n<P><B>5.8.1.2. Make Collection.</B> It must be possible to create a new\ncollection.<BR>\n</P>\n\n<P><B>5.8.1.3. Add to Collection.</B> It must be possible to add a resource\nto a collection directly or by reference.<BR>\n</P>\n\n<P><B>5.8.1.4. Remove from Collection.</B> It must be possible to remove\na resource from a collection. In the case of a resource that belongs to\nthe collection directly, this results in the resource being deleted. In\nthe case of a resource that is merely referenced by the collection, only\nthe reference is removed.<BR>\n</P>\n\n<P><B>5.8.1.5. </B>Collections have implications for the semantics of move,\ncopy, and delete operations. See &quot;5.7. Name Space Manipulation&quot;\nabove. </P>\n\n<H4>5.8.2. Rationale<BR>\n</H4>\n\n<P>In [2] it states that, &quot;some URL schemes (such as the ftp, http,\nand file schemes) contain names that can be considered hierarchical.&quot;\nEspecially for HTTP servers which directly map all or part of their URL\nname space into a filesystem, it is very useful to get a listing of all\nresources located at a particular hierarchy level. This functionality supports\n&quot;Save As...&quot; dialog boxes, which provide a listing of the entities\nat a current hierarchy level, and allow navigation through the hierarchy.\nIt also supports the creation of graphical visualizations (typically as\na network) of the hypertext structure among the entities at a hierarchy\nlevel, or set of levels. It also supports a tree visualization of the entities\nand their hierarchy levels.<BR>\n</P>\n\n<P>In addition, document management systems may want to make their documents\naccessible through the Web. They typically allow the organization of documents\ninto collections, and so also want their users to be able to view the collection\nhierarchy through the Web.<BR>\n</P>\n\n<P>There are many instances where there is not a strong correlation between\na URL hierarchy level and the notion of a collection. One example is a\nserver in which the URL hierarchy level maps to a computational process\nwhich performs some resolution on the name. In this case, the contents\nof the URL hierarchy level can vary depending on the input to the computation,\nand the number of resources accessible via the computation can be very\nlarge. It does not make sense to implement a directory feature for such\na namespace. However, the utility of listing the contents of those URL\nhierarchy levels which do correspond to collections, such as the large\nnumber of HTTP servers which map their namespace to a filesystem, argue\nfor the inclusion of this capability, despite not being meaningful in all\ncases. If listing the contents of a URL hierarchy level does not makes\nsense for a particular URL, then a &quot;405 Method Not Allowed&quot; status\ncode could be issued. <BR>\n</P>\n\n<P>The ability to create collections to hold related resources supports\nmanagement of a name space by packaging its members into small, related\nclusters. The utility of this capability is demonstrated by the broad implementation\nof directories in recent operating systems. The ability to create a collection\nalso supports the creation of &quot;Save As...&quot; dialog boxes with\n&quot;New Level/Folder/Directory&quot; capability, common in many applications.</P>\n\n<H4>5.9. Versioning </H4>\n\n<H4>5.9.1. Background and General Principles<BR>\n</H4>\n\n<P><B>5.9.1.1. Stability of versions.</B> Most versioning systems are intended\nto provide an accurate record of the history of evolution of a document.\nThis accuracy is ensured by the fact that a version eventually becomes\n&quot;frozen&quot; and immutable. Once a version is frozen, further changes\nwill create new versions rather than modifying the original. In order for\ncaching and persistent references to be properly maintained, a client must\nbe able to determine that a version has been frozen. Any successful attempt\nto retrieve a frozen version of a resource will always retrieve exactly\nthe same content, or return an error if that version (or the resource itself)\nis no longer available. </P>\n\n<H4>5.9.1.2. Operations for Creating New Versions<BR>\n</H4>\n\n<P>Version management systems vary greatly in the operations they require,\nthe order of the operations, and how they are combined into atomic functions.\nIn the most complete cases, the logical operations involved are: </P>\n\n<UL>\n<LI>Reserve existing version </LI>\n\n<LI>Lock existing version </LI>\n\n<LI>Retrieve existing version </LI>\n\n<LI>Request or suggest identifier for new version </LI>\n\n<LI>Write new version </LI>\n\n<LI>Release lock </LI>\n\n<LI>Release reservation </LI>\n</UL>\n\n<P>With the exception of requesting a new version identifier, all of these\noperations have applications outside of versioning and are either already\npart of HTTP or are discussed in earlier sections of these requirements.\nTypically, versioning systems combine reservation, locking, and retrieval\n-- or some subset of these -- into an atomic checkout function. They combine\nwriting, releasing the lock, and releasing the reservation -- or some subset\nof these -- into an atomic checkin function. The new version identifier\nmay be assigned either at checkout or at checkin.<BR>\n</P>\n\n<P>The WebDAV extensions must find some balance between allowing versioning\nservers to adopt whatever policies they wish with regard to these operations\nand enforcing enough uniformity to keep client implementations simple.</P>\n\n<H4>5.9.1.3. The Versioning Model<BR>\n</H4>\n\n<P>Each version typically stands in a &quot;derived from&quot; relationship\nto its predecessor(s). It is possible to derive several different versions\nfrom a single version (branching), and to derive a single version from\nseveral versions (merging). Consequently, the collection of related versions\nforms a directed acyclic graph. In the following discussion, this graph\nwill be called a &quot;version graph&quot;. Each node of this graph is\na &quot;version&quot; or &quot;member of the version graph&quot;. The arcs\nof the graph capture the &quot;derived from&quot; relationships.<BR>\n</P>\n\n<P>It is also possible for a single resource to participate in multiple\nversion graphs.<BR>\n</P>\n\n<P>The WebDAV extensions must support this versioning model, though particular\nservers may restrict it in various ways.<BR>\n</P>\n\n<P><B>5.9.1.4. Versioning Policies.</B> Many writers, including Feiler\n[3] and Haake and Hicks [5], have discussed the notion of versioning styles\n(referred to here as versioning policies, to reflect the nature of client/server\ninteraction) as one way to think about the different policies that versioning\nsystems implement. Versioning policies include decisions on the shape of\nversion histories (linear or branched), the granularity of change tracking,\nlocking requirements made by a server, etc. The protocol should clearly\nidentify the policies that it dictates and the policies that are left up\nto versioning system implementors or administrators.<BR>\n</P>\n\n<P><B>5.9.1.5.</B> It is possible to version resources of any media type.</P>\n\n<H4>5.9.2. Functional Requirements<BR>\n</H4>\n\n<P><B>5.9.2.1. Referring to a version graph.</B> There must be a way to\nrefer to a version graph as a whole. <BR>\n</P>\n\n<P>Some queries and operations apply, not to any one member of a version\ngraph, but to the version graph as a whole. For example, a client may request\nthat an entire graph be moved, or may ask for a version history. In these\ncases, a way to refer to the whole version graph is required.<BR>\n</P>\n\n<P><B>5.9.2.2. Referring to a specific member of a version graph.</B> There\nmust be a way to refer to each member of a version graph. This means that\neach member of the graph is itself a resource. <BR>\n</P>\n\n<P>Each member of a version graph must be a resource if it is to be possible\nfor a hypertext link to refer to specific version of a page, or for a client\nto request a specific version of a document for editing.<BR>\n</P>\n\n<P><B>5.9.2.3.</B> A client must be able to determine whether a resource\nis a version graph, or whether a resource is itself a member of a version\ngraph.<BR>\n</P>\n\n<P>A resource may be a simple, non-versioned resource, or it may be a version\ngraph, or it may be a member of a version graph. A client needs to be able\nto tell which sort of resource it is accessing.<BR>\n</P>\n\n<P><B>5.9.2.4.</B> There must be a way to refer to a server-defined default\nmember of a version graph.<BR>\n</P>\n\n<P>The server should return a default version of a resource for requests\nthat ask for the default version, as well as for requests where no specific\nversion information is provided. This is one of the simplest ways to guarantee\nnon-versioning client compatibility. This does not rule out the possibility\nof a server returning an error when no sensible default exists.<BR>\n</P>\n\n<P>It may also be desirable to be able to refer to other special members\nof a version graph. For example, there may be a current version for editing\nthat is different from the default version. For a graph with several branches,\nit may be useful to be able to request the tip version of any branch.<BR>\n</P>\n\n<P><B>5.9.2.5.</B> It must be possible, given a reference to a member of\na version graph, to find out which version graph(s) that resource belongs\nto.<BR>\n</P>\n\n<P>This makes it possible to understand the versioning context of the resource.\nIt makes it possible to retrieve a version history for the graphs to which\nit belongs, and to browse the version graph. It also supports some comparison\noperations: It makes it possible to determine whether two references designate\nmembers of the same version graph. <BR>\n</P>\n\n<P><B>5.9.2.6. Navigation of a version graph.</B> Given a reference to\na member of a version graph, it must be possible to discover and access\nthe following related members of the version graph. </P>\n\n<UL>\n<LI>root member of the graph </LI>\n\n<LI>predecessor member(s) </LI>\n\n<LI>successor member(s) </LI>\n\n<LI>default member of the graph </LI>\n</UL>\n\n<P>It must be possible in some way for a versioning client to access versions\nrelated to a resource currently being exhamined.<BR>\n</P>\n\n<P><B>5.9.2.7. Version Topology. </B>There must be a way to retrieve the\ncomplete version topology for a version graph, including information about\nall members of the version graph. The format for this information must\nbe standardized so that the basic information can be used by all clients.\nOther specialized formats should be accomodated, for servers and clients\nthat require information that cannot be included in the standard topology.<BR>\n</P>\n\n<P><B>5.9.2.8.</B> A client must be able to request that the server generate\na version identifier for a new member of a version graph. Such an identifier\nwill not be used by any other client in the meantime. The server may refuse\nthe request.<BR>\n</P>\n\n<P><B>5.9.2.9.</B> A client must be able to propose a version identifier\nto be used for a new member of a version graph. The server may refuse to\nuse the client's suggested version identifier.<BR>\n</P>\n\n<P><B>5.9.2.10.</B> A version identifier must be unique across a version\ngraph.<BR>\n</P>\n\n<P><B>5.9.2.11.</B> A client must be able to supply version-specific metadata\nto be associated with a new member of a version graph. (See Section 5.1\n&quot;Attributes&quot; above.) At a minimum, it must be possible to associate\ncomments with the new member, explaining what changes were made. <BR>\n</P>\n\n<P><B>5.9.2.12.</B> A client must be able to query the server for information\nabout a version tree, including which versions are locked, which are reserved\nfor editing, and by whom (Session Tracking). <BR>\n</P>\n\n<P><B>5.9.2.13.</B> It must be possible for a client to get from the server\na list of the differences between two or more resources of the same media\ntype.<BR>\n</P>\n\n<P><B>5.9.2.14.</B> A client must be able to request that the server merge\ntwo or more resources, and return the result of the merge to the client\nor store the result as a resource. Server support for this functionality\nis optional.<BR>\n</P>\n\n<P><B>5.9.2.15.</B> Versioning has implications for the semantics of move,\ncopy, and delete operations. See &quot;5.7. Name Space Manipulation&quot;\nabove. In addition, if the WebDAV extensions allow versioning servers to\nPUT or POST new members into a version graph, the semantics of those methods\nmust be extended to encompass the new functionality. </P>\n\n<H4>5.9.3. Rationale<BR>\n</H4>\n\n<P>Versioning in the context of the world-wide web offers a variety of\nbenefits:<BR>\n</P>\n\n<P>It provides infrastructure for efficient and controlled management of\nlarge evolving web sites. Modern configuration management systems are built\non some form of repository that can track the revision history of individual\nresources, and provide the higher-level tools to manage those saved versions.\nBasic versioning capabilities are required to support such systems.<BR>\n</P>\n\n<P>It allows parallel development and update of single resources. Since\nversioning systems register change by creating new objects, they enable\nsimultaneous write access by allowing the creation of variant versions.\nMany also provide merge support to ease the reverse operation.<BR>\n</P>\n\n<P>It provides a framework for coordinating changes to resources. While\nspecifics vary, most systems provide some method of controlling or tracking\naccess to enable collaborative resource development. <BR>\n</P>\n\n<P>It allows browsing through past and alternative versions of a resource.\nFrequently the modification and authorship history of a resource is critical\ninformation in itself.<BR>\n</P>\n\n<P>It provides stable names that can support externally stored links for\nannotation and link-server support. Both annotation and link servers frequently\nneed to store stable references to portions of resources that are not under\ntheir direct control. By providing stable states of resources, version\ncontrol systems allow not only stable pointers into those resources, but\nalso well-defined methods to determine the relationships of those states\nof a resource. <BR>\n</P>\n\n<P>It allows explicit semantic representation of single resources with\nmultiple states. A versioning system directly represents the fact that\na resource has an explicit history, and a persistent identity across the\nvarious states it has had during the course of that history. </P>\n\n<H4>5.10. Authentication and Security<BR>\n</H4>\n\n<P>The WebDAV extensions should make use of existing authentication and\nsecurity protocols. The WebDAV specification must state how the WebDAV\nextensions interoperate with existing authentication and security schemes.</P>\n\n<H3>6. Acknowledgements<BR>\n</H3>\n\n<P>Our understanding of these issues has emerged as the result of much\nthoughtful discussion, email, and assistance by many people, who deserve\nrecognition for their effort.<BR>\n</P>\n\n<UL>\n<LI>Martin Cagan, Continuus Software, Marty_Cagan@continuus.com </LI>\n\n<LI>Steve Carter, Novell, srcarter@novell.com </LI>\n\n<LI>Dan Connolly, World Wide Web Consortium, connolly@w3.org </LI>\n\n<LI>Jim Cunningham, Netscape, jfc@netscape.com </LI>\n\n<LI>Mark Day, Lotus, Mark_Day@lotus.com </LI>\n\n<LI>Assad Faizi, Netscape, asad@netscape.com </LI>\n\n<LI>Ron Fein, Microsoft, ronfe@microsoft.com </LI>\n\n<LI>David Fiander, Mortice Kern Systems, davidf@mks.com </LI>\n\n<LI>Roy Fielding, U.C. Irvine, fielding@ics.uci.edu </LI>\n\n<LI>Yaron Goland, Microsoft, yarong@microsoft.com </LI>\n\n<LI>Phill Hallam-Baker, MIT, hallam@ai.mit.edu </LI>\n\n<LI>Dennis Hamilton, Xerox PARC, hamilton@parc.xerox.com </LI>\n\n<LI>Andre van der Hoek, University of Colorado, Boulder, andre@bigtime.cs.colorado.edu\n</LI>\n\n<LI>Del Jensen, Novell, dcjensen@novell.com </LI>\n\n<LI>Gail Kaiser, Columbia University, kaiser@cs.columbia.edu </LI>\n\n<LI>Rohit Khare, World Wide Web Consortium, khare@w3.org </LI>\n\n<LI>Dave Long, America Online, dave@sb.aol.com </LI>\n\n<LI>Henrik Frystyk Nielsen, World Wide Web Consortium, frystyk@w3.org </LI>\n\n<LI>Ora Lassila, Nokia Research Center, ora.lassila@research.nokia.com\n</LI>\n\n<LI>Larry Masinter, Xerox PARC, masinter@parc.xerox.com </LI>\n\n<LI>Murray Maloney, SoftQuad, murray@sq.com </LI>\n\n<LI>Jim Miller, World Wide Web Consortium, jmiller@w3.org </LI>\n\n<LI>Keith Moore, University of Tennessee, Knoxville, moore@cs.utk.edu </LI>\n\n<LI>Andrew Schulert, Microsoft, andyschu@microsoft.com </LI>\n\n<LI>Christopher Seiwald, Perforce Software, seiwald@perforce.com </LI>\n\n<LI>Einar Stefferud, stef@nma.com </LI>\n\n<LI>Richard Taylor, U.C. Irvine, taylor@ics.uci.edu </LI>\n\n<LI>Robert Thau, MIT, rst@ai.mit.edu </LI>\n</UL>\n\n<H3>7. References</H3>\n\n<P>[1] T. Berners-Lee, D. Connolly, &quot;HyperText Markup Language Specification\n- 2.0&quot;, RFC 1866, MIT/LCS, November 1995.</P>\n\n<P>[2] T. Berners-Lee, L. Masinter, M. McCahill. &quot;Uniform Resource\nLocators (URL)&quot;, RFC 1738, CERN, Xerox PARC, University of Minnesota,\nDecember 1994.</P>\n\n<P>[3] P. Feiler, &quot;Configuration Management Models in Commercial Environments&quot;,\nSoftware Engineering Institute Technical Report CMU/SEI-91-TR-7, &lt;http://www.sei.cmu.edu/products/publications/91.reports/91.tr.007.html&gt;\n</P>\n\n<P>[4] R. Fielding, J. Gettys, J. C. Mogul, H. Frystyk, and T. Berners-Lee,\n&quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;, RFC 2068, U.C. Irvine,\nDEC, MIT/LCS, January 1997.</P>\n\n<P>[5] A. Haake, D. Hicks, &quot;VerSE: Towards Hypertext Versioning Styles&quot;,\nProc. Hypertext'96, The Seventh ACM Conference on Hypertext, 1996, pages\n224-234. </P>\n\n<H3>8. Authors' Addresses</H3>\n\n<PRE>Judith Slein\nXerox Corporation\n800 Phillips Road 128-29E\nWebster, NY 14580\n\nEMail: slein@wrc.xerox.com\n\nFabio Vitali\nDepartment of Computer Science\nUniversity of Bologna\nITALY\n\nEMail: fabio@cs.unibo.it\n\nE. James Whitehead, Jr.\nDepartment of Information and Computer Science\nUniversity of California\nIrvine, CA 92697-3425\n\nFax: 714-824-4056\nEMail: ejw@ics.uci.edu\n\nDavid G. Durand\nDepartment of Computer Science\nBoston University\nBoston, MA\n\nEMail: dgd@cs.bu.edu\n\n</PRE>\n\n<P>Expires August 28, 1997 </P>\n\n<P><BR>\n</P>\n\n</BODY>\n</HTML>\n\n", "encoding": "ascii"}