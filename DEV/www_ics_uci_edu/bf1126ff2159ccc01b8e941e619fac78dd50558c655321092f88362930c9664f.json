{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/constructdebug/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Program Constuction and Debugging</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Program Construction and Debugging</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will learn some general information about\r\n    iterative-enhancement as as technique for designing, coding, testing,\r\n    and debugging programs.\r\n  Then, we will discuss debugging both syntax/complation errors and\r\n    execution/runtime errors in Java.\r\n  Debugging is a skill that you will become more adept at as the quarter\r\n    progresses (because you will be doing so much of it).\r\n  This lecture will be coupled with a handout that includes practical\r\n    information (is a tutorial and reference) about using the\r\n    <a href=\"../../../common/handouts/debugger.doc\">Eclipse Debugger</a>; \r\n    please read it and follow its instructions.\r\n  <p>\r\n  This tool is not only useful for debugging programs, but it is also useful\r\n    for understanding Java control structures, method calls (and their\r\n    parameters and local variables), and objects (and their instance\r\n    variables).\r\n  So, we shall use it in the classroom repeated during the quarter (and\r\n    you should use it to explore these topics, even if you don't use it to\r\n    debug your programs).\r\n  <p>\r\n  As a warmup for debugging, please read the\r\n    <a href=\"../../../common/handouts/bugs.html\">Bugs in Programming</a>\r\n    web page.\r\n  Most programmers write code that is about 80% correct.\r\n  The mark of a good programmer is that he/she systematically locates and\r\n    corrects each bug in the program until it is 100% correct; in contrast, a\r\n    poor programmer randomly changes the program (without knowing the cause of\r\n    the bug or the implications of the changes) and will actually REDUCE the\r\n    correctness of the code.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Iterative Enhancement -->\r\n\r\n<a name=\"IterativeEnhancement\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Program Construction via Iterative Enhancement (Design for Debugging)</b></td>\r\n<td width =\"80%\">\r\n  Application programs are almost always written based on some <i>divide and\r\n    conquer</i>  approach to problem solving.\r\n  Such approaches rely on the belief that it is harder to solve one large\r\n    problem than to solve a sequence of smaller subproblems (which lead to the\r\n    solution of the large problem).\r\n  So, in designing a program, we must determine how to divide the larger\r\n    problem into a sequence of smaller subproblems, and then conquer/solve each\r\n    one individually.\r\n  In industry, a team of programmers working on the same project may solve\r\n    these problems in parallel.\r\n  <p>\r\n  The divide and conquer approach that we will use mostly is \r\n    <b>Iterative-Enhancement</b>.\r\n  Given a problem (a specification of a program to write)\r\n  <ul>\r\n    <li>We start by writing a <b>kernel</b> program that meets some\r\n          dramatically simplified version of the specification.\r\n    <li>We extend the kernel by writing a sequence of programs, each an \r\n          enhancement to the previous one (each is called a <i>phase</i>),\r\n          which includes more and more of the specification.\r\n    <li>We eventually reach the final phase, which is the last program in the\r\n          sequence; it meets the entire specification and solves the entire\r\n          problem.\r\n  </ul>\r\n  By analogy, think of trying to cross a river; we could try to jump it in a\r\n   single bound, or we could try to find a path of stones in the river bed,\r\n    and jump from stone to stone, getting closer and closer to our destination,\r\n    until we reach the other side.\r\n  Each phase in the enhancement is like a stepping stone.\r\n  <p>\r\n  In addition, this approach allows us to gauge our progress, with each\r\n    finished phase acting as a milestone.\r\n  If it has taken us 3 hours to finish the first 4 phases of a project, and\r\n    there are 4 more phases to go (and we assume each phase takes about the \r\n    same amount of work), we can predict that it will take us about another 3\r\n    hours to finish.\r\n  Such an estimate is crude, but it is better than no estimate at all.\r\n  <p>\r\n  Pictorially, we can look at the process as follows.\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/iterative.gif\"></mage>\r\n<p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  We have already practiced this method, on a small scale, in our early\r\n    programming assignments.\r\n  It requires some perspective (and experience) to take a complicated program\r\n    specification and identify a good kernel and design a good sequence of\r\n    enhancements.\r\n  <ul>\r\n    <li>The kernel should capture something essential about the problem,\r\n          without getting bogged down in details.\r\n        Often the kernel captures the information needed to construct the main\r\n          loop in a program.\r\n    <li>Each phase should be a reasonable amount of work, focusing on one\r\n          different aspect of the problem, adding in more details.\r\n  </ul> \r\n The phases involve designing, coding, testing, and debugging a small amount of\r\n    related code to create an enhanced program.\r\n  It is critical that each such program is testable, so that we can verify that\r\n    it meets its enhanced specification and that we are truly making progress\r\n    towards our ultimate goal.\r\n  If any design element or its code fails to work, we will discover it quickly\r\n    and fix it immediately; we won't spend lots of time building other parts of\r\n    the code that depend on a wrong decision.\r\n  <p>\r\n  To start on a program, we need a good -but not perfect- understanding of the\r\n    problem being solved.\r\n  So, we should try to understand as much as we can before starting, but we \r\n    don't need to  understand everything; don't be afraid to begin.\r\n  During the process of writing our program, we will learn more and more\r\n    details about the problem, as we tackle more and more details in the\r\n    enhancements.\r\n  Our \"understanding\" of the problem willl increase, the more we work on\r\n    writing a program to solve it.\r\n  Eventually we will acquire an understanding of every detail of the problem,\r\n    because we have implemented every detail in our program.\r\n  <p>\r\n  When we learn how to write our own methods, we will be able to associate\r\n    an action (some code) with a name.\r\n  Then, by just referring to the name, we can execute the code.\r\n  Sometimes the discovery of methods is bottom-up: we realize that we\r\n    are performing the same computation over and over again, so we write a\r\n    method for it.\r\n  Sometimes the discovery is top-down: before we even write any code we\r\n    realize that certain methods can act as useful building blocks, so we write\r\n    them.\r\n  <p>\r\n  When we learn how to write our own classes, we will apply the same\r\n    bottom-up and top-down process, but on a larger scale.\r\n  Now we can identify useful classes and all the methods they define.\r\n  We can test each class by independently, by testing its individual methods.\r\n  Once each class is working, we can test combinations as we use them to build\r\n    the entire application program.\r\n  Thus, we are always employing some kind of divide-and-conquer approach to\r\n    solve our programming problems.\r\n  <p>\r\n  Another key feature of iterative enhancement is <b>focus</b>.\r\n  Each enhancement focuses on designing and coding a small number of additions\r\n    or modifications to an already working program.\r\n  When debugging a phase, we typically need to focus on only the small amount\r\n    of code that we recently added/changed.\r\n  In this way, we can effectively build large programs by focussing on one\r\n     piece at a time.\r\n  The biggest problem is making sure the pieces all fit together.\r\n  <p>\r\n  The human brain can only keep track of so many details at a time; if we wrote\r\n    a huge amount of code and tried to debug it all, it could easily overload\r\n    our mental capacity.\r\n  Often engineers talk about the KISS principle: Keep It Simple, Stupid.\r\n  Iterative-enhancement lets us keep each task simple.\r\n  <p>\r\n  Finally, at the end of each phase we should <b>simplify</b> our code\r\n    as much as possible: step back and try to come up with equivalent code\r\n    that is easier to understand (and often smaller).\r\n  Because we are building on our code, and making it more complicated by\r\n    further enhancing it, we want to always start each enhancement with the\r\n    simplest code possible.\r\n  Simplifying during iterative enhancement will be much more effective\r\n    (because of focus) than trying to simplify an entire program after\r\n    it is written.\r\n  Time spent simplifying code will pay for itself with time saved in later\r\n    enhancements.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Testing -->\r\n\r\n<a name=\"Testing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Testing Software</b></td>\r\n<td width =\"80%\">\r\n  Testing is the process of running software looking for errors (meaning \r\n    actively trying to make the program fail): failure of the program to\r\n    produce correct output from some correct input.\r\n  Once testing shows the presence of a bug, debugging begins (the process of\r\n    fixing errors found during testing).\r\n  Before discussing the process of debugging, let's look a bit at the process\r\n    of testing.\r\n  <p>\r\n  Professional software testers acquire great skill and intuition at thinking\r\n    up\"good\" inputs  on which to test programs.\r\n  They are valued members of a product team.\r\n  For example, Microsoft employs about one tester for each programmer.\r\n  Sometimes these testers work in teams separate from the programmers; at other\r\n    times a tester will pair up with a programmer.\r\n  When the programmer finishes some part of the code, the tester begins testing\r\n    it while the programmer proceeds to the next part of the code.\r\n  If the tester finds any bugs, the programmer must fix them before continuing.\r\n  As you can imagine, programmers often dislike testers because the latter are\r\n    always pointing out mistakes made by the former!\r\n  <p>\r\n  But, it is better to have the mistake pointed out by your coworker than by\r\n    your boss (or a customer).\r\n  No programmer wants to believe that his/her code contains errors; but they\r\n    all do contain errors.\r\n  Some would argue that the programmer, intimiate with the code he/she has\r\n    written, is the best person to test it.\r\n  But, having a programmer test his/her own code might be bad from a\r\n    psychological point of view:  he/she might not test the code as rigorously,\r\n    because he/she doesn't really want to find any errors.\r\n  Having a separate tester addresses this problem.\r\n  <p>\r\n  But even this approach can cause problems: if a programmer knows an\r\n    independent tester will be examining his/her code after it is written,\r\n    the programmer may write code carelessly, knowing it is someone else's\r\n    job to spot problems.\r\n  Thus, there is a real tangle of incentives when writing and testing code.\r\n  How Microsoft produces software (an overview accessible to students in this\r\n    course) is discussed in Cusumano and Shelby\r\n    <a href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0684855313/qid=1031956797/sr=1-4/ref=sr_1_4/002-9542912-5644017?v=glance&s=books\" target=\"_blank\">\r\n    Microsoft Secrets: How the World's Most Powerful Software Company Creates\r\n      Technology, Shapes Markets, and Manages People</a>, Free Press, 1995.\r\n  <p>\r\n  In <b>Agile</b> programming methods (which includes Extreme Programming,\r\n    which includes Pair Programming) programming is test-driven.\r\n  Before doing any coding, a programmer or tester develops an extensive suite\r\n    of tests that the code must pass.\r\n  Only then is the code written: and the programmer's progress is judged by\r\n    the number of tests in the suite that it passes (which is a bit like\r\n    using iterative enhancment to judge the progress of programming).\r\n  If the code is modified later, it must repass all these tests.\r\n  We will discuss JUnit testing towards the end of the quarter, which helps\r\n    automate test-driven programming.\r\n  <p>\r\n  There are two general categories of testing.\r\n  In <b>black-box</b> testing, testers write test-cases based only on the\r\n    specifications for what the code is supposed to accomplish; they are not\r\n    allowed to look at the code itself.\r\n  In <b>white-box</b> testing, testers write test-cases based both on knowledge\r\n    of the specifications and the code itself: certain kinds of tests migh\r\n    suggest themselves if the tester examines the code.\r\n  Of course, black-box tests can be developed before or while the code is\r\n    written, but white-box tests can be developed only after the code is\r\n    written.\r\n  <p>\r\n  Industry testers often write/use long scripts when they\r\n    <b>regression test</b> programs.\r\n  Each time a program is changed, the tester executes the script to ensure that\r\n    no bugs were introduced in old features (it still works as it always has).\r\n  Then the script is extended for the new features being tested.\r\n  Much of the work in regression testing can be automated: often the result of\r\n     such tools is either a message confirming that all tests were passed, or\r\n     a list of outputs (and their inputs) that differed between the original\r\n     program and the one now being tested.\r\n  <p>\r\n  Finally, <b>integration tests</b> determine whether software components,\r\n    written and tested separately (in <b>component</b> or <b>unit</b> tests),\r\n    work together correctly in a program.\r\n  It is much easier to test/debug each component by itself, than in a system\r\n     comprising many components.\r\n  In systems, even simple bugs can manifest themselves in hard to understand\r\n    situations.\r\n  Many features added to programming languages at the end of the 1990s were\r\n    designed to simplify software integration\r\n  <p>\r\n  We will discuss many of these aspects of testing in more detail in a later\r\n    lecture, focusing on Java's ability to write unit tests inside the classes\r\n    they are testing.\r\n  When we cover JUnit, we will discuss this kind of automated testing in more\r\n    detail.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Debugging -->\r\n\r\n<a name=\"Debugging\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Debugging</b></td>\r\n<td width =\"80%\">\r\n  Once testing has found a problem, we can begin debugging: trying to locate\r\n    the source of the error and fix it.\r\n  Debugging is also a task suited to solution by divide-and-conquer techniques.\r\n  We don't need to remove all the bugs from a program at once; instead, if we\r\n    can remove one bug, then another, etc. we will eventually remove them all.\r\n  Also, when we are looking for the location of a bug in a program, we can\r\n    divide the program into regions and search for the bug in smaller and\r\n    smaller regions until we find it.\r\n  The key idea is to continually make progress, never getting stuck for too\r\n    long on one problem (maybe switching to solve another).\r\n  <p>\r\n  We will divide debugging into syntax/compilation bugs and execution/runtime\r\n     bugs.\r\n  Syntax bugs are diagnosed and reported by the Java compiler, which shows\r\n    their location (or a close approximation) and a description of the error\r\n    (or a close approximation).\r\n  Execution/runtime bugs are much more difficult to fix, primarily because WE\r\n    must first find where they occur.\r\n  The hardest part of debugging is tracking down the location of an error: once\r\n    we have accomplished this task, actually fixing the bug is often much\r\n    simple.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Syntax Errors -->\r\n\r\n<a name=\"SyntaxErrors\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Syntax Bugs</b></td>\r\n<td width =\"80%\">\r\n  As we learned in our first lecture, the earlier a problem is discovered,\r\n    the less time/money it will take to fix it.\r\n  Syntax/compilation errors are discovered very early.\r\n  The Java compiler detects and reports these before running the program; so\r\n    they are much easier to fix than execution/runtime errors.\r\n  In fact, languages with strict compilers help spot at compile time errors\r\n    that become apparent only at runtime in languages with less strict\r\n    compilers.\r\n  Paradoxically, we should be happy whenever Java reports a compile-time bug:\r\n    given that the program has an error, the compiler saves us from having to\r\n    locate the error later, at runtime (a more complicated process).\r\n  <p>\r\n  Never say that a program is correct until it contains neither kinds of\r\n     errors.\r\n  Many introductory programming students say, \"My program has no errors but it\r\n    is not working correctly\", when they should be saying, \"My program has no\r\n     syntax errors (it is compiling correctly), but it still has\r\n     execution/runtime errors\".\r\n  Although no one likes to be told of syntax errors in their programs, Java\r\n    forces us to fix these errors before running our programs, and thus\r\n    eliminates many harder-to-debug execution/runtime errors that would\r\n    otherwise occur.\r\n  A well designed programming language is one that allows errors to be\r\n    detected as early a possible, by the compiler.\r\n  <p>\r\n  Technically, the Java compiler detects and reports a syntax error when it\r\n    examines a token that cannot legally appear next in the code.\r\n  Thus, either that token is wrong, or some recent one that preceded it was.\r\n  So, first check the token itself, and then those immediately preceding it.\r\n  Understand what you are trying to accomplish with these tokens and use this\r\n    knowledge to help determine what is wrong with what you wrote.\r\n  A great help in fixing subtle syntax errors is working code (in some other\r\n    program) that uses the same language features correctly; compare the two \r\n    to find the problem.\r\n  <p>\r\n  Common errors include missing semi-colons, mismatched separators\r\n    (parentheses and braces), misspelled names (for variables, methods, and\r\n     classes; remember that case is important), and the wrong number/type of\r\n     arguments to operators and methods (prototype/signature mismatches).\r\n  Java does a relatively good job of explaining the syntax errors that it\r\n    finds, but sometimes its messages are cryptic (or even just plain wrong);\r\n    it takes a bit of intuition to interpret these messages (a skill that we\r\n    will continue to acquire as we debug more and more of our programs; in\r\n    fact, we can acquire this skill while helping to debug other people's\r\n    programs too: that is why teachers are so good at debugging).\r\n  <p>\r\n  The Java compiler is a multi-pass compiler (it scans the source code from top\r\n    to bottom multiple times), so sometimes the first syntax error reported is\r\n    not the first syntax error in the program.\r\n  Still, the best strategy is to try to fix the first syntax error reported.\r\n  Sometimes you might scan the first few syntax errors and be able to fix more\r\n    than one at a time; other times you may be confused by the first syntax\r\n    error but be able to fix a later one.\r\n  In fact, sometimes fixing one syntax error eliminates others, because they\r\n    all have the same root cause.\r\n  So I recommend fixing just one syntax error for each compilation.\r\n  If you can always fix at least one error each time that you compile a\r\n    program, you will eventually remove all its syntax errors; and often fixing\r\n    three syntax errors can eliminate a dozen syntax error messages.\r\n  <p>\r\n  If you cannot fix a syntax error, seek help; when you understand what you\r\n    did wrong, write down the problem, the error message, and the solution in\r\n    an error log, which you can consult whenever you have hard-to-fix syntax\r\n    errors.\r\n  <p>\r\n  Incorrectly matching braces can cause very many syntax error messages that\r\n    are not indicative  of the real problem.\r\n  For this reason, whenever you type an opening brace, Eclipse will\r\n    automatically type a matching closing brace and position the cursor\r\n    inbetween the two for you to continue typing the statements in the block.\r\n  Eclipse also supports a special \"brace matching\" operation.\r\n  <ul>\r\n    <li>If we double-click immediately after an opening brace\r\n         <!-, or immediately before a closing brace,->\r\n         the editor view will highlight all the lines between the selected\r\n         opening brace and the closing brace that matches it.\r\n   </ul>\r\n  Experiment with this excellent debugging tool immediately, so it will make\r\n    it into your long term memory as soon as possible!\r\n  <p>\r\n  If we don't have a fancy IDE that treats braces so nicely, we have to be\r\n    more proactive about brace matching.\r\n  Whenever we type an open brace in a program, we should immediately type its\r\n    closing brace (then come back and write whatever statements we need inside\r\n    these matching braces).\r\n  If you type an opening brace, and tell yourself, \"I'll type the statements\r\n    first, and then I'll type the closing brace\" most of the time you'll\r\n    forget: your mind gets preoccupied with the statements in-between, and\r\n    it is such a relief to finish writing a block, it is easy to forget about\r\n    the required closing brace.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Execution/Runtime Errors -->\r\n\r\n<a name=\"ExecutionErrors\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Execution Bugs</b></td>\r\n<td width =\"80%\">\r\n  If the Java compiler finds no syntax errors in a program, it can run the\r\n    program.\r\n  The program may or may not behave as it should: a simple program may not\r\n    compute and display the correct results; a more complicated one may not\r\n    do the right thing when you click its buttons.\r\n  If either case, it has an execution/runtime error.\r\n  Technically, an execution/runtime error is something that Java detects (like\r\n    throwing an exception when dividing by 0); an intent error is when the\r\n    program finishes without an execution/runtime error, but nevertheless\r\n    computes an incorrect result.\r\n  In the discussion below, we will refer to both kinds of errors as execution\r\n    errors.\r\n  <p>\r\n  Debugging execution errors is hard: we have to leave our ego at the door,\r\n    admit that WE put an error in our program, and then systematically locate\r\n     and fix the problem.\r\n  The golden rule of debugging is to find the <b>simplest</b> input on which\r\n    a program consistently produces an error (this makes debugging much\r\n    easier).\r\n  We can apply the techniques described below most effectively when debugging\r\n    the program on the simplest input causing an error.\r\n  So, if we find an input that causes the program to fail, we should keep\r\n    trying simpler inputs (fewer values, smaller values, etc.) until we find\r\n    the simplest one on which it fails.\r\n  Only then do we start debubugging.\r\n  <p>\r\n  Job #1 in debugging is finding the location of the error.\r\n  Once we know which statement contains a wrong instruction (wrong not\r\n    because of syntax, but because it is not the right statement for the\r\n    program to execute), finding how to fix it is often much simpler.\r\n  The typical way to find the problem is to <b>instrument</b> the program with\r\n    <b>System.out.println</b> statements that display the current state of the\r\n    \"relevant\" variables.\r\n  We can build complicated programs that trace themselves: we can use an\r\n    <b>if</b> statement testing a <b>trace</b> variable to determine whether\r\n    to print information (for a <b>boolean</b>) or what level of information\r\n    (for an <b>int</b> trace level) to print as the program executes.\r\n  Eventually, we will find that some variable goes from storing the right value\r\n    to storing the wrong one: between the statements that displayed the right\r\n    and wrong value is the location of the error.\r\n  <p>\r\n  When we write programs using iterative enhancement, each phase should display\r\n    the variables that it creates and/or changes, so we can see if the new\r\n    parts of the program are making the right state changes.\r\n  <!---\r\n  See the <a href=\"../../programs/crapsstatisticsinstrumented.zip\">\r\n    Craps Statistics - Instrumented</a> program for an example of building in\r\n    these kinds of tracing/debugging print statements.\r\n  --->\r\n  <p>\r\n  Sometimes a program gets into an infinite loop: the test controling\r\n    termination of the loop is never <b>true</b>.\r\n  If we put a <b>System.out.println</b> statement inside the body of the loop,\r\n    and the loop becomes infinite, that information will print out over and\r\n    over and over again, indicating an infinite loop.\r\n  <pre><b>  for (;;) {\r\n    System.out.println(\"at start of for loop\");\r\n    real statements in loop\r\n  }</b></pre>\r\n  Sometimes <b>System.out.println</b> statements involve no variables:\r\n   <b>System.out.println(\"About to execute critical statement\");</b>\r\n    but more frequently, they do\r\n    <b>System.out.println(\"After update: x = \" + x);</b>\r\n  Always uniquely label your output statements so you know from where in the\r\n    program each piece of information is printed.\r\n  The amount of time you spend typing-in such statements is dwarfed by the\r\n    amount of time you spend studying them; so make the output clear the\r\n    first time.\r\n  <p>\r\n  Always remember to use an <b>println</b> (not <b>print</b>) for debugging\r\n     purposes.\r\n  This has to do with console buffers, which are like file buffers.\r\n  If you use <b>print</b>, it is possible that the program could execute the\r\n    <b>print</b> first and then terminate abnormally without the printed\r\n    information being displayed; this can be very confusing!\r\n  With a <b>println</b>, the information will always be fully displayed before\r\n    the program executes subsequent statements, so the output is an accurate\r\n    log of the program.\r\n  <p>\r\n  Once we find a bug (the hard part), it is often takes much less work to fix\r\n    it.\r\n  Often, we do some hand-simulation to more closely see the problem.\r\n  Whenever we fix a bug, we should immediately hand simulate (or rerun) the\r\n     new code to ensure that it now works correctly.\r\n  If it does not perform as expected, undo the change and go back to the old\r\n    code to look for a different fix.\r\n  We should not keep any change in our code unless we observe that the change\r\n    improves the code: one change may not completely correct the code, but it\r\n    should improve it.\r\n  If we make lots of changes that don't improve the code, we will degrade the\r\n    code and make it harder to fix it.\r\n  <p>\r\n  Again, the first effort of a programmer is often 80% correct.\r\n  Students have a tendancy to make unsupported changes in code they are\r\n    debugging, often taking code from being close to correct to being further\r\n    away.\r\n  Good programmers verify that each change improves their code; if a\r\n    change does not improve things, remove it and go back to the original code.\r\n  They keep making improvements until the code is correct.\r\n  The measure of a good programmer is not necessarily how many bugs are\r\n    initially present in his/her code, but how quickly he/she removes those\r\n    bugs.\r\n  <p>\r\n  Here are a few simple debugging tips:\r\n  <ul>\r\n    <li>Eliminate obvious errors first: make sure the data is being read\r\n          correctly from a file before trying to debug the code that processes\r\n          it (if the data is not being read correctly, of course the processing\r\n          code will produce incorrect results).\r\n    <li>Ensure that every variable contains a reasonable value before its value\r\n          is used the first time.\r\n        Variables can be initialized when they are declared, or in subsequent\r\n          statements involving the <b>=</b> operator: most other state change\r\n          operators (e.g., <b>++</b>) update the state, so they depend on the\r\n          value already stored.\r\n    <li>If an expression is computing an incorrect value, display the values of\r\n           all the variables used in the expression (one of them may be wrong).\r\n    <li>If you are unsure which part of an <b>if/else</b> is executing, put\r\n          something like the following at the top of a block containing the\r\n           statements the <b>if/else</b> controls:\r\n<pre><b>  if (test) {\r\n    System.out.println(\"if (test): test was true\");\r\n    real statements for true test\r\n  }else{\r\n    System.out.println(\"if (test): test was false\");\r\n    real statements for false test\r\n  }</b></pre>\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- The Eclipse Debugger -->\r\n\r\n<a name=\"EclipseDebugger\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The Eclipse Debug Perspective</b></td>\r\n<td width =\"80%\">\r\n  The Eclipse Debug perspective can help automate some of the hand simulation\r\n    and program instrumentation needed to debug programs.\r\n  It allows us to do the equivalent of these without entering more code and\r\n    then recompiling our programs.\r\n  Debuggers contain many powerful features allowing us to monitor the\r\n    execution of a program: both the location of the statement that it is\r\n    being executing, and the values stored in any variables declared in the\r\n    program.\r\n  <p>\r\n  Some programmers prefer to avoid using a debugger and instead instrument\r\n    their code carefully as they write it.\r\n  Others prefer to master the debugger, which they can use quickly to locate\r\n     many kinds  of errors.\r\n  A blend of the two approaches is probably best (but it takes some experience\r\n     to do that well).\r\n  To this end, we will examine the\r\n    <a href=\"../../../common/handouts/debugger.doc\">Eclipse Debugger</a>\r\n    handout and practice using it.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  No problems for this lecture.\r\n  See the \r\n    <a href=\"../../../common/handouts/debugger.doc\">Eclipse Debugger</a>\r\n    handout for problems (the last page).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}