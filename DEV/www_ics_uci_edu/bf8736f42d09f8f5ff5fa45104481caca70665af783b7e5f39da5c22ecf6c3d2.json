{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/04.fibheap", "content": "Homework, due Tuesday 14 Oct: exercise 20.2-5; probs 10-2, 11-2, 20-2\n\n\nPotential function method of amortization [17.3]\n\n    define potential function Phi, Phi>=0, initially zero\n    e.g. for growing vector data structure, Phi = #filled - #unfilled\n\n    define \"amortized cost\" = actual time + c DeltaPhi\n\t(choose c carefully later)\n     insert w/o rebuild: c DeltaPhi = 2c = O(1)\n     rebuild: DeltaPhi = -n, offsets O(n) time for rebuilding\n     so amortized cost always O(1)\n\n    telescopes, so\n    sum(amort) = sum(actual) + Phi_final - Phi_initial >= sum(actual)\n\n\n\nFibonacci heaps [ch.20]:\n    heap allowing insert, delete-min (not arbitrary delete),\n    decrease-key (not arbitrary change-key), merge\n    \n    all operations O(1) time (amortized for decrease-key)\n    except delete O(log n) (amortized)\n    so Dijkstra time becomes O(m + n log n)\n\n    arbitrary delete and change-key could be handled\n    by lazy deletion, O(log n) amortized each\n\n    structure:\n        forest of rooted non-binary trees\n        heap-ordered (key[parent] <= key[self])\n\n\trepresented by nodes with:\n\t\tparent\n\t\tchild: arbitrary one of the node's children\n\t\tleft, right: doubly linked circular list of siblings\n                (left, right pointers of roots give list of all trees)\n\t\tdegree (# of children)\n\t\tmark (boolean, true if lost a child since parent last changed)\n\toverall structure is represented by pointer to tree w/smallest root\n\talso store total number of nodes in the tree\n\n        Phi = # trees + 2*(# marks)\n\n    insert new item:\n        make it into a new singleton tree\n\tadd it into the circular list of tree roots\n\tchange pointer to min root if new item is smaller\n\n        O(1) time, Phi += 1\n\n    find min item:\n        obvious\n\n    merge two trees:\n        concatenate their list of tree roots\n\tset min root pointer to smaller of two min roots\n\n        O(1) time, total Phi unchanged\n\n    delete min:\n\tturn children of min into roots of new trees\n\tgroup roots by their degrees (e.g. bucket sort)\n\twhile two roots x and y have the same degree, root(x)<root(y):\n            make y into a child of x and update buckets\n\n        time:\n            O(max degree) for grouping by degrees\n            O(1) for each pair of trees combined\n\t    Phi -= 1 for each pair of trees combined\n\n            total: O(max degree) amortized\n\n    decrease key:\n        remove the item x from its parent's list of children\n\t    and make it into a new tree root\n\tdo the same for the sequence of marked ancestors of x\n\t    until finding an unmarked ancestor, which gets marked\n\n        time:\n            O(1) per ancestor moved to new tree\n\t    Delta -= 1 per ancestor (1 new tree, 1 fewer mark)\n\t    Delta += 2 for the new marked ancestor\n\n\t    total: O(1) amortized\n\nkey remaining question: why do degrees stay small? [20.4]\nAND why are they called Fibonacci trees anyway?\n\nlemma 1: number children of any degree k node 1,2,...k in order by\n\twhen they were added\nthen degree(child i) >= i-2\n\npf: i'th child was added when degrees were equal\n    (so node had at least i-1 children already)\n    then at most one child could be taken away (if child is marked)\n\nlemma 2: node with degree k has >= F_k nodes in subtree\nF_0 = 1, F_1 = 2,  F_i = F_{i-1} + F_{i-2}\n\npf: children have degrees >= 0, 0, 1, 2, 3, ...\n    so by induction they have at least F_0, F_0, F_1, F_2, ... nodes\n\n    more generally: node itself + sum of first x children's subtrees >= F_x\n    base case: x=0, node itself=1\n    induction: node + x-1 children = F_{x-1} + F_{x-2} = F_x\n\n    lemma follows with x=k\n\nF_k > (1+sqrt(5)/2)^k\n\ncan't have more than n nodes in a subtree\nso max degree < log_phi n = O(log n)\n", "encoding": "ascii"}