{"url": "https://www.ics.uci.edu/~majumder/VC/211HW3/vlfeat/doc/matlab/vl_covdet.html", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n   <html xmlns=\"http://www.w3.org/1999/xhtml\">\n <head>\n  <!-- IE Standards Mode -->\n  <meta content=\"IE=edge\" http-equiv=\"X-UA-Compatible\"></meta>\n\n  <!-- Favicon -->\n  <link href=\"../images/vl_blue.ico\" type=\"image/x-icon\" rel=\"icon\"></link>\n  <link href=\"../images/vl_blue.ico\" type=\"image/x-icon\" rel=\"shortcut icon\"></link>\n\n  <!-- Page title -->\n  <title>VLFeat - Documentation > MATLAB API > SIFT - vl_covdet</title>\n\n  <!-- Stylesheets -->\n  <link href=\"../vlfeat.css\" type=\"text/css\" rel=\"stylesheet\"></link>\n  <link href=\"../pygmentize.css\" type=\"text/css\" rel=\"stylesheet\"></link>\n  <style xml:space=\"preserve\">\n    /* fixes a conflict between Pygmentize and MathJax */\n    .MathJax .mo, .MathJax .mi {color: inherit ! important}\n  </style>\n  \n\n  <!-- Scripts-->\n  \n\n  <!-- MathJax -->\n  <script xml:space=\"preserve\" type=\"text/x-mathjax-config\">\n    MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], ['\\\\(','\\\\)'] ],\n      processEscapes: true,\n    },\n    TeX: {\n      Macros: {\n        balpha: '\\\\boldsymbol{\\\\alpha}',\n        bc: '\\\\mathbf{c}',\n        be: '\\\\mathbf{e}',\n        bg: '\\\\mathbf{g}',\n        bq: '\\\\mathbf{q}',\n        bu: '\\\\mathbf{u}',\n        bv: '\\\\mathbf{v}',\n        bw: '\\\\mathbf{w}',\n        bx: '\\\\mathbf{x}',\n        by: '\\\\mathbf{y}',\n        bz: '\\\\mathbf{z}',\n        bsigma: '\\\\mathbf{\\\\sigma}',\n        sign: '\\\\operatorname{sign}',\n        diag: '\\\\operatorname{diag}',\n        real: '\\\\mathbb{R}',\n      },\n      equationNumbers: { autoNumber: 'AMS' }\n      }\n    });\n  </script>\n  <script src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" xml:space=\"preserve\" type=\"text/javascript\"></script>\n\n  <!-- Google Custom Search -->\n  <script xml:space=\"preserve\">\n    (function() {\n    var cx = '003215582122030917471:oq23albfeam';\n    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;\n    gcse.src = (document.location.protocol == 'https' ? 'https:' : 'http:') +\n    '//www.google.com/cse/cse.js?cx=' + cx;\n    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);\n    })();\n  </script>\n\n  <!-- Google Analytics -->\n  <script xml:space=\"preserve\" type=\"text/javascript\">\n    var _gaq = _gaq || [];\n    _gaq.push(['_setAccount', 'UA-4936091-2']);\n    _gaq.push(['_trackPageview']);\n    (function() {\n    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n    })();\n  </script>\n </head>\n\n <!-- Body Start -->\n <body>\n  <div id=\"header-section\">\n    <div id=\"header\">\n      <!-- Google CSE Search Box -->\n      <div class=\"searchbox\">\n        <gcse:searchbox-only autoCompleteMaxCompletions=\"5\" autoCompleteMatchType=\"any\" resultsUrl=\"http://www.vlfeat.org/search.html\"></gcse:searchbox-only>\n      </div>\n      <h1 id=\"id-16\"><a shape=\"rect\" href=\"../index.html\" class=\"plain\"><span id=\"vlfeat\">VLFeat</span><span id=\"dotorg\">.org</span></a></h1>\n    </div>\n    <div id=\"sidebar\"> <!-- Navigation Start -->\n      <ul>\n<li><a href=\"../index.html\">Home</a>\n<ul>\n<li><a href=\"../about.html\">About</a>\n</li>\n<li><a href=\"../license.html\">License</a>\n</li>\n</ul></li>\n<li><a href=\"../download.html\">Download</a>\n<ul>\n<li><a href=\"../install-matlab.html\">Using from MATLAB</a>\n</li>\n<li><a href=\"../install-octave.html\">Using from Octave</a>\n</li>\n<li><a href=\"../install-shell.html\">Using from the command line</a>\n</li>\n<li><a href=\"../install-c.html\">Using from C</a>\n<ul>\n<li><a href=\"../xcode.html\">Xcode</a>\n</li>\n<li><a href=\"../vsexpress.html\">Visual C++</a>\n</li>\n<li><a href=\"../gcc.html\">g++</a>\n</li>\n</ul></li>\n<li><a href=\"../compiling.html\">Compiling</a>\n<ul>\n<li><a href=\"../compiling-unix.html\">Compiling on UNIX-like platforms</a>\n</li>\n<li><a href=\"../compiling-windows.html\">Compiling on Windows</a>\n</li>\n</ul></li>\n</ul></li>\n<li><a href=\"../overview/tut.html\">Tutorials</a>\n<ul>\n<li><a href=\"../overview/frame.html\">Local feature frames</a>\n</li>\n<li><a href=\"../overview/covdet.html\">Covariant feature detectors</a>\n</li>\n<li><a href=\"../overview/hog.html\">HOG features</a>\n</li>\n<li><a href=\"../overview/sift.html\">SIFT detector and descriptor</a>\n</li>\n<li><a href=\"../overview/dsift.html\">Dense SIFT</a>\n</li>\n<li><a href=\"../overview/liop.html\">LIOP local descriptor</a>\n</li>\n<li><a href=\"../overview/mser.html\">MSER feature detector</a>\n</li>\n<li><a href=\"../overview/imdisttf.html\">Distance transform</a>\n</li>\n<li><a href=\"../overview/encodings.html\">Fisher Vector and VLAD</a>\n</li>\n<li><a href=\"../overview/gmm.html\">Gaussian Mixture Models</a>\n</li>\n<li><a href=\"../overview/kmeans.html\">K-means clustering</a>\n</li>\n<li><a href=\"../overview/aib.html\">Agglomerative Infromation Bottleneck</a>\n</li>\n<li><a href=\"../overview/quickshift.html\">Quick shift superpixels</a>\n</li>\n<li><a href=\"../overview/slic.html\">SLIC superpixels</a>\n</li>\n<li><a href=\"../overview/svm.html#tut.svm\">Support Vector Machines (SVMs)</a>\n</li>\n<li><a href=\"../overview/kdtree.html\">KD-trees and forests</a>\n</li>\n<li><a href=\"../overview/plots-rank.html\">Plotting AP and ROC curves</a>\n</li>\n<li><a href=\"../overview/utils.html\">Miscellaneous utilities</a>\n</li>\n<li><a href=\"../overview/ikm.html\">Integer K-means</a>\n</li>\n<li><a href=\"../overview/hikm.html\">Hierarchical integer k-means</a>\n</li>\n</ul></li>\n<li><a href=\"../applications/apps.html\">Applications</a>\n</li>\n<li class='active'><a href=\"../doc.html\">Documentation</a>\n<ul>\n<li class='active'><a href=\"matlab.html\">MATLAB API</a>\n</li>\n<li><a href=\"../api/index.html\">C API</a>\n</li>\n<li><a href=\"../man/man.html\">Man pages</a>\n<ul>\n<li><a href=\"../man/mser.html\">mser</a>\n</li>\n<li><a href=\"../man/sift.html\">sift</a>\n</li>\n<li><a href=\"../man/vlfeat.html\">vlfeat</a>\n</li>\n</ul></li>\n</ul></li>\n</ul>\n\n    </div> <!-- sidebar -->\n  </div>\n  <div id=\"headbanner-section\">\n    <div id=\"headbanner\">\n      <span class='page'><a href=\"../doc.html\">Documentation</a></span><span class='separator'>></span><span class='page'><a href=\"matlab.html\">MATLAB API</a></span><span class='separator'>></span><span class='page'><a href=\"vl_covdet.html\">SIFT - vl_covdet</a></span>\n    </div>\n  </div>\n  <div id=\"content-section\">\n    <div id=\"content-wrapper\">\n      <div id=\"content\">\n        <div class=\"mdoc\">\n<ul class=\"breadcrumb\"><li><a href=\"matlab.html\">Index</a></li><li><a href=\"vl_quickvis.html\">Prev</a></li><li><a href=\"vl_dsift.html\">Next</a></li></ul><div class=\"documentation\"><p>\n<a href=\"vl_covdet.html\">VL_COVDET</a>() implements a number of co-variant feature detectors\n(e.g., DoG, Harris-Affine, Harris-Laplace) and corresponding\nfeature descriptors (SIFT, raw patches).\n</p><p>\nF = <a href=\"vl_covdet.html\">VL_COVDET</a>(I) detects upright scale and translation covariant\nfeatures based on the Difference of Gaussian (Dog) cornerness\nmeasure from image I (a grayscale image of class SINGLE). Each\ncolumn of F is an oriented ellipse (see <a href=\"vl_plotframe.html\">VL_PLOTFRAME</a>() for the\ndefinition) even if features are upright and/or not affine\ncovariant (in which case unoriented/circular may suffice).\n</p><p>\n<a href=\"vl_covdet.html\">VL_COVDET</a>(I, 'Method', METHOD) allows using one of the following\ndetection methods instead of the default one:\n</p><dl><dt>\nDoG\n<span class=\"defaults\">default</span></dt><dd><p>\nThe Difference of Gaussians is an approximate version of the\nmultiscale trace of Laplacian operator [1].\n</p></dd><dt>\nHessian\n</dt><dd><p>\nDeterminant of Hessian operator [2].\n</p></dd><dt>\nHessianLaplace\n</dt><dd><p>\nDeterminant of Hessian for space localization, trace of\nLaplacian for scale detection [2].\n</p></dd><dt>\nHarrisLaplace\n</dt><dd><p>\nHarris cornerness measure for space localization, trace\nof Laplacian for scale detection [2].\n</p></dd><dt>\nMultiscaleHessian\n</dt><dd><p>\nSame as HessianLaplace, but Laplacian scale detection is not\nperformend (features are simply detected at multiple scales) [2].\n</p></dd><dt>\nMultiscaleHarris\n</dt><dd><p>\nSame as HarrisLaplace, but Laplacian scale detection is not\nperformend (features are simply detected at multiple scales) [2].\n</p></dd></dl><p>\nThe number of detected features is affected by the 'PeakThreshold'\noption, which sets the minimum absolute vale of the cornerness\nmeasure to accept a feature. A larger threshold causes fewer\nfeatures to be extracted. A good way to choose a threshold is to\nlook at the cornerness score of the features extracted from an\nexample image. This score is returned as part of the INFO\nstructure, as explained below.\n</p><p>\nIn addition to the absolute value of the cornerness measure,\nfeatures are also filtered by the curvature of the latter. This is\ncontrolled by the 'EdgeThreshold' parameter, which is the upper\nbound on the ratio of the maximum over the minimum curvature of\nthe cornerness measure at the location of the detected\nfeature. Intuitively, a low ratio corresponds to an elongated\nvalley in the cornerness score map, which usually arises from\nimage edges. These locations are usually discarded as they tend to\nbe unstable.\n</p><p>\nSome corner detectors (e.g. HarrisLaplace) use peak in the\nresponse of the multi-scale Laplace operator to select the\nscale of the detected frames. These peaks are filtered by\na threshold adjustable by using the 'LaplacianPeakThreshold' option.\n</p><p>\n<a href=\"vl_covdet.html\">VL_COVDET</a>(..., 'EstimateAffineShape', true) switches on affine\nadaptation, an algorithm [2] that attempts to estimate the affine\ncovariant shape of each feature.\n</p><p>\n<a href=\"vl_covdet.html\">VL_COVDET</a>(..., 'EstimateOrientation', true) switches on the\nestimation of the orientation of the features. The algorithm looks\nfor one or more dominant orientations of the gradient in a patch\naround the feature as in [1]. Note that more than one orientation\ncan be associated to each detected feature, creating multiple\nversions of the same feature with different orientations.\n</p><p>\n<a href=\"vl_covdet.html\">VL_COVDET</a>(..., 'Frames', F) uses the user specified frames F\ninstead of running a detector. The estimation of the affine shape\nand of the feature orientation can still be performed starting\nfrom such frames. Moreover, descriptors for these frames can be\ncomputed.\n</p><p>\n[F,D] = <a href=\"vl_covdet.html\">VL_COVDET</a>(I, ...) computes the SIFT descriptors [1] for\nthe detected features. Each column of D is the descriptor of the\ncorresponding frame in F. A descriptor is a 128-dimensional vector\nof class SINGLE. The same format of <a href=\"vl_sift.html\">VL_SIFT</a>() is used. SIFT\nfeatures are computed on normalized image patches that are\naffected by the parameters explained next (for example, in order\nto compute SIFT on a larger measurement region, increase the value\nof PatchRelativeExtent).\n</p><p>\n[F,D] = <a href=\"vl_covdet.html\">VL_COVDET</a>(I, 'descriptor', DESCRIPTOR) allows using one\nfollowing descriptors instead\n</p><dl><dt>\nSIFT\n<span class=\"defaults\">default</span></dt><dd><p>\nThe SIFT descriptor.\n</p></dd><dt>\nLIOP\n</dt><dd><p>\nThe Local Intensity Order Pattern descriptor. See <a href=\"vl_liop.html\">VL_LIOP</a>() for\nthe parameters affecting this descriptor. All LIOP parameters can\nbe used as input to <a href=\"vl_covdet.html\">VL_COVDET</a>(), prefixed by the 'Liop' string\n(e.g. 'LiopIntensityThrehsold').\n</p></dd><dt>\nPatch\n</dt><dd><p>\nRaw patches. In this case, each column of D is a stacked square\nimage patch. This is very useful to compute alternative\nuser-defined descriptors.\n</p></dd></dl><p>\nThe following parameters can be used to control the produced\ndescriptors:\n</p><dl><dt>\nPatchResolution\n<span class=\"defaults\">15 (SIFT) or 20 (LIOP, Patch)</span></dt><dd><p>\nThe size of the patch R in pixel. Specifically, the patch is a\nsquare image of side 2*R+1 pixels.\n</p></dd><dt>\nPatchRelativeExtent\n<span class=\"defaults\">7.5 (SIFT), 10 (LIOP), or 6 (Patch)</span></dt><dd><p>\nThe extent E of the patch in the normalized feature frame. The\nnormalized feature frame is mapped to the feature frame F\ndetected in the image by a certain affine transformation (A,T)\n(see <a href=\"vl_plotframe.html\">VL_PLOTFRAME</a>() for details). The patch is a square [-E,\nE]^2 in the normalize frame, and its shape in the original image\nis the (A,T) of it.\n</p></dd><dt>\nPatchRelativeSmoothing\n<span class=\"defaults\">1 (SIFT and LIOP), 1.2 (Patch)</span></dt><dd><p>\nThe smoothing SIGMA of the patch in the normalized feature\nframe. Conceptually, the normalized patch is computed by warping\nthe image (thought as a continuous signal) by the inverse of the\naffine transformation (A,T) discussed above, then by smoothing\nthe wrapped image by a 2D isotropic Gaussian of standard\ndeviation SIGMA, and finally by sampling the resulting signal.\n</p></dd></dl><p>\n[F,D,INFO] = <a href=\"vl_covdet.html\">VL_COVDET</a>(...) returns an additional structure INFO\nwith the following members:\n</p><dl><dt>\ninfo.peakScores\n</dt><dd><p>\nThe peak scores of the detected features.\n</p></dd><dt>\ninfo.edgeScores\n</dt><dd><p>\nThe edge scores of the detected features.\n</p></dd><dt>\ninfo.orientationScores\n</dt><dd><p>\nThe peak score of the gradient orientation histograms used to\nassign an orientation to the detected features.\n</p></dd><dt>\ninfo.laplacianScaleScores\n</dt><dd><p>\nThe peak score of the Laplacian measure used to select\nthe scale of the detected features.\n</p></dd><dt>\ninfo.gss\n</dt><dd><p>\nThe Gaussian scale space (see <a href=\"vl_plotss.html\">VL_PLOTSS</a>()).\n</p></dd><dt>\ninfo.css\n</dt><dd><p>\nThe cornerness measure scale space (see <a href=\"vl_plotss.html\">VL_PLOTSS</a>()).\n</p></dd></dl><p>\nIn addition to the ones discussed so far, the function supports\nthe following options:\n</p><dl><dt>\nOctaveResolution\n<span class=\"defaults\">3</span></dt><dd><p>\nThe number of scale levels sampled per octave when constructing\nthe scale spaces.\n</p></dd><dt>\nDoubleImage\n<span class=\"defaults\">true</span></dt><dd><p>\nWhether to double the image before extracting features. This\nallows to detect features at minimum smoothing level (scale) of\n0.5 pixels rather than 1.0, resulting in many more small\nfeatures being detected.\n</p></dd><dt>\nVerbose\n</dt><dd><p>\nIf specified, it increases the verbosity level.\n</p></dd><dt>\nREFERENCES\n</dt></dl><p>\n[1] D. G. Lowe, Distinctive image features from scale-invariant\nkeypoints. IJCV, vol. 2, no. 60, pp. 91-110, 2004.\n</p><p>\n[2] K. Mikolajcyk and C. Schmid, An affine invariant interest\npoint detector. ICCV, vol. 2350, pp. 128-142, 2002.\n</p><p>\nSee also: <a href=\"vl_sift.html\">VL_SIFT</a>(), <a href=\"vl_liop.html\">VL_LIOP</a>(), <a href=\"vl_plotframe.html\">VL_PLOTFRAME</a>(), <a href=\"vl_plotss.html\">VL_PLOTSS</a>(), <a href=\"vl_help.html\">VL_HELP</a>().\n</p></div></div>\n      </div>\n      <div class=\"clear\">&nbsp;</div>\n    </div>\n  </div> <!-- content-section -->\n  <div id=\"footer-section\">\n    <div id=\"footer\">\n      &copy; 2007-13 The authors of VLFeat\n    </div> <!-- footer -->\n  </div> <!-- footer section -->\n </body>\n <!-- Body ends -->\n</html>\n ", "encoding": "ascii"}