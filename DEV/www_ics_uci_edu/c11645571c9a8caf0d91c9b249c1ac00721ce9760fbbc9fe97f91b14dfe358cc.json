{"url": "https://www.ics.uci.edu/~dan/class/165/notes/memory.html", "content": "<HTML><HEAD>\n<TITLE> Pointers and Memory Allocation\n</TITLE>\n</HEAD><BODY>\n<span style=\"color:#000000; font:16px Arial, Helvetica, sans-serif;\">\n\n<H2> Pointers and Memory Allocation </H2>\n\nWhen declaring a variable, the type given is the type of any expression\nwhich looks like the declaration.  Thus, if we have the declarations\n<center>\n<tt>    int a, *b, c[], *(*d[])();</tt>\n</center>\nthen, in the code, the expressions\n<tt>a</tt>, <tt>*b</tt>, <tt>c[]</tt> and <tt>*(*d[])()</tt>\nwould all evaluate to an integer.&nbsp;\nEncountering the declaration, you might\nhave a hard time figuring out that <tt>d</tt> is an\narray of pointers to functions which return integer pointers,\nbut you <I>do</I> know what type it will evaluate to\nwhen used in the context given.&nbsp;\nThus you know that the statement\n<tt>a = *(*d[5])(x, y)</tt>\nwill place an integer in <tt>a</tt>, even if you are not\nsure what happened.&nbsp;\nYou could similarly match types by stripping\noff matching levels of indirections:&nbsp;\n<tt>b = (*d[5])(x, y)</tt> would store\nan integer pointer in <tt>b</tt> rather than the value of the integer.\n<P>\nAlthough the expression given in the declaration is generally the\n<I>correct</I> way to use the variable,\nthe relation between pointers and arrays allows for other uses.&nbsp;\nSince an array name is just a pointer, we can actually use the\nexpressions <tt>b[]</tt> and <tt>*c</tt> as well.&nbsp;\n(Using the alternate notation is\noften confusing but occasionally more clear.)&nbsp;\nFor example, the sixth\nelement of an array, declared by either of the two methods mentioned\nabove, can be accessed in either of the two following methods:&nbsp;\n<center>\n<tt>    b[5]</tt> &nbsp; or &nbsp; <tt>*(b+5)</tt>\n</center>\n(Recall that the monadic \"<tt>*</tt>\" operator merely takes the\nvalue at the right and performs one level of indirection on it.)\nThe second method adds 5*(size of the array element type) to the address\nof array, resulting in a pointer to the sixth element, and then the \"*\"\ncauses an indirection on that address, resulting in the value stored\nthere.  The subscripted notation is merely shorthand for this.\n<P>\nFor a lab, your testing programs might know that the input is restricted\nto 1000 digits, but your multiplier should not know this.&nbsp;\nThus, you will need to allocate one-dimensional arrays of unpredictable\nsize within these functions.&nbsp;\nTo do this, use the system library\nfunction <I>malloc</I> which will give you a specified number of\ncontiguous bytes of memory.&nbsp;\nYou must first, in your declarations,\ntell the compiler the type of the return value of\n<I>malloc</I> with the\ndeclaration (along with your variable declarations):&nbsp;\n<center>\n<tt>char *malloc();</tt>\n</center>\n<P>\nNow, let's say you want an array of 10 integers.&nbsp;\nLet <tt>A</tt> be\nan integer pointer (declared <tt>int *A</tt>).&nbsp;\nTo get the array, use the command:\n<center>\n<tt>    A = (int *) malloc( 10 * sizeof(int) );</tt>\n</center>\nThe <tt>sizeof()</tt> function is expanded by the compiler to be the\nnumber of bytes in one element of the type given as the argument.&nbsp;\nThus, if there are 4 bytes in\nan integer, <I>malloc</I> will return 40 bytes\n(beginning on a double-word\nboundary to guarantee proper alignment of multiple-byte objects -- you\ndon't need to worry about this).\n<P>\nThe <tt>(int *)</tt> preceeding the function call is called a\n<I>cast</I>.\nThis changes the\ntype of the return of <I>malloc</I>\n(which is a character pointer) into an\ninteger pointer so that it may be stored in <tt>A</tt>.&nbsp;\nOften casts only\naffect the compiler's internal representation of what a type is but\noccasionally they generate code to physically modify data, so you should\nalmost always use them when mixing things of differing types.\n<P>\nAlways make sure, after calling <I>malloc</I>, that you actually got the\nspace you requested.&nbsp;\n<I>Malloc</I> will return a null pointer if it could not\nget you the space.&nbsp;\nA null pointer can be represented in your code as a\nzero, or as <tt>NULL</tt>\nif you include the standard I/O file <tt>&lt;stdio.h&gt;</tt>.\n<P>\nFinally, the function <I>free</I> is used to return space to the\noperating system which was allocated by <I>malloc</I>.&nbsp;\nYou should give,\nas a parameter, to <I>free</I> exactly the pointer given to you by\n<I>malloc</I>.&nbsp;\nYou cannot give back part of an allocation.&nbsp;\nThus there\nshould be exactly as many calls to <I>free</I> as to <I>malloc</I>, and\nthey should involve exactly the same blocks of memory.\n<P>\n<H3> Multi-dimensional arrays </H3>\n\nC uses two implementations of arrays, depending on the declaration.\nThey are the same for one dimension, but different for more dimensions.\n<P>\nFor example, if an array is declared as\n<center>\n<tt>int array[10][20][30];</tt>\n</center>\nthan there are exactly 6000 ints of storage allocated, and a reference\nof the form <tt>array[i][j][k]</tt> will be translated to\n<center>\n<tt>*( array + i*20*30 + j*30 + k )</tt>\n</center>\nwhich calculates the correct offset from the pointer \"array\", and then\ndoes an indirection on it.  To pass an array of this type to a\nprocedure, you must declare the parameter as\n<center>\n<tt>proc( arg ) int arg[][20][30];</tt>\n</center>\n(You may declare the value of the first dimension, but the compiler\ndoesn't care since it is not needed.)\n<P>\nYou will probably not be using this kind of array, since you don't have\nconstant bounds on the sizes of any of your arrays.\n<P>\nThe second type of array is a pointer-vector structure, where each\ndimension is represented by a vector of pointers of objects of the next\ndimension, except the last dimension, which consists of arrays of data.\nThis sounds like a mess, but it really isn't:\n<P>\nIf a three-dimensional array is declared as\n<center>\n<tt>int ***array;</tt>\n</center>\n(and we will assume for the moment that it has been allocated space\nfor a 10*20*30 array), then there is an array of 10 pointers to pointers\nto ints, 10 arrays of 20 pointers to ints, and 6000 ints.&nbsp;\nThe 200 elements of the 10 arrays each point to a block of 30 ints,\nand the 10 elements of the one array each point\nto one of the 10 arrays.&nbsp;\nThe array variable points to the head of the array with 10 elements.\n<P>\nIn short,\n\"<tt>array</tt>\" points to a pointer to a pointer to an integer,\n\"<tt>*array</tt>\" points to a pointer to an integer,\n\"<tt>**array</tt>\" points to an integer, and\n\"<tt>***array</tt>\" is an integer.\n<P>\nIn this case, an access of the form <tt>array[i][j][k]</tt>\nresults in an access of the form\n<center>\n<tt>*( *( *(array+i) + j ) + k )</tt>\n</center>\n<P>\nWhich means:&nbsp;\nTake a pointer to the main array, add <tt>i</tt> to offset to the\npointer to the correct second dimension array and indirect to it.&nbsp;\nNow we have a pointer to one of the arrays of 20 pointers,\nand we add <tt>j</tt> to get the offset to the next dimension,\nand we do an indirection on that.&nbsp;\nWe now have a pointer to an array of 30 integers,\nso we add <tt>k</tt> to get a pointer to the desired integer,\ndo an indirection, and we have the integer.\n<P>\nPassing arrays of this type is simple,\nyou declare the parameter the same way, as \"<tt>int ***arrayname</tt>\".\n<P>\nNow the fun begins:&nbsp; how to allocate memory for a pointer-vector\narray.&nbsp;  We get memory with the function\n<center>\n<tt>char *malloc( nbytes );</tt>\n</center>\n<I>malloc</I> returns a character pointer to a contiguous block of\n<I>nbytes</I> bytes, or a <tt>NULL</tt> pointer\n(<tt>NULL</tt> is defined in the library package\n<tt>&lt;stdio.h&gt;</tt>) if it cannot get the space.\n<P>\nAs before, we will assume that the variable is defined as\n<center>\n<tt>int ***array;</tt>\n</center>\nand we want the dimensions to be 10*20*30 (all of the stuff below could\nbe done for an arbitrary <tt>i</tt>,<tt>j</tt>,<tt>k</tt>, which is closer to what you need).\n<P>\nFirst, we need an array of 10 <tt>int **</tt>'s,\nso we use the following:\n<center>\n<tt>array = (int ***) malloc( 10 * sizeof(int **) );</tt>\n</center>\nThe <I>sizeof</I> function returns an integer telling how many bytes\nare needed by something of type \"<tt>int **</tt>\",\nand we need 10 of them.&nbsp;\nThe \"<tt>(int ***)</tt>\" is a cast which changes the pointer type\nfrom \"<tt>char *</tt>\" to \"<tt>int ***</tt>\",\nto keep the types correct.&nbsp;\nDon't forget that, after this\ncall to <I>malloc</I>, you should check to see if <tt>array==NULL</tt>.\n<P>\nNote:&nbsp; <I>malloc</I> is asked for 10 <tt>int **</tt>'s\nbut its return is a pointer to them,\nso the result is an <tt>int ***</tt>.\n<P>\nNow that we have the 10 pointers, we can get the next level of\npointers:\n<pre>\n\tfor ( i = 0 ; i < 10 ; ++i ) {\n\t    array[i] = (int **) malloc( 20 * sizeof(int *) );\n\t}\n</pre>\nAnd finally, we can fill in each of these pointers with an array of 30\nintegers:\n<pre>\n\tfor ( i = 0 ; i < 10 ; ++i ) {\n\t    for ( j = 0 ; j < 20 ; ++j ) {\n\t\tarray[i][j] = (int *) malloc( 30 * sizeof(int) );\n\t    }\n\t}\n</pre>\nAgain, remember that each call to malloc must check the result.&nbsp;\nAlso note that we could have put the two steps above together,\nfilling each set of 20 pointers as we get them.\n<P>\nIt is <I>much</I> more efficient to combine all similar allocations\nand divide up the memory after getting it.&nbsp;\n(It is also <I>much</I> easier to make mistakes.)&nbsp;\nWhen you've convinced yourself the the following works, you will\nunderstand C pointers fairly well.\n<P>\n<pre>\n\tarray = (int ***) malloc( 10 * sizeof(int **) );\n\tarray[0] = (int **) malloc( 10 * 20 * sizeof( int *) );\n\tarray[0][0] = (int *) malloc( 10 * 20 * 30 * sizeof(int) );\n\tfor ( j = 1  ;  j < 20  ;  ++j ) {\n\t    array[0][j] = array[0][j-1] + 30;\n\t}\n\tfor ( i = 1  ;  i < 10  ;  ++i ) {\n\t    array[i] = array[i-1] + 20;\n\t    array[i][0] = array[i-1][20-1] + 30;\n\t    for ( j = 1  ;  j < 20  ;  ++j ) {\n\t\tarray[i][j] = array[i][j-1] + 30;\n\t    }\n\t}\n</pre>\n<P>\nThis is the method you should use, but you will probably only need two\ndimensional arrays,\nwhich are far easier once you understand this example.\n<P>\nSpace is returned to the system with the command\n<center>\n<tt>free( pointer );</tt>\n</center>\n<P>\nFor returning the space to the system, you <I>always</I>\nreturn exactly what\nyou were given, <I>i.e.</I>,\nthe exact pointer that <I>malloc</I> gave you.&nbsp;\nYou cannot return a portion of an allocation.&nbsp;\nThus there should be a perfect \none-to-one correspondence between calls to <I>malloc</I>\nand calls to <I>free</I>.\n<P>\n</span>\n<HR>\n\nLast modified: Mar 25, 2016\n</BODY></HTML>\n", "encoding": "ascii"}