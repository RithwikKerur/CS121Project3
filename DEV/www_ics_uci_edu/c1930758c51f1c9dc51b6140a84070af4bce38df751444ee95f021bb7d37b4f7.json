{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/disassembly.txt", "content": "See new form: type bytes/instruction\r\nSee Extend_address to user larger addresses (by one more byte); can be used\r\n  multiple times (comes prior to instruction, with upper bits)\r\n\r\n\t\tExecuting Code in The Python Virtual Machine\r\n\r\nLevels of abstraction are important in computing. We can look at a computer\r\n(and the software it runs) at many levels of abstraction: as quantum devices\r\nimplementing logical components, as collections of these components implementing\r\ndigital circuits (described by Boolean formulas), as digital circuits combined\r\ninto an instruction set architecture (ISA which we'll cover in today's lecture)\r\nas an architecture capable of running \"translated\" computer programs written in\r\na high-level language, as large applications written in high-level programming\r\nlanguages, and as distributed/networked applications running on multiple\r\nmachines communicating over a network.\r\n\r\nIt is difficult to hold all these levels of abstraction in our minds while we\r\nare exploring and creating computing systems/software. We often focus on just\r\none level of abstraction for our jobs, while knowing some -but less- about the\r\nlevels directly below and above. We have spent most of ICS 31-33 at the level\r\nof discussing computing via the high-level programming language Python. In this\r\nlecture we will look down one level, at the architecture, which Python programs\r\nare translated into and run on: the Python Virtual Machine.\r\n\r\nSome programming languages (e.g., C++) are translated into instructions that\r\nrun directly on hardware. We speak of \"compiling\" programs in that language onto\r\na specific hardware architecture. Other programming languages (e.g., Java and\r\nPython) are translated to run on a common architecture. Interpreters (or\r\nvirtual machines) for that architecture can be written in a low-level language\r\n(like C, which targets most architectures) or in the machine's hardware language\r\nitself for maximal speed. Exactly the same translated Java/Python programs can\r\nrun unchanged on any architecture that has the virtual machine program\r\nimplemented on it. It is really running under control of the virtual machine\r\nprogram, not the hardware itself.\r\n\r\nThe compiling approach has the advantage of producing programs that execute\r\nspeedily on real machines. But it is a large undertaking to produce a good\r\ncompiler for a new architecture, and compiling a program can take a long time.\r\nThe virtual machine approach is much easier to port to new architectures (it\r\nrequires writing just one smallish, well-understood program that on the new\r\narchitecture) but the extra layer of software (even as well as we know how to\r\nwrite interpreters) above the machine reduces performance, often by a factor\r\n2-10, or even more. So there is no right way to write language translators:\r\neach approach comes with its own advantages and disadvantages, and each can be\r\nused/abused in situations.\r\n\r\nIn fact, hot-spot compilers do a bit of both. They profile programs while\r\ninterpreting them to find their hots spots (small amounts of code that are\r\nexecuted frequently) and then they compile just those small pieces -all while\r\nrunning the program- so they execute at maximal speed. Language translation is\r\nand has always been an important area in Computer Science. At UCI this topic is\r\ncovered initially in COMPSCI 142A/B: Language Processor Construction. The\r\ncomputer architectures for real machines (into which compiled programs are\r\ncompiled) are covered first in ICS-51.\r\n\r\nIn this lecture we will discuss the code that Python is translated into and how\r\nthis code is run on the Python Virtual Machine. There is no way to cover this\r\ntopic fully in one lecture, so my goal is just to introduce this material and\r\nshow you an interesting vertical slice through it. We will leverage off Python's\r\ndis.py module, whose dis function (\"dis\" means \"disassembly\") shows us, in a\r\nreadable form, the Virtual Machine instructions that Python functions, classes,\r\nand modules are translated into. At the very end of this lecture we will return\r\nto material related to analysis of algorithms, by counting the instructions that\r\nour Python functions are translated into.\r\n\r\nFinally, see Section 31.12 in the Python Library documentation for many more\r\ndetails about today's lecture. Once you \"get\" the big picture, you might find\r\nit quite interesting to \"dis\" a variety of software components. I tried to find\r\ninformation about the Python Virtual Machine on the web, but it is pretty\r\nsparse. So I put together this lecture based on general principles and the\r\ndocumentation I could find. There is much more information available for the\r\nJava virtual machine.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nBasics: \r\n\r\nEvery function object (what we are mostly concerned with in this lecture) is\r\nassociated with 3 tuples:\r\n\r\n  (1) its local variable names including parameters (in .__code__.co_varnames)\r\n  (2) the global names it uses                      (in .__code__.co_names)\r\n  (3) the constants it uses                         (in .__code__.co_consts)\r\n\r\nThese tuples are built at the time Python defines the function; they are stored\r\nin the __code__ object associated with the function.\r\n\r\nFor example, if we define\r\n\r\ndef minimum(alist):\r\n    m = None if len(alist) == 0 else alist[0]\r\n    for v in alist[1:]:\r\n        if v < m:\r\n            m = v\r\n    return m\r\n\r\nThen,\r\n  minimum.__code__.co_varnames is ('alist', 'm', 'v')\r\n  minimum.__code__.co_names    is ('len', 'None')\r\n  minimum.__code__.co_consts   is (None, 0, 1)\r\n\r\nLoad operations (e.g., LOAD_FAST, LOAD_GLOBAL, LOAD_CONST, which are all\r\ndiscussed in more detail below) are followed by an integer that indexes these\r\ntuples. So for example, in the function addup addup.__code__.co_varnames is the\r\nlist ('alist', 'sum', 'v'), so the operation LOAD_FAST  0 loads/pushes onto the\r\nstack the value the name alist refers to. LOAD_FAST  1 loads/pushes onto the\r\nstack the value the name sum refers to. LOAD_FAST  2 loads/pushes onto the\r\nstack the value the name v refers to. This scheme allows us to use simple\r\nnumbers to enumerate arbitrary names.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe Python Virtual Machine (PVM) and an example trivial calculation\r\n\r\nThe main data structure in the PVM is the \"regular\" stack (which is like a\r\nrestricted a list, allowing only the operations push=append and pop=pop; those\r\nare both O(1) operations). A stack's primary operations are load/push and\r\nstore/pop. We load/push a value on the top of an upwardly-growing stack\r\n(incrementing the stackp -stack pointer- that indexes the top); we store/pop a\r\nvalues from the top of a stack (decrementing the stackp).\r\n\r\nThere is a secondarily important block stack that is used to store information\r\nabout nested loops, try/except, and with statements. For example, a break\r\nstatement is transated into code that uses the block stack to determine which\r\nloop to break out of (and how to continue executing at the first statement\r\noutside the loop). When Python begins the execution of loops, try/except, and\r\nwith statements, information about their blocks are pushed onto the block stack;\r\nwhen Python terminates executing these control strucutures, this information is\r\npopped off the block stack. The block stack is too complicated to discuss in\r\ntoday's lecture and we do not needed to understand it: so when we run across\r\nblock stack instructions we will point out the fact that we are ignoring them.\r\n\r\nHere is an example of a simple sequence of stack operations to perform the\r\ncalculation d = a+b*c, assuming that a, b, c, and d are local variables inside\r\na function: assume co_varnames is ('a', 'b', 'c', 'd') and the actual values\r\nfor these names are stored in a parallel list [1, 2, 3, None]: e.g., the value\r\nfor 'a' is 1, the value for 'b' is 2, the value for 'c' is 3, and the value for\r\n'd' is None. Generally the value for a name at index i in the co_varnames tuple\r\nis stored in index i in the list of actual values.\r\n\r\nAs we will see in more detail below the meaning of \r\n\r\n  LOAD_FAST N\r\n    load/push onto the stack the value stored in co_varnames[N],\r\n    written stackp += 1, stack[stackp] = co_varnames[N] \r\n\r\n  STORE_FAST N\r\n    store/pop the value on the top of the stack into co_varnames[N],\r\n    written co_varnames[N] = stack[stackp], and stackp -= 1\r\n\r\n  BINARY_MULTIPLY\r\n    load/push onto the stack the * of the two values on the top,\r\n    written stack[stackp-1] = stack[stackp-1] * stack[stackp]; stackp -= 1\r\n    (turns the two values on the top of the stack into their product)\r\n\r\n  BINARY_ADD\r\n    load/push onto the stack the + of the two values on the top\r\n    written stack[stackp-1] = stack[stackp-1] + stack[stackp]; stackp -= 1\r\n    (turns the two values on the top of the stack into their sum)\r\n\r\nThe PVM code for d = a+b*c is\r\n\r\n  LOAD_FAST 0\r\n  LOAD_FAST 1\r\n  LOAD_FAST 2\r\n  BINARY_MULTIPLY\r\n  BINARY_ADD\r\n  STORE_FAST 3\r\n\r\nHere is what happens step by step.\r\n\r\nInitially\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 |                    |\r\n   +--------------------+\r\n 0 |                    |\r\n   +--------------------+\r\nstack (with stackp = -1, meaning is empty stack)\r\n\r\nexecute LOAD_FAST 0\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 |                    |\r\n   +--------------------+\r\n 0 | 1: value of a      |\r\n   +--------------------+\r\nstack (with stackp = 0)\r\n\r\nexecute LOAD_FAST 1\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 | 2: value of b      |\r\n   +--------------------+\r\n 0 | 1: value of a      |\r\n   +--------------------+\r\nstack (with stackp = 1)\r\n\r\nexecute LOAD_FAST 2\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 | 3: value of c      |\r\n   +--------------------+\r\n 1 | 2: value of b      |\r\n   +--------------------+\r\n 0 | 1: value of a      |\r\n   +--------------------+\r\nstack (with stackp = 2)\r\n\r\nexecute BINARY_MULTIPLY\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 | 6: value of b*c    |\r\n   +--------------------+\r\n 0 | 1: value of a      |\r\n   +--------------------+\r\nstack (with stackp = 1)\r\n\r\nexecute BINARY_ADD\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 |                    |\r\n   +--------------------+\r\n 0 |7: value of a+b*c   |\r\n   +--------------------+\r\nstack (with stackp = 0)\r\n\r\nexecute STORE_FAST 3\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 |                    |\r\n   +--------------------+\r\n 0 |                    |\r\n   +--------------------+\r\nstack (with stackp = -1)\r\n\r\nAt this point d's value is 7, the value that was at the top of the stack when\r\nSTORE_FAST was executed. The actual values for these names are stored in the\r\nlist [1, 2, 3, 7].\r\n\r\nProblem: show (by drawing what I drew above) how the following instructions\r\ncompute d = (a+b)*c\r\n\r\n  LOAD_FAST 0\r\n  LOAD_FAST 1\r\n  BINARY_ADD\r\n  LOAD_FAST 2\r\n  BINARY_MULTIPLY\r\n  STORE_FAST 3\r\n\r\nAny similar expression can be translated into similar code for the PVM to\r\nevaulate its value by loading values onto the stack and performing operations.\r\nThe order of loads/operations depends what expression is being computed.\r\n\r\nI will briefly explore (Polish) postfix notation, which we can use to\r\nunambiguously specify arithemtic expressions, without resorting to\r\noperator precedence or parentheses. It is trivial to translate postfix\r\nexpressions into the kind of stack-based code explored above.\r\n\r\n-------------------------\r\n\r\nControl (the fetch/execute cycle) of the PVM\r\n\r\nEach instruction (some of which are shown above) in the PVM consists of 1 or 3\r\nbytes of information (a byte is 8 bits, and can represent numbers from 0 to\r\n2**8 = 255). The first byte is the operation or byte code; the second two bytes\r\nare the operand for that byte code (but not all byte codes require operands:\r\nLOAD_FAST does; BINARY_ADD doesn't). Two bytes (16 bits) can represent the\r\nunsigned numbers 0 to 2**16 = 65,535: when I first learned this fact, I\r\nconjectured that Python function cannot have more than 65,536 different local\r\nvariable names (it turns out I was wrong; a student showed me a Python function\r\nthat had more variables, and it still was still able to be translated and run).\r\nCan you think how the student wrote such a large function and tested it? There\r\nare other special Python operations that allow exceeding the 2-byte limit.\r\n\r\nThe instructions are stored in memory: think of memory too as a kind of list\r\nof bytes, named m, which stores sequential data (bytes) in one location after\r\nthe other. We can illustrate this by writing the instruction sequence above as\r\nfollows:\r\n\r\n  Memory     Instruction\r\n  Location   \r\n--------------------------\r\n   0         LOAD_FAST 0\t(load in byte 0, 0 in bytes 1 and 2)\r\n   3         LOAD_FAST 1\t(load in byte 3, 1 in bytes 4 and 5)\r\n   6         LOAD_FAST 2\t(load in byte 6, 2 in bytes 7 and 8)\r\n   9         BINARY_MULTIPLY\t(multiply operation in byte 9)\r\n  10         BINARY_ADD\t\t(add      operation in byte 10\r\n  11         STORE_FAST 3\t(store in byte 11, 3 in bytes 12 and 13)\r\n\r\nJust as the virtual machine has the name stackp for indexing the stack, it has\r\na name pc (program counter) for indexing memory.\r\n\r\nNote that the first instruction is stored in m[0], and each subsequent\r\ninstruction is stored in a location that is 3 higher (if the instruction has an\r\nexplicit operand, as the load/store instructions do; most instructions have\r\nimplicit operands: stack and pc) or 1 higher (if the instruction has no explicit\r\noperands, as the binary operator instructions do).\r\n\r\nTechnically, the operation name (e.g., LOAD_FAST) represents a one byte value\r\n(an integer from 0 to 255). The next two bytes are typically the higher and\r\nlower bits in an integer between 0 and 2**16-1: 65,535.\r\n\r\nOnce a program (instruction sequence) is loaded into memory, the PVM executes\r\nit according to the following simple rules. This control/execute cycle is what\r\nanimates computers, allowing then to execute programs. It is fundamental in\r\nComputer Science. Here we assume pc is initially 0 (the index where the program\r\nstarts).\r\n\r\n (1) Fetch the operation and its operand (if present) starting at m[pc]\r\n (2) pc += 3 (if operator 2-byte operand) or pc += 1 (if no operand is present)\r\n (3) Execute the operation code (maybe change its operand, stack, stackp, or pc)\r\n (4) Go to step 1\r\n\r\nSome operations manipulate the stack/stackp and the lists that store values,\r\nothers can change the pc (examples of such jump instructions appear in later\r\nsections, changing the locus of execution of the code).\r\n\r\nSo, when the pc is initially 0, the PVM executes the code above as follows\r\n\r\n 1. fetches the operation a m[0] and the operand at m[1] and m[2]\r\n 2. increments pc to 3\r\n 3. manipulates the stack (see above)\r\n 4. goes back to step 1\r\n\r\n 1. fetches the operation a m[3] and the operand at m[4] and m[5]\r\n 2. increments pc to 6\r\n 3. manipulates the stack (see above)\r\n 4. goes back to step 1\r\n\r\n 1. fetches the operation a m[6] and the operand at m[7] and m[8]\r\n 2. increments pc to 9\r\n 3. manipulates the stack (see above)\r\n 4. goes back to step 1\r\n\r\n 1. fetches the operation a m[9]: it has no operand\r\n 2. increments pc to 10\r\n 3. manipulates the stack (see above)\r\n 4. goes back to step 1\r\n\r\n 1. fetches the operation a m[10]: it has no operand\r\n 2. increments pc to 11\r\n 3. manipulates the stack (see above)\r\n 4. goes back to step 1\r\n\r\nAt this point there is no more code to execute. In the next example we will\r\nsee how the PVM executes more complicated code, specified by full (but still\r\nsimple) Python functions.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe dis function in the dis module\r\n\r\nAs described briefly in the intoduction, we can print a symbolic/annotated\r\ndesciption of any Python function (and module/class too; but in this lecture\r\nnote we will stick with just functions) by using the dis function in the dis.py\r\nmodule. Here \"dis\" means \"disassemble\" the code in the function object into a \r\nform that is readable by people. The dis function prints information in the\r\nconsole window (a better idea would be for it to return a string that could be\r\nprinted or processed in other ways).\r\n\r\nHere is an example function (with line numbers) and the result dis.dis displays\r\nfor it). All the operation codes and their meanings are covered in detail in\r\nthe next section; we will look ahead at the relevant ones.\r\n\r\n1 def addup(alist):\r\n2     sum = 0\r\n3     for v in alist:\r\n4         sum = sum + v\r\n5    return sum\r\n\r\nActually, I wrote the following simple function to show useful information\r\nabout any function object (its name, its three tuples, and the dis information:)\r\nlabelled.\r\n\r\ndef func_obj(fo):\r\n    print(fo.__name__)\r\n    print('  co_varnames:',fo.__code__.co_varnames)\r\n    print('  co_names   :',fo.__code__.co_names)\r\n    print('  co_consts  :',fo.__code__.co_consts,'\\n')\r\n    print('Source Line  m  operation/byte-code      operand (useful name/number)\\n'+69*'-')\r\n    dis.dis(fo)\r\n\r\ncalling func_obj(addup) prints the information about the addup function:\r\n\r\naddup\r\n  co_varnames: ('alist', 'sum', 'v')\r\n  co_names   : ()\r\n  co_consts  : (None, 0)\r\n\r\nSource Line  m  op/byte-code             operand (useful name/number)\r\n---------------------------------------------------------------------\r\n  2           0 LOAD_CONST               1 (0) \r\n              3 STORE_FAST               1 (sum) \r\n\r\n  3           6 SETUP_LOOP              24 (to 33) \r\n              9 LOAD_FAST                0 (alist) \r\n             12 GET_ITER             \r\n        >>   13 FOR_ITER                16 (to 32) \r\n             16 STORE_FAST               2 (v) \r\n\r\n  4          19 LOAD_FAST                1 (sum) \r\n             22 LOAD_FAST                2 (v) \r\n             25 BINARY_ADD           \r\n             26 STORE_FAST               1 (sum) \r\n             29 JUMP_ABSOLUTE           13 \r\n        >>   32 POP_BLOCK            \r\n\r\n  5     >>   33 LOAD_FAST                1 (sum) \r\n             36 RETURN_VALUE         \r\n\r\nNote that any line prefaced by >> means that some other instruction in the\r\nfunction will jump to it (start executing code at it). Jumping in the PVM (by\r\nsetting pc) is how loops and if statements in Python do their computation:\r\nrepeating code in a loop; deciding which block to execute in an if.\r\n\r\nHere is a high-level description how this function executes. For more details,\r\nsee the exact description of each instruction in the next section.\r\n\r\nLine 2:\r\n m[ 0]: loads the value 0 (co_consts[1]) on the stack\r\n m[ 3]: stores the value 0 into sum (co_varnames[1])\r\n\r\nLine 3:\r\n m[ 6]: setup for the loop by pushing the size of the loop onto the block stack\r\n          (recall that we won't be doing anything with the block stack)\r\n m[ 9]: loads the value of alist (co_varnames[0]) on the stack\r\n m[12]: replaces its value on the stack by its iterator (by popping and pushing)\r\n m[13]: loads the next iterator value on the stack (like next(),\r\n           jumping to m[32] - the pc + 16- if StopIteration is raised\r\n          (code in m[29] jumps back to this location to make the code loop)\r\n m[16]: stores the next value into v (co_varnames[2]), popping it off the stack\r\n\r\nLine 4:\r\n m[19]: loads the value of sum (co_varnames[1]) on the stack\r\n m[22]: loads the value of v (co_varnames[2]) on the stack\r\n m[25]: removes from stack/adds two values, pushes the result on the stack\r\n m[26]: stores the value into sum (co_varnames[1]), popping it off the stack\r\n m[29]: sets pc to 13, so the next instruction executed in at m[13]\r\n          (jumps back to a previous location to make the code loop)\r\n m[32]: pops what m[6] pushed onto the block stack\r\n          (recall that we won't be doing anything with the block stack)\r\n          (code in m[13] jumps here, on StopIteration, terminating the loop)\r\n\r\nLine 5:\r\n m[33]: load the value of sum (co_varnames[1]) on the stack to return\r\n m[36]: return from the function with the result on the top of the stack\r\n\r\n------------------------------------------------------------------------------\r\n\r\nOperation/Byte Codes\r\n\r\nBelow is a list of many important operations and how they manipulate the PVM.\r\nThe complete list is available in section 31.12 of the Python documenation.\r\nRecall that many operations manipulate stack, stackp, and pc.\r\n\r\nLoading/Storing\r\n\r\n  LOAD_CONST   N\r\n    stackp += 1, stack[stackp] = co_consts[N] \r\n  LOAD_FAST    N\r\n    stackp += 1, stack[stackp] = co_varnames[N] \r\n  LOAD_GLOBAL  N\r\n    stackp += 1, stack[stackp] = co_names[N] \r\n  STORE_CONST  N\r\n    co_consts[N] = stack[stackp], and stackp -= 1\r\n  STORE_FAST   N\r\n    co_varnames[N] = stack[stackp], and stackp -= 1\r\n  STORE_GLOBAL N\r\n    co_names[N] = stack[stackp], and stackp -= 1\r\n\r\nThere are general Load and Store operations that look up names based on the\r\nthe LEGB rules, if Python is unsure where these names will be found. Generally\r\nit uses the operations above.\r\n\r\nOperators\r\n  UNARY_POSITIVE \r\n    stack[stackp] = +stack[stackp]\r\n  UNARY_NEGATIVE \r\n    stack[stackp] = -stack[stackp]\r\n  UNARY_NOT \r\n    stack[stackp] = not stack[stackp] (for bool values)\r\n  UNARY_INVERT \r\n    stack[stackp] = ~stack[stackp]\r\n\r\n  BINARY_ADD\r\n    stack[stackp-1] = stack[stackp-1] + stack[stackp]; stackp -= 1\r\n  BINARY_SUBTRACT \r\n    stack[stackp-1] = stack[stackp-1] - stack[stackp]; stackp -= 1\r\n  BINARY_MULTIPLY\r\n    stack[stackp-1] = stack[stackp-1] * stack[stackp]; stackp -= 1\r\n  BINARY_TRUE_DIVIDE \r\n    stack[stackp-1] = stack[stackp-1] / stack[stackp]; stackp -= 1\r\n  BINARY_FLOOR_DIVIDE \r\n    stack[stackp-1] = stack[stackp-1] // stack[stackp]; stackp -= 1\r\n  BINARY_MODULO \r\n    stack[stackp-1] = stack[stackp-1] % stack[stackp]; stackp -= 1\r\n  BINARY_POWER \r\n    stack[stackp-1] = stack[stackp-1] ** stack[stackp]; stackp -= 1\r\n\r\n  BINARY_SUBSCR (indexing/subscripting)\r\n    stack[stackp-1] = stack[stackp-1] [ stack[stackp] ]; stackp -= 1\r\n\r\n  BINARY_LSHIFT \r\n    stack[stackp-1] = stack[stackp-1] << stack[stackp]; stackp -= 1\r\n  BINARY_RSHIFT \r\n    stack[stackp-1] = stack[stackp-1] >> stack[stackp]; stackp -= 1\r\n\r\n  BINARY_AND \r\n    stack[stackp-1] = stack[stackp-1] & stack[stackp]; stackp -= 1\r\n  BINARY_OR \r\n    stack[stackp-1] = stack[stackp-1] | stack[stackp]; stackp -= 1\r\n  BINARY_XOR \r\n    stack[stackp-1] = stack[stackp-1] ^ stack[stackp]; stackp -= 1\r\n\r\nThere are in-place versions of the binary operators: e.g., x += 1 vs x = x + 1\r\nI will show the meanin of INPLACE_ADD and just list the others here:\r\n\r\n  INPLACE_ADD\r\n    stack[stackp-1] += stack[stackp]; stackp -= 1\r\n\r\nINPLACE_SUBTRACT, INPLACE_MULTIPLY, INPLACE_FLOOR_DIVIDE, INPLACE_TRUE_DIVIDE,\r\nINPLACE_MODULO, INPLACE_POWER, INPLACE_LSHIFT, INPLACE_RSHIFT, INPLACE_AND,\r\nINPLACE_XOR, and INPLACE_OR\r\n\r\nIteration:\r\n\r\n  GET_ITER \r\n    stack[stackp] = iter(stack[stackp])\r\n  FOR_ITER N (really, this should be called NEXT)\r\n    stackp += 1; stack[stackp] = next(stack[stackp-1])\r\n      but if StopIteration exception is raised in part 2: pc += N\r\n  \r\nJumping (changing the pc from where the next instruction is fetched). This\r\nis how Python implemetns loops (jumping back to the start of the loop) and\r\nif statemetns (jumping over blocks executed when the test is True/False):\r\n\r\n  JUMP_ABSOLUTE     N\r\n    pc = N\r\n  JUMP_FORWARD      N\r\n    pc += N\r\n  POP_JUMP_IF_TRUE  N\r\n    if stack[stackp] is True, pc = N (always stackp -= 1)\r\n  POP_JUMP_IF_FALSE N\r\n    if stack[stackp] is False, pc = N (always stackp -= 1)\r\n\r\nCalling Functions and Returning/Yielding\r\n  CALL_FUNCTION N\r\n    The first operand byte is a count of the position arguments: pcount\r\n    The second operand byte is a count of the keyword arguments: kcount\r\n    There are kcount name indexes (for parameter names) and values on the top\r\n       of the stack followed by pcount values followed by the function to call\r\n    This operation pops all function arguments off the stack to store them into\r\n      the co_varnames tuple, and pops off the the function itself\r\n    The function should leave its answer on the top of the stack\r\n\r\n  RETURN_VALUE\r\n    Return to the location that called this function (its retuned answer on the\r\n      top of the stack)\r\n\r\n  YIELD_VALUE\r\n\r\nIn the Library Reference, they use the notation TOS to mean the location at\r\nthe Top Of the Stack, and TOSn to mean n down from the Top Of the Stack. So\r\nTOS is our stack[stackp] and TOS1 is our stack[stackp-1]\r\n\r\n------------------------------------------------------------------------------\r\n\r\nHere is a slightly more interesting function. It contains both a conditional/if\r\nstatement (lines 4-5) and a conditional expression (line 6), which translate\r\ninto a variety of jump instructions. Also note how the tuple assignment in line\r\n2 is translated via the UNPACK_SEQUENCE N instruction (which takes any sequence\r\nof values (tuple or list) and pushes N of them onto the stack right to left:\r\nso if (0,1) is on the stack, UNPACK_SEQUENCE 2 pops this value off the stack,\r\npushing first 1 then 0 onto the stack (which is why the first value below is\r\nstored into sum and the second is stored into count).\r\n\r\n1 def average_positive(alist):\r\n2    sum,count = 0,0\r\n3    for v in alist:\r\n4        if v > 0:\r\n5            sum = sum + v\r\n6            count += 1\r\n7    return sum / (1 if count == 0 else count)\r\n\r\naverage_positive\r\n  co_varnames: ('alist', 'sum', 'count', 'v')\r\n  co_names   : ()\r\n  co_consts  : (None, 0, 1, (0, 0)) \r\n\r\nSource Line  m  operation/byte-code      operand (useful name/number)\r\n---------------------------------------------------------------------\r\n 2            0 LOAD_CONST               3 ((0, 0)) \r\n              3 UNPACK_SEQUENCE          2 \r\n              6 STORE_FAST               1 (sum) \r\n              9 STORE_FAST               2 (count) \r\n\r\n 3           12 SETUP_LOOP              49 (to 64) \r\n             15 LOAD_FAST                0 (alist) \r\n             18 GET_ITER             \r\n        >>   19 FOR_ITER                41 (to 63) \r\n             22 STORE_FAST               3 (v) \r\n\r\n 4           25 LOAD_FAST                3 (v) \r\n             28 LOAD_CONST               1 (0) \r\n             31 COMPARE_OP               4 (>) \r\n             34 POP_JUMP_IF_FALSE       19 \r\n\r\n 5           37 LOAD_FAST                1 (sum) \r\n             40 LOAD_FAST                3 (v) \r\n             43 BINARY_ADD           \r\n             44 STORE_FAST               1 (sum) \r\n\r\n 6           47 LOAD_FAST                2 (count) \r\n             50 LOAD_CONST               2 (1) \r\n             53 INPLACE_ADD          \r\n             54 STORE_FAST               2 (count) \r\n             57 JUMP_ABSOLUTE           19 \r\n             60 JUMP_ABSOLUTE           19 \r\n        >>   63 POP_BLOCK            \r\n\r\n 7      >>   64 LOAD_FAST                1 (sum) \r\n             67 LOAD_FAST                2 (count) \r\n             70 LOAD_CONST               1 (0) \r\n             73 COMPARE_OP               2 (==) \r\n             76 POP_JUMP_IF_FALSE       85 \r\n             79 LOAD_CONST               2 (1) \r\n             82 JUMP_FORWARD             3 (to 88) \r\n        >>   85 LOAD_FAST                2 (count) \r\n        >>   88 BINARY_TRUE_DIVIDE   \r\n             89 RETURN_VALUE         \r\n\r\nIf there were an else: block, it would appear between 57/60: both jump back\r\nto m[19] when their blocks finish executing.\r\n\r\nPlease feel free to type in all sorts of small functions to see how they are\r\ntranslated to run on the PVM. The project folder that you can download includes\r\nsome simple functions and the func_obj function.\r\n\r\nNote that the two simple functions shown did not call functions on their inside:\r\nsee addup1 in the project folder, which uses range and len to iterate of the\r\nlist indexes to compute the sum. The relevant line in the function is\r\n\r\n    for i in range(len(alist)):\r\n\r\nThe local/global names are\r\n\r\n  co_varnames: ('alist', 'sum', 'i')\r\n  co_names   : ('range', 'len')\r\n\r\nand sequence of instructions is\r\n\r\n              9 LOAD_GLOBAL              0 (range) \r\n             12 LOAD_GLOBAL              1 (len) \r\n             15 LOAD_FAST                0 (alist) \r\n             18 CALL_FUNCTION            1 (1 positional, 0 keyword pair) \r\n             21 CALL_FUNCTION            1 (1 positional, 0 keyword pair) \r\n             24 GET_ITER             \r\n        >>   25 FOR_ITER                20 (to 48) \r\n             28 STORE_FAST               2 (i) \r\n\r\nHere the range function, to call last, is loaded/pushed on the stack; then the\r\nlen function, to call first, is loaded/pushed on the stack; then the alist\r\nvariable is pushed on the stack. The stack looks as follows\r\n\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 | alist value        |\r\n   +--------------------+\r\n 1 | len function       |\r\n   +--------------------+\r\n 0 | range function     |\r\n   +--------------------+\r\nstack (with stackp = 2)\r\n\r\nThe first CALL_FUNCTION 1 says using 1 positional argument (stackp=2), call the\r\nfunction specified at stackp-1 (len) on the stack, leaving the answer on the\r\nstack. The stack looks as follows\r\n\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 | len(alist) value   |\r\n   +--------------------+\r\n 0 | range function     |\r\n   +--------------------+\r\nstack (with stackp = 1)\r\n\r\nThe second CALL_FUNCTION 1 says using 1 positional argument (stackp=1), call the\r\nfunction specified at stackp-1 (range) on the stack, leaving the answer on the\r\nstack. The stack looks as follows\r\n\r\n         ....\r\n   +--------------------+\r\n 3 |                    |\r\n   +--------------------+\r\n 2 |                    |\r\n   +--------------------+\r\n 1 |                    |\r\n   +--------------------+\r\n 0 | range(len(alist))  | The range iterator \r\n   +--------------------+\r\nstack (with stackp = 1)\r\n\r\nThen GET_ITER is called to do the iteration, which uses FOR_ITER to produce\r\nthe first value (which is stored in local variable i).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nReturn to Analysis of Algorithms:\r\n\r\nWe can use the result of dis to compute the worst case count of the numnber of\r\ninstructions executed in a function. Let's return to (and review) the addup\r\nfunction for our analysis.\r\n\r\n1 def addup(alist):\r\n2     sum = 0\r\n3     for v in alist:\r\n4         sum = sum + v\r\n5    return sum\r\n\r\naddup\r\n  co_varnames: ('alist', 'sum', 'v')\r\n  co_names   : ()\r\n  co_consts  : (None, 0)\r\n\r\nSource Line  m  op/byte-code             operand (useful name/number)\r\n----------------------------------------------------------------------\r\n  2           0 LOAD_CONST               1 (0) \r\n              3 STORE_FAST               1 (sum) \r\n\r\n  3           6 SETUP_LOOP              24 (to 33) \r\n              9 LOAD_FAST                0 (alist) \r\n             12 GET_ITER             \r\n        >>   13 FOR_ITER                16 (to 32) \r\n             16 STORE_FAST               2 (v) \r\n\r\n  4          19 LOAD_FAST                1 (sum) \r\n             22 LOAD_FAST                2 (v) \r\n             25 BINARY_ADD           \r\n             26 STORE_FAST               1 (sum) \r\n             29 JUMP_ABSOLUTE           13 \r\n        >>   32 POP_BLOCK            \r\n\r\n  5     >>   33 LOAD_FAST                1 (sum) \r\n             36 RETURN_VALUE         \r\n\r\nHere is how to account for the number of instructions executed when Python runs\r\nthis function. As always we will assume that the len(alist) is N. Here there are\r\nno conditional statements so the worst case always executes all the code in the\r\nfunction (and the loop N times).\r\n\r\nInstructions done once (not in the loop proper)\r\n  2 for line 2, code before the loop: initialize sum\r\n  3 for line 3, setup for the loop; not repeated in the loop proper at m[13]\r\n  1 for line 4, at m[32], jumped to when StopIteration exception is raised\r\n  2 for line 5, code after the loop: load/push sum on the stack and return\r\n\r\nInstructions done in the loop\r\n  2 for line 3, m[13] and m[16]; note loop back to m[13]\r\n  5 for line 4, sum = sum + v and jump back to m[13] to get next iterator value\r\n\r\nFinally, note that the instruction at m[13] is executed N+1 times: N times it\r\ncontinues in the loop body and 1 time it raises StopIteration and jumps to\r\nm[32].\r\n\r\nSo, the I(N) is 8 (instructions done once) + 7N (instructions done in the loop)\r\n + 1 (m[13] done on N+1 iteration raising StopInteration) instructions.\r\n\r\nI(N) = 7N + 9 instructions\r\n", "encoding": "ascii"}