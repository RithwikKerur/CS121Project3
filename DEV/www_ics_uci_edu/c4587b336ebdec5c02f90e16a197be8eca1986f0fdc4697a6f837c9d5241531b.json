{"url": "https://www.ics.uci.edu/~stasio/winter06/lab4/lab4.html", "content": "<html>\r\n\t<head>\r\n\t\t<title>Winter 2005 ICS H22</title></head>\r\n\t<body bgColor=\"#ffcc99\">\r\n\t\t<h2>H22 Lab 4 - Running Time Analysis</h2>\r\n\t\t<h2>Due *Wednesday*,&nbsp;February 15 in the discussion session&nbsp;and/or via \r\n\t\t\tdropbox.</h2>\r\n\t\t<P>What's to submit:&nbsp;\r\n\t\t</P>\r\n\t\t<OL>\r\n\t\t\t<LI>\r\n\t\t\t\t<EM>the code</EM>:<EM>&nbsp; </EM>\r\n\t\t\tYou submit the coding part of this lab in the regular way, via the dropbox, but \r\n\t\t\tthe due date is 10am on Wednesday (instead of the usual 23:59pm...).\r\n\t\t\t<LI>\r\n\t\t\t\t<EM>the written part</EM>:&nbsp; This lab assignement has a written part of \r\n\t\t\t\tyour answers, and you can submit those in the distribution center (class in the \r\n\t\t\t\tdiscussion session at 10am on Wendesday.&nbsp; If you prefer, you can type the \r\n\t\t\t\twritten part and submit it electronically, by including the readible document \r\n\t\t\t\t(doc, txt, pdf) with your code in the zip file you submit via the dropbox.</LI></OL>\r\n\t\t<P>Note that there's many optional points in the lab which you can explore.&nbsp; \r\n\t\t\tAll these can earn you bonus points.</P>\r\n\t\t<h3>Overview</h3>\r\n\t\t<P>This lab has 2 parts.&nbsp; First you'll generalize the binary search algorithm \r\n\t\t\tyou wrote in lab2 into \"trinary\" search (and optionally you can generalize that \r\n\t\t\tto \"n-ary\" search for any n=2,3,...).&nbsp; Second, you'll time all these \r\n\t\t\tsearch algorithms, plot their average running times and compare these to the \r\n\t\t\ttheoretical analysis of the (worst-case) running time of these n-ary search \r\n\t\t\talgorithms.</P>\r\n\t\t<P>The point of this lab is that you learn how to:\r\n\t\t</P>\r\n\t\t<OL>\r\n\t\t\t<LI>\r\n\t\t\tgeneralize a binary search algorithm and generalize algorithms in general,\r\n\t\t\t<LI>\r\n\t\t\t\tcompute actual&nbsp;<EM>average</EM> <EM>running time </EM>of <EM>your implemention \r\n\t\t\t\t\tof an algorithm</EM>\r\n\t\t\trunning on some particular architecture, by clocking your code and \r\n\t\t\tthen&nbsp;averaging the timing samples on sample data points\r\n\t\t\t<LI>\r\n\t\t\t\tdo a theoretical, i.e. \"big-O\", analysis of a running time of an algorithm \r\n\t\t\t\t(which is always a <EM>worst case running time</EM>\r\n\t\t\tanalysis),\r\n\t\t\t<LI>\r\n\t\t\tcompare the results of the theoretical analysis of the (worst case) running \r\n\t\t\ttime of the algorithm with the experimental results which show the average \r\n\t\t\trunning time of your implementation of this algorithm\r\n\t\t\t<LI>\r\n\t\t\t\tdraw conclusions:\r\n\t\t\t\t<UL>\r\n\t\t\t\t\t<LI>\r\n\t\t\t\t\tis the \"big-O\" worst-case running time function a good predictor of the \r\n\t\t\t\t\taverage-time behaviour of your implementation of this algorithm?&nbsp;\r\n\t\t\t\t\t<LI>\r\n\t\t\t\t\twhat are the discrepancies due to?&nbsp; can the average case and the worst \r\n\t\t\t\t\tcase differ much?&nbsp; was it justifiable to ignore the low-order terms which \r\n\t\t\t\t\tare indeed ignored by the \"big-O\" analysis?\r\n\t\t\t\t\t<LI>\r\n\t\t\t\t\t\twhat's the actual cost of the \"primitve operations\" on the particular \r\n\t\t\t\t\t\tarchitecture where your implementation of the algorithm ran?</LI></UL>\r\n\t\t\t</LI>\r\n\t\t</OL>\r\n\t\t<h3>Part Ia:&nbsp;Generalize the Binary Search Algorithm from Lab2 to Trinary (and \r\n\t\t\t\"n-ary\") Search</h3>\r\n\t\t<P>Modify the binary search algorithm in lab2 so that it does a \"trinary\" search \r\n\t\t\tinstead.&nbsp; Recall that the binary search examines the value at the middle m \r\n\t\t\t= (f+i)/2 = i + (f-i)/2 of the searched-for interval [i,f] (of ordered values \r\n\t\t\tbetween some initial point i and the final point f), and then recursively calls \r\n\t\t\tthe binary search on either the [i,m] or the [m,f] half of this [i,f] \r\n\t\t\tinverval.&nbsp; The base case of the binary search algorithm is this:&nbsp; If \r\n\t\t\tthe searched-for interval is so small that it cannot be split into two smaller \r\n\t\t\tfragments, i.e. when f-i &lt; 2, then the algorithm \"manually\" examines each of \r\n\t\t\tthe values in the interval, i.e. simply the value at point i and the value at \r\n\t\t\tpoint f.&nbsp; (Note that if f-i &lt; 2 then we either have f=i or f=i+1.)</P>\r\n\t\t<P>A *trinary* search algorithm searches such [i,f] interval by examining the \r\n\t\t\tvalues at 1/3 and the 2/3 of the interval, i.e. by examining the values at \r\n\t\t\tpoint m1 = i + 1/3*(f-i) and m2 = i + 2/3*(f-i), and then, depending on how do \r\n\t\t\tthese values compare with the searched-for value, the trinary search algorithm \r\n\t\t\trecursively calls the trinary search on *either* the [i,m1] interval, or the \r\n\t\t\t[m1,m2] interval, or the [m2,f] interval.&nbsp; The base case of the trinary \r\n\t\t\tsearch algorithm is similar to that of the binary search:&nbsp; If the \r\n\t\t\tsearched-for interval is so small that it cannot be split into even smaller \r\n\t\t\tfragments, then the algorithm examines the remaning values one-by-one.&nbsp;\r\n\t\t</P>\r\n\t\t<P>As you generalize the binary search to trinary one, these are the things you \r\n\t\t\tneed to think about:</P>\r\n\t\t<OL>\r\n\t\t\t<LI>\r\n\t\t\tmake sure that the all the choices of the recursive calls taken together cover \r\n\t\t\tthe whole interval region, i.e. no elements will ever be missed, for example \r\n\t\t\tbecause of the effect of rounding.\r\n\t\t\t<LI>\r\n\t\t\tat the same time, make sure that when the search procedure invoked on arguments \r\n\t\t\t(i,f) makes a recursive call to the itself, it can always do so only if the \r\n\t\t\targuments (i',f') it calls with are such that f'-i' is strictly smaller than \r\n\t\t\tf-i.&nbsp; Only making sure that this is true can guarantee that your algorithm \r\n\t\t\tdoes not enter an infinite loop.\r\n\t\t\t<LI>\r\n\t\t\t\tmake sure that the base case covers all the possibilities that can occur when \r\n\t\t\t\tthe interval is small enough, i.e. the value f-i is small enough, that the base \r\n\t\t\t\tcase needs to kick in.</LI></OL>\r\n\t\t<P>[Optionally, you can generalize this even further, and code a general \"n-ary \r\n\t\t\tsearch\" algorithm which given an argument n does the search by splitting the \r\n\t\t\tsearched-for interval into n fragments and searching them recursively via the \r\n\t\t\t\"n-ary search\".&nbsp; (It might be that the base case of the n-ary search will \r\n\t\t\thave to depend on n, but maybe that will not be necessary.]\r\n\t\t\t<H3>PartIb: Theoretical analysis of the running time of the search algorithms</H3>\r\n\t\t<P>Do the (theoretical) analysis of the (worst-case) running time of the binary \r\n\t\t\tsearch *and* the trinary search algorithms.&nbsp; We want the running time to \r\n\t\t\tbe expressed in terms of just one variable:&nbsp; n, the *size* of the searched \r\n\t\t\tinterval.&nbsp; Note that in the case of the savings calculator application in \r\n\t\t\tlab2, the size n of the searched interval is equal to n = 100t/m where t is the \r\n\t\t\ttarget amount in cents, and m is the the number of months.&nbsp; In the running \r\n\t\t\ttime analysis consider m, the number of months, as a constant.&nbsp; For \r\n\t\t\texample, set m = 60, which&nbsp;corresponds to dealing with 5-year saving \r\n\t\t\tplans.&nbsp; (Note also that the running time of all these algorithmsdoes not \r\n\t\t\tdepend on the interest rate r.)&nbsp; The analysis will give you some running \r\n\t\t\ttime functions, T<SUB>bs</SUB>(n) and&nbsp;T<SUB>ts</SUB>\r\n\t\t(n), for the binary search and the trinary search, correspondingly.&nbsp; What \r\n\t\tis the O() notation for both of these functions?\r\n\t\t<P>Compare the running times of the binary and the trinary search algorithms.&nbsp; \r\n\t\t\tAre they asymptotically the same or one is larger than the other?&nbsp; Even if \r\n\t\t\tthey are the same in the O() sense, i.e. if T<SUB>bs</SUB>(n) = O(T<SUB>ts</SUB>(n)) \r\n\t\t\tand also T<SUB>ts</SUB>(n) = O(T<SUB>bs</SUB>\r\n\t\t(n)), try to think about the constants in fhe functions themselves:&nbsp; Can \r\n\t\tyou hypothesize which function will dominate the other?\r\n\t\t<P>\r\n\t\t\t[Optionally, you can check what's the asymptotic behaviour of the running time \r\n\t\t\tfunction of general n-ary search, and compare it to the others.&nbsp; What's \r\n\t\t\tthe optimal value of n?]</P>\r\n\t\t<P>[Optionally, you can consider both m and n the variables for the running time \r\n\t\t\tfunction.&nbsp; In the book we talked about the running-time function as only a \r\n\t\t\tfunction T(n) of one single variable n that represents the \"size of the \r\n\t\t\tproblem\", but one often wants to express the runnning time as a&nbsp;function \r\n\t\t\tof more than just one variable.&nbsp; In the case of the savings calculator \r\n\t\t\tapplication, it'd be convient to consider its running time as a function of <EM>two</EM>&nbsp;variables, \r\n\t\t\tn and m, i.e.&nbsp;some function&nbsp;T(m,n).&nbsp; The definition of the O() \r\n\t\t\tnotation for the two-variable function is very similar to the single-variable \r\n\t\t\tdefinition:&nbsp;&nbsp;We say that T(m,n) is O(F(m,n)) for some other function \r\n\t\t\tF(m,n) if there exist&nbsp;a constant c&gt;0 and <EM>two</EM> points m0 and n0 \r\n\t\t\ts.t. for all m&gt;m0 and all n&gt;n0 we have that T(m,n) &lt;= c * \r\n\t\t\tF(m,n).&nbsp; When you do the running-time experiments in the second part of \r\n\t\t\tthe lab (see below), you can gather the information also as a function of these \r\n\t\t\ttwo variables, m and n, and compare such results to the O() expression for the \r\n\t\t\tT(m,n) function you derive here using pen and paper.]\r\n\t\t\t<h3>Part IIa:&nbsp;&nbsp;Gather experimental data about average-case time of your \r\n\t\t\t\tbinary and trinary search algorithms</h3>\r\n\t\t<P>\r\n\t\t\tFirst you need to implement the timer.&nbsp; Use an appropriate timer class \r\n\t\t\tfrom the&nbsp; <A href=\"http://java.sun.com/j2se/1.4.2/docs/api/overview-tree.html\">\r\n\t\t\t\tjava Class library</A>\r\n\t\t&nbsp;to clock the time before and after your search algorithm runs.&nbsp; We \r\n\t\tare interested in the running time of your implementation as a function of n, \r\n\t\twhere n = 100t/m, where m is fixed, as we said above, to m=60.&nbsp; [Of course \r\n\t\toptionally you can explore the running time of your algorithm as a function of \r\n\t\tboth n and m.]&nbsp; Since n is not an explicit variable which your algorithm \r\n\t\ttakes as an input, this means that in order to test the time of the algorithm \r\n\t\tas a function of n you need to run the algorithm on input t = n*m / 100.&nbsp; \r\n\t\t(Recall that t denotes the target amount.)&nbsp;\r\n\t\t<P>Moreover, we want to examine the <EM>average</EM>\r\n\t\trunning time, as a function of n, and not just a running time of a single \r\n\t\tinstance of your algorithm for a particular interest rate r.&nbsp; (Once n and \r\n\t\tm are fixed, the only other input that determines how your code is executed \r\n\t\twill be the interest rate r.)&nbsp;&nbsp; How can we do this?&nbsp; Simply, for \r\n\t\tevery n, you should examine the average running time of your algorithm by \r\n\t\taveraging the times observed in k executions of your code, each one executing \r\n\t\twith the same parameter n.&nbsp;&nbsp;It's up to you to determine the useful \r\n\t\tvalue of k, but you can start with k=100.&nbsp; In each of these k instances \r\n\t\tyou should run the algorithm with the same n but you should vary the r \r\n\t\tparameter.&nbsp; For example you can take say that the i-th execution should \r\n\t\trun with r = 0.05 +&nbsp;0.01 * i/k, which will effectively range r between 5% \r\n\t\tand 6%.&nbsp; Or you can assign in each instance r using a random number \r\n\t\tgenerator.&nbsp; (But make sure that it falls into some reasonable region, \r\n\t\tdefinitely different than 0 or 1, because&nbsp;if r is either 0 or 1 your code \r\n\t\tmight exhibit very non-average behaviour...)\r\n\t\t<P>The result of all the above should be a procedure, for example called (binary or \r\n\t\t\ttrinary search) <EM>test</EM>\r\n\t\t, which takes parameters k and n, and outputs the average running time of \r\n\t\tk&nbsp;instances of the (binary or trinary) search algorithm, each of which \r\n\t\texecutes on the same input size n (and each of which runs on some \r\n\t\taverage-looking interest rate r and on m=60).\r\n\t\t<P>Now, to analyze them, gather your results in an array of results for some \r\n\t\t\trealistic n values.&nbsp; Pick the n values in the array so that you can easily \r\n\t\t\tobserve the dependance between the (average) running time and these \r\n\t\t\tvalues.&nbsp; For example, if you have good reasons to believe that the running \r\n\t\t\ttime of your algorithm is a <EM>linear</EM> function of n, you will want your n \r\n\t\t\tvalues spread linearly, e.g. n<SUB>i</SUB> = a * i for some constant a.&nbsp; \r\n\t\t\tIf, on the other hand, you think that your running time is logarithmtic, then \r\n\t\t\tthe running times will be easier to observe if you observe the results for n's \r\n\t\t\tspread <EM>exponentially,&nbsp;</EM>e.g. n<SUB>i</SUB> =&nbsp;2<SUP>i</SUP> or \r\n\t\t\tn<SUB>i</SUB> =&nbsp;10<SUP>i</SUP>\r\n\t\t.&nbsp; In any event, you should program a procedure which iterates over n \r\n\t\tvalues in an array of test cases, runs the above test for each of them, and \r\n\t\tgathers the outputs in an array of outputs.&nbsp; Then you can populate the \r\n\t\tarray of test cases with linearly-spaced n's and see if the results are \r\n\t\tinformative.&nbsp; If not, populate the array of test cases with \r\n\t\texponentially-spaced n's and rerun the process.&nbsp; Note that if you start \r\n\t\twith too-big values, your code will run forever.&nbsp; If on the other hand you \r\n\t\tuse too-small values, the results will be random-looking and hard to \r\n\t\tinterpret.&nbsp; This is exactly why you need to program the *procedures* that \r\n\t\ttake any array of test cases and runs any number k of tests on each.&nbsp; \r\n\t\tUsing these procedures you can easily then change the k parameter and the test \r\n\t\tinputs and see what they need to be in order for you to get observable and easy \r\n\t\tto interpret results!\r\n\t\t<P>\r\n\t\t\tFinally, once you get some easy-to-interprest results, <EM>plot them </EM>\r\n\t\ton a graph.&nbsp; On the x-axis there should be the different values of n, and \r\n\t\ton the y-axis there should be the average running time of the algorithm for a \r\n\t\tgiven n.&nbsp; Your solutions can contain two such plots:&nbsp; One for the \r\n\t\tbinary and one for the trinary algorithms.&nbsp; The two plots should use the \r\n\t\tsame test cases n.&nbsp; Even better, you can draw a single plot, with two \r\n\t\tlines (or curves):&nbsp; In one color the line representing the average running \r\n\t\ttimes of the binary search algorithm, and in the other color the same for the \r\n\t\ttrinary search.\r\n\t\t<P>For the code part, you should submit a code you used to test organized as I'm \r\n\t\t\tsuggesting above, and with a description of how it can be used to do the \r\n\t\t\ttesting:&nbsp; Where do you set the k value, where do you populate the test \r\n\t\t\tcases.&nbsp; The results should be displayed in some easy to read way, but they \r\n\t\t\tdo not need to be plotted on the screen.\r\n\t\t\t<h3>PartIIb: Compare the experimental data and the theoretically-derived runnig \r\n\t\t\t\ttime</h3>\r\n\t\t<P>Answer the following questions:</P>\r\n\t\t<OL>\r\n\t\t\t<LI>\r\n\t\t\t\tWhich algorithm seems better in practice?&nbsp; How can you explain it?&nbsp; \r\n\t\t\t\t[Optionally, what's the optimal n for the n-ary search?]</LI>\r\n\t\t\t<LI>\r\n\t\t\t\tHow do the experimental results compare to the theoretically-derived running \r\n\t\t\t\ttime functions&nbsp;T<SUB>bs</SUB>(n) and&nbsp;T<SUB>ts</SUB> (n)?&nbsp; Note \r\n\t\t\t\tthat the T(n) functions represent the worst-case running time and the \r\n\t\t\t\texperimental results report an average-running time.&nbsp; Are the two \r\n\t\t\t\tdifferent in this case?&nbsp; Why or why not?&nbsp;\r\n\t\t\t</LI>\r\n\t\t\t<LI>\r\n\t\t\t\tIf the average-case and the worst-case are similar in this case, is the \r\n\t\t\t\taverage-case bahaviour <EM>exactly</EM> matching the theoretically derived \r\n\t\t\t\tone?&nbsp; What are the discrepancies and how can you explain them?</LI></OL>\r\n\t\t<P>[Optional idea:&nbsp;&nbsp;You can use this experiment to estimate the cost of \r\n\t\t\tthe arithmetic operations compared to the cost of the other operations (like \r\n\t\t\tcomparisons, look-ups, variable assignments, and everything else this code \r\n\t\t\tdoes).&nbsp; You can see this by replacing floats with doubles (or vice versa) \r\n\t\t\tin the interest-rate operations in the amount-saved procedure, and observing \r\n\t\t\twhether the running time changes by much.&nbsp;&nbsp;If you can, maybe you \r\n\t\t\tcan&nbsp;do all the operations on the integers (it'd be sligtly tricky but it \r\n\t\t\tmight be possible).&nbsp; You can test if this speeds it up.]</P>\r\n\t</body>\r\n</html>\r\n", "encoding": "ascii"}