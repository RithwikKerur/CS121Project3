{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990330.txt", "content": "Minutes 3/30/99\n\nAttending: Judy Slein, Geoff Clemm, Tyson Chihaya, Jim Whitehead, Chuck Fay\n\nACTION ITEMS\n\nAll: Write up pros and cons of making direct references be URL bindings rather than \nresources, circulate to design team.  This week.\n\nJim Whitehead: Draft definition of reference.\n\nSHOULD REFERENCES BE RESOURCES?\n\nJim W: Redirects should be treated as real resources because clients can see them and \noperate on them.\n\nGeoff:  Lessons from his pass through spec:  Jim W\u2019s suggestion that redirects should \nstill be independent resources is right.  So only direct refs get hidden.\n  \nQuestions about ordering: If the collection is locked, do you have to be the lockholder to \nchange the ordering?  Is modification date affected only by changes to the body, not by \nchange to ordering?  What is the body of a collection?  Geoff thinks any change to \nmembership or ordering should change modification date.  What is locked when Depth= \n0? What counts as the state of a collection?  If GET redirects to index, is that one of the \nthings that gets locked?\n\nWhat is a collection?  We have to understand that to make decisions about COPY with \nDepth=0 or LOCK with Depth=infinity.\n  \nAll the problems about LOCK have parallels in versioning.\n\nThese problems led to search for general principle that would lead to the right answer.\n  \nHard questions: what really gets locked, what really gets copied, etc.\n\nWhat is the advantage of letting references be a resource? They can have properties. \nReuse of semantics, e.g., DELETE.\n\nGeoff: But you have to redefine all the standard methods if it\u2019s a resource.  Jim: But No-\nPassthrough gets you that.\n\nAre there use cases to support making references be resources?  \n\nLet a direct reference just be a URI that refers to a resource.  The reference can bind to \nresource and maintain that binding under change.  We are saying that sharing can only \nhappen in the context of a collection, which is fairly natural.  We are really just providing \na binding sharing operation.  It guarantees to bind to the same resource as another URL \nbinds to.  We are providing protocol access to the URL binding operation.\n\nLOCK affects a particular binding and a resource.  Clients could still remove other \nbindings and introduce new binding while the lock is in force.\n\nUser-defined bindings as opposed to system-defined ones.\n\nSome servers do case folding.  How to model that.  Maybe best to be silent on this.\n\nThis strategy helps with the forest of references: you do introduce a forest of bindings.  \nThis seems completely natural if the reference is just a URL binding, instead of seeming \npuzzling.\n\nA direct reference creates a binding.\n\nIs there any difference between a reference and a server-created URL binding?  No.\n\nYou can say UNLINK to any URL, whether created by client or by server.  Strong / weak \napplies to both kinds of bindings (server-created or client-created).\n\nIf direct references are bindings, does this force us to address strong references / \nreferential integrity now? Jim W thinks yes.\n\nWe would be adding state (referential integrity) to the binding - Jim W doesn\u2019t like that.\n\nHow does relative binding work?  More cleanup needed in base spec? Members are \nalways just a path segment. \n\nThe ordering is embodied in the internalmembers property.\n\nIt turns out that Jim and Geoff had in mind different semantics for direct references.  Jim \nwas thinking of something like hard links, Geoff was thinking of something like soft \nlinks.  \n\nJim thinks that you pass in a destination URL with the create request, the server \ndereferences the destination URL to an identifier of the resource (not accessible to the \nclient, but it\u2019s the true name of the resource), and creates a relationship between the new \nURL and that identifier.  So it\u2019s really a new binding that gets created. \n\nGeoff meant it to be \"whatever is at this URL, link to it\" (the current MKREF semantics).\nWhy do you need relative references?  In case you get moved.  For example, you want \n../index always to get your parent\u2019s index.\n\nMake it clear whether it\u2019s hard links or soft links you support.  Geoff wants the same \nsemantics as we\u2019ve had, but just that there\u2019s no independent resource.\n\nJim W may not support this - he thought Geoff wanted hard links, which is not the case.\n\nJim W: If a reference is an independent resource, you could just lock the single resource. \n \nIf the reference is a mapping is held in a property of a collection, all mappings get locked \nin order to affect one.\n\nGeoff: An observation about implementation -- some servers will have to lock the whole \ncollection anyway.  (Unix).  For symbolic links you can\u2019t lock just one, you have to lock \nthe whole directory - Jim doesn\u2019t believe this.\n\nJim W: LOCKs will need some separate server-maintained table in any case.\n\nChuck: The DMA object model has a separate entity for the reference (it\u2019s a relationship \nobject).  It is separate from the collection and separate from the target.  DMA did that \nbecause they expected there to be valuable edge data. \n \nDMA distinguishes between direct and referential membership.  Direct is 1-to-many \n(only one parent container). Referential is many-to-many - so now there needs to be a \nplace for the edge data.  It\u2019s not metadata about the collection and it\u2019s not metadata about \nthe target, but about the reference.  When it was added to the collection and by whom, for \nexample.  \n\nOrdering is modeled how in DMA?  Ordering is optional, and it\u2019s possible both for a \ncollection\u2019s members to be ordered and for an object\u2019s parents to be ordered. Only one \nordering per collection. The ordering property is on the relationship, but not exposed.  \nWhen you put a new member into a collection, you say \"put it before or after this other \nmember relationship\".\n\nThe member relationships do have external names (UUIDs + locating information).\n\nThe relationship object has 2 well-known properties: they are object valued, one is set to \nthe container object, the other is the object you are putting into the container.  \nUUIDs solve MOVE etc problems.\n\nThe one true name - is that like a UUID?  URL -> id -> state (filename).  Some \nproblems might be solved if we had names and made them accessible through protocol.  \nDocument Management and Configuration Management use names guaranteed not to \nchange for life of resource.\n\nIETF community won\u2019t let you use URN to locate something.  URL-to-URL binding is \nthe only one they could make sense of.\n\nAll: Write up Pros and Cons of making direct references into URL bindings.  This week.\n\nREVIEW OF YG-1 - YG-6\n\nIssue YG-1: Definition of collection: Keep as is.\n\nIssue YG-2: Definition of reference - Geoff: if redirect references are resource and direct \nreferences are not, then maybe they are so different that we can\u2019t consider them to be \nspecializations of the same kind of thing.  Let\u2019s revisit this after we\u2019ve decided whether \ndirect references are resources. \n\nIssue YG-3: Extension header for multiple locations -- Geoff:  Off-server references a a \nproblem.  You couldn\u2019t get all of them because there could be references from lots of \ndifferent servers.  You couldn\u2019t be sure that all of them have been maintained, so some of \nthem might be broken. Chuck: You get back the URI used to create the ref.  A single URI \nis the simplest and most reliable. Jim W: This may really be an extensiblity issue, but we \nare using Location from HTTP, so let\u2019s just accept it as it is. Closed: only the HTTP \nLocation header will be used.\n\nIssue YG-4: Values of Ref-Integrity. Closed: Accept Yaron\u2019s proposal.\n\nIssue YG-5: Jim W: highly structured property values may not be searchable by DASL, \nso at least keep reftarget separate so that we are sure it can be searched.  Judy: Do you \nmean we have to make any properties that we want to be searchable into string-valued \nproperties?  Jim W: No.  Geoff is happy with separate properties. Geoff: Values of \nresourcetype should determine different method behaviors.  If method behaviors for \nproperty values are the same, the property doesn\u2019t belong in resourcetype. Jim W: The \nnames ref* may be some indication that we\u2019re dealing with different types of references.  \nBy Goeff\u2019s test, reftype and refintegrity might belong in resourcetype.  Eventually servers \nmay have to branch on refintegrity to determine behavior. Jim W: inclined to keep all \nthree properties separate.  Closed: reftype, refintegrity, and reftarget will stay separate \nproperties.\n\nYG-6: Allow a body to be included in MKREF requests for extensiblity.  On the one \nhand, this looks like a harmless proposal; on the other, it muddies the distinction between \nreferences and other resources.  Geoff - don\u2019t say anything.  Jim W: Use same language \nas MKCOL.  Closed:  The spec will use language similar to that in MKCOL to allow a \nbody without defining it.\n\nDefinition of reference: The current definition says that references have no content.  The \nword \"content\" has been problematic.  What we mean is the chunk of data that would \ncome back as entity body for GET.\n\nBody means what\u2019s in a message, content means what is on the resource. Jim W doesn\u2019t \nlike content because a CGI script is not content, but rather produces content.  Still, we \nwant to include it in what we are talking about.  What is the word for the characteristic of \nthe resource?  The HTTP spec lets you do content negotiation, so that a resource\u2019s state \nincludes several distinct entity bodies.  Computational processes complicate things \nfurther.  What is the persistent state of the resource?  Whatever you change that produces \na change in the entity body for GET.  So we are trying to say that references have no state \nthat would produce a GET entity body.  References do have persistent state that is \nproperties.  Is the target part of a reference\u2019s persistent state?  Data that you get back on \nGET.  Metadata is properties.  In 2518, entity headers and properties count as properties.\n  \nCheck on the definitions of message body vs. entity body. \n\nWe need a mental model of the resource, so we need to talk about the nature of the \nresource, not just about what goes over the wire.  Geoff thinks not.  Jim W:  HTTP took \nthat way out and caused lots of difficulty for WebDAV.\n\nJim W will draft a definition of reference.\n\n\n", "encoding": "Windows-1252"}