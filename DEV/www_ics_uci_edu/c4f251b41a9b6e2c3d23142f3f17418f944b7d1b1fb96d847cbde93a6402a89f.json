{"url": "https://www.ics.uci.edu/~eppstein/180a/components.html", "content": "<HTML><HEAD>\n<TITLE>Game Programming</TITLE>\n<META name=\"Owner\" value=\"eppstein\">\n<META name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</HEAD><BODY>\n<IMG SRC=\"icslogo2.gif\" WIDTH=472 HEIGHT=72 ALT=\"\"><P>\n<A HREF=\"index.html\">\n<H1>ICS 180: Strategy and board game programming</H1></A>\n\n<H2>Project Components</H2>\n\nYour <A HREF=\"project.html\">course project</A> will likely include the\nfollowing components.\n\n<P><B>Phase I</B>\n<UL>\n<LI><B>Board representation</B>.  This is a data structure that\nrepresents all the information needed to store a single position in a game.\n(E.g. in chess, it would include not just the position of each of the pieces,\nbut also a bit indicating whose turn it is, and some extra information\nabout whether either player can castle or capture en passant.)\nYou should define a concise way of inputting and outputting moves;\ne.g. in chess a typical method is computer algebraic notation:\nthe move e2e4 means to move the piece currently on square e2 (row 2,\ncolumn e) to square e4. Your board representation code will include\ncode to input these codes and update the position. It should also detect\nillegal move codes, and represent the position in a form convenient for\nmove generation and evaluation.\n\n<LI><B>Move generation</B>.  This code should look at a board position,\nand output a list of all the moves that are legal to make from that position.\n\n<LI><B>Basic user interface</B>. A fancy graphical interface would be nice,\nbut I won't mark you down if you just do Unix stdio-based text input and\noutput.  For phase I of the projects, your user interface should\nallow a sequence of moves to be input (either in the concise form\ndescribed above or using the mouse), test whether those moves are legal,\nand if so output the list of possible moves available at the resulting\nposition.\n</UL>\n\n<P><B>Phase II</B>\n<UL>\n<LI><B>Evaluation function</B>. This component examines a board position,\nand returns a numerical score indicating which player is likely to win.\nA large positive score should mean that one player has a very good\nposition, a large negative score should mean that the other player has a\nvery good position, and a score near zero should indicate a game that's\neither likely to lead to a draw or too close to decide who is likely to win.\nFor instance, in chess the following very simple \"materialistic\"\nevaluation works pretty well: sum up +1 for each white pawn, +3 for each\nwhite knight or bishop, +5 for each white rook, and +9 for each white queen.\nSubtract the corresponding values for each black piece.\nHowever in other games (e.g. Othello) counting pieces is much worse than\nother more careful evaluations.\n\n<LI><B>Search strategy</B>. Typically this will be alpha-beta or a\nvariant on it. We will discuss this part of the program extensively in\nthe course lectures.\n\n<LI><B>Advanced user interface</B>. Add features to reset the board,\ndecide which side the computer is going to play, and call the search\nstrategy when the computer needs to make a move.\n</UL>\n\n<P><B>Phase III</B>\n<UL>\n<LI><B>Testing</B>. Playing many games against your computer will reveal\nits strengths and weaknesses.\n<LI><B>Evaluation function</B>. The more time you spend on this,\nthe better your computer will play. You should work on making it more\nintelligent and faster.\n<LI><B>Search strategy</B>. There are many sophisticated enhancements to\nalpha-beta, which you can try implementing once you have the basic\nsearch working.\n<LI><B>Write final report of project accomplishments</B>.\n</UL>\n\n<HR>\n<A HREF=\"/~eppstein/\">David Eppstein,\n<A HREF=\"/\">Dept. Information & Computer Science</A>,\n<A HREF=\"http://www.uci.edu/\">UC Irvine</A>,\n<!--#flastmod file=\"components.html\" -->.\n</BODY></HTML>\n", "encoding": "ascii"}