{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/finalreview.txt", "content": "The final exam is worth 200 points. I have not written the final version of this\r\nexam yet, but I expect it to be like the midterm in format: about 10 questions\r\n(some might have multiple parts), each covering about 1 week of material for the\r\n10 week quarter (although there will be no questions on material covered the last\r\nweek). So, it is cumulative. Over this 120 minute test, that is about 12 minutes\r\nper question (to read and answer it).\r\n\r\nWe have covered way too much material for you to re-read everything. I suggest\r\nprimarily reviewing the quizzes and midterm, and then the programming\r\nassignments: not reading them in depth, but being familiar with them and their\r\nmajor themes. Of course you will be analyzing and writing code on the final\r\nexam, but I expect there also to be a small number of questions to be answered\r\nin English or with pictures/diagrams.\r\n\r\nI will write in more detail a few days before the exam, after I have written it.\r\nI will provide the same kind of material I provided for the midterm.\r\n\r\nHere is my view of the material that we covered.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nWeek 1) Review/Extension\r\n  data types: list (sorting), tuple/named-tuple, set/frozenset, dict/defaultdict\r\n  iterators : iterating over sorted/reversed data; 3 ways to iterate over dicts\r\n  importing: forms and meanings\r\n  construction on iterable data\r\n  comprehensions\r\n  function calls: argument/parameter binding options; *args/**kargs\r\n  important functions: split/join, all/any, sum/min/max, zip/enumerate\r\n  lambdas\r\n  sharing vs copying\r\n  raising exceptions and exception/handling with try/except\r\n  classes (__dict__ for object name spaces)\r\n\r\nWeek 2) Text Patterns\r\n  reading files\r\n    standard iteration (and variations with readlines and read)\r\n    calling rstrip and split\r\n    a special function for parsing lines\r\n  EBNF\r\n    named rules; right hand sides: sequence, alternatives, choice, repetition\r\n    proving symbols match rules (in English, etc.); syntax charats\r\n    synthesizing rules from examples\r\n  regular expressions\r\n    elements of the matching language (e.g., what [], {}, |, ?, +, *, etc. mean)\r\n    re functions: match, search, sub, split, compile\r\n    specifying/extracting groups (numbered and named) after matching\r\n    re methods on match objects: mostly group (by number/name) and groupdict\r\n\r\nWeek 3) Classes\r\n  how state and methods are stored in an object's namespace (using __dict__)\r\n  the Fundamental Equation of Object Oriented Programming\r\n  the meaing of _ and __ prefixes in names\r\n  operator overloading via method definition\r\n    misc: __init__, __len__, __bool__, __str__/__repr__\r\n    unary: +, -, abs\r\n    relational\r\n    arithmetic\r\n    container: __getitem__, __setitem__, __delitem__, __contains__\r\n    function call: __call__\r\n    iterators: __iter__, __next__\r\n    attribute: __getattr__, __setattr__, __delattr__, (ignore __getattribute__)\r\n    context managers: __enter__, __exit__\r\n\r\nWeek 4) Iterators\r\n  how iterators work\r\n    translating for loops into while loops with explicit calls to iter/next\r\n  general review of use/illustrations of how to write some builtin (prange)\r\n  implementation of iterators with simple nested classes\r\n  generators\r\n    implementation of iterators with generators\r\n      space efficiency (iterating over many value without storing them all)\r\n  decorators for iterators using generators: e.g., repeat, unique, filter \r\n     decorated is an iterable; decorator produces an iterable\r\n\r\nWeek 5) Recursive and Functional Programming\r\n  recursive programming for standard Python data structures: int, string, list\r\n    recurring on multiple parameters\r\n  proof rules and their application to write/prove recursive code correct\r\n  map/filter/reduce (+ lambdas): definition and use\r\n  accmulation and tail recursion\r\n  decorators for things called\r\n    special @ syntax\r\n    examples: Track_Calls, Memoize, Illustrate_Recursive\r\n\r\nWeek 6) Self-referential data types\r\n  linked lists: pictures, hand-simulation\r\n  binary trees (mostly binary search trees)/structure trees: pictures/meanings\r\n  iterative and recursive functions for simple tasks for lists and trees\r\n\r\nWeek 7) Inheritance\r\n  type vs isinstance\r\n  inheriting/using/overriding: state, __init__, other methods\r\n  locating attribute names in an inheritance hierarchy\r\n    (really a network if multiple inheritance is used)\r\n    (updating the fundamental equation of object-oriented programmming)\r\n  handling exceptions in an inheritance hierarachy\r\n  simple examples: defaultdict, lists indexed at 1, GUI widgets\r\n  mixin examples: Privacy, general-purpose __str__\r\n\r\nWeek 8) Analysis of Algorithms\r\n  complexity classes & Big-O notation: their meaning (doubling signatures)\r\n    common complexity classes: O(1), O(Log2 N), O(N), O(N Log2 N), O(N**2), ...\r\n  complexity classes for standard Python operations\r\n  analysis of code: code -> complexity\r\n  empirical analysis: timing -> complexity\r\n  minor: approximating logarithms base 2; 1+2+..+N = N(N+1)/2\r\n\r\nWeek 9) Tools\r\n  performance: my Performance class, the standard Python profiler\r\n  more empirical analysis:\r\n    computing the average heights of random binary search trees\r\n  correctness: unittests\r\n\r\nWeek 10) No quizzes on these, so they will not appear on the final exam\r\n  A bit about the Python Virtual Machine and Java\r\n  (no quizzes on these, so they will not appear on the final exam)\r\n", "encoding": "ascii"}