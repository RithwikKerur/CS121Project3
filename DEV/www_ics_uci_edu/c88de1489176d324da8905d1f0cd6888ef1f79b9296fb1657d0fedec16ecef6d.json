{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990126.txt", "content": "WebDAV Advanced Collections Conference Call - 1/26/99\n\nAttending: Judy Slein, Geoff Clemm, Jim Whitehead, Chuck Fay\n\nACTION ITEMS\n\nGeoff: Send a message on the semantics of COPY for references to the WebDAV mailing list.\nJudy:  Spec changes\nAll: Send comments to Judy via e-mail this week on the treatment of redirect references\nin sections 3.5 - 3.7 and 3.9.\nAll: Once we have agreed on semantics of MOVE and COPY, revisit how they interact with\nchains of direct references.\n\nLOGISTICS\n\nREVIEW SPEC CHANGES\n\nLOCKING 3.6\n\nAssuming that locking a direct reference locks its target, then in a chain of direct \nreferences, all the intermediate references would be locked.  The server is responsible\nfor detecting any loops.\n\nThe semantics of MOVE for collections that is defined in WebDAV says that if any member of\nthe collection being moved (or of any of its child collections, recursively) is locked, then\nthe MOVE fails.\nThis means that the server has to scan the whole collection hierarchy in order to determine\nwhether it can perform a MOVE. \n\nIf we have LOCKs on collections with direct references lock the targets of the direct\nreferences, there will potentially be locks scattered through many trees as a result.\n\nThe situation will be somehow much worse for servers if we do this than it was when WebDAV\nconsidered only locks on ordinary resources.  (How is it worse?  I've lost it. JS)\n\nIn the systems Geoff works with, there is a difference between locking a resource's content\nand locking down the resource so that it cannot be moved.  (To do the latter, you have to\nlock the whole hierarchy down to the resource you care about.)  That difference is lost in \nthe WebDAV semantics.\n\nThere are performance problems if we require servers to lock the targets of direct\nreferences.  If the lock scope goes beyond one hierarchy, it can become prohibitively\nexpensive.\n\nGeoff also dislikes allowing individual references (as opposed to collections that contain\nthem) to be LOCKed.  This is because file-system-based servers may not store the references\nas separate resources that can carry their own properties.\n\nIf the target of a direct reference gets locked, what happens to alternative references to \nthat target?\n\nOptions:\nGet rid of direct references altogether, or give them to the versioning team to define\nCurtail lock on direct references \nMake direct references be aliases\n\nLet's have a LOCK on a direct reference lock only the reference, not its target.\nIn that case, down-level clients will be \"consistently surprised\".  LOCKS will work the\nsame for all flavors of references.  The client will think it has a lock, but the target\nresource may change.\nKeep the behavior of LOCK for references in collections and for individual references\nconsistent.\n\nShould we also say that the server may reject a request to lock an individual reference? No.\nWebDAV requires support for locking individual resources.  References should be like any\nother resource. \n\nAgreed: When LOCKing a collection, only its internal members are locked.  In this\ncontext, that means that only references get LOCKed, not their targets. This will be true\nfor both direct and redirect references.\n\nAgreed: Include rationale in the specification: Locking targets of direct references forces \nthe scope of LOCK to go beyond a single collection hierarchy.  This would be prohibitively\nexpensive to implement.  Combined with the semantics of MOVE as defined in the WebDAV\nspecification, where a single lock anywhere in the tree below a collection can prevent\nthe collection from being MOVED, this would force a server to scan the entire tree before\nperforming any MOVE.\n\nAgreed: To keep semantics parallel between locking collections and locking individual \nreferences, a LOCK on any reference (direct or redirect) will lock only the reference, not\nits target.\n\nAgreed: If a client submits a lock token in an If header for a resource that is not\nlocked, the request fails with a 412 (Precondition Failed).  Down-level clients would find \nout in this way that the target resource was not locked.  Point this out in the spec.\n\nSEMANTICS OF COPY\n\nGeoff thinks COPY should get passed through to the target, while DELETE and MOVE apply to \nthe reference.  But this may be impossible because WebDAV defines MOVE as COPY + DELETE.\nWe'll return to this issue.\n\nDANGLING REFERENCES 3.13\n\nIn the discussion of PROPFIND and other operations on collections, state clearly what value\nof the Depth header produce the semantics described.\n\nREF-INTEGRITY HEADER\n\nCurrently the spec lays out 3 cases:\n1. do-not-enforce (server MUST NOT enforce referential integrity)\n2. header not present (server MAY, but is not required to, enforce referential integrity\nusing any policy it likes)\n3. header present with any other value (If the server understands the value, it does the\nright thing.  If the server does not understand the value, it MUST assume that some flavor \nof referential integrity is being requested, and enforce referential integrity using the\npolicy of its choice.)\n\nThis is pretty messy.  We could:\n1. provide another value \"enforce\" that lets the server use any policy, and require the\nserver to fail the request if it gets a value it doesn't understand.  (This would leave\n\"enforce\" with some vague meaning -- be explicit about that.)\n2. just require the server to fail the request if it gets a value it doesn't understand\n\nJudy will make a decision and fix the spec.\n\nJudy will delete the \"DAV:\" prefix on the header value. \n\nDAV:refintegrity PROPERTY\n\nThe values should be weak or ANY.\n\nISSUE 2: REDIRECT REFERENCES\n\nEveryone should send mail to Judy this week with comments on sections 3.5 - 3.7 and 3.9.\n\nISSUE 6: REFERENCING HEADERS IN RESPONSES\n\nThis section summarizes things that are said elsewhere.  There's some risk of conflict.\n\nAgreed: Take the normative language out of 3.14.\n\nAgreed: Make it clear that operations on collections that contain direct references do not \nget Ref-Type and Ref-Target headers back.  Instead, they get reftarget and reftype elements\nin the response elements of a Multi-Status response.\n\nAgreed: Make it clear that No-Passthrough is an exception to the second rule.\n\nAgreed: LOCK as we have now defined its semantics gets applied only to references, not to\ntheir targets.  However, we *do* want it to get Ref-Target back with the response.\n\nAgreed: No-Passthrough with LOCK is now a no-op (except that Ref-Target must come back with\nthe response, which is not generally true if you use No-Passthrough with a request).\n\nAgreed: List GET and HEAD as exceptions to rule 2.\n\nAgreed: For chains of direct references, multiple Ref-Target headers will be returned,\neach including a hop number + URL. \n\nConsider including in 3.14 pointers to all the other places (the normative statements) in\nthe spec that discuss what headers are included with responses.\n\nISSUE 9: CHAINS OF DIRECT REFERENCES\n\nIn general, just follow the semantics already in place.  If a chain of direct references\nseems to need an exception in the semantics, there is probably something wrong with the\nsemantics.\n\nPUT, MKREF, MKCOL -- just state the consequence of the current rules.  If there is a\ndangling reference in the middle of a chain of references, the server won't know that it\nis in the middle of a chain.  It will think it is at the end of a chain and is being asked\nto create the resource there.  The result will be a new resource at the location identified\nby the DAV:reftarget property of the broken reference.\n\nOnce we settle on MOVE and COPY semantics, check MOVE and COPY semantics and how they \ninteract with chains of direct references.\n\n", "encoding": "ascii"}