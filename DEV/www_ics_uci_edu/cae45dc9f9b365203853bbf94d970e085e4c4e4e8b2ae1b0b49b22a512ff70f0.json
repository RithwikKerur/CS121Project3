{"url": "https://www.ics.uci.edu/~kibler/ICS23/Homeworks.htm", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\r\n<HTML>\r\n\r\n<HEAD>\r\n\t<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;CHARSET=iso-8859-1\">\r\n\t<META NAME=\"GENERATOR\" Content=\"Visual Page 2.0 for Windows\">\r\n\t<TITLE>H23 Homeworks</TITLE>\r\n</HEAD>\r\n\r\n<BODY BGCOLOR=\"#99FFFF\">\r\n\r\n<P><B>ICS23 Summer Homeworks:</B> Typically these homeworks have a theoretical portion and a coding portion. <B>For\r\nall methods of all classes, you are required to provide a O-notation space and time complexity analysis unless\r\nthe space and time are O(1).</B></P>\r\n<P><I><B>Warning:</B> Only the homework for the next assigment is guaranteed to be correct and complete. Look at\r\nthe assignment early and ask questions if you do not understand what you are supposed to do.</I></P>\r\n<P><B>NOTE: Due Time: </B>Coding assignments are due (i.e. need to be deposited) by <B>NOON</B> of the first class\r\nday of the week that the homework is due. Another handout will explain how this should be done. Work that should\r\nbe handed in is due at the beginning of class of the week that homework is due. Late homeworks will be marked down\r\nby 20% for each day that it is late.</P>\r\n<P><BR>\r\nIn general, if questions are asked about your code, you should answer them in the documentation. For example you\r\nshould document the time and space complexity of all methods when not O(1).</P>\r\n<P><B>Regrades: </B>For a regrade you must resubmit your homework within 1 week of receiving your score. Also you\r\nmust explain what part of your homework needs to be regraded. The entire assigment will be regraded so it is possible\r\nto lower your score on a regrade.</P>\r\n<P><B>Note: Submit only *.java and *.vep files, no *.class files (which are large).</B> See Visual Cafe Lab guide\r\non Li Zhang's web site.</P>\r\n<P><I><BR>\r\n</I><B>Homework 1:</B> Goal: <B>O-notation+ review of arrays, lists and unbalanced trees.</B></P>\r\n<P><B>Read </B>chapter 1. chapter 1 has some useful program examples as well as a review of some basic mathematical\r\ntechniques.</P>\r\n<P><BR>\r\n1. Do problem 5.14, only part a. ( 6 code fragments to analyze). The solutions to these problems can be submittted\r\nin a separate file *.txt file. This should be fairly short, such as: // analysis: 1. O(n^3) 2. O(nlogn) 3. O(n^100)\r\netc. Note; not real answers. The name should be analysis.txt</P>\r\n<P>The quiz will contain problem similar to these.</P>\r\n<P><BR>\r\n<B><BR>\r\nRead</B> chapter 3+ 4.3 Chapter 3 is on lists, stacks, and queues. 4.3 covers binary trees.</P>\r\n<P>In this assignment you will implement a Cache in 4 different ways: namely as an array, a linked list, as binary\r\ntree, and as a tree (new TreeSet()) from the Collection package (in Java.util). The goal of a cache is to store\r\nthe best values. Teh best values are the highest values. They do not have to be stored in order, but this is sometimes\r\nconvenient. Your program will have a single input: an integer that defines the seed for a general random niumber\r\ngenerator, i.e. Random r = new Random(seed) which in the util.* library. Then you can get random integers view\r\nr.nextInt(). For each implementation give an O-notation analysis. Additional compare your implementations by generating\r\n10,000 random integers and putting them into a cache of size 20. Duplicated integers can be stored or not, as your\r\nchoice. Just comment which you do. Which implementation of cache performs best? What can you say about memory use,\r\ni.e. how much memory does each technique require? For each algorithm print out the final state of the cache. Should\r\nthe caches be identical?</P>\r\n<P>Note: To insure that each cache is given the same problem, you should reinitialize the random number generate\r\nwith the given seed for each Cache that you define. Also, to get timing results, you should the function System.currentTimeMillis(),\r\nwhich returns a long.</P>\r\n<P><BR>\r\nSummary: input: single integer that defines the seed for the Random.</P>\r\n<P>Output: for each cache algorithm, it's time and the final elements in the cache.</P>\r\n<P>Questions should be answered in the documentation for your code. In particular give the O analysis for the cache\r\nwhere the number of data elements to be examined is N and the size of the Cache is K. The answer should be O(some\r\nfunction in terms of K and N).</P>\r\n<P><BR>\r\nYou may use your Cache class in later assignments.</P>\r\n<P>Code Hints: TreeSet only allows you add objects, hence you may want to use the wrapper Integer to store the\r\nvalues. Look at the methods on TreeSet so that you don't store too many elements.</P>\r\n<P><B>Homework 2.</B> Goal: Practice creating and using Trees. Huffman trees are discussed in 12,1-12,4. Chapter\r\n18 discusses trees. Key sections are 18.4 on AVL trees and 18.7 on B-trees.</P>\r\n<P>In this assignment you will create optimal codes for the characters a,b,....z by generated a Huffman Tree. You\r\nmay use any of the classes in util that you find useful. The input to your program is the name of a text file.\r\nThe text file will be used to evaluate your program. Uppercase letters should be counted as their lowercase equivalent.\r\nNumbers, punctuations etc are not to be counted. I suggest that you create several simple text files to check that\r\nyour program is working correctly. The output of your program is</P>\r\n<P>a) 26 lines consisting of the letter and its frequency of the letter, in alphabetic order</P>\r\n<P>b) 26 lines consisting of the letter and its code. The letters may be in any order.</P>\r\n<P>. These entries should be separated by a tab.</P>\r\n<P><BR>\r\nSo an example output might look:</P>\r\n\r\n<BLOCKQUOTE>\r\n\t<P>a 132</P>\r\n\t<P>b 15</P>\r\n</BLOCKQUOTE>\r\n\r\n<P>etc</P>\r\n<P>and</P>\r\n<P>a 001</P>\r\n<P>e 10001</P>\r\n<P>etc.</P>\r\n\r\n<BLOCKQUOTE>\r\n\t<P>\r\n</BLOCKQUOTE>\r\n\r\n<P>Summary: input: name of a file</P>\r\n\r\n<P>output: list of letters a..z with their frequence and a list of letters with their Huffman codes.</P>\r\n\r\n<P>Coding Hints: The main two activities are reading a file, counting the frequency of the characters and building\r\na Huffman Tree. Hence I expect that there are two primary classes. Here would be my plan. You do not need to follow\r\nmy plan.</P>\r\n\r\n<P>Monday: write the driver program. Hence I would have at least two auxiliary classes: CountCharacters(String\r\nfileName) and HuffmanTree(int[] array).</P>\r\n\r\n<P>Tuesday: write the CountCharacter class and test. Note if br is a BufferedReader, then br.read() returns -1\r\nif you are at the end of the file. By using char ch = (char)br.read() you will get the next character in the file.\r\nThe Character method isLetter(char c) will tell you if it is a letter. The Character method toLowerCase(char c)\r\nreturns the lower case equivalent of the letter. Assume ch is a lower case letter, then (ch-'a') will be 0 and\r\n(ch)('a'+i) will be the ith character of the alphabet. Note that you can test this class independent of creating\r\nthe Huffman class.</P>\r\n\r\n<P>Wed/Thurs: write the Huffman class, which generates codes for each character. Since the Huffman codes are based\r\non building a special type of tree, I expect to have additional classes such as HuffmanNode. These trees are built\r\nbottom-up, which is not the usual way. You may find the LinkedList or Vector class useful here. You should think\r\ncarefully about what information you store in each node. Also note that you could write and test this class without\r\nwriting CountCharacters, e.g. by inputting simple test arrays where you know what the answer is, such as:</P>\r\n\r\n<P>int[] test = {2,2,2,2} and then running HuffmanTree(test).</P>\r\n\r\n<P>I find that when I make a logical error in coding, its very difficult to find the same day. Hence it's best\r\nfor me to get a night's sleep and retry the next day. That happened to me in coding the Huffman tree.</P>\r\n\r\n<P><BR>\r\n<B>Homework 3. </B>Goals: <B>Processing files, using hashtables and a cache. Using different data structures for\r\ndifferent goals.</B></P>\r\n\r\n<P><B>Read </B>chapter 5 or chapter on hashing</P>\r\n\r\n<P>The program finds interesting kmers. A kmer is contiguous string of exactly k letters. For example in the string\r\nACTACTA there are 4 4-mers, namely ACTA, CTAC, TACT, and ACTA. Note that we allow overlaps. Your program will read\r\nin two files and the size of k. Each file consists of characters from the alphabet {a,c,g,t}. The first file we\r\nwill call the family.The second file we will call the background. To create a filereader from the Masterhit directory,\r\nyou should use new File(&quot;\\\\\\\\Masterhit\\\\Instructional\\\\ics-23\\\\files\\\\nit.txt&quot;); You may think of the\r\nbackground as dna strings from the normal population and the family file as dna from people with some genetic disease.Your\r\nprogram goal is to find unusual (really statistically significant) kmers that occur suprisingly often in the family\r\nwith respect to the background. For the purposes of this homework we define the unusualness of a kmer in the family\r\nas:</P>\r\n\r\n<P>(size of background)*(number of times kmer occurs in family) - ( number of times kmer occurs in background)*\r\n(size of family)</P>\r\n\r\n<P>This is the difference between the actual number of occurrences and the expected number of occurrences, normalized\r\nto be an integer.</P>\r\n\r\n<P>There are more appropriate statistical well-founded definitions of surprisingness, but involve more work and\r\narrive at nearly the same results.This value defines how to kmers should be compared. The size of the background\r\nis the length of the string that the FastaReader generates. Same for the size of the family.</P>\r\n\r\n<P>To count the number of times every kmer in a family occurs use a hashtable which is part of the collections\r\npackage (in java.util.*). For computing the background counts, you should only count the kmers that occur in the\r\nfamily. Again a hashtable is suitable. If you define it properly, you can use the same hashtable as before. For\r\nexample an entry in the hashtable could consist of a pair of integers (family count, background count) and a real-values\r\nscore of the unusualness.</P>\r\n\r\n<P><B>The first step</B>: Make a schedule. Write the driver the first day and then allocate days for the rest.\r\nIf you do not write the driver by Wednesday, then I think you are very far behind schedule. By writing the driver\r\nyou can focus your questions.</P>\r\n\r\n<P>There are three major steps (b,c,d) to do this task, plus a few minor ones (a,e).</P>\r\n\r\n<P>a) You need to read into memory two files and store them as strings. (This isn't entirely necessary, but otherwise\r\nyou will have to worry about substrings wrapping around the end of one line and the beginning of the next line).\r\nBoth files are in Masterhit\\Instructional\\icsh23\\files. The family file is in &quot;nit.txt&quot;. This file is\r\nin standard &quot;Fasta&quot; format, the form that molecular biologists use to store information about genes or\r\ntheir surrounding regions.To process this file you need &quot;skip&quot; the comment lines. The net effect is that\r\nyou read this file and form a single long string, which should have 3500 characters. The second file is the complete\r\nchromosome I of yeast (which has 16 chromosomes) and is called &quot;chri_230203.txt&quot;. You can guess how many\r\ncharacters it has. Again you can do this by reading the file into a single very long string. You can define the\r\nsame reader class to process either file. (I will provide that little bit of code).</P>\r\n\r\n<P><BR>\r\nb) computing the number of times each kmer occurs in the family ( use a Hashtable or a HashMap). You need to define\r\na class I call entry. Its what goes into the hashtable. The key to the entry is the kmer, a string. Since strings\r\nhave well predefined hashcodes you don't need to define anything special. The class entry requires at least two\r\nfields: int family count and int background count. To process the family file you consider each kmer in turn, and\r\neither enter it into the hashtable or update the family count if it is already there. After you process the family\r\nfile, the family count will hold the number of occurrences in the family and the background count will be zero.\r\nThe complexity of all this should be <B>linear</B>. The general rule is that you also avoid processing a file.\r\nTwice through a file is once too many. </P>\r\n\r\n<P>The entry into the hashtable might have the fields: (string kmer, int familyCount, int backgroundCount, long\r\nscore). Note: The Java hashtable uses rehashing, so the table size will automatically be expanded as needed. However\r\nsince you may have as many as 3000 entries, you could use new Hashtable(6000) to initialize the hashtable with\r\nsize 6000.</P>\r\n\r\n<P>c) computing the number of times kmers <B>in the family</B> occur in the background (use <B>the same</B> hashtable).\r\nProcessing this file is a a little different. For each kmer in the file, check to see if it occurs in the hashtable.\r\nIf it isn't there you don't care. Otherwise you update the background count.</P>\r\n\r\n<P>d) computing unusualness and sorting the kmers by this value. Luckily hashtables have enumerators and Hashmaps\r\nhave iterators associated with them. Now you go thru the hashtable and enter the best scoring kmers into your cache\r\n(sorted, bounded) from a previous assignment. It is not necessary to use a cache.</P>\r\n\r\n<P>e) finally you print out ( to the console) the top 20 kmers from your cache with kmersize of 6 (minor step)\r\nInstead of using your cache class, you may use TreeSet from the collections package. Actually you should print\r\nout the entry associated with each of these kmers. So the output would look something like:</P>\r\n\r\n<P>Kmer # of times in family # of times in background Score</P>\r\n\r\n<P>aaaaaa 13 121 ... (not the real answer)</P>\r\n\r\n<P>etc.</P>\r\n\r\n<P>++++++++++++++++++ Code to follow ++++++++++++</P>\r\n\r\n<P><BR>\r\nHere is the code that will concatenate all the upstream regions into a single string. If you write this with s\r\n+= br.readLine() you will have a huge (unacceptable) cost overhead. Instead (and in fact better) you could just\r\nread in and process each upstream region. This code has worked for me, but no guarantees that it is errorfree.\r\nStudents have used it without problems. Complaints/improvements welcomed.</P>\r\n\r\n<P><BR>\r\nimport java.io.*;<BR>\r\n<BR>\r\nclass FastaReader<BR>\r\n{<BR>\r\nString data;<BR>\r\n<BR>\r\nFastaReader(String fileName)<BR>\r\n{<BR>\r\ntry<BR>\r\n{<BR>\r\nFile file = new File(fileName);<BR>\r\nBufferedReader bf = new BufferedReader( new FileReader (file)); <BR>\r\nStringBuffer sbuf = new StringBuffer((int)file.length());<BR>\r\n<BR>\r\nString line = bf.readLine();<BR>\r\nwhile (line != null)<BR>\r\n{ <BR>\r\nif (line.charAt(0) != '&gt;')<BR>\r\nsbuf.append(line);<BR>\r\nline = bf.readLine(); <BR>\r\n} <BR>\r\n<BR>\r\ndata = new String(sbuf);<BR>\r\nbf.close();<BR>\r\n}<BR>\r\n<BR>\r\ncatch(IOException e)<BR>\r\n{ <BR>\r\nSystem.out.println(&quot;bad file or something&quot;); <BR>\r\n}</P>\r\n\r\n<P> String getData()</P>\r\n\r\n<P>{</P>\r\n\r\n<P> return data;</P>\r\n\r\n<P>}<BR>\r\n<BR>\r\n} </P>\r\n\r\n<P><BR>\r\n<B>Homework 4: Comparison of Sorting Routines (Last homework!)</B></P>\r\n\r\n<P><B>Note: </B>As always form a work plan.  If you implement one sorting routine and the driver, you will have\r\na good estimate for thw work involved.<B></B></P>\r\n\r\n<P> Use Random r= new Random(0) for constructing the random number generator. Using this r, construct 4 test arrays\r\nof size 1000, 2000, 4000 and 8000 filling them using r.nextInt().  You will implement  four sorting algorithms\r\nand time their performance on each array.  The four sorting algorithms are: BubbleSort, Mergesort, HeapSort, and\r\nQuickSort. However the text code is for arrays of objects and you will be sorting an array of integers. The text\r\ncode provides a strong outline for the code, but you should be able to greatly simplify it. Or you can write your\r\nown code for the algorithms..  Verify the O-notation formula for the running time of each algorithm by creating\r\nthe following table <B>for each algorithm</B> where n is the number of data items. Use this data to estimate the\r\nconstant in the O-notation for the running time, i.e instead of saying O(n^2) say 23.5*n^2.</P>\r\n\r\n<P>BubbleSort time/1k time/2k time/4k time/8k      meaning the running time for to sort 1k, 2k, 4k and 8k entries\r\ndivided by the size of the array.</P>\r\n\r\n<P>time/klogk time/2klog(2k) time/4klog(4k) time/8klog*8k)</P>\r\n\r\n<P>time/k^2 time /4k^2 time/(16k^2) time/64k^2</P>\r\n\r\n<P>If some row has an approximately  constant value, then you can hypothesize that the running is time is that\r\nconstant*(appropriate polynomial).</P>\r\n\r\n<P>output: For each algorithm, a table of its performance.</P>\r\n\r\n<P>Also (in the document of the code) the precise polynomial you estimate for the running time of each algorithm.</P>\r\n\r\n<P>Besides the Driver program, this programshould have the obvious 4 classes, one for each sorting routine. It\r\nmay be convenient to have additional, auxiliary classes for the sorting routines or for measuring performance.\r\n\r\n</BODY>\r\n\r\n</HTML>", "encoding": "ascii"}