{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/arrayimplementation.txt", "content": "\t\tImplementing Collection Template Classes in the ITL\r\n\r\n\r\nIntroduction:\r\n\r\nIn this lecture we will discuss the details of the implementation of one data\r\ntype, Set, which is one of the five standard generic data types/collection\r\nclasses that we have discussed (Stack, Queue, Priority Queue, Set, and Map).\r\n\r\nThe implementation that we will discuss in detail uses an array data structure,\r\nin a simple way, to store all the values in the Set. There are strong\r\nsimilarities between this implementation of Set and the array implementations\r\nof the other data types; also, Set is of middling complexity compared to Stack,\r\nQueue, and Priority Queue (lower) and Map (higher), so it is a good class to\r\nexamine in detail.\r\n\r\nPlease feel free to examine the array implementations of the other data types;\r\nyou can find these implementations in the courselib project, In Programming\r\nAssignments 2-4, you will write more complicated (but still similar)\r\nimplementations of many of these templated classes. Note that the queue\r\nimplemention is also complicated, because it treats its array as a circular\r\nstructure, to ensure most operations are O(1) (especially enqueue and dequeue).\r\nContrast that implementation with the linear array implementation of a queue,\r\nwhich is simpler but whose operations can take more time.\r\n\r\nIn a code walk-through, a team of programmers listen to another programmer\r\ntalk about his/her code. While looking at the code and hearing a discussion of\r\nit, they probe for errors, try to uncover why certain design decisions were\r\nmade, and generally discuss the code. You need to lose your ego when you lead a\r\ncode walk-through. Consider this lecture a code walk-through: I encourage\r\nquestions about the code or criticisms of it.\r\n\r\nYou should examine array_set.hpp and ics_exceptions.hpp files while reading\r\nthis lecture note.\r\n\r\nNote that you should not edit/change any file in the courselib folder (unless\r\ntold to by the instructor). If you want to experiment with a class, copy it\r\ninto a project folder and change the copy there: when we #include files\r\nin a project, C++ will first look for/find a file with that name IN the project\r\nfolder; if it cannot, only then will it try to find a file with the same name\r\nin another directory. See the CMakeLists.txt file for an entry like the\r\nfollowing, which tells Clion which directories to check after the current one:\r\n\r\ninclude_directories(../courselib/ ../gtestlib/include/ ../gtestlib/)\r\n\r\n-------------------------\r\n\r\nArraySet:\r\n\r\nThe array_set.hpp file defines a class templated by a single type, which\r\nalso defines a nested Iterator class.\r\n\r\ntemplate<class T> class ArraySet {\r\n...\r\n\r\n  class Iterator {\r\n  ....\r\n  }\r\n\r\n....\r\n}\r\n\r\nIn the previous lecture we discussed the declarations of most of the public\r\nconstructors, methods, and operators in ArraySet. Here we will focus first on\r\nthe private data declararations used to store data in these classes, and then\r\nstudy the definitions of the constructors, methods, and operators that\r\nmanipulate them to implement the required semantics/meanings of the data type\r\n\r\n-------------------------\r\n\r\n\r\nArraySet instance variables (private):\r\n\r\nFor a start, let's examine the private: part of this class. It declares the\r\nfollowing 4 instance variables.\r\n\r\n  private:\r\n    T*  set;           //Unordered contiguous array\r\n    int length    = 0; //Physical length of array\r\n    int used      = 0; //Amount of array used: invariant: 0 <= used <= length\r\n    int mod_count = 0; //For sensing concurrent modification\r\n\r\n(1) set: a pointer to an array of type (see the constructors) T.\r\n    The values in the set are stored in this array: they are stored unordered,\r\n      and contiguously (one after the other, no holes) in indexes 0 through\r\n      used-1.\r\n    This array can be reallocated (growing/shrinking) to accomodate more/fewer\r\n       values.\r\n\r\n(2) length: the length of whatever array is pointed to by set.\r\n    When the set array is reallocated (see above) this value changes.\r\n\r\n(3) used: the amount of the array (number of indexes) that contains values.\r\n      invariant: 0 <= used <= length; so, for an array of length 4, used can be\r\n      0, 1, 2, 3, and 4 (meaning storing 0 through 4 values: 5 possibilities);\r\n      the first possible set value is stored in set[0] and the last is stored\r\n      in set[4] when the array is filled.\r\n\r\n(4) mod_count: the number of modIFICATIONs to (calls to mutators that actually\r\n      mutate) an ArraySet since it was constructed.\r\n    Storing this value is required for the correct implementation of iterators,\r\n      so they can sense if a modification has been made since they started.\r\n     \r\nThe private: part of the class also declares three (non-public) helper methods\r\n(erase_at, ensure_length, and ensure_length_low), which are called by public\r\nmethods defined in this class, to simplify their code; we will discuss these\r\nhelper methods later in this lecture note.\r\n\r\nNote that I explicitly initialize all instance variables but \"set\". I like to\r\nuse such initializations and minimize the number of initializations in the\r\nconstructors, to avoid forgetting to initalize something. Alex Thornton thinks\r\nthat every constructor should explicitly initialize all its instance variables\r\n(citing locality: the initializations should appear near the constructor). Both\r\nof us are concerned about accidentally failing to initialize an instance\r\nvariable. Often C++ compilers will provide warning/error messages if an\r\ninstance variable is not initialized in one way or the other. The interesting\r\npart of every constructor (discussed below) is allocating (and reallocating, in\r\nthe ensure_length/ensure_length_low helper methods) the array storing the\r\nvalues in the set.\r\n\r\nmod_count is updated by command/mutator methods and examined solely by Iterator\r\nmethods when iterating over an ArraySet, to determine if the ArraySet has been\r\nmodified since the iteration started. If it has, and the iteration continues,\r\nthe Iterator methods will throw a ConcurrentModificationError exception. We\r\ncannot simultaneously traverse (iterate over) and mutate a data structure:\r\ndoing so can lead to unpredictable behavior, so instead the iterator throws an\r\nexception in such circumstances. Note it is OK for the iterator itself to mutate\r\nthe data structure (with its .erase method) and continue iterating - although in\r\nthis case other iterators must stop.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nDestructor/Constructors (public, also covering ensure_length/ensure_length_low,\r\nwhich are private):\r\n\r\nThis section discusses the definition of the destructor and all the constructors\r\ndeclared in ArraySet.\r\n\r\n(0) ~ArraySet() - a destructor that deallocates the array that set refers to,\r\nwhich also calls a destructor on each of the values in the array.\r\n\r\ntemplate<class T>\r\nArraySet<T>::~ArraySet() {\r\n  delete[] set;\r\n}\r\n\r\n\r\n(1) ArraySet() - default constructor:  allocate an array of length 0. The\r\ninsert method always calls ensure_length to ensure that an array will be long\r\nenough to store a newly inserted value (and the erase method always calls\r\nensure_length_low to shrink the array if it is overly long). So its length will\r\nbe increased to 1 before storing the first value. Some implementations would\r\nallocate a non-zero minimal-sized arrray: not a bad idea because we problably\r\nwouldn't declare the Set if we weren't going to put at least one value in it.\r\nOf course, we can do that explicitly, by using the next constructor.\r\n\r\ntemplate<class T>\r\nArraySet<T>::ArraySet() {\r\n  set = new T[length];\r\n}\r\n\r\n\r\n(2) ArraySet(int initial_length): use inital_length as the initial length for\r\nthe array to allocate (although negative lengths are disallowed: it uses length\r\n0 if the argument is negative, instead of throwing an exception). Note that\r\nthis constructor is called a conversion constructor, which we don't want to be\r\ncalled automatically, so we declare it (earlier in the class declaration) with\r\nthe keyword \"explicit\": by using \"explicit\", ArraySet s = 1; will not compile;\r\nwithout \"explicit\" it would have the same meaning as writing ArraySet s(1);\r\nwhich does NOT create a set storing the value 1, but instead creates a set\r\nwhose array is length 1. Note, the stuff between the : and { is called the\r\ninitializer: it initializes some (not necessarily all) instance varaibles.\r\n\r\ntemplate<class T>\r\nArraySet<T>::ArraySet(int initial_length)\r\n: length(initial_length) {\r\n  if (length < 0)\r\n    length = 0;\r\n  set = new T[length];\r\n}\r\n\r\n\r\n(3) ArraySet(const ArraySet<T>& to_copy) - copy constructor: use the to_copy\r\nArraySet to supply the length and used instance variables, then allocate an\r\nappropriate sized array and copy the required values into it. We could instead\r\nwrite: length(to_copy.used), which would create a minimal length copy (but big\r\nenough for all used values).\r\n\r\ntemplate<class T>\r\nArraySet<T>::ArraySet(const ArraySet<T>& to_copy)\r\n: length(to_copy.length), used(to_copy.used) {\r\n  set = new T[length];\r\n  for (int i=0; i<to_copy.used; ++i)\r\n    set[i] = to_copy.set[i];\r\n}\r\n\r\n\r\n(4) ArraySet(const std::initializer_list<T>& il)) - initializer constructor\r\n(new in C++11): iterate through all the values in the initializer_list,\r\ninserting each into the ArraySet. This constructor allows us to write:\r\n\r\n  ArraySet<int> s({1,2,3,4,5});\r\n\r\nThis statement declares the ArraySet s and stores into it the values 1 through\r\n5 inclusive.\r\n\r\nNote that the following will not work, because the constructor is explicit.\r\n\r\n  ArraySet<std:int> s = {1,2,3,4,5};\r\n\r\nBut, using the = operator and two constructors, we could write the following\r\ncode (which redundantly constructs and destructs a temporary ArraySet).\r\n\r\n  ArraySet<int> s = ArraySet<int>({1,2,3,4,5});\r\n\r\nMaybe explicit is a poor choice for the initializer list constructor :(\r\n\r\ntemplate<class T>\r\nArraySet<T>::ArraySet(const std::initializer_list<T>& il)\r\n: length(il.size()) {\r\n  set = new T[length];\r\n  for (const T& s_elem : il)  //Can use for-each to iterate over intializer_list\r\n    insert(s_elem);\r\n}\r\n\r\n(5) template<class Iterable> ArraySet(const Iterable& i) - iterator constructor:\r\niterate through all the values in i, inserting each into the ArraySet. Each of\r\nthe five standard data types supports size/begin/end/prefix ++, which are\r\nneeded for the for-each loop in this method to work correctly. Thus, we can\r\neasily construct a data type from one class by iterating over the data stored in\r\nanother class: e.g., construct a Set with all the values in a Queue.\r\n\r\ntemplate<class T>\r\ntemplate<class Iterable>\r\nArraySet<T>::ArraySet(const Iterable& i)\r\n: length(i.size()) {\r\n  set = new T[length];\r\n  for (const T& v : i)\r\n    insert(v);\r\n}\r\n\r\n\r\nI will now include a description of the private helper methods (a) ensure_length\r\nand (b) ensure_length_low here, because they also relate to reallocation of the\r\n\"set\" instance variable. These methods, which appear similarly in the array\r\nimplementations of all the data types, ensure that set's array length is\r\n\"reasonble\": big enough when \"inserting\" and not too big when \"erasing\".\r\n\r\n(a) For ensure_length, it ensures the array can store new_length values; if it\r\ncannot, ensure_length makes set's length either new_length or double the old\r\nlength (whichever is bigger) and copies all the set's values there; finally it\r\ndeletes the old array, reclaiming all its space. The code here is delicate: we\r\nneed to keep track of the old information while creating the new information.\r\n\r\nWhen we talk about Analysis of Algorithms we will see that this doubling\r\nstrategy requires only O(N) copies when creating a Set of N new values. If\r\nwe increased the size just by 1 for each new value (not doubling), that\r\nstrategy would require O(N^2) copies.\r\n\r\ntemplate<class T>\r\nvoid ArraySet<T>::ensure_length(int new_length) {\r\n  if (length >= new_length)\r\n    return;\r\n  T* old_set = set;\r\n  length = std::max(new_length,2*length);\r\n  set = new T[length];\r\n  for (int i=0; i<used; ++i)\r\n    set[i] = old_set[i];\r\n\r\n  delete [] old_set;\r\n}\r\n\r\n(b) For ensure_length_low, it ensures the array is not too large, but it is\r\nlarge enough to double in length without reallocating the array. Thus, if the\r\nlength needed is <= 1/4 of the actual length, the array length will be reduced\r\nto just twice what is needed (typically halved). For example, if we have 8\r\nvalues in an array and then start removing them, when the number or remaining\r\nvalue becomes 2 (1/4 of 8) the array size will be reduced to 4 (halved). It is\r\nnow smaller (by half) but it still allows 2 more values to be added into the\r\narray before it must be doubled.\r\n\r\nIf we halved the size of the array when half (not a quarter) was needed\r\n(reduced the length 8 array to a length 4 array when only 4 values remained),\r\nthen adding a new value into the array would require its length to be doubled\r\nimmediately. Whenever we reallocate an array, we want to be able to add/remove\r\na reasonable number of values without having to reallocate the array.\r\n\r\nAgain, the code here is delicate: we need to keep track of the old information\r\nwhile creating the new information.\r\n\r\ntemplate<class T>\r\nvoid ArraySet<T>::ensure_length_low(int new_length) {\r\n  if (length < 4 * new_length)\r\n    return;\r\n  T *old_set = set;\r\n  length = 2 * new_length;\r\n  set = new T[length];\r\n  for (int i = 0; i < used; ++i)\r\n    set[i] = old_set[i];\r\n\r\n  delete[] old_set;\r\n}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nQueries/Accessors (public):\r\n\r\nNotice that each of of these methods include the keyword \"const\" after its\r\nparameter list, because each leaves the data structure unchanged/unmutated.\r\n\r\n\r\n(1) empty: returns whether the Set stores no value (used is 0). We could more\r\ngenerally just check this->size() == 0, and we would if the size() function was\r\ntruly computed in a complicated function, but here we check the used instance\r\nvariable directly. (See the relationship in the ArrayQueue class between the\r\nempty and size functions for something more complicated).\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::empty() const {\r\n  return used == 0;\r\n}\r\n\r\nWe spoke about using \"used\" to cache the number of values used in the array,\r\ntaking up SPACE so we don't have spend TIME computing it. A time/space tradeoff.\r\n\r\nI could have also declared this function starting with \"inline\". That is\r\nanother form of a time/space tradeoff. Inline functions take us more space\r\neverywhere they are called (the compiled code is repeated at each call site),\r\nbut cuts down the time taken to call/return from a function. For a big function\r\n(where calling and returning time is small compared to the function execution\r\ntime: say functions that contain loops), the time improvement is small and the\r\nspace degradation is large. But for a tiny function (where the overhead of\r\ncalling/returning from the function might take the same amount of time as the\r\nfunction itself), the inline might be warranted. Sometimes debugging is more\r\ncomplicated with inline (but if it is a tiny function, we hope we don't have\r\nto debug it).\r\n\r\n\r\n(2) size: returns the number of values the Set stores. The set's values are\r\nstored in indexes 0 to used-1, for a total of used values. When used is 5, the\r\nvalues are stored in indexes 0, 1, 2, 3, and 4.\r\n\r\ntemplate<class T>\r\nint ArraySet<T>::size() const {\r\n  return used;\r\n}\r\n\r\nThis would be another good candidate for an inline function.\r\n\r\n\r\n(3) contains: determines whether an element is in the Set. It performs a linear\r\nsearch of the array (whose values are unordered), returning true immediately\r\nwhen the value element is found in any used index in the array; and returning\r\nfalse (after/outside the loop) if element is not found in any used index in the\r\narray.\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::contains (const T& element) const {\r\n  for (int i=0; i<used; ++i)\r\n    if (set[i] == element)\r\n      return true;\r\n\r\n  return false;\r\n}\r\n\r\n\r\n(4) str: uses a temporary ostringstream (returned using the .str() function to\r\nconvert the ostringstream to a std::string) to collect all the textual data\r\nstr() returns: this includes the standard text for inserting a set onto the\r\nostream. For example, \"ArraySet[0:a,1:b,2:c,3:](length=4,used=3,mod_count=3)\"\r\nshows\r\n\r\n (a) \"ArraySet\" is the implementation\r\n (b) the array instance variable (all its indices and their values); here I\r\n       chose to show ALL indices, not just the used onces. Because used is 3,\r\n       index 3 shows the empty string (put into each index by the default\r\n       constructor for std::string).\r\n (c) the values of all the other instance variables used in this array\r\n       implementation of a set.\r\n\r\nUsing ostringstream in this way is useful in many contexts when we want to build\r\na large string from a variety of values (converting each to its string\r\nrepresentation). Some types don't define a function that returns their string\r\nrepresentation, but do define the << operator, which is used here.\r\n\r\nUse << for real output for a Set and .str() for debugging output for a Set\r\n(especially to debug specific implementations, like ArraySet).\r\n\r\ntemplate<class T>\r\nstd::string ArraySet<T>::str() const {\r\n  std::ostringstream answer;\r\n  answer << \"ArraySet[\";\r\n\r\n  if (length != 0) {\r\n    answer << \"0:\" << set[0];\r\n    for (int i = 1; i < length; ++i)\r\n      answer << \",\" << i << \":\" << set[i];\r\n  }\r\n\r\n  answer << \"](length=\" << length << \",used=\" << used << \",mod_count=\" << mod_count << \")\";\r\n  return answer.str();\r\n}\r\n\r\n\r\n(5) contains_all: determines whether ALL the values in the iterable are in the\r\nSet. It uses a for-each loop to iterate over the parameter i, using contains\r\n(see above) to check whether any value produced by the iterable returns false:\r\nif so this function immediately returns false; if every value produced by the\r\niterable is contained in the array, then this function eventually returns true.\r\nAgain, we could write this->contains(v) to emphasize we are calling the contains\r\nmethod in the ArraySet class.\r\n\r\ntemplate<class T>\r\ntemplate<class Iterable>\r\nbool ArraySet<T>::contains_all (const Iterable& i) const {\r\n  for (const T& v : i)\r\n    if (!contains(v))\r\n        return false;\r\n  \r\n    return true;\r\n}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCommands/Mutators (public, also covering erase_at which is private):\r\n\r\nNotice that none of these methods say \"const\" after the parameter list, because\r\nall change (or at least can change, if necessary) the data structure. Each\r\nchange is accompanied by incrementing the mod_count (modification count)\r\ninstance variable. If we wrote \"const\" with these methods, the compiler would\r\nreport an error because it knows when we are \"lying\" (the code can change\r\ninstance variables).\r\n\r\n\r\n(1) insert: adds an element into the Set if it is not already in the Set,\r\nreturning 1 if it was not in the Set and 0 if it is was. It performs a linear\r\nsearch through the array, returning 0 immediately if it finds the element; if it\r\ndoesn't find the element anywhere, it calls ensure_length to ensure the length\r\nof the array is big enough to store a new element (initially going from\r\nlength = 0 to length = 1, otherwise doubling the length); then it puts the\r\nelement in the array one beyond the last element previously stored, and notes\r\nthe modification by incrementing mod_count, and returning 1.\r\n\r\nThis method is the most critical in the class; we should hand simulate a few\r\ninsertions, including calls to ensure_length. Note that if used = 5, then\r\nindexes 0 through 4 are occupied, so writing set[used++] = element; increments\r\nused by 1, but uses its old value (5) as the index to store the new element,\r\nwhich is exactly what we want to happen: it is 1 beyond the index of the\r\npreviously last value, stored in index 4.\r\n\r\nNote that Sets are not ordered in any special way, so we can put the element\r\nanywhere, but it is most convenient to store it at an index one higher than the\r\nlast (requiring no other data movements in the array). I'm also assuming that\r\nyou know the exact meanings and differences between used++ and ++used: both\r\nincrement used, but the value returned by the postfix operator (yes, this\r\noperator returns a values, just as a+b returns a value) is the original value\r\nin used (before incrementing it) while the value returned by the prefix\r\noperator is the new  value in used (after incrementing it).\r\n\r\nint ArraySet<T>::insert(const T& element) {\r\n  for (int i=0; i<used; ++i)\r\n    if (set[i] == element)\r\n      return 0;\r\n\r\n  this->ensure_length(used+1);\r\n  set[used++] = element;\t//or 2 statements: set[used] = element; ++used;\r\n  ++mod_count;\r\n  return 1;\r\n}\r\n\r\nWe could call the contains method here, instead of writing the same for loop.\r\n\r\n\r\n(2) erase: removes (the opposite of insert) the element from the Set if it is\r\nalready in the Set, returning 1 if it is in the Set and 0 if it is not. It\r\nperforms a linear search through the array, returning the value that private\r\nhelper method erase_at(i) returns (it always returns 1; erase_at is described\r\nat the end of this section) if it finds element; if it doesn't find the element,\r\nit just returns 0 without calling erase_at. The erase_at method may reallocate\r\nthe array to be smaller, and always updates mod_count too; this same method is\r\nalso called by the Iterator's erase method (discussed later).\r\n\r\ntemplate<class T>\r\nint ArraySet<T>::erase(const T& element) {\r\n  for (int i=0; i<used; ++i)\r\n    if (set[i] == element)\r\n      return erase_at(i);\r\n\r\n  return 0;\r\n}\r\n\r\nNote that erase_at might shrink the array (see its code below).\r\n\r\n\r\n(3) clear: removes all the elements from the Set by just resetting used (and of\r\ncourse incrementing mod_count). The call to ensure_length_low will actually\r\nreallocated the array to store 0 values. The speed of this operation is\r\nindependent of the number of elements stored in the array: it is O(1).\r\n\r\ntemplate<class T>\r\nvoid ArraySet<T>::clear() {\r\n  used = 0;\r\n  this->ensure_length_low(0);\r\n  ++mod_count;\r\n}\r\n\r\n\r\n(4) insert_all: inserts all the values in the iterable into the Set, returning\r\na count of the number of values actually inserted (unique values not originally\r\nin the Set). It uses a for-each loop to iterate over the parameter i, using\r\ninsert (see above) to actually insert the value into the Set; each call to\r\ninsert updates mod_count, so mod_count can increase by more than 1 in a call to\r\ninsert_all.\r\n\r\ntemplate<class T>\r\ntemplate<class Iterable>\r\nint ArraySet<T>::insert_all(const Iterable& i) {\r\n  int count = 0;\r\n  for (const T& v : i)\r\n     count += insert(v);\r\n  return count;\r\n}\r\n\r\n\r\n(5) erase_all: erases all the values in the iterable from the Set, returning a\r\ncount of the number actually erased (unique values originally in the Set). It\r\nuses a for-each loop to iterate over the parameter i, using erase (see above)\r\nto actually erase the value into the Set; each call to erase updates  mod_count,\r\nso mod_count can increase by more than 1 in a call to erase_all.\r\n\r\ntemplate<class T>\r\ntemplate<class Iterable>\r\nint ArraySet<T>::erase_all(const Iterable& i) {\r\n  int count = 0;\r\n  for (const T& v : i)\r\n     count += erase(v);\r\n\r\n  return count;\r\n}\r\n\r\nNote that erase (calling erase_at) might shrink the array multiple times, which\r\nit inefficient; better to shrink it once, after all erasures. To do this we\r\nwould have to \"turn off\" shrinking until after the loop finishes, and then\r\ncall ensure_length_low(used); explicitly here.\r\n\r\n\r\n(6) retain_all: retains all the values in the iterable in the Set, returning a\r\ncount of the number actually erased (unique values originally in the Set). It\r\nuses the iterable constructor to create an ArraySet s containing all the values\r\nin the iterable; then it examines every element in the Set and checks s to\r\ndecide whether or not it should be erased, using erase (see above) to actually\r\nerase the value into the Set; each call to erase updates  mod_count, so\r\nmod_count can increase by more than 1 in a call to retain_all.\r\n\r\nKey point (read erase_at below first): if it erases the value at index i, a new\r\nvalue is put into index i (the value formerly at the end of the array), so that\r\nvalue must be checked too; but because i will be incremented at the bottom of\r\nthe loop, we must decrement i explicitly whenever we erase a value. Hand\r\nsimulate an example (including the call to erase_at) where a Set contains two\r\nvalues and the iterable creates an empty set s (so neither value should be\r\nretained): without decrementing i, this code would skip (and therefore retain)\r\nthe second value!\r\n\r\ntemplate<class T>\r\ntemplate<class Iterable>\r\nint ArraySet<T>::retain_all(const Iterable& i) {\r\n  ArraySet s(i);\r\n  int count = 0;\r\n  for (int i=0; i<used; i++)\r\n    if (!s.contains(set[i])) {\r\n      erase_at(i);\r\n      --i;\r\n      ++count;\r\n    }\r\n\r\n  return count;\r\n}\r\n\r\n\r\n(7) erase_at: a private helper method that removes the value at index i from\r\nthe Set/array. Note that as we talked about in class, while we COULD shift the\r\nvalues in each index after it, one forward (an O(N) operation), but that order-\r\npreserving operation is not necessary because Sets have no order! So the \"no\r\norder\" latitude allows us to implement this operation in O(1) time by just\r\ncopying the value at the end of the array to the index of the value to remove\r\nand then \"ignore\" the value in that last position by decrementing used.\r\n\r\nNote if that the index to remove is 0 and used is 1, this code still work: it\r\ncopies from the last index (0) to the index being removed (0) and then\r\ndecrements used to 0. of course, this method also increments mod_count.\r\n\r\nAfter the set is updated and used is decremented, it calls ensure_length_low,\r\nwhich might reallocate/shrink the set array (it reallocates/shrinks only if\r\nused is < 1/4 of length).\r\n\r\nAgain, look at this code and go back to what I said in detail about the\r\nretain_all method - about decrementing i when a value is removed: because a new\r\nvalue is moved to index i, it still must be checked for being retained, but the\r\nfor loop automatically increments i: so to keep i the same, we must decrement\r\nit first. Tricky, but OK.\r\n\r\ntemplate<class T>\r\nint ArraySet<T>::erase_at(int i) {\r\n  set[i] = set[--used];\r\n  this->ensure_length_low(used);\r\n  ++mod_count;\r\n  return 1;\r\n}\r\n\r\n\r\nIt might have been useful to write a private index_of method that either\r\nreturns the index at which a value is stored in the array or -1 if it is not\r\nstored there (because -1 is never a legal arrray index). Note that because we\r\nare storing a Set of values, the same value cannot occur twice. Such code would\r\nsimplify a few methods by removing their looping code and calling the looping\r\ncode in index_of. Here are examples of how such code would work, if it were in\r\nthe class:\r\n\r\ntemplate<class T>\r\nint ArraySet<T>::index_of(const T& element) const {\r\n  for (int i=0; i<used; ++i)\r\n    if (set[i] == element)\r\n      return i;\r\n\r\n  return -1;\r\n}\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::contains (const T& element) const {\r\n  return index_of(element) != -1;\r\n}\r\n\r\nint ArraySet<T>::insert(const T& element) {\r\n  int i = index_of(element);\r\n  if (i != -1)\r\n    return 0;\r\n\r\n  this->ensure_length(used+1);\r\n  set[used++] = element;\r\n  ++mod_count;\r\n  return 1;\r\n}\r\n\r\ntemplate<class T>\r\nint ArraySet<T>::erase(const T& element) {\r\n  int i = index_of(element);\r\n  return (i == -1 ? 0 : erase_at(i));\r\n}\r\n\r\n------------------------------------------------------------------------------\r\n\r\nOverloaded Operators (public):\r\n\r\n(1) operator =: assign the value of the Set rhs to this Set so they compare ==\r\n(see below). Note if x and y are Sets, then x = y calls operator= on the left\r\nSet (so \"this\" refers to the Set x) while the parameter name rhs refers to\r\nthe Set y. It first checks if the two Sets are the same object (meaning the\r\nassignment statement was of the form x = x) and if so does nothing; otherwise\r\nit ensures this Set has an array big enough to store all the values stored in\r\nrhs Set, sets used correctly, fills the array with values for the rhs,\r\nincrements mod_count, and returns this (for use in code like x = y = z; which\r\nassigns z to y, returning y, which it assigns to x.\r\n\r\ntemplate<class T>\r\nArraySet<T>& ArraySet<T>::operator = (const ArraySet<T>& rhs) {\r\n  if (this == &rhs)\r\n    return *this;\r\n  this->ensure_length(rhs.used);\r\n  used = rhs.used;\r\n  for (int i=0; i<used; ++i)\r\n    set[i] = rhs.set[i];\r\n\r\n  ++mod_count;\r\n  return *this;\r\n}\r\n\r\nNotice that copying the array is faster (O(N)) than \"inserting\" every value\r\ninto the set (O(N^2)): each insert first looks to see if the value is already\r\nin the set (which is O(N) itself). We \"know\" -because rhs is an ArraySet- it\r\ncontains NO DUPLICATE VALUES, so we can just jam each one into the set array\r\nwithout determining if it is already there.\r\n\r\n\r\n(2) operator ==: determines whether or not two Sets store the same values\r\n(regardless of their order in the arrays: recall Sets are unordered). It too\r\nfirst checks if the two Sets are the same object (meaning the test was of the\r\nform x == x) and if so immediately returns true; otherwise if next quickly\r\nchecks whether the Sets are the same size, and if not returns false; finally it\r\niterates through this Set's array to ensure every value in it is also contained\r\nin the rhs Set. If this is true, and sets are the same size, they are ==.\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::operator == (const ArraySet<T>& rhs) const {\r\n  if (this == &rhs)\r\n    return true;\r\n\r\n  if (used != rhs.size())\r\n    return false;\r\n\r\n  for (int i=0; i<used; ++i)\r\n    if (!rhs.contains(set[i]))\r\n      return false;\r\n\r\n  return true;\r\n}\r\n\r\n\r\n(3) operator !=: determines whether two Sets have some different values\r\n(regardless of their order in the arrays). It just calls == and negates the\r\nresults (a tiny bit less efficient but much simpler).\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::operator != (const Set<T>& rhs) const {\r\n  return !(*this == rhs);\r\n}\r\n\r\n\r\n(4) operator <=: determines whether this Set is a subset (or the same Set) as\r\nrhs Set. Mostly, this operators does what == does, but it also allows\r\nthis->used to be <= rhs.used.\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::operator <= (const Set<T>& rhs) const {\r\n  if (this == &rhs)\r\n    return true;\r\n\r\n  if (used > rhs.size())\r\n    return false;\r\n\r\n  for (int i=0; i<used; ++i)\r\n    if (!rhs.contains(set[i]))\r\n      return false;\r\n\r\n  return true;\r\n}\r\n\r\n\r\n(5) operator <: determines whether this Set is a strict subset (not the same\r\nSet) as rhs Set. Mostly, this operators does what == does, but it also allows\r\nthis->used to be < rhs.used.\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::operator < (const Set<T>& rhs) const {\r\n  if (this == &rhs)\r\n    return false;\r\n\r\n  if (used >= rhs.size())\r\n    return false;\r\n\r\n  for (int i=0; i<used; ++i)\r\n    if (!rhs.contains(set[i]))\r\n      return false;\r\n\r\n  return true;\r\n}\r\n\r\n\r\n(6) operator >=: determines whether this Set is a superset (or the same Set) as\r\nrhs Set. Uses the rule x >= y iff y <= x (which is true for the subset\r\nrelation).\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::operator >= (const Set<T>& rhs) const {\r\n  return rhs <= *this;\r\n}\r\n\r\n\r\n(7) operator >: determines whether this Set is a strict superset (not the same\r\nSet as hrs Set. Uses the rule x > y iff y < x (which is true for the proper\r\nsubset relation).\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::operator > (const Set<T>& rhs) const {\r\n  return rhs < *this;\r\n}\r\n\r\nIn retrospect (and maybe I'll change this with a later release of the\r\ncourselib), I should have implemented <= in detail as shown above and then\r\nimplemented all the other relational operators as follows:\r\n\r\n  == as <= and used == rhs.used\r\n  != the same, by negating ==: x != y iff !(x == y)\r\n  >  by negating <=: x > y iff !(x <= y)\r\n  <  the same, by changing sides: x < y iff y > x\r\n  >= by changing sides: x >= y iff y <= x\r\n\r\nWhich results in only one multi-line method: the rest one-liners. So we can\r\nsimply define all relational operators in terms of <=.\r\n\r\n\r\n(8) operator <<: insert onto the outs ostream either \"set[]\" or \"set[...]\"\r\nwhere ... are all the values in the Set, separated by commas. Note that the\r\nvalues can appear in any order in a Set: so two Sets that print differently are\r\nreally the same (are ==) if they print the same values but just in a different\r\norder.\r\n\r\nIn the code below it is simplest to use the order the values are  stored in the\r\narray, and that order is fine. That is, for Sets, any order will do. WE CANNOT\r\nASSUME THAT ALL IMPLEMENTATIONS OF SETS WILL USE SUCH AN ORDERING. Hand\r\nsimulate this code for a Set containing just a few values to see why it works.\r\n\r\nQuestion: could we have implemented == by using << to create two strings for\r\nSets (first using ostringstream then .str() to get the string itself) and\r\ncompare these string for equality? If so, why (and would it be a good idea);\r\nif not, why not?\r\n\r\ntemplate<class T>\r\nstd::ostream& operator << (std::ostream& outs, const ArraySet<T>& s) {\r\n  outs << \"set[\";\r\n\r\n  if (!s.empty()) {\r\n    outs << s.set[0];\r\n    for (int i=1; i < s.used; ++i)\r\n      outs << \",\" << s.set[i];\r\n  }\r\n\r\n  outs << \"]\";\r\n  return outs;\r\n}\r\n\r\nA slightly simpler body (without the special case) would be as follows. Notice\r\nhow it inserts the empty set a bit differently, and after inserting the last\r\nvalue in the set, inserts the empty string (\"\") and inserts \"]\" after the loop\r\nfinishes.\r\n\r\ntemplate<class T>\r\nstd::ostream& operator << (std::ostream& outs, const ArraySet<T>& s) {\r\n  outs << \"set[\";\r\n\r\n  for (int i=0; i < s.used; ++i)\r\n    outs << (i == 0 ? \"\" : \",\") << s.set[i];\r\n\r\n  outs << \"]\";\r\n  return outs;\r\n}\r\n\r\nThere are many ways to do equivalent things in C++: try to choose ways that are\r\nsimple and clear. Can you argue why \"something special\" is always needed to\r\ncorrectly show the values separated by commas?\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterator Nested class (public):\r\n\r\nIMPORTANT: In the drivers there is an \"it\" menu option to examine iterators in\r\ndetail (their methods and operators). After you read this section, try the \"it\"\r\nsubmenu to further explore your understanding of the methods described below.\r\n\r\nThe meanings of the commands in the (it)erator menu are as follows:\r\n  <   : print the iterator\r\n  e   : erase the value specified by the iterator (by it cursor)\r\n  *   : print the value the iterator refers to (its cursor refers to)\r\n  +   : increment the iterator prefix, ++i (advance cursor, return new value)\r\n  +o  : increment the iterator pOstfix, i++ (advance cursor, return old value)\r\n  c   : process regular commands for the data type while remembering the\r\n          iterator (do a mutator, then quit, then update the iterator to\r\n          see a ConcurrentModificationError)\r\n  *a  : repeatedly print the value the iterator refers to and then prefix\r\n          increment the iterator, until it reaches one beyond the end\r\n  ea  : repeatedly erase the values the iterator refers to and then prefix \r\n          increment the iterator, until it reaches one beyond the end\r\n          (printing the initial and final iterator values)\r\n  f   : use a for-each loop to print the value of every value the iterator\r\n         refers to\r\n  q   : quit experimenting with the iterator\r\n\r\nNote that the ArraySet class defines a nested scope containing the Iterator\r\nclass. We can refer to this class by ics::ArraySet<T>::Iterator if we need to.\r\nWe can use an Iterator to erase a value from the Set, compute a .str()\r\nrepresentation of the Iterator, increment an Iterator (both ways: prefix ++i\r\nand postfix i++), check for equality/inequality among Iterators, and finally\r\ndereference an  Iterator to get at the value it refers to or get a pointer to\r\nthe value it refers to.\r\n\r\nWe will discuss these methods below. But first we discuss the private instance\r\nvariables. Note that there is a simple but delicate relationship between the\r\nerase method and ++ operators.\r\n\r\n    class Iterator {\r\n      public:\r\n        //Private constructor called in begin/end, which are friends of ArraySet<T>\r\n        ~Iterator();\r\n        T           erase();\r\n        std::string str  () const;\r\n        ArraySet<T>::Iterator& operator ++ ();\r\n        ArraySet<T>::Iterator  operator ++ (int);\r\n        bool operator == (const ArraySet<T>::Iterator& rhs) const;\r\n        bool operator != (const ArraySet<T>::Iterator& rhs) const;\r\n        T& operator *  () const;\r\n        T* operator -> () const;\r\n        friend std::ostream& operator << (std::ostream& outs, const ArraySet<T>::Iterator& i) {\r\n          outs << i.str(); //Use the same meaning as the debugging .str() method\r\n          return outs;\r\n        }\r\n        friend Iterator ArraySet<T>::begin () const;\r\n        friend Iterator ArraySet<T>::end   () const;\r\n\r\n      private:\r\n        //If can_erase is false, current indexes the \"next\" value (must ++ to reach it)\r\n        int          current;  //if can_erase is false, this value is unusable\r\n        ArraySet<T>* ref_set;\r\n        int          expected_mod_count;\r\n        bool         can_erase = true;\r\n\r\n        //Called in friends begin/end and postfix ++\r\n        Iterator(ArraySet<T>* iterate_over, int initial);\r\n    };\r\n\r\n------------------------------------------------------------------------------\r\n\r\nArraySet::Iterator instance variables (private):\r\n\r\n (1) current: an index into a Set's array: where the iterator is in an ArraySet.\r\n     It should always be >= 0 and <= used. It is OK to be == to used because it\r\n     can be ONE BEYOND the end of the array; that is how the for-each code\r\n     knows it has iterated over every value in the Set.\r\n\r\n (2) ref_set: the ArraySet the iterator refers to (is indexing over): we will\r\n     access its \"set\" instance variable (an array) with indexed by current\r\n     (an int).\r\n\r\n (3) expected_mod_count: stores the mod_count's value when the iterator was\r\n     created; to work properly, expected_mod_count must == ref_set->mod_count;\r\n     it is checked in every operation and if these values are unequal, it means\r\n     that the array was mutated (by something other than erase in the\r\n     iterator, which is discussed below), so the ConcurrentModificationError\r\n     exception is thrown.\r\n\r\n (4) can_erase: ensures we cannot call .erase() on the iterator twice in a row,\r\n     without calling ++ to advance the iterator. When the value in some index\r\n     is erased, it is replaced by the value appearing at the end of the array;\r\n     in this case, the next call to a ++ operator actually does not increment\r\n     current (discussed more below) because it already indexes the next value \r\n     (one value beyond the most recently erased value).\r\n\r\nNote: The can_erase instance variable always starts true (all the others need\r\nto be given values in the constructor).\r\n\r\nThe code shown for the Iterator methods/operators will clarify what the last\r\ntwo instance variables mean, by discussing how they are used.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nMethods producing Iterators (public)\r\n\r\nNote that the only constructor for Iterator is private. But, this class friends\r\nthe begin/end methods declared in the ArraySet class, directly after it declares\r\nthe Iterator class. These begin/end methods construct and return Iterators. Both\r\nmethods require their return type to be specified as auto, but then explicitly\r\nadded the actual return type after the ->.\r\n\r\nIn all cases we have to cast away constness of \"this\" because we need to be able\r\nto call .erase() on an Iterator which means it can change the state of the\r\nArraySet it refers to. Alex -my C++ guru- recommended declaring ref_set as\r\nmutable, which would not required the cast. I'm not sure which I like better.\r\n\r\n(1) begin: return an Iterator whose current index is where the first value in\r\nthe ArraySet would be stored (index 0). \r\n\r\ntemplate<class T>\r\nauto ArraySet<T>::begin () const -> ArraySet<T>::Iterator {\r\n  return Iterator(const_cast<ArraySet<T>*>(this),0);\r\n}\r\n\r\nNote the auto and -> parts of these definition. Writing\r\n\r\nArraySet<T>::Iterator ArraySet<T>::begin () const {...}\r\n\r\nwould confuse C++ having to do with the interaction between the return type\r\nand the templated class in which this is a method (I'm murky on this). The C++\r\ncompiler would complain about \"missing typename\" and we could successfully write\r\nthis header as \r\n\r\ntypename ArraySet<T>::Iterator ArraySet<T>::begin () const {...}\r\n\r\n\r\n(2) end: return an Iterator whose current index is ONE BEYOND where the last\r\nvalue in the ArraySet is stored (index used).\r\n\r\ntemplate<class T>\r\nauto ArraySet<T>::end () const -> ArraySet<T>::Iterator {\r\n  return Iterator(const_cast<ArraySet<T>*>(this),used);\r\n}\r\n\r\nDitto.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIterators constructors/methods/operators (private and public)\r\n\r\n(1) Iterator constructor: fills in ref_set (which ArraySet this iterator is\r\niterating over) and initializes to what index in ref_set's array the iterator\r\nis referring.\r\n\r\nCRITICAL: The expected_mod_count instance variable copies the mod_count of the\r\nref_set to which it refers. If the mod_count of this ref_set ever changes\r\n(because it is mutated) and an operation is called on the iterator, the\r\niterator will be able to discover the modification (its expected_mod_count will\r\nbe wrong) and fail (as it is required to do) by throwing the\r\nCurrentModificationError exception.\r\n\r\nTo save space, we will use CME to abbreviate ConcurrentModificationError.\r\n\r\n\r\nTemplate<class T>\r\nArraySet<T>::Iterator::Iterator(ArraySet<T>* iterate_over, int initial)\r\n: current(initial), ref_set(iterate_over), expected_mod_count(ref_set->mod_count) {\r\n}\r\n\r\n\r\n(2) Iterator destructor: it allocates no dynamic storage with new, so it\r\ndeallocates none with delete.\r\n\r\ntemplate<class T>\r\nArraySet<T>::Iterator::~Iterator()\r\n{}\r\n\r\n\r\n(3) erase: erase from the ArraySet the value the iterator indexes. It must\r\nfirst check that the mod_count is unchanged and that can_erase is true\r\n(throwing special exceptions for either error); likewise, it also checks that\r\nthe iterator really refers to a legal position in ref_set's array. If so, it\r\ndoes the erase:\r\n\r\n  (a) setting can_erase to false means that we must call ++ on the iterator\r\n      before it can erase the next value (see ++ code for resetting can_erase),\r\n\r\n  (b) it saves the value it is removing to return,\r\n\r\n  (c) it calls the erase_at helper method using ref_set to erase the value at\r\n      the current index (note that erase_at changes ref_set's mod_count and\r\n      might even reallocate the set array to be smaller),\r\n\r\n  (d) it resets the expected_mod_count: when an iterator erases a value, that\r\n      iterator (but no others) can still correctly continue iterating through\r\n      the data structure; if multiple iterators are active on the data\r\n      structure, all the others will fail because their expected_mod_count will\r\n      remain the same and thus become incorrect,\r\n\r\n  (e) the removed value is returned\r\n\r\ntemplate<class T>\r\nT ArraySet<T>::Iterator::erase() {\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::erase\");\r\n  if (!can_erase)\r\n    throw CannotEraseError(\"ArraySet::Iterator::erase Iterator cursor already erased\");\r\n  if (current < 0 || current >= ref_set->used)\r\n    throw CannotEraseError(\"ArraySet::Iterator::erase Iterator cursor beyond data structure\");\r\n\r\n  can_erase = false;\r\n  T to_return = ref_set->set[current];\r\n  ref_set->erase_at(current);               //changes ref_set->mod_count\r\n  expected_mod_count = ref_set->mod_count;\r\n  return to_return;\r\n}\r\n\r\n\r\n(4) str: returns interesting information about the iterator's implementation:\r\nstarting with ref_set-->str(), it includes the values in the ArraySet it is\r\niterating over and the instance variables used in the ArraySet implementation;\r\nthese are followed by the instance variables of the iterator.\r\n\r\ntemplate<class T>\r\nstd::string ArraySet<T>::Iterator::str() const {\r\n  std::ostringstream answer;\r\n  answer << ref_set->str() << \"(current=\" << current << \",expected_mod_count=\" << expected_mod_count << \",can_erase=\" << can_erase << \")\";\r\n  return answer.str();\r\n}\r\n\r\n\r\n(5) prefix ++: advances the iterator so that it indexes the next value,\r\nreturning a REFERENCE to the NEW state of this iterator (the object ++ applies\r\nto). It checks for CME. The cursor is immediately returned (NOT incremented) if\r\nit is already ONE BEYOND the last index (>= used): that is the biggest it\r\nshould get. Otherwise, it is incremented if can_erase == true but NOT\r\nincremented if can_erase == false (because that means the previous value was\r\nerased, so current indexes the value it was replaced by, which is still the\r\nnext value to be iterated over); in this case it resets can_erase to true.\r\nFinally, it returns a reference to the newly incremented iterator object.\r\n\r\ntemplate<class T>\r\nauto ArraySet<T>::Iterator::operator& ++ () -> ArraySet<T>::Iterator {\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::operator ++\");\r\n\r\n  if (current >= ref_set->used)\r\n    return *this;\r\n\r\n  if (can_erase)\r\n    ++current;\r\n  else\r\n    can_erase = true;  //current already indexes \"one beyond\" deleted value\r\n\r\n  return *this;\r\n}\r\n\r\n\r\n(6) postfix ++: advances the iterator so that it indexes the next value,\r\nreturning the OLD state of this iterator. It checks for CME. The cursor is NOT\r\nincremented if it is already ONE BEYOND the last index (used): that is the\r\nbiggest it should get. Otherwise, it saves the previous current value of the\r\nIterator, so it can return it. As with the prefix ++ operator, both the current\r\nvalue and the current value in to_return are incremented if can_erase == true\r\nbut NEITHER is incremented if can_erase == false;  in this case it resets\r\ncan_erase to true. Finally, it returns the orginal iterator.\r\n\r\ntemplate<class T>\r\nauto ArraySet<T>::Iterator::operator ++ (int) -> ArraySet<T>::Iterator {\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::operator ++(int)\");\r\n\r\n  if (current >= ref_set->used)\r\n    return *this;\r\n\r\n  Iterator to_return(this->ref_set,current-1);\r\n\r\n  if (can_erase)\r\n    ++current;\r\n  else\r\n    can_erase = true;  //current already indexes \"one beyond\" deleted value\r\n\r\n  return to_return;\r\n}\r\n\r\nGenerally it is a bad idea to try to do anything with the value of the returned\r\nIterator (reference). It is best to increment iterators in statements, not\r\nusing their values: ++i; or i++;\r\n\r\nPrefer prefix ++ because it does not have to create an object to return; instead\r\nit just returns a reference to the iterator object that has been incremented,\r\nwhich saves time/space (sometimes a lot, for complicated implementations).\r\n\r\n\r\n(7) operator ==: determines whether two Iterators have the same values: they\r\nmust be the same type of Iterator (checked via dynamic_cast), the mod_count\r\nmust not have have changed, and the ref_set pointers must be the same too.\r\nFinally (and most importantly) they must index the same value (current).\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::Iterator::operator == (const ics::Iterator<T>& rhs) const {\r\n  const Iterator* rhsASI = dynamic_cast<const Iterator*>(&rhs);\r\n  if (rhsASI == 0)\r\n    throw IteratorTypeError(\"ArraySet::Iterator::operator ==\");\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::operator ==\");\r\n  if (ref_set != rhsASI->ref_set)\r\n    throw ComparingDifferentIteratorsError(\"ArraySet::Iterator::operator ==\");\r\n\r\n  return current == rhsASI->current;\r\n}\r\n\r\nI actually now think the dynamic_cast is unneccesary (it will always produce\r\nthe correct result) but I haven't thought it through deeply enough, nor tested\r\nit by trying to come up with counter examples. In a previous version of my\r\nlibraries, I used a more generic Iterator class that required this check. So\r\nmostly ignore this test even though it is still in the code.\r\n\r\n\r\n(8) operator !=: determines whether two Iteraors have different values: all\r\nthe early checks must be OK, but the last check is done oppositely.\r\n\r\ntemplate<class T>\r\nbool ArraySet<T>::Iterator::operator != (const ics::Iterator<T>& rhs) const {\r\n  const Iterator* rhsASI = dynamic_cast<const Iterator*>(&rhs);\r\n  if (rhsASI == 0)\r\n    throw IteratorTypeError(\"ArraySet::Iterator::operator !=\");\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::operator !=\");\r\n  if (ref_set != rhsASI->ref_set)\r\n    throw ComparingDifferentIteratorsError(\"ArraySet::Iterator::operator !=\");\r\n\r\n  return current != rhsASI->current;\r\n}\r\n\r\n\r\n(9) operator *: dereference (get the value the iterator indexes); checks for CME\r\nand checks that current has not been erased (cannot * an erased value until\r\nafter ++) and is legal [0,used); return the value at the index it refers to.\r\n\r\ntemplate<class T>\r\nT& ArraySet<T>::Iterator::operator *() const {\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::operator *\");\r\n  if (!can_erase || current < 0 || current >= ref_set->used) {\r\n    std::ostringstream where;\r\n    where << current << \" when size = \" << ref_set->size();\r\n    throw IteratorPositionIllegal(\"ArraySet::Iterator::operator * Iterator illegal: \"+where.str());\r\n  }\r\n\r\n  return ref_set->set[current];\r\n}\r\n\r\n\r\n(9) operator ->: dereference and select local instance/method (using the value\r\nthe iterator indexes); checks for CME and checks that current has not been\r\nerased (cannot -> an erased value until after ++) and is legal [0,used); return\r\na pointer to the value at the index it refers to.\r\n\r\nNote that for an iterator i, (*i).foo is equivalent to i->foo.\r\n\r\ntemplate<class T>\r\nT* ArraySet<T>::Iterator::operator ->() const {\r\n  if (expected_mod_count != ref_set->mod_count)\r\n    throw ConcurrentModificationError(\"ArraySet::Iterator::operator ->\");\r\n\r\n  if (!can_erase || current < 0 || current >= ref_set->used) {\r\n    std::ostringstream where;\r\n    where << current << \" when size = \" << ref_set->size();\r\n    throw IteratorPositionIllegal(\"ArraySet::Iterator::operator -> Iterator illegal: \"+where.str());\r\n  }\r\n\r\n  return &ref_set->set[current];\r\n}\r\n\r\n\r\nIt would be instructive to hand simulate the following code as a program; or\r\nexecute its equivalent in the set_driver using the regular menu and then the\r\n\"it\" submenu; or even execute the code in a project. It produces the results\r\n\r\n----------\r\na\r\ne\r\nd\r\nb\r\nc\r\nset[d,c] \r\n----------\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include \"array_set.hpp\"\r\n\r\n\r\nint main() {\r\n  try {\r\n\r\n    //Example: simple iterator test for Sets\r\n\r\n    ics::ArraySet<std::string> s({std::string(\"a\"), std::string(\"b\"), std::string(\"c\"), std::string(\"d\"), std::string(\"e\")});\r\n\r\n    ics::ArraySet<std::string>::Iterator i = s.begin();\r\n    std::cout << *i << std::endl;\r\n    i.erase();\r\n    ++i;\r\n    std::cout << *i << std::endl;\r\n    i.erase();\r\n    ++i;\r\n    std::cout << *i << std::endl;\r\n    ++i;\r\n    std::cout << *i << std::endl;\r\n    i.erase();\r\n    ++i;\r\n    std::cout << *i << std::endl;\r\n\r\n    std::cout << s << std::endl;\r\n  } catch (ics::IcsError& e) {\r\n    std::cout << e.what() << std::endl;\r\n  }\r\n\r\n  return 0;\r\n} \r\n\r\nYou might also want to remove some the ++i; code to see what exceptions are\r\nthrown. Also you can std::cout << i << std::endl; to see debugging information\r\nabout the iterator i.\r\n\r\nSome guidelines for thinking about and writing iterators.\r\n\r\n1) An iterator's cursor will either be legal or one beyond legal. When it is\r\n   initialized, it may be either (depending on whether or not the data\r\n   structure contains any values), and can_erase starts as true.\r\n\r\n   The cursor indicates the current value that would be (a) returned by the *\r\n   operator or (b) erased by the .erase() method call.\r\n\r\n   Note that in both forms of ++ we test for a legal/one beyond legal cursor\r\n   first, immediately returning the current iterator if it is already one\r\n   beyond. Only if it is legal, do we compute what to return.\r\n\r\n2) When .erase() is called on an iterator with (a) can_erase false or (b) a\r\n   cursor one beyond legal (see previous paragraph), it cannot erase anything\r\n   and raises an exception; it also doesn't advance the cursor.\r\n\r\n   When .erase() is called on an iterator with (a) can_erase true and (b) a\r\n   a legal cursor, not only is the cursor's value removed from the data\r\n   structure, but the cursor is advanced to the next value (which may legal or\r\n   one beyond legal), and can_erase is set to false: at this point .erase()\r\n   cannot be called until some form of ++ is called (see below), which won't\r\n   actually advance the cursor the next time it is called, because it has been\r\n   advanced here.\r\n\r\n   In this implementation, the cursor's value stays the same after erase, but a\r\n   new Set value (the one at the end of the array) is placed in the array at\r\n   this index; we must execute a ++ (which does nothing in this case) to\r\n   \"advance\" to this value.\r\n\r\n3) When either form (prefix or postfix) of ++ is called on an iterator, it\r\n   either advances the cursor or leaves it at its current value (depending on\r\n   what operation -erase or ++- was called previously, and in both cases, \r\n   can_erase is/becomes true).\r\n\r\n   If the currsor is one beyond legal, the cursor does not advance and is\r\n   returned; can_erase remains unchanged.\r\n   \r\n   If can_erase == false (meaning the previous cursor was erased and the\r\n   cursor already indexes the correct value), it does not advance but just\r\n   resets can_erase to true: otherwise the cursor is advanced/incremented.\r\n\r\n4) Any change to a data structure via .erase() using an iterator disallows any\r\n   cursor operations on any other iterator, because mod_count increases.\r\n\r\n-------------------------\r\n\r\nFinal Words\r\n\r\nPrefer for-each to explicit iteration: the code is more compact. If writing\r\nexplicit iterators, prefer prefix to postfix incrementation (++i to i++). The\r\nfollowing two code fragments are equivalent only when there are no calls to\r\ni.erase() in the body of the loop\r\n\r\n  for (ArraySet<...>::Iterator i = c.begin(); i != c.end(); ++i)\r\n    ...\r\n\r\nThe one belows caches the value of c.end()\r\n\r\n  ArraySet<...>::Iterator end = c.end();\r\n  for (ArraySet<...>::Iterator i = c.begin(); i != end; ++i)\r\n    ...\r\n\r\nwhich can change if i.erase() is called; so do not use this form if you are\r\ncalling i.erase().\r\n\r\nWe have now taken the complete tour through the .hpp file storing the ArraySet\r\nimplementation of Set. Feel free to examine any/all of the array implementations\r\nof the four other data types. Each will have some unique code, but there will\r\nalso be much similar code as well.\r\n\r\nArrayStack is very simple.\r\n\r\nArrayQueue is implemented using the array as a circular structure: improving\r\nits performance (dequeque is O(1)) but making all the code more complicated to\r\nunderstand. The code in LinearArrayQueue, from Programming Assignment #0, is\r\nsimpler to understand but is slower: e.g., dequeue is O(N), because it shifts\r\nto the left by one index all values that remain in the Queue.\r\n\r\nArrayPriorityQueue is simple, except it introduces/uses the concept of a\r\nfunction pointer: a pointer to a function that computes whether a > b for\r\nthe prioritization. This function pointer can be supplied as an argument to the\r\ntemplate or a constructor.\r\n\r\nArrayMap is simple, except it introduces/uses the pair class, which itself is\r\nvery simple, to associate keys with their values in each location of the array.\r\n\r\nIn Programming Assignment #2 you will write linked list implementations of\r\nvarious templated classes: each will implement its data type by using a simple\r\nlinear linked list or a variant. Much of the code will mirror what is written\r\nhere (converting array access to linked list accesses). Especially interesting\r\nis the code relating to Iterators (where hints will be given).\r\n", "encoding": "ascii"}