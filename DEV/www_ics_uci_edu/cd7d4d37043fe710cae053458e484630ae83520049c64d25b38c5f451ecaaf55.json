{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990406.txt", "content": "WebDAV Advanced Collections: April 6, 1999\n\nAttending: Judy Slein, Jim Davis, Geoff Clemm, Jim Whitehead\n\nACTION ITEMS\n\nJim Whitehead: Draft semantics of bindings.\nGeoff: Draft semantics of fixup operation on MOVE.\nJudy: Mail to Max Rible asking for scenario justifying support for server-maintained \norderings.\nJim Whitehead: Check on whether we can use a 506 response code for loops.\n\nWHAT ARE DIRECT REFERENCES?\n\nGeoff\u2019s proposal was that they be URLs stored in a DAV:internalmembers property on \ncollections.  Geoff is willing to drop this proposal if no one wants to pursue it.\n\nJim W wants to explore it.  Something like a symbolic link.  Separate the issues of what \nthey direct references are and whether to store them on the collection.  Problems about \nLOCK if addressed to a direct reference, does that lock the collection also?\n \nGeoff: It locks the target, and the server is responsible for making sure the URL stays \nbound to that resource.\n\nJim W: MOVE and DELETE operations get passed through to the target.\n\nGeoff:  No, we define an advanced collections delete that is a modification to the \ncollection, not a modification to the member - redefine delete to be unbind.  The same for \nmove.  Copy does affect the resource itself (same whether it\u2019s a reference or not).\n\nJim D: If you copy a collection that contains a direct reference, then what? Geoff: Just \ncopy the reference.  Jim D: That\u2019s unintuitive.\n  \nJim D: Geoff\u2019s proposal doesn\u2019t do anything to resolve the hard problems.  We still have \nto appeal to other arguments to resolve them.  The user of the protocol can\u2019t tell what \nreferences are.\n\nGeoff:  they can tell because some methods behave differently when applied to references \nthan to resources, some methods can\u2019t be applied to references.\n\nJim D: If Geoff\u2019s proposal offered a radical simplification, it would be worth pursuing.  \nBut it doesn\u2019t.   It will lead to other complicated discussions about what a binding is.  It \ndoesn\u2019t let us say in any principled way why methods work the way they do.\n  \nJim W: There is no compelling reason for one way or the other.  We can have state as a \nresource or state on a collection.  We can have things that act sort of like symbolic links \n(direct references as we\u2019ve described them up till now), or things that act sort of like hard \nlinks. The Web is different from a file system - open / GET differs from the Unix file \nsystem.  In Unix, open can\u2019t give a redirect response.  Redirect is a new thing.  We are \nrediscovering rationale for both hard and symbolic links.  Define semantics of something \nlike hard links.  It doesn\u2019t have to be in a collection.  But allow our version of hard links \npoint to a directory.  A hard link points to an underlying resource, and allows multiple \nURLs to be bound to a resource in such a way that MOVE doesn\u2019t affect any other \nbindings.  Hard links provide localized reliable binding. MOVE just changes the entry \nand doesn\u2019t affect any other binding.\n\nJim D: It\u2019s a bad idea to define references based on the Unix file system.\n\nGeoff: We won\u2019t do that.  What we care about is the underlying notion that multiple \ncollections can have members bound to the same resource.\n\nJim D: Don\u2019t use the terms hard / soft links.  Talk independently of Unix.  There are also \n2 other semantics to consider Document Management Systems, and existing web servers \n(Apache).  Original motivation: in current web servers there are analogs of direct and \nredirect reference, but you could only create them out of band.\n\nGeoff: The motivation for references is to provide the ability to reliably share a resource.  \nWhen you change it, anyone using any reference to it will see the change.\n\nJim D: Both direct and redirect references have that property.\n\nWhat is the desired semantics when you MOVE the target of a resource?  The spec today \nallows, but does not require, that the reftarget properties of references to it get fixed up.\n\nJim D: Just fix the gap in the protocol - when you MOVE a resource, the DAV:reftarget \nproperties of all references to it  MUST get updated to point to new location.\n\nGeoff: No, we need both semantics.  There are cases where we don\u2019t want fixup to \nhappen (direct references), and cases where we do (bindings).\n  \nJim W: What are the 2 scenarios?\n\nGeoff: Activities and configurations should be unaffected by any moves or deletes to the \nsame resources, but in other situations we do want resources to appear and disappear \nwhen they are deleted or moved from another place.\n\nJim D: If you want the reference to be left dangling, do COPY + DELETE.\n\nJim W: There are many possible policies, and it\u2019s not clear which should be mandated.  \nExisting systems may have one or another policy.  So we stay neutral.  Some people want \nto create dangling references from the moment of creation.\n  \nWe can get both semantics using MKREF with new headers.  You can discover which \nsemantics a reference has by examining DAV:refintegrity.  Yes, on Geoff\u2019s proposal that \ninformation would just be stored on a collection rather than on a resource.\n \nJim W: Let direct references be bindings because when a user creates a direct reference, \nhe is trying to create a location in a namespace that is as much as possible like the target.  \nThe best you can do is make it just another URL.  MOVE has down-level DAV semantics.\n\nIf you create a binding, you pass in URL r and URL t for resource x.  The server has an \ninternal id for x, and binds r to that internal resource id.  If someone does a MOVE \nthrough t, the server creates a resource with internal id y and binds t to it, and deletes x.  \nIt is gray in WebDAV what happens to r.  There are two possible answers - fix up r to \npoint to y, or let r to x binding disappear.\n\nJim D: This is the same as the existing MKREF.\n\nJim W: There is no way to distinguish r from any other URL.  There\u2019s only one resource.  \nAll semantics are down-level semantics.  They are indistinguishable to down-level \nclients.\n\nJim D: The rationale won\u2019t be any more satisfactory than it is currently.  From user\u2019s point \nof view, he says copy r and finds that target got copied.  That\u2019s the opposite of the IETF \nconsensus.\n\nJim W: At IETF, people were thinking in terms of the ontology where references are \nresources.  If we present a different ontology, people\u2019s intuitions may change. \n\nGeoff: Ideally, we would give up the WebDAV definition of MOVE.  MOVE is a rename. \n \nJim W: Once you have the notion of a binding, move is a change in one end of the \nrelationship, copy adds a new binding.  But it\u2019s troublesome to redefine move / copy.  We \ncould create new move / copy methods.  Don\u2019t do that.  People will accuse us of feature \ncreep.  Geoff - No, don\u2019t have new move / copy.  Just explain the fixup stage - adjusting \nthe bindings.\n  \nJim W: Here\u2019s a problem with the binding approach, though: If we replace direct \nreferences with bindings, we lose relative references.  A binding is an absolute URL \nbound to a resource.\n\nJim D: If you move a collection, things will break.\n\nGeoff: If relative URLs point downward in the hierarchy, that\u2019s ok.  It\u2019s a problem if they \ngo up and out.\n\nJim D: No, once the binding is complete, it would continue to point to the original target.\n\nJim W: Suppose URL t is created with PUT, and the internal resource id is x.  Later \nsomeone creates a new binding r, to t.  Now someone moves collection c that contains t - \nthen the server has to do fixup semantics.  If you do a depth copy of collection c to new \nURL d, a new resource with id y gets created - what should fixup do?\n\nGeoff : You avoid fixup if c/ is a binding to collection rc, and t is bound to x.  When you \nmove c to d, you just change the binding from c to rc to be d to rc.  Then all members \nstay the same.\n\nJim D: But what if I wanted my references to become dangling?\n\nGeoff: We need 2 kinds of references.  We still need references that aren\u2019t bindings, they \nrefer to URLs.\n\nBindings are direct by definition.  \n\nJim W: If you do a copy and that just changes the binding, that\u2019s not the semantics that \nare in rfc 2518.  Geoff: The fixup stage is intended to produce this.\n\nGeoff: We need both kinds of members, so we define a new operation called BIND different \nfrom move or copy.\n\nJim D: We could just put headers on MKREF.\n\nFixup is different depending on whether you have a reference or a binding - we need two well-\ndefined semantics - mkref and bind, or distinguish between the semantics with a header\n\nJim D: There\u2019s a requirement that references be able to carry properties.  What do we say \nto people who care about that requirement?\n\nJim W: We can just say that trying to meet that goal led to a protocol with undesirable \ncharacteristics.\n\nGeoff: In versioning, the only properties it was tempting to put on references were \ntransitory and interesting only for the server.\n  \nSomeone needs to write down the proposed semantics in detail.\n  \nJudy, Jim D: Separate the issue of treating references as bindings from the issue of \nincorporating them in a property of collections.\n\nNeed implementations to see whether there are problems with one approach or the other. \n \nUnstated requirement: Must DAV map to file system semantics?  A mapping to file \nsystem semantics can be a goal, but don\u2019t constrain the protocol to be the least common \ndenominator of file systems. Jim W: Web servers that map onto file systems (Apache) \nmust have some module that does URL to file mapping.  There must be a table or algorithm \nthere, just add a new table entry, and have MOVE and COPY operate on the table - this \nshouldn\u2019t be hard.  Jim D thinks this is not an easy implementation.\n\nLet\u2019s see the semantics first.  Jim W will write definition of a BIND method.  Geoff will \nwrite a description of the fixup step operation.\n\nGeoff: We need 3 tpyes of references - bindings (associate a url with a resource), \nreferential members (associate a url with a url), redirect members\n\nDrop direct references? Bindings don\u2019t give relative references capability. \n\nSemantics will include an example where operation on binding differs from operation on \nreferences.\n\nJim D: Drop direct references - this is getting too complex.\n\nSEPARATE SPEC FOR ORDERING\n\nJim D: Is there any advantage in separating ordered collections and publishing that spec \nnow?  It seems stable, whereas referencing is not.\n\nJim W: Keep them together.  There are already 4 RFCs planned for WebDAV capabilities, plus \nDASL.  Options are getting too complicated.  Is there any benefit to getting ordered \ncollections out sooner?  There is more interest in references than in ordering.  If we keep \nthem together, we might get more people to implement ordering because they want \nreferencing.  But the spec has separate compliance classes for ordering and referencing \nbecause they are orthogonal.  We could query the group.  Web folders alphabetize the \ncontents of collections, so they are imposing their own ordering on the client side.\n\nSERVER-MAINTAINED ORDERINGS\n\nServer-maintained orderings: Jim D: Why would you want this?  Jim W: A server-maintained \nalphabetical ordering makes sense. Jim D: From the standpoint of the protocol, \nserver-maintained is unordered.  We have made it possible. Current spec says a request fails\nif it has a Position header on an unordered collection.  Jim W believes that Max only wants\nus to say that server-maintained orderings may exist, and say how operations act against \nserver-maintained orderings.  We don't want to get into issues about registering server-\nmaintained orderings. Jim D does not want to let client select from a list of available \nserver-maintained orderings - he sees no use case for this, and it's expensive to implement.\nIt\u2019s one thing for the server to declare how it will order, another for client to be able to\nrequest a particular server-maintained ordering.  Jim D doesn\u2019t see use case even for that.\nMax is implementing a server.  Ask him for use case - advertise an ordering that it will use\nvs. let client choose.\n  \nJudy: will send note to Max asking for a compelling use case and whether Max intends to \nimplement something like this if we make it possible.\n\nDO WE NEED BOTH DIRECT AND REDIRECT REFERENCES? \n\nIf clients are intelligent enough to use redirect, then perform all future operations on \nthe target isn\u2019t that more efficient than direct references?  Yes, if the client does that.\nThere's a one-time loss, then use the target\u2019s URL.  But that's incorrect use of 302.  \nSuppose we use 301 instead.  There's a one-time cost, then the client operates on the target.\nGets rid of complexity.  (Geoff: We do not want the client to assume the location of the\ntarget won\u2019t change.  We want 302 semantics, where we force the client to continue to use \nthe reflector.  If we also want a permanent redirect, it's ok to have that as well.)  \n\nFrom a document management perspective, we need direct references.  We need to hide the \ntarget, need redirection to be done server-side.  Flat namespace and faking the hierarchy.  \nWe\u2019ll assess this case against bindings semantics.\n\nGeoff is willing to deal with relative references later.\n\nLOOP DETECTION\n\nShould we require servers to detect loops? If the server is providing a chunked response, \nit might never discover a loop.  It might never abort.  Let's say SHOULD.  Jim W: if we\nthink there's enough justification for SHOULD, then let's say MUST. We should always start\nat MUST, and only back down to SHOULD if we know of some case where a stronger requirement \nwould be a problem.  We know it's easy to implement loop detection.  Say MUST, and see if the\ncommunity objects.  Decision: MUST.\n\nJim W: Will ask Roy about using a 506 response for this case.\n", "encoding": "Windows-1252"}