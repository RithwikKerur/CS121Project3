{"url": "https://www.ics.uci.edu/~ardalan/courses/os/pintos/pintos_4.html#SEC52", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n                      \"http://www.w3.org/TR/html40/loose.dtd\">\n<HTML>\n<!-- Created on September, 4 2018 by texi2html 1.66 -->\n<!--\nWritten by: Lionel Cons <Lionel.Cons@cern.ch> (original author)\n            Karl Berry  <karl@freefriends.org>\n            Olaf Bachmann <obachman@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Many creative people <dev@texi2html.cvshome.org>\nSend bugs and suggestions to <users@texi2html.cvshome.org>\n\n-->\n<HEAD>\n<TITLE>Pintos Projects: Project 2--User Programs</TITLE>\n\n<META NAME=\"description\" CONTENT=\"Pintos Projects: Project 2--User Programs\">\n<META NAME=\"keywords\" CONTENT=\"Pintos Projects: Project 2--User Programs\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"texi2html 1.66\">\n<LINK REL=\"stylesheet\" HREF=\"pintos.css\">\n</HEAD>\n\n<BODY >\n\n<A NAME=\"SEC42\"></A>\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_3.html#SEC25\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_5.html#SEC63\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n\n<HR SIZE=2>\n<H1> 4. Project 2: User Programs </H1>\n<!--docid::SEC42::-->\n<P>\n\nNow that you've worked with Pintos and are becoming familiar with its\ninfrastructure and thread package, it's time to start working on the\nparts of the system that allow running user programs.\nThe base code already supports loading and\nrunning user programs, but no I/O or interactivity\nis possible.  In this project, you will enable programs to interact with\nthe OS via system calls.\n</P>\n<P>\n\nYou will be working out of the <Q><TT>userprog</TT></Q> directory for this\nassignment, but you will also be interacting with almost every\nother part of Pintos.  We will describe the\nrelevant parts below.\n</P>\n<P>\n\nYou can build project 2 on top of your project 1 submission or you can\nstart fresh.  No code from project 1 is required for this\nassignment.  The &quot;alarm clock&quot; functionality may be useful in\nprojects 3 and 4, but it is not strictly required.\n</P>\n<P>\n\nYou might find it useful to go back and reread how to run the tests\n(see section <A HREF=\"pintos_1.html#SEC8\">1.2.1 Testing</A>).\n</P>\n<P>\n\n<A NAME=\"Project 2 Background\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC43\"></A>\n<H2> 4.1 Background </H2>\n<!--docid::SEC43::-->\n<P>\n\nUp to now, all of the code you have run under Pintos has been part\nof the operating system kernel.  This means, for example, that all the\ntest code from the last assignment ran as part of the kernel, with\nfull access to privileged parts of the system.  Once we start running\nuser programs on top of the operating system, this is no longer true.\nThis project deals with the consequences.\n</P>\n<P>\n\nWe allow more than one process to run at a time.  Each process has one\nthread (multithreaded processes are not supported).  User programs are\nwritten under the illusion that they have the entire machine.  This\nmeans that when you load and run multiple processes at a time, you must\nmanage memory, scheduling, and other state correctly to maintain this\nillusion.\n</P>\n<P>\n\nIn the previous project, we compiled our test code directly into your\nkernel, so we had to require certain specific function interfaces within\nthe kernel.  From now on, we will test your operating system by running\nuser programs.  This gives you much greater freedom.  You must make sure\nthat the user program interface meets the specifications described here,\nbut given that constraint you are free to restructure or rewrite kernel\ncode however you wish.\n</P>\n<P>\n\n<A NAME=\"Project 2 Source Files\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC44\"></A>\n<H3> 4.1.1 Source Files </H3>\n<!--docid::SEC44::-->\n<P>\n\nThe easiest way to get an overview of the programming you will be\ndoing is to simply go over each part you'll be working with.  In\n<Q><TT>userprog</TT></Q>, you'll find a small number of files, but here is\nwhere the bulk of your work will be:\n</P>\n<P>\n\n</P>\n<DL COMPACT>\n<DT><Q><TT>process.c</TT></Q>\n<DD><DT><Q><TT>process.h</TT></Q>\n<DD>Loads ELF binaries and starts processes.\n<P>\n\n</P>\n<DT><Q><TT>pagedir.c</TT></Q>\n<DD><DT><Q><TT>pagedir.h</TT></Q>\n<DD>A simple manager for 80<VAR>x</VAR>86 hardware page tables.\nAlthough you probably won't want to modify this code for this project,\nyou may want to call some of its functions.\nSee section <A HREF=\"pintos_5.html#SEC69\">5.1.2.3 Page Tables</A>, for more information.\n<P>\n\n</P>\n<DT><Q><TT>syscall.c</TT></Q>\n<DD><DT><Q><TT>syscall.h</TT></Q>\n<DD>Whenever a user process wants to access some kernel functionality, it\ninvokes a system call.  This is a skeleton system call\nhandler.  Currently, it just prints a message and terminates the user\nprocess.  In part 2 of this project you will add code to do everything\nelse needed by system calls.\n<P>\n\n</P>\n<DT><Q><TT>exception.c</TT></Q>\n<DD><DT><Q><TT>exception.h</TT></Q>\n<DD>When a user process performs a privileged or prohibited operation, it\ntraps into the kernel as an &quot;exception&quot; or &quot;fault.&quot;<A NAME=\"DOCF2\" HREF=\"pintos_fot.html#FOOT2\">(2)</A>  These files handle\nexceptions.  Currently all exceptions simply print a message and\nterminate the process.  Some, but not all, solutions to project 2\nrequire modifying <CODE>page_fault()</CODE> in this file.\n<P>\n\n</P>\n<DT><Q><TT>gdt.c</TT></Q>\n<DD><DT><Q><TT>gdt.h</TT></Q>\n<DD>The 80<VAR>x</VAR>86 is a segmented architecture.  The Global Descriptor\nTable (GDT) is a table that describes the segments in use.  These\nfiles set up the GDT.  You should not need to modify these\nfiles for any of the projects.  You can read the code if\nyou're interested in how the GDT works.\n<P>\n\n</P>\n<DT><Q><TT>tss.c</TT></Q>\n<DD><DT><Q><TT>tss.h</TT></Q>\n<DD>The Task-State Segment (TSS) is used for 80<VAR>x</VAR>86 architectural\ntask switching.  Pintos uses the TSS only for switching stacks when a\nuser process enters an interrupt handler, as does Linux.  You\nshould not need to modify these files for any of the projects.\nYou can read the code if you're interested in how the TSS\nworks.\n</DL>\n<P>\n\n<A NAME=\"Using the File System\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC45\"></A>\n<H3> 4.1.2 Using the File System </H3>\n<!--docid::SEC45::-->\n<P>\n\nYou will need to interface to the file system code for this project,\nbecause\nuser programs are loaded from the file system and many of the\nsystem calls you must implement deal with the file system.  However,\nthe focus of this project is not the file system, so we have\nprovided a simple but complete file system in the <Q><TT>filesys</TT></Q>\ndirectory.  You\nwill want to look over the <Q><TT>filesys.h</TT></Q> and <Q><TT>file.h</TT></Q>\ninterfaces to understand how to use the file system, and especially\nits many limitations.\n</P>\n<P>\n\nThere is no need to modify the file system code for this project, and so\nwe recommend that you do not.  Working on the file system is likely to\ndistract you from this project's focus.\n</P>\n<P>\n\nProper use of the file system routines now\nwill make life much easier for project 4, when you improve the file\nsystem implementation.  Until then, you will have to tolerate the\nfollowing limitations:\n</P>\n<P>\n\n<UL>\n<LI>\nNo internal synchronization.  Concurrent accesses will interfere with one\nanother.  You should use synchronization to ensure that only one process at a\ntime is executing file system code.\n<P>\n\n</P>\n<LI>\nFile size is fixed at creation time.  The root directory is\nrepresented as a file, so the number of files that may be created is also\nlimited.\n<P>\n\n</P>\n<LI>\nFile data is allocated as a single extent, that is, data in a single\nfile must occupy a contiguous range of sectors on disk.  External\nfragmentation can therefore become a serious problem as a file system is\nused over time.\n<P>\n\n</P>\n<LI>\nNo subdirectories.\n<P>\n\n</P>\n<LI>\nFile names are limited to 14 characters.\n<P>\n\n</P>\n<LI>\nA system crash mid-operation may corrupt the disk in a way\nthat cannot be repaired automatically.  There is no file system repair\ntool anyway.\n</UL>\n<P>\n\nOne important feature is included:\n</P>\n<P>\n\n<UL>\n<LI>\nUnix-like semantics for <CODE>filesys_remove()</CODE> are implemented.\nThat is, if a file is open when it is removed, its blocks\nare not deallocated and it may still be accessed by any\nthreads that have it open, until the last one closes it.  See  <A HREF=\"pintos_4.html#Removing an Open File\">Removing an Open File</A>, for more information.\n</UL>\n<P>\n\nYou need to be able to create a simulated disk with a file system\npartition.  The <CODE>pintos-mkdisk</CODE> program provides this\nfunctionality.  From the <Q><TT>userprog/build</TT></Q> directory, execute\n<CODE>pintos-mkdisk filesys.dsk --filesys-size=2</CODE>.  This command\ncreates a simulated disk named <Q><TT>filesys.dsk</TT></Q> that contains a 2\nMB Pintos file system partition.  Then format the file system\npartition by passing <Q><SAMP>-f -q</SAMP></Q> on the kernel's command line:\n<CODE>pintos -f -q</CODE>.  The <Q><SAMP>-f</SAMP></Q> option causes the file system to\nbe formatted, and <Q><SAMP>-q</SAMP></Q> causes Pintos to exit as soon as the\nformat is done.\n</P>\n<P>\n\nYou'll need a way to copy files in and out of the simulated file system.\nThe <CODE>pintos</CODE> <Q><SAMP>-p</SAMP></Q> (&quot;put&quot;) and <Q><SAMP>-g</SAMP></Q> (&quot;get&quot;)\noptions do this.  To copy <Q><TT><VAR>file</VAR></TT></Q> into the\nPintos file system, use the command <Q><TT>pintos -p <VAR>file</VAR> -- -q</TT></Q>.\n(The <Q><SAMP>--</SAMP></Q> is needed because <Q><SAMP>-p</SAMP></Q> is for the <CODE>pintos</CODE>\nscript, not for the simulated kernel.)  To copy it to the Pintos file\nsystem under the name <Q><TT><VAR>newname</VAR></TT></Q>, add <Q><SAMP>-a\n<VAR>newname</VAR></SAMP></Q>: <Q><TT>pintos -p <VAR>file</VAR> -a <VAR>newname</VAR> -- -q</TT></Q>.  The\ncommands for copying files out of a VM are similar, but substitute\n<Q><SAMP>-g</SAMP></Q> for <Q><SAMP>-p</SAMP></Q>.\n</P>\n<P>\n\nIncidentally, these commands work by passing special commands\n<CODE>extract</CODE> and <CODE>append</CODE> on the kernel's command line and copying\nto and from a special simulated &quot;scratch&quot; partition.  If you're very\ncurious, you can look at the <CODE>pintos</CODE> script as well as\n<Q><TT>filesys/fsutil.c</TT></Q> to learn the implementation details.\n</P>\n<P>\n\nHere's a summary of how to create a disk with a file system partition,\nformat the file system, copy the <CODE>echo</CODE> program into the new\ndisk, and then run <CODE>echo</CODE>, passing argument <CODE>x</CODE>.\n(Argument passing won't work until you implemented it.)  It assumes\nthat you've already built the examples in <Q><TT>examples</TT></Q> and that the\ncurrent directory is <Q><TT>userprog/build</TT></Q>:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>pintos-mkdisk filesys.dsk --filesys-size=2\npintos -f -q\npintos -p ../../examples/echo -a echo -- -q\npintos -q run 'echo x'\n</pre></td></tr></table><P>\n\nThe three final steps can actually be combined into a single command:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>pintos-mkdisk filesys.dsk --filesys-size=2\npintos -p ../../examples/echo -a echo -- -f -q run 'echo x'\n</pre></td></tr></table><P>\n\nIf you don't want to keep the file system disk around for later use or\ninspection, you can even combine all four steps into a single command.\nThe <CODE>--filesys-size=<VAR>n</VAR></CODE> option creates a temporary file\nsystem partition\napproximately <VAR>n</VAR> megabytes in size just for the duration of the\n<CODE>pintos</CODE> run.  The Pintos automatic test suite makes extensive\nuse of this syntax:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>pintos --filesys-size=2 -p ../../examples/echo -a echo -- -f -q run 'echo x'\n</pre></td></tr></table><P>\n\nYou can delete a file from the Pintos file system using the <CODE>rm\n<VAR>file</VAR></CODE> kernel action, e.g. <CODE>pintos -q rm <VAR>file</VAR></CODE>.  Also,\n<CODE>ls</CODE> lists the files in the file system and <CODE>cat\n<VAR>file</VAR></CODE> prints a file's contents to the display.\n</P>\n<P>\n\n<A NAME=\"How User Programs Work\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC46\"></A>\n<H3> 4.1.3 How User Programs Work </H3>\n<!--docid::SEC46::-->\n<P>\n\nPintos can run normal C programs, as long as they fit into memory and use\nonly the system calls you implement.  Notably, <CODE>malloc()</CODE> cannot be\nimplemented because none of the system calls required for this project\nallow for memory allocation.  Pintos also can't run programs that use\nfloating point operations, since the kernel doesn't save and restore the\nprocessor's floating-point unit when switching threads.\n</P>\n<P>\n\nThe <Q><TT>src/examples</TT></Q> directory contains a few sample user\nprograms.  The <Q><TT>Makefile</TT></Q> in this directory\ncompiles the provided examples, and you can edit it to\ncompile your own programs as well.  Some of the example programs will\nonly work once projects 3 or 4 have been implemented.\n</P>\n<P>\n\nPintos can load <EM>ELF</EM> executables with the loader provided for you\nin <Q><TT>userprog/process.c</TT></Q>.  ELF is a file format used by Linux,\nSolaris, and many other operating systems for object files,\nshared libraries, and executables.  You can actually use any compiler\nand linker that output 80<VAR>x</VAR>86 ELF executables to produce programs\nfor Pintos.  (We've provided compilers and linkers that should do just\nfine.)\n</P>\n<P>\n\nYou should realize immediately that, until you copy a\ntest program to the simulated file system, Pintos will be unable to do\nuseful work.  You won't be able to do\ninteresting things until you copy a variety of programs to the file system.\nYou might want to create a clean reference file system disk and copy that\nover whenever you trash your <Q><TT>filesys.dsk</TT></Q> beyond a useful state,\nwhich may happen occasionally while debugging.\n</P>\n<P>\n\n<A NAME=\"Virtual Memory Layout\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC47\"></A>\n<H3> 4.1.4 Virtual Memory Layout </H3>\n<!--docid::SEC47::-->\n<P>\n\nVirtual memory in Pintos is divided into two regions: user virtual\nmemory and kernel virtual memory.  User virtual memory ranges from\nvirtual address 0 up to <CODE>PHYS_BASE</CODE>, which is defined in\n<Q><TT>threads/vaddr.h</TT></Q> and defaults to <TT>0xc0000000</TT> (3 GB).  Kernel\nvirtual memory occupies the rest of the virtual address space, from\n<CODE>PHYS_BASE</CODE> up to 4 GB.\n</P>\n<P>\n\nUser virtual memory is per-process.\nWhen the kernel switches from one process to another, it\nalso switches user virtual address spaces by changing the processor's\npage directory base register (see <CODE>pagedir_activate()</CODE> in\n<Q><TT>userprog/pagedir.c</TT></Q>).  <CODE>struct thread</CODE> contains a pointer to a\nprocess's page table.\n</P>\n<P>\n\nKernel virtual memory is global.  It is always mapped the same way,\nregardless of what user process or kernel thread is running.  In\nPintos, kernel virtual memory is mapped one-to-one to physical\nmemory, starting at <CODE>PHYS_BASE</CODE>.  That is, virtual address\n<CODE>PHYS_BASE</CODE> accesses physical\naddress 0, virtual address <CODE>PHYS_BASE</CODE> + <TT>0x1234</TT> accesses\nphysical address <TT>0x1234</TT>, and so on up to the size of the machine's\nphysical memory.\n</P>\n<P>\n\nA user program can only access its own user virtual memory.  An attempt to\naccess kernel virtual memory causes a page fault, handled by\n<CODE>page_fault()</CODE> in <Q><TT>userprog/exception.c</TT></Q>, and the process\nwill be terminated.  Kernel threads can access both kernel virtual\nmemory and, if a user process is running, the user virtual memory of\nthe running process.  However, even in the kernel, an attempt to\naccess memory at an unmapped user virtual address\nwill cause a page fault.\n</P>\n<P>\n\n<A NAME=\"Typical Memory Layout\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC48\"></A>\n<H4> 4.1.4.1 Typical Memory Layout </H4>\n<!--docid::SEC48::-->\n<P>\n\nConceptually, each process is\nfree to lay out its own user virtual memory however it\nchooses.  In practice, user virtual memory is laid out like this:\n</P>\n<P>\n\n<CENTER>\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>   PHYS_BASE +----------------------------------+\n             |            user stack            |\n             |                 |                |\n             |                 |                |\n             |                 V                |\n             |          grows downward          |\n             |                                  |\n             |                                  |\n             |                                  |\n             |                                  |\n             |           grows upward           |\n             |                 ^                |\n             |                 |                |\n             |                 |                |\n             +----------------------------------+\n             | uninitialized data segment (BSS) |\n             +----------------------------------+\n             |     initialized data segment     |\n             +----------------------------------+\n             |           code segment           |\n  0x08048000 +----------------------------------+\n             |                                  |\n             |                                  |\n             |                                  |\n             |                                  |\n             |                                  |\n           0 +----------------------------------+\n</pre></td></tr></table></CENTER>\n<P>\n\nIn this project, the user stack is fixed in size, but in project 3 it\nwill be allowed to grow.  Traditionally, the size of the uninitialized\ndata segment can be adjusted with a system call, but you will not have\nto implement this.\n</P>\n<P>\n\nThe code segment in Pintos starts at user virtual address\n<TT>0x08048000</TT>, approximately 128 MB from the bottom of the address\nspace.  This value is specified in [ <A HREF=\"pintos_14.html#SysV-i386\">SysV-i386</A>] and has no deep\nsignificance.\n</P>\n<P>\n\nThe linker sets the layout of a user program in memory, as directed by a\n&quot;linker script&quot; that tells it the names and locations of the various\nprogram segments.  You can learn more about linker scripts by reading\nthe &quot;Scripts&quot; chapter in the linker manual, accessible via <Q><SAMP>info\nld</SAMP></Q>.\n</P>\n<P>\n\nTo view the layout of a particular executable, run <CODE>objdump</CODE>\n(80<VAR>x</VAR>86) or <CODE>i386-elf-objdump</CODE> (SPARC) with the <Q><SAMP>-p</SAMP></Q>\noption.\n</P>\n<P>\n\n<A NAME=\"Accessing User Memory\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC49\"></A>\n<H3> 4.1.5 Accessing User Memory </H3>\n<!--docid::SEC49::-->\n<P>\n\nAs part of a system\ncall, the kernel must often access memory through pointers provided by a user\nprogram.  The kernel must be very careful about doing so, because\nthe user can pass a null pointer, a pointer to\nunmapped virtual memory, or a pointer to kernel virtual address space\n(above <CODE>PHYS_BASE</CODE>).  All of these types of invalid pointers must\nbe rejected without harm to the kernel or other running processes, by\nterminating the offending process and freeing its resources.\n</P>\n<P>\n\nThere are at least two reasonable ways to do this correctly.  The\nfirst method is to verify\nthe validity of a user-provided pointer, then dereference it.  If you\nchoose this route, you'll want to look at the functions in\n<Q><TT>userprog/pagedir.c</TT></Q> and in <Q><TT>threads/vaddr.h</TT></Q>.  This is the\nsimplest way to handle user memory access.\n</P>\n<P>\n\nThe second method is to check only that a user\npointer points below <CODE>PHYS_BASE</CODE>, then dereference it.\nAn invalid user pointer will cause a &quot;page fault&quot; that you can\nhandle by modifying the code for <CODE>page_fault()</CODE> in\n<Q><TT>userprog/exception.c</TT></Q>.  This technique is normally faster\nbecause it takes advantage of the processor's MMU, so it tends to be\nused in real kernels (including Linux).\n</P>\n<P>\n\nIn either case, you need to make sure not to &quot;leak&quot; resources.  For\nexample, suppose that your system call has acquired a lock or\nallocated memory with <CODE>malloc()</CODE>.  If you encounter an invalid user pointer\nafterward, you must still be sure to release the lock or free the page\nof memory.  If you choose to verify user pointers before dereferencing\nthem, this should be straightforward.  It's more difficult to handle\nif an invalid pointer causes a page fault,\nbecause there's no way to return an error code from a memory access.\nTherefore, for those who want to try the latter technique, we'll\nprovide a little bit of helpful code:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* Reads a byte at user virtual address UADDR.\n   UADDR must be below PHYS_BASE.\n   Returns the byte value if successful, -1 if a segfault\n   occurred. */\nstatic int\nget_user (const uint8_t *uaddr)\n{\n  int result;\n  asm (&quot;movl $1f, %0; movzbl %1, %0; 1:&quot;\n       : &quot;=&amp;a&quot; (result) : &quot;m&quot; (*uaddr));\n  return result;\n}\n \n/* Writes BYTE to user address UDST.\n   UDST must be below PHYS_BASE.\n   Returns true if successful, false if a segfault occurred. */\nstatic bool\nput_user (uint8_t *udst, uint8_t byte)\n{\n  int error_code;\n  asm (&quot;movl $1f, %0; movb %b2, %1; 1:&quot;\n       : &quot;=&amp;a&quot; (error_code), &quot;=m&quot; (*udst) : &quot;q&quot; (byte));\n  return error_code != -1;\n}\n</pre></td></tr></table><P>\n\nEach of these functions assumes that the user address has already been\nverified to be below <CODE>PHYS_BASE</CODE>.  They also assume that you've\nmodified <CODE>page_fault()</CODE> so that a page fault in the kernel merely\nsets <CODE>eax</CODE> to <TT>0xffffffff</TT> and copies its former value\ninto <CODE>eip</CODE>.\n</P>\n<P>\n\n<A NAME=\"Project 2 Suggested Order of Implementation\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC50\"></A>\n<H2> 4.2 Suggested Order of Implementation </H2>\n<!--docid::SEC50::-->\n<P>\n\nWe suggest first implementing the following, which can happen in\nparallel:\n</P>\n<P>\n\n<UL>\n<LI>\nArgument passing (see section <A HREF=\"pintos_4.html#SEC54\">4.3.3 Argument Passing</A>).  Every user program will\npage fault immediately until argument passing is implemented.\n<P>\n\nFor now, you may simply wish to change\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>*esp = PHYS_BASE;\n</pre></td></tr></table>to\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>*esp = PHYS_BASE - 12;\n</pre></td></tr></table>in <CODE>setup_stack()</CODE>.  That will work for any test program that doesn't\nexamine its arguments, although its name will be printed as\n<CODE>(null)</CODE>.\n<P>\n\nUntil you implement argument passing, you should only run programs\nwithout passing command-line arguments.  Attempting to pass arguments to\na program will include those arguments in the name of the program, which\nwill probably fail.\n</P>\n<P>\n\n</P>\n<LI>\nUser memory access (see section <A HREF=\"pintos_4.html#SEC49\">4.1.5 Accessing User Memory</A>).  All system calls\nneed to read user memory.  Few system calls need to write to user\nmemory.\n<P>\n\n</P>\n<LI>\nSystem call infrastructure (see section <A HREF=\"pintos_4.html#SEC55\">4.3.4 System Calls</A>).  Implement enough\ncode to read the system call number from the user stack and dispatch to\na handler based on it.\n<P>\n\n</P>\n<LI>\nThe <CODE>exit</CODE> system call.  Every user program that finishes in the\nnormal way calls <CODE>exit</CODE>.  Even a program that returns from\n<CODE>main()</CODE> calls <CODE>exit</CODE> indirectly (see <CODE>_start()</CODE> in\n<Q><TT>lib/user/entry.c</TT></Q>).\n<P>\n\n</P>\n<LI>\nThe <CODE>write</CODE> system call for writing to fd 1, the system console.\nAll of our test programs write to the console (the user process version\nof <CODE>printf()</CODE> is implemented this way), so they will all malfunction\nuntil <CODE>write</CODE> is available.\n<P>\n\n</P>\n<LI>\nFor now, change <CODE>process_wait()</CODE> to an infinite loop (one that waits\nforever).  The provided implementation returns immediately, so Pintos\nwill power off before any processes actually get to run.  You will\neventually need to provide a correct implementation.\n</UL>\n<P>\n\nAfter the above are implemented, user processes should work minimally.\nAt the very least, they can write to the console and exit correctly.\nYou can then refine your implementation so that some of the tests start\nto pass.\n</P>\n<P>\n\n<A NAME=\"Project 2 Requirements\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC51\"></A>\n<H2> 4.3 Requirements </H2>\n<!--docid::SEC51::-->\n<P>\n\n<A NAME=\"Project 2 Design Document\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC52\"></A>\n<H3> 4.3.1 Design Document </H3>\n<!--docid::SEC52::-->\n<P>\n\nBefore you turn in your project, you must copy <A HREF=\"userprog.tmpl\">the project 2 design document template</A> into your source tree under the\nname <Q><TT>pintos/src/userprog/DESIGNDOC</TT></Q> and fill it in.  We recommend\nthat you read the design document template before you start working on\nthe project.  See section <A HREF=\"pintos_10.html#SEC152\">D. Project Documentation</A>, for a sample design document\nthat goes along with a fictitious project.\n</P>\n<P>\n\n<A NAME=\"Process Termination Messages\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC53\"></A>\n<H3> 4.3.2 Process Termination Messages </H3>\n<!--docid::SEC53::-->\n<P>\n\nWhenever a user process terminates, because it called <CODE>exit</CODE>\nor for any other reason, print the process's name\nand exit code, formatted as if printed by <CODE>printf (&quot;%s:\nexit(%d)\\n&quot;, <small>...</small>);</CODE>.  The name printed should be the full name\npassed to <CODE>process_execute()</CODE>, omitting command-line arguments.\nDo not print these messages when a kernel thread that is not a user\nprocess terminates, or\nwhen the <CODE>halt</CODE> system call is invoked.  The message is optional\nwhen a process fails to load.\n</P>\n<P>\n\nAside from this, don't print any other\nmessages that Pintos as provided doesn't already print.  You may find\nextra messages useful during debugging, but they will confuse the\ngrading scripts and thus lower your score.\n</P>\n<P>\n\n<A NAME=\"Argument Passing\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC54\"></A>\n<H3> 4.3.3 Argument Passing </H3>\n<!--docid::SEC54::-->\n<P>\n\nCurrently, <CODE>process_execute()</CODE> does not support passing arguments to\nnew processes.  Implement this functionality, by extending\n<CODE>process_execute()</CODE> so that instead of simply taking a program file\nname as its argument, it divides it into words at spaces.  The first\nword is the program name, the second word is the first argument, and so\non.  That is, <CODE>process_execute(&quot;grep foo bar&quot;)</CODE> should run\n<CODE>grep</CODE> passing two arguments <CODE>foo</CODE> and <CODE>bar</CODE>.\n</P>\n<P>\n\nWithin a command line, multiple spaces are equivalent to a single\nspace, so that <CODE>process_execute(&quot;grep  foo   bar&quot;)</CODE>\nis equivalent to our original example.  You can impose a reasonable\nlimit on the length of the command line arguments.  For example, you\ncould limit the arguments to those that will fit in a single page (4\nkB).  (There is an unrelated limit of 128 bytes on command-line\narguments that the <CODE>pintos</CODE> utility can pass to the kernel.)\n</P>\n<P>\n\nYou can parse argument strings any way you like.  If you're lost,\nlook at <CODE>strtok_r()</CODE>, prototyped in <Q><TT>lib/string.h</TT></Q> and\nimplemented with thorough comments in <Q><TT>lib/string.c</TT></Q>.  You can\nfind more about it by looking at the man page (run <CODE>man strtok_r</CODE>\nat the prompt).\n</P>\n<P>\n\nSee section <A HREF=\"pintos_4.html#SEC61\">4.5.1 Program Startup Details</A>, for information on exactly how you\nneed to set up the stack.\n</P>\n<P>\n\n<A NAME=\"System Calls\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC55\"></A>\n<H3> 4.3.4 System Calls </H3>\n<!--docid::SEC55::-->\n<P>\n\nImplement the system call handler in <Q><TT>userprog/syscall.c</TT></Q>.  The\nskeleton implementation we provide &quot;handles&quot; system calls by\nterminating the process.  It will need to retrieve the system call\nnumber, then any system call arguments, and carry out appropriate actions.\n</P>\n<P>\n\nImplement the following system calls.  The prototypes listed are those\nseen by a user program that includes <Q><TT>lib/user/syscall.h</TT></Q>.  (This\nheader, and all others in <Q><TT>lib/user</TT></Q>, are for use by user\nprograms only.)  System call numbers for each system call are defined in\n<Q><TT>lib/syscall-nr.h</TT></Q>:\n</P>\n<P>\n\n<A NAME=\"IDX4\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> void <B>halt</B> (void)\n<DD>Terminates Pintos by calling <CODE>shutdown_power_off()</CODE> (declared in\n<Q><TT>devices/shutdown.h</TT></Q>).  This should be seldom used, because you lose\nsome information about possible deadlock situations, etc.\n</DL>\n<P>\n\n<A NAME=\"IDX5\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> void <B>exit</B> (int <VAR>status</VAR>)\n<DD>Terminates the current user program, returning <VAR>status</VAR> to the\nkernel.  If the process's parent <CODE>wait</CODE>s for it (see below), this\nis the status\nthat will be returned.  Conventionally, a <VAR>status</VAR> of 0 indicates\nsuccess and nonzero values indicate errors.\n</DL>\n<P>\n\n<A NAME=\"IDX6\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> pid_t <B>exec</B> (const char *<VAR>cmd_line</VAR>)\n<DD>Runs the executable whose name is given in <VAR>cmd_line</VAR>, passing any\ngiven arguments, and returns the new process's program id (pid).  Must\nreturn pid -1, which otherwise should not be a valid pid, if\nthe program cannot load or run for any reason.\nThus, the parent process cannot return from the <CODE>exec</CODE> until it\nknows whether the child process successfully loaded its executable.\nYou must use appropriate synchronization to ensure this.\n</DL>\n<P>\n\n<A NAME=\"IDX7\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> int <B>wait</B> (pid_t <VAR>pid</VAR>)\n<DD>Waits for a child process <VAR>pid</VAR> and retrieves the child's exit status.\n<P>\n\nIf <VAR>pid</VAR> is still alive, waits until it terminates.  Then, returns\nthe status that <VAR>pid</VAR> passed to <CODE>exit</CODE>.  If <VAR>pid</VAR> did not\ncall <CODE>exit()</CODE>, but was terminated by the kernel (e.g. killed\ndue to an exception), <CODE>wait(pid)</CODE> must return -1.  It is perfectly\nlegal for a parent process to wait for child processes that have already\nterminated by the time the parent calls <CODE>wait</CODE>, but the kernel must\nstill allow the parent to retrieve its child's exit status, or learn\nthat the child was terminated by the kernel.\n</P>\n<P>\n\n<CODE>wait</CODE> must fail and return -1 immediately if any of the\nfollowing conditions is true:\n<UL>\n<LI>\n<VAR>pid</VAR> does not refer to a direct child of the calling process.\n<VAR>pid</VAR> is a direct child of the calling process if and\nonly if the calling process received <VAR>pid</VAR> as a return value\nfrom a successful call to <CODE>exec</CODE>.\n<P>\n\nNote that children are not inherited: if <VAR>A</VAR> spawns child <VAR>B</VAR>\nand <VAR>B</VAR> spawns child process <VAR>C</VAR>, then <VAR>A</VAR> cannot wait for\n<VAR>C</VAR>, even if <VAR>B</VAR> is dead.  A call to <CODE>wait(C)</CODE> by process\n<VAR>A</VAR> must fail.  Similarly, orphaned processes are not assigned to\na new parent if their parent process exits before they do.\n</P>\n<P>\n\n</P>\n<LI>\nThe process that calls <CODE>wait</CODE> has already called <CODE>wait</CODE> on\n<VAR>pid</VAR>.  That is, a process may wait for any given child at most\nonce.\n</UL>\n<P>\n\nProcesses may spawn any number of children, wait for them in any order,\nand may even exit without having waited for some or all of their children.\nYour design should consider all the ways in which waits can occur.\nAll of a process's resources, including its <CODE>struct thread</CODE>, must be\nfreed whether its parent ever waits for it or not, and regardless of\nwhether the child exits before or after its parent.\n</P>\n<P>\n\nYou must ensure that Pintos does not terminate until the initial\nprocess exits.  The supplied Pintos code tries to do this by calling\n<CODE>process_wait()</CODE> (in <Q><TT>userprog/process.c</TT></Q>) from <CODE>main()</CODE>\n(in <Q><TT>threads/init.c</TT></Q>).  We suggest that you implement\n<CODE>process_wait()</CODE> according to the comment at the top of the\nfunction and then implement the <CODE>wait</CODE> system call in terms of\n<CODE>process_wait()</CODE>.\n</P>\n<P>\n\nImplementing this system call requires considerably more work than any\nof the rest.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX8\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> bool <B>create</B> (const char *<VAR>file</VAR>, unsigned <VAR>initial_size</VAR>)\n<DD>Creates a new file called <VAR>file</VAR> initially <VAR>initial_size</VAR> bytes\nin size.  Returns true if successful, false otherwise.\nCreating a new file does not open it: opening the new file is a\nseparate operation which would require a <CODE>open</CODE> system call.\n</DL>\n<P>\n\n<A NAME=\"IDX9\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> bool <B>remove</B> (const char *<VAR>file</VAR>)\n<DD>Deletes the file called <VAR>file</VAR>.  Returns true if successful, false\notherwise.\nA file may be removed regardless of whether it is open or closed, and\nremoving an open file does not close it.  See  <A HREF=\"pintos_4.html#Removing an Open File\">Removing an Open File</A>, for details.\n</DL>\n<P>\n\n<A NAME=\"IDX10\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> int <B>open</B> (const char *<VAR>file</VAR>)\n<DD>Opens the file called <VAR>file</VAR>.  Returns a nonnegative integer handle\ncalled a &quot;file descriptor&quot; (fd), or -1 if the file could not be\nopened.  \n<P>\n\nFile descriptors numbered 0 and 1 are reserved for the console: fd 0\n(<CODE>STDIN_FILENO</CODE>) is standard input, fd 1 (<CODE>STDOUT_FILENO</CODE>) is\nstandard output.  The <CODE>open</CODE> system call will never return either\nof these file descriptors, which are valid as system call arguments only\nas explicitly described below.\n</P>\n<P>\n\nEach process has an independent set of file descriptors.  File\ndescriptors are not inherited by child processes.\n</P>\n<P>\n\nWhen a single file is opened more than once, whether by a single\nprocess or different processes, each <CODE>open</CODE> returns a new file\ndescriptor.  Different file descriptors for a single file are closed\nindependently in separate calls to <CODE>close</CODE> and they do not share\na file position.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX11\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> int <B>filesize</B> (int <VAR>fd</VAR>)\n<DD>Returns the size, in bytes, of the file open as <VAR>fd</VAR>.\n</DL>\n<P>\n\n<A NAME=\"IDX12\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> int <B>read</B> (int <VAR>fd</VAR>, void *<VAR>buffer</VAR>, unsigned <VAR>size</VAR>)\n<DD>Reads <VAR>size</VAR> bytes from the file open as <VAR>fd</VAR> into\n<VAR>buffer</VAR>.  Returns the number of bytes actually read (0 at end of\nfile), or -1 if the file could not be read (due to a condition other\nthan end of file).  Fd 0 reads from the keyboard using\n<CODE>input_getc()</CODE>.\n</DL>\n<P>\n\n<A NAME=\"IDX13\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> int <B>write</B> (int <VAR>fd</VAR>, const void *<VAR>buffer</VAR>, unsigned <VAR>size</VAR>)\n<DD>Writes <VAR>size</VAR> bytes from <VAR>buffer</VAR> to the open file <VAR>fd</VAR>.\nReturns the number of bytes actually written, which may be less than\n<VAR>size</VAR> if some bytes could not be written.\n<P>\n\nWriting past end-of-file would normally extend the file, but file growth\nis not implemented by the basic file system.  The expected behavior is\nto write as many bytes as possible up to end-of-file and return the\nactual number written, or 0 if no bytes could be written at all.\n</P>\n<P>\n\nFd 1 writes to the console.  Your code to write to the console should\nwrite all of <VAR>buffer</VAR> in one call to <CODE>putbuf()</CODE>, at least as\nlong as <VAR>size</VAR> is not bigger than a few hundred bytes.  (It is\nreasonable to break up larger buffers.)  Otherwise,\nlines of text output by different processes may end up interleaved on\nthe console, confusing both human readers and our grading scripts.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX14\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> void <B>seek</B> (int <VAR>fd</VAR>, unsigned <VAR>position</VAR>)\n<DD>Changes the next byte to be read or written in open file <VAR>fd</VAR> to\n<VAR>position</VAR>, expressed in bytes from the beginning of the file.\n(Thus, a <VAR>position</VAR> of 0 is the file's start.)\n<P>\n\nA seek past the current end of a file is not an error.  A later read\nobtains 0 bytes, indicating end of file.  A later write extends the\nfile, filling any unwritten gap with zeros.  (However, in Pintos files\nhave a fixed length until project 4 is complete, so writes past end of\nfile will return an error.)  These semantics are implemented in the\nfile system and do not require any special effort in system call\nimplementation.\n</P>\n</DL>\n<P>\n\n<A NAME=\"IDX15\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> unsigned <B>tell</B> (int <VAR>fd</VAR>)\n<DD>Returns the position of the next byte to be read or written in open\nfile <VAR>fd</VAR>, expressed in bytes from the beginning of the file.\n</DL>\n<P>\n\n<A NAME=\"IDX16\"></A>\n</P>\n<DL>\n<DT><U>System Call:</U> void <B>close</B> (int <VAR>fd</VAR>)\n<DD>Closes file descriptor <VAR>fd</VAR>.  \nExiting or terminating a process implicitly closes all its open file\ndescriptors, as if by calling this function for each one.\n</DL>\n<P>\n\nThe file defines other syscalls.  Ignore them for now.  You will\nimplement some of them in project 3 and the rest in project 4, so be\nsure to design your system with extensibility in mind.\n</P>\n<P>\n\nTo implement syscalls, you need to provide ways to read and write data\nin user virtual address space.\nYou need this ability before you can\neven obtain the system call number, because the system call number is\non the user's stack in the user's virtual address space.\nThis can be a bit tricky: what if the user provides an invalid\npointer, a pointer into kernel memory, or a block\npartially in one of those regions?  You should handle these cases by\nterminating the user process.  We recommend\nwriting and testing this code before implementing any other system\ncall functionality.  See section <A HREF=\"pintos_4.html#SEC49\">4.1.5 Accessing User Memory</A>, for more information.\n</P>\n<P>\n\nYou must synchronize system calls so that\nany number of user processes can make them at once.  In particular, it\nis not safe to call into the file system code provided in the\n<Q><TT>filesys</TT></Q> directory from multiple threads at once.  Your system\ncall implementation must treat the file system code as a critical\nsection.  Don't forget\nthat <CODE>process_execute()</CODE> also accesses files.  For now, we\nrecommend against modifying code in the <Q><TT>filesys</TT></Q> directory.\n</P>\n<P>\n\nWe have provided you a user-level function for each system call in\n<Q><TT>lib/user/syscall.c</TT></Q>.  These provide a way for user processes to\ninvoke each system call from a C program.  Each uses a little inline\nassembly code to invoke the system call and (if appropriate) returns the\nsystem call's return value.\n</P>\n<P>\n\nWhen you're done with this part, and forevermore, Pintos should be\nbulletproof.  Nothing that a user program can do should ever cause the\nOS to crash, panic, fail an assertion, or otherwise malfunction.  It is\nimportant to emphasize this point: our tests will try to break your\nsystem calls in many, many ways.  You need to think of all the corner\ncases and handle them.  The sole way a user program should be able to\ncause the OS to halt is by invoking the <CODE>halt</CODE> system call.\n</P>\n<P>\n\nIf a system call is passed an invalid argument, acceptable options\ninclude returning an error value (for those calls that return a\nvalue), returning an undefined value, or terminating the process.\n</P>\n<P>\n\nSee section <A HREF=\"pintos_4.html#SEC62\">4.5.2 System Call Details</A>, for details on how system calls work.\n</P>\n<P>\n\n<A NAME=\"Denying Writes to Executables\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC56\"></A>\n<H3> 4.3.5 Denying Writes to Executables </H3>\n<!--docid::SEC56::-->\n<P>\n\nAdd code to deny writes to files in use as executables.  Many OSes do\nthis because of the unpredictable results if a process tried to run code\nthat was in the midst of being changed on disk.  This is especially\nimportant once virtual memory is implemented in project 3, but it can't\nhurt even now.\n</P>\n<P>\n\nYou can use <CODE>file_deny_write()</CODE> to prevent writes to an open file.\nCalling <CODE>file_allow_write()</CODE> on the file will re-enable them (unless\nthe file is denied writes by another opener).  Closing a file will also\nre-enable writes.  Thus, to deny writes to a process's executable, you\nmust keep it open as long as the process is still running.\n</P>\n<P>\n\n<A NAME=\"Project 2 FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC57\"></A>\n<H2> 4.4 FAQ </H2>\n<!--docid::SEC57::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT>How much code will I need to write?\n<DD><P>\n\nHere's a summary of our reference solution, produced by the\n<CODE>diffstat</CODE> program.  The final row gives total lines inserted\nand deleted; a changed line counts as both an insertion and a deletion.\n</P>\n<P>\n\nThe reference solution represents just one possible solution.  Many\nother solutions are also possible and many of those differ greatly from\nthe reference solution.  Some excellent solutions may not modify all the\nfiles modified by the reference solution, and some may modify files not\nmodified by the reference solution.\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre> threads/thread.c     |   13 \n threads/thread.h     |   26 +\n userprog/exception.c |    8 \n userprog/process.c   |  247 ++++++++++++++--\n userprog/syscall.c   |  468 ++++++++++++++++++++++++++++++-\n userprog/syscall.h   |    1 \n 6 files changed, 725 insertions(+), 38 deletions(-)\n</pre></td></tr></table><P>\n\n</P>\n<DT>The kernel always panics when I run <CODE>pintos -p <VAR>file</VAR> -- -q</CODE>.\n<DD><P>\n\nDid you format the file system (with <Q><SAMP>pintos -f</SAMP></Q>)?\n</P>\n<P>\n\nIs your file name too long?  The file system limits file names to 14\ncharacters.  A command like <Q><SAMP>pintos -p ../../examples/echo -- -q</SAMP></Q>\nwill exceed the limit.  Use <Q><SAMP>pintos -p ../../examples/echo -a echo\n-- -q</SAMP></Q> to put the file under the name <Q><TT>echo</TT></Q> instead.\n</P>\n<P>\n\nIs the file system full?\n</P>\n<P>\n\nDoes the file system already contain 16 files?  The base Pintos file\nsystem has a 16-file limit.\n</P>\n<P>\n\nThe file system may be so fragmented that there's not enough contiguous\nspace for your file.\n</P>\n<P>\n\n</P>\n<DT>When I run <CODE>pintos -p ../file --</CODE>, <Q><TT>file</TT></Q> isn't copied.\n<DD><P>\n\nFiles are written under the name you refer to them, by default, so in\nthis case the file copied in would be named <Q><TT>../file</TT></Q>.  You\nprobably want to run <CODE>pintos -p ../file -a file --</CODE> instead.\n</P>\n<P>\n\nYou can list the files in your file system with <CODE>pintos -q ls</CODE>.\n</P>\n<P>\n\n</P>\n<DT>All my user programs die with page faults.\n<DD><P>\n\nThis will happen if you haven't implemented argument passing\n(or haven't done so correctly).  The basic C library for user programs tries\nto read <VAR>argc</VAR> and <VAR>argv</VAR> off the stack.  If the stack\nisn't properly set up, this causes a page fault.\n</P>\n<P>\n\n</P>\n<DT>All my user programs die with <CODE>system call!</CODE>\n<DD><P>\n\nYou'll have to implement system calls before you see anything else.\nEvery reasonable program tries to make at least one system call\n(<CODE>exit()</CODE>) and most programs make more than that.  Notably,\n<CODE>printf()</CODE> invokes the <CODE>write</CODE> system call.  The default system\ncall handler just prints <Q><SAMP>system call!</SAMP></Q> and terminates the program.\nUntil then, you can use <CODE>hex_dump()</CODE> to convince yourself that\nargument passing is implemented correctly (see section <A HREF=\"pintos_4.html#SEC61\">4.5.1 Program Startup Details</A>).\n</P>\n<P>\n\n</P>\n<DT>How can I disassemble user programs?\n<DD><P>\n\nThe <CODE>objdump</CODE> (80<VAR>x</VAR>86) or <CODE>i386-elf-objdump</CODE>\n(SPARC) utility can disassemble entire user\nprograms or object files.  Invoke it as <CODE>objdump -d\n<VAR>file</VAR></CODE>.  You can use GDB's\n<CODE>disassemble</CODE> command to disassemble individual functions\n(see section <A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A>).\n</P>\n<P>\n\n</P>\n<DT>Why do many C include files not work in Pintos programs?\n<DD><DT>Can I use lib<VAR>foo</VAR> in my Pintos programs?\n<DD><P>\n\nThe C library we provide is very limited.  It does not include many of\nthe features that are expected of a real operating system's C library.\nThe C library must be built specifically for the operating system (and\narchitecture), since it must make system calls for I/O and memory\nallocation.  (Not all functions do, of course, but usually the library\nis compiled as a unit.)\n</P>\n<P>\n\nThe chances are good that the library you want uses parts of the C library\nthat Pintos doesn't implement.  It will probably take at least some\nporting effort to make it work under Pintos.  Notably, the Pintos\nuser program C library does not have a <CODE>malloc()</CODE> implementation.\n</P>\n<P>\n\n</P>\n<DT>How do I compile new user programs?\n<DD><P>\n\nModify <Q><TT>src/examples/Makefile</TT></Q>, then run <CODE>make</CODE>.\n</P>\n<P>\n\n</P>\n<DT>Can I run user programs under a debugger?\n<DD><P>\n\nYes, with some limitations.  See section <A HREF=\"pintos_11.html#SEC161\">E.5 GDB</A>.\n</P>\n<P>\n\n</P>\n<DT>What's the difference between <CODE>tid_t</CODE> and <CODE>pid_t</CODE>?\n<DD><P>\n\nA <CODE>tid_t</CODE> identifies a kernel thread, which may have a user\nprocess running in it (if created with <CODE>process_execute()</CODE>) or not\n(if created with <CODE>thread_create()</CODE>).  It is a data type used only\nin the kernel.\n</P>\n<P>\n\nA <CODE>pid_t</CODE> identifies a user process.  It is used by user\nprocesses and the kernel in the <CODE>exec</CODE> and <CODE>wait</CODE> system\ncalls.\n</P>\n<P>\n\nYou can choose whatever suitable types you like for <CODE>tid_t</CODE> and\n<CODE>pid_t</CODE>.  By default, they're both <CODE>int</CODE>.  You can make them\na one-to-one mapping, so that the same values in both identify the\nsame process, or you can use a more complex mapping.  It's up to you.\n</DL>\n<P>\n\n<A NAME=\"Argument Passing FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC58\"></A>\n<H3> 4.4.1 Argument Passing FAQ </H3>\n<!--docid::SEC58::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT>Isn't the top of stack in kernel virtual memory?\n<DD><P>\n\nThe top of stack is at <CODE>PHYS_BASE</CODE>, typically <TT>0xc0000000</TT>, which\nis also where kernel virtual memory starts.\nBut before the processor pushes data on the stack, it decrements the stack\npointer.  Thus, the first (4-byte) value pushed on the stack\nwill be at address <TT>0xbffffffc</TT>.\n</P>\n<P>\n\n</P>\n<DT>Is <CODE>PHYS_BASE</CODE> fixed?\n<DD><P>\n\nNo.  You should be able to support <CODE>PHYS_BASE</CODE> values that are\nany multiple of <TT>0x10000000</TT> from <TT>0x80000000</TT> to <TT>0xf0000000</TT>,\nsimply via recompilation.\n</DL>\n<P>\n\n<A NAME=\"System Calls FAQ\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC59\"></A>\n<H3> 4.4.2 System Calls FAQ </H3>\n<!--docid::SEC59::-->\n<P>\n\n</P>\n<DL COMPACT>\n<DT>Can I just cast a <CODE>struct file *</CODE> to get a file descriptor?\n<DD><DT>Can I just cast a <CODE>struct thread *</CODE> to a <CODE>pid_t</CODE>?\n<DD><P>\n\nYou will have to make these design decisions yourself.\nMost operating systems do distinguish between file\ndescriptors (or pids) and the addresses of their kernel data\nstructures.  You might want to give some thought as to why they do so\nbefore committing yourself.\n</P>\n<P>\n\n</P>\n<DT>Can I set a maximum number of open files per process?\n<DD><P>\n\nIt is better not to set an arbitrary limit.  You may impose a limit of\n128 open files per process, if necessary.\n</P>\n<P>\n\n</P>\n<DT>What happens when an open file is removed?\n<DD><A NAME=\"Removing an Open File\"></A>\n<P>\n\nYou should implement the standard Unix semantics for files.  That is, when\na file is removed any process which has a file descriptor for that file\nmay continue to use that descriptor.  This means that\nthey can read and write from the file.  The file will not have a name,\nand no other processes will be able to open it, but it will continue\nto exist until all file descriptors referring to the file are closed\nor the machine shuts down.\n</P>\n<P>\n\n</P>\n<DT>How can I run user programs that need more than 4 kB stack space?\n<DD><P>\n\nYou may modify the stack setup code to allocate more than one page of\nstack space for each process.  In the next project, you will implement a\nbetter solution.\n</P>\n<P>\n\n</P>\n<DT>What should happen if an <CODE>exec</CODE> fails midway through loading?\n<DD><P>\n\n<CODE>exec</CODE> should return -1 if the child process fails to load for\nany reason.  This includes the case where the load fails part of the\nway through the process (e.g. where it runs out of memory in the\n<CODE>multi-oom</CODE> test).  Therefore, the parent process cannot return\nfrom the <CODE>exec</CODE> system call until it is established whether the\nload was successful or not.  The child must communicate this\ninformation to its parent using appropriate synchronization, such as a\nsemaphore (see section <A HREF=\"pintos_7.html#SEC112\">A.3.2 Semaphores</A>), to ensure that the information is\ncommunicated without race conditions.\n</DL>\n<P>\n\n<A NAME=\"80x86 Calling Convention\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC60\"></A>\n<H2> 4.5 80<VAR>x</VAR>86 Calling Convention </H2>\n<!--docid::SEC60::-->\n<P>\n\nThis section summarizes important points of the convention used for\nnormal function calls on 32-bit 80<VAR>x</VAR>86 implementations of Unix.\nSome details are omitted for brevity.  If you do want all the details,\nrefer to [ <A HREF=\"pintos_14.html#SysV-i386\">SysV-i386</A>].\n</P>\n<P>\n\nThe calling convention works like this:\n</P>\n<P>\n\n<OL>\n<LI>\nThe caller pushes each of the function's arguments on the stack one by\none, normally using the <CODE>PUSH</CODE> assembly language instruction.\nArguments are pushed in right-to-left order.\n<P>\n\nThe stack grows downward: each push decrements the stack pointer, then\nstores into the location it now points to, like the C expression\n<Q><SAMP>*--sp = <VAR>value</VAR></SAMP></Q>.\n</P>\n<P>\n\n</P>\n<LI>\nThe caller pushes the address of its next instruction (the <EM>return\naddress</EM>) on the stack and jumps to the first instruction of the callee.\nA single 80<VAR>x</VAR>86 instruction, <CODE>CALL</CODE>, does both.\n<P>\n\n</P>\n<LI>\nThe callee executes.  When it takes control, the stack pointer points to\nthe return address, the first argument is just above it, the second\nargument is just above the first argument, and so on.\n<P>\n\n</P>\n<LI>\nIf the callee has a return value, it stores it into register <CODE>EAX</CODE>.\n<P>\n\n</P>\n<LI>\nThe callee returns by popping the return address from the stack and\njumping to the location it specifies, using the 80<VAR>x</VAR>86 <CODE>RET</CODE>\ninstruction.\n<P>\n\n</P>\n<LI>\nThe caller pops the arguments off the stack.\n</OL>\n<P>\n\nConsider a function <CODE>f()</CODE> that takes three <CODE>int</CODE> arguments.\nThis diagram shows a sample stack frame as seen by the callee at the\nbeginning of step 3 above, supposing that <CODE>f()</CODE> is invoked as\n<CODE>f(1, 2, 3)</CODE>.  The initial stack address is arbitrary:\n</P>\n<P>\n\n<CENTER>\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>                             +----------------+\n                  0xbffffe7c |        3       |\n                  0xbffffe78 |        2       |\n                  0xbffffe74 |        1       |\nstack pointer --&gt; 0xbffffe70 | return address |\n                             +----------------+\n</pre></td></tr></table></CENTER>\n<P>\n\n<A NAME=\"Program Startup Details\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC61\"></A>\n<H3> 4.5.1 Program Startup Details </H3>\n<!--docid::SEC61::-->\n<P>\n\nThe Pintos C library for user programs designates <CODE>_start()</CODE>, in\n<Q><TT>lib/user/entry.c</TT></Q>, as the entry point for user programs.  This\nfunction is a wrapper around <CODE>main()</CODE> that calls <CODE>exit()</CODE> if\n<CODE>main()</CODE> returns:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>void\n_start (int argc, char *argv[]) \n{\n  exit (main (argc, argv));\n}\n</pre></td></tr></table><P>\n\nThe kernel must put the arguments for the initial function on the stack\nbefore it allows the user program to begin executing.  The arguments are\npassed in the same way as the normal calling convention (see section <A HREF=\"pintos_4.html#SEC60\">4.5 80<VAR>x</VAR>86 Calling Convention</A>).\n</P>\n<P>\n\nConsider how to handle arguments for the following example command:\n<Q><SAMP>/bin/ls -l foo bar</SAMP></Q>.\nFirst, break the command into words: <Q><SAMP>/bin/ls</SAMP></Q>,\n<Q><SAMP>-l</SAMP></Q>, <Q><SAMP>foo</SAMP></Q>, <Q><SAMP>bar</SAMP></Q>.  Place the words at the top of the\nstack.  Order doesn't matter, because they will be referenced through\npointers.\n</P>\n<P>\n\nThen, push the address of each string plus a null pointer sentinel, on\nthe stack, in right-to-left order.  These are the elements of\n<CODE>argv</CODE>.  The null pointer sentinel ensures that <CODE>argv[argc]</CODE>\nis a null pointer, as required by the C standard.  The order ensures\nthat <CODE>argv[0]</CODE> is at the lowest virtual address.  Word-aligned\naccesses are faster than unaligned accesses, so for best performance\nround the stack pointer down to a multiple of 4 before the first push.\n</P>\n<P>\n\nThen, push <CODE>argv</CODE> (the address of <CODE>argv[0]</CODE>) and <CODE>argc</CODE>,\nin that order.  Finally, push a fake &quot;return address&quot;: although the\nentry function will never return, its stack frame must have the same\nstructure as any other.\n</P>\n<P>\n\nThe table below shows the state of the stack and the relevant registers\nright before the beginning of the user program, assuming\n<CODE>PHYS_BASE</CODE> is <TT>0xc0000000</TT>:\n</P>\n<P>\n\n<CENTER>\n</P>\n<TABLE>\n<TR><TD>Address </TD><TD> Name </TD><TD> Data </TD><TD> Type</TD>\n</TR>\n<TR><TD><TT>0xbffffffc</TT> </TD><TD> <CODE>argv[3][<small>...</small>]</CODE> </TD><TD> <Q><SAMP>bar\\0</SAMP></Q> </TD><TD> <CODE>char[4]</CODE></TD>\n</TR>\n<TR><TD><TT>0xbffffff8</TT> </TD><TD> <CODE>argv[2][<small>...</small>]</CODE> </TD><TD> <Q><SAMP>foo\\0</SAMP></Q> </TD><TD> <CODE>char[4]</CODE></TD>\n</TR>\n<TR><TD><TT>0xbffffff5</TT> </TD><TD> <CODE>argv[1][<small>...</small>]</CODE> </TD><TD> <Q><SAMP>-l\\0</SAMP></Q> </TD><TD> <CODE>char[3]</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffed</TT> </TD><TD> <CODE>argv[0][<small>...</small>]</CODE> </TD><TD> <Q><SAMP>/bin/ls\\0</SAMP></Q> </TD><TD> <CODE>char[8]</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffec</TT> </TD><TD> word-align </TD><TD> 0 </TD><TD> <CODE>uint8_t</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffe8</TT> </TD><TD> <CODE>argv[4]</CODE> </TD><TD> <TT>0</TT> </TD><TD> <CODE>char *</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffe4</TT> </TD><TD> <CODE>argv[3]</CODE> </TD><TD> <TT>0xbffffffc</TT> </TD><TD> <CODE>char *</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffe0</TT> </TD><TD> <CODE>argv[2]</CODE> </TD><TD> <TT>0xbffffff8</TT> </TD><TD> <CODE>char *</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffdc</TT> </TD><TD> <CODE>argv[1]</CODE> </TD><TD> <TT>0xbffffff5</TT> </TD><TD> <CODE>char *</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffd8</TT> </TD><TD> <CODE>argv[0]</CODE> </TD><TD> <TT>0xbfffffed</TT> </TD><TD> <CODE>char *</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffd4</TT> </TD><TD> <CODE>argv</CODE> </TD><TD> <TT>0xbfffffd8</TT> </TD><TD> <CODE>char **</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffd0</TT> </TD><TD> <CODE>argc</CODE> </TD><TD> 4 </TD><TD> <CODE>int</CODE></TD>\n</TR>\n<TR><TD><TT>0xbfffffcc</TT> </TD><TD> return address </TD><TD> 0 </TD><TD> <CODE>void (*) ()</CODE></TD>\n</TR></TABLE>\n</CENTER>\n<P>\n\nIn this example, the stack pointer would be initialized to\n<TT>0xbfffffcc</TT>.\n</P>\n<P>\n\nAs shown above, your code should start the stack at the very top of\nthe user virtual address space, in the page just below virtual address\n<CODE>PHYS_BASE</CODE> (defined in <Q><TT>threads/vaddr.h</TT></Q>).\n</P>\n<P>\n\nYou may find the non-standard <CODE>hex_dump()</CODE> function, declared in\n<Q><TT>&lt;stdio.h&gt;</TT></Q>, useful for debugging your argument passing code.\nHere's what it would show in the above example:\n</P>\n<P>\n\n<TABLE><tr><td>&nbsp;</td><td class=example><pre>bfffffc0                                      00 00 00 00 |            ....|\nbfffffd0  04 00 00 00 d8 ff ff bf-ed ff ff bf f5 ff ff bf |................|\nbfffffe0  f8 ff ff bf fc ff ff bf-00 00 00 00 00 2f 62 69 |............./bi|\nbffffff0  6e 2f 6c 73 00 2d 6c 00-66 6f 6f 00 62 61 72 00 |n/ls.-l.foo.bar.|\n</pre></td></tr></table><P>\n\n<A NAME=\"System Call Details\"></A>\n<HR SIZE=\"6\">\n<A NAME=\"SEC62\"></A>\n<H3> 4.5.2 System Call Details </H3>\n<!--docid::SEC62::-->\n<P>\n\nThe first project already dealt with one way that the operating system\ncan regain control from a user program: interrupts from timers and I/O\ndevices.  These are &quot;external&quot; interrupts, because they are caused\nby entities outside the CPU (see section <A HREF=\"pintos_7.html#SEC120\">A.4.3 External Interrupt Handling</A>).\n</P>\n<P>\n\nThe operating system also deals with software exceptions, which are\nevents that occur in program code (see section <A HREF=\"pintos_7.html#SEC119\">A.4.2 Internal Interrupt Handling</A>).  These can be errors such as a page fault or division by\nzero.  Exceptions are also the means by which a user program\ncan request services (&quot;system calls&quot;) from the operating system.\n</P>\n<P>\n\nIn the 80<VAR>x</VAR>86 architecture, the <Q><SAMP>int</SAMP></Q> instruction is the\nmost commonly used means for invoking system calls.  This instruction\nis handled in the same way as other software exceptions.  In Pintos,\nuser programs invoke <Q><SAMP>int $0x30</SAMP></Q> to make a system call.  The\nsystem call number and any additional arguments are expected to be\npushed on the stack in the normal fashion before invoking the\ninterrupt (see section <A HREF=\"pintos_4.html#SEC60\">4.5 80<VAR>x</VAR>86 Calling Convention</A>).\n</P>\n<P>\n\nThus, when the system call handler <CODE>syscall_handler()</CODE> gets control,\nthe system call number is in the 32-bit word at the caller's stack\npointer, the first argument is in the 32-bit word at the next higher\naddress, and so on.  The caller's stack pointer is accessible to\n<CODE>syscall_handler()</CODE> as the <Q><SAMP>esp</SAMP></Q> member of the\n<CODE>struct intr_frame</CODE> passed to it.  (<CODE>struct intr_frame</CODE> is on the kernel\nstack.)\n</P>\n<P>\n\nThe 80<VAR>x</VAR>86 convention for function return values is to place them\nin the <CODE>EAX</CODE> register.  System calls that return a value can do\nso by modifying the <Q><SAMP>eax</SAMP></Q> member of <CODE>struct intr_frame</CODE>.\n</P>\n<P>\n\nYou should try to avoid writing large amounts of repetitive code for\nimplementing system calls.  Each system call argument, whether an\ninteger or a pointer, takes up 4 bytes on the stack.  You should be able\nto take advantage of this to avoid writing much near-identical code for\nretrieving each system call's arguments from the stack.\n<A NAME=\"Project 3--Virtual Memory\"></A>\n<HR SIZE=\"6\">\n<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>\n<TR><TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_4.html#SEC42\"> &lt;&lt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_5.html#SEC63\"> &gt;&gt; </A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\"> &nbsp; <TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Top\">Top</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos.html#SEC_Contents\">Contents</A>]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[Index]</TD>\n<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">[<A HREF=\"pintos_abt.html#SEC_About\"> ? </A>]</TD>\n</TR></TABLE>\n<BR>\n<FONT SIZE=\"-1\">\nThis document was generated\nby <I>Ryan Huang</I> on <I>September, 4 2018</I>\nusing <A HREF=\"http://texi2html.cvshome.org\"><I>texi2html</I></A>\n</FONT>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}