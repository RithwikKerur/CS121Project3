{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/linkedlist.txt", "content": "\t\tLinked Lists and Linked List Processing\r\n\r\n\r\nIntroduction:\r\n\r\nThis lecture reviews the basics of linked lists and linked list processing. You\r\nare expected to understand how to draw linked lists (both full and abbreviated\r\npictures), how to update these drawings by hand simulating code that operates\r\non linked lists (which is especially useful for debugging linked list code that\r\nyou write), how to process linked lists by iterating over/traversing them (in a\r\nvariety of ways), how add values at the front and rear of a linked list, how to\r\nsearch for and remove a value from a linked list, and how to copy a linked list\r\nefficiently.\r\n\r\nHere we use the term \"linked list\" to refer to what more formally be called a\r\n\"linear linked list\". In the next lecture we will examine simple linked list\r\nvariants and their uses: circular lists, header/trailer lists, and doubly-linked\r\nlists. In that lecture we will also discuss using references to pointers and\r\npointers to pointers in linked list processing. In a third lecture we will\r\nexamine how linked lists are defined and processed recursively, which will also\r\nhighlight using references to pointers.\r\n\r\n\r\nLinked List Basics:\r\n\r\nWe will start by looking at a simple templated class named LN, which we use to\r\nrepresent List Nodes in a linearly-linked list: each LN<T> object points to\r\nanother LN<T> object from that same class (the one that follows it in the list)\r\n-or to nothing (meaning this object is at the end of the list), represented by\r\nnullptr.\r\n\r\nThis class declares two public instance variables, instead of private ones with\r\naccessor/setter methods: in this generic class, the setters would allow any\r\nvalue to be stored there, so setters aren't of much use (and would increase the\r\nsyntactic complexity of writing code to process LNs). It also defines three\r\npublic constuctors (default and copy) and another useful constructor that is\r\ncalled with two arguments: a value of type T and of type LN<T>* (whose default\r\nvalue in nullptr).\r\n\r\ntemplate<class T>\r\nclass LN {\r\n  public:\r\n    LN ()                               : next(nullptr){}\r\n    LN (const LN<T>& ln)                : value(ln.value), next(ln.next){}\r\n    LN (const T& v, LN<T>* n = nullptr) : value(v), next(n){}\r\n\r\n    T      value;\r\n    LN<T>* next;\r\n};\r\n\r\nAlthough not universally agreed upon, I think this style (public instance\r\nvariables) is easier to write code for, avoiding the extra syntax of doing\r\nmethod calls to examine and set these instance variables. Also, we often \r\ndeclare classes like LN<T> to be nested classes inside another class (as we will\r\nin the linked-list implementations of data types in Programming Assignment #2),\r\nand therefore they can be manipulated only by the code in the outer class.\r\n\r\nWe will examine an Object/Variable picture of a linked list built from this\r\nclass, and a simplified picture that represents all the necessary information,\r\nbut more compactly (if a bit more ambiguously). You should be able think in\r\nterms of both the full and abbreviated pictures, whichever is best for the\r\nvisualization you need.\r\n\r\nGiven such pictures, we should be able to understand how such data structures\r\nare accessed when using combinations of ->value and ->next; e.g., in the linked\r\nlist shown, what is the type and value of x->next->next->value or x->next->next?\r\nWhat would happen if these appeared as lvalues (on the left hand side of an =): \r\n  x->next->next->value = 10;\r\n  x->next->next        = nullptr;\r\n\r\nEvery occurence of \"->name\" means \"(a) follow the pointer before the arrow to\r\nthe object that it refers to and (b) focus on the instance variable/box for\r\nthat \"name\" (which might store a pointer to follow later). So, x->next both\r\nstores a value and is a location in which we can store a value. The -> operator\r\nis called \"member (or instance) access\". The statement x->next->next->value = 10\r\nstarts at pointer x; then it follows it to the list node it points to and\r\nfocuses on the \"next\" instance variable (which is also a pointer); then it\r\nfollows that to the list node it points to and focuses on the \"value\" instance\r\nvariable, setting it to 10.\r\n\r\nThe * operator is also used with pointers too, but less often than -> is used.\r\nEvery occurence of \"*\" means just \"follow the pointer before the arrow to the\r\nobject that it refers to\", which is just the first part of the -> operator.\r\nIf we use *, we will typically process that whole object, or we then use the\r\n. (dot) operator to focus on the the instance variable/box for a name. The *\r\noperator is called indirection/dereference.\r\n\r\nIn fact, (*x).value has the same meaning as x->value, so we often use the\r\nsimpler x->value form, rather than the (*x).value form. Because . has higher\r\noperator precedence than *, we must use these parentheses to get the desired\r\nresult.\r\n\r\nI have found that many students are just \"faking\" an understanding of how\r\nlinked lists are accessed and updated. They really don't understand all the\r\nmaterial in the previous paragraph, or how code accesses and mutates linked\r\nlists. They intuit the meaning of simple access, but cannot understand more\r\ncomplicated ones. They don't follow my recommendations to practice hand-\r\nsimulating linked list code, so they ultimately have a very hard time writing\r\n(and even a harder time debugging) their linked list code.\r\n\r\n\r\nIterating over Linked Lists:\r\n\r\nWe will examine the concept of \"cursors\" and how they unify the processing\r\nof arrays (where cursors are ints) and linked lists (where cursors are\r\npointers, which are actually int-like values that represent addresses that\r\npoint to memory locations): in each case the cursor (a small piece of data)\r\ntells \"where we are focussed\" in a large data structure. With both we can use a\r\nstandard \"for\" loop for traversing the entire data structure (focusing on each\r\npiece of data in the data structure, one after the other). Iterators implement\r\na way to keep track of cursors for a data structure as they traverse it.\r\n\r\n  array       x: for (int       i=0; i<length  ; ++i      ) ...access x[i]\r\n  linked list x: for (LN<...>*  p=x; p!=nullptr; p=p->next) ...access p->value\r\n\r\nNote that when i<length is false, i is ONE BEYOND the end of the array; likewise\r\nwhen p != nullptr is false, p is ONE BEYOND the last list node in the linked\r\nlist. Recall how the .end() method call on an iterator generates a value ONE\r\nBEYOND the end of what is being iterated over: in explicit iteration we write\r\nthe for loop test for cursor c iterating over any queue q as c != q.end().\r\n\r\nWe will closely examine what p = p->next means, and more generally what it\r\nmeans to copy any pointer value into a pointer variable.\r\n\r\n  For the statement \"p1 = p2;\" the magic words are: \"Make the box storing\r\n  variable p1 refer/point to the same object that the box for the variable p2\r\n  refers/points to.\" Note that if p2 stores nullptr (refers/points to no object)\r\n  then nullptr should be stored in p1 too (so that it also refers/points to no\r\n  object).\r\n\r\n  A statement like p1->next = p2; is interpreted very similarly, but here the\r\n  box on the left side of the = is an instance variable in the object p1 refers\r\n  to. So this assignment statement says \"Make the box storing p1->next (which is\r\n  the instance variable \"next\" in the object that variable p1 refers/points to)\r\n  refer/point to the same object that the box for the variable p2 refer/points\r\n  to.\r\n\r\n  Finally, p = p->next means, \"Find the object p refers/points to and examine\r\n  the value of its \"next\" instance variable; store this pointer into p. The\r\n  result is that p (a cursor) is advanced to index the next LN in the linked\r\n  list (or ONE BEYOND the linked list).\r\n\r\nOf course, what the assignment \"p1 = p2;\" really does is copy the integer that\r\nis the pointer p2 into p1. The integer refers to the memory address of the\r\nobject. But it is better at the beginning to ignore memory addresses and show\r\npointers as arrows. Later, C++ references (i.e. &) make these pictures tougher\r\nto draw and interpret (but we will still do both; and both help us understand\r\nand debug the code we write).\r\n\r\nWhile the semantics of pointer assignments is not really complicated once you\r\n\"get the hang of it\", many students don't take the time to \"get the hang of it\".\r\nSuch a misunderstanding makes it difficult to write and especially debug code\r\n(by hand simulation) that uses linked lists. There is little I want you to\r\nlearn by rote this quarter, but learn these words by rote.\r\n\r\nNote that after p1 = p2; the test p1 == p2 evaluates to true: both variables\r\nrefer/point to the same object. So, of course *p1 == *p2 is also true, because\r\nthe state of the object p1 refers to is the same as the state of the object p2\r\nrefers to (what == means when applied to objects): because they refer/point to\r\nthe same object! And typically == on objects (not pointers) computes whether\r\nthe objects have the same state: their instance variables store the same values.\r\nSo == on pointers is like Python's \"is\" operator and == on dereferenced\r\npointers is like Python's == operator.\r\n\r\nHere are a series of code fragments/functions that process linked lists. All of\r\nthe examples in this lecture use LN<int> for simplicity. Most interesting\r\ndetails of linked procesing concerns the use of \"next\" not \"value\". Computing\r\nthe length of a linked list (example 3) doesn't concern \"value\" at all. All of\r\nthese operations traverse the linked list (visiting every LN). Almost all use\r\nthe same for loop form: which is similar to doing each of these operations on an\r\narray, with an integer index rather than a pointer as a cursor.\r\n\r\nAssumes we have defined\r\n\r\n  LN<int>* l\r\n    +---+   +-------+   +-------+   +-------+   +-------+   \r\n    | --+-->| 5 | --+-->| 2 | --+-->| 7 | --+-->| 4 | / |\r\n    +---+   +-------+   +-------+   +-------+   +-------+   \r\n\r\n\r\n(1) Traverse a linked list, computing the sum of its <int> values.\r\n\r\nIf you truly understand how/why this code works, at the microscopic level, you\r\nare 70% of the way to a good understanding of linked lists. See the Picture\r\nlink on the website showing all the changes to p and sum that occur when\r\nexecuting this code.\r\n\r\n  int sum = 0;\r\n  for (LN<int>* p = l;   p != nullptr;   p = p->next)\r\n    sum += p->value;\r\n  std::cout << \"Sum = \" << sum << std::endl;\r\n\r\nIt computes the value 18 for the list above.\r\n\r\n\r\n(2) Define a function to traverse a linked list, inserting each value on the\r\ncout output stream (with \"->\" between values, ending in \"nullptr\"); this is\r\nshown as overloading the operator <<.\r\n\r\n  template<class T>\r\n  std::ostream& operator << (std::ostream& outs, LN<T>* l) {\r\n    for (LN<T>* p = l;   p != nullptr;   p = p->next)\r\n      outs << p->value << \"->\";\r\n    outs << \"nullptr\";\r\n    return outs;\r\n}\r\n\r\nstd::cout << l; prints \"5->2->7->4->nullptr\" for the list above. We might use\r\na function like this one for the str method defined for a linked list\r\nimplementation of a data type.\r\n\r\n\r\n(3) Define a function to traverse a linked list computing its length: the\r\nnumber of LN<T> objects reachable.\r\n\r\ntemplate<class T>\r\nint length (LN<T>* l) {\r\n  int answer = 0;\r\n  for (LN<T>* p = l;   p != nullptr ;   p = p->next)\r\n    ++answer;\r\n  return answer;\r\n}\r\n\r\nlength(l) returns 4 for the list above. To computes .size() for an array\r\nimplementation of a data type, we must store the \"used\" in the array; but for\r\nlinked lists we can actually compute this value (although caching it can be much\r\nfaster for a long linked list, and caching one int doesn't occupy much space).\r\n\r\n\r\n(4) Define a function to traverse a linked list computing how often a certain\r\nvalue occurs in it.\r\n\r\ntemplate<class T>\r\nint count_occurences (LN<T>* l, T to_count) {\r\n  int answer = 0;\r\n  for (LN<T>* p = l;   p !=nullptr;   p = p->next)\r\n    if (p->value == to_count)\r\n      ++answer;\r\n  return answer;\r\n}\r\n\r\ncount_occurrences(l,2) returns 1 for the list above.\r\n\r\n\r\n(5) Define a function to traverse a linked list computing whether or not it is\r\nin a sorted order. Recall that empty lists and lists with one value are sorted\r\nby definition: there are no \"out of order\" values. Sorted here means that the\r\nvalues are in non-decreasing order: subsequent values stay the same or get\r\nlarger. For this function to compile/work correcly, operator> must be defined\r\non type T. Algorithmically (after checking for a list of length 0 or 1), it\r\nchecks whether any values are \"out of order\" and if so, returns false; if there\r\nare no \"out of order\" values it returns true after scanning the entire list.\r\n\r\ntemplate<class T>\r\nbool is_sorted (LN<T>* l) {\r\n  if (l == nullptr || l->next == nullptr) //Shortcircuit || is critical here\r\n    return true;\r\n\r\n  T prev = l->value;\r\n  for (LN<T>* p = l->next;   p != nullptr;   prev = p->value, p = p->next)\r\n    if (prev > p->value)\r\n      return false;\r\n  return true;\r\n}\r\n\r\nis_sorted(l) returns false for the list above.\r\n\r\nRecall that || is a short-circuit boolean operator: if the first condition is\r\ntrue, then the value of the entire boolean expression is known to be true, so\r\nthe second condition isn't even tested/evaluated; if it were tested/evaluated,\r\nit would crash the program (see below), because l->next cannot be computed when\r\nl stores nullptr (the \"follow the pointer to the object it points to\" part\r\nfails, because it points to no object). Thus, the order in which the conditions\r\nare tested is very important to the test working correctly.\r\n\r\nActually, we can simplify the code as\r\n\r\ntemplate<class T>\r\nbool is_sorted (LN<T>* l) {\r\n  if (l == nullptr)\r\n    return true;\r\n\r\n  T prev = l->value;\r\n  for (LN<T>* p = l->next;   p != nullptr;   prev = p->value, p = p->next)\r\n    if (prev > p->value)\r\n      return false;\r\n  return true;\r\n}\r\n\r\nHere, if l->next is nullptr (a one element list), the for loop executes 0 times\r\n(never executing its body), returning true (whereas the code at the beginning\r\nreturns immediately, never reaching the loop).\r\n\r\nWe can also write this code without the temporary \"prev\", by using the single\r\npointer p to refer to a value (p->value) that is compared with the value\r\nfollowing it in the the linked list (p->next->value). We should execute this\r\ntest in the body of the loop only if p->next is not nullptr (testing that there\r\nis an object after the object p refers/points to).\r\n\r\ntemplate<class T>\r\nbool is_sorted2 (LN<T>* l) {\r\n  if (l == nullptr)\r\n    return true;\r\n\r\n  for (LN<T>* p = l;   p->next != nullptr;   p = p->next)\r\n    if (p->value > p->next->value)\r\n      return false;\r\n  return true;\r\n}\r\n\r\nAll these traversals (except the last) are written with simple and similar\r\nlist-processing code. When we write code that processes a linked list, we\r\nshould be able to prove that every time that we write \"p->\" inside the loop's\r\nbody, then p is not nullptr (i.e., that p really points to some object). The\r\ntypical continuation condition in a for loop that processes a linked list (the\r\ntest: p!=nullptr) guarantees that the body of the loop can contain \"p->\"\r\nbecause the body is executed only if p is not nullptr. Likewise, in the last\r\ncode fragment above, the continuation condition is p->next != nullptr, because\r\nthe body refers to p->next->value; can you argue/prove that p is never nullptr\r\nwhen this condition is checked/evaluated?\r\n\r\nIf we ever execute \"p->....\" when p stores nullptr, the C++ program does not\r\nthrow an exception: it crashes. On Windows I get a popup window saying that\r\n...exe has stopped working. To ensure maximum speed, C++ does not check that\r\na pointer if nullptr before following it; Python and Java do, and therefore\r\nthrow an exception that can be caught and handled. When a nullptr is followed\r\nin C++, it causes the program to terminate by crashing. So, C++ runs code more\r\nquickly, but when the code is incorrect can crash the program with little useful\r\ninformation about why. C++ will run correct code as fast as possible;\r\nprogrammers should never make this mistake (dereference a nullptr), and if they\r\ndo, they will receive no nice error indication.\r\n\r\nRecall that C++ has the following \"conditional expression\" syntax. Actually, the\r\n() are not required, but they are useful to contain this conditional expression\r\nwhen other operators apply to the value of the condition expression.\r\n\r\n  (boolean expression ? ValueIfTrue : ValueIfFalse)\r\n\r\nConditional \"expressions\" are sometimes a shorter and simpler to understand\r\nversion of a conditional \"statement\": the if statement. Often a question arises\r\nabout which is \"faster\": I don't know, but they probably run at about the same\r\nspeed. The benefit of a conditional expression derives from whether it\r\nsimplifies the code or not, compared to an \"if statement\" which is the typical\r\nalternative. Note that expressions compute values; statements execute,\r\ntypically causing state-changes.\r\n\r\n\r\nBuilding Lists:\r\n\r\nWe will now write code fragments to add a value to the front of a list and at\r\nthe rear of a list. In this way we can build any list we want, with the values\r\nin any order. Inserting a new LN at the front of a linked list moves every node\r\nback by one in the linked list, without changing any other pointers. Inserting\r\na node at the rear of a linked list requires traversing the list, skipping unti\r\nwe point to the last LN, and then appending a new LN after it. Of course, we\r\ncan always cache a pointer to the last node in a non-empty list, to access it\r\nimmediately.\r\n\r\nConstrast the code below with adding a new value at the front and rear of an\r\narray (assuming we need to retain the order of the values). For a list, we can\r\nadd a LN at the front by changing one pointer; for an array we must first move\r\nevery value in the array to the next higher index, opening up index 0 in which\r\nwe put the new value. Such shifting can be inefficient if the array contains\r\nmany values. Of course, if the length of the array is not big enough to include\r\nanother value at its front, we must construct a new array with a larger length\r\nand copy all the original array values to it (although we can copy each value\r\nto an index one bigger here, rather than copy all values first and then skip\r\nall values).\r\n\r\nThe code to add a node storing some_value at the front of LN<int>* x; is just\r\n\r\n  x = new LN<int>(some_value, x);\r\n\r\nThis code works whether x points to an empty list (stores nullptr) or whether x\r\nstores a pointer to the first node in a list with any number of values following\r\nit. Paraphrased, x now points to a new node storing the value some_value, whose\r\nnext instance variable points to the list that x originally pointed to. Draw\r\nsome examples of lists (empty and not) and hand simulate this code on them to\r\nensure you completely understand it. Yes, I really mean this. Serious, I really\r\ndo mean it.\r\n\r\nI still mean it. If you haven't done this do it now.\r\n\r\nThe opposite is true for adding at the rear of a linked list/array data\r\nstructure: for a linked list, we must skip over every node starting from the\r\nfront of the list to find the rear node of the list; for an array we typically\r\nknow the index of the last value and put the new value one beyond the end, so\r\nwe do not have to examine any other values in the array. Of coure, if the\r\nlength of the array is not big enough to include another value at its end, we\r\nmust construct a new array with a larger length and copy all the original array\r\nvalues to it.\r\n\r\nIn fact, for adding a value at the rear of a linked list, we need two cases.\r\nIf the list is empty, we must store the new pointer in x (in this case the\r\nrear becomes the front too); if the list is not empty, we must store the new\r\npointer in the ->next instance variable of the node currently at the rear of\r\nthe list (the node whose ->next stores nullptr). This code is\r\n\r\n  if (x == nullptr)\r\n    x = new LN<int>(some_value); //Default argument for 2nd parameter is nullptr\r\n  else {\r\n    LN<int>* p = x;\r\n    for (; p->next != nullptr; p = p->next)  or\twhile (p->next!=nullptr)\r\n      {}\t\t\t\t\t  p = p->next;\r\n    p->next = new LN<int>(some_value);\r\n  }\r\n\r\nNotice two important things about the code in the else block\r\n\r\n  1. We must declare p BEFORE/OUTSIDE the for loop, because we use it\r\n     AFTER the for loop terminates (outside the loop). Variables declared\r\n     inside a loop can be accessed only by code inside the loop's body.\r\n\r\n  2. We terminate the for loop when p refers to the LAST NODE in the linked\r\n     list; the last node is the only one whose ->next is nullptr. In this case\r\n     we DO NOT stop when p == nullptr (as we did for all the query code); that\r\n     would mean p has gone too far (ONE BEYOND the last list node): we have run\r\n     off the linked list and have lost the pointer to the last node, whose\r\n     \"next\" we  are trying to change, by  making \"next\" point to a new node. We\r\n     stop when p points to the last node in the list, the unique node whose\r\n     ->next is nullptr.\r\n\r\nWe could also write the else clause as follows, declaring p inside the loop,\r\nand updating it in the loop body before breaking out of the loop.\r\n\r\n  else\r\n    for (LN<int>* p = x;   /*see body for explicit termination*/;   p = p->next)\r\n      if (p->next == nullptr) {\r\n        p->next = new LN<int>(some_value);\r\n        break;\r\n      }\r\n\r\nWe could encapsulate these code fragments into functions and then call either\r\nx = add_front(x,some_value); or  x = add_rear(x,some_value); in both cases it\r\nis critical to store the returned value in x, because if x is empty (stores\r\nnullptr) unless we store a value into x it will not change (but we will see how\r\nto use & references to solve this problem for functions in the next lecture).\r\n\r\ntemplate<class T>\r\nLN<T>* add_front(LN<T>* l, const T& value) { //O(1) complexity class\r\n  return new LN<T>(value,l);\r\n}\r\n\r\ntemplate<class T>\r\nLN<T>* add_rear(LN<T>* l, const T& value) {  //O(N) complexity class\r\n  if (l == nullptr)\r\n    return new LN<T>(value); //Default argument for 2nd parameter is nullptr\r\n\r\n  for (LN<T>* p = l;   /*see body for explicit termination*/;   p = p->next)\r\n    if (p->next == nullptr) {\r\n      p->next = new LN<T>(value);\r\n      break;\r\n    }\r\n  return l;\r\n}\r\n\r\nor\r\n\r\ntemplate<class T>\r\nLN<T>* add_rear(LN<T>* l, const T& value) {\r\n  if (l == nullptr)\r\n    return new LN<T>(value); //Default argument for 2nd parameter is nullptr\r\n\r\n  LN<T>* p = l;\r\n  for (/*See above*/;   p->next != nullptr;   p = p->next) //  or  while (p->next != nullptr)\r\n    {}                                                     //         p = p->next;\r\n  p->next = new LN<T>(value);\r\n\r\n  return l;\r\n}\r\n\r\nHere is a simple (but slow) function that puts the code above into a simple\r\nloop to store all the values in an array into a linked list, preserving the\r\norder, by using add_rear. We could write a simlar function to read the values\r\nfrom a file.\r\n\r\ntemplate<class T>\r\nLN<T>* build_linked_list_simple(T values[], int length) {\r\n  LN<T>* front = nullptr;\r\n  for (int i=0;   i<length;   ++i)\r\n    front = add_rear(front,values[i]);\r\n\r\n  return front;\r\n}\r\n\r\nThis process repeated calls add_rear, which requires the code to traverse\r\nthe entire linked list every time a new value is stored at the rear;\r\nmathematically, if the array stores 1,000 values, when building the linked list\r\nwe will have to scan approximately 500,000 list nodes (that number of values\r\nsquared, divided by 2: we skip 0 nodes to add the first value, 1 node to add\r\nthe second value, 2 nodes to add the third, value, ...  and 999 nodes to add\r\nthe 1000th value; so we skip 0 + 1 + 2 + ... + 999 nodes) which is slow:\r\nO(N**2). We can speed up adding values via caching, discussed next.\r\n\r\nAside: we could iterate through the array BACKWARDS, and add each value at the\r\nFRONT of the linked list we are building, to get the right order. Doing so\r\ntakes O(N) time. We could not use \"going backwards\" in our solution of copying\r\na linked list (but we can use caching, discussed below).\r\n\r\ntemplate<class T>\r\nLN<T>* build_linked_list_backward_with_reversed_array(T values[], int length) {\r\n  LN<T>* front = nullptr;\r\n  for (int i=length-1;   i>= 0;   --i)\r\n    front = add_front(front,values[i]);\r\n\r\n  return front;\r\n}\r\n\r\nWe briefly discussed caching when we discussed the size method in the ArraySet\r\nclass. Caching is a classic \"space for time\" tradeoff: we use extra space to\r\nstore (and update) a precomputed value so that we don't have to recompute it.\r\nIn ArraySet, we stored the instance variable used, so the size method can just\r\nreturn this value; it doesn't have to count the number of values stored in the\r\narray each time we need to compute the size. Whenever we added or removed a\r\nvalue from the array, the code incremented/decremented this counter.\r\n\r\nLikewise, we often cache the size of a list implementing a data type (rather\r\nthan scanning the list to compute the size). If we need to repeatedly add a\r\nvalue at the rear of a linked list, we can also cache a pointer to the last\r\nnode in the linked list, so we can quickly add a new node at the rear (and then\r\nthe new node becomes the new rear). With such a cached value we never have to\r\ntraverse the linked list to find its last node; we've already precomputed it\r\neach time we need it, and update it when it changes.\r\n\r\nHere is a variation of the \"build_linked_list_simple\" function that accomplish\r\nthe same result but more efficiently. \r\n\r\ntemplate<class T>\r\nLN<T>* build_linked_list_fast(T values[], int length) {\r\n  if (length == 0)\r\n    return nullptr;\r\n\r\n  LN<T>* front      = new LN<T>(values[0]); //length != 0 so at least one value\r\n  LN<T>* rear_cache = front;\r\n\r\n  for (int i=1;   i<length;   ++i)\r\n    rear_cache = rear_cache->next = new LN<T>(values[i]);\r\n\r\n  return front;\r\n}\r\n\r\nNotice that rear_cache = rear_cache->next = new LN<T>(values[i]); uses a\r\nchained = to extend the linked list with a new node: the new node is now the\r\nonly one in the linked list whose ->next is nullptr, and rear_cache refers to\r\nit, and extends the linked list on the next iteration by storing something new\r\ninto its next. We could accomplish these same two action by two statements\r\n\r\n    rear_cache->next = new LN<T>(values[i]);\r\n    rear_cache = rear_cache->next;\r\n\r\nbut they would have to be executed in this order (why?)\r\n\r\nIn build_linked_list_fast, each loop iteration requires just a constant amount\r\nof work, O(1), so building an N node linked list is N*O(1) =  O(N).\r\n\r\nThe build_linked_list_fast function cries out to be hand simulated on a small\r\nexample (say building a list with 4-6 list nodes). Do so.\r\n\r\nFinally, if we are inside a Queue implementation that stores a linked list\r\nusing the instance variable \"front\", as well as a cache instance variable\r\n\"rear\", we can easily enqueue a value at the rear by using the following code.\r\nBy using \"front\" and \"rear\" we have covered both hot-spots in a Queue: the \r\nfront where values are dequeued and the rear where values are enqueued.\r\n\r\nint enqueue (const T& element) {\r\n  if (front == nullptr)\r\n    front = rear = new LN<T> (element,nullptr);\r\n  else\r\n    rear = rear->next = new LN<T>(element,nullptr);\r\n\r\n  ...other code for stuff like ++used and ++mod_count\r\n}\r\n\r\nLinked list processing isn't easy, so you should check the code you write by\r\ndoing small hand simulations of it, in a few different situations. Following\r\nthis advice will improve your ability to hand simulate linked list code quickly\r\nand improve your ability to debug linked list code. We will spend some time\r\nsimulating the following code. It is not obvious what it does, but we should be\r\nable to update the picture by executing this code to learn what it does. Doing\r\nso quickly and accurately proves that we have a good understanding of the\r\nbasic operations on linked lists.\r\n\r\nAssume LN<int>* x and x points to a linked list with 4 or 5 values.\r\n\r\n  LN<int>* answer = nullptr;\r\n  while (x != nullptr) {\r\n    LN<int>* to_move  = x;\r\n    x                 = x->next;\r\n    to_move->next     = answer;\r\n    answer            = to_move; \r\n  }\r\n    \r\n  x = answer;\r\n\r\n\r\nMore Linked List Processing:\r\n\r\n(1) The following function searches an unordered linked list looking for a \r\nspecified value. We use just the standard for loop to traverse it, and return a\r\npointer to the first node found that contains the searched-for value (there may\r\nbe many such nodes with that value). Note that we use nullptr just as we use -1\r\nwhen returning array indexes: it means the value was not found.\r\n\r\ntemplate<class T>\r\nLN<T>* find (LN<T>* l, T to_find) {\r\n  for (LN<T>* p = l;   p != nullptr;   p = p->next)\r\n    if (p->value == to_find)\r\n       return p;\r\n\r\n  return nullptr;\r\n}\r\n\r\nFor an ordered linked list (assume an ordering of values smallest to largest)\r\nwe can also stop and report a failure as soon as we examine a value strictly\r\ngreater than the one that we are searching to find (or, of course, if we run\r\nout of nodes to examine). The continuation condition in the resulting for loop\r\nis more complicated, but it can terminate more quickly (without examining every\r\nvalue in the linked list, unlike in the case of an unordered list).\r\n\r\ntemplate<class T>\r\nLN<T>* find (LN<T>* l, T to_find) {\r\n  for (LN<T>* p = l;   p != nullptr && p->value <= to_find;   p = p->next)\r\n    if (p->value == to_find)\r\n       return p;\r\n\r\n  return nullptr;\r\n}\r\n\r\nNotice that the continuation condition is that both (a) p != nullptr, and\r\n(b) p->value <= to_find. Recall that && is a short-circuit boolean operator:\r\nif the first condition is false, then the value of the entire boolean\r\nexpression is known to be false, so the second condition isn't even tested; if\r\nit were tested, it would crash the program, because p->value cannot be computed\r\nwhen p stores nullptr. Thus, the order in which the conditions are tested is\r\nvery important to the test working correctly.\r\n\r\n\r\n(2) The following function removes the first node storing a specific value from\r\na linked list. What is most interesting here is that when we remove a node, we\r\nwe must change the ->next instance variable in the node BEFORE the one that we \r\nare removing: if (see the picture) we remove the node storing the value 7, then\r\nwe must change the ->next in the node storing the value 2, making its ->.next\r\nrefer to the node containing 4 (the ->next in the node storing the value 7).\r\nThus, if we now follow the links, we visit nodes storing 5 then 2 then 4. Also\r\ninteresting is that we DON'T do this if the node we want to remove is at the\r\nfront of the linked list (instead we change l to point to the second list node).\r\n\r\nThere are two basic approaches to solving this \"node before\" problem: the first\r\nuses look-ahead: a single pointer that checks values \"one after\" the node it\r\ncurrently points to; when it finds the node to remove one ahead, it changes the\r\n->next in the node to which it points. That code is\r\n\r\ntemplate<class T>\r\nLN<T>* remove_lookahead (LN<T>* l, T to_remove) {\r\n  if (l == nullptr)\r\n    return nullptr;\r\n\r\n  if(l->value == to_remove) {\r\n    LN<T>* to_delete = l;\r\n    l = l->next;\r\n    delete to_delete;\r\n  }else{\r\n    for (LN<T>* p = l;   p->next != nullptr;   p = p->next)\r\n      if (p->next->value == to_remove) {\r\n        LN<T>* to_delete = p->next;\r\n        p->next = p->next->next;\r\n        delete to_delete;\r\n        break;\r\n      }\r\n  }\r\n\r\n  return l;\r\n}\r\n\r\n-----\r\ndelete interlude: PC/Mac Incompatibility based on \"undefined\" behavior\r\n\r\nNote that we use delete [] to deallocate (return to heap managed storage) an\r\narray of values; we use delete to deallocate (return to heap managed storage)\r\nan object like LN<T>. Once we delete an object (delete the object a pointer\r\npoints to) we should NEVER follow that same pointer (or anything else leading\r\nto the deallocated object) to access data stored in the deallocated object:\r\nthat object is \"gone\" and trying to access its data is \"undefined\" (which we\r\nhave seen before: no behavior is guaranteed by all C++ compilers).\r\n\r\nOn Macs, we can often get to a deallocated object and use its values (although\r\nwe NEVER SHOULD); on a PC, doing so would immediately and silently terminate\r\nthe program. We are grading on PCs, so Mac users should be very careful that\r\nthey do not use information in deallocated objects: such code might work on\r\ntheir computer, but will not work on the grader's computer.\r\n-----\r\n\r\nAs with add_front and add_rear functions, this remove function returns a\r\npointer to the head of the list in which the removal occurred. It should be\r\ncalled like x = remove_lookahead(x,value);\r\n\r\nAs with the code for adding at the rear of a list, there is a special case for\r\n(a) an empty linked list (l == nullpt) and here there is a special case for\r\n(b) for removing a value that happens to be the first value in a linked list.\r\nNote that we explicitly delete (recycle the storage for) the LN<T> containing\r\nthe to_remove value.\r\n\r\nTry hand simulating this code on an empty list, and a 4-6 node linked list,\r\nremoving the first, last, some middle value, and the end value. Especially\r\ninteresting is the code\r\n\r\n  p->next = p->next->next;\r\n\r\nwhich says put into the next field in the node p refers to, whatever is in\r\nthe next field of the node coming after the node that p refers to; this removes\r\nfrom the linked list the node after the one p refers to.\r\n\r\nThe second approach to solving this \"node before\" problem is to use an extra\r\nvariable: p to traverse through the nodes in the linked list looking for the\r\nnode with the value to remove, and a second variable (prev) that remembers where\r\nthe first one \"just was\" (sometimes called a ghost pointer). It is the ->next\r\nfield in the node referred to by this prev variable that is changed.\r\n\r\ntemplate<class T>\r\nLN<T>* remove_ghost (LN<T>* l, T to_remove) {\r\n  if (l == nullptr)\r\n    return nullptr;\r\n\r\n  if(l->value == to_remove) {\r\n    LN<T>* to_delete = l;\r\n    l = l->next;\r\n    delete to_delete;\r\n  }else{\r\n    LN<T>* prev = l;\r\n    for (LN<T>* p = l->next;   p != nullptr;   prev = p, p = p->next)\r\n      if (p->value == to_remove) {\r\n        prev->next = p->next;\r\n        delete p;\r\n        break;\r\n      }\r\n  }\r\n\r\n  return l;\r\n}\r\n  \r\nNotice the initialization and update part of the for (...) initializes/updates\r\ntwo pointers, not just one (the is_sorted function used this double update\r\ntoo; in fact the first version of is_sorted used something like a \"ghost\"\r\npointer; the second version used a lookahead pointer). The variable prev always\r\nrefers to the node one before the variable p refers to. Note that we delete\r\n(recycle the storage for) the LN<T> containing the to_remove value.\r\n\r\n\r\n(3) The following function copies an N node linked list in O(N), by caching the\r\nrear of the list (as we did in build_linked_list_fast). note that we do not\r\ncopy the value stored in the linked list, but create a new link list that\r\nshares those values.\r\n\r\ntemplate<class T>\r\nLN<T>*  copy (LN<T>* l) {\r\n  if (l == nullptr)\r\n    return nullptr;\r\n\r\n  LN<T>* front      = new LN<T>(l->value);  //Guaranteed to exist: l != nullptr\r\n  LN<T>* rear_cache = front;\r\n\r\n  for (l = l->next;   l != nullptr;   l = l->next)\r\n    rear_cache = rear_cache->next = new LN<T>(l->value);\r\n\r\n  return front;\r\n}\r\n\r\nAnother way to read data from a file and put it into a linked list in that\r\norder, or copy a linked list, is to read/copy it in reverse (adding new values\r\nat the front, not the rear, and then reverse all the list nodes in the linked\r\nlist.\r\n\r\n\r\n(4) The following function determines whether two linked lists store the same\r\nvalues in the same order. It requires traversing both linked lists\r\nsimultaneously (stopping when either is exhausted): any unequal values mean the\r\nlinked lists are unequal; and if one is exhausted before the other, they are\r\nunequal. Said another way, they are equal if they have the same size and all\r\nthe same values in the same order.\r\n\r\ntemplate<class T>\r\nbool equals (LN<T>* l1, LN<T>* l2) {\r\n  for (; l1 != nullptr && l2 != nullptr;   l1 = l1->next, l2 = l2->next)\r\n    if (l1->value != l2->value)\r\n      return false;\r\n\r\n  return l1 == nullptr && l2 == nullptr;\r\n}\r\n\r\nIn the next lecture we will see how & references can simplify writing some of\r\nthe linked list processing code written here. Java/Pythong don't support &\r\nreferences so the code here is as simple as Java/Python linked list processing\r\ncode gets. In the next lecture we will also learn about some special kinds of\r\nlinked lists that are not linear linked lists: circular linked lists,\r\nheader/trailer linked lists, and doubly linked lists.\r\n\r\nIn a third lecture we will examine recursion and see how linked lists are\r\ndefined and processed recursively. Suprisingly, once you get the hang of\r\nwriting recursive functions, they are often easier to write than iterative ones.\r\n\r\nLater, when we study sorting, we will see algorithms that work well for sorting\r\narray and linked list representations of data.\r\n", "encoding": "ascii"}