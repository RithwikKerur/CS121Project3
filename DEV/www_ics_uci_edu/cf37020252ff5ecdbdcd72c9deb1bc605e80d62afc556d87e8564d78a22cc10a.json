{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990831.txt", "content": "WebDAV Advanced Collections Minutes August 31, 1999\n\nATTENDING: Judy Slein, Geoff Clemm, Jim Whitehead, Chuck Fay, Jason \nCrawford\n\nACTION ITEMS\n\nAll: Check the paragraphs on POST and PUT in Bindings, Section 10.\n\nJudy: Take locking decisions to the mailing list.\n\nLOGISTICS\n\nNo meeting next week.  We'll try to progress by e-mail.\n\nNext meeting (even though Jim Whitehead will be away) September 14.\n\nProposed general WebDAV meeting at IBM / Chapel Hill in October.\n1 day WebDAV, 1/2 day DASL, 1 day versioning.\n\nISSUES\n\nISSUE 2: YOU CAN'T PREVENT PEOPLE FROM DELETING COLLECTIONS ALONG THE\nPATH OF THE REQUEST-URI, BECAUSE WRITE LOCKS WON'T BE THE ONLY KIND OF\nLOCK IN THE WORLD.  IMAGINE A TYPE OF LOCK THAT PREVENTS AN UPDATE BUT\nNOT A DELETE OR MOVE.\n\nAGREED: We'll change the language related to protecting the\nRequest-URI to SHOULD.  We intend this to protect the entire path,\nincluding the final segment.  This does impact the definition of write\nlocks in RFC 2518, which will have to change.  It's no longer that a\nwrite lock MUST prevent MOVE and DELETE, but that it SHOULD prevent\nthem.\n\nJim: It's not necessary to worry about all the kinds of locks people\nmight invent.\n\nGeoff: Would prefer just lock resource, and not to protect the path of\nthe Request-URI.  He thought that in the past Yaron wanted to guarantee \nthat the lock owner could still use Request-URI.  So that's why we put\nin this extra constraint.\n\nJason: In some situations you need to \"lock\" the namespace, especially\nwhen crossing servers.\n\nGeoff: It's awkward that the namespace \"lock\" is on a number of individual\nbindings in different places.  And the way each segment of the Request-\nURI is affected depends on the lock type.  As people define different\nkinds of locks, we have to revisit how protecting the Request-URI \ninteracts with those new kinds of locks.\n\nGeoff: What is the overhead of protecting the Request-URL?  You have to store \nthe Request-URL with the lock token.\n\nJim: Even if there is some inconvenience to preserving the Request-URI, we\nshould do so to meet the user expectation of being able to use \nrequest-URI.\n\nJim: If we had a different id for the resource, this wouldn't be an issue.\n\"the one true name\" \n\nGeoff: This is too hard to tackle.  The semantics would be\nhard to figure out.  For example, suppose one client uses \"TodaysDoc\"\nand another uses \"July23Doc\".  Does the true name change over time?  It\ndepends on implementation choices, not on a dependable semantic.\n\nJim: Sometimes you want to be able to figure out whether 2 urls point to \nthe same resource.  It doesn't matter if the answer changes over time.  \nYou only care about now.  Why do people want this? For a static\nresource, want to be able to make links or RDF assertions about them. \nYou want to know that the 2 urls point to the same thing, so that you\nknow that an assertion about url a is an assertion about url b.\n\nJudy: We could constrain the stuff about protecting the Request-URI to write \nlocks, and leave behavior for other kinds of locks undefined.\n\nJason: We will probably end up with more kinds of locks, and will need to \nrevisit this when they come along.\n\nGeoff: Locks can disappear anyway through administrator action, so it's not so \nimportant to protect the namespace.  It's highly unlikely that anyone\nwill remove a binding somewhere above the locked resource in the \nRequest-URI anyhow.\n\nJim: Since it's not a common case for a name to disappear, it's better to\nsimplify.  Take out the requirement that the Request-URI be protected.\n\nGeoff: In versioning, a resource is unwritable unless it is checked out, so \nit decreases even further the chance of something getting changed on \nthe Request-URI path.\n\n\nGeoff: Doesn't like the definition of write lock in RFC 2518 preventing \nMOVE and DELETE, since those operations affect the parent collection,\nnot the locked resource.\n\nJim: A binding is a relation, so it really affects both ends of the\nrelation, the parent collection and the locked resource, when you do\na MOVE or a DELETE.\n\nGeoff: Wants it to affect only the collection. Otherwise, you have to \nchange the state of the target resource and create a new version of it \nwhen you do a MOVE.\n\nChuck: No, a write lock needs to prevent MOVE and DELETE.\n\nGeoff: Making one URL segment special is bad, from conceptual point of \nview and implementation.  If we say we are not going to protect the\nRequest-URI -- we allow non-lock-holders to MOVE or DELETE bindings\nhigher in the path -- then we need to allow MOVE and DELETE on the final\nsegment of the Request-URI.\n\nThere's value in being able to protect the path, but complexity is too\nmuch.\n\nJim: It's ok to not protect parent paths, but we violate user \nexpectations if we don't protect the name of the resource itself. \nImplementation complexity for that is not great. Don't let anyone move \nor delete the locked resource out from under the lock holder.\n\nJason: Agrees that we should be consistent and protect either the whole\npath or none of it.\n\nJim: We are not defining a pure system, but one used by people with  \nexpectations that are not necessarily pure.\n\nChuck:  We could say that an optimal implementation would lock whole \npath, but make it a SHOULD.\n\nGeoff: The server could choose complexity vs user expectation.\n\nJim:  Really we would want MAY for the path above the locked resource,\nand SHOULD for the complete Request-URI (identifier of the locked\nresource itself).\n\nGeoff: Let's make it SHOULD all the way up.\n\nJason: What makes it hard to implement protecting the Request-URI?\n\nGeoff: In versioning, you control what appears in a workspace by version\nselection rules that pick out which revision of each collection is to\nbe included.  If then you have to protect a name of a locked resource,\nit becomes hard to evaluate the VSRs.  You have to check both lock\nstate and the VSR.\n\nISSUE 1: INCOMPATIBILITY BETWEEN RFC 2518 LOCK/MOVE BEHAVIOR AND MOVE\nSEMANTICS DEFINED FOR BINDINGS.\n\nAGREED: \nFor MOVE, if the source resource is locked (the lock is not inherited from\na parent collection), the lock moves with it to the destination.  If the \ndestination resource is locked (the lock is not inherited from a parent\ncollection), its lock is lost.  \nFor MOVE, if it's the parent collections that are locked, the resource\nbeing moved inherits the lock of the destination collection.\nIf a collection is MOVEd, and there are some locked resources in that\ncollection, the locks on those resources get moved.\nWe don't require support for cross-server MOVEs where the source resource\nis locked, but we will define an optional lock header for use in\nresponses, so that the destination server can change the lock token and\nreturn the new token with its response.  If the server allows a cross-\nserver MOVE but elects not to return a lock token value, the client\ncan do lock discovery to find it out. \nIf a cross-server MOVE is allowed in a case where there are multiple\nbindings to the source resource, and the source resource is locked, the\nresult will be that the resource is locked on both servers with the same\nlock token in both places.  (If the same lock token cannot be used, the\nMOVE must fail.\nFor COPY, any locks at the destination are deleted, and no new locks are\ncreated at the destination.  After the COPY, there will be no locks at\nthe destination except what is inherited from above.\n\nThis is a reversal of the position taken in RFC 2518.\n\nRFC 2518 Section 7.7 is clear for cases where a resource is moved into\na locked collection: the resource inherits the lock on the parent\ncollection at the destination.\n\nThere is controversy about whether it also is intended to apply to cases\nwhere a resource is moved to a location where the individual resource\nis locked.\n\nJim: Section 7.7 was intended to apply to individual locks: if the \ndestination is locked, the resource would be locked after the move.\nThis is inconsistent with statements elsewhere in RFC 2518 that locks\ndo not survive a DELETE and that MOVE is equivalent to COPY + DELETE\nwith some fixup.  The intent was that 7.7 would override these \nstatements for the particular case where a resource is being moved to\na locked location.\n\nGeoff favors getting rid of Depth locks, so that we would only have to\nbe concerned about singleton locks.\n\nJason: We should at least allow lock to move with the resource, maybe\nby providing a header.\n\nGeoff: Why was the decision made to remove locks on move? Cross-server \ncases -- the destination server might change the lock token.  Servers\nare allowed to use whatever algorithm they like for generating lock\ntokens, as long as they are guaranteed unique for all space and time.\n\nGeoff: Depth locks across servers are problematic.  Think about moving\na tree that spans multiple servers.\n\nJim: It's much simpler to have the lock disappear after a move.\n\nDoes a lock follow along with the move? everyone thinks so except Jim\nand Yaron.  ClearCase does bring lock along.  Binding semantics\nmaks it harder to say that the lock disappears.  \n\nJason: If we say that we are going to protect the Request-URL and \nthe lock owner performs a move, do we then protect the destination URL?\n\nChuck: On a cross-server move, is the destination server required to \nrecognize the same lock token after the move?  RFC 2518 lets servers\ndecide how they want to structure lock tokens, as long as the token is\nguaranteed unique.  So the destination server might not want to use the\noriginal token.  There are choices about how we might deal with this:\nhave the server refuse to MOVE the resource if it can't use the same\ntoken, or let servers change the token and provide a way for clients to \ndiscover the new token.\n\nWhat if there are locks on several resources in a tree that is being\nmoved across servers (but the tree itself is not locked)? Move /foo/a/ \nto a different server, when /foo/a/x.html is locked, /foo/a/w.html is \nlocked.  The destination collection would not be locked, but the\nindividual resources would still be locked.  If the tokens changes, you\nwould not report the changed tokens in a header.  The client would just\nhave to do a PROPFIND to discover the new lock tokens.\n\nWhat if there is a second binding to a resource being moved across\nservers? After the move, it would be locked at both source and \ndestination (on different servers).  Most likely the server would not\nallow the move in that case.  You can probably only move a resource\nacross servers if there is only one binding or if the resource is not \nlocked.  \n\nGeoff: As long as we support depth locks, we can get around the problems\nof cross-server MOVEs by having clients lock the parent at the \ndestination, then lock the child after it is moved. \n\nIf client wants to maintain lock on copy / move but not have null \nresource at the destination, it can lock parent at destination, lock \nchild after it is moved, then unlock parent.\n\nJudy: I don't think you can lock the child while its parent is locked\nwith a depth lock.  You can only have one lock on a resource at a time.\n\nUntil we started discussing cross-server cases, we had consensus that\nsource locks are preserved over a MOVE.\n\nJudy: There may be some disagreement on list.  When we looked at scenarios,\nKevin thought the lock at the destination should always be the one that\nsurvives a move.  Jim Amsden felt that no lock should be present after\na move. \n\nOthers: That's because the question was not posed in the right way.\n\nWe should take our proposal to the list for discussion.\n\nISSUE 3: CYCLES\n\nAGREED: We will allow cycles to be created.\nAGREED: We will provide an error code that can be used if a loop is\nencountered while processing a request, but we won't require servers to\nfail requests if they encounter loops.\n\nThere are 2 questions:  Should we allow cycles to be created in the\nfirst place?  If so, should we require failure when a cycle is\nencountered in Depth: infinity processing?\n\nGeoff: We should allow cycles to be created.  This is cheaper than \nrequiring servers to check.  \n\nYou pay now or later.  If you don't pay at creation time, you pay later\nwhen doing Depth: infinity processing.\n\nBut if you wait till later, you are in a situation where you are doing\nthe traversal anyway, so the incremental cost is small.\n\nGeoff: At Oslo, by the end of the discussion people agreed that it is\nreasonable to allow cycles to be created.\n\nGeoff: There are also cases where cycles are required.  In versioning,\nactivities may contain versions and may contain other activities.  You\nmay want cyclic relationships in some cases.  Versioning proposes to use\nbindings for this.\n\nShould we require failure if a cycle is encountered during depth\ninfinity processing?  It's not always a problem.  It's not a problem for\nMOVE except maybe in cross-server cases.\n\nJason: We should not require failure, but some loops may be a problem,\ndepending on the operation and on whether the Request-URI is involved\nin the loop.  If you are trying to perform a depth lock and you encounter\na loop, the lock would fail.\n\nJim: The operation would eventually terminate, but the behavior would\nbe unexpected behavior.\n\nSometimes the server won't be able to perform the operation because of\na cycle, and sometimes the server might decide it's too much trouble to\nperform the operation because of a cycle.  We need to define some error\ncode \"can't do because of cycle\" and provide a way to identify the path\nthat's the problem.\n\nShould we just make the error code available, but not specify when it\nmust be used?\n\nWe should probably specify what to do in a PROPFIND.  Use the error\ncode for the URL that caused the problem, but complete the PROPFIND.\n\nShould we distinguish between \"can't do\" and \"detected and moving on\"?\nWhat family of error code to use?  It may not be a client error, but \nit's not really a server error.  There's no category that really fits.\nSometimes the loop may be created intentionally, sometimes accidentally,\nsometimes maliciously.\n\nSo we'll just use a server error code, recognizing that the category is\nnot an ideal fit. If the error code is at the top level, it was fatal \nand the server didn't perform the operation. If it's inside a Multi-\nStatus response, it's only terminating that loop and does not indicate\nfailure of the operation as a whole.\n\nISSUE 4: WHETHER TO REPLACE DAV:bindings WITH A METHOD.\n\nAGREED: We'll keep the DAV:bindings property.\n\nGeoff: This is probably part of Yaron's general aversion to live \nproperties.  We should not do anything about this property alone.  If\nwe ever do get rid of live properties altogether, that will be the time\nto get rid of DAV:bindings.  \n\nISSUE 5: WHETHER TO REPLACE THE Position HEADER WITH A METHOD.\n\nAGREED: We'll keep the Position header.\n\nNo, setting a member's position really is part of the operation of\nadding it to the collection.\n\nIf you separate setting the position from adding the member, someone \ncould sneak in and lock the collection between the time you add the \nmember and the time you attempt to set its position in the ordering.\n\nISSUE 6: WHETHER TO GET RID OF THE \"BINDINGS AND OTHER METHODS\" SECTION.\n\nAGREED:  We keep this section.\n\nNothing is ever obvious when it comes to bindings.\n\nMISCELLANEOUS\n\nJim: Do mailing list members understand why we think this functionality \nis important?\n\nGeoff: At Oslo, people assumed it is valuable.  No one raised the \nquestion.\n\nJim: We are running out of time.  Keith wants us to finish.  We'll have \nto make the case toKeith that there is wide desire for these specs.\n\nGeoff did not think Keith wanted to prevent them from being approved, \njust wants us to finish up.\n\nJim: On the next draft, each of us should find at least one other person\nwho commits to reviewing it on mailing list.  This will be evidence of\nwider interest than just the authoring team.\n\nJim: Proposes a general WebDAV meeting at the end of October.  Jim Amsden\nwould host it in North Carolina.  The proposal is for 1 day DAV, \n1/2 day DASL, 1 day versioning.\n\nIssues that Jim sees needing attention:\n\nNeed continuing DAV support organization: interoperability, press, demos\n\nPlan for move from proposed to draft standard\n\nDecide what to do about remaining topics: acl, variants -- new working\ngroups?\n\nJim won't be able to contribute significantly after beginning of the\nyear, so we need transition plans.\n\n\n", "encoding": "ascii"}