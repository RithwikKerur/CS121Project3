{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990413.txt", "content": "Minutes 4/13/99\n\nAttending: Judy Slein, Geoff Clemm, Jim Davis, Jim Whitehead, Tyson Chihaya, Pete Carlson\n\nACTION ITEMS\n\nGeoff: Confirm with Yaron that he can accept the proposed semantics for MOVE.\nGeoff: Draft a definition of \"binding\".\nGeoff: Send a note to WebDAV discussing forests of references.\nGeoff: Send a note to WebDAV describing his MKRESOURCE proposal.\n\nJim W: Write up rationale for not using the approach of a separate URL for the reference.\n\nJudy: Revise spec in time for review before next week's meeting.\n\nISSUES TO REVISIT NEXT WEEK:\n\nSemantics of COPY for collections\nSemantics of MOVE\nServer-maintained orderings\nMKRESOURCE\n\nBINDINGS\n\nPoll: Geoff: bindings now (direct references eventually), Jim D: bindings, Judy: either way,\nJim W: bindings\nDecision: We will replace direct references with bindings.\n\nSEMANTICS OF BINDINGS\n\nSemantics of bindings created with BIND are the same as for any other binding.\n\nDELETE: Just removes the one binding that was the request-URI.\n\nMOVE: Proposal to use Geoff's mailnote, which extends John Stracke's thought --\n\nA \"MOVE source-URL target-URL\" has the logical effect of a\n\"BIND source-URL target-URL\" followed by a \"DELETE source-URL\".\nThis is logically equivalent to doing a \"COPY source-URL target-URL\",\nfollowed by a fixup stage that adjusts all the bindings to the source\nresource (except for source-URL) to be bindings to the new resource,\nfollowed by a \"DELETE source-URL\".\n\nJim W wants to think about this.  RFC 2518 was intentionally designed to force a new \nresource to be created on MOVE.  If you are in a repository where there is a consistent\nnamespace, you could use bindings, but if part of the namespace maps to a medium with\ndifferent characteristics, you want to create a new resource. E.g., in a Unix file system\nmoving across file systems, you can't create a hard link.\n\nGeoff:  People really think of move as new name. So to implement that if you move a resource\nto another server, you will create a new resource and do fixup. But think of the cross \nserver case as a special case rather than the other way around.  There are ways that MOVE\nbehaves very differently from COPY, for example, does the resource's id change, that's a key\narea where they shouldn't behave the same.\n\nJim W: Doesn't want us to change semantics of move.  Geoff: Clarify what we are doing by \nsaying you can think of it either as BIND/DELETE or as COPY/fixup/DELETE, and describe fixup\nstage. Jim W: Saying that you can think of it as just BIND/DELETE violates the design \nrationale for the original definition of MOVE.\nGeoff: The \"logically equivalent to\" clause in RFC 2518 means you don't have to create the \nnew resource, according to Yaron.  The end result just has to be as if you had done so.\nGeoff: Action item to confirm with Yaron that our proposal is ok. If Yaron is agrees, Jim W\nis ok with it.\n\nLOCK: Geoff proposes that we consider the set of bindings (segment name to resource) are \npart of the state of the resource and so get locked when the resource gets locked.\nJim W: Bindings are really relationships, so you can identify them at either end of the \nrelationship, and treat them as state of either object. RFC 2518 says that if you lock \na location in a namespace, this has side effects on the collection that contains that\nlocation. Geoff: Let's focus on locking the state, and assume that effects on collections \nwill be as before.  Jim W: ok for now.\nGeoff: The state of an advanced collection is just the segment names, not the absolute\nURLs. Whether there are multiple URLs for the collection above is orthogonal.\n\nCASE FOLDING\n\nJim W: Should we address leftover issues from RFC 2518? In particular, how to handle case \nmappings.  If a server is non-case-sensitive, the problem is how to define the collection so\nthat any permutation is a member of the collection, but you don't list every permutation in\nresponse to a PROPFIND.  Geoff has already tried and failed, and recommends punting.  \nCase folding differs from one language to another, some letters are identical in one \nlanguage but not in another.  How to define delete across such cases?  Agreed: We'll punt\non this issue.\n\nSTATE OF A COLLECTION\n\nGeoff wonders:  What is the state of a collection?  What changes cause a change in\nmodification date?  Can a collection have a body?  index.html. separate resource? \nWhat is the response to a GET on a collection?  Is it a separate resource (gotten by a\nredirect)? Or can there be an actual body of the collection?  Jim D: GET on collection is\nusually html fabricated automatically by the server fabricates. Exactly how the body is\nimplemented is irrelevant to us.  Jim W: machine-gen list is the body of the collection.\n\nGeoff wants a list of bindings to be part of the state of the collection, and any \nadd / delete /change to a binding changes the state of the collection, and changing the \nstate should affect modification date. Jim W is ok with that.  \n\nGeoff wants to differentiate between bindings, which he takes to be just the final segment\nof the URL, and collection members, which he takes to be absolute URLs.  He wants only the\nbindings to be part of the state of the collection, and the list of members (absolute URLs)\n*not* to be part of the collection's state.  So moving some\ncollection above it in the hierarchy or adding a binding to a point higher in the hierarchy\nwould not result in a change in the collection's state.\n\nJim W: It was the intent that all members of a collection are relative URLs, though\nthis was not explicit in RFC 2518.\n\nJim D: The binding from a URL to a resource is never part of the state of the resource \nitself -- the general rule subsumes this case.  Geoff: It would imply that the state of \na collection is not affected by a binding of that collection resource itself, but also \nthat the full URLs of immediate members are not part of the state of the collection either.\n\nGeoff; If we have a/b/c.html and b is bound to an advanced collection with just one member,\nand b contains only one binding (c.html to some resource), and if members of coll were \nguaranteed to be just relative names, he would be happy.  But if a member is the full url \n(a/b/c.html is the member) then he wants to be sure that mapping is not part of the\nstate of b.\n\nJim D: Members should always be relative urls -- otherwise you can't do relative pathnames,\nand can't have the same collection with 2 names.\n\nAgreed.\n\nJim W: Thinks he sent mail last fall defining collection members as single path segments.\n\nGeoff: A problem with this approach may come with locking.  People want the absolute-URL-\nto-resource mapping to be locked, and so they tend to think of collections as having \nabsolute URLs as members.  Jim D: Don't worry about objections till someone raises them.\n\nOTHER ISSUES ABOUT BINDINGS\n\nIt won't be possible to store properties on bindings. Agreed.\n\nYou can't bind to a nonexistent resource. Agreed, this is true by definition.\n\nDown-level deletes make sense.  Agreed.\n\nBindings are part of the state of collection. Agreed.\n\nJudy will make a pass through the spec converting direct references to bindings.\n\nREMAINING OPEN ISSUES\n\nDEFINITIONS\n\nWe will not include a definition of reference.  We will define binding and redirect\nreference.  A binding is an association of a segment name to a resource -- Geoff will draft\na definition and send it to the list.\n\nFORESTS OF REFERENCES\n\nForests of references: Geoff thinks his distinction between mappings and bindings will help\nhere.  He uses the term \"mapping\" for absolute-URL to resource relationships, and \"binding\"\nfor relative-URL to resource relationships. The introduction of a second binding for a\ncollection could produce a forest of new mappings, but no new bindings.  It certainly could\nproduce no new resources.  Geoff will send out a mailnote to WebDAV discussing this.\n\nSEMANTICS OF COPY\n\nGeoff thinks COPY with Depth=0 will produce a copy of the advanced\ncollection with all the same bindings as the source.\nJim W and Judy think this is wrong.  As defined in RFC 2518, copying a collection with\nDepth=0 results in an empty collection.  Only the collection's properties get copied.\nGeoff: But if the list of bindings is part of the collection's state, it should get copied\nwhen the collection is copied. \n\nGeoff: a LOCK with Depth=0 on collection prevents you from doing put into collection.  It\naffects your ability to do things to the collection members, so shouldn't COPY with Depth=0\nbring the members with it?\n\nJim W: RFC 2518 says that collections must support COPY with Depth=0 and with Depth=infinity,\nNo semantics for Depth=1 are specified.\nGeoff needs to be able to copy the bindings with the collection.  He thinks it's\nacceptable, though confusing, to use Depth=1 for this.  \nJim W and Judy want bindings to apply to any collection, not just advanced collections.  So\ndon't do anything that will break RFC 2518.  \nGeoff: It's strange just to copy a collection's properties, but it would be ok to define a\nDepth=1 COPY to use for copying members with the collection.\n\nIf on Depth=0 COPY we copy bindings, but not resources, is that consistent with RFC 2518?\n\nWe'll revisit this issue next week.  \n\nCOPY for redirect references: \nGeoff: If you COPY an individual redirect reference, respond with 302.  But if you COPY\nan advanced collection that contains redirects, copy the redirects.\nJudy: This is contrary to the sentiment at IETF -- keep it simple, do everything the same \nway.  \nGeoff: People will expect a new collection with redirects where approp.  \nJim W dosn't have a strong feeling.\nJudy: We've discussed this ad nauseam, we just need to make a decision.\nAgreed: We'll go with Geoff's proposal.\n\nPASSTHROUGH WITH BOOLEAN VALUES\n\nJudy: Now we've just defined a case (COPY on a collection with redirect references) where the\ndefault semantics is *not* to pass the method through.  In order to get the non-default\nbehavior, you would have to identify all the redirect references and copy their targets each\nindividually.  So it would be useful to have No-Passthrough=F in this case to get the non-\ndefault behavior in one request.\n\nGeoff: There may be other cases in the future where we want the default semantics to be\nNo-Passthrough, so providing boolean values is a good idea.  It gives us the freedom to \nchoose whatever default we want.\n\nEverybody likes the idea of renaming the header Passthrough to avoid the double negative\nand giving it boolean values.\n\nSEPARATE URL TO AFFECT REFERENCE\n\nJim has discussed this issue with Roy and will write up rationale for not accepting this\nsuggestion.\n\nDecision: No.\n\nGENERIC CREATION METHOD\n\nGeoff proposes using a generic MKRESOURCE method instead of MKREF.  This would be used to\ncreate resources of any new types (and maybe also existing types).\n\nJim W: You may want to do access control per type of resource, and that would be easier if\nyou had a different creation method for each resource type.\nJudy: Is it that much harder to figure out the resource type from a header?\nGeoff: Prefers to include the resource type in an XML body.\nJim W: Follow the principle of separation of concerns? Separate concerns by having a \nseparate method for each resource type.\nGeoff's product tried using separate creation methods and had to switch after the product\nwas in the field.\nJim W is willing to try it, but there was opposition in the past. Marshalling will be tricky.\n\nGeoff also wants to propose that there be an XML body, to allow a client to initialize \nproperties at the same time the resource is created.  The body would be identical to \nPROPPATCH's body. In versioning, there are stages in the creation of some things, and to \ninsure integrity, you need to initialize properties when you create the object.\n\nQuestions: Is resourcetype required? Is it part of the proppatch body?  Can the new method\nbe used to create collections instead of MKCOL? Is contenttype required?\nBefore, resourcetype was readonly.  This would make it writeable. \n\nPROPPATCH is very different from resource creation. Don't blend them. \n\nGeoff also wants overwrite to be possible.\nJim W: Doesn't want there to be side effects of setting properties. Geoff thinks that\ncreating resource and specifying its state is cleaner than letting server guess what its\nstate should be and patching it later.\n\nGeoff: Would like to see us use MKRESOURCE even if the versioning team was not considering\ndoing so.\n\nJim D and Jim W: send description to webDAV, then if they are ok with it, we can do it\n\nGeoff will send out a proposal this week.\n\nThe spec will continue to use MKREF for now.\n\nMKREF OVERWRITE\n\nShould we allow MKREF to overwrite an existing resource? What if the existing resource is \nnot a reference?  \n\nBIND can overwrite an existing binding, and if in doing that you destroy the last binding to\na resource, the resource goes away.  \n\nMKREF should be similar to PUT.  With PUT, you could prevent it from overwriting an existing\nresource by including If-Match: *.  That won't work for MKREF because there is no entity\ntag to check.  We could introduce a new header to prevent an overwrite.  We could just use\nthe Overwrite header defined in RFC 2518.  It has boolean values.\n\nDecision: By default MKREF does overwrite an existing resource at the request-URI.  \nOverwrite: F can be used with MKREF to prevent it from overwriting.  \n\nSERVER-MAINTAINED ORDERINGS\n\nLeave on the list a while longer.  See if they agree that DASL is the answer.\n\nRESPONSE TO GET WITH NO-PASSTHROUGH\n\nJim W: How should a server respond to GET with No-Passthrough?  We shouldn't use \n204 (No Content) because it was intended for use with POST.  204 gets returned if submitted \nform content and don't want the display to update. \nIf there's no content there, can't update anyway.  \nWe could specify 200 (OK) with Content-Length=0 and no Content-Type.  We could rule it out \nof order.  \nWhat if a server wants to define content that it will return, similarly to GET on a \ncollection today?  \n\nDecision: Leave it undefined.  \n\nORDERPATCH: should be atomic, just as PROPPATCH is.\n", "encoding": "ascii"}