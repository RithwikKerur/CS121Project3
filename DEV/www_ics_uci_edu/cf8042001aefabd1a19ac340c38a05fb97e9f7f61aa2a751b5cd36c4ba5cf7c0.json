{"url": "https://www.ics.uci.edu/~kay/courses/h21/hw/hw7.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<HTML>\n<HEAD>\n<META HTTP-EQUIV=\"GENERATOR\" CONTENT=\"Globetrotter 1.1.1\" />\n<META HTTP-EQUIV=\"AUTHOR\" CONTENT=\"David G. Kay\" />\n<META HTTP-EQUIV=\"UPDATED\" CONTENT=\"Thursday, November 10, 2005 3:43 AM\" />\n<TITLE>Seventh Homework</TITLE>\n<META HTTP-EQUIV=\"X-GLOBETROTTERDATA\" CONTENT=\"D22A250A\" />\n<META HTTP-EQUIV=KEYWORDS CONTENT=\"CS 1, CS1, assignment, Scheme\" />\n<META HTTP-EQUIV=\"DESCRIPTION\" CONTENT=\"An assignment for ICS H21, an honors first-quarter course in computer science in Information and Computer Science, UC Irvine, using How to Design Programs by Matthias Felleisen et al.\" />\n<META HTTP-EQUIV=\"COPYRIGHT\" CONTENT=\"Copyright &#169; 2001-2004 by David G. Kay.  All rights reserved.\" />\n<style type=\"text/css\">\n<!--\n.style1 {font-size: 10pt}\n.style2 {\tfont-size: 10pt;\n\tfont-family: \"Courier New\", Courier, monospace;\n}\n-->\n</style>\n</HEAD>\n<BODY BGCOLOR=\"#FFFFFF\">\n<P><font size=\"2\" face=\"Garamond\">ICS H21 &bull; UC IRVINE &bull; DAVID G. KAY &bull; FALL 2009</font></P>\n<P><FONT FACE=\"Garamond\" SIZE=6><B>Seventh<font face=\"Garamond\"> Homework </font></B></FONT></P>\n<P><FONT FACE=\"Garamond\" SIZE=4>This assignment is due at the start of lab on Monday, November 9. </FONT></P>\n<P>\n<FONT FACE=\"Garamond\" SIZE=4><B>(1) </B>Take a look back at the discussion of the\nfunction </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">reduce</FONT></span> </FONT><FONT FACE=\"Garamond\" SIZE=4>in\nsection 21.5.  (</FONT><span class=\"style1\"><FONT FACE=\"Courier New\">Reduce</FONT></span><FONT FACE=\"Garamond\" SIZE=4> is sometimes called </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">accumulate</FONT></span><FONT FACE=\"Garamond\" SIZE=4> or </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">foldr</FONT></span><FONT FACE=\"Garamond\" SIZE=4>,\nsometimes with the arguments in a different order. In DrScheme, the predefined function is named </FONT><span class=\"style2\">foldr</span><FONT FACE=\"Garamond\" SIZE=4>.)  Using </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">foldr/reduce</FONT></span><FONT FACE=\"Garamond\" SIZE=4>, </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">map</FONT></span><FONT FACE=\"Garamond\" SIZE=4>,\nand </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">filter</FONT></span><FONT FACE=\"Garamond\" SIZE=4>,\nyou can define many powerful operations very compactly, without explicit\nrecursion.  For example, suppose we have a list of restaurant (</FONT><span class=\"style1\"><FONT FACE=\"Courier New\">rrant</FONT></span><FONT FACE=\"Garamond\" SIZE=4>)\nstructures as we&#39;ve used in class before; call that list RL.  To produce\na list of the names of the cheap Thai restaurants in RL, we only need to\nsay </FONT></P>\n<P><font face=Courier>(map rrant-name (filter cheap? (filter Thai?\n  RL)))</font><FONT FACE=\"Garamond\" SIZE=4>.</FONT></P>\n<P> <FONT FACE=\"Garamond\" SIZE=4>To calculate the average price of the cheap\n  Thai restaurants, we can say </FONT></P>\n<P><FONT FACE=\"Courier\">(local ((define cheap-thai-restaurant-prices<br />\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map rrant-price (filter cheap? (filter Thai? RL)))))<br />\n  &nbsp;&nbsp;(/ (foldr + 0 cheap-thai-restaurant-prices)<br />\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(length cheap-thai-restaurant-prices)))</FONT></P>\n<P> <FONT FACE=\"Garamond\" SIZE=4>(In the above example, note that using the\n  local expression saves us from computing the list of prices two separate\n  times.)  If you have trouble figuring out how these expressions work, first\n  make sure you understand </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">map</FONT></span><FONT FACE=\"Garamond\" SIZE=4>, </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">filter</FONT></span><FONT FACE=\"Garamond\" SIZE=4>,\n    and </FONT><span class=\"style1\"><FONT FACE=\"Courier New\">foldr</FONT></span><FONT FACE=\"Garamond\" SIZE=4> individually (look at their &quot;contracts&quot;) and then look at what\n      each part of the expression returns, starting from the inside out.</FONT></P>\n<P> <FONT FACE=\"Garamond\" SIZE=4>Do each of the following problems.  Be aware, also,\n  that problems like these are likely to show up on exams.</FONT></P>\n<P> <FONT FACE=\"Garamond\" SIZE=4><B>(1.1)</B> Write the function </FONT><span class=\"style2\">convert-to-1</span><FONT FACE=\"Garamond\" SIZE=4> that takes one argument (of any type) and returns the number 1, no matter\n  what the argument is.  Next, use </FONT><span class=\"style2\">map</span><FONT FACE=\"Garamond\" SIZE=4> and </FONT><span class=\"style2\">convert-to-1</span><FONT FACE=\"Garamond\" SIZE=4> to define the function </FONT><span class=\"style2\">list-of-ones</span><FONT FACE=\"Garamond\" SIZE=4> that takes a list of items and returns a list of 1s that&#39;s\n    the same length as its argument.  Finally, use </FONT><span class=\"style2\">foldr</span><FONT FACE=\"Garamond\" SIZE=4> and <span class=\"style2\">list-of-ones</span> to\n      rewrite the last line of the <span class=\"style2\">average-price</span> code above without using <span class=\"style2\">length</span>. We did this in class; now you should be able to do it, too.</FONT></P>\n<P> <FONT FACE=\"Garamond\" SIZE=4><B>(1.2)</B> What is the result of evaluating\n  each of these expressions?</FONT></P>\n<ul>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(foldr\n    + 0 &#39;(1 2 3 4 5))</FONT></code></li>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(foldr\n    (lambda (a b) (+ b (if (even? a) a 0))) 0 &#39;(1 2 3 4 5))</FONT></code></li>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(foldr\n    cons &#39;() &#39;(Huey Dewey Louie))</FONT></code></li>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(foldr\n    max -1 &#39;(1953 1956 1949 1991 1964))</FONT></code></li>\n</ul>\n<P><FONT FACE=\"Garamond\" SIZE=4><B>(1.3)</B> Assume you have a function </FONT><FONT FACE=\"Courier\"><code>(interval\n  a b)</code></FONT><FONT FACE=\"Garamond\" SIZE=4> that returns a list of all\n    the integers between </FONT><FONT FACE=\"Courier\"><code>a</code></FONT><FONT FACE=\"Garamond\" SIZE=4> and </FONT><FONT FACE=\"Courier\"><code>b</code></FONT><FONT FACE=\"Garamond\" SIZE=4>,\n      inclusive (so that </FONT><FONT FACE=\"Courier\"><code>(interval 5 10)</code></FONT><FONT FACE=\"Garamond\" SIZE=4> would return </FONT><FONT FACE=\"Courier\"><code>(5 6 7 8 9 10)</code></FONT><FONT FACE=\"Garamond\" SIZE=4>).\n        (Re-)write the function </FONT><FONT FACE=\"Courier\"><code>factorial</code></FONT><FONT FACE=\"Garamond\" SIZE=4> using </FONT><FONT FACE=\"Courier\"><code>foldr</code></FONT><FONT FACE=\"Garamond\" SIZE=4> (and </FONT><FONT FACE=\"Courier\"><code>interval</code></FONT><FONT FACE=\"Garamond\" SIZE=4>),\n          without any explicit recursion.</FONT></P>\n<P> <FONT FACE=\"Garamond\" SIZE=4><B>(1.4)</B> Now, think back to the restaurant\n  collection program and assume we have a list (called </FONT><FONT FACE=\"Courier\"><TT>RL</TT></FONT><FONT FACE=\"Garamond\" SIZE=4>)\n    of the restaurant objects as described there.  For each of the following\n    expressions, describe in one English sentence what value it returns.  Don&#39;t\n    just say, &quot;It does a foldr of plus and zero\n    to a map of ... ;&quot; give a description of what the expression <I>means,</I> something you could put in a software catalog so that a prospective buyer\n    could find what he or she wanted.</FONT></P>\n<ul>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(foldr\n    + 0 (map (lambda (R) 1) RL))</FONT></code></li>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(filter\n    (lambda (R) (equal? &#39;Ethiopian (rrant-cuisine R))) RL)</FONT></code></li>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(/\n    (foldr + 0 (map (lambda (R) (rrant-price R)) RL)) <BR />\n    &#160;&#160;  &#160;   (foldr + 0 (map (lambda (R) 1) RL)))</FONT></code></li>\n  <li> <code><FONT FACE=\"Garamond\" SIZE=4>&#160;&#160;</FONT><FONT FACE=\"Courier\">(local\n    ((define PRL (filter (lambda (R) (equal? 'pizza (rrant-dish R))) RL))) <BR />\n    &#160;&#160;  &#160;  (/ (foldr + 0\n    (map rrant-price PRL)) <BR />\n    &#160;        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(foldr + 0 (map (lambda (R) 1) PRL))))</FONT></code></li>\n</ul>\n<P> <FONT FACE=\"Garamond\" SIZE=4><B>(1.5)</B> Using </FONT><FONT FACE=\"Courier\" class=\"style2\">map</FONT><FONT FACE=\"Garamond\" SIZE=4>, </FONT><FONT FACE=\"Courier\" class=\"style2\">filter</FONT><FONT FACE=\"Garamond\" SIZE=4>,\n  and </FONT><FONT FACE=\"Courier\" class=\"style2\">foldr</FONT><FONT FACE=\"Garamond\" SIZE=4>,\n    write an expression to return each of the following values without using\n    explicit recursion:</FONT></P>\n<ul>\n  <li> <FONT FACE=\"Garamond\" SIZE=4>a list of all the French and\n    Italian restaurants in RL</FONT></li>\n  <li> <FONT FACE=\"Garamond\" SIZE=4>a list of all the (best) dishes\n    served at the French and Italian restaurants in RL; it's okay for this list\n    to have duplicates in it, though you may attempt to remove them if you'd like\n    (as it can be done without explicit recursion)</FONT></li>\n  <li> <FONT FACE=\"Garamond\" SIZE=4>a list of all the restaurants\n    in RL whose best dish costs between $10.00 and $20.00 (inclusive)</FONT></li>\n  <li> <FONT FACE=\"Garamond\" SIZE=4>the name of the lowest-priced\n    French restaurant in RL</FONT></li>\n  <li> <FONT FACE=\"Garamond\" SIZE=4>a list of all the restaurants\n    in RL, where every French restaurant whose best dish&#39;s price is less\n    than the average (price of best dishes at French restaurants) has its price\n    changed to that average price</FONT></li>\n</ul>\n<P> <FONT FACE=\"Garamond\" SIZE=4><B>(2)</B> Chapter 25 talks about recursive\n  algorithms that don&#39;t follow a conventional template or formula. Chapters\n  26, 27, and 28 continue this theme.  You can certainly skip sections 27.3,\n  27.4, and 27.5.  The discussion of backtracking in Chapter 28 is something\n  you&#39;ll see in ICS H23.</FONT></P>\n<P><FONT FACE=\"Garamond\" SIZE=4><B>(3)  </B>Intermezzo 5 (Chapter 29) of the\n  HtDP text talks about O-notation and vectors.  For a preview of topics in\n  ICS H22, look at exercises 29.2.1, 29.2.2, and 29.2.3; you&#39;re not responsible\n  for those exercises this quarter, though.</FONT></P>\n<P><FONT FACE=\"Helvetica\" SIZE=1>Based in part on ICS H21assignments by David\nG. Kay from Fall 2001; modified by David G. Kay, Fall 2004&ndash;Fall 2009.</FONT></P>\n<HR />\n<FONT FACE=\"Garamond\"><A HREF=\"http://www.ics.uci.edu/~kay/\">David G. Kay</A>, <a href=mailto:kay@uci.edu>kay@uci.edu</A> </FONT><span><br />\n<font size=\"2\" face=\"Garamond\">\n<!-- #BeginDate format:fcAm1a -->Saturday, November 7, 2009 6:11 AM<!-- #EndDate -->\n</font></span></BODY>\n</HTML>", "encoding": "ascii"}