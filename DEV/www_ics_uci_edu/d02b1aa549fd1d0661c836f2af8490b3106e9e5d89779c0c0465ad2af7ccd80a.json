{"url": "https://www.ics.uci.edu/~willmlam/teaching/cs175_w12/Mancala/README.html", "content": "<h3>Changelog</h3>\n\n<ul>\n<li>02/29/2012: Tiny change to TermGame so that a gs.copy() is passed into the getMove() method of a player for safety reasons.</li>\n<li>02/24/2012: Added an actionsBeforeDeletion() method for use when a player class is no longer going to be used. More details on its usage and reason in TermGame.java</li>\n<li>02/08/2012: Fixed a bug where the second player could keep making pie moves as long as it never makes a different move. (Thanks to a student for pointing this out!)</li>\n<li>01/26/2012: Changed to feature added yesterday to have the method take in the game state instead. This should allow for more flexibility by providing the entire final state as information.</li>\n<li>01/25/2012: Added a method to MancalaPlayer which allows it to do something after the game ends. This can be used to provide feedback to the player for learning purposes.</li>\n<li>01/23/2012: Fixed a bug in KalahGameState where a grab was not occuring when it lands on the first bucket after the opponent's.</li>\n<li>01/21/2012: Modified the interactive_Player class so it works in Eclipse.</li>\n<li>01/18/2012: Added a version of Kalah using the pie rule (KalahPieGameState).\nRemoved \"winner\" fields from GameState classes.</li>\n<li>01/14/2012: Initial release.</li>\n</ul>\n\n<h3>About the Mancala Game Framework</h3>\n\n<p>This framework was adapted for Mancala by William Lam for the Winter 2012 \noffering of CS 175, taught by Max Welling. The code was originally designed \nfor Connect Four, provided by Alex Ihler.</p>\n\n<h3>Classes/Interfaces</h3>\n\n<pre><code>MancalaGameState (abstract)\n|- KalahGameState\n|- OwareGameState\n|- KalahPieGameState\n</code></pre>\n\n<p>Use one of the subclasses to decide on the Mancala variant.</p>\n\n<pre><code>MancalaPlayer (interface)\n|- random_Player\n|- interactive_Player\n</code></pre>\n\n<p>Implement the MancalaPlayer interface to create your AI routine. The \nname of your class should be formatted as YourClassName_Player.</p>\n\n<pre><code>TermGame\n</code></pre>\n\n<p>TermGame provides an example of how to use MancalaGameState and \nMancalaPlayer. It uses reflection to instantiate the state and player classes \nbased on command line parameters. We will use a similar main class to \nthis to run the tournament.</p>\n\n<pre><code>The command-line parameter format is: \njava TermGame &lt;GameType&gt; &lt;StartingStones&gt; &lt;Player0Class&gt; &lt;Player1Class&gt;\n\nEx: java TermGame Kalah 4 interactive random\nSet player 0 as the interactive player and player 1 as the random player, \nplaying the Kalah variant with 4 starting stones in each bucket.\n</code></pre>\n\n<p>Note that for Oware, repeated states are possible in the game tree. Since \nwe cannot assume that two players will make a consensus to end the game, \nwe will leave this decision up to the user interface running the game. (It \nshould detect a sequence of repeated states and end the main execution loop, \nif so.)</p>\n\n<h3>About the competition</h3>\n\n<p>For the competition, we will run a program using the <em>KalahPieGameState</em> class \nthat uses your AI player classes (and any of their dependencies) only.  It \nwill stop the execution of your player class without warning (and thus count \nas a forfeit) if it does not make a move within the time limit. You will be \nresponsible of keeping track of the time within your implementation.</p>\n\n<p>We will use a machine running Java 6 and your agent should use no more than \n1GB memory and a single thread.</p>\n\n<p>Time limit: 5 seconds per move</p>\n\n<p>Tournament format: Double round-robin \n(allowing players to take turns going first)</p>\n\n<p>We will then run the tournament as many times as we have time/resources for. \nThe hope is that learning agents will play differently as we \nrun more tournaments. The rankings will then be determined by the number of \nwins across all tournaments.</p>\n", "encoding": "ascii"}