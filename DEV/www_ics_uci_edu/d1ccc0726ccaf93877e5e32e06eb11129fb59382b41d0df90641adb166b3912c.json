{"url": "https://www.ics.uci.edu/~dan/class/267P/datasets/calgary/progp", "content": "program interval(input,output);\n{dataflow simulator for real interval arithmetic}\n\nconst\n\tIMem = 500; {number of instructions}\n\tDMem = 200;  {number of interval variables allowed}\n\tPar = 3;   {max number of paramters for an operator}\n\tMaxexp = 10; Minexp = -9;\n\tMaxinf =10000; Mininf =-10000; {Tied to values of Minman and Maxman}\n\tMaxman = 9999; Minman = -9999; {cannot exceed sqrt(maxint)}\n\tSplitman = 1000; {Smallest normalized mantisa}\n\tDigits = 4; {number of digits in mantissa}\n\ntype\n\tPositive= 0..maxint;\n\tState  = -1..99;  {Used for holding state of operator -1:done}\n\tOpType = (print,pr,tr,soln,readr,halve,halves,linh,mult,add,intgr,\nless,leq,noteq,sqrr,minr,maxr,modu,absr,trig,expr,lb,ub,copy,stop); {!!}\n\tPtr    = 1..DMem;\n\tLoc    = 1..IMem;\n\tLoc0   = 0..IMem;\n\tEdgeT  = (hout,lin,hin,lout); {Warning this order is important in}\n\t\t\t\t      {predicates such as gtS,geS}\n\tCardT  = (finite,infinite);\n\tExpT   = Minexp..Maxexp;\n\tManT   = Mininf..Maxinf; \n\tPflag  = (PNull,PSoln,PTrace,PPrint);\n\tSreal  = record\n\t\t    edge:EdgeT;\n\t\t    cardinality:CardT;\n\t\t    exp:ExpT; {exponent}\n\t\t    mantissa:ManT;\n\t\t end;\n\tInt    = record\n\t\t    hi:Sreal;\n\t\t    lo:Sreal;\n\t end;\n\tInstr  = record\n\t\t    Code:OpType;\n\t\t    Pars: array[0..Par] of 0..DMem;\n\t\t end;\n\tDataMem= record\n\t\t    D        :array [Ptr] of Int;\n\t\t    S        :array [Loc] of State;\n\t\t    LastHalve:Loc;\n\t\t    RHalve   :array [Loc] of real;\n\t\t end;\n\tDataFlags=record\n\t\t    PF\t     :array [Ptr] of Pflag;\n\t\t end;\nvar\n\tDebug  : (none,activity,post,trace,dump);\n\tCut    : (once,all);\n\tGlobalEnd,Verifiable:boolean;\n\tHalveThreshold:real;\n\tI      : array [Loc] of Instr; {Memory holding instructions}\n\tEnd    : Loc; {last instruction in I}\n\tParN   : array [OpType] of -1..Par; {number of parameters for each \n\t\t\topcode. -1 means no result}\n        ParIntersect : array [OpType] of boolean ;\n\tDInit  : DataMem; {initial memory which is cleared and \n\t\t\t\tused in first call}\n\tDF     : DataFlags; {hold flags for variables, e.g. print/trace}\n\tMaxDMem:0..DMem;\n\tShift  : array[0..Digits] of 1..maxint;{array of constant multipliers}\n\t\t\t\t\t\t{used for alignment etc.}\n\tDummy  :Positive;\n\t{constant intervals and Sreals}\n\tPlusInfS,MinusInfS,PlusSmallS,MinusSmallS,ZeroS,\n\tPlusFiniteS,MinusFiniteS:Sreal;\n\tZero,All,AllFinite:Int;\n\nprocedure deblank;\nvar Ch:char;\nbegin\n   while (not eof) and (input^ in [' ','\t']) do read(Ch);\nend;\n\nprocedure InitialOptions;\n\n#include '/user/profs/cleary/bin/options.i';\n\n   procedure Option;\n   begin\n      case Opt of\n      'a','A':Debug:=activity;\n      'd','D':Debug:=dump;\n      'h','H':HalveThreshold:=StringNum/100;\n      'n','N':Debug:=none;\n      'p','P':Debug:=post;\n      't','T':Debug:=trace;\n      'v','V':Verifiable:=true;\n      end;\n   end;\n\nbegin\n   Debug:=trace;\n   Verifiable:=false;\n   HalveThreshold:=67/100;\n   Options;\n   writeln(Debug);\n   writeln('Verifiable:',Verifiable);\n   writeln('Halve threshold',HalveThreshold);\nend;{InitialOptions}\n\nprocedure NormalizeUp(E,M:integer;var S:Sreal;var Closed:boolean);\nbegin\nwith S do\nbegin\n   if M=0 then S:=ZeroS else\n   if M>0 then\n   begin\n      while M>=Maxinf do\n      begin \n\t if M mod 10 > 0 then begin Closed:=false;M:=(M div 10)+1 end\n\t else M:=M div 10;\n\t E:=E+1;\n      end;\n\t \n      while M < Maxinf div 10 do\n      begin M:=M*10; E:=E-1; \n      end;\n\n      if E > Maxexp then {overflow-set to infinity}\n      begin \n\t S:=PlusInfS;\n\t Closed:=false;\n      end else\n      if E < Minexp then {underflow-set to smallest positive value}\n      begin \n         S:=PlusSmallS;\n         Closed:=false;\n      end else\n      begin cardinality:=finite;exp:=E;mantissa:=M;\n      end;\n   end else\t \n   if M < 0 then\n   begin\n      while M <= Mininf do\n      begin \n\t if M mod 10 < 0 then Closed:=false else\n\t if M mod 10 > 0 then halt;\n\t M:=M div 10;\n\t E:=E+1;\n      end;\n\t \n      while M > (Mininf div 10) do\n      begin M:=M*10; E:=E-1; \n      end;\n\n      if E > Maxexp then {overflow-set to most negative value}\n      begin \n         S:=MinusFiniteS;\n         Closed:=false;\n      end \n      else\n      if E < Minexp then {underflow-set to zero}\n      begin\n         S:=ZeroS;\n         Closed:=false;\n      end else\n      begin\n         cardinality:=finite;exp:=E;mantissa:=M;\n      end;\n   end;\nend;\nend;{NormalizeUp}\n\nprocedure NormalizeDn(E,M:integer;var S:Sreal;var Closed:boolean);\nbegin\nwith S do\nbegin\n   if M=0 then S:=ZeroS else\n   if M>0 then\n   begin\n      while M >= Maxinf do\n      begin \n\t if M mod 10 > 0 then Closed:=false else\n\t if M mod 10 < 0 then halt;\n\t M:=M div 10;\n\t E:=E+1;\n      end;\n\t \n      while (M < Maxinf div 10) do\n      begin M:=M*10; E:=E-1; \n      end;\n\n      if E > Maxexp then {overflow-set to largest positive value}\n      begin \n\t S:=PlusFiniteS;\n\t Closed:=false;\n      end else\n      if E < Minexp then {underflow-set to zero}\n      begin S:=ZeroS; Closed:=false;\n      end else\n      begin cardinality:=finite;exp:=E;mantissa:=M;\n      end;\n   end else\t \n   if M < 0 then\n   begin\n      while M <= Mininf do\n      begin \n\t if M mod 10 < 0 then \n\t begin Closed:=false; M:=M div 10 -1;end\n\t else \n\t if M mod 10 = 0 then M:=M div 10 \n\t else halt;\n\t E:=E+1;\n      end;\n\t \n      while (M>Mininf div 10) do\n      begin M:=M*10; E:=E-1; \n      end;\n\n      if E > Maxexp then {overflow}\n      begin \n         S:=MinusInfS;\n         Closed:=false;\n      end \n      else\n      if E < Minexp then {underflow}\n      begin S:=MinusSmallS; Closed:=false;\n      end else\n      begin\n         cardinality:=finite;exp:=E;mantissa:=M;\n      end;\n   end;\nend;\nend;{NormalizeDn}\n\nprocedure WriteS(X:Sreal);\nvar E,M:integer;\nbegin\nwith X do\nbegin\n   case edge of\n   lin: write('[');\n   lout: write('(');\n   hin,hout:\n   end;\n   \n   case cardinality of\n   infinite: write('inf':Digits+4); \n   finite: \n      if mantissa = 0 then write(0:Digits+1,' ':3)\n      else begin\n         M:=mantissa;\n\t E:=exp; \n         while (M mod 10 = 0) do\n\t begin M:=M div 10; E:=E+1;\n\t end;\n         write(M:Digits+1,'e',E-Digits:2);\n      end;\n   end;\n   \n   case edge of \n   hin: write(']');\n   hout:write(')');\n   lin,lout:\n   end;\nend;\nend;{WriteS}\n\nprocedure WriteInt(I:Int);\nbegin\n   with I do begin WriteS(lo); write(','); WriteS(hi); end;\nend;{WriteInt}\n   \nprocedure DumpS(X:Sreal);\nbegin\nwith X do\n   write(edge:4,cardinality:9,mantissa:7,exp:3);\nend;{DumpS}\n\nprocedure DumpInt(I:Int);\nbegin\n   with I do begin DumpS(lo); write(' || '); DumpS(hi); end;\nend;{DumpInt}\n   \nprocedure ReadInt(var I:Int);\n\nvar   Ch:char;\n      Cll,Clu:boolean;\n\t\n   procedure ReadSUp(var X:Sreal; var Closed:boolean);\n   var E,M:integer;\n   begin\n      with X do\n      begin\n         deblank;\n         case input^ of\n         '~':begin X:=PlusInfS;read(Ch);\n\t     end;\n         '-','+','0','1','2','3','4','5','6','7','8','9':\n\t begin\n\t    cardinality:=finite;\n   \t    read(M);\n\t    read(E); E:=E+Digits;\n\t    NormalizeUp(E,M,X,Closed);\n\t end;\n\t end;{case}\n      end;\n   end;{ReadSUp}\n\n   procedure ReadSDn(var X:Sreal; var Closed:boolean);\n   var E,M:integer;\n       Ch:char;\n   begin\n      with X do\n      begin\n         deblank;\n         case input^ of\n         '~':begin X:=MinusInfS;read(Ch);\n\t     end;\n         '-','+','0','1','2','3','4','5','6','7','8','9':\n\t begin\n\t    cardinality:=finite;\n   \t    read(M);\n\t    read(E); E:=E+Digits;\n\t    NormalizeDn(E,M,X,Closed);\n\t end;\n\t end;{case}\n      end;\n   end;{ReadSDn}\nbegin{ReadInt}\n   with I do \n   begin \n      deblank; read(Ch); \n      case Ch of\n      '[':Cll:=true;\n      '(':Cll:=false;\n      end;\n      ReadSDn(lo,Cll);if Cll then lo.edge:=lin else lo.edge:=lout;\n      deblank;\n      read(Ch); assert(Ch=',');\n      Clu:=true;\n      ReadSUp(hi,Clu);\n      deblank;\n      read(Ch);\n      case Ch of\n      ']':if Clu then hi.edge:=hin else hi.edge:=hout;\n      ')':hi.edge:=hout;\n      end;\n   end;\nend;{ReadInt}\n   \nprocedure DumpTables;\nvar tL:Loc; tPar:0..Par; tOp:OpType;\nbegin\n\tfor tOp := print to stop do\n\t   writeln(tOp:6,ParN[tOp]:2);\n\twriteln;\n\n\tfor tL := 1 to End do\n\twith I[tL] do\n\tbegin\n\t   write(Code:5);\n\t   for tPar := 0 to Par do\n\t      if Pars[tPar] <> 0 then write(Pars[tPar]:4);\n\t   writeln;\n\tend;\n\twriteln('number of memory locations used:',MaxDMem:0);\n\twriteln;\nend;{DumpTables}\n\t\nprocedure AlignUp\n   (E0:ExpT;M0:ManT;E1:ExpT;M1:ManT;var E,N0,N1:integer;var Closed:boolean);\n{Align mantissas M0,M1 preserving accuracy and rounding up wherever possible}\n{common resulting exponents in E, and mantissas in N0,N1}\nvar D:Positive;\nbegin\n   if M0=0 then begin E:=E1;N0:=0;N1:=M1;end else\n   if M1=0 then begin E:=E0;N0:=M0;N1:=0;end else\n   if E0=E1 then\n   begin E:=E0; N0:=M0; N1:=M1;\n   end else\n   if (E0>E1) then AlignUp(E1,M1,E0,M0,E,N1,N0,Closed) else\n   begin\n      D:=E1-E0;\n      if D>= 2*Digits then\n      begin \n         N1:=M1*Maxinf; E:=E1-Digits;\n\t if M0<0 then N0:=0 else N0:=1;\n\t Closed:=false;\n      end else\n      if D > Digits then\n      begin \n         N1:=M1*Maxinf; E:=E1-Digits; \n\t if (M0 mod Shift[D-Digits]) = 0 \n\t then N0:=(M0 div Shift[D-Digits])\n\t else\n\t    if M0 > 0 then N0:=(M0 div Shift[D-Digits])+1\n\t              else N0:=(M0 div Shift[D-Digits]);\n      end else\n      {Digits>=D>=0}\n      begin N1:=M1*Shift[D]; E:=E1-D; N0:=M0;\n      end;\n   end;\nend;{AlignUp}\n\nfunction gtS(X,Y:Sreal):boolean;\n{X>Y  careful need to be able to compare x] and (x etc.}\nvar gt:boolean;\nbegin\n   if (X.exp=Y.exp)and(X.mantissa=Y.mantissa) then gt:=X.edge>Y.edge else\n   if X.exp = Y.exp then gt:= (X.mantissa > Y.mantissa) else\n   if X.mantissa = 0 then gt:= 0 > Y.mantissa else\n   if Y.mantissa = 0 then gt:= X.mantissa > 0 else\n   if (X.mantissa>0) and (Y.mantissa>0) then gt:= (X.exp > Y.exp) else\n   if (X.mantissa>0) and (Y.mantissa<0) then gt:= true else\n   if (X.mantissa<0) and (Y.mantissa>0) then gt:= false else\n   if (X.mantissa<0) and (Y.mantissa<0) then gt:= (X.exp < Y.exp) \n   else  writeln('error in gtS');\n   \n   gtS:=gt;\nend;{gtS}\n   \nfunction geS(X,Y:Sreal):boolean;\n{X>=Y  careful need to be able to compare x] and (x etc.}\nbegin\n   if (X.exp=Y.exp)and(X.mantissa=Y.mantissa) then geS:=X.edge>=Y.edge else\n   if X.exp = Y.exp then geS:= (X.mantissa >= Y.mantissa) else\n   if X.mantissa = 0 then geS:= 0 >= Y.mantissa else\n   if Y.mantissa = 0 then geS:= X.mantissa >= 0 else\n   if (X.mantissa>0) and (Y.mantissa>0) then geS:= (X.exp > Y.exp) else\n   if (X.mantissa>0) and (Y.mantissa<0) then geS:= true else\n   if (X.mantissa<0) and (Y.mantissa>0) then geS:= false else\n   if (X.mantissa<0) and (Y.mantissa<0) then geS:= (X.exp < Y.exp) \n   else  writeln('error in geS');\nend;{geS}\n   \nfunction Point(X:Int):boolean;\n{X=[x,x]}\nbegin\nwith X do\n   Point:=(lo.edge=lin)and (hi.edge=hin) and \n\t  (lo.mantissa=hi.mantissa) and\n\t  (lo.exp=hi.exp);\nend;{Point}\n\nprocedure maxS(X,Y:Sreal;var max:Sreal);\nbegin\n\tif gtS(X,Y) then max:=X else max:=Y;\nend;\n\nprocedure minS(X,Y:Sreal;var min:Sreal);\nbegin\n\tif gtS(X,Y) then min:=Y else min:=X;\nend;\n\nprocedure Inter(P,Q:Int;var R:Int);\nbegin\n   minS(P.hi,Q.hi,R.hi);\n   maxS(P.lo,Q.lo,R.lo);\nend;\n\nfunction CheckHi(X:Sreal):boolean;\nvar OK:boolean;\nbegin\n   OK:=true;\n   with X do\n   begin\n      case cardinality of\n      infinite:\n         if (exp=Maxexp)and(mantissa=Maxinf) then\n\t else writeln('**Invalid hi infinity');\n      finite:\n      begin\n         if (mantissa=Maxinf) or (mantissa=Mininf) then\n\t begin OK:=false; writeln('**Invalid finite value - hi');\n\t end;\n\t \n         if mantissa = 0 then\n\t    if (exp=0) then \n\t    else \n\t    begin OK:=false; writeln('**Invalid zero - hi')\n\t    end\n\t else\n\t begin\n\t    if (mantissa > 0) then\n\t       if mantissa >= (Maxinf div 10) then {OK}\n\t       else \n\t       begin OK:=false; writeln('**Incorrect normalization - hi') \n\t       end\n\t    else{mantissa<0}\n\t       if mantissa > (Mininf div 10) then\n\t       begin OK:=false; writeln('**Incorrect normalization - hi') \n\t       end;\n\t end;\n      end;\n      end;{case}\n\n      if not (edge in [hin,hout]) then\n      begin\n         OK:=false;\n\t writeln('**hi edge value incorrect');\n      end;\n   end;\n   \n   CheckHi:=OK;\nend;{CheckHi}\n  \nfunction CheckLo(X:Sreal):boolean;\nvar OK:boolean;\nbegin\n   OK:=true;\n   with X do\n   begin\n      case cardinality of\n      infinite:\n         if (exp=Maxexp)and(mantissa=Mininf) then\n\t else writeln('**Invalid lo infinity');\n      finite:\n      begin\n         if (mantissa=Maxinf) or (mantissa=Mininf) then\n\t begin OK:=false; writeln('**Invalid finite value - hi');\n\t end;\n\t \n         if mantissa = 0 then\n\t    if (exp=0) then \n\t    else \n\t    begin OK:=false; writeln('**Invalid zero - lo')\n\t    end\n\t else\n\t begin\n\t       if (mantissa > 0) then\n\t          if mantissa >= (Maxinf div 10) then{OK}\n\t\t  else \n\t\t  begin OK:=false; writeln('**Incorrect normalization - lo') \n\t\t  end\n\t       else{mantissa<0}\n\t          if mantissa > (Mininf div 10) then\n\t\t  begin OK:=false; writeln('**Incorrect normalization - lo') \n\t\t  end;\n\t end;\n      end;\n      end;{case}\n\n      if not (edge in [lin,lout]) then\n      begin\n         OK:=false;\n\t writeln('**lo edge value incorrect');\n      end;\n   end;\n   \n   CheckLo:=OK;\nend;{CheckLo}\n  \nfunction CheckInt(I:Int):boolean;\nvar OK:boolean;\nbegin\n   OK:=CheckHi(I.hi) and CheckLo(I.lo);\n   if gtS(I.lo,I.hi) then\n   begin\n      OK:=false;\n      writeln('**Limits out of order');\n   end;\n\n   if not OK then \n   begin writeln('**Error in Check'); DumpInt(I);\n   end;\n   \n   CheckInt:=OK;\nend;\n\nprocedure DumpMem(var DCurr:DataMem);\nvar tD:Ptr; tL:Loc;\nbegin\n   with DCurr do\n   begin\n        writeln('LastHalve:',LastHalve:0);\n\t\n    \tfor tL:= 1 to End do\n\t   writeln(tL:3,S[tL]:2,RHalve[tL]);\n\twriteln;\n\t\n\tfor tD:= 1 to MaxDMem do \n\tbegin \n\t   write(tD:5);\n\t   DumpInt(D[tD]);\n\t   assert(CheckInt(D[tD]));\n\t   writeln;\n\tend;\n\twriteln;\n   end;\nend;{DumpMem}\n\nprocedure WriteMem(var DCurr:DataMem);\nvar tD:Ptr; \nbegin\n   with DCurr do\n   begin\n\tfor tD:= 1 to MaxDMem do \n\tif (DF.PF[tD] > PNull) or (Debug > activity) then\n\tbegin \n\t   write(tD:5);\n\t   WriteInt(D[tD]);\n\t   writeln;\n\tend;\n\twriteln;\n   end;\nend;{WriteMem}\n\nprocedure OuterExec\n(PC:Loc0;DCurr:DataMem;Change:boolean;First:State;\n var OldCounter:Positive;Level:Positive);\n\nvar Counter:Positive;\n    Fail,AllPoints,LocalChange:boolean;\n\nprocedure NewOuter(F:State);\nbegin OuterExec(PC,DCurr,Change,F,Counter,Level+1);\nend;\n\n{!!}\nprocedure execprint(PC:Loc; L:Ptr; R0:Int);\nbegin\n   DF.PF[L]:=PSoln;\n   writeln;\n   write(PC:3,L:5);\n   WriteInt(R0);\n   writeln;\nend;\n\nprocedure execpr(var Sr:State; L:Ptr);\nbegin\n   Sr:=-1; DF.PF[L]:=PPrint;\nend;{execpr}\n\nprocedure exectr(var Sr:State; L:Ptr);\nbegin\n   Sr:=-1; DF.PF[L]:=PTrace;\nend;{exectr}\n\nprocedure execsoln(var Sr:State; L:Ptr);\nbegin\n   Sr:=-1; DF.PF[L]:=PSoln;\nend;{execsoln}\n\nprocedure execreadr(var Sr:State;var R0:Int);\nbegin\n   writeln;\n   write('<<');\n   ReadInt(R0);\n   Sr:=-1;\nend;\n\nfunction GetReal(E,M:integer):real;\n{convert E-exponent,M-mantissa into genuine Pascal real number}\nvar x:real;\nbegin\n   x:=M/Maxinf;\n   while E>0 do begin x:=x*10; E:=E-1; end; \n   while E<0 do begin x:=x/10; E:=E+1; end;\n   GetReal:=x; \nend;{GetReal} \n   \nprocedure Ratio(Lo,Hi:Sreal;var ERat,MRat:integer); \n{compute ratio of Hi to Lo in exponent mantissa form}\nbegin\n   if Lo.mantissa=0 then\n   begin{treat zero as if smallest possible positive number}\n      ERat:=Hi.exp-Minexp;\n      MRat:=Hi.mantissa*10;\n   end else\n   if Hi.mantissa=0 then\n   begin{treat zero as if smallest possible negative number}\n      ERat:=Minexp-Lo.exp;\n      MRat:=Lo.mantissa*10;\n   end\n   else begin\n      ERat:=Hi.exp-Lo.exp;\n      MRat:=(Hi.mantissa*Maxinf) div Lo.mantissa;\n   end;\nend;{Ratio}\n    \nfunction Adjacent(X:Int):boolean;\n{are hi and lo bounds adjacent points}\nbegin\n   with X do\n   if (hi.mantissa=0) or (lo.mantissa=0) then\n      Adjacent:=\n         ((hi.mantissa=0)and(lo.mantissa=Mininf div 10)and(lo.exp=Minexp)) or\n         ((lo.mantissa=0)and(hi.mantissa=Maxinf div 10)and(hi.exp=Minexp)) \n   else\n      Adjacent:=\n         ((lo.exp=hi.exp)and(lo.mantissa+1=hi.mantissa)) or\n\t ((hi.exp=lo.exp+1)and(hi.mantissa=(lo.mantissa div 10)+1)) or\n\t ((hi.exp=lo.exp-1)and((hi.mantissa div 10)-1=lo.mantissa));\nend;{Adjacent}\n\nprocedure exechalve\n   (var PC:Loc0;var Sr:State;var R0:Int;var OK:boolean;var Change:boolean);\n{Reduce range of R0 (suceeds twice for two 'halves')}\n\nvar EDiff,MDiff,ERat,MRat,MidE,MidM,M0,M1,HiM,HiE:integer;\n    Dummy:boolean;\n    Mid:Sreal;\n    R,D:real;\n    OldPC:Loc;\n   \n    procedure AtEnd;{What to do afer a successful halve}\n    begin  \n\tDCurr.LastHalve:=PC; PC:=0; Sr:=0;\n    end;\n\nbegin{exechalve}\nOldPC:=PC;\nwith R0 do\n begin\n      if DCurr.LastHalve >= PC then {not our turn yet} else\n      if (lo.mantissa = hi.mantissa) and (lo.exp=hi.exp) and\n         (lo.edge=lin) and (hi.edge=hin)\n      then {single point cant be divided} Sr:=-1 \n      else\n      if Adjacent(R0) and \n\t (((lo.edge=lout) and (hi.edge=hout)) or\n\t  ((lo.cardinality=infinite)and(hi.edge=hout)) or \n\t  ((hi.cardinality=infinite)and(lo.edge=lout))\n\t )\n      then Sr:=-1\n      else\n      if Sr=0 then\n         begin\n            AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n            MDiff:=M0+M1;\n\t    D:=GetReal(EDiff,MDiff);\n\t    if D < DCurr.RHalve[PC]*HalveThreshold \n\t    then {already narrowed enough dont bother} \n\t       Change:=true {otherwise can terminate too early}\n\t    else begin\n\t       DCurr.RHalve[PC]:=D;\n               NewOuter(1);\n               NewOuter(2);\n\t       OK:=false;{fail after both alternatives tried}\n\t    end\n         end\n   else{Sr=1,2}\n   if Adjacent(R0)\n   then begin{two adjacent points - needs special care}\n      if (hi.edge=hin) and (hi.cardinality=finite) then\n      begin\n         case Sr of\n\t 1:hi.edge:=hout;\n\t 2:begin lo:=hi; lo.edge:=lin;\n\t   end;\n\t end;\n\n         AtEnd;\n      end\n      else if (lo.edge=lin) and (lo.cardinality=finite) then \n      begin\n         case Sr of\n\t 1:begin hi:=lo; hi.edge:=hin;\n\t   end;\n\t 2:lo.edge:=lout;\n\t end;\n         AtEnd;\n      end else {cant be narrowed} Sr:=-1;\n\n   end{adjacent} else\n   begin\n      if (lo.mantissa < 0) and (hi.mantissa > 0) then\n      begin\n         MidM:=0; MidE:=0;\n      end else\n      begin\n         Ratio(lo,hi,ERat,MRat);\n         if MRat < 0 then MRat:=-MRat;\n         R:=GetReal(ERat,MRat);\n(*writeln(ERat,MRat,R);*)\n         AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n         MDiff:=M0+M1;\n         if (R > 4) or (R < 0.25) then\n         begin{divide hi by sqrt of ratio to get midpoint}\n\t    if hi.mantissa = 0 \n\t    then begin HiM:=Mininf div 10; HiE:=Minexp;\n\t    end else\n\t    begin HiM:=hi.mantissa; HiE:=hi.exp;\n\t    end;\n\t    if ERat < 0 then MidE:=HiE-((ERat-1) div 2)\n\t \t        else MidE:=HiE-(ERat div 2);\n\t    if odd(ERat) \n\t       then MidM:=trunc(HiM*(Maxinf div 100)/sqrt(MRat*10))\n\t       else MidM:=trunc(HiM*(Maxinf div 100)/sqrt(MRat));\n(*writeln(MidE,MidM);*)\n         end else\n         begin{take (hi+lo)/2 as midpoint}\n            MidM:=MDiff div 2 - M1;\n\t    MidE:=EDiff;\n         end;\n      end;\n      if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Dummy)\n      \t\t   else NormalizeUp(MidE,MidM,Mid,Dummy);\n      case Sr of\n      1:begin hi:=Mid; hi.edge:=hout;\n        end;\n      2:begin lo:=Mid; lo.edge:=lin;\n        end;\n      end;\n(*DumpInt(R0);writeln;*)\n      AtEnd;\n   end;{if Sr}\n\n   AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n   MDiff:=M0+M1;\n   DCurr.RHalve[OldPC]:=GetReal(EDiff,MDiff);\n\n end;{with}\nend;{exechalve}\n\nprocedure exechalves\n   (var PC:Loc0;var Sr:State;var R0:Int;var OK:boolean;var Change:boolean);\n{Reduce range of R0 (suceeds twice for two 'halves')}\n{Simple version thats averages exponents}\n\nvar EDiff,MDiff,ERat,MRat,MidE,MidM,M0,M1,HiM,HiE:integer;\n    Dummy:boolean;\n    Mid:Sreal;\n    R,D:real;\n    OldPC:Loc;\n   \n    procedure AtEnd;{What to do afer a successful halve}\n    begin  \n\tDCurr.LastHalve:=PC; PC:=0; Sr:=0;\n    end;\n\n    procedure Average(Lo,Hi:Sreal;var Exp:integer);\n    {compute average of exponents allowing for zero}\n    {infinities happen to work because of representation}\n    var Le,He:integer;\n    begin\n       if Lo.mantissa = 0 then\n\t  Le := Minexp\n       else\n\t  Le := Lo.exp;\n       if Hi.mantissa = 0 then\n\t  He := Minexp\n       else\n\t  He := Hi.exp;\n       Exp:= (He + Le - 2*Minexp) div 2 + Minexp;\nwriteln(Exp,Hi.exp,Lo.exp,Minexp,He,Le);\n    end;{Average}\n\nbegin{exechalves}\nOldPC:=PC;\nwith R0 do\n begin\n      if DCurr.LastHalve >= PC then {not our turn yet} else\n      if (lo.mantissa = hi.mantissa) and (lo.exp=hi.exp) and\n         (lo.edge=lin) and (hi.edge=hin)\n      then {single point cant be divided} Sr:=-1 \n      else\n      if Adjacent(R0) and \n\t (((lo.edge=lout) and (hi.edge=hout)) or\n\t  ((lo.cardinality=infinite)and(hi.edge=hout)) or \n\t  ((hi.cardinality=infinite)and(lo.edge=lout))\n\t )\n      then Sr:=-1\n      else\n      if Sr=0 then\n         begin\n            AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n            MDiff:=M0+M1;\n\t    D:=GetReal(EDiff,MDiff);\n\t    if D < DCurr.RHalve[PC]*HalveThreshold \n\t    then {already narrowed enough dont bother} \n\t       Change:=true {otherwise can terminate too early}\n\t    else begin\n\t       DCurr.RHalve[PC]:=D;\n               NewOuter(1);\n               NewOuter(2);\n\t       OK:=false;{fail after both alternatives tried}\n\t    end\n         end\n   else{Sr=1,2}\n   if Adjacent(R0)\n   then begin{two adjacent points - needs special care}\n      if (hi.edge=hin) and (hi.cardinality=finite) then\n      begin\n         case Sr of\n\t 1:hi.edge:=hout;\n\t 2:begin lo:=hi; lo.edge:=lin;\n\t   end;\n\t end;\n\n         AtEnd;\n      end\n      else if (lo.edge=lin) and (lo.cardinality=finite) then \n      begin\n         case Sr of\n\t 1:begin hi:=lo; hi.edge:=hin;\n\t   end;\n\t 2:lo.edge:=lout;\n\t end;\n         AtEnd;\n      end else {cant be narrowed} Sr:=-1;\n\n   end{adjacent} else\n   begin\n      if (lo.mantissa < 0) and (hi.mantissa > 0) then\n      begin\n         MidM:=0; MidE:=0;\n      end else\n      begin\n         Ratio(lo,hi,ERat,MRat);\n(*writeln(ERat,MRat,R);*)\n         AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n         MDiff:=M0+M1;\n         if (ERat > 1) or (ERat < -1) then\n         begin{Average exponents}\n\t    if hi.mantissa <= 0 \n\t    then begin MidM:= -Splitman;\n\t    end else\n\t    begin MidM:= Splitman; assert(lo.mantissa >= 0);\n\t    end;\n            Average(lo,hi,MidE);\n         end else\n         begin{take (hi+lo)/2 as midpoint}\n            MidM:=MDiff div 2 - M1;\n\t    MidE:=EDiff;\n         end;\n      end;\n      if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Dummy)\n      \t\t   else NormalizeUp(MidE,MidM,Mid,Dummy);\n      case Sr of\n      1:begin lo:=Mid; lo.edge:=lin;\n        end;\n      2:begin hi:=Mid; hi.edge:=hout;\n        end;\n      end;\n(*DumpInt(R0);writeln;*)\n      AtEnd;\n   end;{if Sr}\n\n   AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n   MDiff:=M0+M1;\n   DCurr.RHalve[OldPC]:=GetReal(EDiff,MDiff);\n\n end;{with}\nend;{exechalves}\n\nprocedure execlinh\n   (var PC:Loc0;var Sr:State;var R0:Int;var OK:boolean;var Change:boolean);\n{Reduce range of R0 (suceeds twice for two 'halves')}\n\nvar EDiff,MDiff,MidE,MidM,M0,M1:integer;\n    Dummy:boolean;\n    Mid:Sreal;\n    D:real;\n    OldPC:Loc;\n   \n    procedure AtEnd;{What to do afer a successful halve}\n    begin  \n\tDCurr.LastHalve:=PC; PC:=0; Sr:=0;\n    end;\n\nbegin{execlinh}\nOldPC:=PC;\nwith R0 do\n begin\n      if DCurr.LastHalve >= PC then {not our turn yet} else\n      if (lo.mantissa = hi.mantissa) and (lo.exp=hi.exp) and\n         (lo.edge=lin) and (hi.edge=hin)\n      then {single point cant be divided} Sr:=-1 \n      else\n      if Adjacent(R0) and \n\t (((lo.edge=lout) and (hi.edge=hout)) or\n\t  ((lo.cardinality=infinite)and(hi.edge=hout)) or \n\t  ((hi.cardinality=infinite)and(lo.edge=lout))\n\t )\n      then Sr:=-1\n      else\n      if Sr=0 then\n         begin\n            AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n            MDiff:=M0+M1;\n\t    D:=GetReal(EDiff,MDiff);\n\t    if D < DCurr.RHalve[PC]*HalveThreshold\n\t    then {already narrowed enough dont bother} \n\t       Change:=true {otherwise possible to terminate early}\n\t    else begin\n\t       DCurr.RHalve[PC]:=D;\n               NewOuter(1);\n               NewOuter(2);\n\t       OK:=false;{fail after both alternatives tried}\n\t    end\n         end\n   else{Sr=1,2}\n   if Adjacent(R0)\n   then begin{two adjacent points - needs special care}\n      if (hi.edge=hin) and (hi.cardinality=finite) then\n      begin\n         case Sr of\n\t 1:begin lo:=hi; lo.edge:=lin;\n\t   end;\n\t 2:hi.edge:=hout;\n\t end;\n         AtEnd;\n      end\n      else if (lo.edge=lin) and (lo.cardinality=finite) then \n      begin\n         case Sr of\n\t 1:lo.edge:=lout;\n\t 2:begin hi:=lo; hi.edge:=hin;\n\t   end;\n\t end;\n         AtEnd;\n      end else {cant be narrowed} Sr:=-1;\n   end{adjacent} else\n   begin\n      if (lo.mantissa < 0) and (hi.mantissa > 0) then\n      begin\n         MidM:=0; MidE:=0;\n      end else\n      begin\n         AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n         MDiff:=M0+M1;\n         MidM:=MDiff div 2 - M1;\n\t MidE:=EDiff;\n      end;\n      if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Dummy)\n      \t\t   else NormalizeUp(MidE,MidM,Mid,Dummy);\n      case Sr of\n      1:begin lo:=Mid; lo.edge:=lin;\n        end;\n      2:begin hi:=Mid; hi.edge:=hout;\n        end;\n      end;\n      \n      AtEnd;\n   end;{if Sr}\n\n   AlignUp(hi.exp,hi.mantissa,lo.exp,-lo.mantissa,EDiff,M0,M1,Dummy);\n   MDiff:=M0+M1;\n   DCurr.RHalve[OldPC]:=GetReal(EDiff,MDiff);\n\n end;{with}\nend;{execlinh}\n\nprocedure execmult(var Sr:State;T0,T1,T2:Int;var R0,R1,R2:Int;var OK:boolean);\nvar Q0,Q1,Q2:Int;\n\n   procedure multS(S0,S1:Sreal;var U,D:Sreal);\n   var M,E:integer;\n       Closed,Clu,Cld:boolean;\n   begin\n      M:=S0.mantissa*S1.mantissa;\n(*DumpS(S0);write('//');DumpS(S1);write(M);*)\n      Closed:=(S0.edge in [hin,lin]) and (S1.edge in [hin,lin]);\n      if ((S0.mantissa=0) and (S0.edge in [hin,lin])) or\n         ((S1.mantissa=0) and (S1.edge in [hin,lin]))\n      then Closed:=true; \n      Clu:=Closed; Cld:=Closed;\n      if (S0.cardinality=infinite) or (S1.cardinality=infinite) then\n      begin\n         if M < 0 then begin D:=MinusInfS; U:=MinusInfS; end else\n\t if M > 0 then begin D:=PlusInfS; U:=PlusInfS; end else\n\t begin {M=0} D:=ZeroS; U:=ZeroS; end;\n\t Closed:=((S0.cardinality=infinite)and(S0.edge in [hin,lin]))or\n\t         ((S1.cardinality=infinite)and(S1.edge in [hin,lin]));\n\t Clu:=Closed;Cld:=Closed;\n      end\n      else{everybody finite}\n      begin\n         E:=S0.exp+S1.exp-Digits;\n\t NormalizeUp(E,M,U,Clu);\n\t NormalizeDn(E,M,D,Cld);\n      end;\n      if Clu then U.edge:=hin else U.edge:=hout;\n      if Cld then D.edge:=lin else D.edge:=lout;      \n(*writeln(E);DumpS(U);write('::');DumpS(D);writeln;*)\n   end;{multS}\n         \n   procedure mult(Ta,Tb:Int;var R:Int);\n   var U0,U1,U2,U3,U4,U5,D0,D1,D2,D3,D4,D5:Sreal;\n   begin\n      multS(Ta.hi,Tb.hi,U0,D0);\n      multS(Ta.hi,Tb.lo,U1,D1);\n      multS(Ta.lo,Tb.hi,U2,D2);\n      multS(Ta.lo,Tb.lo,U3,D3);\n      maxS(U0,U1,U4);maxS(U2,U3,U5);maxS(U4,U5,R.hi);\n      minS(D0,D1,D4);minS(D2,D3,D5);minS(D4,D5,R.lo);\n   end;\n   \n   procedure InvS(S:Sreal;var W:Sreal);\n   var E,M,Rem:integer;\n       Closed:boolean;\n   begin\n      Closed:= S.edge in [hin,lin];\n      if (S.cardinality = infinite) then\n         W:=ZeroS\n      else\n      if (S.mantissa = 0) then\n         case S.edge of\n\t hin,hout:W:=MinusInfS;\n\t lin,lout:W:=PlusInfS;\n\t end\n      else\n      begin\n         M:=(Maxinf*Maxinf) div S.mantissa;\n\t Rem:=(Maxinf*Maxinf) mod S.mantissa;\n\t if Rem < 0 then halt;\n\t E:=-S.exp;\n\t case S.edge of\n\t lin,lout: begin \n\t     \t      if (Rem > 0) and (M > 0) then \n\t\t      begin M:=M+1;Closed:=false; \n\t\t      end;\n\t\t      NormalizeUp(E,M,W,Closed);\n\t           end;\n\t hin,hout: begin \n\t     \t      if (Rem > 0) and (M < 0) then \n\t\t      begin M:=M-1;Closed:=false;\n\t\t      end;\n\t\t      NormalizeDn(E,M,W,Closed);\n\t           end;\n\t end;\n      end;\n      \n      if Closed then\n         case S.edge of\n         hin:W.edge:=lin;\n         lin:W.edge:=hin;\n         end\n      else\n         case S.edge of\n\t hin,hout:W.edge:=lout;\n\t lin,lout:W.edge:=hout;\n\t end;\n\n      \n   end;{InvS}\t \n   \n   procedure Inv(T:Int;var X:Int;Pos:boolean);\n   {1/T positive -> X}\n   {If 1/T splits to two intervals then use Pos to select which to use}\n   begin\n      if (T.lo.mantissa < 0) and (T.hi.mantissa > 0) then\n         if (T.lo.cardinality=infinite) and (T.hi.cardinality=infinite) then\n\t    X:=All\n\t else if Pos then\n\t begin InvS(T.hi,X.lo); X.hi:=PlusInfS; X.hi.edge:=hin;\n\t end else \n\t begin InvS(T.lo,X.hi); X.lo:=MinusInfS; X.lo.edge:=lin;\n\t end\n      else\n      begin InvS(T.hi,X.lo); InvS(T.lo,X.hi);\n      end;\n   end;{Inv}\n   \n   procedure divi(Ta,Tb:Int;var R:Int);\n   var X:Int;\n   begin\n      if (Tb.lo.mantissa < 0) and (Tb.hi.mantissa > 0) then\n         if (Ta.lo.mantissa < 0) and (Ta.hi.mantissa > 0) then\n\t { need do nothing as R will be set to [inf,inf]}\n\t else\n\t \n         begin\n\t    {if both same sign get positive side of inverse}\n\t    {else get negative}\n\t    Inv(Tb,X,(Ta.hi.mantissa <= 0) = (R.hi.mantissa <= 0));\n\t    mult(Ta,X,R);\n\t end\n      else {Tb wont give split inverse}\n      begin\n         Inv(Tb,X,true);\n\t mult(Ta,X,R);\n      end;\n(*\nDumpInt(Tb);writeln('//');DumpInt(X);writeln;\nDumpInt(Ta);writeln('\\\\');DumpInt(R);writeln;\n*)\n   end;\n   \n   function Split(T:Int):boolean;\n   begin\n      Split:=(T.lo.mantissa<0) and (T.hi.mantissa>0) \n      \t      and ((T.lo.cardinality=finite) or (T.hi.cardinality=finite));\n   end;{Split}\n\n   function Zin(T:Int):boolean;\n   {check if 0 in range of interval}\n   begin\n      if (T.lo.mantissa > 0) then Zin:=false else\n      if (T.lo.mantissa = 0) then\n\t Zin:=(T.lo.edge=lin) else\n      if (T.hi.mantissa < 0) then Zin:=false else\n      if (T.hi.mantissa = 0) then\n         Zin:=(T.hi.edge=hin) \n      else\n         Zin:=true;\n   end;{Zin}\n   \nbegin{execmult}\n   case Sr of\n   0,10:begin\n        if T2=Zero then\n           if (T1=Zero) or (T0=Zero) then Sr:=-1\n           else\n\t   if not Zin(T0) then begin R1:=Zero; Sr:=-1; end else\n\t   if not Zin(T1) then begin R0:=Zero; Sr:=-1; end \n\t   else\n           begin\n              NewOuter(11); NewOuter(12);OK:=false;     \n           end\n        else if (Sr=0) then\n        begin\n\t   if (T0.hi.mantissa > 0) and (T0.lo.mantissa < 0) and Split(T1) \n           then  begin NewOuter(1); NewOuter(2); OK:=false; end\n           else if (T1.hi.mantissa > 0) and \n\t           (T1.lo.mantissa < 0) and Split(T0) \n                then  begin NewOuter(3); NewOuter(4); OK:=false; end;\n\tend;\n     end;\n   1:begin R0.lo:=ZeroS; R0.lo.edge:=lin; T0:=R0; Sr:=10;\n     end;\n   2:begin R0.hi:=ZeroS; R0.hi.edge:=hout; T0:=R0; Sr:=10;\n     end;\n   3:begin R1.lo:=ZeroS; R1.lo.edge:=lin; T1:=R1; Sr:=10;\n     end;\n   4:begin R1.hi:=ZeroS; R1.hi.edge:=hout; T1:=R1; Sr:=10;\n     end;\n   11:begin R0:=Zero; Sr:=-1;\n      end;\n   12:begin R1:=Zero; Sr:=-1;\n      end;\n   end;\n   \n   if OK and (Sr<>-1) then\n   begin\n      mult(T0,T1,Q2); Inter(R2,Q2,R2);\n      Q1:=R1; divi(T2,T0,Q1); Inter(R1,Q1,R1);\n      Q0:=R0; divi(T2,T1,Q0); Inter(R0,Q0,R0);\n      Sr:=10;\n   end;\nend;{execmult}\n\nprocedure execadd(T0,T1,T2:Int;var R0,R1,R2:Int);\n  procedure addhi(S0,S1:Sreal; var S2:Sreal);\n  var Closed:boolean;  Exp,M0,M1:integer;\n  begin{addhi}\n  with S2 do\n  begin\n     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then\n     begin  \n        S2:=PlusInfS;\n        Closed:=((S0.cardinality=infinite)and(S0.edge=hin))or\n\t        ((S1.cardinality=infinite)and(S1.edge=hin));\n     end else\n     begin\n        Closed:=(S0.edge=hin)and(S1.edge=hin);\n        AlignUp(S0.exp,S0.mantissa,S1.exp,S1.mantissa,Exp,M0,M1,Closed);\n\tNormalizeUp(Exp,M0+M1,S2,Closed)\n     end;\n     if Closed then S2.edge:=hin else S2.edge:=hout;\n  end;\n  end;{addhi}\n  \n  procedure addlo(S0,S1:Sreal; var S2:Sreal);\n  var Closed:boolean;  Exp,M0,M1:integer;\n  begin{addlo}\n  with S2 do\n  begin\n     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then\n     begin  \n        S2:=MinusInfS;\n        Closed:=((S0.cardinality=infinite)and(S0.edge=lin))or\n\t        ((S1.cardinality=infinite)and(S1.edge=lin));\n     end else\n     begin\n        Closed:=(S0.edge=lin)and(S1.edge=lin);\n        AlignUp(S0.exp,-S0.mantissa,S1.exp,-S1.mantissa,Exp,M0,M1,Closed);\n\tNormalizeUp(Exp,M0+M1,S2,Closed); mantissa:=-mantissa;\n     end;\n     if Closed then S2.edge:=lin else S2.edge:=lout;\n  end;\n  end;{addlo}\n  \n  procedure subhi(S0,S1:Sreal; var S2:Sreal);\n  var Closed:boolean;  Exp,M0,M1:integer;\n  begin{subhi}\n  with S2 do\n  begin\n     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then\n     begin  \n        S2:=PlusInfS;\n        Closed:=((S0.cardinality=infinite)and(S0.edge=hin))or\n\t        ((S1.cardinality=infinite)and(S1.edge=lin));\n     end else\n     begin\n        Closed:=(S0.edge=hin)and(S1.edge=lin);\n        AlignUp(S0.exp,S0.mantissa,S1.exp,-S1.mantissa,Exp,M0,M1,Closed);\n\tNormalizeUp(Exp,M0+M1,S2,Closed);\n     end;\n     if Closed then S2.edge:=hin else S2.edge:=hout;\n  end;\n  end;{subhi}\n  \n  procedure sublo(S0,S1:Sreal; var S2:Sreal);\n  var Closed:boolean;  Exp,M0,M1:integer;\n  begin{sublo}\n  with S2 do\n  begin\n     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then\n     begin  \n        S2:=MinusInfS;\n        Closed:=((S0.cardinality=infinite)and(S0.edge=lin))or\n\t        ((S1.cardinality=infinite)and(S1.edge=hin));\n     end else\n     begin\n        Closed:=(S0.edge=lin)and(S1.edge=hin);\n        AlignUp(S0.exp,-S0.mantissa,S1.exp,S1.mantissa,Exp,M0,M1,Closed);\n\tNormalizeUp(Exp,M0+M1,S2,Closed);mantissa:=-mantissa;\n     end;\n     if Closed then S2.edge:=lin else S2.edge:=lout;\n  end;\n  end;{sublo}\n  \nbegin{execadd}\n   addhi(T0.hi,T1.hi,R2.hi);\n   addlo(T0.lo,T1.lo,R2.lo);\n   \n   subhi(T2.hi,T0.lo,R1.hi);\n   sublo(T2.lo,T0.hi,R1.lo);\n   \n   subhi(T2.hi,T1.lo,R0.hi);\n   sublo(T2.lo,T1.hi,R0.lo);\nend;{execadd}\n\n\n\n\nprocedure execintgr(var Sr:State; var R:Int);\n      \n  procedure floor (var R : Sreal);\n  var sign , dum : boolean ;\n      E, M ,t    : integer ;\n  \n  begin\n     sign := false ;\n     with R do\n        begin\n           if (mantissa < 0) then\n              begin\n                 sign := true ;\n                 mantissa := - mantissa ;\n              end ;\n           if (exp <= 0) then\n              begin\n                 if sign or ((mantissa = 0) & (edge = hout)) then\n                    begin\n                       M := 1 ; \n                       sign := true ;\n                    end \n                 else\n                    M := 0 ;\n                 E := Digits ;\n                 NormalizeUp (E,M,R,dum) ;\n                 edge := hin ;\n              end \n        \n           else {exp >0}\n              if (exp <= Digits) then\n                 begin\n                    M := 1 ;\n                    E := exp ;\n                    while (E < Digits) do\n                       begin\n                          M := M * 10 ;\n                          E := E + 1 ;\n                       end ;\n                    t := mantissa mod M ;\n                    M := mantissa div M ;\n                    if (sign & ((edge = hout) or(t > 0))) then\n                       M := M + 1 ; \n                    if (not sign & (t = 0)) & (edge = hout) then\n                       M := M - 1 ;\n                    E := Digits ;\n                    NormalizeUp (E,M,R,dum) ;\n                    edge := hin ;\n                 end \n              else\n                 if ((edge = hout)&(exp = (Digits+1))) & (not sign & (mantissa = Splitman)) then\n                    begin\n                       mantissa := Maxman ;\n                       exp := Digits ;\n                       edge := hin ;\n                    end ;\n           if sign then\n              mantissa := - mantissa ;\n        end ;{with R}\n  end ; {floor} \n  procedure ceiling (var R : Sreal);\n  var sign , dum : boolean ;\n      E, M , t   : integer ;\n  \n  begin\n     sign := false ;\n     with R do\n        begin\n           if (mantissa < 0) then\n              begin\n                 sign := true ;\n                 mantissa := - mantissa ;\n              end ;\n           if (exp <= 0) then\n              begin\n                 if sign or ((mantissa = 0) & (edge = lin)) then\n                    M := 0 \n                 else\n                    M := 1 ;\n                 E := Digits ;\n                 NormalizeDn (E,M,R,dum) ;\n                 edge := lin ;\n              end \n        \n           else {exp > 0}\n              if (exp <= Digits) then\n                 begin\n                    M := 1 ;\n                    E := exp ;\n                    while (E < Digits) do\n                       begin\n                          M := M * 10 ;\n                          E := E + 1 ;\n                       end ;\n                    t := mantissa mod M ;\n                    M := mantissa div M ;\n                    if ( not sign & ((edge = lout) or(t > 0))) then\n                       M := M + 1 ;\n                    if (sign & (t = 0)) & (edge = lout) then\n                       M := M - 1 ;\n                    E := Digits ;\n                    NormalizeDn (E,M,R,dum) ;\n                    edge := lin ;\n                 end \n              else\n                 if ((edge = lout)&(exp = (Digits+1))) & (sign & (mantissa = Splitman)) then\n                    begin\n                       mantissa := Maxman ;\n                       exp := Digits ;\n                       edge := lin ;\n                    end ;\n           if sign then\n              mantissa := - mantissa ;\n        end ;{with R}\n  end ; {ceiling} \nbegin\n   with R do\n      begin\n(*         writeln ('IN EXECINTGR :') ;\n         writeln ;\n         writeln ('HI : ', hi.mantissa , hi.exp) ;\n         writeln ;\n         writeln ('LO : ', lo.mantissa , lo.exp) ;\n         writeln ;\n*)\n         if (hi.cardinality <> infinite) then\n            floor (hi) ;\n         if (lo.cardinality <> infinite) then\n            ceiling (lo) ;\n         if ((hi.mantissa = lo.mantissa) & (hi.exp = lo.exp)) then\n            Sr := - 1 ;\n(*         writeln ('OUT EXECINTGR :') ;\n         writeln ;\n         writeln ('HI : ', hi.mantissa , hi.exp) ;\n         writeln ;\n         writeln ('LO : ', lo.mantissa , lo.exp) ;\n         writeln ;\n*)\n      end ;\nend;{execintgr}\n\n\n\n\n\n\n\n\n\n\n\n\n\n  procedure execlb (R1 : Int ; var R : Int) ;\n  begin\n     R := R1 ;\n     with R.lo do\n        if (cardinality = infinite) then\n           R.hi := MinusFiniteS \n        else\n           R.hi := R.lo ;\n     R.hi.edge := hin ;\n     R.lo := MinusInfS ;\n  end ;\n\nprocedure execub (var X , Xd : Int) ;\nvar     Dum : Int ;     \n  begin\n     Xd := X ;\n     execadd (Xd, Dum, Zero, Dum, Xd, Dum) ;\n     execlb (Xd,Xd) ;\n     execadd (Xd, Dum, Zero, Dum, Xd, Dum) ;\n  end ;\n\nprocedure execcopy (R0 :Int; var R1:Int);\nbegin\n  R1:=R0;\nend;\n\nprocedure execless(var Sr:State; var R0,R1:Int);\n{R0 < R1}\nbegin\n   if Point(R0) or Point(R1) then Sr:=-1;\n   if gtS(R1.lo,R0.hi) then Sr:= -1 else\n   begin\n      R0.hi:=R1.hi;\n      R0.hi.edge:=hout;\n      R1.lo:=R0.lo;\n      R1.lo.edge:=lout;\n   end;\nend;{execless}\n\nprocedure execleq(var Sr:State; var R0,R1:Int);\n{R0 =< R1}\nbegin\n   if Point(R0) or Point(R1) then Sr:=-1;\n   if geS(R1.lo,R0.hi) then Sr:= -1 else\n   begin\n      R0.hi:=R1.hi;\n      R1.lo:=R0.lo;\n   end;\nend;{execleq}\n\nprocedure execnoteq(var Sr:State; var R0,R1:Int);\n{R0 <> R1}\nbegin\n   case Sr of\n   0:{nothing done yet}\n     begin\n     if gtS(R0.lo,R1.hi) or gtS(R1.lo,R0.hi) \n     then Sr:=-1 {no need to check in future}\n     else \n     begin\n        if Point(R0) then \n\tbegin\n\t   OuterExec(PC,DCurr,true,1,Counter,Level+1);\n\t   Sr:=2;\n\t   execless(Sr,R1,R0);\n\tend else\n\tif Point(R1) then\n\tbegin\n\t   OuterExec(PC,DCurr,true,2,Counter,Level+1);\n\t   Sr:=1;\n\t   execless(Sr,R0,R1);\n\tend;\n     end;\n     end;\n   1:execless(Sr,R0,R1);\n   2:execless(Sr,R1,R0);\n   end;\nend;{execnoteq}\n\nprocedure execsqrr(var R0,R1:Int);\nbegin{execsqrr}\nend;{execsqrr}\n\nprocedure execminr(var R0,R1,R2:Int);\nbegin{execminr}\nend;{execminr}\n\nprocedure execmaxr(var R0,R1,R2:Int);\n  procedure chmaxhi(S0,S1:Sreal; var S2:Sreal);\n  var Closed:boolean;  Exp,M0,M1:integer;\n  begin{chmaxhi}\n  with S2 do\n  begin\n     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then\n     begin  \n        S2:=PlusInfS;\n        Closed:=((S0.cardinality=infinite)and(S0.edge=hin))or\n\t        ((S1.cardinality=infinite)and(S1.edge=hin));\n     end else\n     begin\n        Closed:=(S0.edge=hin)and(S1.edge=hin);\n        AlignUp(S0.exp,S0.mantissa,S1.exp,S1.mantissa,Exp,M0,M1,Closed);\n        if M1 > M0 then\n           M0 := M1 ;\n\tNormalizeUp(Exp,M0,S2,Closed)\n     end;\n     if Closed then S2.edge:=hin else S2.edge:=hout;\n  end;\n  end;{chmaxhi}\n  \n  procedure chmaxlo(S0,S1:Sreal; var S2:Sreal);\n  var Closed:boolean;  Exp,M0,M1:integer;\n  begin{chmaxlo}\n  with S2 do\n  begin\n     if (S0.cardinality=infinite)or(S1.cardinality=infinite) then\n     begin  \n        S2:=MinusInfS;\n        Closed:=((S0.cardinality=infinite)and(S0.edge=lin))or\n\t        ((S1.cardinality=infinite)and(S1.edge=lin));\n     end else\n     begin\n        Closed:=(S0.edge=lin)and(S1.edge=lin);\n        AlignUp(S0.exp,-S0.mantissa,S1.exp,-S1.mantissa,Exp,M0,M1,Closed);\n\tNormalizeUp(Exp,M0+M1,S2,Closed); mantissa:=-mantissa;\n     end;\n     if Closed then S2.edge:=lin else S2.edge:=lout;\n  end;\n  end;{addlo}\nbegin{execmaxr}\nend;{execmaxr}\n\nprocedure execmodu(var R0,R1,R2:Int);\nbegin{execmodu}\nend;{execmodu}\n\nprocedure execabsr(var R0,R1:Int);\nbegin{execabsr}\nend;{execabsr}\n\nprocedure exectrig(var R0,R1,R2:Int);\nbegin{exectrig}\nend;{exectrig}\n\nprocedure execexpr(var R0,R1:Int);\nbegin{execexpr}\nend;{execexpr}\n\n\nfunction Exec(I:Instr;var PC:Loc0;var Change:boolean):boolean;\nvar\n\tR:array[0..Par] of Int;  {working registers}\n\tSr:State;  {State register}\n\tP:0..Par;\n\tE:boolean;\n\tNewPC:Loc0;\n\tTraceChange:boolean;\n\n   procedure WritePars; {write out list of parameter registers for curr ins}\n   begin\n   with I do\n   begin\n      write(PC:2,Code:5,Sr:3);\n      for P := 0 to Par do\n         if Pars[P] <> 0 then \n\t begin\n\t    write(Pars[P]:3);\n\t    WriteInt(R[P]);\n\t end;\n      writeln;\n   end;\n   end;{WritePars}\n\nbegin{Exec}\nwith I,DCurr do\nbegin\n   Counter:=Counter+1;\n   {get parameters}\n   for P := 0 to ParN[Code] do \n   begin R[P]:=D[Pars[P]]; assert(CheckInt(R[P]));\n   end;\n   \n   Sr:=S[PC];\n   if Debug >= trace then  begin write(' '); WritePars; end;\n   E:=true;\n   Change:=false;\n   NewPC:=PC;\n\n{!!}case Code of \n   print: execprint(PC,Pars[0],R[0]);\n   pr   : execpr(Sr,Pars[0]);\n   tr   : exectr(Sr,Pars[0]);\n   soln : execsoln(Sr,Pars[0]);\n   readr: execreadr(Sr,R[0]);\n   halve: exechalve(NewPC,Sr,R[0],E,Change);\n   halves:exechalves(NewPC,Sr,R[0],E,Change);\n   linh : execlinh(NewPC,Sr,R[0],E,Change);\n   mult : execmult (Sr,R[0],R[1],R[2],R[0],R[1],R[2],E);\n   add  : execadd  (R[0],R[1],R[2],R[0],R[1],R[2]);\n   intgr: execintgr(Sr,R[0]);\n   less : execless (Sr,R[0],R[1]);\n   leq  : execleq  (Sr,R[0],R[1]);\n   noteq: execnoteq(Sr,R[0],R[1]);\n   sqrr : execsqrr(R[0],R[1]);\n   minr : execminr(R[0],R[1],R[2]);\n   maxr : execmaxr(R[0],R[1],R[2]);\n   modu : execmodu(R[0],R[1],R[2]);\n   absr : execabsr(R[0],R[1]);\n   trig : exectrig(R[0],R[1],R[2]);\n   expr : execexpr(R[0],R[1]);\n   lb   : execlb (R[0],R[1]);\n   ub   : execub (R[0],R[1]);\n   copy : execcopy(R[0],R[1]);\n   end;\n\n   TraceChange:=false;\n   AllPoints:=true;\n   for P := 0 to ParN[Code] do\n   with D[Pars[P]] do\n   begin\n      if DF.PF[Pars[P]]=PPrint then TraceChange:=true;\n      assert(CheckLo(R[P].lo));assert(CheckHi(R[P].hi));\n      if ParIntersect [Code] then\n         begin\n            maxS(R[P].lo,lo,R[P].lo);\n            minS(R[P].hi,hi,R[P].hi);\n         end ;\n      if gtS(R[P].lo,R[P].hi) then \n      begin E:=false; assert(CheckLo(R[P].lo));assert(CheckHi(R[P].hi));\n      end\n      else begin\n         if D[Pars[P]] <> R[P] then \n         begin \n\t    D[Pars[P]] := R[P]; \n\t    Change:=true;\n\t    if DF.PF[Pars[P]] = PTrace then TraceChange:=true;\n         end;\n         AllPoints:=AllPoints and Point(R[P]);\n         assert(CheckInt(R[P])); assert(CheckInt(D[Pars[P]]));\n      end;\n   end;\n\n   if (Debug=activity) and TraceChange then writeln;\n   if (Debug >=activity) then \n   begin if Change then write('*') else write ('.');\n   end;\n   Exec:=E;\n   if E then\n   begin\n      if AllPoints then Sr:=-1; \n      if (Sr <> S[PC]) then begin S[PC]:=Sr; Change:=true; end;\n      if (Debug=activity) and TraceChange then WritePars;\n      if Debug >= post then  WritePars;\n      if Debug = dump then DumpMem(DCurr);\n   end else \n   if Debug >= activity then \n   begin writeln('FAILED'); write(' '); WritePars; \n   end;\n   PC:=NewPC;\nend;\nend;{Exec}\n\nbegin{OuterExec}\n   writeln;\n   writeln(Level:2,'Entering  Count:',OldCounter:0); OldCounter:=0;\n   Counter:=0;\n   Fail:=false;\n   if First <> 0 then DCurr.S[PC]:=First;\n   {Run simulation until failure or nothing further to be done}\n   repeat\n        if (PC = End) then \n   \tbegin PC:=1; Change:=false; DCurr.LastHalve:=1; end;\n   \twhile (PC < End) and not Fail and not GlobalEnd do\n   \twith I[PC] do\n   \tbegin\n   \t   if DCurr.S[PC] > -1 then\n\t   begin Fail:=not Exec(I[PC],PC,LocalChange); \n\t      Change:=Change or LocalChange;\n\t   end;\n   \t   PC:=PC+1;\n   \tend;\n   until Fail or (not Change) or GlobalEnd;\n   writeln;\n   write(Level:2,'Exiting  Count:',Counter:0);\n   if not (Fail or GlobalEnd) then\n   begin \n      if (Cut=once) then GlobalEnd:=true;\n      writeln('SOLUTION');\n      WriteMem(DCurr);\n   end \n   else writeln;\nend;{OuterExec}\n\n\nprocedure Clear;\nvar tL:Loc; \n    tD,tDF:Ptr; \n    tPar:1..Par; \n    DI:1..Digits;\n    J:1..Maxexp;\n    MaxDiff:real;\nbegin\n   Shift[0]:=1;\n   for DI:= 1 to Digits do Shift[DI]:=Shift[DI-1]*10;\n\n   with PlusInfS do\n   begin\n      edge:=hin;cardinality:=infinite;mantissa:=Maxinf;\n      exp:=Maxexp;\n   end;\n   with MinusInfS do\n   begin\n      edge:=lin;cardinality:=infinite;mantissa:=Mininf;\n      exp:=Maxexp;\n   end;\n   with PlusFiniteS do\n   begin\n      edge:=hin;cardinality:=finite;mantissa:=Maxman;\n      exp:=Maxexp;\n   end;\n   with MinusFiniteS do\n   begin\n      edge:=lin;cardinality:=finite;mantissa:=Minman;\n      exp:=Maxexp;\n   end;\n   with ZeroS do\n   begin exp:=0;mantissa:=0;edge:=hin;cardinality:=finite;\n   end;\n   with PlusSmallS do\n   begin exp:=Minexp;mantissa:=Maxinf div 10; cardinality:=finite;\n   end;\n   with MinusSmallS do\n   begin exp:=Minexp;mantissa:=Mininf div 10; cardinality:=finite;\n   end;\n   \n\n\n   with Zero do\n   begin lo:=ZeroS;lo.edge:=lin; hi:=ZeroS;hi.edge:=hin;\n   end;\n   with All do\n   begin hi:=PlusInfS; lo:=MinusInfS;\n   end;\n   with AllFinite do\n   begin lo:=MinusFiniteS; hi:=PlusFiniteS;\n   end;\n\n   with DF do\n   begin\n        for tDF:= 1 to DMem do PF[tDF]:=PNull;\n   end;\n  \n   with DInit do\n   begin\n\tfor tD:= 1 to DMem do\n\t   if Verifiable then D[tD]:=AllFinite\n\t   \t\t else D[tD]:=All;\n\tLastHalve:=1;\n\n\tMaxDiff:=2;\n\tfor J:=1 to Maxexp do MaxDiff:=MaxDiff*10;\n\t\n\tfor tL := 1 to IMem do\n\tbegin\n\t   RHalve[tL]:=MaxDiff;\n\t   S[tL]:=0;\n\t   with I[tL] do\n\t   for tPar := 1 to Par do\n\t\tPars[tPar]:=0;\n\tend;\n\n{!!}\tParN[print]:=0;\n        ParN[pr]:=0;\n        ParN[tr]:=0;\n        ParN[soln]:=0;\n\tParN[halve]:=0;\n\tParN[halves]:=0;\n\tParN[readr]:=0;\n\tParN[linh]:=0;\n\tParN[mult]:=2;\n\tParN[add]:=2;\n\tParN[intgr]:= 0;\n\tParN[less]:= 1;\n\tParN[leq]:= 1;\n\tParN[noteq]:= 1;\n\tParN[sqrr]:= 1;\n\tParN[minr]:=2;\n\tParN[maxr]:=2;\n\tParN[modu]:= 1;\n\tParN[absr]:= 1;\n\tParN[trig]:=2;\n\tParN[expr]:= 1;\n        ParN[lb]:= 1;\n        ParN[ub]:= 1; \n        ParN[copy]:= 1; \n\tParN[stop]:=-1;\n{!!}\tParIntersect[print]:= true;\n        ParIntersect[pr]:= true;\n        ParIntersect[tr]:= true;\n        ParIntersect[soln]:= true;\n\tParIntersect[halve]:=true;\n\tParIntersect[halves]:=true;\n\tParIntersect[readr]:=true;\n\tParIntersect[linh]:=true;\n\tParIntersect[mult]:=true;\n\tParIntersect[add]:=true;\n\tParIntersect[intgr]:= true;\n\tParIntersect[less]:= true;\n\tParIntersect[leq]:= true;\n\tParIntersect[noteq]:= true;\n\tParIntersect[sqrr]:= true;\n\tParIntersect[minr]:= true;\n\tParIntersect[maxr]:= true;\n\tParIntersect[modu]:= true;\n\tParIntersect[absr]:= true;\n\tParIntersect[trig]:= true;\n\tParIntersect[expr]:= true;\n        ParIntersect[lb]:= false;\n        ParIntersect[ub]:= false;\n\tParIntersect[stop]:= true;\n\tParIntersect[copy]:= true;\n   end;\nend;{Clear}\n\t\nprocedure ReadInstr;\nvar\n\ttP:0..Par;\n\tOp:OpType;\n\ttDat:Ptr;\nbegin\n   with DInit do\n   begin\n\tEnd:=1;\n\tMaxDMem:=0;\n\trepeat\n\t   with I[End] do\n\t   begin\n\t      read(Op);\n\t      Code:=Op;\n\t      for tP := 0 to ParN[Op] do with I[End] do \n\t      begin\n\t         read(tDat); Pars[tP]:=tDat;\n\t\t if tDat>MaxDMem then MaxDMem:=tDat;\n\t\t if MaxDMem > DMem then \n\t\t begin writeln('Too many variables');halt;\n\t\t end;\n\t      end;\n\t      readln;\n\t   end;\n\t   End:=End+1; \n\t   if End >= IMem then begin writeln('Too many instructions');halt;end;\n\tuntil Op = stop;\n\tEnd:=End-1;\n\n\twhile not eof do {read constant values for memory locations}\n\tbegin\n\n   \t   read(tDat);\n\t   if tDat > DMem then writeln('Variable out of range',tDat,DMem);\n\t   ReadInt(D[tDat]);\n\t   readln;\n\tend;\n   end;\nend;{ReadInstr}\n\nbegin\n\tGlobalEnd:=false;\n\tInitialOptions;\n\treadln(Cut);\n\twriteln(Cut);\n\tClear;\n\t{ set to initial values, read instructions}\n\tReadInstr;\n\tif Debug = dump then begin DumpTables; DumpMem(DInit); end;\n\tif Debug >= activity then WriteMem(DInit);\n\tDummy:=0;\n\tOuterExec(1,DInit,false,0,Dummy,0);\n\tif Debug = dump then DumpMem(DInit);\nend.\n", "encoding": "ascii"}