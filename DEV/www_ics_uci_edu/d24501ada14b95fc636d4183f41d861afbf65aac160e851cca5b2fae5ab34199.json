{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990914.txt", "content": "WebDAV Advanced Collections Minutes September 14, 1999\n\nATTENDING: Judy Slein, Geoff Clemm, Chuck Fay, Jason Crawford\n\nACTION ITEMS\n\nJudy: Respond to Jim Amsden on Issue 8, explaining why we are\nnot making any changes to the spec.\n\nJudy: Start a thread on whether / how to provide more than just\n501 (Not Implemented) when a binding cannot be created.\n\nGeoff: Write replacement text for the algorithm for determining\nwhat new URL mappings are introduced by a new binding.\n\nJudy: Draft new language for the section \"Bindings and Other\nMethods\" and send it to the mailing list.\n\nGeoff: Write up arguments against protecting the LOCK Request-URI,\nand send them to the mailing list.\n\nJudy: Send out proposal for a GUID property.\n\nLOGISTICS\n\nDecide whether to have an unofficial advanced collections meeting \nat IETF, in addition to the official WebDAV meeting.  Make this \ndecision early enough for people to take it into account when\ndeciding whether to attend IETF.\n\nISSUE 7: RESOURCE-TYPE HEADER IS NOT EXTENSIBLE.\n\nAGREED: We will get rid of the Resource-Type header and instead\nreturn the DAV:reftarget property in the response body.  This will \nlet clients know that the 302 is from a redirect reference, and\nalso gives them the relative URI of the target.\n\nJudy: This is true, but all we are using it for is in 302\nresponses, to let clients know that it's not an ordinary HTTP 302,\nbut a response from a redirect reference.  So we could just use\na Redirect-Ref header with no value (it's either present or not).\n\nGeoff: Prefers using XML in the message body.  The parser is cheap\nto invoke.  There's no real runtime cost.\n\nGeoff: Doesn't like using headers.  They are global, that is, they\nneed to be usable with all methods.  There is a length limit.  He\nwould only favor a header if there is already a defined body being\nused for something else.\n\nJudy: In this case, it is global -- it gets returned by all methods\nwhenever there is a 302 response from a redirect reference.\n\nGeoff: Generally it's good to use XML for additional information\nabout an error.  There might be other information about the 302 that\nyou might want to return.\n\nThis issue is related to Issue 14, trying to limit the number of \nnew headers we define.\n\nISSUE 8: IT IS IMPOSSIBLE TO GUARANTEE REFERENTIAL INTEGRITY FOR\nBINDINGS.\n\nAGREED:  We will not weaken the spec.  We require a guarantee of\nintegrity for bindings.\n\nJudy: Not sure exactly what Jim is getting at, but it looks like\nhe is imagining that the server where the resource lives might go\ndown, while the server where a binding lives is running.  Then\nthe binding is at least temporarily broken.\n\nGeoff: It the server is willing to go to enough trouble, it can\nguarantee the integrity of its binding to the remote resource.  It\ncan store a copy of the resource locally, and make it a policy that\nunless both participants are up, no changes to the resource are\nallowed.  It could respond with \"Temporarily unavailable\" to\nrequests that would make changes in case the other server is down.\n\nChuck: In effect, you have to keep state on the server for all \nbindings that it holds.\n\nGeoff: The one thing we want to avoid is for a client to use one \nname and get one value, but use a different name and get a \ndifferent value.\n\nProbably few servers will attempt to support cross-server bindings.\n\nSTATEMENTS ABOUT CROSS-SERVER BINDINGS\n\nGeoff: There should be nothing in the spec about cross-server \nanything except rationale for decisions.  We should never fork based \non same-server / cross-server.\n\nAGREED: We will strike statement that support for cross-server \nbindings is OPTIONAL.\n\nGeoff: It's OK to leave the discussion about the difficulty of\nguaranteeing the integrity of bindings across servers if we label \nit as an implementer's note.  Or move it to a different, supporting\ndocument.\n\nCurrently we say that if the server can't guarantee the required\nbehavior for the binding, it must fail the BIND request with a 501\n(Not Implemented).  We may want to provide better information, about\nwhy the binding can't be created, especially in the case of cross-\nserver bindings.  Geoff sees no problem with talking about cross-\nserver operations in error descriptions.\n\nThere are at least 3 possibilities, each favored by one member of the\nteam:\n1. A new error code for \"Can't create binding\" or even \"Can't create\ncross-server binding\". (Judy prefers this.)\n2. Use 501, but put an explanation in the response body. (Geoff prefers\nthis.)\n3. Use 501, and don't provide any further explanation. Keep it simple.\n(Chuck prefers this.)\n\nJudy will take these options to the mailing list.\n\nISSUE 9: WHAT TO SAY ABOUT TRAILING \"/\" ON REQUEST-URI AND DESTINATION\nHEADER OF BIND REQUESTS\n\nAGREED: We will remove the language related to trailing slashes from\nthe BIND method, and remove the corresponding BIND Conflict example.\n\nThe presence or absence of a trailing \"/\" cannot be relied upon for\nany indication of the type of resource.\n\nISSUE 10: ALGORITHM FOR DETERMINING URL MAPPINGS\n\nGeoff will write replacement text for how to determine all the new mappings\nintroduced by a bind.  It is easier to specify what will change than to try\nto specify the complete set of mappings, old and new.\n\nISSUE 11: WHAT TO SAY ABOUT PUT AND POST IN RELATION TO BINDINGS\n\nAGREED: 2 bindings to same resource always produce same result for\nall methods; if can't guarantee that, BIND must fail (so probably\ncan't bind to dynamic resources)\n\nJudy: The concern is that if the resource is a cgi script or other\nexecutable that dynamically produces content, you can't be assured\nthat the result will be the same no matter which binding you use to\naccess it.  The language takes this into account for most methods, but\nI couldn't think of a case where PUT might have different results\ndepending on the Request-URI.  Can anyone think of a case?\n\nGeoff: One URI might translate the content into French, another\ninto Spanish.\n\nChuck: For GET, using a binding with pdf in it might retrieve the\nPDF rendition, while a binding with html in it might retrieve the\nHTML rendition.\n\nGeoff: If you get different results using different URIs, then they\nare not bindings but something else.\n\nGeoff: We need to say something about the normal case, the intent with some\nexceptions.\n\nJudy: The trouble is that we can't anticipate all the exceptions.  We\ncan't give a clean definition of the exceptions.\n\nWe are trying to distinguish between static and dynamic responses.\n\nIf a resource has access to the Request-Uri, it can perform arbitrary \nbehavior depending on the Request-Uri.  We can say that for bindings\nthat's not legal.\n\nWe can leave it vague, and depend on people's intuition: The general\nintent is for it to appear to be the same resource responding to the\nsame request through any Request-URI. \n\nThat would argue for deleting the section, as Yaron suggested.\n\nGeoff: We can at least say that dead properties display the same no\nmatter which binding is used to access the resource.\n\nWe can at least define a GUID (see Issue 12), and then say that\nit is guaranteed that all bindings to the same resource would return \nsame GUID.\n\nGeoff: This spec is about authoring.  For the resources that Jim\nis calling \"functors\", you can't author the resource directly.  You\nwould have to follow its DAV:source property to do that.  The\nRequest-URI that you use to address a functor does not map to a\nbinding.\n\nConsider a dynamic resource that returns the current time. When\nyou access that resource, by the same or a different URI, you get \na different value each time.  But the thing that you author, the\nthing you would do a PUT to, is the resource identified by the\nDAV:source property.  You would get the same result every time if\nyou did a GET to that resource.\n\nYou can't PUT to a dynamic resource.\n\nWhat we care about is the Source resource and authoring that.\nThere can be multiple bindings to that for authoring. You don't \nauthor the dynamic things, but rather their source.\n\nChuck: Distinguish between static and dynamic resources.  It's the\nstatic ones where 2 bindings must behave the same. \n \nGeoff: There are not multiple bindings to dynamic resources. There\nmight be multiple bindings to the source resource.\n\nGeoff hesitates to rely on static vs dynmic, but we can say whether\nBIND works.  We say that BIND must fail if you can't guarantee that\nGET using the new binding will always get the same result as GET\nthrough the existing binding.\n\nChuck: We might want to have multiple bindings to a dynamic \nresource (e.g., the clock).\n\nGeoff: If the cost of binding to executables is not being able to \nsay anything intelligible about the semantics of bindings, that \ncost is too high.  Let's just not allow bindings to executables.\n\nGeoff: 2 bindings to same resource always produce same result for\nall methods; if can't guarantee that, BIND must fail (so probably\ncan't bind to dynamic resources)\n\nJudy will draft language for this proposal and send it to the mailing\nlist.\n\nISSUE 1: MOVE AND LOCKS\n\nAGREED: If the source resource is locked individually, the lock\nmoves with it.  We will not put anything in the protocol that is\nspecific to cross-server moves.\n\nAGREED: If the source resource is locked individually, and the\ndestination parent collection is locked with a different token,\nthe MOVE will fail.\n\nIt seems as if opinion is moving toward consensus that it's OK\nfor the lock to move with the resource.\n\nYaron and Greg are opposed to moving locks.  Yaron is concerned\nabout Microsoft file systems not being able to comply.\n\nGeoff: Can't find anything related to locks in Windows 95. If there\nis something, it must be under the covers.\n\nDon't try to make our protocol Windows-95-compliant for the sake\nof something under the covers.\n\nUNIX doesn't have lock tokens, locking, depth locking.\n\nJudy: So we should stick with our basic position that locks move\nwith a resource, but remove all the language about cross-server\nmoves.  We won't provide anything in th protocol special for\ncross-server moves.\n\nJudy: We haven't discussed the case Jason raised about conflicting\nlocks.  What happens if the source resource is locked, and the\ndestination parent collection is locked with a different token?\n\nWe agree that this move fails.\n\nJudy will simplify the proposal on this issue, getting rid of\neverything related to cross-server moves, and re-post to the list.\n\nISSUE 2: PROTECTING THE LOCK REQUEST-URL\n\nAre locks on resources, or are they protections of URIs, or some\nhybrid?\n\nGeoff: Opposes trying to protect the Request-URI at all.  It's too\nexpensive.  When you move a collection, you would have to scan \ndescendents and check whether any descendent is locked, and figure\nout which URL was used to lock it and whether the protected URL\nincludes yours.  Where there may be multiple bindings and only one\npath is protected, that's hard.\n\nJim W said last time that it's only the last segment that he\nreally cares about protecting.\n\nGeoff: In versioning, it's even harder to protect the Request-URI.\n\nGeoff will post his arguments against protecting the Request-URI\nto the mailing list.  So far the discussion has only been about\nSHOULD vs. MUST, but we need discussion about whether it makes\nsense to try to protect the Request-URI at all.\n\nChuck: The motivation for trying to protect the Request-URI is \nthat the client may not know any other URI for the resource, and\nso would be cut off from the resource if the Request-URI no longer\nprovided access to it.\n\nThere was a proposal on the list to make it possible to use the\nlock token as the request-URI  for UNLOCK so that at least it \nwould be possible to release the lock.  That doesn't help with \nother operations.\n\nIt would be nice to have a persistent name for a resource \n(guaranteed to name it for all time) as in DMSs.\n\nChuck: The client could always lock all elements on the path if it really\ncares.  \n\nJason: But that would mean that no one else could make any \nchanges anywhere in the namespace since he would have to lock the\nroot collection.\nAlso, if there are non-DAV resources above, it wouldn't be possible\nto lock those, so can't protect those so couldn't protect the\nRequest-URI.\n\nChuck: protecting the URI is different from locking all elements \nof the path, because a lock has defined methods that it prevents, \nstronger than protecting as we have proposed it.\n\nProtecting has limited semantics: It affects only DELETE and MOVE,\nlike defining a \"protect lock\".\nWe could define a semantics that would allow clients to do the\nprotecting, but would allow others to do useful work while the\n\"protect lock\" was in place.\n\nPROPOSAL: Don't protect the Request-URL.  Do allow an unlock on \nthe token itself.\n\nISSUE 12: DEFINE A GUID PROPERTY THAT CAN BE USED TO DETERMINE\nWHETHER 2 BINDINGS ARE TO THE SAME RESOURCE.\n\nAGREED: We will define such a property.\n\nJudy will send mail about this to the list.\n\nIt could just be an ID, not a URN.  It could even be a URN.  \nPeople aren't opposed to URNs per se, but only to using URNs as\nURLs.\n\nChuck: Maybe must just be globally unique, but doesn't need to \nfollow any particular guid generation algorithm.  With lock tokens,\nwe gave an example algorithm, but didn't require its use.  \n\nMake it a URI so that you know what namespace you are in.\n\nISSUE 13: CLARIFY WHAT \"OPTIONAL\" MEANS FOR DAV:bindings\n\nAGREED: The property is optional per resource.  If it exists, it\nmust contain a complete list of the bindings to that resource.\n\nChuck: Is it possible to be sure the list is complete?\n\nJudy: We think yes, because we are requiring BIND to fail unless\nintegrity can be guaranteed.  You couldn't make that guarantee\nunless the resource knew about all bindings to it.\n\nISSUE 14: CAN WE GET RID OF SOME SIMILAR HEADERS: Destination,\nLocation, Ref-Target\n\nThe only one we are introducing is Ref-Target.  We use that only\nin MKREF requests.\n\nGeoff: Would prefer just putting the DAV:reftarget property into \nthe body of MKREF.  We could also do that in 302 responses instead\nof using the Resource-Type header.\n\nThat would cut by 2 the number of new headers we are defining.\n\nAGREED: We'll accept Geoff's suggestion.\n\n\n", "encoding": "ascii"}