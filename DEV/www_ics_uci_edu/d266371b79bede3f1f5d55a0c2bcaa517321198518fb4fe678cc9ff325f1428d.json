{"url": "https://www.ics.uci.edu/~eppstein/161/960307.html", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<html>\n<head>\n<title>Computational Geometry</title>\n<meta name=\"Owner\" value=\"eppstein\">\n<meta name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</head>\n<body>\n<h1>ICS 161: Design and Analysis of Algorithms<br>\nLecture notes for March 7, 1996</h1>\n\n<!--#config timefmt=\"%d %h %Y, %T %Z\" -->\n<hr>\n<p></p>\n\n<h1>Computational Geometry</h1>\n\n<h2>What is computational geometry?</h2>\n\nMany situations in which we need to write programs involve\ncomputations of a geometric nature. \n\n<p></p>\n\n<ul>\n<li>For instance, in <a href= \n\"http://www.ics.uci.edu/~eppstein/gina/vidgames.html\">video\ngames</a> such as Doom, the computer must display scenes from a\nthree-dimensional environment as the player moves around. This\ninvolves determining where the player is, what he or she would see\nin different directions, and how to translate this\nthree-dimensional information to the two-dimensional computer\nscreen. A data structure known as a <a href= \n\"http://www.qualia.com/bspfaq/\">binary space partition</a> is\ncommonly used for this purpose. \n\n<p></p>\n</li>\n\n<li>In order to control <a href= \n\"http://www.ics.uci.edu/~eppstein/gina/robot.html\">robot\nmotion</a>, the computer must generate a model of the obstacles\nsurrounding the robot, find a position for the robot that is\nsuitable for whatever action the robot is asked to perform,\nconstruct a plan for moving the robot to that position, and\ntranslate that plan into controls of the robot's actuators. One\nexample of this sort of problem is parallel parking a car -- how\ncan you compute a plan for entering or leaving a parking spot,\ngiven a knowledge of nearby obstacles (other cars) and the turning\nradius of your own car? \n\n<p></p>\n</li>\n\n<li>In <a href=\n\"http://www.ics.uci.edu/~eppstein/gina/meshgen.html\">scientific\ncomputation</a> such as the simulation of the airflow around a\nwing, one typically partitions the space around the wing into\nsimple regions such as triangles (as shown below), and uses some\nsimple approximation (such as a linear function) for the flow in\neach region. The computation of this approximation involves the\nnumerical solution of differential equations and is outside the\nscope of this class. But where do these triangles come from?\nTypically the actual input consists of a description of the wing's\noutline, and some algorithm must construct the triangles from that\ninput -- this is another example of a geometric computation.</li>\n</ul>\n\n<center><img src=\"barth.gif\" width=\"501\" height=\"234\" alt=\n\"triangulated mesh for airfoil simulation\"></center>\n\n<p>For more descriptions of these and other applications of\ncomputational geometry, see my web site \"<a href= \n\"http://www.ics.uci.edu/~eppstein/geom.html\">Geometry in\nAction</a>\".</p>\n\n<p>Today's lecture will describe algorithms for two simple\ngeometric problems: determining whether a point is in a polygon,\nand finding <i>convex hulls</i>. Next quarter I will be offering\nICS 164, a class devoted entirely to geometric algorithms, in which\nI'll describe some more algorithms and applications, for instance\nthe binary space partitions used by Doom.</p>\n\n<h2>Polygons</h2>\n\nA <i>polygon</i> is just a collection of line segments, forming a\ncycle, and not crossing each other. We can represent it as a\nsequence of points, each of which is just a pair of coordinates.\nFor instance the points \n\n<pre>\n    (0,0),  (0,1),  (1,1),  (1,0)\n</pre>\n\nform a square. The line segments of the polygon connect adjacent\npoints in the list, together with one additional segment connecting\nthe first and last point. \n\n<p>Not all sequences of points form a polygon; for instance the\npoints</p>\n\n<pre>\n    (0,-1),  (0,1),  (1,0),  (0,-1)\n</pre>\n\nwould result in two segments that cross each other. Sometimes we\nuse the phrase <i>simple polygon</i> to emphasize the requirement\nthat no two segments cross. \n\n<h2>Testing if a point is in a polygon</h2>\n\nIt is a famous theorem (the <i>Jordan curve theorem</i>) that any\npolygon cuts the plane into exactly two connected pieces: the <i>\ninside</i> and the <i>outside</i>. (The inside always has some\nfinite size, while the outside contains points arbitrarily far from\nthe polygon.) Actually, the Jordan curve theorem is more generally\ntrue of certain curves in the plane, not just shapes formed by\nstraight line segments; the more general fact is often proved by\napproximating these curves by polygons. \n\n<p>For uncomplicated enough polygons, it's easy to see by eye which\nparts of the plane are inside and which are outside. But this is\nnot always easy. For instance is the marked point inside the\nfollowing polygon?</p>\n\n<center><img src=\"theseus.gif\" width=\"468\" height=\"367\" alt=\n\"spiral polygon; is point in or out?\"></center>\n\n<p> Seemingly even more difficult, we'd like to answer questions\nlike this on a computer, which doesn't have built into it the\npowerful visual processing system that we have, and can only deal\nwith this sort of problem by translating it to a collection of\nnumbers. The general problem we'd like to solve is, given a point\n(x,y) (represented by those two numbers) and a polygon P\n(represented by its sequence of vertices), is (x,y) in P, on the\nboundary, or outside?</p>\n\n<p>This is a commonly occurring problem, enough so that it is one\nof the most <a href= \n\"http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html\">frequently\nasked questions</a> on the comp.graphics.algorithms newsgroup. For\ninstance if you want to display a polygon on a computer screen, you\nneed to be able to test whether each pixel of the screen\ncorresponds to a point that's inside or outside the polygon, so you\ncan tell what color to draw it.</p>\n\n<p>Fortunately the problem has a simple and elegant answer. Just\ndraw a ray (portion of a line extending infinitely in one\ndirection) down (or in any other direction) from (x,y):</p>\n\n<center><img src=\"ariadne.gif\" width=\"468\" height=\"369\" alt=\n\"spiral polygon: count crossings on ray\"></center>\n\n<p> Every time the polygon crosses this ray, it separates a part of\nthe ray that's inside the polygon from a part that's outside.\nEventually the ray will get far from the polygon, at which point we\nknow that that part is outside the polygon. We can then work\nbackwards from there, declaring different parts of the ray to be\ninside or outside alternately at each crossing. Actually, we don't\neven need to look at what order these crossings occur in; all we\nreally need to know is whether there's an even or odd number of\nthem. In the example shown above, there are eight crossings, so the\npoint is outside the polygon.</p>\n\n<p>We can now write a rough outline of pseudo-code for this\nproblem:</p>\n\n<pre>\n    int crossings = 0\n    for (each line segment of the polygon)\n        if (ray down from (x,y) crosses segment)\n            crossings++;\n    if (crossings is odd)\n        return (inside);\n    else return (outside);\n</pre>\n\n<h2>Details of the point-in-polygon routine</h2>\n\nNormally when we do computational geometry, we'd just stop here.\nAll the rest is details to be filled in only when you actually\nwrite a program. But it's useful to see, at least once, what this\nsort of detail looks like. \n\n<p>As we'll see, we also need to be a little more careful:\ncrossings can also occur at vertices of the polygon, and we haven't\nchecked whether (x,y) sits exactly on the boundary. First let's see\nhow to implement the steps of this pseudo-code.</p>\n\n<p>How do we tell if the ray down from (x,y) crosses the segment\nbetween two points (x1,y1) and (x2,y2)? All points of the ray have\nthe same first coordinate x. If this is to be between (x1,y1) and\n(x2,y2) then x should be between x1 and x2; either (x1&lt;x and\nx&lt;x2) or (x1&gt;x and x&gt;x2). We can write this more\nsuccinctly as (x1-x)(x2-x)&lt;0 but this might actually slower\nsince it involves a high-precision multiplication.</p>\n\n<p>Now suppose x is between x1 and x2. Where is the crossing point?\nDoes it have a smaller second coordinate than y? One definition of\nthe line determined by points (x1,y1) and (x2,y2) is that it\nconsists of all points of the form</p>\n\n<pre>\n    (t x1 + (1-t)x2, t y1 + (1-t)y2)\n</pre>\n\nwhere different values of t give different points on the line. To\nfind the second coordinate of the crossing, let's use the known\nvalue of the first coordinate to solve for t: \n\n<pre>\n    x = t x1 + (1-t)x2\n\n    t = (x - x2) / (x1 - x2)\n\n    crossing = (x, t y1 + (1-t)y2)\n</pre>\n\nNote that we can also tell if (x,y) is exactly on the line segment\nby testing whether y=crossing. Here's a little problem: this\nformula might involve a division by zero. But in that case x1=x2 so\nx couldn't be between the two. As long as we only compute t when x\nis between x1 and x2, we're safe. Let's plug these formulas into\nour pseudo-code. We'll let n denote the number of points in the\npolygon, and P(i).x and P(i).y denote the coordinates of point (i\nmod n). \n\n<pre>\n    int crossings = 0\n    for (int i = 0; i &lt; n; i++)\n        if ((P(i).x &lt; x &amp;&amp; x &lt; P(i+1).x) || (P(i).x &gt; x &amp;&amp; x &gt; P(i+1).x))\n        {\n            t = (x - P(i+1).x) / (P(i).x - P(i+1).x)\n            cy = t*P(i).y + (1-t)*P(i+1).y\n            if (y == cy) return (on boundary)\n            else if (y &gt; cy) crossings++;\n        }\n    if (crossings is odd)\n        return (inside);\n    else return (outside);\n</pre>\n\nFinally, what happens if the ray from (x,y) passes exactly through\na vertex of P? Sometimes this should count as a crossing, but\nsometimes the ray only \"grazes\" P and shouldn't count as a\ncrossing. There are lots of cases to consider, so this may be\nconfusing. A standard way to cut through this sort of complication\nis to <i>perturb</i> the problem: move the points slightly so these\nspecial cases don't happen. For instance, we could move the point\n(x,y) just a tiny amount to the right; this won't change whether\nit's inside or outside the polygon but will change whether the ray\ncrosses through any vertices. In fact, we can perform this\nperturbation only in our minds, and let it guide us in thinking\nabout solving the problem, without actually moving any points.\nSuppose the ray would cross a vertex before it was perturbed. After\nthe perturbation, which edges would it cross? Just the ones that go\nto the right of the vertex. We can test the two rays out of the\nvertex and see which of them go rightwards, and adjust the count\naccordingly. Again, we also need to be careful about testing\nwhether the point is exactly on the boundary of the polygon; the\nmost complicated case is when this happens on a vertical line\nsegment. \n\n<pre>\n    int crossings = 0\n    for (int i = 0; i &lt; n; i++)\n    {\n        if ((P(i).x &lt; x &amp;&amp; x &lt; P(i+1).x) || (P(i).x &gt; x &amp;&amp; x &gt; P(i+1).x))\n        {\n            t = (x - P(i+1).x) / (P(i).x - P(i+1).x)\n            cy = t*P(i).y + (1-t)*P(i+1).y\n            if (y == cy) return (on boundary)\n            else if (y &gt; cy) crossings++;\n        }\n        if ((P(i).x == x &amp;&amp; P(i).y &lt;= y) {\n            if (P(i).y == y) return (on boundary);\n            if (P(i+1).x == x)\n            {\n                if ((P(i).y &lt;= y &amp;&amp; y &lt;= P(i+1).y) || (P(i).y &gt;= y &amp;&amp; y &gt;= P(i+1).y))\n                    return (on boundary);\n            } else if (P(i+1).x &gt; x) crossings++;\n            if (P(i-1).x &gt; x) crossings++;\n        }\n    }\n    if (crossings is odd)\n        return (inside);\n    else return (outside);\n</pre>\n\nThis is almost completely expanded to compilable code, and it's not\ntoo long, but not easy to read. To understand the ideas behind the\nalgorithm, I'd stick with the pseudo-code I started with in the\nprevious section. \n\n<h2>Points in convex polygons</h2>\n\nA <i>convex polygon</i> is just one without any indentations. It\ncan also be defined formally as having the property that any two\npoints inside the polygon can be connected by a line segment that\ndoesn't cross the polygons. \n\n<p>Convex polygons are typically much easier to deal with than\nnon-convex ones. As an example, let's see how to simplify the\npoint-in-polygon test.</p>\n\n<p>Let P(i) be the leftmost point of the polygon, and P(j) be the\nrightmost point. These two points divide the polygon into two\nparts, the <i>upper chain</i> and the <i>lower chain</i>. Any line\nor ray crosses the polygon at most twice, and any vertical line or\nray crosses each chain at most once.</p>\n\n<p>So a lot of the work of the previous point-in-polygon algorithm\nis wasted -- we go through each segment checking whether it gives a\ncrossing, but the answer will be yes in at most two cases.</p>\n\n<p>How can we find these two cases more quickly? Binary search.\nJust search for x in the first coordinates of points in the two\nchains. If it is in the chain, you have found a crossing through a\nvertex (and you don't have to be as careful to tell what kind of\ncrossing, either). If x is not the coordinate of a vertex in the\nchain, the two nearest values to it tell you which segment the ray\nfrom (x,y) might cross. So we can test whether a point is in a\nconvex polygon in time O(log n).</p>\n\n<p>It turns out that there are data structures that can test\nwhether a point is in an arbitrary polygon (or which of several\npolygons it's in) in the same O(log n) time bound. But they're more\ncomplicated, so I don't have time to describe them here; I'll talk\nabout them at some point in ICS 164.</p>\n\n<h2>Convex hulls</h2>\n\nSince convex polygons are so much nicer to deal with than other\nkinds of polygons, how can we make an input convex? The smallest\nconvex polygon containing a collection of points is known as the\n<i>convex hull</i>; this can also be defined as the intersection of\nthe (infinitely many) <i>halfspaces</i> (portions of the plane on\none side of a line) that contain all the points. \n\n<p>I'll describe an algorithm for finding convex hulls known as the\n<i><a href=\"people.html#graham\">Graham</a> scan</i>. The idea is a\ncommon one in computational geometry, known as an <i>incremental\nalgorithm</i>: add items one at a time to some structure,\nmaintaining as you do a partial solution for the items added so\nfar. The order in which items are added is often important; the\nGraham scan adds points in sorted order from left to right (by the\nvalues of their first coordinates). So O(n log n) time is needed\nfor an initial sorting stage, or less time if you want to assume\ne.g. that the points' coordinates are small integers.</p>\n\n<p>The algorithm is easier to describe in terms of the upper and\nlower chains defined earlier. I'll describe how to compute the\nupper chain; the lower chain is completely symmetric. Because of\nthe order in which we add points, the first point is always the\nleft end of the upper chain, and the last point is always the right\nend. The only question is, what happens in the middle?</p>\n\n<p>The figure below shows what happens when we add one new point to\nthe upper chain. We know it should be at the right end, so let's\ntry adding it after the previous rightmost point. However, this\nmight make an indentation at that previous point; if so we remove\nthe indentation from the chain, making it have one less edge. We\nkeep removing indentations one by one until there are none left, at\nwhich point we have the new chain.</p>\n\n<center><img src=\"graham.gif\" width=\"491\" height=\"477\" alt=\n\"Graham scan steps\"></center>\n\n<p> This is easiest to implement if we maintain the chain using a\nstack data structure. Each new point in the chain corresponds to a\npush in the stack, and removing an indentation corresponds to a\npop. Here is some pseudocode:</p>\n\n<pre>\n    stack S = empty\n    for each point (x,y) in sorted order by x\n    {\n    if (x,y) and top two points on S are indented\n        pop S\n    push (x,y) onto S\n    }\n</pre>\n\nThe only question is how we test whether three points (x0,y0),\n(x1,y1), and (x2,y2) form an indentation. Since we know in this\ncase the ordering of the x-coordinates of the three points, all we\nneed to do is test whether the middle point is above or below the\nline segment formed by the other two. This is basically the same as\nthe math I went through to detect crossings for the\npoint-in-polygon test. \n\n<p>The algorithm goes through O(n) iterations of the outer loop.\nThere is also an inner nested loop, but each iteration of the inner\nloop removes a point from the stack, and each point can only be\nremoved once, so this happens O(n) times total. Therefore the total\ntime for the convex hull algorithm, after the initial sorting\nstage, is O(n). The overall algorithm takes time O(n log n) because\nof the sorting step.</p>\n\n<p>A similar process of shortcutting indentations also works for\nfinding convex hulls of simple polygons. Of course you could just\nsort the vertices of the polygon and apply Graham scan, but you can\ninstead do the shortcutting process on the polygon itself. It is\npossible for a shortcut to add a crossing between two edges, but\nthese will always become untangled by later stages of the angles.\nIn this way, one can find convex hulls of simple polygons in linear\ntime, without taking the time for a sorting stage.</p>\n\n<hr>\n<p><a href=\"/~eppstein/161/\">ICS 161</a> -- <a href=\"/\">Dept.\nInformation &amp; Computer Science</a> -- <a href= \n\"http://www.uci.edu/\">UC Irvine</a><br>\n<small>Last update: \n<!--#flastmod file=\"960307.html\" --></small></p>\n</body>\n</html>\n\n", "encoding": "ascii"}