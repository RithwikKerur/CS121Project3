{"url": "https://www.ics.uci.edu/~dechter/courses/ics-275a/fall-99/slides/node72.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3O//DTD W3 HTML 2.0//EN\">\r\n<!Converted with LaTeX2HTML 95.1 (Fri Jan 20 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >\r\n<HEAD>\r\n<TITLE> Writing Efficient Code</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<meta name=\"description\" value=\" Writing Efficient Code\">\r\n<meta name=\"keywords\" value=\"umsroot\">\r\n<meta name=\"resource-type\" value=\"document\">\r\n<meta name=\"distribution\" value=\"global\">\r\n<P>\r\n <BR> <HR><A NAME=tex2html3115 HREF=\"node73.html\"><IMG ALIGN=BOTTOM ALT=\"next\" SRC=\"http://www.ecrc.de/eclipse/new_icons//next_motif.gif\"></A>   <A NAME=tex2html3113 HREF=\"node63.html\"><IMG ALIGN=BOTTOM ALT=\"up\" SRC=\"http://www.ecrc.de/eclipse/new_icons//up_motif.gif\"></A>   <A NAME=tex2html3107 HREF=\"node71.html\"><IMG ALIGN=BOTTOM ALT=\"previous\" SRC=\"http://www.ecrc.de/eclipse/new_icons//previous_motif.gif\"></A>      <A NAME=tex2html3117 HREF=\"node321.html\"><IMG ALIGN=BOTTOM ALT=\"index\" SRC=\"http://www.ecrc.de/eclipse/new_icons//index_motif.gif\"></A>   <BR>\r\n<B> Next:</B> <A NAME=tex2html3116 HREF=\"node73.html\"> Special Primitives</A>\r\n<B>Up:</B> <A NAME=tex2html3114 HREF=\"node63.html\"> The Compiler</A>\r\n<B> Previous:</B> <A NAME=tex2html3108 HREF=\"node71.html\"> Compiler Pragmas</A>\r\n<BR> <HR> <P>\r\n<H1><A NAME=SECTION00690000000000000000> Writing Efficient Code</A></H1>\r\n<P>\r\nThe <A NAME=tex2html286 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n  compiler tries its best, however there are some\r\nconstructs which can be compiled more efficiently than others.\r\nOn the other hand, many Prolog programmers overemphasise\r\nthe importance of efficient code and write completely unreadable\r\nprograms which can be only hardly maintained and which are only\r\nmarginally faster than simple, straightforward and readable\r\nprograms.\r\nThe advice is therefore <b> Try the simple and straightforward\r\nsolution first!</b>\r\nThe second rule is to keep this original program even if you try\r\nto optimise it. You may find out that the optimisation\r\nwas not worth the effort.\r\n<P>\r\nTo achieve the maximum speed of your programs, you must\r\nproduce the optimised code with the flag <tt> debug_compile</tt>\r\nbeing off, e.g. by calling nodbgcomp/0\r\nor <b> set_flag(debug_compile, off)</b>,\r\nor using the pragma <b> nodebug</b>.\r\nSetting the flag <tt> variable_names</tt> can also cause slight\r\nperformance degradations and it is thus better to have\r\nit off, unless variable names have to be kept.\r\nUnlike in the previous releases, the flag <tt> coroutine</tt>\r\nhas now no influence on the execution speed.\r\nSome programs spend a lot of time in the garbage collection,\r\ncollecting the stacks and/or the dictionary.\r\nIf the space is known to be deallocated anyway, e.g. on failure,\r\nthe programs can be often speeded up considerably\r\nby switching the garbage collector off or by increasing\r\nthe <tt> gc_interval</tt> flag.\r\nAs the global stack expands automatically, this does not cause\r\nany stack overflow, but it may of course exhaust the machine memory.\r\n<P>\r\nWhen the program is running and its speed is still\r\nnot satisfactory, use the profiling tools.\r\nThe profiler can tell you which predicates\r\nare the most expensive ones, and the statistics tool\r\ntells you why.\r\nA program may spend its time in a predicate because the predicate\r\nitself is very time consuming, or because it was frequently executed.\r\nThe statistics tool gives you this information.\r\nIt can also tell whether the predicate was slow because it\r\nhas created a choice point or because there was too much\r\nbacktracking due to bad indexing.\r\n<P>\r\nOne of the very important points is the selection\r\nof the clause that matches the current call.\r\nIf there is only one clause that can potentially match,\r\nthe compiler is expected to recognise this and generate code\r\nthat will directly execute the right clause\r\ninstead of trying several subsequent clauses until the\r\nmatching one is found.\r\nUnlike most of the current Prolog compilers, the <A NAME=tex2html287 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n<P>\r\ncompiler tries to base this selection (<i> indexing</i>) on the most suitable\r\nargument of the predicate<A NAME=tex2html288 HREF=\"footnode.html#1067\"><IMG ALIGN=BOTTOM ALT=\"gif\" SRC=\"http://www.ecrc.de/eclipse/new_icons//foot_motif.gif\"></A>.\r\nIt is therefore not necessary to reorder the predicate\r\narguments so that the first one is the crucial argument\r\nfor indexing.\r\nHowever, the decision is still based only on one argument.\r\nIf it is necessary to look at two arguments\r\nin order to select the matching clause, e.g. in\r\n<blockquote> <PRE>p(a, a) :- a.\r\np(b, a) :- b.\r\np(a, b) :- c.\r\np(d, b) :- d.\r\np(b, c) :- e.\r\n</PRE>\r\n</blockquote>\r\nand if it is crucial that this procedure is executed\r\nas fast as possible, it is necessary to define\r\nan auxiliary procedure which can be indexed on the other argument:\r\n<blockquote> <PRE>p(X, a) :- pa(X).\r\np(X, b) :- pb(X).\r\np(b, c) :- e.\r\n\r\npa(a) :- a. pa(b) :- b.\r\n\r\npb(a) :- c. pb(d) :- d.\r\n</PRE>\r\n</blockquote>\r\n<P>\r\nThe compiler also tries to use for indexing all type-testing information\r\nthat appears at the beginning of the clause body:\r\n<UL><LI> Type testing predicates free/1, var/1, meta/1,\r\natom/1, integer/1, real/1, number/1,\r\nstring/1, atomic/1, compound/1, nonvar/1 and\r\nnonground/1.\r\n<P>\r\n<LI> Explicit unification and value testing\r\n=/2, ==/2, <IMG  ALIGN=MIDDLE ALT=\"\" SRC=\"img1.gif\">/2\r\nand <IMG  ALIGN=MIDDLE ALT=\"\" SRC=\"img2.gif\">/2.\r\n<P>\r\n<LI> Combinations of tests with ,/2, ;/2,\r\nnot/1, <b>-&gt;</b>/2.\r\n<P>\r\n<LI> Arithmetic testing predicates\r\n<b>&lt;</b>/2,\r\n<b>=&lt;</b>/2,\r\n<b>&gt;</b>/2,\r\n<b>&gt;=</b>/2 if one argument is an integer constant and the\r\nother one known to be of the integer type.\r\n<P>\r\n<LI> A cut after the type tests.\r\n</UL>\r\n<P>\r\nIf the compiler can decide about the clause selection at compile time,\r\nthe type tests are never executed and thus they incur no overhead.\r\nWhen the clauses are not disjoint because of the type tests, either a cut\r\nafter the test or more tests into the other clauses can be added.\r\nFor example, the following procedure will be recognised as deterministic\r\nand all tests are optimised away:\r\n<P>\r\n<PRE>    % a procedure without cuts\r\n    p(X) :- var(X), ...\r\n    p(X) :- (atom(X); integer(X)), X \\= [], ...\r\n    p(X) :- nonvar(X), X = [_|_], ...\r\n    p(X) :- nonvar(X), X = [], ...\r\n</PRE>\r\n<P>\r\nAnother example:\r\n<PRE>    % A procedure with cuts\r\n    p(X{_}) ?- !, ...\r\n    p(X) :- var(X), !, ...\r\n    p(X) :- integer(X), ...\r\n    p(X) :- real(X), ...\r\n    p([H|T]) :- ...\r\n    p([]) :- ...\r\n</PRE>\r\n<P>\r\nIntegers less than or greater than a constant can also be\r\nrecognised by the compiler:\r\n<PRE>    p(X) :- integer(X), X &lt; 5, ...\r\n    p(7) :- ...\r\n    p(9) :- ...\r\n    p(X) :- integer(X), X &gt;= 15, ...\r\n</PRE>\r\n<P>\r\nIf the clause contains tests of several head arguments, only the\r\nfirst one is taken into account for indexing.\r\n<P>\r\nHere are some more hints for efficient coding with <A NAME=tex2html289 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n :\r\n<UL><LI> Arguments which are repeated in the clause head and in the first\r\nregular goal in the body do not require any data moving and thus\r\nthey do not cost anything. For example,\r\n<blockquote> <PRE>p(X, Y, Z, T, U) :- q(X, Y, Z, T, U).\r\n</PRE>\r\n</blockquote>\r\nis as expensive as\r\n<blockquote> <PRE>p :- q.\r\n</PRE>\r\n</blockquote>\r\nOn the other hand, switching arguments requires data moves and so\r\n<blockquote> <PRE>p(A, B, C) :- q(B, C, A).\r\n</PRE>\r\n</blockquote>\r\nis significantly more expensive.\r\n<P>\r\n<LI> When accessing an argument of a\r\nstructure whose functor is known, unification\r\nis better than <b> arg/3</b>.\r\nNote, however, that for better maintainability the library <b> structures</b>\r\nshould be used to define the structures.\r\n<A NAME=1107>&#160;</A>\r\n<P>\r\n<LI> Tests are generally rather slow unless they can be compiled away\r\n(see <i> indexing</i>).\r\n<LI> When processing all arguments of a structure, using =../2\r\nand list predicates is always faster, more readable\r\nand easier analyzable by automated tools than using functor/3\r\nand arg/3 loops.\r\n<P>\r\n<LI> Similarly, when adding one new element to a structure, using <b> =../2</b>\r\nand append/3 is faster than functor/arg.\r\n<P>\r\n<LI> Waking is less expensive than metacalling and more expensive\r\nthan direct calling.\r\nMetacalls, although generally slow, are still a lot faster than\r\nin some other Prolog systems.\r\n<P>\r\n<LI> Sorting using sort/2 is very efficient and it does not use\r\nmuch space.\r\nUsing setof/3, findall/3 etc. is also efficient enough\r\nto be used every time a list of all solutions is needed.\r\n<P>\r\n<LI> using <b> not not Goal</b> is optimised in the compiler\r\nto use only one choice point.\r\n<P>\r\n<LI> =/2, when expanded by the compiler, is faster than ==/2\r\nor =:=/2.\r\n<P>\r\n<LI> call_explicit/2 is optimised away by the compiler\r\nif both argument are known.\r\n<P>\r\n<LI> Using several clauses is much more efficient than using\r\na disjunction if the clause heads contain nonvariables\r\nwhich can be used for indexing.\r\nIf no indexing can be made anyway, using a disjunction\r\nis slightly faster.\r\n<P>\r\n<LI> Conditionals with <b> <IMG  ALIGN=MIDDLE ALT=\"\" SRC=\"img3.gif\"></b> are compiled more efficiently\r\nif the condition is a simple built-in test.\r\nHowever, using several clauses can be faster if the compiler\r\noptimises the test away.\r\n<P>\r\n</UL><BR> <HR><A NAME=tex2html3115 HREF=\"node73.html\"><IMG ALIGN=BOTTOM ALT=\"next\" SRC=\"http://www.ecrc.de/eclipse/new_icons//next_motif.gif\"></A>   <A NAME=tex2html3113 HREF=\"node63.html\"><IMG ALIGN=BOTTOM ALT=\"up\" SRC=\"http://www.ecrc.de/eclipse/new_icons//up_motif.gif\"></A>   <A NAME=tex2html3107 HREF=\"node71.html\"><IMG ALIGN=BOTTOM ALT=\"previous\" SRC=\"http://www.ecrc.de/eclipse/new_icons//previous_motif.gif\"></A>      <A NAME=tex2html3117 HREF=\"node321.html\"><IMG ALIGN=BOTTOM ALT=\"index\" SRC=\"http://www.ecrc.de/eclipse/new_icons//index_motif.gif\"></A>   <BR>\r\n<B> Next:</B> <A NAME=tex2html3116 HREF=\"node73.html\"> Special Primitives</A>\r\n<B>Up:</B> <A NAME=tex2html3114 HREF=\"node63.html\"> The Compiler</A>\r\n<B> Previous:</B> <A NAME=tex2html3108 HREF=\"node71.html\"> Compiler Pragmas</A>\r\n<BR> <HR> <P>\r\n<BR> <HR>\r\n<P><ADDRESS>\r\n<I>Micha Meier <BR>\r\nMon Mar  4 12:11:45 MET 1996</I>\r\n</ADDRESS>\r\n</BODY>\r\n", "encoding": "ascii"}