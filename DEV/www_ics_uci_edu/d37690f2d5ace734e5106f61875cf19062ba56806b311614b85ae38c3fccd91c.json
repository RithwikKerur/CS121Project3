{"url": "https://www.ics.uci.edu/~irani/w10_23/Lab2/BlackAndWhite.htm", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC\n \"-//W3C//DTD XHTML 1.1//EN\"\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\n<link rel=\"stylesheet\" href=\"../course2.css\" type=\"text/css\" />\n\n<title>ICS 23 / CSE 23 Winter 2010, Project #2: Black and White</title>\n</head>\n\n<body>\n\n\n<div class=\"header\">\n\n<p>ICS 23 / CSE 23 Winter 2010<br />\n   Project #2: <i>Black and White</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<p class=\"center\"><b>Due date and time:</b> <i>Friday, January 29, 6:59pm</i></p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Introduction</p>\n\n<p>Othello is a well-known two-player strategy game.  For this project, you will develop portions of an intelligent program that plays Othello.  We've provided you with a user interface and the game logic (code that implements the rules of the game).  You will write the search and strategy routines that will allow your program to play the game against a human opponent.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">The game of Othello</p>\n\n<p>Othello &mdash; also known as Reversi &mdash; is a strategy game played on a square board divided into an 8x8 grid.  The rules of the game, along with some notion of strategy, are described in the <a href=\"http://en.wikipedia.org/wiki/Reversi\">Wikipedia entry on Reversi</a>; if you haven't played Othello before, or don't remember how it works, you should at least ready the first couple of sections of the Wikipedia entry.</p>\n\n<p>Be sure you know how to play the game before attempting to complete this program; it will save you much time and effort.  As provided, the program will already play a game of Othello with two human players, but it will not allow you to play against a computer player until you create your AI class and write the necessary code in the OthelloAIFactory class (which is described later in the write-up).</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Starting point</p>\n\n<p>All of the code that you'll need to complete the project is included in this <a href=\"BlackAndWhite.zip\">Zip archive</a>.  Much of the code is provided in compiled (i.e., <b>.class</b>) form.  The provided <b>.java</b> files are heavily commented.</p>\n\n<p>You'll only need to work on two classes.  First, you need to create a new class that implements the <b>OthelloAI</b> interface.  Your class needs to be named in a certain way; specifically, the name of the class needs to begin with <b>OthelloAI</b>, followed by your eight-digit student ID#.  So, if your student ID# is 12345678, your class should be called <b>OthelloAI12345678</b>.  <i>This is important!</i></p>\n\n<p>Once you've created your AI class, you'll also need to write one line of code in the <b>OthelloAIFactory</b> class.  The comments in that class will explain what you need to do and why.</p>\n\n<p>Everything else is to be left as-is.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">How to run the program</p>\n\n<p>The <b>Othello</b> class contains a main( ) method.  To run the program, execute the <b>Othello</b> class.  The provided GUI is simple and straightforward to use.  When you run <b>Othello</b>, a window will appear with a green area with the label \"Click here to start game.\"  Click the green area and you'll be asked to specify whether each player should be controlled by a human or the computer; for now, specify human for both, as you haven't implemented your AI yet.  Clicking on <b>OK</b> starts the game.</p>\n\n<p>A human-controlled player makes a move by double-clicking an empty square on the grid.  Not all squares constitute valid moves; the mouse cursor will turn into a \"hand\" when a square is a valid one, much like when you hover over a link in your browser.  (Note that the mouse handling is a tad bit buggy at the moment, so you may have to move the mouse within the square a bit in order for the cursor to change.)  The computer simply moves when it is its turn.  The GUI animates the placing and flipping of tiles, so that you can see the moves \"in action.\"  Status messages display the score and remind you whose move it is.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Some necessary terminology</p>\n\n<p>You will be building a rudimentary <i>artificial intelligence</i> (AI) so that the computer can play a game of Othello against you (or against another instance of your artificial intelligence).  Your task for this project is fairly narrow, so you can disregard the vast majority of the code that we gave you, most of which implements either the GUI or the game logic.  In fact, most of the code has been provided in compiled (i.e., <b>.class</b>) form, rather than as source code, for this very reason.</p>\n\n<p>There are three main abstractions that you need to understand in order to write the code required for this project:</p>\n\n<ul>\n  <li>The contents of each grid cell are represented by the enumeration <b>OthelloCell</b>, which has three possible values: <b>OthelloCell.NONE</b> (for an empty cell), <b>OthelloCell.BLACK</b> (for a cell containing a black tile), and <b>OthelloCell.WHITE</b> (for a cell containing a white tile).  The locations of the grid cells are denoted by ordered pairs (<i>r</i>, <i>c</i>), where <i>r</i> is the row and <i>c</i> is the column.  As is the custom with two-dimensional arrays in Java, the row numbers and column numbers begin at 0, so the range of possible locations is (0, 0) through (7, 7).</li>\n  <li>As your AI analyzes possibilities, it will be necessary for it to evaluate the current game situation.  Collectively, we call the description of the current situation a <i>game state</i> or, more tersely, a <i>state</i>.  A game state is comprised of the contents of each grid cell, the score of the game, a flag indicating whose turn it is, and a flag indicating whether the game has ended.</li>\n  <li>Since it's possible to have two AI's playing against each other, it makes sense to encapsulate the AI into a class, so that two objects of that class could be created and play against one another.  You'll implement your AI in a class that implements the <b>OthelloAI</b> interface, which consists of a method called <b>chooseMove( )</b> that analyzes all of the possibilities and picks the AI's next move.  Since a move is denoted by the square in which a new tile should be placed, <b>chooseMove( )</b> returns an object of type <b>OthelloMove</b>, which contains a row number and column number.</li>\n</ul>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Game trees</p>\n\n<p>You can think of the possible game states as being arranged, conceptually, in a kind of search tree called a <i>game tree</i>.  Each node of the tree contains a particular game state <i>g</i>.  Its children are the game states that can result from making each valid move from the state <i>g</i>.</p>\n\n<p>The root of the tree is the initial game state &mdash; that is, the Othello game before the first move is made.  The children of this initial state are all of the possible states that can arise from the black player (who moves first) making a valid opening move.  There are four such states, corresponding to the four possible moves that the black player is permitted to make at the opening.  (All other moves are illegal and, as such, are not to be considered.)</p>\n\n<p>Here is a partial look at an Othello game tree:</p>\n\n<p class=\"center\"><img src=\"SearchTree.jpg\" /></p>\n\n<p>In the picture, from the initial state, there are four possibilies from which the black player can choose its initial move.  From the first of those, we see that there are three possible moves that the white player can make in response.  Other moves aren't pictured, but the tree continues to grow in this fashion.  (Not surprisingly, the game tree can grow large rather quickly.)</p>\n\n<p>We'll call the leaves in such a game tree the <i>final states</i>.  These leaves indicate the states in which one player or the other has won the game.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Exhaustively searching all possibilities</p>\n\n<p>Each time a player wants to pick a move, he or she wants to pick the one that will lead to a winning game state.  We can determine the best move in three steps:</p>\n\n<ol>\n  <li>We apply an <i>evaluation function</i> to each final game state.  An evaluation function typically returns a number, where higher numbers are considered better.  We then identify the final state with the highest value &mdash; that is the \"end game\" that we would like to occur, as it is the best win for us.</li>\n  <li>We determine the path from the current game state to the final state that we chose above.</li>\n  <li>We make the move that takes us from the current game state down the path toward the chosen final state.</li>\n</ol>\n\n<p>Assuming that you had a complete game tree at your disposal, this is a simple approach to implement.  However, practical limitations make this approach impossible.  First of all, the number of game states on each level of the tree grows exponentially as you work your way down the tree, since there are a number of possible moves that can be taken from any particular game state.  There simply won't be enough memory to store the entire game tree.  (You can imagine that, if you build the game tree 20 levels deep, and there are four possible moves that can be made from any particular state, the number of nodes in the tree would be greater than 4<sup>20</sup>, which is a large number!)  Besides, even if there were enough memory available to store the tree, the processing time to create the entire game tree would be prohibitive.</p>\n\n<p>So we'll need to find a compromise &mdash; an approach that perhaps doesn't always find the best possible outcome, but that makes a decision in a reasonable amount of time and using a reasonable amount of memory.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Heuristic search</p>\n\n<p>The study of artificial intelligence has much to say about good ways to search toward a goal when it's impractical to check all possible paths toward it.</p>\n\n<p>We can first make use of the following observation: Suppose the top player has made a move in the game, and the bottom player wants to figure out the best move to make, using the search tree approach we've been discussing.  Then the bottom player need only concern himself with the subtree that has the current game state as its root.  Once a move is made, all the other moves that could have been made can be ignored, as it is now not possible to take those paths down the tree.  Thus, when analyzing the next move to make, we need only generate the part of the search tree that originates from the current game state.</p>\n\n<p>This approach reduces our storage needs significantly &mdash; and we don't waste time or memory processing parts of the tree that we can no longer reach.</p>\n\n<p>Even if we generate only the part of the tree that we need, that part will still be much too large to store until we're nearing the end of the game.  This is where a <i>heuristic search</i> comes into play.  In a heuristic search, we generate as much of the relevant subtree as is practical, using the resulting game states to guide us in selecting a move that we hope will be the best.</p>\n\n<p>There are several strategies that we could use.  At the heart of the strategy that we'll use is the notion of an <i>evaluation function</i> that we discussed earlier.  We'll need to rate each particular game state in some way, so that we can decide which of a large number of game states is the best outcome for us.  A simple approach &mdash; though one that ignores some aspects of the game &mdash; is the following:</p>\n\n<p><i>eval(state) = number of tiles belonging to me &minus; number of tiles belonging to my opponent</i></p>\n\n<p>It's also important to note here that <i><b>you do not need to actually build a game tree in memory</b></i>.  Our algorithm will\nperform a sort of <i>depth-first search</i> on the game tree, meaning that we can use parameters in a recursive method (stored on the\nrun-time stack) to perform the search, negating the need to actually build and store a game tree.  This will dramatically reduce the\namount of memory needed to choose a move, since only one path in the tree will ever need to be stored on the run-time stack at a time.\n<b> Please note that you are required to use recursion in this lab. </b>\n</p>\n\n<p>Putting these ideas together, we can develop a search algorithm that will look for the move that leads to the game state that evaluates to the highest value.  That algorithm looks something like this:</p>\n\n<pre>\nint search(OthelloGameState s, int depth)\n{\n    if (depth == 0)\n        return evaluation of s\n    else\n    {\n        if (it's my turn to move)\n        {\n            for each valid move that I can make from s\n            {\n                make that move on s yielding a state s'\n                search(s', depth - 1)\n            }\n\n            return the <i>maximum</i> value returned from recursive search calls\n        }\n        else\n        {\n            for each valid move that my opponent can make from s\n            {\n                make that move on s yielding a state s'\n                search(s', depth - 1)\n            }\n\n            return the <i>minimum</i> value returned from recursive search calls\n        }\n    }\n}\n</pre>\n\n<p>There are a few things we need to discuss about the algorithm above.  First, notice that there are two cases of recursion: either it is the computer player's turn (who is currently making the decision) or its opponent's turn.  In each case, the algorithm is almost the same, except:</p>\n\n<ul>\n  <li>...when it is the computer player's turn, the <i>maximum</i> value is returned.  In other words, the computer player wants to make the best possible move it can.</li>\n  <li>...when it is the opponent's turn, the <i>minimum</i> value is returned.  This is because it is assumed that the opponent will also make the move that's in <i>its</i> best interest (which is in our worst interest).</li>\n</ul>\n\n<p>You <i>may not</i> assume that the computer player will always be the black or the white player.  Either the black or the white player (or both!) might be a computer player.  When deciding whether it's \"my turn\" or \"my opponent's turn,\" you'll have to exercise some caution to ensure that you're making the right decision.</p>\n\n<p>Second, notice the <b>depth</b> parameter.  This will be used to limit the depth of our search, to make sure that our search is of a manageable length.  Each time we recurse one level deeper, the depth is reduced by one, and we stop recursing when it reaches zero.</p>\n\n<p>Thirdly, observe that when one player makes a move, it isn't necessarily the case that the other player will be making the next move; occasionally, in Othello, the same player gets to move twice in a row.  So, care must be taken in deciding whose turn it is.  The easiest way to deal with this problem is to count on the current game state to keep track of this for you; it can always tell you reliably whose turn it is.</p>\n\n<p>Lastly, note that this algorithm returns the <i>evaluation</i> of the best state, not the best state itself.  In short, calling search(<i>s</i>, 4) for some state <i>s</i> asks the following question: \"Looking four moves into the future, and assuming I do the best I can do and so does my opponent, how well will the state <i>s</i> turn out for me?\"  You'll need to exercise some care in actually implementing this algorithm so that chooseMove( ) will be able to call search( ) and use the result to help it choose the right move.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Evaluation functions</p>\n\n<p>The core of your AI &mdash; what will set it apart from others &mdash; is the evaluation function that it uses to decide how \"good\" each board configuration is.  I'm leaving this as an open problem and you're welcome to implement your evaluation function however you'd like.  You might want to poke around the web looking for strategy guides or other information, taking into account, for example, that some squares on the Othello board are considered more important than others.</p>\n\n<p>It's intended to be fun to play against your own program to see if you can beat it, and I also hope you enjoy fine-tuning your program until you have trouble beating it.</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">A tournament!</p>\n\n<p>After this project's due date has passed, We'll be gathering all of your AIs together and running a tournament to determine\nwho has the best AI.  In fairness, We'll explain here how the tournament will be organized:</p>\n\n<ul>\n  <li>Each AI will play two games against each other AI, one each as black and as white.</li>\n  <li>The primary factor in determining the \"best\" AI is the total percentage of games won.\n  (Draws will count as 1/2 of a win and 1/2 of a loss.)  So, first and foremost, it's important\n  to win games.</li>\n  <li>A secondary factor, to be used in the case of a tie, is the total number of tiles accumulated\n  in all games.  This means that winning games big, as opposed to squeaking out close wins, is important\n  if there's a tie.</li>\n  <li>Your AI will be given 5 seconds of CPU time to choose each of its moves.  (I'll be running the\n  tournament on a 2.8 GHz Intel Core 2 Duo.  The fact that it has two processors only means that We'll be running four games at a time.)</li>\n  <li>If your AI takes too long to make a move, returns null, throws an exception, isn't named according to the naming convention, or violates any of the other rules laid out in the project write-up, it will be disqualified from the tournament.</li>\n</ul>\n\n<p>The outcome of the tournament will have no bearing on your grade, but it will hopefully motivate\nyou to think a bit about how you might tune up your evaluation function &mdash; or explore alternative\nways of helping your AI to see farther into the future.  (You are required, fundamentally, to use the\nalgorithm shown in this write-up, though there are optimizations you can make to it, if you're so inclined.\nIf you're not sure whether your idea is permissible, ask me and I'd be glad to let you know what I think about it.)</p>\n\n<p>The winner ofthe tournament will receive a $25 iTunes gift card. </p>\n<p>Good luck!</p>\n\n</div>\n\n<div class=\"section\">\n\n<hr />\n\n<p class=\"title\">Deliverables</p>\n\n<p>You need only turn in your <b>OthelloAIFactory.java</b> file and the file containing your AI class, along with any additional\nclasses you created, if any.  You do not need to turn in any of the other files that were provided to you.\nFollow <a href=\"../SubmittingProjects.html\">this link</a> for an explanation of how to turn in your project.</p>\n\n</div>\n\n<div class=\"history\">\n\n<hr />\n\n<ul class=\"nomarker\">\n  <li>Originally written by Alex Thornton, Fall 2007, with portions taken from <i>End of the Game</i> by Alex Thornton and Norman Jacobson.</li>\n</ul>\n\n</div>\n\n</body>\n</html>\n", "encoding": "ascii"}