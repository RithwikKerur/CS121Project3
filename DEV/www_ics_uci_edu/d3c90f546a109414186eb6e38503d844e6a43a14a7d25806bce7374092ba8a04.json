{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/operatoroverloading2.txt", "content": "\t\t\tOperator Overloading (continued)\r\n\r\nIn this lecture we examine how to overload more operators: many fewer than\r\nin the first lecture, but some that perform more interesting (and subtle)\r\noperations -some that get to the core of Python's operation, which we have the\r\nability to levarage in the classes we write! Some symbols/operators we discuss\r\nhere include [] (index/dict lookup) and in (contains) and with (context manager)\r\nand . (attribute access)  and del (attribute removal)...\r\n\r\n------------------------------------------------------------------------------\r\n\r\nContainer operators: in Lists/Tuples\r\n\r\nWe saw that when we call the standard len function with an object argument, it\r\nis translated into a call of the __len__ method on that object: for example,\r\ncalling len(x) returns the value x.__len__(); Python does the same with the\r\nreversed function and and the __reversed__ method. Since __reversed__ is really\r\nan iterator, we will discuss it in depth next week (see how it, and similar\r\niterators are coded).\r\n\r\nThe following methods all relate to indexing: using the [] delimiters, which\r\nPython interprets as symbols describing the indexing operator. What appears\r\ninside the brackets is typically either a simple integer (for lists and tuples)\r\nor a slice (ditto: more on slices below). Also [] is an operator that works on\r\ndictionaries (dict and defaultdict), where the value inside [] is the dict's\r\nkey, which can be any arbitrary value (well, it has to be immutable/hashable).\r\nLet's look at the laundry list of methods first, and then use each in a new\r\nclass that we define. Assume for the examples below that we have defined l to\r\nbe a list.\r\n\r\nNote that the index parameter can be an int or a slice for lists/tuples (we will\r\nfocus on lists here). We discuss three different forms of using an index, each\r\ncalling a different double underscore method; a fourth related operator, \"in\",\r\nis translated into a call on the  __contains__ method and is discussed below\r\ntoo.\r\n\r\n__getitem__(self,index)        : index: l[3] or l[1:-1]\r\n__setitem__(self,index,value)  : store list: l[3]='a' or l[2:4]=('a','b','c')\r\n__delitem__(self,index)        : delete: del l[3] or del l[1:-1]\r\n__contains__(self,item)        : called by the in operator: 'a' in l\r\n\r\nTo illustrate these methods, let's write a class that allows us to specify\r\na list that is indexed staring at 1 (not 0). Really we should think in terms\r\nof defining a class for a new type of data (lists, tuples, sets, frozensets,\r\ndicts, and defaultdicts are all types of data; we can use inheritance, discussed\r\nlater in the quarter, to define variants of these data types more easily), but\r\nfor now let's look at adapting/using standard lists in this new way, to simplify\r\nwhat we are learning (we could do the same with strings, writing Str1). This\r\nexample also uses delegation, where an operation on a List1 is translated into\r\na \"similar\" operation on the list it actually stores/delegates to. We start with\r\n\r\nclass List1:\r\n    def __init__(self,iterable):\r\n        self._plist = list(iterable)\r\n        \r\n    def __str__(self):\r\n        return str(self._plist)\r\n\r\nSo, we can write\r\n\r\nx = List1(['a', 'b', 'c', 'd', 'e'])\r\nprint(x)\r\n\r\nwhich prints as\r\n\r\n  ['a', 'b', 'c', 'd', 'e']\r\n\r\nSo x looks just like a list when we create one and print one (although we must\r\nuse the List1 constructor, not just [...] for these special lists). Its argument\r\nis anything Python can iterate over to create the values in the list, and we\r\ncopy that information into a regular list. We now want to implement list-like\r\nbehavior, but with indexes that start at 1 instead of 0. First we look at the\r\n__getitem__ method, called by l[...]. We can use either integers or slices\r\ninside the brackets, for now let's look at just integers.\r\n\r\nNote that in Python lists, integer indexes are either non-negative (0, 1, ...),\r\nwhich specify an index from the beginning (e.g., 0 is the first, 1 is the\r\nsecond...), or negative, which specify an index from the end (e.g., -1 is the\r\nlast index, -2 second from last). Note the asymmetry we are now fixing: in List1\r\nwe want 1 to be first and -1 be last, 2 to be second and -2 to be 2nd from last,\r\nunlike Python lists, where 0 is the first index and -1 the last.\r\n\r\nSo we will start with the helper function (static method) _fix_index: the\r\nleading underscore means this method should be used only other methods in the\r\nList1 class (although it is safe to use by anyone: it doesn't set/mutate any\r\nattributes). This function demotes positive indexes by 1, but leaves 0 and\r\nnegative indexes as is. So _fix_index(1) returns 0, which when used to index\r\nself._plist, the delegated list, denotes the index of the first value. Likewise,\r\n_fix_index(-1) returns -1, which still denotes the index of the last value.\r\n\r\n    @staticmethod\r\n    def _fix_index(i):\r\n        return (i-1 if i >= 1 else i)\r\n\r\nRecall, because this is a static method, it has no self parameter. We will call\r\nthis method (see below) like List1._fix_index(...). Static means it does not\r\noperate on instances of a class: so it uses no self parameter to refer to an\r\ninstance of List1. If l is a list we could call l._fix_index(...); because\r\nit is static, FEEOP translates it to List._fix_index(...), not putting l as a\r\nfirst agurment (because there is no self in static methods).\r\n\r\nAlternatively, we could have defined _fix_index as a global function in this\r\nmodule, and called it just as _fix_index(...) in the class methods, but it is\r\nbetter to define this static method in the class itself (avoiding \"polluting\"\r\nthe module's namespace by putting another name in it). Again, note that we use\r\na prefix underscore to indicate no function/method outside the class SHOULD\r\ncall this function: it is just a helper for the methods in the class. But there\r\nis nothing in Python that disallows us from calling List1._fix_index anywhere.\r\n\r\nWith _fix_index defined, we can write __getitem__ as follows. Notice that it\r\nensures index is an int, otherwise it raises an exception. If index is an int,\r\nit delegates to self._plist to access its information, but when accessing\r\nself._plist, we decrease the index by 1 for positive indexes, but leave zero\r\nand negative indexes alone. For illumination/debugging purposes we have put a\r\nprint in __getitem__ which we will comment/uncomment as needed. For the examples\r\nbelow we will leave it in, so that we can see when __getitem__ is called by\r\nPython, since we don't explicitly call it.\r\n\r\n    def __getitem__(self,index):\r\n        print('List1.__getitem__('+str(index)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            return self._plist[List1._fix_index(index)]\r\n        else:\r\n            raise TypeError('List1.__getitem__ index('+str(index)+') must be int')\r\n\r\nRunning the following script illustrates how __getitem__ is called.\r\n\r\nx = List1(['a','b','c','d','e'])\r\nprint(x)\r\nprint(x[1], x[2], x[-2], x[-1])\r\n\r\nPython produces the following output, printing the entire list, the first,\r\nsecond, last, and second to last values. Notice the calls that Python\r\nautomatically makes to __getitem__ when we use the [] operator. Note that print\r\ncalls __getitem__ on its arguments, buiding a string to print, and then prints\r\nthe entire string after getting all the values.\r\n\r\n  ['a', 'b', 'c', 'd', 'e']\r\n  List1.__getitem__(1)\r\n  List1.__getitem__(2)\r\n  List1.__getitem__(-2)\r\n  List1.__getitem__(-1)\r\n  a b d e\r\n\r\nTwo things about this method. First, we should probably raise an exception if\r\nthe index is 0 because that value should not be a legal index in a List1 list.\r\nBut for purposes of illustration later, when we discuss the \"in\" method, we will\r\nnot do this (so index 0 will be the same as index 1: both translate to 0).\r\nSecond, we need to talk about slices and how List1 objects will can process\r\nthem. \r\n\r\n----------\r\nInterlude: slices\r\n\r\nTo finish writing __getitem__ we must take a short detour to talk about slices.\r\nRecall that for Python lists we can write indexes like x[1:4], x[2:-2], x[:-1]\r\nand even x[::2]. Each of these slices translates into an actual slice object\r\n(yes there is a slice class defined in the builtins module which is\r\nautomatically imported into every python module) that is passed to __getitem__.\r\nEach slice object has three atrributes that we can access: start, stop and step\r\n(with None for every value not specified in the slice).\r\n\r\nx[1:4]  translates to x[slice(1,4,None)]\r\nx[2:-2] translates to x[slice(2,-2,None)]\r\nx[:-1]  translates to x[slice(None,-1,None)]\r\nx[::2]  translates to x[slice(None,None,2)]\r\n\r\nThe __getitem__ methods for lists know how to process slices. We can delegate\r\nthese slices to be used on self._plist, but we need to fix the start and stop\r\nindexes (as done above for pure int indexes, with the same function), but leave\r\nthe step as is. Also, since slices can specify None, we need to update\r\n_fix_index to leave None unchanged.\r\n\r\nSo, we update the _fix_index and __getitem__ methods as shown below. Now for\r\nslices, we construct a fixed slice from the one passed as an argument (fixed for\r\nstart and stop in 1-origin lists) and use this slice when delegating to\r\nself._plist.\r\n\r\n    @staticmethod\r\n    def _fix_index(i):\r\n        if i == None:\r\n            return None\r\n        else:\r\n            return (i-1 if i >= 1 else i)\r\n            # for + indexes, 1 smaller: 1 -> 0\r\n            # for - indexes, the same: -1 (still last), -2 (still 2nd to last)\r\n        \r\n    def __getitem__(self,index):\r\n        print('List1.__getitem__('+str(index)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            return self._plist[List1._fix_index(index)]\r\n        elif type(index) is slice:\r\n            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)\r\n            return self._plist[s]\r\n        else:\r\n            raise TypeError('List1.__getitem__ index('+str(index)+') must be int/slice')\r\n\r\nRunning the following script illustrates how __getitem__ works with slices; we\r\nleft the print statement in __getitem__ and the __str__ for slice objects prints\r\nas slice(start, stop, step)\r\n\r\nx = List1(['a','b','c','d','e'])\r\nprint(x)\r\nprint(x[1:4], x[2:-2], x[:-1], x[::2])\r\n\r\nPython produces the following output, printing the entire list, and then the\r\nspecified slices of that list (again, where the index of the first item is 1).\r\nNotice the calls that Python automatically makes to __getitem__ when we use the\r\n[] operator with slices. Remember that slices include indexes up to but not\r\nincluding the stop index (we could fix this too, if we didn't like, by always\r\nincrementing the stop index by 1, therefore using one more index; this would be\r\na problem, though for incrementing -1 to 0 which would be wrong and we'd need\r\na special way to fix that: incrementing -1 to None: here, x[1:] would be slice\r\nwith all valus in a List1).\r\n\r\n  ['a', 'b', 'c', 'd', 'e']\r\n  List1.__getitem__(slice(1, 4, None))\r\n  List1.__getitem__(slice(2, -2, None))\r\n  List1.__getitem__(slice(None, -1, None))\r\n  List1.__getitem__(slice(None, None, 2))\r\n  ['a', 'b', 'c'] ['b', 'c'] ['a', 'b', 'c', 'd'] ['a', 'c', 'e']\r\n----------\r\n\r\nNow that we know how to handle indexes that are integers or slices (by fixing\r\nthem and delgating their use to self._plist),  we can easily write the remaining\r\nmethods. For example the __setitem__(self,index,value) method is supposed to\r\nassign value to object at the specified index(es). Its structure is identical\r\nto __getitem__, processing int indexes, slice indexes, or raising TypeError.\r\nHere, though, we are assigning to self._plist, not returning a value. Because\r\nthere are no return statements in this method, Python will automatically return\r\nNone when it finishes executing; we could also specify this explicitly as\r\nreturn None: both have the same effect in Python.\r\n\r\n    def __setitem__(self,index,value):\r\n        print('List1.__setitem__('+str(index)+','+str(value)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            self._plist[List1._fix_index(index)] = value\r\n        elif type(index) is slice:\r\n            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)\r\n            self._plist[s] = value\r\n        else:    \r\n            raise TypeError('List1.__setitem__ index('+str(index)+') must be int/slice')\r\n\r\nRunning the following script illustrates how __setitem__ works with int and\r\nslice indexes; we again left the print statement in __setitem__.\r\n\r\nx = List1(['a','b','c','d','e'])\r\nprint(x)\r\nx[1] = 1\r\nx[4:5] = (4,5)\r\nprint(x)\r\n\r\nPython produces the following output, printing the entire list, and then the\r\nupdated list. Notice the calls that Python automatically makes to __setitem__\r\nwhen we use the [] operator with slices.\r\n\r\n  ['a', 'b', 'c', 'd', 'e']\r\n  List1.__setitem__(1,1)\r\n  List1.__setitem__(slice(4, 5, None),(4, 5))\r\n  [1, 'b', 'c', 4, 5, 'e']\r\n\r\nNext, the __delitem__(self,index) method is supposed to delete/remove values\r\nfrom the specified index(es). Its structure is identical to __getitem__ and\r\n__set__item, processing int indexes, slice indexes, or raising TypeError. As\r\nwith __setitem__ we automatically return None.\r\n\r\n    def __delitem__(self,index):\r\n        print('List1.__delitem__('+str(index)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            del self._plist[List1._fix_index(index)]\r\n        elif type(index) is slice:\r\n            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)\r\n            del self._plist[s]\r\n        else:            \r\n            raise TypeError('List1.__delitem__ index('+str(index)+') must be int/slice')\r\n\r\nRunning the following script illustrates how __delitem__ works with int and\r\nslice indexes; we again left the print statement in __delitem__.\r\n\r\nx = List1(['a','b','c','d','e'])\r\nprint(x)\r\ndel x[1]\t# now ['b','c','d','e'] index 1 deleted\r\nprint(x)    \r\ndel x[2:4]\t# now ['b','e']\t\tindexes 2-3 (not 4) deleted\r\nprint(x)\r\n\r\nPython produces the following output, printing the entire list, and then the\r\nupdated list. Notice the calls that Python automatically makes to __delitem__\r\nwhen we use the [] operator with slices.\r\n\r\n  ['a', 'b', 'c', 'd', 'e']\r\n  List1.__delitem__(1)\r\n  ['b', 'c', 'd', 'e']\r\n  List1.__delitem__(slice(2, 4, None))\r\n  ['b', 'e']\r\n\r\n----------\r\n\r\nImplementing in via __getitem__ (Python's default if no __contains__ exists)\r\n\r\nBefore defining the __contains__ method, we will learn that if there is no\r\ndefined __contains__ method, Python will check \"x in l\" by first checking if\r\nx == l[0], then x == l[1], then x == l[2], ... until it finds x, or indexing\r\nraises an exception (Python takes this approach instead of compuing len(l) as\r\nan upper bound to index, because the __len__ method might not be defined for\r\nthe class).\r\n\r\nSo if we ran the following script (without defining the __contains__ method)\r\n\r\nx = List1(['a','b','c','d','e'])\r\nprint('d' in x)\r\nprint('z' in x)\r\n\r\nPython produces the following output, printing\r\n\r\n  List1.__getitem__(0)\r\n  List1.__getitem__(1)\r\n  List1.__getitem__(2)\r\n  List1.__getitem__(3)\r\n  List1.__getitem__(4)\r\n  True\r\n  List1.__getitem__(0)\r\n  List1.__getitem__(1)\r\n  List1.__getitem__(2)\r\n  List1.__getitem__(3)\r\n  List1.__getitem__(4)\r\n  List1.__getitem__(5)\r\n  List1.__getitem__(6)\r\n  False\r\n\r\nLet's look at this carefully. For the first print Python executes 'd' in x; it\r\nfirst calls __getitem__(0) but in the List1 objects there is nothing at index\r\n0; actually if you look at the code a call of __getitem__(0) is translated to\r\n[0] -storing 'a'- which looks at the first value and doesn't find 'd'; then\r\nPython calls getitem(1), which is also translated to [0] -storing 'a'- which\r\nagain looks at the first value and doesn't find 'd'; then Python calls\r\n__getitem(2), which is translated to [1] -storing 'b'- which looks at the\r\n second value and doesn't find 'd'; ...; then Python calls __getitem(4), which\r\nis translated to [3] -storing 'd'- which looks at the fourth value and does\r\nfind 'd', so the contains returns True, which is printed.\r\n\r\nFor the second print Python executes 'z' in x; it calls __getitem__ multiple\r\ntimes; __getitem(5) is translated to [4] -storing 'e'- which looks at the\r\nfifth/last value and doesn't find 'z'; then Python calls __getitem(6), which\r\nraises an exception indicating that there are no more values to examine, so\r\nusing \"in\" (translated to multiple indexes) returns False, which is printed.\r\n\r\nAlthough using \"in\" accesses index 0 twice, it does always produce the correct\r\nanswer. If we wrote _fix_index to raise an exception for index 0 (which\r\nisn't really a legal index in List1) __contains__ would not automatically work\r\ncorrectly. But now we will explicitly write a __contains__ method that does not\r\nautomatically call the __getitem__ method.\r\n----------\r\n\r\nNow, we can define our own contains to just use the in operator for lists.\r\n\r\n    def __contains__(self,item):\r\n        for v in self._plist:\r\n            if v == item:\r\n                return True\r\n        return False\r\n\r\nbut this is just checking whether item is in _plist: checking \"in\" doesn't\r\nreally depend on whether our indexes start at 0 or 1: it depends only on whether\r\nthe value is at some index in the stored list. So we can simplify it to delegate\r\nto the in operator for the standard list it stores.\r\n\r\n    def __contains__(self,item):\r\n        return item in self._plist\r\n\r\nSo if we ran the following script (defining the __contains__ method above)\r\n\r\nx = List1(['a','b','c','d','e'])\r\nprint('d' in x)\r\nprint('z' in x)\r\n\r\nPython now produces the following output, printing just the following, showing\r\nthat there are no more calls automatically made to __getitem__.\r\n\r\n  True\r\n  False\r\n\r\nAgain,, when determining whether a value is in a list, we don't really care what\r\nindex it is stored in: we just want to know whether it is stored anywhere.\r\n\r\nIf we want to iterate over a class (for example, in a for loop) we should\r\nimplement the __iter__ and __next__ methods. We will discuss these in detail\r\nin next week's lectures. But like in/__contains__ if those methods aren't\r\ndefined, Python calls the __getitem__ method for indexing. For example, if\r\nPython executes\r\n\r\nx = List1(['a','b','c','d','e'])\r\nfor i in x:\r\n    print(i)\r\n\r\nfor the List1 class as defined above, it prints the following\r\n\r\n  __getitem__(0)\r\n  a\r\n  __getitem__(1)\r\n  a\r\n  __getitem__(2)\r\n  b\r\n  __getitem__(3)\r\n  c\r\n  __getitem__(4)\r\n  d\r\n  __getitem__(5)\r\n  e\r\n  __getitem__(6)\r\n\r\nNotice as with the in operator above, it starts calling __getitem__ at index 0,\r\nso that value gets produced/printed twice by the iterator. For the in operator\r\nthis wasn't a problem, but here it produces/prints the first value twice, which\r\nwe will fix when we define the real __iter__ method. Also as with the in\r\noperator it calls __getitem__ with successively bigger indexes, returning those\r\nvalues until at __getitem__(6) an exception is raised, because there is no\r\nindex 6 in this List1 object: just indexes 1 through 5 and stops by handling\r\n(and not showing) the exception.\r\n\r\nSo, we really should write _fix_index to raise an exception when supplied the\r\nargument 0, which is not a legal index for objects constructed from List1. Then\r\nwe must define explicit __contains__ and iteration methods (__iter__ and\r\n__next__, discussed next week) because using the automatic ones would generate\r\nindex 0, for which _fix_index would raise an exception.\r\n\r\nIt is often the case that we define new classes using combinations of the\r\nbuiltin classes (like list, tuple, set, dict) so often we delegate operations\r\nfor our new class to operations on the classes it is built from. In the Vector\r\nexample, we represented a Vector as a tuple: we computed the __len__ of the\r\nVector just by delegating __len__ to compute on the tuple.\r\n\r\n-------\r\n\r\nContainer operators: in Dictionaries\r\n\r\nWe are now coming to the end of this example. Although this example used\r\ninteger indexes for list, if we wanted to produce a special kind of dictionary\r\ndata type we can use any type of index as a key in the __getitem__, __setitem__,\r\nand __delitem__  methods. Of course we cannot use slices with dictionaries, as\r\nwe did above with List1.\r\n\r\nFor classes that will be used like dicts, there is another special method\r\n\r\n__missing__(self,key)\r\n\r\nwhich should be called whenever a dict fails to find a key it is looking up. We\r\ncan define the __missing__ method to tell Python what to do in these cases. In\r\na normal dict class, Python raises an exception; in the defaultdict class, its\r\n__missing__ method associates a special object in the defaultdict (specificied\r\nby an argument in the construction of the defaultdict) with that key, and then\r\nreturns that associated object for possible further processing. When we study\r\ninheritance later in the quarter, we will see how to completely define\r\ndefaultdict easily, including defining the __missing__ method as described\r\nabove.\r\n\r\nOne last point here. many of the methods below return None, because they are\r\nmeant to be the result of commands that mutate arguments, not return values.\r\nBut, it might be useful for them to return a value. For example, in the Java\r\nlibrary for maps (which are like Python dicts), mapping keys to values, calling\r\n__setitem__ returns the OLD value associated with the key being set; likewise,\r\n__delitem__ returns the value associated with the key being deleted. Using\r\nthese returned values sometimes makes for more elegant code. Although Python\r\ndoesn't do this, we can write our own classes that mimic a standard dict, but\r\nin addition behave any special way we want them to (like returning such values).\r\n\r\nFinally, although we changed the indexes to start at 1, we did not change the\r\nupper-bound meaning of slices. recall that a standard slice 2:5 correspondes to\r\nindexes 2, 3, and 4 (not including 5). I often find it difficult to remember\r\nor use the fact that the stop index is not included in the slice, so it might\r\nbe interesting to change the slices so that the stop index is included (as I\r\ndid for irange in my goody module) which can be done simply when the slices are\r\ncreated/\"fixed\" and used in __getitem__, __setitem__, and __delitem__ methods.\r\n\r\nThe main point here (and for the special methods below) is that if we want a\r\ndata type to behave a certain way in Python, we can write classes in Python for\r\nthat data type and make it exhibit exactly the behavior that we want by writing\r\nmethods for the class. We have crude ways to do that now, but will see more\r\npowerful ways when we study inheritance.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunction Call\r\n\r\nWe know how Python calls methods on instances of classes: by the Fundamental\r\nEquation of OOP, o.m(...) is translated into type(o).m(o,...). But we can also\r\ndefine how to use an instance as if it were a function itself, allowing us to\r\n\"call it\" as o(...). The way we do this is by defining a method named __call__\r\nin the class. The call o(...) -here () is the \"call operator\"- is translated\r\ninto o.__call__(...), and by FEOOP type(o).__call__(o,...)\r\n\r\n----\r\nIn fact, when we use the name of a class like a function call, we are using this\r\nmechanism. For example, when calling set([1,2,3]) we are calling a function on\r\nthe set class object, which is an instance of a special class named type; it is\r\n__call__ in type that creates an emptly object, and calls __init__ defined in\r\nset on it. Below we will show how to overload __call__ for objects that have\r\nalready been constructed from a class.\r\n---\r\n\r\n1) Here is a tiny example of overloading __call__ followed by a more interesting\r\none. When we call the object, it will increment the self.x value: x is stored in\r\nthe namespace/__dict__ of the object.\r\n\r\nclass C:\r\n    def __init__(self):\r\n        self.x = 0\r\n    \r\n    def __call__(self,inc=1):\r\n        self.x += inc\r\n\r\nSo if we construct objects from class C, we can call them specifying one\r\nargument (to match the inc parameter), and their x attribute is incremented\r\nby that amount. We can write\r\n\r\no = C()\r\nprint(o.x)\r\no(2)\r\nprint(o.x)\r\no()\r\nprint(o.x)\r\n\r\nNote that we can call the object o refers to just by writing parentheses after\r\no. Python processes o(2) by calling to o.__call__(2) and then calling\r\ntype(o).__call__(o,2) which is C.__call__(o,2). It prints\r\n\r\n  0\r\n  2\r\n  3\r\n\r\n2) The following class is a bit ahead of where we are now, but it shows a more\r\nrealistic use of overloading __call__, and we will discuss this class, and\r\nother classes like it, here and in detail later in the quarter. Track_Calls is a\r\n(decorator) class that we can use to remember how many times functions are\r\ncalled. We illustrate its use with a recursive fibonnaci (fib) function.\r\n\r\nWhen Python constructs an object from the Track_Calls class, it remembers the\r\nfunction it is given (f) in its _f instance variable, and initializes its calls\r\ninstance variable to 0. Here we assume f is a function of one parameter, but\r\nsee the \"#to bundle\" commend below.\r\n\r\nAn object of class Track_Calls can be called directly: its __call__ method\r\nincrements the calls counter and calls and returns the value computed by the\r\nremembered function: delegating to it to compute the actual values we want.\r\nThus, we can replace a function call with a function call to an object in which\r\nthe original function is remembered; and objects can do more than functions:\r\nfor example, they can remember information/state, like how many times they are\r\ncalled.\r\n\r\nclass Track_Calls:\r\n    def __init__(self,f):\r\n        self._f = f\r\n        self.calls = 0\r\n    \r\n    def __call__(self,x): # or ,*args,**kargs): #to bundle arbitrary arguments\r\n        self.calls += 1\r\n        return  self._f(x)# or ,*args,**kargs)  #to unbundle arbitrary arguments\r\n\r\ndef fib(n):\r\n    assert n>=0, 'fib cannot have negative n('+str(n)+')'\r\n    if    n == 0: return 1\r\n    elif  n == 1: return 1\r\n    else:         return fib(n-1) + fib(n-2)\r\n\r\nfib = Track_Calls(fib)\r\n\r\nThe script above defines the Track_Calls class, the fib function, and then\r\nrebinds the name fib to an object constructed from the Track_Calls class, when\r\npassed a reference to the fib function object as an argument.\r\n\r\nWhen we call fib(...), Python finds the Trace_Calls object that fib refers to\r\nand calls its __call__ method. So, it calls fib.__calls__(...) which FEOOP\r\ntranslates to Track_Calls.__calls__(fib,...) which increments the calls \r\ninstance variables and then calls the original function object bound to fib\r\n(now bound to self._f, which is recursive) and returns that value. Remember\r\nthat the fib name is now bound to a Track_Calls object, so any recursive calls\r\nto fib are also handled by the Track_Calls._call__ method (which increments the\r\ncalls instance variable). Ultimately the recursive function call returns an\r\nanswer and the \"calls\" attribute/instance variable accumulates how many calls\r\nof fib, called through Track_Calls.__call__, were made.\r\n\r\nHere is code that creates a table of the returned values from fib and the\r\nnumber of calls each required. I directly reset fib.calls to 0, but I could\r\nhave created a method in Track_Calls to reset this instance variable, or just\r\nremembered the number of calls before and after a new call and subtracted.\r\n\r\nfor i in irange(0,31):\r\n    print('fib(', i, ') =', fib(i), 'and was called', fib.calls,'times')\r\n    fib.calls = 0 # reset instance variable to 0 for next iteration\r\n\r\nIn this code I am using an instance variable directly (note calls is not\r\npreceded by an underscore). To avoid using this instance variable directly, I\r\ncould have defined this instance variable as _calls and then defined the report\r\nmethod below to return such a value (and another method to reset it):\r\n\r\n    def report_calls(self):\r\n        return self._calls.\r\n\r\n    def reset_calls(self):\r\n        self._calls = 0\r\n\r\nThis follows the more standard convention of using a class without directly\r\nusing its state attributes; the class supplies methods to access/update them.\r\n\r\nIn this case I would write the code above as\r\n\r\nfor i in irange(0,31):\r\n    print('fib(', i, ') =', fib(i), 'and was called', fib.report_calls(), 'times')\r\n    fib.reset_calls() # reset for next call in loop\r\n\r\nWhen we discuss \"decorators\" later in the course, we will see all sorts of what\r\nI would call fascinating uses of classes that remember a function and define\r\nfunction calls for the object that delegate to the function, but do something\r\nelse too. Thus, they \"decorate\" the function.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nContext managers:\r\n\r\nWe will first review using context managers, which have the following syntax. \r\n\r\n  with A_Class(...) [as name]:        # as name  is optional: in [] (EBNF)\r\n      block  # (possibly using name in its statements)\r\n\r\nYou should have used context managers in ICS-32, with the open class, to ensure\r\nthat any opened file is closed automatically (even if an exception was rasised\r\nwhen executing the block of code using it). We use the keyword \"with\" to invoke\r\na context manager, whose object may or may not be named; the context manager\r\nmanages execution of a block.\r\n\r\nGenerally, the purpose of a context manager is to simplify the setup/teardown\r\nof a context in which to execute the block. Oftentimes, the context includes\r\ninformation about how to do exception handling for the block, if any statement\r\nin the block raises an exception. To be used by a context manager, the class\r\nmust define both __enter__ and __exit__ methods. Below, we will examine how\r\nsuch code can perform setup and teardown, and handle exceptions. Once these\r\nmethods are written in a class, we can easily use a context manager to manage\r\nobjects from that class, avoding duplicating try/except statments other code.\r\n\r\nFor example, we can use an \"open\" class object in a context manager to ensure\r\nthat the open file is closed after the block finishes executing, regardless\r\nof whether our block raises an exception. We write no code to handle any\r\nexceptions and no code to close the file: that code appears in the __enter__ and\r\n__exit__ methods defined in the open class itself. For an example, we can\r\nwrite just\r\n\r\nwith open(...) as open_file:\r\n    for line in open_file:\r\n        process line, possibly raising an exception\r\n\r\nwhich opens the file, and processes all the information in it, a line it a time,\r\nand then closes the file. Even if the block raises an exception, the file will\r\nstill be closed by the context manager before it finishes executing.\r\n\r\nWe can write our own context managers by defining its protocol: writing two\r\nspecial methods in the class, __enter__ and __exit__. By defining these methods,\r\nwe can use objects of such a class in the syntax Python provides for context\r\nmanagers. Thus, defining these methods is similar to overloading operators:\r\nPython calls these __ methods automatically based on us using the \"with\" syntax,\r\nwhich is why we discuss them in this lecture.\r\n\r\nGenerally, the __enter__ method takes the standard self (an argument that is\r\nan instance of A_Class) and peforms the SETUP; if the \"as name\" option is to be\r\nused, then this method MUST RETURN SELF to bind to name. That name can be used\r\nin the statements executed in the block. It is a good idea for __enter__ to\r\nalways return self, whether or not it is expected to be bound to anything (with\r\nno \"as name\" option, this returned value is ignored).\r\n\r\nThe __exit__ method takes four arguments:\r\n  (1) the standard self,\r\n  (2) an object that is an exception class\r\n  (3) and object that is a raised exception: 2 is the type of 3; for example,\r\n        for raise AttributeError('...') (2) is AttributeError and (3) is the\r\n        raised exception object, which includes the text '...'\r\n  (4) a traceback (which we can print, and typically is formatted to print\r\n        nicely).\r\n\r\nThese parameters are bound to these special values automatically, if an actual\r\nexception is raised in the block; if no exception is raised, then 2-4 are each\r\nbound to the value None. So, the __exit__ of a context manager has a lot to do\r\nwith exceptions.\r\n\r\nThe __exit__ method performs the TEARDOWN and looks at these parameters and\r\ndoes what it wants with them: if it returns True any exception is considered to\r\nbe handled (some say the context manager \"swallows the exception\") and it does\r\nnot propagate; if __exit__ returns False, Python propagates the exception\r\n(re-raises it, signaling an error that must still be handled by other/outer\r\ncode -if not, Python just terminates the program and prints the traceback).\r\n\r\nWe can show the meaning of the \"with\" statement\r\n\r\n  with A_Class(...) [as name]:\r\n      block\r\n\r\nas being equivalent to the following Python code. Here underscored variables\r\n(e.g., _mgr) are temporary/locals used by Python, hidden from the programmer.\r\n\r\nimport sys\r\n_mgr   = A_Class(...)           # construct A_Class object\r\n_exit  = type(_mgr).__exit__    # just find it: if missing raises AttributeError\r\n_value = _mgr.__enter__()       # call SETUP: if missing raises AttributeError\r\n\r\ntry:\r\n    [name = _value]                     # Only if \"as name\" is present\r\n    block\r\nexcept:                                 # block raises ANY exception\r\n    if not _exit(_mgr,*sys.exc_info()): #   do TEARDOWN and exception handling\r\n        raise                           #   re-raise if _exit returns False\r\nelse:                                   # block raises NO exception \r\n    _exit(_mgr, None, None, None)       #   do TEARDOWN by special _exit call\r\n\r\nNote that *sys.exc_info() produces a 3-tuple consisting of the type of exception\r\nraised, the actual exception object, and the \"traceback\" with information about\r\nhow the exception started and propagated.\r\n\r\nHere are a few simple but powerful context managers. The first executes a block\r\n(really designed to execute a single statement) handling specific exceptions by\r\nignoring them, but propagating all other exceptions.\r\n\r\nclass Ignore:\r\n    # no 2nd argument means ignore ALL exceptions\r\n    def __init__(self,*exceptions_to_ignore):\r\n        self._ignore = exceptions_to_ignore\r\n    \r\n    def __enter__(self):\r\n        return self\r\n    \r\n    def __exit__(self,exc,exc_value,traceback):\r\n        return self._ignore == () or exc in self._ignore\r\n\r\nHere __enter__ does nothing special (but does return self); __exit__ returns\r\nTrue if self._ignore is either the empty tuple (meaning ignore ALL exceptions),\r\nor the exception raised is in self._ignore tuple (one of the exceptions that\r\nthe class was constructed to ignore). Remember than returning True means that\r\nthe exception is considered handled/swallowed and will not propagate. So\r\nexecuting\r\n\r\nwith Ignore(AssertionError):\r\n    raise AssertionError('...')\r\nprint('After with')\r\n\r\nwill execute the print statement (because __exit__ returns True, since the\r\nIgnore object it is told to ignore AssertionError); but executing\r\n\r\nwith Ignore(AssertionError):\r\n    raise TypeError('...')\r\nprint('After with')\r\n\r\nwill NOT execute the print statement; instead the context manager will raise a\r\nTypeError exception (because __exit__ returns False, since the Ignore object is\r\nnot told to ignore TypeError).\r\n\r\nA more realistic use of the Ignore in a context manager allows us to ensure\r\nthere is no file with a certain name in our directory: we want to remove a file\r\nname from our directory, but if the file doesn't exist in the first place, we\r\njust keep executing. Calling os.remove for a file that does not exist raises the\r\nFileNotFoundError.\r\n\r\nwith Ignore(FileNotFoundError):\r\n    os.remove(file)\r\n\r\nHere, if the removal of a file fails, the FileNotFoundError error is raised but\r\nignored. So, the code after the context manager keeps executing. Without\r\ncontext managers we would need to write\r\n\r\ntry:\r\n    os.remove(file)\r\nexcept FileNotFoundError:\r\n    pass\r\n\r\nSo, we can use context managers to more simply capture this pattern, and use\r\nit much more easily.\r\n\r\nHow does the open class used in ICS-32 work with the context manager? It defines\r\nan __enter__ and __exit__ class. In the open class, its __init__ method would\r\nstore the open file object, then its __enter__ method would return it, and\r\nfinally the __exit__ method would close that file before returning, regardless\r\nof whether an exception was raised; if an exception was raised, it will be\r\npropagated (__exit__ always returns False).\r\n\r\nAs a similar example, suppose that we wanted to write a class that allowed us to\r\nuse it in context manager to echo/duplicate all values printed via a print\r\nstatement into a special log file. The print would still print on the console\r\n\r\nclass Echo:\r\n    def __init__(self,open_file):\r\n        self._log_file = open_file\r\n        \r\n    def __enter__(self):\r\n        import builtins,sys\r\n        self._real_print = builtins.print # Save the print accessed via builtins\r\n        def echo_print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False):\r\n            self._real_print(*objects,sep=sep,end=end,file=file,flush=flush)\r\n            self._real_print(*objects,sep=sep,end=end,file=self._log_file,flush=flush)\r\n        builtins.print = echo_print       # Change the print accessed via builtins!\r\n        return self\r\n    \r\n    def __exit__(self,exc,exc_value,traceback):\r\n        import builtins\r\n        self._log_file.close()\r\n        builtins.print = self._real_print # Always restore the original print accessed via builtins!\r\n        return False                      # Don't \"swallow\" any exceptions\r\n\r\nWe would use this class in a context manager like\r\n\r\nwith Echo(open('test_echo_output.txt','w')):\r\n    print('abc')\r\n    print(1,2,3)\r\n    print('xyz')\r\nprint('After with')\r\n\r\nHere, abc, 1 2 3, xyz, and After with are printed on the console. The file\r\nname test_echo_output.txt contains abc, 1 2 3, and xyz (not After with).\r\nIn fact, if we called any function in the Echo block, and that function\r\ncontained a print that was accessed in builtins, then that print would be\r\nechoed too.\r\n\r\nTo start, __init__ creates an attribute to refer to the open file object into\r\nwhich information is written.\r\n\r\nHere __enter__ creates an attribute to remember the real print statement (the\r\none stored in builtins.print); it then defines echo_print to have the same\r\nheader as print (but its body calls the real print, and the real print\r\nspecifying self._log_file as the place the print write into); then it replaces\r\nbuiltins.print with this one. Finally __enter__ returns an Echo object (which\r\nis not really needed because the context manager doesn't use \"as name\").\r\n\r\n__exit__ automatically closes the file (like open's __exit__ does) and restores\r\nthe original print in builtns. Then it returns False, propagating any exceptions\r\nraised in block (none in the example above). But it does make sure, even if an\r\nexception is raised, that the builds.print function is restored.\r\n\r\nFinally, the \"with\" syntax can include a sequence of objects, which create\r\nnested context managers. In Python's form of EBNF (a cross between EBNF and\r\nregular expressions) we would write\r\n\r\nwith_stmt ::=  \"with\" with_item (\",\" with_item)* \":\"\r\n                   block\r\nwith_item ::=  expression [\"as\" target]\r\n\r\nwith A_Class(...) as name1, B_Class(...) as name2:\r\n    block\r\n\r\nis equivalent to \r\n\r\nwith A_Class(...) as name1:\r\n    with B_Class(...) as name2:\r\n        block\r\n\r\n------------------------------------------------------------------------------\r\n\r\nAttributes:\r\n\r\nIn this last section we will discuss some of the methods that are at the heart\r\nof how Python executes our code. All require careful use or they will cause\r\nbig problems (often infinite recursion) that stop the execution of all Python\r\ncode. All concern getting and setting the values of attributes in the namespaces\r\nof objects (what classes are all about). Here is the complete laundry list.\r\n\r\n__getattr__(self,name)\t     \t     : called, when cannot find name attribute\r\n__setattr__(self,name,value)\t     : set name attribute to value\r\n__delattr__(self,name)\t\t     : delete name attribute\r\n__getattribute__(self,name)\t     : access name attribute\r\n                                       (tough to overload, unless you know about\r\n                                        inheritance, we will discuss it then)\r\n\r\nWhenever we refer to an attribute in some object's namespace (recall __dict__\r\nstores the namespaces for objects, containing the bindings of their instance\r\nvariables) Python calls one of a few double-underscore method: if we do NOT\r\ndefine these methods for a class, Python uses inheritance (a topic that we will\r\ncover later) to determine what to do.\r\n\r\nWe will look at __getattr__ first (it is the safest), which is called when a\r\nattribute CANNOT be found in a namespace (much like __missing__ for\r\ndictionaries, discussed briefly above). Here is a small class that defines this\r\nmethod to return a string that includes the name of the nonexistant attribute,\r\ninstead of raising the NameError exception. We could also easily return None\r\nfor such non-existant attributes when they are \"gotten\".\r\n\r\nclass C:\r\n    def __getattr__(self,name): # call when name (a str) isn't in the namespace\r\n        print('Attribute for ' + name + ' not found')\r\n        return name+'?' # Just returns a string of name followed by ?\r\n\r\no = C()\r\nprint(o.a_name)\r\nprint(o.a_name)\r\no.a_name = 0\r\nprint(o.a_name)\r\n\r\nRunning this code prints the results\r\n\r\nAttribute for a_name not found\r\na_name?\r\nAttribute for a_name not found\r\na_name?\r\n0\r\n\r\nWhen the a_name attribute of o is referred to in the first print; this attribute\r\ndoesn't exist, so Python calls __getattr__ for its result, which returns the\r\nattribute's name with a ? appended. This doesn't change whether that name is\r\nbound to anything, so the same thing happens if it is called again. When the\r\na_name attribute of o is referred to in the second print, it has already been\r\nbound to a value (see o.a_name = 0) so Python doesn't call the __getattr__\r\nmethod. IMPORTANT __getattr__ is called only for attributes that don't exist;\r\nit is not called for all attributes (that is what __getattribute__ is for, but\r\nit is tough to use correctly until we learn about inheritance).\r\n\r\nNow let's look at the standard meaning of __setattr__ for a class; if we do\r\nnot define our own __setattr__, the class uses one (through inheritance, a topic\r\nwe cover later in ICS-33) that is equivalent to defining the following one.\r\n\r\n    def __setattr__(self,name,value):\r\n        self.__dict__[name] = value\r\n\r\nStudy this simple code carefully. It translates o.a = v into a method call on\r\n__setattr__: it executes o.a = v by executing o.__setattr__('a', v), which\r\nexecutes o.__dict__['a'] = v. Notice that the attribute name is CONVERTED INTO\r\nAN EQUIVALENT STRING when calling __setattr__, which is used as a key in\r\n__dict__.\r\n\r\nOne thing we should NEVER DO is write\r\nOne thing we should NEVER DO is write\r\nOne thing we should NEVER DO is write\r\n\r\n    def __setattr__(self,name,value):    # NEVER DO THIS\r\n        pass                             # NEVER DO THIS\r\n\r\nThis code executes o.a = v by doing nothing! It does not bind this attribute to\r\nanything. By NOT DEFININING OUR OWN __setattr__, the standard one will execute.\r\nif we DEFINE OUR OWN, it is likely to include self.__dict__[name] = value\r\nsomewhere in the code: we set the attribute but maybe do something else too.\r\n\r\nNow let's looks at a sophisticated use of the __setattr__ method. The class\r\nbelow defines the __setattr_ method so that it uses a dict to remember all the\r\nvalues ever bound to an attribute (stored in self._history).\r\n\r\nfrom collections import defaultdict # for elegance; with __setattr__ we need it\r\n\r\nclass C:\r\n    def __init__(self):\r\n        self._history = defaultdict(list)   # empty list when initially accessed\r\n        self.s = 0\r\n\r\n    def bump(self):     # resets attribute s: bind s to a value one bigger\r\n        self.s += 1\t# equivalent to self.s = self.s + 1\r\n        \r\n    def __setattr__(self,name,value):\r\n        # print('C.__setattr__',name,value) # helps for debugging\r\n        if '_history' in self.__dict__:     # False (skip append) 1st time only:\r\n                                            #   self._history = ... in __init__\r\n           self._history[name].append(value)# Do this every time but 1st\r\n        self.__dict__[name] = value         # always do this too, to update name\r\n            \r\n    def report(self):\r\n        print('History Report:') \r\n        for k,v in sorted(self._history.items()):\r\n            print('  ',k,' had the values:', v)\r\n\r\nFirst, whenever __setattr__ is called, it checks to see if '_history' is already\r\nan attribute name; if not yet, it means that self._history is being set for the\r\nfirst time, in __init__, by executing the self._history = defaultdict(list),\r\nso __setattr__ shouldn't update the history by appending a new value, because\r\nthere is no history dictionary yet to append to! This binding MUST occur FIRST\r\nin __init__ for the interesting parts of __setattr__ to work correctly.\r\n\r\nNext, __setattr__ sets the attribute by using __dict__ directly, using the\r\nstring name as the key, and thus bypasses another (recursive) call to\r\n__setattr__. So, when called in __init__, when there is no '_history' attribute,\r\nthis statement creates one; if there already is a '_history' attribute, this\r\nstatement updates whatever attribute is being set.\r\n\r\nIf we ran the following script\r\n\r\nx = C()\r\nx.s = 3    # resetts attribute initialized to 0 in __init__\r\nx.bump()\r\nx.bump()\r\nx.y = 11   # create a new attribute not created in __init__\r\nx.s = 8\r\nx.y += 1\r\nx.report()\r\n\r\nCalling x.report would show a history of all the values the two instance\r\nvariables stored.  Recall that the name parameter in __setattr__ is passed a\r\nstring argumen: x.s = passes 's' as the name of the attribute to set, and\r\n8 as its value.\r\n\r\nHistory Report:\r\n   s  had the values: [0, 3, 4, 5, 8]\r\n   y  had the values: [11, 12]\r\n\r\nNote that x._history['s'][-1] is the current value bound to x.s (the last one\r\nin the list), and x._history['s'][-2] is the previous one to that. We might\r\ncall this an Elephant class: it never forgets the binding for a name, even\r\nafter the name is rebound to another value.\r\n\r\nThe method __delattr__ is not so useful (and __getattribute__ is so dangerous\r\nto use that we will bylass it now). But here is a short example of a class that\r\nkeeps a list of names that have been deleted from it and what their last\r\nbindings were (like remembering the old bindings of instance varaibles). Recall\r\nthat name is a string: del o.y calls type(o).__delattr__ and passes 'y' as the\r\nname of the attribute to delete.\r\n\r\nclass C:\r\n    def __init__(self):\r\n        self._deleted = {}\r\n\r\n    def __delattr__(self,name):\r\n        self._deleted[name] = self.__dict__[name]\r\n        del self.__dict__[name]\r\n\r\n    def report(self):\r\n        print('Deleted attributes and their final values:',self._deleted)\r\n\r\no = C()\r\no.x = 1\r\no.y = 2\r\no.z = 3\r\ndel o.x\r\ndel o.y\r\no.report()\r\n\r\nCalling o.report prints: \r\n\r\n  Deleted attributes and their final values when deleted : {'y': 2, 'x': 1}\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe double-underscore methods __iter__ and __next__ are so useful (everything\r\nabout iteration is useful) we will spend next week examining this protocol\r\nand various ways to implement it.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFYI, here is the entire List1 class with all the methods described above.\r\n\r\nclass List1:\r\n    def __init__(self,_plist):\r\n        self._plist = list(_plist)\r\n        \r\n    def __str__(self):\r\n        return str(self._plist)\r\n\r\n    @staticmethod\r\n    def _fix_index(i):\r\n        if i == None:\r\n            return None\r\n        else:\r\n            # for positive indexes, 1 smaller: 1 -> 0\r\n            # for - indexes, the same: -1 (still last), -2 (still 2nd to last\r\n            return (i-1 if i >= 1 else i)\r\n        \r\n    def __getitem__(self,index):\r\n        print('List1.__getitem__('+str(index)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            return self._plist[List1._fix_index(index)]\r\n        elif type(index) is slice:\r\n            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)\r\n            return self._plist[s]\r\n        else:\r\n            raise TypeError('List1.__getitem__ index('+str(index)+') must be int/slice')\r\n  \r\n    def __setitem__(self,index,value):\r\n        print('List1.__setitem__('+str(index)+','+str(value)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            self._plist[List1._fix_index(index)] = value\r\n        elif type(index) is slice:\r\n            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)\r\n            self._plist[s] = value\r\n        else:    \r\n            raise TypeError('List1.__setitem__ index('+str(index)+') must be int/slice')\r\n        \r\n    def __delitem__(self,index):\r\n        print('List1.__delitem__('+str(index)+')') # for illumination/debugging\r\n        if type(index) is int:\r\n            del self._plist[List1._fix_index(index)]\r\n        elif type(index) is slice:\r\n            s = slice(List1._fix_index(index.start), List1._fix_index(index.stop), index.step)\r\n            del self._plist[s]\r\n        else:            \r\n            raise TypeError('List1.__delitem__ index('+str(index)+') must be int/slice')\r\n\r\n    def __len__(self):\r\n        return len(self.thislist)\r\n    \r\n    def __contains__(self,item):\r\n        return item in self._plist\r\n\r\n\r\nNote that we could define the following __getattr__ method for List1.\r\n\r\n    def __getattr__(self,attr):        # if attr not here, try self._plist\r\n        return getattr(self._plist,attr)\r\n\r\nThis says, if we try to access any attribute that is not defined for List1,\r\nget that attribute from self._plist. Generally this is called delegation:\r\nwhere an \"outer\" object that does not have some attribute delegates the\r\nattribute reference to an inner object. Doing so allows us the inner object \r\nimplicitly to do all processing not explicitly done by the outer object.\r\n\r\nSo for example, if we wrote\r\n\r\nx = List1([1,2,3])\r\nx.append(4)\r\nprint(x[4])\r\n\r\nit would print 4. There is no append attribute defined in List1, so instead we\r\nget that attribute from self._plist, in which case the attribute is a method\r\nthat we can call (we call it here with the argument 4).\r\n\r\nGenerally this is called delegation: where an \"outer\" object that does not have\r\nsome attribute delegates the attribute reference to an inner object. Decorators\r\noften use exactly this form of delegation, so the decorator object can process\r\nits attributes and all the attributes of the decorated object.\r\n\r\nIn fact, with this __getattr__ method we can omit defininig __len__ and\r\n__contains__ letting those attributes be accessed in the self._plist. Such\r\ndelegation would work for all method that are index independent. We would still\r\nhave to define, in List1, all the methods using list indexes because the whole\r\npurpose of this class is to shift the original from index 0 to index 1.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFYI, here is a list of operators and the double-underscore methods that we can\r\ndefine to overload them. We've covered most but not all.\r\n\r\nRelational operators: < > <= >= eq ne\r\n__lt__  __gt__  __le__  __ge__  __eq__  __ne__\r\n\r\nUnary operators/functions: + - abs ~ round floor ceil trunc\r\n__pos__  __neg__  __abs__  __invert__  __round__  __floor__  __ceil__\r\n\r\nArithmetic: + - * / // % divmod ** << >> & | ^\r\n__add__  __sub__  __mul__  __truediv__  __floordiv__  __mod__  __divmod__\r\n__pow__ __lshift__  __rshift__  __and__  __or__  __xor__\r\n\r\nReflected (right) arithmetic \r\n__radd__  __rsub__  __rmul__  __rtruediv__  __rfloordiv__  __rmod__  __rdivmod__\r\n__rpow__  __rlshift__  __rrshift__  __rand__  __ror__  __rxor__\r\n\r\nIncrementing Arithmetic: += -= *= /= //= %= **= <<= >>= &= |= ^=\r\n__iadd__  __isub__  __imul__  __idiv__  __ifloordiv__  __imod__  __idivmod__\r\n__ipow__ __lishift__  __irshift__  __iand__  __ior__  __ixor__\r\n\r\n\r\nType conversion: int float complex oct hex index trunc coerce\r\n__int__  __float__  __complex__  __oct__  __hex__  __index__  __trunc__  \r\n__coerce__\r\n\r\nClass representation:\r\n__str__  __repr__  __unicode__  __format__  __hash__  __nonozero__  __dir__\r\n\r\n\r\nAttribute:\r\n__getattr__  __setattr__  delattr__  __getattribute__\r\n\r\n\r\nContainers:\r\n__len__  __getitem__  __setitem__  __delitem__ __iter__  __reversed__\r\n__contains__  __missing__\r\n\r\nMisc:\r\n\r\n__call__  __copy__  __deepcopy__\r\ngetattr/setattr: special classes, wrapped, inheritance soon, and decorators\r\n\r\nContext managers\r\n\r\n__enter__  __exit__\r\n\r\nDescriptors:\r\n__get__  __set__  __delete__\r\n\r\n\r\n\r\nDo you want to build your own context manager: overload the __enter__ and\r\n__exit__ methods\r\n\r\n\r\n__iter__ and __next_ for generators\r\n\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n1) Write a class named Indexed_Set that defines an __init__ method taking\r\nanything that can be iterated over as an argument (e.g., list, tuple, set) and\r\nstores all these values in a set. Although sets don't have indexes, define a\r\n__getitem__ method such that for int index i it returns the ith value produced\r\nwhen iterating over the set (raising IndexError for too small/too large\r\nindexes); for a slice index, __getitem__ produces a set containing all the the\r\nindexed values; for any other index (non-int, non-slice) raise the TypeError\r\nexception. Of course Python can iterate over an Indexed_Set using __getitem__.\r\nHint: write a _getitem helper method that implements the requirements for int\r\nindexes, which is called from __getitem__ when necessary (once for an int index,\r\nmultiple times for a slice index; build the resulting set with a comprehension).\r\n\r\n\r\n2) Write a class name Count_Argument_Use that defines an __init__ method taking\r\na function of one parameter as an argument. Define a __call__ method that keeps\r\na dictionary of what argument the function was called with and how often it\r\nwas called with each argument. Define a report method that prints each argument\r\nin this dictionary, followed by the number times it was used, in decreasing\r\norder of the times it was used. Test this code on the fibonacci function defined\r\nin these notes. For fib(10), calling report() should print:\r\n\r\nArgument | Times Called\r\n---------+-------------\r\n       1 |           55\r\n       0 |           34\r\n       2 |           34\r\n       3 |           21\r\n       4 |           13\r\n       5 |            8\r\n       6 |            5\r\n       7 |            3\r\n       8 |            2\r\n       9 |            1\r\n      10 |            1\r\n\r\n3) Write a class named Copying that can be used as context manager for writing\r\nsimple scripts that copy information an input file to an output file. It\r\ndefines an __init__ method taking the name of the input and output files as\r\narguments. It defines an __enter__ method that opens these file names for\r\nreading/writing and prints 'Starting Copy' on the console. Copying defines a\r\nread method that calls readline on the open input file and either (a) returns\r\nthe next line of the input file or (b) or raises the EOFError exception if that\r\nline comes back empty; it defines a write method (with a string parameter) that\r\nwrites its parameter into the open output file. Finally, Copying defines an\r\n__exit__ method that prints 'Stopping Copy....successfully on EOF' if that was\r\nthe exception that terminated the block (and considers the exception handled)\r\nand prints 'Stopping Copy....on exception' if any other exception that\r\nterminated the block (and considers the exception not handled). Here are three\r\nexamples of code using the Copying class as a context manager.\r\n\r\n#pure copy\r\nwith Copying('input.txt','output.txt') as copy:\r\n    while True:\r\n        copy.write(copy.read())\r\n\r\n#duplicate input lines for output\r\nwith Copying('input.txt','output.txt') as copy:\r\n    while True:\r\n        to_write = copy.read()\r\n        copy.write(to_write)\r\n        copy.write(to_write)\r\n\r\n#only copy lines matching the string pattern\r\nwith Copying('input.txt','output.txt') as copy:\r\n    re_pattern = re.compile(pattern)\r\n    while True:\r\n        to_write = copy.read()\r\n        if re_pattern.match(to_write):\r\n            copy.write(to_write)\r\n  \r\n4) Write the class Store_Once that defines an __init__ method taking a anything\r\nthat can be iterated over to produce strings as an argument (e.g., list of\r\nstrings, tuple of string, set of string) and stores all these strings in a set.\r\nDefine a __setattr__ method that allows currently unbound attributes to be set,\r\nbut raises Exception (with a reasonable message) if attempting to change the\r\nbinding of a currently bound attribute in the stored set. Raise the exception\r\nonly if the value is to be changed, not just rebound to the same (check using\r\nthe is or is not operator).\r\n\r\n4) The following code is supposed to print a file twice. Why does it not work?\r\nWhat does it do.\r\n\r\no = open('filename','r')\r\n\r\nwith o:\r\n    for line in o:\r\n        print(line)\r\n\r\nwith o:\r\n    for line in o:\r\n        print(line)\r\n", "encoding": "ascii"}