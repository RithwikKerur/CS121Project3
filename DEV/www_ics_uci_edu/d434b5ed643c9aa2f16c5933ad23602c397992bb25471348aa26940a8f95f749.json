{"url": "https://www.ics.uci.edu/~kay/courses/141/restaurants.txt", "content": "\n;;;;;;;; RESTAURANT DATABASE PROGRAM\n;;;;;;;; ICS 141 -- UC Irvine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; David G. Kay\n\n;;;;;;;; Top-level Application Routines ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define Restaurants                        ; Main \"driver\" routine; call in\n   (lambda ()                              ;   interpreter by (Restaurants)\n      (let((collection (make-collection))) \n        (handle-commands collection)\n      (write-line \"Thank you.  Good-bye.\"))))\n\n(define handle-commands                   ; Repeatedly handle menu requests\n  (lambda (C)\n   (let ((response (get-menu-response)))  ; Get a response from the user\n     (case response                       ; 'case' is like 'cond' but it\n       ((q) C)                            ; matches values, not boolean expressions\n       ((a) (handle-commands (collection-add C (rest-get-info))))\n       ((r) (handle-commands (collection-remove C (test-to-match-name))))\n       ((p) (begin (print-collection C) (handle-commands C)))\n       ((s) (begin (search-collection C) (handle-commands C)))\n       (else (begin (invalid-command response) (handle-commands C)))))))\n\n(define  get-menu-response                ; Print the menu and get an answer\n   (lambda ()\n      (newline)\n      (write-line \"Restaurant Collection Program --- Choose one:\")\n      (write-line \"   a:  Add a new restaurant to the collection\")\n      (write-line \"   r:  Remove a restaurant from the collection\")\n      (write-line \"   s:  Search the collection for selected restaurants\")\n      (write-line \"   p:  Print all the restaurants\")\n      (write-line \"   q:  Quit\")\n      (read)))\n\n(define invalid-command                       \n   (lambda (response)                                 \n      (write-line \"Sorry; '\" response \"' isn't a valid command.  Please try again.\")))\n\n(define test-to-match-name     ; This routine returns a PROCEDURE (a lambda     \n  (lambda ()                   ; expression); that's what's needed by the\n    (let ((deletion            ; 'remove' command.\n            (get-it \"name of the restaurant to delete\")))\n      (lambda (R)\n        (equal? deletion (rest->name R))))))\n\n(define print-collection       ; The (lambda(x)#t) below matches every restaurant\n  (lambda (collection)         ; in the collection, so this call essentially gives\n    (for-each rest-print       ; us a Lisp list of each rest. in the collection.\n                 (collection-select collection (lambda (x) #t)))))                  \n\n(define search-collection\n  (lambda (collection)\n    (let ((name (get-it \"name of the restaurant to search for\")))\n        (for-each rest-print\n                          (collection-select collection\n                                             (lambda (R)\n                                               (equal? name (rest->name R))))))))\n\n\n\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t\t\t\t\t   \n\n\n\n;  Here's another routine that the program here doesn't call;\n;  it's a good exercise, though.\n\n(define cheap-dishes          ; What restaurants are cheap?\n   (lambda (C)\n     (let ((threshhold ((get-it \"the cut-off price\"))))\n       (for-each rest-prin\n                 (collection-select C (lambda (R) (< (rest->price R) threshhold)))))))\n           \n           \n           \n;;; REST -- Abstract data type for a restaurant\n\n(define-record rest (name cuisine phone dish price))\n\n; Calling define-record automatically creates for us:\n;     (make-rest n c ph d p)   -- This \"constructor\" routine builds a new 'rest'\n;     (rest? R)                -- This predicate checks whether R is a 'rest'\n;     (rest->name R)           -- These \"selector\" routines return the components\n;     (rest->cuisine R)        --     of a 'rest'\n;     (rest-phone R)    (rest->dish R)    (rest-price R)\n\n(define rest-get-info                       ; Prompts a user at a terminal to enter\n  (lambda ()                                ; info to create a new restaurant\n    (write-line \"When the machine asks you to supply some non-numeric information, \")\n    (write-line \"please type that information surrounded by parentheses.\")\n    (let* ((n (get-it \"restaurant's name\"))\n           (c (get-it \"kind of food served\"))\n           (ph (get-it \"phone number\"))\n           (d (get-it \"name of the best dish\"))\n           (p (get-it \"price of that dish\")))\n       (make-rest n c ph d p))))\n\n(define rest-print\n  (lambda (r)\n    (write-line \"Name:      \" (rest->name r))\n    (write-line \"Cuisine:   \" (rest->cuisine r))\n    (write-line \"Phone:     \" (rest->phone r))\n    (write-line \"Best dish: \" (rest->dish r))\n    (write-line \"Price:     \" (rest->price r))))\n\n\n;;; COLLECTION -- Abstract data type for a collection of restaurants\n;;;\n;;; We represent the collection as a Lisp list of restaurants (for now;\n;;; we could change that representation, perhaps to a binary search tree\n;;; sorted by the name of the restaurant).\n\n(define make-collection\n  (lambda ()\n    '()))\n\n(define collection-add\n  (lambda (C R)\n    (cons R C)))\n\n(define collection-empty?\n  (lambda (C)\n    (null? C)))\n\n(define collection-remove       ; Return a collection made up of all the\n  (lambda (C test?)             ; restaurants in C that do NOT pass 'test?'\n    (cond\n      ((collection-empty? C) (make-collection))\n      ((test? (first C)) (collection-remove (rest C) test?))\n      (else (cons (first C) (collection-remove (rest C) test?))))))\n\n(define collection-select       ; Return a Lisp list made up of all the\n  (lambda (C test?)             ; restaurants in C that pass 'test?'\n    (cond\n      ((collection-empty? C) '())\n      ((test? (first C)) (cons (first C) (collection-select (rest C) test?)))\n      (else (collection-select (rest C) test?)))))\n\n\n\n\n\n\n(define collection-change       ; Return collection after applying 'action'\n  (lambda (C test? action)      ; to each restaurant that passes 'test?'\n    (cond\n      ((collection-empty? C) (make-collection))\n      ((test? (first C)) (cons (action (first C))\n                               (collection-change (rest C) test? action)))\n      (else (cons (first c) \n                  (collection-change (rest C) test? action))))))\n\n;;;;;;;; GENERALLY USEFUL INPUT/OUTPUT ROUTINES\n\n(define get-it\n   (lambda (what-to-get)\n      (display \"Please enter the \")\n      (display what-to-get)\n      (display \":  \")\n      (read)))\n\n(define write-line         ; The form of lambda used here makes 'item'\n  (lambda item             ; a list of ALL the arguments (however many)\n    (for-each display item); in the call to write-line.  The 'for-each'\n    (newline)))            ; applies 'display' to each element of 'item'.\n\n", "encoding": "ascii"}