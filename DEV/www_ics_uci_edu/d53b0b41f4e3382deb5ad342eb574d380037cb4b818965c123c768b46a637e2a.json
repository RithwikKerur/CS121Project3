{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990929.txt", "content": "WebDAV Advanced Collections Minutes September 21, 1999\n\nATTENDING: Judy Slein, Jason Crawford, Jim Whitehead, Geoff Clemm, Chuck Fay\n\nACTION ITEMS\n\nGeoff or Jason: Write up a discussion of protection for the mailing list\n\nJim: Put the issue of overlapping source / destination trees in COPY operations\non the RFC 2518 issues list.\n\nLOGISTICS\n\nPlan for WebDAV meeting at IETF: We might try to avoid spending time on a presentation at\nthe meeting by notifying the mailing list that specs must be read in advance, and that if\npeople don't do that we will spend the first hour of the meeting reading and marking up\nspecs.\n\nSchedule of spec revisions: Next draft to team 10/8, submit to internet-drafts 10/15\n\nIt would help people for planning whether / when to attend IETF to know whether there will\nbe informal breakout sessions and which days.\nWe'll have a half-day breakout session on advanced collections, preferably on the same day\nas WebDAV.  This will depend partly on when Delta-V gets scheduled.  But in any case we'll\ntry to keep all official and unofficial WebDAV and Delta-V meetings on Wednesday and\nThursday. (Jim Whitehead requested Wednesday or Thursday for the official WebDAV meeting,\nand requested that WebDAV and Delta-V get times near each other, but hasn't heard back.) \n\nISSUE 21: COPY INTO THE SAME TREE\n\nThis issue isn't really advanced collections.  It's about RFC 2518.  There is a need to \nclarify semantics for cases where there is overlap between the source tree and the\ndestination tree in a COPY operation.  Jim will make sure this issue gets included on\nthe RFC 2518 issues list.\n\nGeoff had proposed that we sat COPY is equivalent to copy to a temporary location,\nthen MOVE to the destination as a way to make this case work properly.\n\nDELETE SEMANTICS\n\nAgreed: DELETE has unbind semantics.\n\nThe unbind semantics is required both for backward compatibility in versioning\ncontexts, and for normal Web authoring (John Stracke's scenario).\n\nDO LOCKS MOVE WITH A MOVED RESOURCE?\n\nAgreed: If a locked resource is MOVEd, the lock moves with it.  The lock token has to \nstay the same during a MOVE; if the server can't preserve the lock token, it must fail \nthe MOVE.\n\nKey use case: If there are multiple bindings to resource R, and a LOCK is performed\nthrough one URL, and a MOVE on another URL, the resource needs to stay locked.  That's\nwhy MOVE should preserve the lock.\n\nAnother use case: If you MOVE collection A, and there's a resource under it that's \nlocked, that lock should not get lost.  (Yaron thinks it should get lost.)\n\nWe agreed earlier that the lock token is not allowed to change during a MOVE.  If\nthe server can't preserve the same lock token, it must fail the MOVE.\n\nFor any underlying repository that doesn't have DAV semantics for lock/move, there\nwill be the problem of how to map DAV semantics to the underlying repository\nsemantics.\n\nIf a move fails because of a lock, the client can just unlock, move, relock.\nSomething might happen during the small interval of time when the resource is\nnot locked.\n\nAre we concerned about losing the lock or about protecting the url so that the\nclient can continue to use it to refer to the resource? Both.\n\nIf the lock follows with a move, that might negatively affect lots of\nservers.  The underlying file system probably doesn't have a lock token, so the\nserver has to add that. They have to add a layer between the protocol and their \nfile system.\n\nWe shouldn't disrupt the semantics of the protocol to minimize the work of\nthe server implementer.  At least not unless we think the vast majority of\nrepository / file system implementations will have the same semantics.\n\nWe need to try to preserve a clean semantic model.\n\nWe agree that when a resource moves, its lock moves with it.  The token has to\nstay the same or the move fails.\n\nDOES A WRITE LOCK PREVENT NON-LOCK-OWNERS FROM MOVING A RESOURCE?\n\nThe key use case we all agree on is lost update: read, edit, put back -- the resource's\nstate shouldn't have changed in the mean time.\n\nDoes lock affect a MOVE? If Joe has lock on A, can Bob move A?  RFC 2518 \nsays that a write lock on a resource prevents that resource from being MOVEd by\nanyone other than the lock holder, but our binding semantics would say that a \nwrite lock on a resource does not prevent a MOVE.\n(A write lock on the parent collection would prevent a resource from being moved.)\n\nJim: We've been saying that a binding is only part of the collection's state.  But\nconsider a model of containment as 2 tokens, for the 2 ends of the relationship.\nIt's part of the state of the collection, and also part of the state of the\nresource.  Then to DELETE, you have to own the lock on both (or you own the lock\non one and other is not locked, or neither is locked).\n\nGeoff: There are these possibilities --\n1. the containment relation is stored in the collection. \n2. it is part of the state of the collection member. \n3. it is part of the state of both.\n4. it is part of the state of neither, but instead it's part of the state of some\n   third resource.\nAll of these logical possibilities have different effects on whathas to be \nlocked/unlocked, checked in/out. If we try to be neutral, it will be hard to say \nanything about effect of locks.  We have to make a choice.\n\nJim: Preferred it to be in both, but RFC 2518 claims the containment relationship\nis just in the collection.\n\nGeoff: Unix treats it as in collection. \n\nChuck: In DMA, there is a separate containment relationship object.  Containment\nis separate from issues of naming.  Each object has its own guid.\n\nIn DMA trial use, the binding name (last segment) is associated with the object, \nthe rest of the path you find by going up hierarchy. Every object knows the names \nof its parents.\n\nJim: Choose between having the containment relationship in the collection or in both.\nWe could say that a regular expression or complete set of its names is part\nof the state of the resource, so that you have to check out the resource in \norder to rename it.  Or maybe it's an attribute that can be changed without checking \nout the resource.\n\nThe question for versioning is when do you have to check out an object (create\na new version).  What we say about where the containment relationship resides\ndetermines this for MOVE.\n\nWhat locks affect your ability to rename / move an object? \nDo you need to lock the parent in order to move a resource? No.\nIf there is a lock on the parent, do you have to own it in order to move resource? Yes.\nIf the parent is unlocked but resource is locked, can someone move the resource? Depends \nwhere the state of binding is stored.\nWhat behavior does a client want to see?\n\nJim: Wants this: In order to move a resource, if parent is locked you must own\nthe lock, and if the resource itself is locked you must also own that lock.\n\nanonymous inverse binding: if I don't own the lock token on a resource, I can't modify \neither end of the containment relation.\n\nJim: Doesn't want to protect whole path, just finds it odd that someone other than \nthe lock owner could move the resource.  We can distinguish between a binding and \na name of a binding.  The binding is shared, but the name of the binding could belong \nto the collection. The part of the relationship that is stored in the contained resource\nis the unique id of the containing collection.\n\nJim really wants move behavior such that if you own the lock on a resource, you \nare the only one who can move the resource.\n\nGeoff would rather lose that than do confusing and special case semantics.  Keep the\nsemantics simple.\n\nJim: If locking doesn't prevent others from moving the resource, what do I do when\nI want to update the resource I locked but can't find it? \n \nGeoff: Do a PROPFIND on the lock token and comb through the results, or do a DASL\nquery on the lock token's value.  Neither of these will work if the resource was\nmoved far from its original location (for example, moved off server).\n\nJim: Clients are not currently very sophisticated.  You can't expect that much of \nthe client.\n\nYou can lock the collection if you really care.\n\nThis is excessive.\n\nMaybe the client would just let you save the resource as a different file (maybe\nwith the original name) if it got moved while you were editing.\n\nWhy not make server keep track of moves (as suggested on the mailing list)? \nJim: That would be a hack, a special case.\n\nGeoff: The clean position is to say that the lock is on the resource state, and\nif it's gone when want to do a PUT, you find it or create new a new resource at \nthe same URL.\n\nWe need to establish and stick to an underlying model.  Otherwise, when we add\nnew methods (as in versioning and beyond), there's no model you can appeal to.\n\nJim: We have to be sensitive to when we will reach limits of how much can push \neveryone into the same model.\n\nGeoff: In versioning, where you say the containment relationship lives determines\nwhat needs to be checked out to perform various operations.  If only the collection\nknows the names of its children, that keeps things simple when different people\nare using different names for the same resource.\n\nVersioning use cases argue for having the parent know the names of its children,\nbut the children not knowing their own names or the names of their parents.\n\nCan we say that the anonymous part of the relationship is not versioned. and so \nnot part of the state? \nWe don't want lock / checkout to affect different properties.\n\nNo agreement.\n\nPROTECTING THE URL\n\nWe still can try to do some protection. When you lock a resource, you lock its state\nand protect all bindings that lead to it.  Protecting is different from locking.\nIt means that nobody (including the lock owner) can delete this. Protection is cumulative.\nThe binding can only be deleted if all protections are gone.\n\nIf we only protect the final segment, it's not as important to distinguish between \nprotect and lock.\n\nWhen you unlock, it unprotects all those segments.\n\nProtection works with versioning, though it would be painful to implement.\n\nChuck: If we have a guid property, could you use the guid instead of the original \nrequest-URI in case the uri doesn't work?  (or use the lock token as the guid)\n\nGeoff: A real guid (urn) doesn't give locatability. They are orthogonal concepts.  You\nneed at least repository id, so that the repository can look up in the namespace with \nthe guid.\n\nChuck: You have host + guid.  The host in effect identifies the repository.\n\nObjection: If you do a PUT to a lock token, and its for a depth lock, what happens?\n\nSuppose we decide to protect the URL:\nIf you own the lock, and you move the resource, is the URL you used to designate\nthe new location now protected? This seems reasonable.\n\nWe need to continue discussion of protecting the URL.  Geoff will write up a\nproposal for discussion on the mailing list.\n", "encoding": "ascii"}