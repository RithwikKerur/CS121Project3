{"url": "https://www.ics.uci.edu/~kibler/javacourse/inheritance.html", "content": "<HTML>\n<head>\n<title>  Inheritance </title>\n<H1> Inheritance </H1>\n Goals: increase reusability, reliability and comprehensibility.\n<h3> Relationships between classes</h3>\n <ul>\n   <li> One class may <b> use </b> another class.\n   <li> One class may  <b> contain </b> another class. (Has-a)\n   <li> One class may <b> inherit </b> from another class. (is-a)\n   <li> Pay attention to the relationships between classes.\n </ul>\n<h3> Inheritance </h3>\n<li> Old method: code copying.\n<li> New method: Classes with inheritance.\n<li> You can inherited methods and data.\n<li> Inheritance permits minor variation and sharing.\n<li> Polymorphism permits determination of which\n    function to execute at run-time, decided by object type.\n<li> Java supports single-inheritance, ie. you can inheritance\n   hierarchy from a tree and each object is a member of only\n  one tree. An argument for this is simplicity.\n<li> A limited form of multiple inheritance is achieved with interfaces,\n   which is the next topic.\n</ul>\n\n  <h3> Inheritance Example  </h3>\n    <pre> public class NormedComplex\n             extends Complex         // the inheritance \n     {\n        private double norm;\n        \n         NormedComplex(double x, double y)\n        {\n           super(x,y);    // if this is not here, super() is assumed.\n                          // if super() not defined, compiler error.\n           norm = x*x-y*y;\n        }\n        NormedComplex()\n        {\n          this(0,0);     // No call to super() as \"this\" will call super.\n        } \n       \n        public void normalize()\n        {\n          setReal(getReal()/norm);            // getReal is inherited\n          setComplex(getImaginary()/norm);\n        }\n       ....\n      }\n\n</pre>  \n<h3> Shadowing/Overriding </h3>\n <ul>\n  <li>  Super can be used to access data member and member functions of the\n superclass (the one which was extended). \n <li> In the subclass, one can use the same variable name or method name\n   as in the superclass.\n     This <em>shadows </em> (hides) the inherited value. To get the inherited\n     value use super.x. \n <li> One can also shadow methods, which is called <em>overriding </em>.\n      Again to get the inherited method, use super.method(...).\n  <li> You cannot go up more than one level, by using super.super....\n  <li> You can prevent shadowing/overriding by declaring the member\n   to be final. It is common to declare constants to be final.\n  <li> You cannot increase the accessibility in subclasses.\n </ul>\n\n\n <h3> Casting </h3>\n  <ul>\n   <li> Casting converts an instance of one type  to another type, via\n      the prefix operator (type).\n   <li> Casting can be explicit or implicit.\n   <li> Examples of implicit casting:\n      <ul>\n         <li>  3+4.2    Here 3 is cast from integer to float.\n         <li>  \"sam\"+3  Here 3 is cast from integer to String.\n       </ul>\n   <li> Implicit casting is also called upcasting or widening,\n       as the object gains additional fields, usually set to\n     some default value.\n    <li>  Explicit casting typical narrows or removes fields, which\n    is called downcasting.\n    This can be dangerous as information maybe lost. For example:\n       <pre>\n         int i = 1000;\n         byte b = (byte) i;       \n      </pre>\n    If you are sure of the range of variable's value, casting may not\n   hurt, as in:\n\n      <pre>\n          int i  = 4;\n          byte b = (int)4;\n      </pre>  \n       \n    <li>\n     A typical use of casting occurs when retrieving elements\n    from some container, such as a Vector. \n    <pre>\n       Vector v = new Vector();\n       v.addElement(Complex c = new Complex(3,4));   // c is upcast to object\n       Complex c1 = v.getElementAt(0);   // This is an error, instead use\n       Complex c1 = (Complex) v.getElementAt(0);  // downcasting\n    </pre>\n    Notice that in Java Vectors are unsafe as Vectors (and other containers)\n   only hold Objects. Without undue cost, you can't enforce a Vector\n   of a particular type. Here Java is not as strongly typed as C++ is,\nwhich would accomplish the task via templates.\n   \n   </ul>\n\n  <h3> Abstract Classes </h3>\n  <ul>\n    <li> An <em> abstract </em> method consists of the signature followed by \n      a semicolon, e.g.  double area();\n    <li> An abstract method is used to set up a promise or contract that\n      every concrete subclass will implement the abstract method.\n  <li> A class is <em>abstract </em>\n      if it has at least one  method without an implementation or\n       if it is declared abstract.\n   <li> A class that contains an abstract method must be declared\n       abstract.\n    <li> You cannot instantiated (have an instance of) an abstract class.\n     <li> Subclasses of an abstract class may be abstract.\n     <li> Subclasses of a concrete class can be abstract.\n     <li> If a subclass overrides all the abstract methods, then it\n       can be instantiated.\n\n  </ul>\n\n <h3> Polymorphism Example </h3>\n<pre>\n  abstract class Shape  //  can't be instantiated\n  {\n    double  area();  // notice prototype\n    double perimeter();\n  }\n  class Rectangle extends Shape \n   {                            \n     double length, width;\n     Rectangle(double length , double width)\n      { \n        this.length = length;\n        this.width = width;\n      }\n     double area()\n    {\n      return length*width;\n    }\n     double perimeter()\n     {\n      return 2*length + 2*width;\n      }\n    }\n  class Square extends Rectangle \n     {\n        square(double side)\n       {\n          super(side,side);\n       }\n     }\n class Circle extends Shape\n\n   {\n     double radius;\n     circle(double radius)\n     {\n       this.radius = radius;\n     }\n    double area()\n   {\n     return Math.PI*radius*radius;\n   }\n   double perimeter()\n  {\n    return Math.PI*diameter(); // you don't worry about order of declaration\n  }\n  double diameter()\n  {\n    return 2*radius;\n }\n</pre>\n<h3> Polymorphism Example 2 </h3>\n Suppose we have graphical objects like buttons, scrollbars,\ntextfields, canvas, radio buttons and the like.\n<br> Suppose each is derived from a superclass class component, which\n has a paint method.\n<br> Suppose each graphical object overrides the paint method, saying\n how it should be drawn on display.\n <br> Suppose we have a method update() which has a container for\nall the objects on display and simple calls paint on each of them.\n <br> Notice how easy it will be to add a new graphical object.\n <br> This is how  Applet draw on the screen.\n \n<h3> What have we accomplished? </h3>\n <ul>\n <li> guaranteed that all implementation of shape have area function,\n    otherwise compile-time error.\n <li> allowed for uniform determination of area via polymorphism,\n  e.g. we could have a vector of shapes which was a mixture of\n  rectangles, squares, and circles and we could loop through them\n  and determine each objects area. But remember we need to cast them\n  to shape.\n </ul>\n\n\n  <h3> Accessibility Rules  </h3>\n The boundaries of accessibility are determined by class, subclass\nand package. If you write your code(classes) in one  directory, then the\nclasses are all part of the same anonymous package.\n  <ul>\n    <li> <em> Public </em> means accessible to anyone.\n    <li> <em> Private </em> means accessible only to members of the class\n   or to its inner classes.\n    <li> <em> No designation </em> means package or friendly accessibility,\n   ie. full visibility of methods and data to anyone in  the same package.\n    <li> <em> Protected </em> means accessible to subclasses\n    and to package members.\n    <li>  <em> Private Protected </em> means accessible only to subclasses.\n    <li> Note: when you subclass and override, you cannot increase the\n         accessibility. This would lead to a compile error.\n         \n   </ul>\n\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}