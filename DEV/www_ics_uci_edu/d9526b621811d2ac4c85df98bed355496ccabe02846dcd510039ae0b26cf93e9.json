{"url": "https://www.ics.uci.edu/~neno/dsl/dsl97.html", "content": "<HTML>\n<HEAD>\n   <META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n   <META NAME=\"Generator\" CONTENT=\"Microsoft Word 97\">\n   <META NAME=\"GENERATOR\" CONTENT=\"Mozilla/4.01 [en] (Win95; U) [Netscape]\">\n   <TITLE>Domains of Concern in Software Architectures</TITLE>\n</HEAD>\n<BODY>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=+1>Domains of Concern in Software\nArchitectures</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=+1>and Architecture Description\nLanguages</FONT></FONT></B></CENTER>\n<P>\n<CENTER><FONT FACE=\"Variable Width\">\n<a href=\"http://www.ics.uci.edu/~neno/\">Nenad Medvidovic</a> and \n<a href=\"http://www.ics.uci.edu/~dsr/\">David S. Rosenblum</a></FONT></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">\n<a href=\"http://www.ics.uci.edu/index.html\">Department of Information and Computer Science</a></FONT></I></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">\n<a href=\"http://www.uci.edu/\">University of California, Irvine</a></FONT></I></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">Irvine, California 92697-3425, U.S.A.</FONT></I></CENTER>\n\n<CENTER><I><FONT FACE=\"Variable Width\">{neno,dsr}@ics.uci.edu</FONT></I></CENTER>\n\n\n<P><B><FONT FACE=\"Variable Width\">Abstract</FONT></B>\n\n<P><I><FONT FACE=\"Variable Width\">Software architectures shift the focus of developers\nfrom lines-of-code to coarser-grained elements and their interconnection\nstructure. Architecture description languages (ADLs) have been proposed\nas domain-specific languages for the domain of software architecture. There\nis still little consensus in the research community on what problems are\nmost important to address in a study of software architecture, what aspects\nof an architecture should be modeled in an ADL, or even what an ADL is.\nTo shed light on these issues, we provide a framework of </FONT>architectural\ndomains, or areas of concern in the study of software architectures. We\nevaluate existing ADLs with respect to the framework and study the relationship\nbetween architectural and application domains. One conclusion is that,\nwhile the architectural domains perspective enables one to approach architectures\nand ADLs in a new, more structured manner, further understanding of architectural\ndomains, their tie to application domains, and their specific influence\non ADLs is needed.</I>\n\n<P><B>Keywords -</B><I> software architecture, architecture description\nlanguage, domain, domain-specific language, architectural domain</I>\n\n<P>\n<HR>\n<P>\n<B>Contents<BR>\n<UL>\n<LI><a href=\"#1\">1. Introduction</a>\n<LI><a href=\"#2\">2. Overview of ADLs</a>\n  <UL> \n  <LI><a href=\"#2.1\">2.1. Definitions of Architecture and Style</a>\n  <LI><a href=\"#2.2\">2.2. Definition of ADLs</a>\n  <LI><a href=\"#2.3\">2.3. Categorizing ADLs</a>\n  <LI><a href=\"#2.4\">2.4. Applications of ADLs</a>\n  <LI><a href=\"#2.5\">2.5. Architecture vs. Design</a>\n  </UL>\n<LI><a href=\"#3\">3. Architectural Domains</a>\n  <UL>\n  <LI><a href=\"#3.1\">3.1. Representation</a>\n  <LI><a href=\"#3.2\">3.2. Design Process Support</a>\n  <LI><a href=\"#3.3\">3.3. Analysis</a>\n    <UL>\n    <LI><a href=\"#3.3.1\">3.3.1. Static Analysis</a>\n    <LI><a href=\"#3.3.2\">3.3.2. Dynamic Analysis</a>\n    </UL> \n  <LI><a href=\"#3.4\">3.4. Evolution</a>\n    <UL>\n    <LI><a href=\"#3.4.1\">3.4.1. Specification-Time Evolution</a>\n    <LI><a href=\"#3.4.2\">3.4.2. Execution-Time Evolution</a>\n    </UL> \n  <LI><a href=\"#3.5\">3.5. Refinement</a>\n  <LI><a href=\"#3.6\">3.6. Traceability</a>\n  <LI><a href=\"#3.7\">3.7. Simulation/Executability</a>\n  </UL>\n<LI><a href=\"#4\">4. ADL Support for Architectural Domains</a>\n  <UL>\n  <LI><a href=\"#4.1\">4.1. Representation</a>\n  <LI><a href=\"#4.2\">4.2. Design Process Support</a>\n  <LI><a href=\"#4.3\">4.3. Analysis</a>\n    <UL>\n    <LI><a href=\"#4.3.1\">4.3.1. Static Analysis</a>\n    <LI><a href=\"#4.3.2\">4.3.2. Dynamic Analysis</a>\n    </UL> \n  <LI><a href=\"#4.4\">4.4. Evolution</a>\n    <UL>\n    <LI><a href=\"#4.4.1\">4.4.1. Specification-Time Evolution</a>\n    <LI><a href=\"#4.4.2\">4.4.2. Execution-Time Evolution</a>\n    </UL> \n  <LI><a href=\"#4.5\">4.5. Refinement</a>\n  <LI><a href=\"#4.6\">4.6. Traceability</a>\n  <LI><a href=\"#4.7\">4.7. Simulation/Executability</a>\n  <LI><a href=\"#4.8\">4.8. Summary</a>\n  </UL>\n<LI><a href=\"#5\">5. Architectural vs. Application Domains</a>\n<LI><a href=\"#6\">6. Conclusions</a>\n<LI><a href=\"#7\">7. Acknowledgements</a>\n<LI><a href=\"#8\">8. References</a>\n<LI><a href=\"#Footnotes\">Footnotes</a>\n</UL>\n</B><P>\n<HR>\n\n<P><a name=\"1\"><B><FONT FACE=\"Variable Width\">1. Introduction</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Software architecture is an aspect\nof software engineering directed at reducing costs of developing applications\nand increasing the potential for commonality among different members of\na closely related product family [<a href=\"#PW92\">PW92</a>, \n<a href=\"#GS93\">GS93</a>]. Software development based\non common architectural idioms has its focus shifted from lines-of-code\nto coarser-grained architectural elements and their overall interconnection\nstructure. This enables developers to abstract away the unnecessary details\nand focus on the \"big picture:\" system structure, high level communication\nprotocols, assignment of software components and connectors to hardware\ncomponents, development process, and so on.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Many researchers have realized that,\nto obtain the benefits of an architectural focus, software architecture\nmust be provided with its own body of specification languages and analysis\ntechniques [<a href=\"#Gar95\">Gar95</a>, <a href=\"#GPT95\">GPT95</a>, \n<a href=\"#Wolf96\">Wolf96</a>]. Such languages are needed to demonstrate\nproperties of a system upstream, thus minimizing the costs of errors. They\nare also needed to provide abstractions adequate for modeling a large system,\nwhile ensuring sufficient detail for establishing properties of interest.\nA large number of <I>architecture description languages</I> (ADLs) has\nbeen proposed, each of which embodies a particular approach to the specification\nand evolution of an architecture. Examples are \nRapide [<a href=\"#LKA+95\">LKA+95</a>, <a href=\"#LV95\">LV95</a>], \nAesop [<a href=\"#GAO94\">GAO94</a>], \nMetaH [<a href=\"#Ves96\">Ves96</a>], \nUniCon [<a href=\"#SDK+95\">SDK+95</a>], \nDarwin [<a href=\"#MDEK95\">MDEK95</a>, <a href=\"#MK96\">MK96</a>], \nWright [<a href=\"#AG94a\">AG94a</a>, <a href=\"#AG94b\">AG94b</a>], \nC2 [<a href=\"#MTW96\">MTW96</a>, <a href=\"#MORT96\">MORT96</a>,  \n<a href=\"#Med96\">Med96</a>], and \nSADL [<a href=\"#MQR95\">MQR95</a>]. \nRecently, initial work has been done on an architecture interchange language, \nACME [<a href=\"#GMW95\">GMW95</a>, <a href=\"#GMW97\">GMW97</a>], which is \nintended to support mapping of architectural specifications\nfrom one ADL to another, and hence provide a bridge for their different\nfoci and resulting support tools.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There is still very much a lack of\nconsensus in the research community on what an ADL is, what aspects of\nan architecture should be modeled by an ADL, and what should be interchanged\nin an interchange language. This divergence has resulted in a wide variation\nof approaches found in this first generation of ADLs. Perhaps even more\nsignificantly, there is a wide difference of opinions as to what problems\nare most important to address in a study of software architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>In our previous research, we have provided\na foundation for understanding, defining, classifying, and comparing ADLs\n[<a href=\"#Med97\">Med97</a>, <a href=\"#MT97\">MT97</a>]. In this paper, we build upon those results by identifying\nand characterizing <I>architectural domains</I>, the problems or areas\nof concern that need to be addressed by ADLs. Understanding these domains\nand their properties is a key to better understanding the needs of software\narchitectures, architecture-based development, and architectural description\nand interchange. A study of architectural domains is also needed to guide\nthe development of next-generation ADLs.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This paper presents a framework of\narchitectural domains. We demonstrate that each existing ADL currently\nsupports only a small subset of these domains, and we discuss possible\nreasons for that. Finally, we consider the relationship between architectural\ndomains and application domains.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>While we draw from previous ADL work\nand reference a number of ADLs, the most significant contribution of this\npaper is the framework of architectural domains. It provides structure\nto a field that has been approached largely in an ad-hoc fashion thus far.\nThe framework gives the architect a sound foundation for selecting an ADL\nand orients discourse away from arguments about notation and more towards\nsolving important engineering problems.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The remainder of the paper is organized\nas follows. <a href=\"#2\">Section 2</a> provides a short discussion of ADLs. \n<a href=\"#3\">Section 3</a> presents\nand motivates each architectural domain, while <a href=\"#4\">Section 4</a> discusses the\nsupport for architectural domains in existing ADLs. <a href=\"#5\">Section 5</a> expounds\non the relationship between application domains and architectural domains.\nDiscussion and conclusions round out the paper.</FONT></FONT>\n\n<P><a name=\"2\"><B><FONT FACE=\"Variable Width\">2. Overview of ADLs</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>To properly enable further discussion,\nseveral definitions are needed. In this section, we define software architectures,\narchitectural styles, and ADLs.<a name = \"foot1-txt\"><a href=\"#foot1\"><FONT SIZE=-1>[Footnote 1]</FONT></a> We categorize ADLs, differentiate them\n\nfrom other, similar notations, and discuss examples of use of ADLs in actual\nprojects. Finally, we provide a short discussion on our use of the terms\n\"architecture\" and \"design.\"</FONT></FONT>\n\n<P><a name=\"2.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.1. Definitions of Architecture and Style</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There is no standard definition of architecture,\nbut we will use as our working definition the one provided by Garlan and\nShaw [<a href=\"#GS93\">GS93</a>]:</FONT></FONT>\n<DIR><FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>[</I>Software architecture <I>is\na level of design that] goes beyond the algorithms and data structures\nof the computation: designing and specifying the overall system structure\nemerges as a new kind of problem. Structural issues include gross organization\nand global control structure; protocols for communication, synchronization,\nand data access; assignment of functionality to design elements; physical\ndistribution; composition of design elements; scaling and performance;\nand selection among design alternatives.</I></FONT></FONT></DIR>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>Architectural style </I>is \"a set of\ndesign rules that identify the kinds of components and connectors that\nmay be used to compose a system or subsystem, together with local or global\nconstraints on the way the composition is done\" [<a href=\"#SC96\">SC96</a>].</FONT></FONT>\n\n<P><a name=\"2.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.2. Definition of ADLs</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Loosely defined, \"an <I>ADL </I>for software\napplications focuses on the high-level structure of the overall application\nrather than the implementation details of any specific source module\" \n[<a href=\"#Ves93\">Ves93</a>].\nADLs provide both a concrete syntax and a conceptual framework for modeling\na software system's <I>conceptual </I>architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The building blocks of an architectural\ndescription are</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>components </I>- units of computation\nor data stores;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>connectors </I>- architectural building\nblocks used to model interactions among components and rules that govern\nthose interactions; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>architectural configurations </I>-\nconnected graphs of components and connectors that describe architectural\nstructure.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>An ADL must provide the means for their\n<I>explicit </I>specification; this criterion enables one to determine\nwhether or not a particular notation is an ADL. In order to infer any kind\nof information about an architecture, at a minimum, <I>interfaces </I>of\nconstituent components must also be modeled formally. Without this information,\nan architectural description becomes but a collection of (interconnected)\nidentifiers.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>An ADL's conceptual framework typically\nsubsumes a formal semantic theory. That theory is part of the ADL's underlying\nframework for characterizing architectures; it influences the ADL's suitability\nfor modeling particular kinds of systems (e.g., highly concurrent systems)\nor particular aspects of a given system (e.g., its static properties).\nExamples of formal specification theories are \nPetri nets [<a href=\"#Pet62\">Pet62</a>], \nStatecharts [<a href=\"#Har87\">Har87</a>], \npartially-ordered event sets [<a href=\"#LVB+93\">LVB+93</a>], \ncommunicating sequential processes (CSP) [<a href=\"#Hoa85\">Hoa85</a>], \nmodel-based formalisms (e.g., \nCHemical Abstract Machine [<a href=\"#IW95\">IW95</a>], \nZ [<a href=\"#Spi89\">Spi89</a>]), \nalgebraic formalisms (e.g., Obj [<a href=\"#GW88\">GW88</a>]), and\naxiomatic formalisms (e.g., Anna [<a href=\"#Luc87\">Luc87</a>]).</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Finally, even though the suitability\nof a given language for modeling architectures is independent of whether\nand what kinds of <I>tool support </I>it provides, an accompanying toolset\nwill render an ADL both more usable and useful. Furthermore, capabilities\nprovided by such a toolset are often a direct reflection of the ADL's intended\nuse.</FONT></FONT>\n\n<P><a name=\"2.3\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.3. Categorizing ADLs</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Existing languages that are commonly referred\nto as ADLs can be grouped into three categories, based on how they model\nconfigurations:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>implicit configuration languages </I>model\nconfigurations implicitly through interconnection information that is distributed\nacross definitions of individual components and connectors;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>in-line configuration languages </I>model\nconfigurations explicitly, but specify connector information only as part\nof the configuration, \"in line\";</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>explicit configuration languages </I>model\nboth components and connectors separately from configurations.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>The first category, implicit configuration\nlanguages, are, by definition given in this paper, not ADLs, although they\nmay serve as useful tools in modeling certain aspects of architectures.\nAn example of an implicit configuration language is \nArTek [<a href=\"#TLPD95\">TLPD95</a>]. In\nArTek, there is no configuration specification; instead, each connector\nspecifies component ports to which it is attached.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The focus on conceptual architecture\nand explicit treatment of connectors as first-class entities differentiate\nADLs from module interconnection languages (MILs) \n[<a href=\"#DK76\">DK76</a>, <a href=\"#PN86\">PN86</a>], programming\nlanguages, and object-oriented notations and languages (e.g., Unified Method\n[<a href=\"#BR95\">BR95</a>]). MILs typically describe the uses relationships among modules in\nan <I>implemented </I>system and support only one type of connection \n[<a href=\"#AG94a\">AG94a</a>, <a href=\"#SG94\">SG94</a>]. \nProgramming languages describe a system's implementation, whose\narchitecture is typically implicit in subprogram definitions and calls.\nExplicit treatment of connectors also distinguishes ADLs from OO languages,\nas demonstrated in [<a href=\"#LVM95\">LVM95</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>It is important to note, however, that\nthere is less than a firm boundary between ADLs and MILs. Certain ADLs,\ne.g., Wright and Rapide, model components and connectors at a high level\nof abstraction and do not assume or prescribe a particular relationship\nbetween an architectural description and an implementation. We refer to\nthese languages as being <I>implementation independent</I>. On the other\nhand, several ADLs, e.g., UniCon and MetaH, enforce a high degree of fidelity\nof an implementation to its architecture. Components modeled in these languages\nare directly related to their implementations, so that a module interconnection\nspecification may be indistinguishable from an architectural description\nin such a language. These are <I>implementation constraining </I>languages.</FONT></FONT>\n\n<P><a name=\"2.4\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.4. Applications of ADLs</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs are special purpose notations whose\nvery specific foci render them suitable for powerful analyses, simulation,\nand automated code generation. However, they have yet to find their place\nin mainstream software development. Although current research is under\nway to bridge the gap that separates ADLs from more widely used design\nnotations [<a href=\"#RMRR97\">RMRR97</a>], only a small number of existing ADLs have been applied\nto large-scale, \"real-world\" examples to date. What these examples do demonstrate\nis the potential for effective use of ADLs in software projects.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Wright was used to model and analyze\nthe <I>Runtime Infrastructure </I>(RTI) of the Department of Defense (DoD)\n<I>High-Level Architecture for Simulations </I>(HLA) \n[<a href=\"#All96\">All96</a>]. The original\nspecification for RTI was over 100 pages long. Wright was able to substantially\ncondense the specification and reveal several inconsistencies and weaknesses\nin it.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>SADL was applied to an operational\npower-control system, used by the Tokyo Electric Power Company. The system\nwas implemented in 200,000 lines of Fortran 77 code. SADL was used to formalize\nthe system's reference architecture and ensure its consistency with the\nimplementation architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Finally, Rapide has been used in several\nlarge-scale projects thus far. A representative example is the X/Open Distributed\nTransaction Processing (DTP) Industry Standard. The documentation for the\nstandard is over 400 pages long. Its reference architecture and subsequent\nextensions have been successfully specified and simulated in \nRapide [<a href=\"#LKA+95\">LKA+95</a>].</FONT></FONT>\n\n<P><a name=\"2.5\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>2.5. Architecture vs. Design</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Given the above definition of software\narchitectures and ADLs, an issue worth addressing is the relationship between\narchitecture and design. Current literature leaves this question largely\nunanswered, allowing for several interpretations:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>architecture and design are the same;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>architecture is at a level of abstraction\nabove design, so it is simply another step (artifact) in a software development\nprocess; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>architecture is something new and is somehow\ndifferent from design (but just how remains unspecified).</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>All three interpretations are partially\ncorrect. To a large extent, architectures serve the same purpose as design.\nHowever, their explicit focus on connectors and configurations distinguishes\nthem from traditional software design. At the same time, as a (high level)\narchitecture is refined, connectors lose prominence by becoming distributed\nacross the (lower level) architecture's elements. Such a lower level architecture\nmay indeed be considered to be a design. Keeping this relationship in mind,\nfor reasons of simplicity we will simply refer to architectures as \"high\nlevel,\" \"low level,\" and so forth, in the remainder of the paper, while\n\"design\" will only refer to the process that results in an architecture.</FONT></FONT>\n\n<P><a name=\"3\"><B><FONT FACE=\"Variable Width\">3. Architectural Domains</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs typically share syntactic constructs\nthat enable them to model components and component interfaces, connectors,\nand configurations.<a name = \"foot2-txt\"><a href=\"#foot2\"><FONT SIZE=-1>[Footnote 2]</FONT></a> A much greater source of divergence are the different\nADLs' conceptual frameworks, and, consequently, their support for modeling\narchitectural semantics. ADL developers typically have decided to focus\non a specific aspect of architectures, or an <I>architectural domain</I>,\nwhich guides their selection of an underlying semantic model and a set\nof related formal specification notations. These formal notations, in turn,\nrestrict the types of problems for which the ADL is suitable.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This relationship between an architectural\ndomain and candidate formal notations is rarely straightforward or fully\nunderstood. In the absence of objective criteria, ADL researchers are forced\nto base their decisions on intuition, experience, and biases arising from\npast research accomplishments. Unfortunately, intuition can often be misleading\nand experience insufficient in a young discipline such as software architectures.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>In this paper, we attempt to fill this\nvoid. The remainder of this section motivates and formulates a framework\nfor classifying the problems on which architectural models focus (architectural\ndomains), shown in <a href=\"#Fig.1\">Figure 1</a>. Architectural domains represent broad classes\nof problems and are likely to be reflected in many ADLs and their associated\nformal specification language constructs. Their proper understanding is\nthus necessary. Furthermore, heuristics may be developed over time that\nwill enable easier interchange of architectures modeled in ADLs that focus\non particular architectural domains. Finally, such a framework can be used\nas a guide in developing future ADLs.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&nbsp;</FONT></FONT>\n\n<P>\n<a name=\"Fig.1\"><img src=fig1.jpg border=2>\n<P><FONT SIZE=+0><FONT FACE=\"Variable Width\"><B>Figure 1: </B></FONT>Architectural domains.</FONT><FONT SIZE=+0></FONT>\n\n<P><a name=\"3.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.1. Representation</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>A key role of an explicit representation\nof an architecture is to aid understanding and communication about a software\nsystem among different stakeholders. For this reason, it is important that\narchitectural descriptions be simple, understandable, and possibly graphical,\nwith well understood, but not necessarily formally defined, semantics.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Architectural models typically comprise\nmultiple views, e.g., high level graphical view, lower level view with\nformal specifications of components and connectors, conceptual architecture,\none or more implementation architectures, corresponding development process,\ndata or control flow view, and so on. Different stakeholders (e.g., architects,\ndevelopers, managers, customers) may require different views of the architecture.\nThe customers may be satisfied with a high-level, \"boxes and arrows\" description,\nthe developers may want detailed component and connector models, while\nthe managers may require a view of the development process.</FONT></FONT>\n\n<P><a name=\"3.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.2. Design Process Support</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Software architects decompose large, distributed,\nheterogeneous systems into smaller building blocks. In doing so, they have\nto consider many issues, make many decisions, and utilize many design techniques,\nmethodologies, and tools.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Modeling architectures from multiple\nperspectives, discussed in the previous subsection, is only one way of\nsupporting software architects' cognitive processes. Others include delivering\ndesign guidance in a timely and understandable fashion, capturing design\nrationale, and revisiting past design steps.</FONT></FONT>\n\n<P><a name=\"3.3\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.3. Analysis</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Architectures are often intended to model\nlarge, distributed, concurrent systems. The ability to evaluate the properties\nof such systems upstream, at the architectural level, can substantially\nlessen the number of errors passed downstream. Given that unnecessary details\nare abstracted away in architectures, the analysis task may also be easier\nto perform than at source code level.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Analysis of architectures may be performed\nstatically, before execution, or dynamically, at runtime. Certain types\nof analysis can be performed both statically and dynamically.</FONT></FONT>\n\n<P><a name=\"3.3.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.3.1. Static Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Examples of static analysis are internal\nconsistency checks, such as whether appropriate components are connected\nand their interfaces match, whether connectors enable desired communication,\nwhether constraints are satisfied, and whether the combined semantics of\ncomponents and connectors result in desired system behavior. Certain concurrent\nand distributed aspects of an architecture can also be assessed statically,\nsuch as the potential for deadlocks and starvation, performance, reliability,\nsecurity, and so on. Finally, architectures can be statically analyzed\nfor adherence to design heuristics and style rules.</FONT></FONT>\n\n<P><a name=\"3.3.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.3.2. Dynamic Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Examples of dynamic analysis are testing,\ndebugging, assertion checking, and assessment of the performance, reliability,\nand schedulability of an executing architecture. Saying that an architecture\nis executing can mean two different things:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>the system built based on the architecture\nis executing, or</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>the runtime behavior of the architecture\nitself is being simulated.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Clearly, certain analyses, such as performance\nor reliability, are more meaningful or even only possible in the former\ncase. However, an implementation of the system may not yet exist. Furthermore,\nit may be substantially less expensive to perform dynamic analyses in the\nlatter case, particularly when the relationship between the architecture\nand the implemented system is well understood.</FONT></FONT>\n\n<P><a name=\"3.4\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.4. Evolution</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Support for software evolution is a key\naspect of architecture-based development. Architectures evolve to reflect\nevolution of a single software system; they also evolve into families of\nrelated systems. As design elements, individual components and connectors\nwithin an architecture may also evolve.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Evolution of components, connectors,\nand architectures can occur at specification time or execution time.</FONT></FONT>\n\n<P><a name=\"3.4.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.4.1. Specification-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>If we consider components and connectors\nto be types which are instantiated every time they are used in an architecture,\ntheir evolution can be viewed simply in terms of subtyping. Since components\nand connectors are modeled at a high level of abstraction, flexible subtyping\nmethods may be employed. For example, it may be useful to evolve a single\ncomponent in multiple ways, by using different subtyping mechanisms (e.g.,\ninterface, behavior, or a combination of the two) \n[<a href=\"#MORT96\">MORT96</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>At the level of architectures, evolution\nis focused on incremental development and support for system families.\nIncrementality of an architecture can further be viewed from two different\nperspectives. One is its ability to accommodate addition of new components\nand the resulting issues of scale; the other is specification of incomplete\narchitectures.</FONT></FONT>\n\n<P><a name=\"3.4.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.4.2. Execution-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Explicit modeling of architectures\nis intended to support development and evolution of large and potentially\nlong-running systems. Being able to evolve such systems during execution\nmay thus be desirable and, in some cases, necessary. Architectures exhibit\ndynamism by allowing replication, insertion, removal, and reconnection\nof architectural elements or subarchitectures during execution.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Dynamic changes of an architecture\nmay be either planned at architecture specification time or unplanned.\nBoth types of dynamic change must be constrained to ensure that no desired\narchitectural properties are violated.</FONT></FONT>\n\n<P><a name=\"3.5\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.5. Refinement</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>The most common argument for creating\nand using formal architectural models is that they are necessary to bridge\nthe gap between informal, \"boxes and arrows\" diagrams and programming languages,\nwhich are deemed too low-level for designing a system. Architectural models\nmay need to be specified at several levels of abstraction for different\npurposes. For example, a high level specification of the architecture can\nbe used as an understanding and communication tool; a subsequent lower\nlevel may be analyzed for consistency of interconnections; an even lower\nlevel may be used in a simulation. Therefore, correct and consistent refinement\nof architectures to subsequently lower levels of abstraction is imperative.\nNote that, in this sense, code generation is simply a special case of architectural\nrefinement.</FONT></FONT>\n\n<P><a name=\"3.6\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.6. Traceability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>As discussed above, a software architecture\noften consists of multiple views and may be modeled at multiple levels\nof abstraction (<a href=\"#Fig.2\">Figure 2</a>). We call a particular view of the architecture\nat a given level of abstraction (i.e., a single point in the two-dimensional\nspace of <a href=\"#Fig.2\">Figure 2</a>) an \"architectural cross-section.\" It is critical for\nchanges in one cross-section to be correctly reflected in others. A particular\narchitectural cross-section can be considered \"dominant,\" so that <I>all\n</I>changes to the architecture are made to it and then reflected in others.\nHowever, changes will more frequently be made to the most appropriate or\nconvenient cross-section. Traceability support will hence need to exist\nacross all pertinent cross-sections.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>One final issue is the consistency\nof an architecture with system requirements. Changes to the requirements\nmust be appropriately reflected in the architecture; changes to the architecture\nmust be validated against the requirements. Therefore, even though system\nrequirements are in the problem domain, while architecture is in the solution\ndomain, traceability between the two is crucial. For purposes of traceability,\nrequirements can be considered to be at a very high level of architectural\nabstraction, as shown in <a href=\"#Fig.2\">Figure 2</a>.</FONT></FONT>\n\n<P><FONT FACE=\"Courier\"><FONT SIZE=-1>&nbsp;</FONT></FONT>\n\n<P>\n<a name=\"Fig.2\"><img src=fig2.jpg border=2>\n<P><FONT SIZE=+0><FONT FACE=\"Variable Width\"><B>Figure 2: </B></FONT>Two-dimensional\nspace of architectural views and levels of abstraction. The vertical axis\nis a set of discrete values with a nominal ordering. The horizontal axis\nis a continuum with an ordinal ordering of values, where system requirements\nare considered to be the highest level of abstraction and source code the\nlowest. One possible dominant cross-section (graphical view of the high\nlevel architecture) is shown.</FONT><FONT SIZE=+0></FONT>\n\n<P><a name=\"3.7\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>3.7. Simulation/Executability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Static architectural models are useful\nfor establishing static properties of the modeled system. Certain dynamic\nproperties may also be predicted with static models, but only if specific\nassumptions hold. For example, if the architect can correctly predict execution\ntime and criticality of each component, then schedulability of the encompassing\narchitecture can be evaluated.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>On the other hand, other dynamic properties,\nsuch as reliability, may by definition require a running system. Also,\ndevelopers may want to produce an early prototype to, e.g., attempt allocation\nof architectural elements to components of the physical system. Other stakeholders\n(e.g., customers or managers) may want to verify early on that the architecture\nconforms to their wishes. Simulating the dynamic behavior of a high level\narchitecture may thus be preferred to implementing the system: it is a\nquicker, cheaper, and more flexible way of arriving at the desired information.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>A special case of architectural simulation\nis the execution of the complete implemented system. The ultimate goal\nof any software design and modeling endeavor is to produce such a system.\nAn elegant and effective architectural model is of limited value, unless\nit can be converted into a running application. A simulation can only partially\ndepict the final system's dynamic behavior. Manually transforming an architecture\ninto a running system may result in many, already discussed problems of\nconsistency and traceability between the architecture and its implementation.\nTechniques, such as refinement and traceability discussed above, must be\nemployed to properly accomplish this task.</FONT></FONT>\n\n<P><a name=\"4\"><B><FONT FACE=\"Variable Width\">4. ADL Support for Architectural Domains</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>In the previous section, we motivated\nand described different architectural domains in terms of their characteristics\nand needs of software architectures. Another way of viewing architectural\ndomains is in terms of modeling languages and specific language features\nneeded to support different domains. At the same time, a useful way of\nunderstanding and classifying architecture modeling languages is in terms\nof architectural domains they are intended to support. For these reasons,\nthis section studies the kinds of language facilities that are needed to\nsupport each architectural domain, as well as the specific features existing\nADLs employ to that end. Our hope is that this discussion will shed light\non the relationships among different architectural domains (and their resulting\nADL features) and point out both where they can be effectively combined\nand where we can expect difficulties.</FONT></FONT>\n\n<P><a name=\"4.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.1. Representation</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Ideally, an ADL should make the structure\nof a system clear from a configuration specification alone, i.e., without\nhaving to study component and connector specifications. Architecture descriptions\nin <I>in-line configuration ADLs</I>, such as Darwin, MetaH, and Rapide\ntend to be encumbered with connector details, while <I>explicit configuration\nADLs</I>, such as ACME, Aesop, C2, SADL, UniCon, and Wright have the best\npotential to facilitate understandability of architectural structure.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>One common way of facilitating understandability\nand communication is by providing a graphical notation, in addition to\nthe textual notation. However, this is only the case if there is a precise\nrelationship between a graphical description and the underlying semantic\nmodel. For example, Aesop, C2, Darwin, MetaH, Rapide, and UniCon support\nsuch \"semantically sound\" graphical notations, while ACME, SADL, and Wright\ndo not.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs must also be able to model the\narchitecture from multiple perspectives. As discussed above, several ADLs\nsupport at least two views of an architecture: textual and graphical. Each\nof these ADLs also allows both top-level and detailed views of composite\nelements. Aesop, MetaH, and UniCon further distinguish different types\nof components and connectors iconically.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Support for other views is sparse.\nC2 provides a view of the development process that corresponds to the architecture\n[<a href=\"#RR96\">RR96</a>]. Darwin's <I>Software Architect's Assistant</I>\n[<a href=\"#NKM96\">NKM96</a>] provides\na hierarchical view of the architecture which shows all the component types\nand the \"include\" relationships among them in a tree structure. Rapide\nallows visualization of an architecture's execution behavior by building\nits simulation and animating its execution. Rapide also provides a tool\nfor viewing and filtering events generated by the simulation.</FONT></FONT>\n\n<P><a name=\"4.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.2. Design Process Support</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>As the above examples of C2's, Darwin's,\nand Rapide's support tools indicate, language features can only go so far\nin supporting software architects. Adequate tools are also needed. A category\nof tools that is critical for adequately supporting the design process\nare <I>active specification tools</I>; they can significantly reduce the\ncognitive load on architects.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Only a handful of existing ADLs provide\ntools that actively support specification of architectures. In general,\nsuch tools can be proactive or reactive. UniCon's graphical editor is proactive.\nIt invokes UniCon's language processing facilities to <I>prevent </I>errors\nduring design. Reactive specification tools detect <I>existing </I>errors.\nThey may either only inform the architect of the error (<I>non-intrusive</I>)\nor also force the architect to correct it before moving on (<I>intrusive</I>).\nAn example of the former is C2's design environment, <I>Argo</I>, while\nMetaH's graphical editor is an example of the latter.</FONT></FONT>\n\n<P><a name=\"4.3\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.3. Analysis</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>The types of analyses for which an ADL\nis well suited depend on its underlying semantic model, and to a lesser\nextent, its specification features. The semantic model will largely influence\nwhether the ADL can be analyzed statically or dynamically, or both. For\nexample, Wright, which is based on communicating sequential processes (CSP)\n[<a href=\"#Hoa85\">Hoa85</a>], allows static deadlock analysis of individual connectors and components\nattached to them. On the other hand, Rapide architectures, which are modeled\nwith partially ordered event sets (posets) \n[<a href=\"#LVB+93\">LVB+93</a>], can be analyzed dynamically.</FONT></FONT>\n\n<P><a name=\"4.3.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.3.1. Static Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The most common type of static analysis\ntools are language parsers and compilers. Parsers analyze architectures\nfor syntactic correctness, while compilers establish semantic correctness.\nAll existing ADLs have parsers. Darwin, MetaH, Rapide, and UniCon also\nhave compilers, which enable these languages to generate executable systems\nfrom architectural descriptions. Wright does not have a compiler, but it\nuses FDR [<a href=\"#For92\">For92</a>], a model checker, to establish type conformance.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There are numerous other possible types\nof static analysis of architectures. Several examples are provided by current\nADLs. Aesop provides facilities for checking for type consistency, cycles,\nresource conflicts, and scheduling feasibility in its architectures. C2\nuses critics to establish adherence to style rules and design guidelines.\nMetaH and UniCon both currently support schedulability analysis by specifying\nnon-functional properties, such as criticality and priority. Finally, given\ntwo architectures, SADL can establish their relative correctness with respect\nto a refinement map.</FONT></FONT>\n\n<P><a name=\"4.3.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.3.2. Dynamic Analysis</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The ability to analyze an architecture\ndynamically directly depends on the ADL's ability to model its dynamic\nbehavior. To this end, ADLs can employ specification mechanisms, such as\nevent posets, CHAM, or temporal logic, which can express dynamic properties\nof a system. Another aspect of dynamic analysis is enforcement of constraints\nat runtime.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Most existing ADLs tend to view architectures\nstatically, so that current support for dynamic modeling and analysis is\nscarce. Darwin enables dynamic analysis of architectures by instantiating\nparameters and components to enact \"what if\" scenarios. Similarly, Rapide\n<I>Poset Browser</I>'s event filtering features and <I>Animation Tools\n</I>facilitate analysis of architectures through simulation. Rapide's <I>Constraint\nChecker </I>also analyzes the conformance of a Rapide simulation to the\nformal constraints defined in the architecture. Finally, runtime systems\nof those ADLs that provide architecture compilation support can be viewed\nas dynamic analysis facilities.</FONT></FONT>\n\n<P><a name=\"4.4\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.4. Evolution</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>An architecture can evolve in two different\ndimensions:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>evolution of individual components and\nconnectors, where the structure of the architecture is not affected, although\nits behavior may be; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>evolution of the entire architecture,\nwhich affects both the structure and behavior of an architecture.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Evolution in these two dimensions can\noccur both at architecture specification time and while the architecture\nis executing.<a name=\"foot3-txt\"><a href=\"#foot3\"><FONT SIZE=-1>[Footnote 3]</FONT></a></FONT></FONT>\n\n<P><a name=\"4.4.1\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.4.1. Specification-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs can support specification-time\nevolution of individual components and connectors with subtyping. Only\na subset of existing ADLs provide such facilities, and even their evolution\nsupport is limited and often relies on the chosen implementation (programming)\nlanguage. The remainder of the ADLs view and model components and connectors\nas inherently static.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Aesop supports behavior-preserving\nsubtyping of components and connectors to create substyles of a given architectural\nstyle. Rapide allows its interface types to inherit from other types by\nusing OO methods, resulting in structural subtyping. ACME also supports\nstructural subtyping via its <I>extends </I>feature. C2 provides a more\nsophisticated subtyping and type checking mechanism. Multiple subtyping\nrelationships among components are allowed: name, interface, behavior,\nand implementation subtyping, as well as their combinations \n[<a href=\"#MORT96\">MORT96</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Specification-time evolution of complete\narchitectures has two facets: support for incremental development and support\nfor system families. Incrementality of an architecture can be viewed from\ntwo different perspectives. One is its ability to accommodate addition\nof new components to the architecture. In general, <I>explicit configuration\nADLs </I>can support incremental development more easily and effectively\nthan <I>in-line configuration ADLs</I>; ADLs that allow variable numbers\nof components to communicate through a connector are well suited for incremental\ndevelopment, particularly when faced with unplanned architectural changes\n[<a href=\"#Med97\">Med97</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Another view of incrementality is an\nADL's support for incomplete architectural descriptions. Incomplete architectures\nare common during design, as some decisions are deferred and others have\nnot yet become relevant. However, most existing ADLs and their supporting\ntoolsets have been built to prevent precisely these kinds of situations.\nFor example, Darwin, MetaH, Rapide, and UniCon compilers, constraint checkers,\nand runtime systems have been constructed to raise exceptions if such situations\narise. In this case, an ADL, such as Wright, which focuses its analyses\non information local to a single connector is better suited to accommodate\nexpansion of the architecture than, e.g., SADL, which is very rigorous\nin its refinement of <I>entire </I>architectures.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Still another aspect of static evolution\nis support for application families. In [<a href=\"#MT96\">MT96</a>], we showed that the number\nof possible architectures in a component-based style grows exponentially\nas a result of a linear expansion of a collection of components. All such\narchitectures may not belong to the same logical family. Therefore, relying\non component and connector inheritance, subtyping, or other evolution mechanisms\nis insufficient. An obvious solution, currently adopted only by ACME, is\nto provide a language construct that allows the architect to specify the\nfamily to which the given architecture belongs.</FONT></FONT>\n\n<P><a name=\"4.4.2\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.4.2. Execution-Time Evolution</FONT></FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>There are presently two approaches\nto supporting evolution of architectures at execution time. The first is\nwhat Oreizy calls \"constrained dynamism\": all runtime changes to the architecture\nmust be known a priori and are specified as part of the architectural model\n[<a href=\"#Ore96\">Ore96</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Two existing ADLs support constrained\ndynamism. Rapide supports conditional configuration; its <I>where </I>clause\nenables a form of architectural rewiring at runtime, using the <I>link\n</I>and <I>unlink </I>operators. Darwin allows runtime replication of components\nusing the <I>dyn </I>operator.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The second approach to execution time\nevolution places no restrictions at architecture specification time on\nthe kinds of allowed changes. Instead, the ADL has an architecture modification\nfeature, which allows the architect to specify changes while the architecture\nis running.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Darwin and C2 are the only ADLs that\nsupport such \"pure dynamism\" [<a href=\"#Ore96\">Ore96</a>]. Darwin allows deletion and rebinding\nof components by interpreting Darwin scripts. C2 specifies a set of operations\nfor insertion, removal, and rewiring of elements in an architecture at\nruntime [<a href=\"#Med96\">Med96</a>]. C2's <I>ArchShell </I>tool enables arbitrary interactive\nconstruction, execution, and runtime-modification of C2-style architectures\nby dynamically loading and linking new architectural elements \n[<a href=\"#Ore96\">Ore96</a>, <a href=\"#MOT97\">MOT97</a>].\nAn issue that needs further exploration is constraining pure dynamic evolution\nto ensure that the desired properties of architectures are maintained.</FONT></FONT>\n\n<P><a name=\"4.5\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.5. Refinement</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>ADLs provide architects with expressive\nand semantically elaborate facilities for specification of architectures.\nHowever, an ADL must also enable correct and consistent refinement of architectures\nto subsequently lower levels of abstraction, and, eventually, to executable\nsystems.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>An obvious way in which ADLs can support\nrefinement is by providing patterns, or maps, that, when applied to an\narchitecture, result in a related architecture at a lower level of abstraction.\nSADL and Rapide are the only two ADLs that provide such support. SADL uses\nmaps to enable correct architecture refinements across styles, while Rapide\ngenerates comparative simulations of architectures at different abstraction\nlevels. Both approaches have certain drawbacks, indicating that a hybrid\napproach may be useful.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Garlan has recently argued that refinement\nshould not be consistent with respect to a single (immutable) law, but\nrather with respect to particular properties of interest, be they conservative\nextension (SADL), computational behavior (Rapide), or something entirely\ndifferent, such as performance [<a href=\"#Gar96\">Gar96</a>]. This may be a good starting point\ntowards a successful marriage of the two approaches.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Several ADLs take a different approach\nto refinement: they enable generation of executable systems directly from\narchitectural specifications. These are typically the i<I>mplementation\nconstraining languages</I>, such as MetaH and UniCon. These ADLs assume\nthe existence of a source file that corresponds to a given architectural\nelement. This approach makes the assumption that the relationship between\nelements of an architectural description and those of the resulting system\nwill be 1-to-1. Given that architectures are intended to describe systems\nat a higher level of abstraction than source code modules, this can be\nconsidered only a limited form of refinement.</FONT></FONT>\n\n<P><a name=\"4.6\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.6. Traceability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>While the problem of refinement essentially\nfocuses only on one axis of <a href=\"#Fig.2\">Figure 2</a> (the horizontal axis) and one direction\n(left to right), traceability may need to cover a large portion of the\ntwo-dimensional space and is applicable in both directions. This presents\na much more difficult task, indicating why this is the architectural domain\nin which existing ADLs are most lacking.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The relationships among architectural\nviews (vertical axis) are not always well understood. For example, ADLs\ncommonly provide support for tracing changes between textual and graphical\nviews, such that changes in one view are automatically reflected in the\nother; however, it may be less clear how the data flow view should affect\nthe process view. In other cases, changes in one view (e.g., process) should\nnever affect another (e.g., control flow). An even bigger hurdle is providing\ntraceability support across <I>both </I>architectural views and levels\nof abstraction simultaneously. Finally, although much research has been\ndirected at methodologies for making the transition from requirements to\ndesign (e.g., OO), this process is still an art form. Further research\nis especially needed to understand the effects of changing requirements\non architectures and vice versa.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Traceability is particularly a problem\nin the way implementation constraining languages approach code generation,\ndiscussed in the previous subsection. These ADLs provide no means of guaranteeing\nthat the source modules which are supposed to implement architectural components\nwill do so correctly. Furthermore, even if the specified modules currently\nimplement the needed behavior correctly, there is no guarantee that any\nfuture changes to those modules will be traced back to the architecture\nand vice versa.</FONT></FONT>\n\n<P><a name=\"4.7\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.7. Simulation/Executability</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>As with dynamic analysis \n(<a href=\"#4.3.2\">Section 4.3.2</a>),\nsimulating an architecture will directly depend upon the ADL's ability\nto model its dynamic behavior. Currently, Rapide is the only ADL that can\nsimulate the architecture itself, by generating event posets. Other ADLs\nenable generation of running systems corresponding to the architecture.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>MetaH and UniCon require preexisting\ncomponent implementations in Ada and C, respectively, in order to generate\napplications. Darwin can also construct executable systems in the same\nmanner in C++, and Rapide in C, C++, Ada, VHDL, or its executable sublanguage.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>C2 and Aesop provide class hierarchies\nfor their concepts and operations, such as components, connectors, and\ninterconnection and message passing protocols. These hierarchies form a\nbasis from which an implementation of an architecture may be produced.\nAesop's hierarchy has been implemented in C++, and C2's in C++, Java, and\nAda.</FONT></FONT>\n\n<P><a name=\"4.8\"><B><FONT FACE=\"Variable Width\"><FONT SIZE=+0>4.8. Summary</FONT></FONT></B>\n<P>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Existing ADLs span a broad spectrum in\nterms of the architectural domains they support. On the one hand, languages\nlike SADL and Wright have very specific, narrow foci. On the other, C2,\nRapide, and Darwin support a number of architectural domains. Certain domains,\ne.g., evolution, refinement, and traceability are only sparsely supported,\nindicating areas around which future work should be centered. A more complete\nsummary of this section is given in <a href=\"#Table1\">Table 1</a> below.</FONT></FONT>\n<P>\n<CENTER><TABLE BORDER CELLPADDING=2 WIDTH=\"625\" >\n<TR>\n<TD VALIGN=TOP COLSPAN=\"10\"> <a name=\"Table1\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Table 1: ADL Support for Architectural\nDomains</FONT></FONT></B></CENTER>\n</TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER>&nbsp;<B><FONT SIZE=-1>ARCH.</FONT></B></CENTER>\n\n<CENTER><B><U><FONT SIZE=-1>DOMAIN</FONT></U></B></CENTER>\n\n<CENTER><B><FONT SIZE=-1>ADL</FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Represent.</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Design</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Process</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Support</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Static</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Analysis</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Dynamic</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Analysis</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Spec-Time</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Evolution</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Exec-Time</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Evolution</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Refinement</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Trace.</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Simulation/</FONT></FONT></B></CENTER>\n\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Executability</FONT></FONT></B></CENTER>\n</TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>ACME</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\n\"weblets\"</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>application\nfamilies</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>rep-maps across\nlevels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Aesop</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\ngraphical notation; types distinguished iconically</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>syntax directed\neditor; specialized editors for visualization classes</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; style-specific\ncompiler; type, cycle, resource conflict, and scheduling feasibility checker</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>behavior-preserving\nsubtyping of components and connectors</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1><I>build </I>tool\nconstructs system glue code in C for pipe-and-filter style</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>C2</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\ngraphical notation; process view; simulation; event filtering</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>non-intrusive,\nreactive design critics and to-do lists in Argo</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; critics\nto establish adherence to style rules and design heuristics</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>event filtering</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>multiple subtyping\nmechanisms; allows partial architectures</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>pure dynamism:\nelement insertion, removal, and rewiring</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>class framework\nenables generation of C/C++, Ada, and Java code</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Darwin</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>implicit config.;\ngraphical notation; hierarchical system view</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>automated addition\nof ports; propagation of changes across bound ports; property dialogs</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>\"what if\" scenarios\nby instantiating parameters and dynamic components</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>constrained\ndynamism: runtime replication of components and conditional configuration</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>compiler generates\nC++ code</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>MetaH</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>implicit config.;\ngraphical notation; types distinguished iconically</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>intrusive,\nreactive graphical editor</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler;\nschedulability, reliability, and security analysis</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>compiler generates\nAda code (C code generation planned)</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Rapide</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>implicit config.;\ngraphical notation; animated simulation; event filtering</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler;\nconstraint checker to ensure valid mappings</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>event filtering\nand animation</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>inheritance\n(structural subtyping)</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>constrained\ndynamism: conditional configuration and dynamic event generation</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>refinement\nmaps enable comparative simulations of architectures at different levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical;</FONT></FONT></CENTER>\n\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=-1>constraint checking across refinement</FONT></FONT>&nbsp;\n<BR><FONT FACE=\"Variable Width\"><FONT SIZE=-1>levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>simulation\nby generating event posets; system construction in C/C++, Ada, VHDL, and\nRapide</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>SADL</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; relative\ncorrectness of architectures w.r.t. a refinement map</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>component and\nconnector refinement via pattern maps</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>maps enable\ncorrect refinements across levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>refinement</FONT></FONT>&nbsp;\n<BR><FONT FACE=\"Variable Width\"><FONT SIZE=-1>across levels</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>UniCon</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.;\ngraphical notation</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>proactive GUI\neditor invokes language checker</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; compiler;\nschedulability analysis</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\">\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>textual</FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>\n\n<CENTER><FONT FACE=\"Variable Width\"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>compiler generates\nC code</FONT></FONT></TD>\n</TR>\n\n<TR>\n<TD VALIGN=TOP WIDTH=\"7%\">\n<CENTER><B><FONT FACE=\"Variable Width\"><FONT SIZE=-1>Wright</FONT></FONT></B></CENTER>\n</TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>explicit config.</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"11%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>parser; model\nchecker for type conformance; deadlock analysis of connectors</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"9%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>type conformance\nfor behaviorally related protocols</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"10%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"8%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n\n<TD VALIGN=TOP WIDTH=\"12%\"><FONT FACE=\"Variable Width\"><FONT SIZE=-1>none</FONT></FONT></TD>\n</TR>\n</TABLE></CENTER>\n\n<P><a name=\"5\"><B><FONT FACE=\"Variable Width\">5. Architectural vs. Application Domains</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Over the past decade there has been\ninterest in relating architectures, which are in the solution domain, to\nthe problem (or application) domain, leading to the notion of <I>domain-specific\nsoftware architectures (DSSAs) </I>[<a href=\"#Tra95\">Tra95</a>]. A DSSA provides a single (generic)\n<I>reference architecture</I>, which reflects the characteristics of a\nparticular problem domain, and which is instantiated for each specific\napplication in that domain. <I>Architectural styles</I>, discussed in \n<a href=\"#2\">Section 2</a>,\nprovide another way of relating the problem and solution spaces. Styles\nare largely orthogonal to DSSAs: a single style may be applicable to multiple\napplication domains; on the other hand, a single DSSA may use multiple\nstyles.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Any attempt to further explore and\nperhaps generalize the relationship between architectural and application\ndomains would be greatly aided by a classification of application domains.\nWe are unaware of any such classification, although Jackson identified\na number of <I>domain characteristics </I>that could serve as a starting\npoint for one [<a href=\"#Jac95\">Jac95</a>]:</FONT></FONT>\n<UL>\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>static </I>vs. <I>dynamic </I>domains,\nwith the latter being application domains having an element of time, events,\nand/or state;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>one-dimensional </I>vs. <I>multi-dimensional\n</I>domains;</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>tangible </I>vs. <I>intangible </I>domains,\nwith the latter typically involving machine representations of abstractions\n(such as user interfaces);</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>inert </I>vs. <I>reactive </I>vs. <I>active\n</I>dynamic domains; and</FONT></FONT></LI>\n\n<LI>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0><I>autonomous </I>vs. <I>programmable\n</I>vs. <I>biddable </I>active dynamic domains.</FONT></FONT></LI>\n</UL>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>Given these application domain characteristics,\none can easily identify a number of useful relationships with architectural\ndomains. For instance, support for evolution, executability and dynamic\nanalysis are more important for dynamic domains than for static domains.\nAs another example, reactive domains are naturally supported by a style\nof representation (e.g., Statecharts [<a href=\"#Har87\">Har87</a>]) that is different from that\nin active domains (e.g., CHAM [<a href=\"#IW95\">IW95</a>]). As we deepen our understanding of\narchitectural domains, we will be able to solidify our understanding of\ntheir relationship with application domains.</FONT></FONT>\n\n<P><a name=\"6\"><B><FONT FACE=\"Variable Width\">6. Conclusions</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Software architecture research has\nbeen moving forward rapidly. A number of ADLs and their supporting toolsets\nhave been developed; many existing styles have been adopted and new ones\ninvented. Theoretical underpinnings for the study of software architectures\nhave also begun to emerge in the form of definitions \n[<a href=\"#PW92\">PW92</a>, <a href=\"#GS93\">GS93</a>] and formal\nclassifications of styles [<a href=\"#SC96\">SC96</a>] and \nADLs [<a href=\"#Med97\">Med97</a>, <a href=\"#MT97\">MT97</a>].</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This body of work reflects a wide spectrum\nof views on what architecture is, what aspects of it should be modeled\nand how, and what its relationship is to other software development concepts\nand artifacts. This divergence of views has also resulted in a divergence\nof ADLs' conceptual frameworks (as defined in <a href=\"#2\">Section 2</a>). Such fragmentation\nhas made it difficult to establish whether there exists in ADLs a notion\nsimilar to computational equivalence in programming languages. Furthermore,\nsharing support tools has been difficult.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>ACME has attempted to provide a basis\nfor interchanging architectural descriptions across ADLs. However, ACME\nhas thus far been much more successful at achieving architectural interchange\nat the syntactic (i.e., structural) level, than at the semantic level.\nAlthough some of the ACME team's recent work looks encouraging, this still\nremains an open problem. One of the reasons ACME has encountered difficulties\nis precisely the fact that there is only limited agreement in the architecture\ncommunity on some fundamental issues, the most critical of which is what\nproblems architectures should attempt to solve.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This paper presents an important first\nstep towards a solution to this problem. We have recognized that the field\nof software architecture is concerned with several domains and that every\nADL reflects the properties of one or more domains from this set. Architectural\ndomains thus provide a unifying view to what had seemed like a disparate\ncollection of approaches, notations, techniques, and tools. The task of\narchitectural interchange can be greatly aided by studying the interrelationships\namong architectural domains. Existing ADLs can be better understood in\nthis new light and new ADLs more easily developed to solve a specific set\nof problems.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Much further work is still needed,\nhowever. Our current understanding of the relationship between architectural\ndomains and formal semantic theories (<a href=\"#2\">Section 2</a>) is limited. Also, we need\nto examine whether there exist techniques that can more effectively support\nthe needs of particular architectural domains than those provided by existing\nADLs. Finally, a more thorough understanding of the relationship between\narchitectural and application domains is crucial if architecture-based\ndevelopment is to fulfill its potential.</FONT></FONT>\n\n<P><a name=\"7\"><B><FONT FACE=\"Variable Width\">7. Acknowledgements</FONT></B>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>We would like to thank Richard Taylor,\nPeyman Oreizy, Jason Robbins, David Redmiles, and David Hilbert for their\nparticipation in numerous discussions of issues concerning ADLs. We also\nthank the DSL reviewers for their helpful reviews.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Effort partially sponsored by the Defense\nAdvanced Research Projects Agency, and Rome Laboratory, Air Force Materiel\nCommand, USAF, under agreement numbers F30602-94-C-0218 and F30602-97-2-0021.\nThe U.S. Government is authorized to reproduce and distribute reprints\nfor Governmental purposes notwithstanding any copyright annotation thereon.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>Approved for Public Release - Distribution\nUnlimited.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>The views and conclusions contained\nherein are those of the authors and should not be interpreted as necessarily\nrepresenting the official policies or endorsements, either expressed or\nimplied, of the Defense Advanced Research Projects Agency, Rome Laboratory\nor the U.S. Government.</FONT></FONT>\n\n<P><FONT FACE=\"Variable Width\"><FONT SIZE=+0>This material is also partially based\non work supported by the National Science Foundation under Grant No. CCR-9701973.</FONT></FONT>\n\n<P><a name=\"8\"><B><FONT FACE=\"Variable Width\">8. References</FONT></B>\n<P>\n<DL COMPACT>\n<FONT FACE=\"Variable Width\"><FONT SIZE=+0>\n\n<DT><a name=\"AG94a\">[AG94a] \n<DD>R. Allen and D. Garlan. Formal\nConnectors. Technical Report, CMU-CS-94-115, Carnegie Mellon University,\nMarch 1994.\n\n<DT><a name=\"AG94b\">[AG94b] \n<DD>R. Allen and D. Garlan. Formalizing\nArchitectural Connection. In <I>Proceedings of the Sixteenth International\nConference on Software Engineering</I>, pages 71-80, Sorrento, Italy, May\n1994.</FONT></FONT>\n\n<DT><a name=\"All96\">[All96] \n<DD>R. Allen. HLA: A Standards\nEffort as Architectural Style. In A. L. Wolf, ed., <I>Proceedings of the\nSecond International Software Architecture Workshop (ISAW-2)</I>, pages\n130-133, San Francisco, CA, October 1996.\n\n<DT><a name=\"BR95\">[BR95] \n<DD>G. Booch and J. Rumbaugh. <I>Unified\nMethod for Object-Oriented Development</I>. Rational Software Corporation,\n1995.\n\n<DT><a name=\"DK76\">[DK76] \n<DD>F. DeRemer and H. H. Kron. Programming-in-the-large\nversus Programming-in-the-small. <I>IEEE Transactions on Software Engineering</I>,\npages 80-86, June 1976.\n\n<DT><a name=\"For92\">[For92] \n<DD><I>Failures Divergence Refinement:\nUser Manual and Tutorial</I>. Formal Systems (Europe) Ltd., Oxford, England,\nOctober 1992.\n\n<DT><a name=\"GAO94\">[GAO94] \n<DD>D. Garlan, R. Allen, and J.\nOckerbloom. Exploiting Style in Architectural Design Environments. In <I>Proceedings\nof SIGSOFT'94: Foundations of Software Engineering</I>, pages 175-188,\nNew Orleans, Louisiana, USA, December 1994.\n\n<DT><a name=\"Gar95\">[Gar95] \n<DD>D. Garlan, editor. <I>Proceedings\nof the First International Workshop on Architectures for Software Systems</I>,\nSeattle, WA, April 1995.\n\n<DT><a name=\"Gar96\">[Gar96] \n<DD>D. Garlan. Style-Based Refinement\nfor Software Architecture. In A. L. Wolf, ed., <I>Proceedings of the Second\nInternational Software Architecture Workshop (ISAW-2)</I>, pages 72-75,\nSan Francisco, CA, October 1996.\n\n<DT><a name=\"GMW95\">[GMW95] \n<DD>D. Garlan, R. Monroe, and D.\nWile. ACME: An Architectural Interconnection Language. Technical Report,\nCMU-CS-95-219, Carnegie Mellon University, November 1995.\n\n<DT><a name=\"GMW97\">[GMW97] \n<DD>D. Garlan, R. Monroe, and D.\nWile. ACME: An Architecture Interchange Language. Submitted for publication,\nJanuary 1997.\n\n<DT><a name=\"GPT95\">[GPT95] \n<DD>D. Garlan, F. N. Paulisch,\nand W. F. Tichy, editors. <I>Summary of the Dagstuhl Workshop on Software\nArchitecture</I>, February 1995. Reprinted in ACM Software Engineering\nNotes, pages 63-83, July 1995.\n\n<DT><a name=\"GS93\">[GS93] \n<DD>D. Garlan and M. Shaw. <I>An\nIntroduction to Software Architecture: Advances in Software Engineering\nand Knowledge Engineering</I>, volume I. World Scientific Publishing, 1993.\n\n<DT><a name=\"GW88\">[GW88] \n<DD>J. A. Goguen and T. Winkler.\nIntroducing OBJ3. Technical Report SRI-CSL-88-99. SRI International, 1988.\n\n<DT><a name=\"Har87\">[Har87] \n<DD>D. Harel. Statecharts: A Visual\nFormalism for Complex Systems. <I>Science of Computer Programming</I>,\n1987.\n\n<DT><a name=\"Hoa85\">[Hoa85] \n<DD>C. A. R. Hoare. <I>Communicating\nSequential Processes</I>. Prentice Hall, 1985.\n\n<DT><a name=\"IW95\">[IW95] \n<DD>P. Inverardi and A. L. Wolf.\nFormal Specification and Analysis of Software Architectures Using the Chemical\nAbstract Machine Model. <I>IEEE Transactions on Software Engineering</I>,\npages 373-386, April 1995.\n\n<DT><a name=\"Jac95\">[Jac95]\n<DD>M. Jackson. <I>Software Requirements\nand Specifications: A Lexicon of Practice, Principles and Prejudices</I>.\nAddison-Wesley, 1995.\n\n<DT><a name=\"LKA+95\">[LKA+95] \n<DD>D. C. Luckham, J. J. Kenney,\nL. M. Augustin, J. Vera, D. Bryan, and W. Mann. Specification and Analysis\nof System Architecture Using Rapide. <I>IEEE Transactions on Software Engineering</I>,\npages 336-355, April 1995.\n\n<DT><a name=\"Luc87\">[Luc87] \n<DD>D. Luckham. <I>ANNA, a language\nfor annotating Ada programs: reference manual</I>, volume 260 of <I>Lecture\nNotes in Computer Science</I>. Springer-Verlag, Berlin, 1987.\n\n<DT><a name=\"LV95\">[LV95] \n<DD>D. C. Luckham and J. Vera. An Event-Based Architecture Definition Language. <I>IEEE Transactions on Software\nEngineering</I>, pages 717-734, September 1995.\n\n<DT><a name=\"LVB+93\">[LVB+93] \n<DD>D. C. Luckham, J. Vera, D.\nBryan, L. Augustin, and F. Belz. Partial Orderings of Event Sets and Their\nApplication to Prototyping Concurrent, Timed Systems. <I>Journal of Systems\nand Software</I>, pages 253-265, June 1993.\n\n<DT><a name=\"LVM95\">[LVM95] \n<DD>D. C. Luckham, J. Vera, and\nS. Meldal. Three Concepts of System Architecture. Unpublished Manuscript,\nJuly 1995.\n\n<DT><a name=\"Med96\">[Med96] \n<DD>N. Medvidovic. ADLs and Dynamic\nArchitecture Changes. In A. L. Wolf, ed., <I>Proceedings of the Second\nInternational Software Architecture Workshop (ISAW-2)</I>, pages 24-27,\nSan Francisco, CA, October 1996.\n\n<DT><a name=\"Med97\">[Med97] \n<DD>N. Medvidovic. A Classification\nand Comparison Framework for Software Architecture Description Languages.\nTechnical Report, UCI-ICS-97-02, University of California, Irvine, January\n1997.\n\n<DT><a name=\"MDEK95\">[MDEK95] \n<DD>J. Magee, N. Dulay, S. Eisenbach,\nand J. Kramer. Specifying Distributed Software Architectures. In <I>Proceedings\nof the Fifth European Software Engineering Conference (ESEC'95)</I>, Barcelona,\nSeptember 1995.\n\n<DT><a name=\"MK96\">[MK96] \n<DD>J. Magee and J. Kramer. Dynamic\nStructure in Software Architectures. In <I>Proceedings of ACM SIGSOFT'96:\nFourth Symposium on the Foundations of Software Engineering (FSE4)</I>,\npages 3-14, San Francisco, CA, October 1996.\n\n<DT><a name=\"MOT97\">[MOT97] \n<DD>N. Medvidovic, P. Oreizy, and\nR. N. Taylor. Reuse of Off-the-Shelf Components in C2-Style Architectures.\nIn <I>Proceedings of the 1997 Symposium on Software Reusability (SSR'97)</I>,\npages 190-198, Boston, MA, May 17-19, 1997. Also in <I>Proceedings of the\n1997 International Conference on Software Engineering (ICSE'97)</I>, pages\n692-700, Boston, MA, May 17-23, 1997.\n\n<DT><a name=\"MORT96\">[MORT96] \n<DD>N. Medvidovic, P. Oreizy,\nJ. E. Robbins, and R. N. Taylor. Using object-oriented typing to support\narchitectural design in the C2 style. In <I>Proceedings of ACM SIGSOFT'96:\nFourth Symposium on the Foundations of Software Engineering (FSE4)</I>,\npages 24-32, San Francisco, CA, October 1996.\n\n<DT><a name=\"MQR95\">[MQR95] \n<DD>M. Moriconi, X. Qian, and R.\nA. Riemenschneider. Correct Architecture Refinement. <I>IEEE Transactions\non Software Engineering</I>, pages 356-372, April 1995.\n\n<DT><a name=\"MT96\">[MT96] \n<DD>N. Medvidovic and R. N. Taylor.\nReusing Off-the-Shelf Components to Develop a Family of Applications in\nthe C2 Architectural Style. In <I>Proceedings of the International Workshop\non Development and Evolution of Software Architectures for Product Families</I>,\nLas Navas del Marqu&eacute;s, &Aacute;vila, Spain, November 1996.\n\n<DT><a name=\"MT97\">[MT97] \n<DD>N. Medvidovic and R. N. Taylor.\nA Framework for Classifying and Comparing Architecture Description Languages.\nTo appear in <I>Proceedings of the Sixth European Software Engineering\nConference together with Fifth ACM SIGSOFT Symposium on the Foundations\nof Software Engineering</I>, Zurich, Switzerland, September 22-25, 1997.\n\n<DT><a name=\"MTW96\">[MTW96] \n<DD>N. Medvidovic, R. N. Taylor,\nand E. J. Whitehead, Jr. Formal Modeling of Software Architectures at Multiple\nLevels of Abstraction. In <I>Proceedings of the California Software Symposium\n1996</I>, pages 28-40, Los Angeles, CA, April 1996.\n\n<DT><a name=\"NKM96\">[NKM96] \n<DD>K. Ng, J. Kramer, and J. Magee.\nA CASE Tool for Software Architecture Design. <I>Journal of Automated Software\nEngineering (JASE), Special Issue on CASE-95</I>, 1996.\n\n<DT><a name=\"Ore96\">[Ore96] \n<DD>P. Oreizy. Issues in the\nRuntime Modification of Software Architectures. Technical Report, UCI-ICS-96-35,\nUniversity of California, Irvine, August 1996.\n\n<DT><a name=\"Pet62\">[Pet62] \n<DD>C. A. Petri. Kommunikationen\nMit Automaten. PhD Thesis, University of Bonn, 1962. English translation:\nTechnical Report RADC-TR-65-377, Vol.1, Suppl 1, Applied Data Research,\nPrinceton, N.J.\n\n<DT><a name=\"PN86\">[PN86] \n<DD>R. Prieto-Diaz and J. M. Neighbors.\nModule Interconnection Languages. <I>Journal of Systems and Software</I>,\npages 307-334, October 1989.\n\n<DT><a name=\"PW92\">[PW92] \n<DD>D. E. Perry and A. L. Wolf.\nFoundations for the Study of Software Architectures. <I>ACM SIGSOFT Software\nEngineering Notes</I>, pages 40-52, October 1992.\n\n<DT><a name=\"RMRR97\">[RMRR97] \n<DD>J. E. Robbins, N. Medvidovic,\nD. F. Redmiles, and D. S. Rosenblum. Integrating Architecture Description\nLanguages with a Standard Design Method. Technical Report, UCI-ICS-97-35,\nUniversity of California, Irvine, August 1997.\n\n<DT><a name=\"RR96\">[RR96] \n<DD>J. E. Robbins and D. Redmiles.\nSoftware architecture design from the perspective of human cognitive needs.\nIn <I>Proceedings of the California Software Symposium (CSS'96)</I>, Los\nAngeles, CA, USA, April 1996.\n\n<DT><a name=\"SC96\">[SC96] \n<DD>M. Shaw and P. Clements. Toward\nBoxology: Preliminary Classification of Architectural Styles. In A. L.\nWolf, ed., <I>Proceedings of the Second International Software Architecture\nWorkshop (ISAW-2)</I>, pages 50-54, San Francisco, CA, October 1996.\n\n<DT><a name=\"SDK+95\">[SDK+95] \n<DD>M. Shaw, R. DeLine, D. V.\nKlein, T. L. Ross, D. M. Young, and G. Zelesnik. Abstractions for Software\nArchitecture and Tools to Support Them. <I>IEEE Transactions on Software\nEngineering</I>, pages 314-335, April 1995.\n\n<DT><a name=\"SG94\">[SG94] \n<DD>M. Shaw and D. Garlan. Characteristics\nof Higher-Level Languages for Software Architecture. Technical Report,\nCMU-CS-94-210, Carnegie Mellon University, December 1994.\n\n<DT><a name=\"Spi89\">[Spi89] \n<DD>J. M. Spivey. <I>The Z notation:\na reference manual</I>. Prentice Hall, New York, 1989.\n\n<DT><a name=\"TLPD95\">[TLPD95] \n<DD>A. Terry, R. London, G. Papanagopoulos,\nand M. Devito. The ARDEC/Teknowledge Architecture Description Language\n(ArTek), Version 4.0. Technical Report, Teknowledge Federal Systems, Inc.\nand U.S. Army Armament Research, Development, and Engineering Center, July\n1995.\n\n<DT><a name=\"Tra95\">[Tra95] \n<DD>W. Tracz. DSSA (Domain-Specific\nSoftware Architecture) Pedagogical Example. <I>ACM SIGSOFT Software Engineering\nNotes</I>, July 1995.\n\n<DT><a name=\"Ves93\">[Ves93] \n<DD>S. Vestal. A Cursory Overview\nand Comparison of Four Architecture Description Languages. Technical Report,\nHoneywell Technology Center, February 1993.\n\n<DT><a name=\"Ves96\">[Ves96] \n<DD>S. Vestal. MetaH Programmer's\nManual, Version 1.09. Technical Report, Honeywell Technology Center, April\n1996.\n\n<DT><a name=\"Wolf96\">[Wolf96] \n<DD>A. L. Wolf, editor. <I>Proceedings\nof the Second International Software Architecture Workshop (ISAW-2)</I>,\nSan Francisco, CA, October 1996.\n\n</FONT></FONT>\n</DL>\n\n<P>\n<HR>\n<P><a name=\"Footnotes\"><B><FONT FACE=\"Variable Width\">Footnotes</FONT></B>\n<P>\n<DL>\n<DT><a name=\"foot1\"><a href=\"#foot1-txt\">[Footnote 1]</a>\n<DD>This section is condensed from a detailed exposition on\nADLs given in [<a href=\"#Med97\">Med97</a>] and [<a href=\"#MT97\">MT97</a>], where we provided a \ndefinition of ADLs and devised a classification and comparison \nframework for them.\n\n<P>\n<DT><a name=\"foot2\"><a href=\"#foot2-txt\">[Footnote 2]</a>\n<DD>One can think of these syntactic features as equivalent to a \n\"boxes and arrows\" graphical notation with little or no underlying \nsemantics.\n\n<P>\n<DT><a name=\"foot3\"><a href=\"#foot3-txt\">[Footnote 3]</a>\n<DD>Saying that an architecture is \"executing\" can mean either \nthat the architecture is being simulated or that the executable \nsystem built based on that architecture is running.\n</DL>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}