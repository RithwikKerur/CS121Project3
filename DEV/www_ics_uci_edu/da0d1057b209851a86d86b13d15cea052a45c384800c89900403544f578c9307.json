{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/Tron.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// \"Tron\"-like motorcycle-crashing ray-intersection diagram\n\n#include \"Tron.h\"\n#include \"Random.h\"\n#include \"Error.h\"\n#include <math.h>\n\nstatic void RandomCircle(double & x, double & y)\n{\n\tdouble arg = RandomDouble() * 3.1415926535898;\n\tx = cos(arg);\n\ty = sin(arg);\n}\n\nTron::Tron(unsigned long npoints) : PointSet(npoints), points(new ray[npoints])\n{\n\tif (points == 0) error(\"RayDiagram: unable to allocate points\");\n\tfor (unsigned long i = 0; i < npoints; i++) {\n\t\tRandomCircle(points[i].x, points[i].y);\n\t\tRandomCircle(points[i].dx, points[i].dy);\n\t\tdouble rate = RandomDouble();\n\t\tpoints[i].dx /= rate;\n\t\tpoints[i].dy /= rate;\n\t\tpoints[i].t = MAX_DISTANCE;\n\t}\n}\n\n// find crossing of two rays, return LATER of two crossing times\n// (that's when the crash happens: the second ray crashes into the first).\ndouble Tron::operator() (point i, point j) {\n\tgDistances++;\n\tdouble ti, tj;\n\tcross(i,j,ti,tj);\n\tif (ti > tj) return ti;\n\telse return tj;\n}\n\n// determine time parameter where two lines cross\n// and test whether it corresponds to an actual ray-ray or ray-seg intersection\nvoid Tron::cross(point i, point j, double & ti, double & tj)\n{\n\t// solve system of equations\n\t// p[i].x + ti p[i].dx = p[j].x + tj p[j].dx\n\t// p[j].y + ti p[i].dy = p[j].y + tj p[j].dy\n\t// then test if ti, tj in range [0,p[].t], if not use MAX_DIST\n\tdouble d = points[i].dx * points[j].dy - points[j].dx * points[i].dy;\n\tif (d == 0) ti = tj = MAX_DISTANCE;\t\t// parallel rays\n\telse {\n\t\tti = (points[j].dy * (points[j].x - points[i].x) -\n\t\t\t  points[j].dx * (points[j].y - points[i].y)) / d;\n\t\ttj = (points[i].dy * (points[j].x - points[i].x) -\n\t\t\t  points[i].dx * (points[j].y - points[i].y)) / d;\n\n\t\t// make sure in range to be a collision\n\t\tif (ti < 0.0 || ti > points[i].t || tj < 0.0 || tj > points[j].t)\n\t\t\tti = tj = MAX_DISTANCE;\n\t\t\n\t\t// make sure we don't crash the same motorcycle twice\n\t\tif ((ti >= tj && points[i].t < MAX_DISTANCE) ||\n\t\t\t(tj >= ti && points[j].t < MAX_DISTANCE)) ti = tj = MAX_DISTANCE;\n\t}\n}\n\n// cut ray off at intersection\nvoid Tron::TerminateRays(point a, point b, ClosestPairs & cp)\n{\n\tdouble ta,tb;\n\tcross(a,b,ta,tb);\t\t// find when each ray crosses pt of collision\n\tif (ta >= tb) {\t\t\t// cut short last ray to cross\n\t\tpoints[a].t = ta;\n\t\tcp.UpdatePoint(a);\n\t\tgDeletions++;\n\t}\n\tif (tb >= ta) {\n\t\tpoints[b].t = tb;\n\t\tcp.UpdatePoint(b);\n\t\tgDeletions++;\n\t}\n}\n\ndouble RayDiagram(unsigned long np, PointSet & ps, ClosestPairs & cp)\n{\n\tTron & t = * (Tron *) &ps;\n\tdouble total = 0.0;\n\tpoint a, b;\n\tfor (;;) {\n\t\tdouble d = cp(a,b);\t// find time of next collision\n\t\tif (d == MAX_DISTANCE) return total;\t// no more collisions, return\n\t\ttotal = d;\t\t\t// else remember time of last collision for retval\n\t\tt.TerminateRays(a, b, cp);\t// turn rays into segments\n\t}\n}\n", "encoding": "ascii"}