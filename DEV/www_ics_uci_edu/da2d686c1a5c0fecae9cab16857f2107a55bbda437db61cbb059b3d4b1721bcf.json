{"url": "https://www.ics.uci.edu/~dechter/courses/ics-275a/fall-99/slides/node234.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3O//DTD W3 HTML 2.0//EN\">\r\n<!Converted with LaTeX2HTML 95.1 (Fri Jan 20 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >\r\n<HEAD>\r\n<TITLE> Nondeterministic Externals</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<meta name=\"description\" value=\" Nondeterministic Externals\">\r\n<meta name=\"keywords\" value=\"umsroot\">\r\n<meta name=\"resource-type\" value=\"document\">\r\n<meta name=\"distribution\" value=\"global\">\r\n<P>\r\n <BR> <HR><A NAME=tex2html5055 HREF=\"node235.html\"><IMG ALIGN=BOTTOM ALT=\"next\" SRC=\"http://www.ecrc.de/eclipse/new_icons//next_motif.gif\"></A>   <A NAME=tex2html5053 HREF=\"node215.html\"><IMG ALIGN=BOTTOM ALT=\"up\" SRC=\"http://www.ecrc.de/eclipse/new_icons//up_motif.gif\"></A>   <A NAME=tex2html5047 HREF=\"node233.html\"><IMG ALIGN=BOTTOM ALT=\"previous\" SRC=\"http://www.ecrc.de/eclipse/new_icons//previous_motif.gif\"></A>      <A NAME=tex2html5057 HREF=\"node321.html\"><IMG ALIGN=BOTTOM ALT=\"index\" SRC=\"http://www.ecrc.de/eclipse/new_icons//index_motif.gif\"></A>   <BR>\r\n<B> Next:</B> <A NAME=tex2html5056 HREF=\"node235.html\"> Suspending with External </A>\r\n<B>Up:</B> <A NAME=tex2html5054 HREF=\"node215.html\"> External Language Interface</A>\r\n<B> Previous:</B> <A NAME=tex2html5048 HREF=\"node233.html\"> Calling Prolog from </A>\r\n<BR> <HR> <P>\r\n<H1><A NAME=SECTION001950000000000000000> Nondeterministic Externals</A></H1>\r\n<P>\r\nThe previous sections covered the creation of deterministic\r\nexternal predicates.\r\nThe nondeterministic predicates can of course use the same macros\r\nas the deterministic ones, however their functionality\r\nis larger in that they are sensitive to the backtracking process.\r\n<P>\r\nA non deterministic Prolog procedure has potentially more than one\r\nsolution. When it is first called, a solution is found if possible, and\r\nexecution proceeds. If a subsequent goal fails, backtracking occurs,\r\nand an attempt is made to find another solution to the\r\ncall of the procedure. To\r\nmake this action possible in the procedural language C, <A NAME=tex2html813 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n<P>\r\nprovides a macro which will take note of the values to be given to the\r\narguments of an external procedure if an attempt is made  to resatisfy\r\nit. This macro is <tt> Remember()</tt>.\r\n<P>\r\nTo illustrate its use, consider the next example,\r\nit shows a C implementation of the Prolog predicate <b> member/2</b>.\r\nAs opposed to the well-known Prolog definition this one does not work\r\nbackwards, i.e. it will not construct lists when called with the\r\nsecond argument uninstantiated:\r\n<blockquote> <PRE>int\r\np_member(velt, telt, vlist, tlist)\r\nvalue velt, vlist;\r\ntype telt, tlist;\r\n{\r\n        pword *p;\r\n\r\n        /* we require a list or nil */\r\n        Check_List(tlist);\r\n        /* if the list is empty, we fail */\r\n        if(IsNil(tlist))\r\n        {\r\n                Cut_External;\r\n                Fail;\r\n        }\r\n        /* the tail of the list */\r\n        p = vlist.ptr + 1;\r\n        /* must be dereferenced! */\r\n        Dereference(p);\r\n        /*\r\n        * on backtracking we will get the tail of the list\r\n        * instead of the list itself\r\n        */\r\n        Remember(2, p-&gt;val, p-&gt;tag);\r\n        /*\r\n        * and we behave as the unification\r\n        * of the element and the head\r\n        */\r\n        Return_Unify_Pw(velt, telt,\r\n                vlist.ptr-&gt;val, vlist.ptr-&gt;tag);\r\n}\r\n</PRE>\r\n</blockquote>\r\nTo link this C function to a Prolog predicate use b_external/2 as \r\nfollows:\r\n<blockquote> <PRE>b_external(member/2, p_member)\r\n</PRE></blockquote>\r\nIn a Prolog program the call \r\n<blockquote> <PRE>member(X, List)\r\n</PRE></blockquote> \r\nwill succeed if X is\r\na member of the list List. This is clearly resatisfiable - for example\r\nin the call\r\n<blockquote> <PRE>member(X, [1, 2, 3, 4])\r\n</PRE></blockquote> where X is an uninstantiated variable,\r\nX will first be instantiated to 1, and on resatisfaction of the goal it\r\nwill successively be instantiated to 2, 3, and 4 before it finally\r\nfails.\r\nA solution to the call <blockquote> <PRE>member(X, List)\r\n</PRE></blockquote> is found when\r\nX is unified with the head of <i> List</i>\r\nby the <tt> Return_Unify_Pw()</tt> statement in the last line of the\r\nfunction. When an attempt is made to resatisfy the above clause,\r\nX must be instantiated to another element of <i> List</i>. This will\r\nbe done if the procedure is called again with a new instantiation of\r\nits arguments, namely that when the second argument has the value of\r\nthe tail of the list which it was given on the previous call.\r\n<P>\r\nThe use of the macro <tt> Remember()</tt> makes this new instantiation of the\r\n<A NAME=3655>&#160;</A>\r\nprocedure's arguments possible. In an external procedure, the call of\r\nthe macro\r\n<blockquote> <PRE>Remember(n, val, tag);\r\n</PRE></blockquote> has the effect that if an attempt is\r\nmade to resatisfy the procedure, the value given in argument <tt> n</tt>\r\n<i> of the Prolog procedure</i> will be the Prolog term represented by the\r\n<i> value</i> val and the <i> tag</i> tag. The type of  val must be <tt> value</tt>\r\nand the type of tag must be <tt> type</tt>.\r\n<P>\r\nThus in the above example, it is required that the procedure be\r\ncalled with the second argument instantiated to the tail of the list\r\nwhich was its previous value. So a pointer is taken to the tail\r\nby the assignment of the pointer <tt> p</tt> in the fourth statement,\r\nand the call <blockquote> <PRE>Remember(2, p-&gt;val, p-&gt;tag);\r\n</PRE></blockquote> informs <A NAME=tex2html815 HREF=\"http://www.ecrc.de/eclipse/eclipse.html\"><b> ECLiPSe</b></A>\r\n<P>\r\nthat to resatisfy the goal\r\na call of the Prolog procedure must be made again, with the second argument\r\ninstantiated to the object pointed to by <tt> p</tt>.\r\n<P>\r\nNote the use of the <tt> Dereference</tt> macro in the previous\r\n<A NAME=3669>&#160;</A>\r\nexample.\r\n<tt> p</tt> is the tail of the list and so to access its value,\r\nit must be dereferenced, even though it will become\r\n<A NAME=3671>&#160;</A>\r\npredicate argument in the next invocation of <tt> p_member</tt> - only\r\nthe terms which are arguments of the normal (not after backtracking)\r\ninvocation are dereferenced by the system.\r\n<P>\r\nA nondeterministic external predicate is resatisfiable until\r\nit explicitly cuts all following alternatives using\r\nthe macro <tt> Cut_External</tt>, i.e.\r\n<A NAME=3674>&#160;</A>\r\nif it uses <tt> Return_Unify</tt> and this unification fails\r\nor if it uses the macro <tt> Fail</tt>, it will be\r\ncalled immediately again with the newly remembered value, if any.\r\nIf it is known that the current solution is the last one,\r\nthe macro <tt> Succeed_Last</tt> can be used for a deterministic exit\r\n<A NAME=3678>&#160;</A>\r\nfrom this external predicate, i.e. the predicate succeeds\r\nand is no longer resatisfiable.\r\n<P>\r\nTo perform the backtracking operation, some information must be stored\r\nbetween one attempt at satisfaction of the goal and an attempt to\r\nresatisfy it.\r\nBy this mechanism,\r\nthe backtracking of Prolog can be imitated by  the facilities in\r\nC. It is not always possible (and seldom desirable)\r\nto map directly from the  definition of\r\nthe procedure in Prolog to an implementation in C. Some ingenuity may\r\nbe required. A very simple example is the procedure <b> p/1</b> defined in Prolog\r\nas\r\n<blockquote> <PRE>p(a).\r\np(b).\r\np(c).\r\n</PRE>\r\n</blockquote>\r\nThis is implemented as a C external by defining the Prolog code\r\n<blockquote> <PRE>p(X) :- p(X, 1).\r\n</PRE></blockquote>\r\nThe C external is then written for the procedure <b> p/2</b>, whose\r\nauxiliary second argument serves to count its invocations.\r\n<blockquote> <PRE>int\r\np_p2(v1, t1, v2, t2)\r\nvalue v1, v2;\r\ntype  t1, t2;\r\n{\r\n        char        *result;\r\n        pword       new;\r\n\r\n        /* first check the arguments */\r\n        Check_Integer(t2);\r\n        Check_Output_Atom(t1);\r\n        /* take note of new resatisfaction */\r\n        Make_Integer(&amp;new, v2.nint + 1);\r\n        Remember(2, new.val, new.tag);\r\n        /* get the string that corresponds to the value of v2 */\r\n        switch(v2.nint)\r\n        {\r\n                case 1:\r\n                        result = &quot;a&quot;;\r\n                        break;\r\n                case 2:\r\n                        result = &quot;b&quot;;\r\n                        break;\r\n                case 3:\r\n                        result = &quot;c&quot;;\r\n                        break;\r\n                default:\r\n                        Fail;\r\n        }\r\n        Return_Unify_Atom(v1, t1, Did(result, 0));\r\n}\r\n</PRE>\r\n</blockquote><BR> <HR><A NAME=tex2html5055 HREF=\"node235.html\"><IMG ALIGN=BOTTOM ALT=\"next\" SRC=\"http://www.ecrc.de/eclipse/new_icons//next_motif.gif\"></A>   <A NAME=tex2html5053 HREF=\"node215.html\"><IMG ALIGN=BOTTOM ALT=\"up\" SRC=\"http://www.ecrc.de/eclipse/new_icons//up_motif.gif\"></A>   <A NAME=tex2html5047 HREF=\"node233.html\"><IMG ALIGN=BOTTOM ALT=\"previous\" SRC=\"http://www.ecrc.de/eclipse/new_icons//previous_motif.gif\"></A>      <A NAME=tex2html5057 HREF=\"node321.html\"><IMG ALIGN=BOTTOM ALT=\"index\" SRC=\"http://www.ecrc.de/eclipse/new_icons//index_motif.gif\"></A>   <BR>\r\n<B> Next:</B> <A NAME=tex2html5056 HREF=\"node235.html\"> Suspending with External </A>\r\n<B>Up:</B> <A NAME=tex2html5054 HREF=\"node215.html\"> External Language Interface</A>\r\n<B> Previous:</B> <A NAME=tex2html5048 HREF=\"node233.html\"> Calling Prolog from </A>\r\n<BR> <HR> <P>\r\n<BR> <HR>\r\n<P><ADDRESS>\r\n<I>Micha Meier <BR>\r\nMon Mar  4 12:11:45 MET 1996</I>\r\n</ADDRESS>\r\n</BODY>\r\n", "encoding": "ascii"}