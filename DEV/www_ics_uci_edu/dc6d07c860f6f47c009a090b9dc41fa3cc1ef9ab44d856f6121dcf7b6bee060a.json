{"url": "https://www.ics.uci.edu/~ejw/authoring/protocol/draft-ietf-webdav-protocol-01.txt", "content": "\n\n\n\n\n\n         WEBDAV Working Group                         Y. Goland, Microsoft\n         INTERNET-DRAFT                  E. J. Whitehead, Jr., U.C. Irvine\n         <draft-ietf-webdav-protocol-01>              Asad Faizi, Netscape\n                                                 Stephen R. Carter, Novell\n                                                        Del Jensen, Novell\n         Expires January 15, 1997                            July 13, 1997\n\n\n                  Extensions for Distributed Authoring and Versioning\n                                       on the\n                               World Wide Web -- WEBDAV\n\n\n         Status of this Memo\n\n         This document is an Internet-Draft. Internet-Drafts are working\n         documents of the Internet Engineering Task Force (IETF), its\n         areas, and its working groups. Note that other groups may also\n         distribute working documents as Internet-Drafts.\n\n         Internet-Drafts are draft documents valid for a maximum of six\n         months and may be updated, replaced, or made obsolete by other\n         documents at any time. It is inappropriate to use Internet-Drafts\n         as reference material or to cite them other than as \"work in\n         progress\".\n                   \n         To learn the current status of any Internet-Draft, please check\n         the \"1id-abstracts.txt\" listing contained in the Internet-Drafts\n         Shadow Directories on ftp.is.co.za (Africa), nic.nordu.net\n         (Europe), munnari.oz.au (Pacific Rim), ds.internic.net (US East\n         Coast), or ftp.isi.edu (US West Coast).\n\n         Distribution of this document is unlimited. Please send comments\n         to the Distributed Authoring and Versioning (WEBDAV) working\n         group at <w3c-dist-auth@w3.org>, which may be joined by sending a\n         message with subject \"subscribe\" to <w3c-dist-auth-\n         request@w3.org>.\n\n         Discussions of the WEBDAV working group are archived at\n         <URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\n\n         Abstract\n         This Document specifies a set of methods and content-types\n         ancillary to HTTP/1.1 for the management of resource properties,\n         simple name space manipulation,\n         simple resource locking (collision avoidance) and resource\n         version control.\n\n\n\n                                  Table of Contents\n\n         Abstract\n         1    Terminology\n         2    Data Model and Methods for DAV Properties\n              2.1  Introduction\n                   2.1.1............................The DAV Property\n                   2.1.2.................Existing Metadata Proposals\n                   2.1.3.................Properties and HTTP Headers\n              2.2  A Property Model for HTTP Resources\n                   2.2.1....................................Overview\n                   2.2.2..........................Property Namespace\n                   2.2.3.........................Property Attributes\r\f\n\n\n\n\n\n                   2.2.4.....................................Schemas\n              2.3  DAV Schema\n                   2.3.1..............................Live Attribute\n                   2.3.2..........................ReadOnly Attribute\n                   2.3.3....................................Elements\n              2.4  Property Identifiers\n                   2.4.1..........................Problem Definition\n                   2.4.2........................Solution Requirement\n                   2.4.3...........................DAV URL Parameter\n                   2.4.4...............................Name Encoding\n                   2.4.5...........Compatibility with legacy systems\n              2.5  Link XML Element\n                   2.5.1.........................Problem Description\n                   2.5.2.......................Solution Requirements\n                   2.5.3............................Link XML Element\n                   2.5.4.............................Src XML Element\n                   2.5.5.............................Dst XML Element\n                   2.5.6.....................................Example\n              2.6  Properties and Methods\n                   2.6.1......................................DELETE\n                   2.6.2.........................................GET\n                   2.6.3............................PROPPATCH Method\n                   2.6.4.........................................PUT\n                   2.6.5......................................SEARCH\n         3    A Proposal for Collections of Web Resources and Name Space\n         Operations\n              3.1  Observations on the HTTP Object Model\n                   3.1.1........................Collection Resources\n                   3.1.2Creation and Retrieval of Collection Resources\n                   3.1.3.......Source Resources and Output Resources\n              3.2  MKCOL Method\n                   3.2.1.........................Problem Description\n                   3.2.2.......................Solution Requirements\n                   3.2.3.....................................Request\n                   3.2.4....................................Response\n                   3.2.5.....................................Example\n              3.3  INDEX Method\n                   3.3.1.........................Problem Description\n                   3.3.2.......................Solution Requirements\n                   3.3.3.................................The Request\n                   3.3.4................................The Response\n                   3.3.5.......................Response Message Body\n                   3.3.6.....................................Example\n              3.4  Behavior of RFC 2068 Methods on Collections\n                   3.4.1...................GET, HEAD for Collections\n                   3.4.2........................POST for Collections\n                   3.4.3.........................PUT for Collections\n                   3.4.4......................DELETE for Collections\n              3.5  COPY Method\n                   3.5.1.........................Problem Description\n                   3.5.2.......................Solution Requirements\n                   3.5.3.................................The Request\n                   3.5.4................................The Response\n                   3.5.5....................................Examples\n              3.6  MOVE Method\n                   3.6.1.........................Problem Description\n                   3.6.2.......................Solution Requirements\n                   3.6.3.................................The Request\n                   3.6.4................................The Response\n                   3.6.5....................................Examples\n              3.7  Multi-Status Response\n                   3.7.1..........................Problem Definition\n                   3.7.2.......................Solution Requirements\n                   3.7.3.......................Multi-Status Response\n                   3.7.4.....................................Example\r\f\n\n\n\n\n\n              3.8  ADDREF Method\n                   3.8.1..........................Problem Definition\n                   3.8.2.......................Solution Requirements\n                   3.8.3.................................The Request\n              3.9  DELREF Method\n                   3.9.1..........................Problem Definition\n                   3.9.2.......................Solution Requirements\n                   3.9.3.................................The Request\n              3.10 PATCH Method\n                   3.10.1.........................Problem Definition\n                   3.10.2......................Solution Requirements\n                   3.10.3................................The Request\n                   3.10.4.........application/XML elements for PATCH\n                   3.10.5...............................The Response\n                   3.10.6...................................Examples\n              3.11 Headers\n                   3.11.1......................................Depth\n                   3.11.2................................Destination\n                   3.11.3....................Enforce-Live-Properties\n                   3.11.4.......................Duplicate-Properties\n                   3.11.5..................................Overwrite\n                   3.11.6.............................Destroy Header\n                   3.11.7...................Collection-Member Header\n              3.12 Links\n                   3.12.1..................Source Link Property Type\n         4    State Tokens\n              4.1  Overview\n                   4.1.1.........................Problem Description\n                   4.1.2.......................Solution Requirements\n              4.2  State Token Syntax\n              4.3  State Token Conditional Headers\n                   4.3.1..............................If-State-Match\n                   4.3.2.........................If-None-State-Match\n              4.4  State Token Header\n              4.5  E-Tags\n         5    Locking\n              5.1  Problem Description - Overview\n                   5.1.1..................Exclusive Vs. Shared Locks\n                   5.1.2............................Required Support\n              5.2  LOCK Method\n                   5.2.1...................................Operation\n                   5.2.2The Effect of Locks on Properties and Containers\n                   5.2.3................Locking Replicated Resources\n                   5.2.4..............Interaction with other Methods\n                   5.2.5....................Lock Compatibility Table\n                   5.2.6................................Status Codes\n                   5.2.7.....................................Example\n                   5.2.8....................Lock-Info Request Header\n                   5.2.9........................Owner Request Header\n                   5.2.10............................Time-Out Header\n                   5.2.11.........................State-Token Header\n              5.3  Write Lock\n              5.4  Lock Tokens\n                   5.4.1.........................Problem Description\n                   5.4.2...........................Proposed Solution\n                   5.4.3.......................Lock Token Definition\n              5.5  UNLOCK Method\n                   5.5.1..........................Problem Definition\n                   5.5.2.....................................Example\n              5.6  Discovery Mechanisms\n                   5.6.1.........................Lock Type Discovery\n                   5.6.2.......................Active Lock Discovery\n         6    Version Control\n         7    Internationalization Support\n         8    Security Considerations\r\f\n\n\n\n\n\n         9    Acknowledgements\n         10   References\n         11   Authors' Addresses\n         Appendix 1 - Content Type Application/XML\n              Syntax\n              XML element\n              Entity-Name\n              Close\n              XML Encoding\n              Markup Modifier\n              XML Syntax Shorthand\n         Appendix 2 - Parameter Syntax for Content-Type Application/XML\n              Schema Content-Type Parameter\n         Appendix 3 \u2013 URI Path Encoding\n              Problem Definition\n              Solution Requirement\n              Path Component\n         Appendix 4 - XML URI\n         Appendix 5 - XML elements\n              Ref XML element\n              Namespace\n                   Namespace XML element\n                   AS XML element\n                   Required XML element\n                   The XML URI and Namespace\n\n\n\n         1  Terminology\n         Collection - A resource that contains member resources.\n\n         Member Resource - a resource referred to by a collection. There\n         are two types of member resources: external and internal.\n\n         Internal Member Resource - the name given to a member resource of\n         a collection whose URI is relative to the URI of the collection.\n\n         External Member Resource - a member resource with an absolute URI\n         that is not relative to its parent\u2019s URI.\n\n         Properties \u2013 Also known as small-chunk metadata, a hierarchical\n         set of name/value pairs that describe a resource.\n\n         Live Properties \u2013 Properties whose semantics and syntax are\n         enforced by the server. For example, a live \u201cread-only\u201d property\n         that is enforced by the server would disallow PUTs to the\n         associated resource.\n\n         Dead properties \u2013 Properties whose semantics and syntax are not\n         enforced by the server. A dead \u201cread-only\u201d property would not be\n         enforced by the server and thus would not be used by the server as\n         a reason to disallow a PUT on the associated resource.\n\n\n\n         2  Data Model and Methods for DAV Properties\n\n         2.1 Introduction\n\n         2.1.1     The DAV Property\n\n         Properties are pieces of data that describe the state of a\n         resource. Properties are data about data. The term property is\n         used within this specification to disambiguate the concept from\n         the overloaded terms \u201cmetadata\u201d and \u201cattribute\u201d.\n\n         Properties are used within distributed authoring environments to\n         provide for efficient discovery and management of resources. For\r\f\n\n\n\n\n\n         example, a \u2018subject\u2019 property might allow for the indexing of all\n         resources by their subject, and an \u2018author\u2019 property might allow\n         for the discovery of what authors have written which documents.\n\n\n         2.1.2     Existing Metadata Proposals\n\n         Properties have a long played an essential role in the maintenance\n         of large document repositories, and many current proposals contain\n         some notion of a property. These include PICS [Miller et al.,\n         1996], PICS-NG, the Rel/Rev draft [Maloney, 1996], Web\n         Collections, XML [Bray, 1997], several proposals on representing\n         relationships within HTML, digital signature manifests (DCMF), and\n         a position paper on Web metadata architecture [Berners-Lee, 1997].\n\n         Some proposals come from a digital library perspective. These\n         include the Dublin Core [Weibel et al., 1995] metadata set and the\n         Warwick Framework [Lagoze, 1996], a container architecture for\n         different metadata schemas. The literature includes many examples\n         of metadata, including MARC [MARC, 1994], a bibliographic metadata\n         format, RFC 1807 [Lasher, Cohen, 1995], a technical report\n         bibliographic format employed by the Dienst system, and the\n         proceedings from the first IEEE Metadata conference describe many\n         community-specific metadata sets.\n\n         Participants of the 1996 Metadata II Workshop in Warwick, UK\n         [Lagoze, 1996], noted that, \"new metadata sets will develop as the\n         networked infrastructure matures\" and \"different communities will\n         propose, design, and be responsible for different types of\n         metadata.\" These observations can be corroborated by noting that\n         many community-specific sets of metadata already exist, and there\n         is significant motivation for the development of new forms of\n         metadata as many communities increasingly make their data\n         available in digital form, requiring a metadata format to assist\n         data location and cataloging.\n\n\n         2.1.3     Properties and HTTP Headers\n\n         Properties already exist, in a limited sense, within HTTP through\n         the use of message headers. However, in distributed authoring\n         environments a relatively large number of properties are needed to\n         fully describe the state of a resource, and setting/returning them\n         all through HTTP headers is inefficient. Thus a mechanism is\n         needed which allows a principal to identify a set of properties in\n         which the principal is interested and to then set or retrieve just\n         those properties.\n\n         2.2 A Property Model for HTTP Resources\n\n         2.2.1     Overview\n\n         The DAV property model is based on name/value/attribute triples.\n         The name of a property identifies the property\u2019s syntax and\n         semantics, and provides an address with which to refer to a\n         property. The value of a property is an octet stream. The\n         attributes of a property are a set of name/value pairs that are\n         not directly addressable. Attributes are retrieved in conjunction\n         with retrieving a property, and are set when changing a property\u2019s\n         value. This specification defines two attributes, live, which\n         indicates if the property\u2019s syntax and semantics is enforced by\n         the server, and readonly, which indicates that the property\u2019s\n         value may be retrieved but not set.\r\f\n\n\n\n\n\n         2.2.2     Property Namespace\n\n\n         2.2.2.1   Problem Definition\n\n         The requirement is to be able to associate a value with a property\n         name on a resource and to be able to directly address that value.\n\n\n         2.2.2.2   Solution Requirement\n\n         Ideally a property namespace should work well with extant property\n         implementations as well as database systems. The DAV property\n         namespace has been specified with the following two facts in mind:\n\n            Namespaces associated with flat file systems are certainly\n               ubiquitous.\n\n            Many databases use a fixed schema mechanism, which makes\n               efficient implementation of hierarchical properties\n               difficult. Specifically, each property has a random set of\n               children; the best a relational database can do is provide\n               a table with name and value, where the value is a series\n               of indexes into other tables and each index represents a\n               specific value. However most RDBS do not provide for table\n               pointers, only index values. Such a system would have to\n               be jury-rigged to handle table pointers. In addition,\n               indexing systems are optimized for a small set of\n               relatively large tables; hierarchical property systems\n               tend toward many properties, each with different numbers\n               and types of children, thus potentially requiring a table\n               for each child.\n\n            It would seem best to implement a flat property namespace,\n            inducing a natural isomorphism between DAV and most native\n            file systems. Adopting such a model should not restrict RDBS\n            from taking full advantage of their search facilities.\n\n            However, it seems that future trends might be toward\n            hierarchical properties. As such, DAV requirements []\n            stipulate that the design of the flat property system MUST\n            be such that it will be possible to add true hierarchical\n            properties later without breaking downlevel clients.\n            Specifically, a flat client MUST be able to speak to a\n            hierarchical server and a hierarchical client MUST be able\n            to speak to a flat server. Worst case either way MUST be\n            that the request fails.\n\n\n            2.2.2.3   Property Names\n\n            A property name identifies both the syntax and semantics of\n            the property\u2019s value. It is critical that property names do\n            not collide, e.g., two principals defining the same property\n            name with two different meanings.\n\n            The URI framework provides for a mechanism to prevent\n            namespace collision and for varying degrees of\n            administrative control. Rather than reinvent these desirable\n            features, DAV properties make use of them by requiring that\n            all DAV property names MUST be URIs.\n\n            The property namespace is flat, that is, it is not possible\n            to string together a series of property names in order to\n            refer to a hierarchy of properties. Thus it is possible to\n            refer to a property A but not a property A/B.\r\f\n\n\n\n\n\n            2.2.3     Property Attributes\n\n            The attributes of a property provide information about the\n            property. Note that a property contains information about a\n            resource.\n\n            Attributes consist of name/value pairs whose value MUST be a\n            string. Attributes are not directly addressable, rather they\n            are retrieved and defined in the context of other property\n            operations. For example, if one retrieves a property value,\n            the attributes will also be returned. If one sets a property\n            value, one may also specify the values for its attributes.\n\n            All attributes on a server MUST be live. This means that the\n            server MUST only record attributes with syntax and semantics\n            the server understands and enforces. This normally means\n            that clients can not define new attributes on a property;\n            clients may only make use of the attributes supported by the\n            server.\n\n            If a client submits an attribute when setting a property\n            then the server MUST NOT record the property unless it\n            accepts the values specified for the corresponding\n            attributes. Thus, if a property value is submitted with a\n            live attribute then the server MUST NOT record the value\n            unless the server understands and enforces the syntax and\n            semantics of the property.\n\n\n            2.2.4     Schemas\n\n            A schema is a group of property names, attributes, and XML\n            elements.\n\n            It is often useful to indicate support for a particular\n            schema in a request or a response. Schema discovery is also\n            useful for determining if a system supports a group of\n            properties, attributes, or XML elements. A property does not\n            necessarily contain sufficient information to identify any\n            schema(s) to which it may belong.\n\n            As with property names, schemas MUST use URIs as their\n            names.\n\n            2.3 DAV Schema\n            The DAV Schema is specified as\n            http://www.ietf.org/standards/dav/. This schema is used to\n            indicate support for\n\n            properties and attributes that can be defined on a resource\n               and\n\n            XML elements that can be returned in responses.\n\n            All DAV compliant servers MUST support the DAV schema.\n\n\n            2.3.1     Live Attribute\n\n            Name: http://www.ietf.org/standards/dav/live\n\n            Purpose: To indicate that the property has its syntax and\n            semantics enforced by the resource on which it is recorded.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Any property\n\n            Values= \u201c=\u201d <\u201d><\u201d>\n\n            Description: This attribute is used to indicate that the\n            resource expressing the property understands and enforces\r\f\n\n\n\n\n\n            the syntax and semantics of the property. The absence of the\n            Live attribute in a response indicates to the client that\n            the corresponding property does not have its syntax and\n            semantics enforced by the resource on which it is recorded.\n            If a live attribute is included when setting the value of a\n            property then the server SHOULD set the property if the\n            property will be live and MUST NOT set the property if the\n            property will not be live.\n\n\n            2.3.2     ReadOnly Attribute\n\n            Name: http://www.ietf.org/standards/dav/readonly\n\n            Purpose: To indicate that a property can be retrieved, but\n            not set through the property mechanism.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Any property\n\n            Values= \u201c=\u201d <\u201d><\u201d>\n\n            Description: This attribute is used to indicate that the\n            property can only be retrieved, not set through the property\n            mechanism. This attribute is not meant as an access control\n            mechanism but rather to reflect the fact that the property\n            is not designed to have its value set through the property\n            mechanism. If this attribute is included when setting the\n            value of a property, the request MUST be rejected since\n            accepting the value would violate ReadOnly attribute. A\n            server MUST NOT effect a property protocol element that is\n            inconsistent or ill-defined with respect to the element\u2019s\n            attribute state, were it to be expressed.\n\n\n            2.3.3     Elements\n\n\n            2.3.3.1   Prop XML element\n\n            Name: http://www.ietf.org/standards/dav/prop\n\n            Purpose: To specify the name and value of a property\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Any\n\n            Values: PropName PropValue\n\n\n            2.3.3.2   PropName XML element\n\n            Name: http://www.ietf.org/stnadards/dav/name\n\n            Purpose: To specify the name of a property, which MUST be a\n            URI.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Prop\n\n            Values: URI\n\n\n            2.3.3.3   PropValue XML element\n\n            Name: http://www.ietf.org/standards/dav/propvalue\n\n            Purpose: To specify the value of a property.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Prop\r\f\n\n\n\n\n\n            Values: The contents of a property.\n\n            2.4 Property Identifiers\n\n            2.4.1     Problem Definition\n\n            The addition of DAV properties to the HTTP object model\n            introduces the need for a mechanism to unambiguously refer\n            to either the body of the resource or the properties of a\n            resource.\n\n\n            2.4.2     Solution Requirement\n\n            The mechanism used for referring to the resource body must\n            also be usable for referring to the resource\u2019s properties,\n            such that even non-DAV aware clients can retrieve DAV\n            properties.\n\n\n            2.4.3     DAV URL Parameter\n\n            To allow for the specification of property information in\n            the context of an http scheme URL, a switch is needed. The\n            switch indicates that following path segments specify a\n            property location. To this end the \u201cDAV\u201d param is introduced\n            for use with http scheme URLs. The path segment to the right\n            of the DAV param MUST be formatted according to the XML Link\n            standard, described in Appendix 3.\n\n\n            2.4.4     Name Encoding\n\n            Properties on a resource are given URIs as a name. Thus, in\n            order to be able to refer to a property one must be able to\n            put the property\u2019s URI into an HTTP URI.\n\n            For example, the author property with full name\n            http://www.w3.org/standards/z39.50/author is defined on\n            http://somewhere.com/resource.\n\n            To create a reference to the author one would perform the\n            following steps.\n\n            Add the DAV parameter to the base URI,\n               http://somewhere.com/resource;DAV.\n\n            Add \u201c/\u201d to refer to the root of the resource\u2019s property\n               namespace, http://somewhere.com/resource;DAV/.\n\n            Change the author property\u2019s name into parameter format by\n               changing \u201c/\u201ds to \u201c!\u201ds and encasing the entire value in\n               parenthesis. The value must be encased in parenthesis in\n               order to indicate the \u201c/\u201d to \u201c!\u201d translation. The\n               translation \u201c/\u201d to \u201c!\u201d is done in order to prevent\n               confusion over segments boundaries, and to make sure that\n               the syntax for relative URIs remains well-defined.\n               http://somewhere.com/resource;DAV/(http:!!www.w3.org!stand\n               ards!z39.50!author).\n\n            The process is now complete, and the URL can be used in a\n            GET or PATCH to retrieve or alter the value. See appendix 3\n            for more information.\r\f\n\n\n\n\n\n            2.4.5     Compatibility with legacy systems\n\n\n            2.4.5.1   Problem Definition\n\n            The HTTP parameter space is uncontrolled, thus someone may\n            already be using a parameter with a value of \u201cDAV\u201d for some\n            end other than the one described here. Thus a client sending\n            a URI with a DAV param to a server may receive an unexpected\n            or inappropriate response.\n\n\n            2.4.5.2   Solution Requirement\n\n            A mechanism is needed to prevent namespace collisions.\n\n\n            2.4.5.3   Proposed Solution\n\n            All DAV compliant servers MUST honor the DAV param type on\n            http URLs. Thus if a client knows it is talking to a DAV\n            server, it can safely send an http URL with the DAV param.\n\n            The client may send the http URL with the DAV param\n            extension to a server that is not known to be DAV compliant\n            if the client uses PEP [Connolly, 1997] to prevent\n            collisions. The proper PEP header is:\n\n            DAVPEP = \u201cPEP: {{map \u201cDAV\u201d}{strength must}}\u201d\n\n            Note: this PEP header is not compliant with [Connolly,\n            1997]; the PEP authors have indicated they will change the\n            format to make the example legal.\n\n            2.5 Link XML Element\n\n            2.5.1     Problem Description\n\n            A mechanism is needed to associate resources with other\n            resources. These associations, also known as links, consist\n            of three values, a type describing the nature of the\n            association, the source of the link, and the destination of\n            the link. In the case of annotation, neither the source nor\n            the destination of a link need be the resource upon which\n            the link is recorded.\n\n\n            2.5.2     Solution Requirements\n\n            The association mechanism MUST make use of the DAV property\n            mechanism in order to make the existence of the associations\n            searchable.\n\n\n            2.5.3     Link XML Element\n\n            Name: http://www.ietf.org/standards/dav/link\n\n            Purpose: The XML document which is the value of a link.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Values= An XML document which MUST have a src and dst XML\n            element.\n\n            Description: Link is used to provide the source and one or\n            more destinations of the link. The type of the property\n            provides the type of the link. Link is a multivalued\n            element,so multiple Links may be used together to indicate\n            multiple links with the same type.\r\f\n\n\n\n\n\n            2.5.4     Src XML Element\n\n            Name: http://www.ietf.org/standards/dav/src\n\n            Purpose: To indicate the source of a link.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: http://www.ietf.org/standards/dav/link\n\n            Values= URI\n\n\n            2.5.5     Dst XML Element\n\n            Name: http://www.ietf.org/standards/dav/Dst\n\n            Purpose: To indicate one or more destinations of a link\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: http://www.ietf.org/standards/dav/link\n\n            Values= URI\n\n\n            2.5.6     Example\n\n            <XML>\n                 <Namespace><Ref>http://www.ietf.org/standards/dav/</><A\n                 S>D</></>\n                 <D:Prop>\n                      <Propname>Source</>\n                      <Propvalue>\n                           <XML:XML>\n                                <Namespace>\n\n                                     <Ref>http://www.ietf.org/standards/\n                                dav/</><AS>D</>\n                                </>\n                                <Namespace>\n\n                                     <Ref>http://www.foocorp.com/Project\n                                /</><AS>F</>\n                                </>\n                                <D:Link>\n                                     <F:ProjectFiles>Source</>\n                                     <src>http://foo.bar/program</>\n\n                      <dst>http://foo.bar/source/main.c</>\n                                </>\n                                <D:Link>\n                                     <F:ProjectFiles>Library</>\n                                     <src>http://foo.bar/program</>\n\n                      <dst>http://foo.bar/source/main.lib</>\n                                </>\n                                <D:Link>\n                                     <F:ProjectFiles>Makefile</>\n                                     <src>http://foo.bar/program</>\n\n                      <dst>http://foo.bar/source/makefile</>\n            </>  </>  </>  </>  </>\n\n            In this example the resource http://foo.bar/program has a\n            source property defined which contains three links. Each\n            link contains three elements, two of which, src and dst, are\n            part of the DAV schema defined in this document, and one\n            which is defined by the schema\n            http://www.foocorp.com/project/ (Source, Library, and\r\f\n\n\n\n\n\n            Makefile). A client which only implements the elements in\n            the DAV spec will not understand the foocorp elements and\n            will ignore them, thus seeing the expected source and\n            destination links. An enhanced client may know about the\n            foocorp elements and be able to present the user with\n            additional information about the links.\n\n            2.6 Properties and Methods\n\n            2.6.1     DELETE\n\n            The delete method, when used on a property, causes the\n            property to be removed.\n\n\n            2.6.2     GET\n\n            A GET on a property returns the name of the property. Accept\n            types may be used to specify the format of the return value,\n            but all DAV compliant servers MUST at minimum support a\n            return type of application/XML. If application/XML is used\n            as the response format then it MUST include the\n            http://www.ietf.org/standards/dav/ schema.\n\n\n            2.6.2.1   Example\n\n            GET bar;DAV/(http:!!www.w3.org!standards!z39.50!Authors)\n            HTTP/1.1\n            Host: foo.com\n\n            HTTP/1.1 200 OK\n            Content-Type: application/xml\n            Content-Length: xxxx\n            E-tag: \u201c1234\u201d\n            Last-Modified: xxxx\n\n            <XML>\n                 <XML:Namespace><Ref>http://www.ietf.org/standards/dav/<\n            /><AS>D</></>\n                 <XML:Namespace><Ref>http://www.w3.com/standards/z39.50/\n            </><AS>Z</></>\n                 <D:prop>\n                      <propname>Z:Authors</>\n                      <propvalue>\n                           <XML:XML>\n                                <Namespace>\n\n                                     <Ref>http://www.ietf.org/standards/\n                                dav/</>\n                                     <AS>D</>\n                                </>\n                                <Namespace>\n\n                                <Ref>http://www.w3.com/standards/z39.50/\n                           </>\n                                     <AS>Z</>\n                                </>\n                                <Z:Author>Jane Doe</>\n                                <Z:Author>Joe Doe</>\n                                <Z:Author>Lots o\u2019Doe</>\n            </>  </>  </>  </>\n\n            GET bar;DAV/(Dublin:Producer) HTTP/1.1\n            Host: foo.com\n\n            HTTP/1.1 200 OK\r\f\n\n\n\n\n\n            Content-Type: application/xml\n            Content-Length: xxxx\n            E-tag: \u201c2345\u201d\n            Last-Modified: xxxx\n\n            <XML>\n                 <XML:Namespace><Ref>http://www.ietf.org/standards/dav/<\n            /><AS>D</></>\n                 <XML:Namespace><Ref>Dublin</><AS>Du</></>\n                 <D:prop>\n                      <propname>Du:Producer</>\n                      <propvalue><XML:XML>Marcus Doe</></>\n            </>  </>\n\n            GET bar;DAV/ HTTP/1.1\n            Host: foo.com\n\n            HTTP/1.1 200 OK\n            Content-Type: application/xml\n            Content-Length: xxxx\n            E-tag; \u201c1234\u201d\n            Last-Modified: xxxx\n\n            <XML>\n                 <XML:Namespace><Ref>http://www.ietf.org/standards/dav/<\n            /><AS>D</></>\n                 <XML:Namespace><Ref>http://www.w3.com/standards/z39.50/\n            </><AS>Z</></>\n                 <XML:Namespace><Ref>Dublin</><AS>Du</></>\n                 <D:prop>\n                      <propname>Z:Authors</>\n                      <propvalue>\n                           <XML:XML>\n                                <Namespace>\n\n                                     <Ref>http://www.ietf.org/standards/\n                                dav/</>\n                                     <AS>D</>\n                                </>\n                                <Namespace>\n\n                                <Ref>http://www.w3.com/standards/z39.50/\n                           </>\n                                     <AS>Z</>\n                                </>\n                                <Z:Author>Jane Doe</>\n                                <Z:Author>Joe Doe</>\n                                <Z:Author>Lots o\u2019Doe</>\n                 </>  </>  </>\n                 <D:prop>\n                      <propname>Du:Producer</>\n                      <propvalue><XML:XML>Marcus Doe</></>\n            </>  </>\n\n\n            2.6.3     PROPPATCH Method\n\n            The PROPPATCH method specifies how to alter a property. The\n            message body controls the actual action taken by a\n            PROPPATCH. All DAV compliant servers are required to support\n            the use of the application/XML content-type using the\n            http://www.ietf.org/standards/dav/proppatch/ schema in a\n            PROPPATCH method with a request-URI that points to the\n            resource upon which the property is defined.\r\f\n\n\n\n\n\n            The changes in a http://www.w3.com/standards/dav/proppatch/\n            request MUST be atomically executed, partial results are not\n            allowed.\n\n\n            2.6.3.1   Request URI\n\n            The request URI of a PROPPATCH method with the\n            http://www.ietf.org/standards/dav/proppatch/ schema MUST\n            point to the resource upon which the property is defined.\n\n\n            2.6.3.2   PropertyUpdate XML element\n\n            Name: http://www.ietf.org/standards/dav/PropertyUpdate\n\n            Purpose: To contain a request to alter the properties on a\n            resource.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: <XML>\n\n            Values= *(Create | Remove | Insert)\n\n            Description: This XML element is a container for the\n            information required to modify the properties on the\n            resource. This XML element is multivalued.\n\n\n            2.6.3.3   Create XML element\n\n            Name: http://www.ietf.org/standards/dav/create\n\n            Purpose: To create the DAV property specified inside the\n            Create XML element.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: http://www.ietf.org/standards/dav/PropertyUpdate\n\n            Values= Prop\n\n            Description: This XML element contains a Prop as the only\n            element. The PropName contains the name of the property to\n            be created or overwritten. The PropValue XML element\n            contains the value of the new property.\n\n\n            2.6.3.4   Remove XML element\n\n            Name: http://www.ietf.org/standards/dav/remove\n\n            Purpose: To remove the DAV property specified inside the\n            Remove XML element.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: http://www.ietf.org/standards/dav/PropertyUpdate\n\n            Values= PropName\n\n            Description: Remove specifies that the property specified in\n            PropName should be removed. Specifying the removal of a\n            property that does not exist is not an error.\n\n\n            2.6.3.5   Response Codes\n\n            200 OK \u2013 The command succeeded. As there can be a mixture of\n            PUT and DELETEs in a body, a 201 Create seems inappropriate.\n\n            400 Bad Request \u2013 The client has provide a value whose\n            syntax is illegal for the property.\n\n            401 Unauthorized \u2013 The client does not have authorization to\r\f\n\n\n\n\n\n            alter one of the properties. This error also occurs if a\n            property is inherently read only.\n\n            403 Forbidden \u2013 The client, for reasons the server chooses\n            not to specify, can not alter one of the properties.\n\n            405 Conflict \u2013 The client has provided a value whose\n            semantics are not appropriate for the property.\n\n            413 Request Entity Too Long \u2013 If a particular property is\n            too long to be recorded then a composite XML error will be\n            returned indicating the offending property.\n\n\n            2.6.3.6   Example\n\n            PROPPATCH bar;DAV/ HTTP/1.1\n            Host: www.foo.com\n            Content-Type: application/XML\n            Content-Length: xxxx\n\n            <XML>\n                 <Namespace><Ref>http://www.ietf.org/standards/dav/</><A\n            S>D</></>\n                 <Namespace><Ref>http://www.w3.com/standards/z39.50/</><\n            AS>Z</></>\n                 <D:PropertyUpdate>\n                      <Create><prop>\n                           <propname>Z:authors</>\n                           <propvalue>\n                                <XML:XML>\n                                <Namespace>\n\n                 <Ref>http://www.ietf.org/standards/dav/proppatch/</>\n                                <AS>D</>\n                                </>\n                                <Namespace>\n\n                 <Ref>http://www.w3.com/standards/z39.50/</>\n                                     <AS>Z</>\n                                </>\n                                <Z:Author>Jim Whitehead</>\n                                <Z:Author>Roy Fielding</>\n                           </>\n                      </>\n                      <Remove><propname>Z:Copyright-Onwer</></>\n            </>  </>\n\n            2.6.4     PUT\n\n            A PUT is specified in order to control what is returned by a\n            GET. However a GET on a property always returns some sort of\n            property containment format. As such PUT can not be used if\n            the Request-URI refers to a property.\n\n\n            2.6.5     SEARCH\n\n\n            2.6.5.1   Request-URI\n\n            The request-URI of the search method is the URI of the\n            resource. .\n\n            The Depth header MUST NOT be used on a SEARCH method which\n            contains a Limited-Search XML element (\u201climited search\u201d).\r\f\n\n\n\n\n\n            2.6.5.2   Command Format\n\n            The message body stipulates the action of a SEARCH method.\n            This section defines an application/xml content type using\n            the http://www.ietf.org/standards/dav/ schema. This method\n            is not normally cacheable.\n\n\n            2.6.5.2.1 Limited-Search XML element\n\n            Name: http://www.ietf.org/standards/dav/limited-search\n\n            Purpose: To specify the set of matching properties\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: <XML>\n\n            Values: The value is a single OR XML element. The OR element\n            may only contain AND XML elements, and MUST contain at least\n            one AND element.\n\n            Description: This property indicates a very limited search.\n            The search may only be on HTTP properties.\n\n\n            2.6.5.2.2 OR XML element\n\n            Name: http://www.ietf.org/standards/dav/or\n\n            Purpose: To take its members, evaluate them, get a true or\n            false result, \u201cor\u201d the results together, and have that be\n            the total result.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Limited-Search XML element\n\n            Values: AND XML element.\n\n\n            2.6.5.2.3 AND XML element\n\n            Name: http://www.ietf.org/sandards/dav/and\n\n            Purpose: To take its members, evaluate them, get a true or\n            false result, \u201cand\u201d the results together, and have that be\n            the total result.\n\n            Schema: http://www.ietf.org/standards/dav\n\n            Parent: OR XML element\n\n            Values: Zero or one Name XML element, and zero or one Value\n            XML element. There MUST be at least one Name or Value XML\n            element.\n\n\n            2.6.5.2.4 Name XML element\n\n            Name: http://www.ietf.org/standards/dav/name\n\n            Purpose: To provide a pattern against which property names\n            are to be compared. If the name matches then the property\n            evaluates to true, otherwise false.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: AND XML element\n\n            Values: Match-Stream\n\n\n            2.6.5.2.5 Value XML element\n\n            Name: http://www.ietf.org/standards/dav/value\r\f\n\n\n\n\n\n            Purpose: To provide a pattern against which property values\n            are to be compared. If the value matches then the property\n            evaluates to true, otherwise false.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: AND XML element\n\n            Values: Match-Stream\n\n\n            2.6.5.2.6 Match-String XML element\n\n            Name: http://www.ietf.org/standards/dav/match-string\n\n            Purpose: To specify a search pattern to be matched against\n            an octet stream\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Name or Value XML element\n\n            Values: (\u201c*\u201d | \u201c?\u201d | EncodedOctet)\n            EncodedOctet = <An EncodedOctet uses XML encoding to encode\n            \u201c*\u201d and \u201c?\u201d as well as \u201c<\u201d and \u201c>\u201d\n\n            Description: This element provides a template against which\n            anything that can be expressed as an octet stream may be\n            compared. \u201c*\u201d is a wildcard that matches zero or more\n            unspecified contiguous octets. \u201c?\u201d is a wildcard that\n            matches exactly one unspecified octet.\n\n\n            2.6.5.3   Response Format\n\n            The response is an application/xml message body which\n            contains a single SearchResult XML element whose contents\n            are a series of XML elements representing matching\n            properties.\n\n\n            2.6.5.3.1 SearchResult XML element\n\n            Name: http://www.ietf.org/standards/dav/searchresult\n\n            Purpose: To contain the results of a SEARCH request\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: Any, usually <XML>\n\n            Values: Zero or more Prop XML elements (defined in\n            Properties draft)\n\n            Description: The SearchResult XML element provides the\n            context to inform the client that its contents are not just\n            some XML element, but an XML representation of the requested\n            property.\n\n\n            2.6.5.4   Example\n\n                 SEARCH  /container/ HTTP/1.1\n                 Host: www.foo.bar\n                 Content-Length: xxxx\n                 Content-Type: application/xml\n\n                 <XML>\n                      <XML:Namespace>\n                           <Ref>http://www.ietf.org/standards/dav/</>\n                           <AS>S</>\n                      </>\n                      <S:limited-search>\r\f\n\n\n\n\n\n                           <OR>\n                                <AND>\n                                     <Name>*</>\n                                </>\n                           </>\n                      </>\n                 </>\n\n                 HTTP/1.1 200 OK\n                 Content-Type: application/xml\n                 Content-Length: xxxxx\n\n                 <XML>\n                      <XML:Namespace>\n                           <Ref>http://www.ietf.org/standards/dav/</>\n                           <As>S</>\n                      </>\n                      <XML:Namespace>\n                           <Ref>http://www.foo.bar/boxschema</>\n                           <AS>R</>\n                      </>\n                      <S:SearchResult>\n                           <Prop>\n                                <PropName>R:bigbox</>\n                                <PropValue>\n                                     <XML:XML>\n                                          <BoxType>Box type A</>\n                                     </>\n                                </>\n                           </>\n                           <Prop>\n                                <PropName>R:author</>\n                                <PropValue>\n                                     <XML:XML>\n                                          <Name>J.J.\n                 Dingleheimerschmidt</>\n                                     </>\n                                </>\n                           </>\n                      </>\n                 </>\n\n            The result will return all properties on the container and\n            its members. In this case only two properties were found,\n            one on the container and one on one of its members, both\n            properties are live.\n\n\n\n            3  A Proposal for Collections of Web Resources and Name\n               Space Operations\n\n            3.1 Observations on the HTTP Object Model\n            As a prerequisite for specification of collections and name\n            space operations for the Web, a model for collection\n            resources and for namespace topology must be given.  This\n            section describes a new type of Web resource, the collection\n            resource, and provides a model for discussing the\n            relationship between the resources that are generated as the\n            result of a data-producing process, and the source resources\n            that describe the process.\r\f\n\n\n\n\n\n            3.1.1     Collection Resources\n\n            A collection is a Web resource type whose primary state is a\n            set of URIs and associated values that are recorded as\n            properties on the resource.  The URIs identify resources\n            that are members of the collection.  The values associated\n            with each URI include information such as the Last Modified\n            Date, Entity Tag, Creation Date, Content Type, Display Name,\n            and whether the member is a collection.\n\n            A member of a collection is either an internal member\n            resource, which MUST have a URI that is relative to the base\n            URI of the collection, or an external member resource, which\n            has a URI which is not relative to the base URI of the\n            collection. External member resources are further subdivided\n            into propagate members, which have recursive method\n            invocations propagated to them, and no-propagate members,\n            which do not.\n\n            A collection resource may be viewed and used as a compound\n            resource in which the collection is a container for a group\n            of related resources that, together, form a larger logical\n            unit.  For example, a collection of HTML resources where\n            each resource is the chapter of a book can be viewed as a\n            compound resource representing the entire book.\n\n            Some methods, when invoked on a collection, affect the\n            entire collection.  For example, it is possible to copy an\n            entire collection and its contents with just a single copy\n            method request. The model for performing these operations is\n            a tree traversal.  The method is invoked on the collection,\n            which then performs the method on itself before propagating\n            the method to all its internal members and propagate\n            external members.  If these are non-collection resources,\n            the request method is processed.  However, if the request is\n            propagated to another collection, then the propagation\n            begins again.  This sequence of actions causes the method to\n            be propagated as a tree traversal of the members of the\n            collections.  It is incumbent upon the client to perform any\n            locking operation on the collection or subordinate members\n            that it deems necessary in order to maintain state\n            consistency during the execution of  such methods.\n\n\n            3.1.2     Creation and Retrieval of Collection Resources\n\n            Since the existing HTTP methods for creating (PUT, POST) and\n            retrieving (GET) a resource were defined for non-collection\n            resources, it is not surprising that the semantics of these\n            methods do not transfer well to collections. For example,\n            the PUT method is defined to store the request entity under\n            the Request-URI.  While a description format for a\n            collection can readily be constructed that could be used\n            with PUT, the implications of sending such a description to\n            the server are undesirable.  For example, if a description\n            of a collection that omitted some existing resources were\n            PUT to a server, this might be interpreted as a command to\n            remove those members.  This would extend PUT to perform\n            DELETE functionality, which is undesirable since it changes\n            the semantics of PUT, and makes it difficult to control\n            DELETE functionality with an access control scheme based on\n            methods.\n\n            While the POST method is sufficiently open-ended that a\n            \u201ccreate a collection\u201d POST command could be constructed,\n            this is undesirable because it would be difficult to provide\n            separate access control for collection creation and other\n            uses of POST if they both use the same method.\r\f\n\n\n\n\n\n            The GET method when applied to collections is also\n            problematic.  While it might seem desirable to have GET\n            return a listing of the members of a collection, this is\n            foiled by the existence of the \u201cindex.html\u201d de-facto\n            standard namespace redirection, in which a GET request on a\n            collection is automatically redirected to the index.html\n            resource.\n\n            Because of the difficulty of reusing some existing HTTP/1.1\n            methods for collections, two new resource creation/retrieval\n            methods are needed.  This specification introduces the MKCOL\n            method for creating collection resources, and the INDEX\n            method for retrieving the contents of a collection.\n\n            The exact definition of the behavior of GET and PUT on\n            collections is defined later in this draft. \n\n\n            3.1.3     Source Resources and Output Resources\n\n            For many resources, the entity returned by GET exactly\n            matches the persistent state of the resource, for example, a\n            GIF file stored on a disk.  For this simple case, the URL at\n            which a resource is accessed is identical to the URL at\n            which the source (the persistent state) of the resource is\n            accessed. This is also the case for HTML source files that\n            are not processed by the server prior to transmission.\n\n            However, HTML files can sometimes be processed by the server\n            before being transmitted as a return entity body.  Server-\n            side-include directives within an HTML file instruct a\n            server to replace the directive with another value, such as\n            the current date.  In this case, what is returned by GET\n            (HTML plus date) differs from the persistent state of the\n            resource (HTML plus directive). Typically there is no way to\n            access the HTML file containing the unprocessed directive.\n\n            Sometimes the entity returned by GET is the output of a\n            data-producing process that is described by one or more\n            source resources (that may not even have a location in the\n            URL namespace).  A single data-producing process may\n            dynamically generate the state of a potentially large number\n            of output resources. An example of this is a CGI script that\n            describes a \"finger\" gateway process that maps part of the\n            namespace of a server into finger requests, such as\n            http://www.foo.bar.org/finger_gateway/user@host.\n\n            In the absence of distributed authoring capability, the fact\n            that the source resource(s) for server generated output do\n            not have a mapping to the URI namespace is not a problem,\n            and has desirable security benefits. However, if remote\n            editing of the source resource(s) is desired, they should be\n            given a location in the URI namespace. This source location\n            should not be one of the locations at which the generated\n            output is retrievable, since in general it is impossible for\n            the server to differentiate requests for source resources\n            from requests for process output resources. There is often a\n            many-to-many relationship between source resources and\n            output resources.\n\n            For DAV compliant servers all output resources which have a\n            single source resource (and that source resource has a URI),\n            the URI of the source resource SHOULD be stored in a single\n            link on the output resource with type DAV:/ Source. Note\n            that by storing the source URI in links on the output\n            resources, the burden of discovering the source is placed on\n            the authoring client. \r\f\n\n\n\n\n\n            In the general case, a large number of source resources can\n            comprise a data-producing process that generates many output\n            resources, creating a many-to-many relationship between\n            output resources and source resources. If each output\n            resource had links back to every source resource in the\n            data-producing process, there can be a potentially large\n            number of such links. Due to the potentially large number of\n            links, and the lack of a policy for ordering access to\n            multiple sources, explicit storage of source relationships\n            is limited to cases with only a single source resource.\n\n\n\n            3.2 MKCOL Method\n\n            3.2.1     Problem Description\n\n            The client needs a way to create a collection.\n\n\n            3.2.2     Solution Requirements\n\n            The solution:\n\n            Must ensure that a collection has been made (i.e. that it\n               responds to the INDEX method) as opposed to a non-\n               collection resource. If a collection could not be made, it\n               must indicate a failure to the principal.\n\n            Requires that the server MAY, if necessary, create any\n               intermediate collections so that the underlying storage\n               medium is self-consistent.\n\n\n            3.2.3     Request\n\n            The MKCOL method creates a new collection resource at the\n            location specified by the Request-URI. If the Request-URI\n            exists then MKCOL must fail. \n\n            During MKCOL processing, a server MAY add the Request-URI to\n            one or more collections within the server\u2019s controlled\n            namespace.\n\n\n            3.2.3.1   MKCOL Without Request Body\n\n            When MKCOL is invoked without a request body then the\n            collection created has no members.\n\n\n            3.2.3.2   MKCOL With Request Body\n\n            A MKCOL request message MAY contain a message body.  The\n            behavior of a MKCOL request when the body is present is\n            limited to creating collections, members of a collection,\n            bodies of members and properties on the collections or\n            members. If the server receives a MKCOL request entity type\n            it does not support or understand it MUST respond with a 415\n            (Unsupported Media Type) status code.\n\n\n            3.2.3.3   Creating Multiple Collections\n\n            The server MAY create intermediate collections if they do\n            not already exist. For example, if the collection\n            http://server/a/ already exists in the server\u2019s namespace,\n            then while performing a MKCOL to create http://server/a/b/c/\n            the server may also create a collection at\n            http://server/a/b/.\r\f\n\n\n\n\n\n            3.2.4     Response\n\n            Responses from a MKCOL request are not cacheable, since\n            MKCOL has non-idempotent semantics.\n\n            201 (Created) - The structured resource was created in its\n            entirety.\n\n            403 (Forbidden) - The server does not allow the creation of\n            collections at the given location in its namespace.\n\n            415 (Unsupported Media Type)\u2013 The server does not support\n            the request type of the body.\n\n            416 (Unprocessable Entity) - A new status code.  The server\n            understands the content type of the request entity, but was\n            unable to process the contained instructions.\n\n\n            3.2.5     Example\n\n            This example creates a container collection called\n            /webdisc/xfiles/ on the server www.server.org.\n\n                 MKCOL /webdisc/xfiles/ HTTP/1.1\n                 Host: www.server.org\n\n\n                 HTTP/1.1 201 Created\n\n\n            3.3 INDEX Method\n\n            3.3.1     Problem Description\n\n            A mechanism is needed to discover if a resource is a\n            collection and if so, list its members.\n\n\n            3.3.2     Solution Requirements\n\n            The solution:\n\n            must allow a client to discover the members of a collection\n\n            must always provide a machine-readable description of the\n               membership of a collection\n\n\n            3.3.3     The Request\n\n            The INDEX method returns a machine-readable representation\n            of the membership of the resource at the Request-URI.  For a\n            collection, INDEX MUST return a machine-readable list of its\n            members.  For other resources, the information returned by\n            INDEX is undefined, and MAY vary.  The request message body\n            of an INDEX request SHOULD be ignored.\n\n            The Depth header can be used to indicate how much of a\n            result can be generated for the response. The specific\n            values allowed for the depth header when used with the INDEX\n            method are 1 and infinity. The 1 value indicates that the\n            internal and external member resources should be reported in\n            the result, infinity indicates that all internal and\n            external member resources and all their descendants should\n            be in the result. If the Depth header is not given, then 1\n            is assumed. Servers MUST honor a depth of 1. Servers MAY\n            honor infinity.  If the server does not support the value of\n            the depth header then a 412 (Precondition failed) MUST be\n            returned.\r\f\n\n\n\n\n\n            3.3.4     The Response\n\n            200 (OK) \u2013 The server MUST send an application/xml response\n            entity which describes the collection.\n\n            404 (Not Found) - Same behavior as HTTP 1.1. The server\n            never had the resource, or the server permanently deleted\n            the resource and has no knowledge that it ever existed. This\n            error code implies that, essentially, the server has no\n            information about the Request URI.\n\n\n            3.3.5     Response Message Body\n\n            The default INDEX response for a resource is an\n            application/xml HTTP entity (i.e., an Extensible Markup\n            Language (XML) document) that contains a single XML element\n            called collectionresource which describes the collection,\n            and a set of XML elements called memberesource which\n            describe the members of the collection.\n\n            The response from INDEX is cacheable, and SHOULD be\n            accompanied by an ETag header (see section 13.3.4 of RFC\n            2068). If GET and INDEX return different entities for the\n            same resource state, they MUST return different entity tags.\n\n            The server MUST transmit the following XML elements for each\n            member resource of a collection: Ref, IsCollection, Content-\n            Type, External. The server MUST transmit the following XML\n            elements if it can generate any meaningful values for them:\n            Creation-Date, Last-Modified, DisplayName, Content-Language.\n              The server SHOULD transmit Etag XML elements for each\n            member (see section 13.3.4 of RFC 2068).\n\n            The value of content-type, last-modified, and etag XML\n            elements MUST be identical to the value of the response\n            header field of the same name in the HTTP/1.1 specification.\n             Since the HTTP/1.1 header fields are described in terms of\n            the on-the-wire entity, the values presented by INDEX are\n            those that would be generated if the resource was accessed\n            using the GET method without content negotiation.\n\n\n            3.3.5.1   CollectionResource\n\n            Name: http://www.ietf.org/standards/dav/collectionresource\n\n            Purpose:  Describes a collection\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   <XML>\n\n            Value:MemberResource\n\n\n            3.3.5.2   MemberResource\n\n            Name: http://www.ietf.org/standards/dav/memberresource\n\n            Purpose:  Describes a member of a collection\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   CollectionResource\n\n            Value:Ref, IsCollection, Content-Type, External, Creation-\n            Date, Last-Modified, ETag, DisplayName (other XML elements\n            MAY also be present)\n\n\n            3.3.5.3   Ref\n\n            See XML definition.\r\f\n\n\n\n\n\n            3.3.5.4   IsCollection\n\n            Name: http://www.ietf.org/standards/dav/iscollection\n\n            Purpose:  This is a boolean value which is set to \u201ctrue\u201d if\n            the entry is a collection\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:(\u201ctrue\u201d | \u201cfalse\u201d)\n\n\n            3.3.5.5   Content-Type\n\n            Name: http://www.ietf.org/standards/dav/content-type\n\n            Purpose:  The content-type of the member resource.\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:media-type   ; defined in Section 3.7 of [HTTP11]\n             If no meaningful content-type can be generated, then an\n            empty value MUST be given.\n\n\n            3.3.5.6   External\n\n            Name: http://www.ietf.org/standards/dav/external\n\n            Purpose:  If present, this element indicates the resource is\n            an external member of the collection.  If the value is\n            \u201cpropagate,\u201d it is a propagate member, if the value is \u201cno-\n            propagate,\u201d it is a no-propagate member.\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:(\u201cpropagate\u201d | \u201cno-propagate\u201d)\n\n\n            3.3.5.7   Creation-Date\n\n            Name: http://www.ietf.org/standards/dav/creation-date\n\n            Purpose:  The date the resource was created.\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:The date MUST be given in RFC 1123 format (rfc-1123\n            production, defined in section 3.3.1 of [HTTP11]\n\n\n            3.3.5.8   Last-Modified\n\n            Name: http://www.ietf.org/standards/dav/last-modified\n\n            Purpose:  The date the resource was last modified.\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:The date MUST be given in RFC 1123 format (rfc-1123\n            production, defined in section 3.3.1 of [HTTP11]\n\n\n            3.3.5.9   ETag\n\n            Name: http://www.ietf.org/standards/dav/etag\n\n            Purpose:  The entity tag of the resource.\r\f\n\n\n\n\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:entity-tag    ; defined in Section 3.11 of [HTTP11]\n\n\n            3.3.5.10  DisplayName\n\n            Name: http://www.ietf.org/standards/dav/displayname\n\n            Purpose:  A name for the resource that is suitable for\n            presentation to a person\n\n            Schema:   http://www.ietf.org/standards/dav/\n\n            Parent:   MemberResource\n\n            Value:Any valid XML character data (from XML specification)\n\n\n            3.3.5.11  Content-Language\n\n            Name:     http://www.ietf.org/standards/dav/content-language\n\n            Purpose:  Describes the natural language(s) of the intended\n            audience for the resource.\n\n            Schema:   http://www.ietf.org.standards/dav/\n\n            Parent:   MemberResource\n\n            Value:    1#language-tag ;language-tag is defined in section\n            14.13 of RFC 2068\n\n\n\n            3.3.6     Example\n\n                 INDEX /user/yarong/dav_drafts/ HTTP/1.1\n                 Host: www.microsoft.com\n                 Depth: 1\n\n                 HTTP/1.1 200 OK\n                 Content-Type: application/xml\n                 Content-Length: xxx\n                 Last-Modified: xxx\n                 ETag: \u201cfooyyybar\u201d\n\n\n                 <XML>\n                 <XML:Namespace><Ref>http://www.ietf.org/standards/dav/<\n                 /><As>D</></>\n                 <D:CollectionResource>\n                      <MemberResource>\n                           <XML:Ref>namespace.doc</>\n                           <IsCollection>false</>\n                           <Content-Type>application/msword</>\n                           <External>false</>\n                           <Creation-Date>Thu, 20 Mar 1997 23:05:25\n                 GMT</>\n                           <Last-Modified>Fri, 22 Aug 1997 18:22:56\n                 GMT</>\n                           <Etag>8675309</>\n                           <DisplayName>WebDAV Name Space Operations\n                 Draft</>\n                           <Content-Language>en</>\n                 </>  </>\n                 </>\n\n            This example shows the result of the INDEX method applied to\r\f\n\n\n\n\n\n            the collection resource\n            http://www.microsoft.com/er/yarong/dav_drafts/.  It returns\n            a response body in XML format, which gives information about\n            the container\u2019s sole member,\n            http://www.microsoft.com/users/yarong/dav_drafts/namespace.d\n            oc.\n\n\n\n            3.4 Behavior of RFC 2068 Methods on Collections\n            With the introduction of the collection resource type to the\n            HTTP object model, it is necessary to define the behavior of\n            the existing methods (defined in RFC 2068) when invoked on a\n            collection resource to avoid ambiguity.  While some methods,\n            such as OPTIONS and TRACE behave identically when applied to\n            collections, GET, HEAD, POST, PUT, and DELETE require some\n            additional explanation.\n\n\n            3.4.1     GET, HEAD for Collections\n\n            The semantics of GET are unchanged when applied to a\n            collection, since GET is defined as, \u201cretrieve whatever\n            information (in the form of an entity) is identified by the\n            Request-URI\u201d [HTTP11]. GET when applied to a collection MAY\n            return the contents of an \u201cindex.html\u201d resource, a human-\n            readable view of the contents of the collection, or\n            something else altogether, and hence it is possible the\n            result of a GET on a collection will bear no correlation to\n            the state of the collection.\n\n            Similarly, since the definition of HEAD is a GET without a\n            response message body, the semantics of HEAD do not require\n            any modification when applied to collection resources.\n\n\n            3.4.2     POST for Collections\n\n            Since by definition the actual function performed by POST is\n            determined by the server and often depends on the particular\n            resource, the behavior of POST when applied to collections\n            cannot be modified because it is largely undefined.  Thus\n            the semantics of POST do not require any modification when\n            applied to a collection.\n\n\n            3.4.3     PUT for Collections\n\n            In HTTP/1.1, PUT stores the request entity under the\n            Request-URI, and hence its semantics are limited to non-\n            collection resources.  If a PUT is invoked on a collection\n            resource it MUST fail.\n\n            When the PUT operation creates a new non-collection\n            resource, a server MAY add that resource\u2019s URI to one or\n            more collections within the server\u2019s controlled namespace.\n\n\n            3.4.4     DELETE for Collections\n\n            When DELETE is applied to a collection resource, all\n            internal members MUST be recursively deleted. The\n            dav:link/propagate external members MUST be deleted and\n            their links must be removed. dav:link/nopropagate external\n            members MUST have only their link removed; the resources\n            MUST not be deleted.\n\n            The Depth header does not apply to the DELETE method. It\n            cannot be used to limit the extent of the operation. If it\r\f\n\n\n\n\n\n            is present it MUST be ignored.\n\n            When applied to any resource, the DELETE method deletes all\n            properties on the Request-URI. \n\n            During DELETE processing, a server MAY remove the URI of the\n            deleted resource(s) from collections within its controlled\n            namespace.\n\n\n            3.4.4.1   New Response Codes for DELETE\n\n            207 (Partial Success) Only some of the member resources were\n            deleted. The response entity will describe any errors.\n\n            500 (Server Error) The resource was in such a state that it\n            could not be deleted. The response entity will describe\n            reason for the error.\n\n            3.5 COPY Method\n\n            3.5.1     Problem Description\n\n            Currently, in order to create a copy of a resource, the\n            client must GET an entity and then PUT that entity to the\n            desired destination. This requires (1) an entity to be\n            transmitted to and from the server and (2) that the resource\n            be expressible as an entity with complete fidelity.\n\n            This is problematic because of the network traffic involved\n            in making a copy, and because there is often no way to fully\n            express a resource as an entity without a loss of fidelity.\n\n\n            3.5.2     Solution Requirements\n\n            The solution:\n\n            MUST allow a principal to create a copy of a resource\n               without having to transmit the resource to and from the\n               server.\n\n\n            3.5.3     The Request\n\n            The COPY method creates a duplicate of the source resource,\n            given by the Request-URI, in the destination resource, given\n            by the Destination header.  The Destination header MUST be\n            present.  The exact behavior of the COPY method depends on\n            the type of the source resource.\n\n\n            3.5.3.1   COPY for HTTP/1.1 resources\n\n            When the source resource is not a collection, and is not a\n            property, the body of the destination resource MUST be\n            octet-for-octet identical to the body of the source\n            resource. Alterations to the destination resource do not\n            modify the source resource. Alterations to the source\n            resource do not modify the destination resource. Thus, all\n            copies are performed \u201cby-value\u201d.\n\n            If the Duplicate-Properties header is \u201cfalse,\u201d then\n            properties SHOULD NOT be copied to the destination resource.\n            If the Duplicate-Properties header is \u201cfalse\u201d and the\n            Enforce-Live-Properties header is also present, the request\n            MUST fail with a 412 (Precondition Failed) status code. \n            [Ed. Note: what if resource to be copied has no properties,\n            and no properties are explicitly named in the header?]\n\n            All properties on a source resource SHOULD be duplicated on\r\f\n\n\n\n\n\n            the destination resource following the definition for\n            copying properties.\n\n\n            3.5.3.2   COPY for Properties\n\n            Live properties SHOULD be duplicated as identically behaving\n            live properties at the destination resource. Since they are\n            live properties, the server determines the syntax and\n            semantics (hence value) of these properties.  Properties\n            named by the Enforce-Live-Properties header MUST be live on\n            the destination resource, or the method MUST fail.  If a\n            property is not named by Enforce-Live-Properties and cannot\n            be copied live, then its value MUST be duplicated in an\n            identically named, dead resource on the destination\n            resource.\n\n            For every dead property defined on the source resource,\n            there SHOULD be an octet-for-octet identical dead property\n            on the destination resource.\n\n\n            3.5.3.3   COPY for Collections\n\n            The Depth and Overwrite headers govern the behavior of COPY\n            for collections.  \n\n            When performing a recursive copy, all HTTP/1.1 request\n            headers are duplicated on the propagated method request\n            except for the precondition headers If-Modified-Since, If-\n            Match, If-None-Match, If-Range, If-Unmodified-Since, which\n            should only be applied to the Request-URI in order to\n            determine if the operation should be performed. The\n            Destination header MUST be rewritten to preserve the\n            membership of the destination collection, i.e., by appending\n            the relative URI of the member to the URI of the destination\n            collection.\n\n            A Depth of \u201c0\u201d indicates the collection MUST duplicate all\n            of its external members in a new collection at the\n            Destination. Since the COPY method is not propagated to its\n            members, no internal member resource is duplicated.\n\n            A Depth of \u201c1\u201d indicates the collection MUST propagate the\n            COPY to all internal, non-collection members.  If the\n            Overwrite header is \u201ctrue\u201d the COPY method duplicates all of\n            its external members in a new collection at the Destination.\n            If the Overwrite header is \u201cfalse\u201d and the destination\n            resource is a collection, the COPY method does not duplicate\n            its external members, but is propagated to all internal,\n            non-collection members.\n\n            A Depth of \u201cinfinity\u201d indicates the collection MUST\n            propagate the COPY method to all internal members. If the\n            Overwrite header is \u201ctrue,\u201d the COPY method MUST duplicate\n            all of its external members in a new collection at the\n            Destination. If the Overwrite header is \u201cfalse\u201d and the\n            destination resource is a collection, then the COPY method\n            does not duplicate its external members, but is propagated\n            to all internal members.\n\n\n            3.5.3.4   Type Interactions\n\n            If the destination resource identifies a property and the\n            source resource is not a property, then the copy SHOULD\n            fail.\n\n            If the destination resource identifies a collection and the\n            Overwrite header is \u201ctrue,\u201d prior to performing the copy,\r\f\n\n\n\n\n\n            the server MUST perform a DELETE operation on the\n            collection.\n\n\n            3.5.4     The Response\n\n            200 (OK) The source resource was successfully copied to a\n            pre-existing destination resource.\n\n            201 (Created) The source resource was successfully copied. \n            The copy operation resulted in the creation of a new\n            resource.\n\n            207 (Partial Success) Only some of the member resources were\n            copied. The return entity body describes the status code for\n            each resource.\n\n            412 (Precondition Failed) This status code MUST be returned\n            if the server was unable to maintain the liveness of the\n            properties listed in the Enforce-Live-Properties header, or\n            if the Overwrite header is false, and the state of the\n            destination resource is non-null.\n\n            500 (Server Error) The resource was in such a state that it\n            could not be copied. This may occur if the Destination\n            header indicated an external (from the point of view of the\n            server) resource and the server has no capability to copy to\n            an external resource.\n\n            502 (Bad Gateway) - This may occur when copying to external\n            resources and the destination server refused to accept the\n            resource.\n\n\n            3.5.5     Examples\n\n\n            3.5.5.1   Overwrite Example\n\n            This example shows resource\n            http://www.ics.uci.edu/~fielding/index.html being copied to\n            the location\n            http://www.ics.uci.edu/users/f/fielding/index.html.  The\n            contents of the destination resource were overwritten, if\n            non-null.\n\n\n                 COPY /~fielding/index.html HTTP/1.1\n                 Host: www.ics.uci.edu\n                 Destination:\n                 http://www.ics.uci.edu/users/f/fielding/index.html\n                 Overwrite: \u201ctrue\u201d\n\n\n                 HTTP/1.1 200 OK\n\n            3.5.5.2   No Overwrite Example\n\n            The following example shows the same copy operation being\n            performed, except with the Overwrite header set to \u201cfalse.\u201d\n             A response of 412, Precondition Failed, is returned because\n            the destination resource has a non-null state.\n\n                 COPY /~fielding/index.html HTTP/1.1\n                 Host: www.ics.uci.edu\n                 Destination:\n                 http://www.ics.uci.edu/users/f/fielding/index.html\n\n\n                 HTTP/1.1 412 Precondition Failed\r\f\n\n\n\n\n\n\n\n            3.6 MOVE Method\n\n            3.6.1     Problem Description\n\n            The move operation on a resource is the logical equivalent\n            of a copy followed by a delete.\n\n            In HTTP 1.1, the procedure could be performed in several\n            steps. First, the client could issue a GET to retrieve a\n            representation of a resource, issue a DELETE to remove the\n            resource from the server, then use PUT to place the resource\n            on the server with a new URI. As is the case for COPY -\n            because of the network traffic involved in making a move,\n            and because there is often no way to fully express a\n            resource as an entity without a loss of fidelity - server\n            move functionality is preferable.\n\n            With a DAV server, a principal may accomplish this task by\n            issuing a COPY and then DELETE. Network load decreases, but\n            the server load may still be significant because the server\n            must create a duplicate resource. Were a server to know\n            beforehand that a principal intended to perform COPY and\n            DELETE operations in succession, it could avoid the creation\n            of a duplicate resource.\n\n\n            3.6.2     Solution Requirements\n\n            The solution:\n\n            Must prevent the unneeded transfer of entity bodies from and\n               to the server.\n\n            Must prevent the unneeded creation of copies by the server.\n\n\n            3.6.3     The Request\n\n            The MOVE method is defined as the logical equivalent of a\n            COPY followed by a DELETE of the source resource, performed\n            atomically.\n\n\n            3.6.4     The Response\n\n            200 (OK) - The resource was moved. A successful response\n            must contain the Content-Location header, set equal to the\n            URI in source. This lets caches properly flush any cached\n            entries for the source. Unfortunately the Content-Location\n            header only allows a single value so it is not possible for\n            caches unfamiliar with the MOVE method to properly clear\n            their caches.\n\n            207 (Partial Success) Only some of the member resources were\n            moved.  The return entity body will give the status code for\n            each resource.\n\n            412 (Precondition Failed) This status code MUST be returned\n            if the server was unable to maintain the liveness of the\n            properties listed in the Enforce-Live-Properties header, or\n            if the Overwrite header is false, and the state of the\n            destination resource is non-null.\n\n            501 (Not Implemented) - This may occur if the Destination\n            header specifies a resource which is outside its domain of\n            control (e.g., stored on another server) resource and the\n            server either refuses or is incapable of moving to an\n            external resource.\r\f\n\n\n\n\n\n            502 (Bad Gateway) - This may occur when moving to external\n            resources and the destination server refused to accept the\n            resource.\n\n\n            3.6.5     Examples\n\n\n            3.6.5.1   Overwrite Example\n\n            This example shows resource\n            http://www.ics.uci.edu/~fielding/index.html being moved to\n            the location\n            http://www.ics.uci.edu/users/f/fielding/index.html.  The\n            contents of the destination resource were overwritten, if\n            non-null.\n\n                 MOVE /~fielding/index.html HTTP/1.1\n                 Host: www.ics.uci.edu\n                 Destination:\n                 http://www.ics.uci.edu/users/f/fielding/index.html\n                 Overwrite: true\n\n\n                 HTTP/1.1 200 OK\n                 Content-Location:\n                 http://www.ics.uci.edu/users/f/fielding/index.html\n\n            3.7 Multi-Status Response\n\n            3.7.1     Problem Definition\n\n            Certain methods (COPY, MOVE, and DELETE) when applied to a\n            collection might be recursively applied to all sub-members\n            of the collection.  In this case, it is possible that the\n            operation will succeed on some member resources and fail on\n            others, thus generating a 207 (Partial Success) status code.\n             A principal may need to know which members of the\n            collection succeeded and which failed.\n\n\n            3.7.2     Solution Requirements\n\n            The solution must:\n\n            - communicate the status code and reason\n\n            - give the URI of the resource on which the method was\n               invoked\n\n            - be consistent with other return body formats\n\n\n            3.7.3     Multi-Status Response\n\n            The default multi-status response body is an application/xml\n            HTTP entity that contains a single XML element called\n            multiresponse, which contains a set of XML elements called\n            response, one for each 200, 300, 400, and 500 series status\n            code generated during the method invocation.  100 series\n            status codes MUST NOT be recorded in a response XML element.\n            Each response XML element contains two sub-entities, ref,\n            the URI of the resource on which the method was invoked, and\n            status, which holds the status-line from the method\n            invocation.\n\n            A multi-status response MUST be present when a 207 (Partial\n            Success) status code is returned by the initial method\n            invocation.\r\f\n\n\n\n\n\n            3.7.3.1   MultiResponse\n\n            Name:\n                   http://www.ietf.org/standards/dav/multiresponse/multi\n            response\n\n            Purpose:  Contains multiple response messages.\n\n            Schema:   http://www.ietf.org/standards/dav/multiresponse/\n\n            Parent:   <XML>\n\n            Value:1*Response\n\n\n            3.7.3.2   Response\n\n            Name:\n                   http://www.ietf.org/standards/dav/multiresponse/respo\n            nse\n\n            Purpose:  Holds a single response\n\n            Schema:   http://www.ietf.org/standards/dav/multiresponse/\n\n            Parent:   MultiResponse\n\n            Value:Ref, Status\n\n\n            3.7.3.3   Status\n\n            Name:\n                   http://www.ietf.org/standards/dav/multiresponse/statu\n            s\n\n            Purpose:  Holds a single HTTP status-line\n\n            Schema:   http://www.ietf.org/standards/dav/multiresponse/\n\n            Parent:   Response\n\n            Value:status-line   ;status-line defined in [HTTP11]\n\n\n            3.7.4     Example\n\n\n            COPY /users/jdoe/collection/ HTTP/1.1\n            Host: www.doecorp.com\n            Destination:\n            http://www.doecorp.com/users/jdoe/othercollection/\n            Depth: infinity\n            Overwrite: false\n\n\n            HTTP/1.1 207 Partial Success\n            Content-Type: application/xml\n            Content-Length: xxx\n\n            <XML>\n            <XML:Namespace><Ref>http://www.ietf.org/standards/dav/multir\n            esponse/</><As>R</></>\n            <R:MultiResponse>\n                 <Response>\n\n                 <XML:Ref>http://www.doecorp.com/users/jdoe/collection/i\n            ndex.html</>\n                      <Status>HTTP/1.1 412 Precondition Failed</>\n                 </>\n                 <Response>\r\f\n\n\n\n\n\n                 <XML:Ref>http://www.doecorp.com/users/jdoe/collection/r\n            eport.html</>\n                      <Status>HTTP/1.1 200 OK</>\n                 </>\n            </>\n            </>\n\n\n            3.8 ADDREF Method\n\n            3.8.1     Problem Definition\n\n            There needs to be a way to add an external member to a\n            collection.\n\n\n            3.8.2     Solution Requirements\n\n            The solution must:\n\n            allow access control\n\n            allow referencing to URIs of external members\n\n            not require a body\n\n\n            3.8.3     The Request\n\n            The ADDREF method adds the URI specified in the Collection-\n            Member header as an external member to the collection\n            specified by the Request-URI. The value in the Collection-\n            Member header MUST be an absolute URI meeting the\n            requirements of an external member URI.  The propagation\n            type of the external URI is specified in the Collection-\n            Member Header.\n\n\n\n            3.9 DELREF Method\n\n            3.9.1     Problem Definition\n\n            There needs to be a way to remove an external member from a\n            collection.\n\n\n            3.9.2     Solution Requirements\n\n            The solution must:\n\n            allow access control\n\n            allow referencing to URIs of external members\n\n            not require a body\n\n\n            3.9.3     The Request\n\n            The DELREF method removes the URI specified in the\n            Collection-Member header from the collection specified by\n            the Request-URI.\r\f\n\n\n\n\n\n            3.10 PATCH Method\n\n            3.10.1    Problem Definition\n\n            At present, if a principal wishes to modify a resource, they\n            must issue a GET against the resource, modify their local\n            copy of the resource, and then issue a PUT to place the\n            modified resource on the server. This procedure is\n            inefficient because the entire entity for a resource must be\n            transmitted to and from the server in order to make even\n            small changes.  Ideally, the update entity transmitted to\n            the server should be proportional in size to the\n            modifications.\n\n\n            3.10.2    Solution Requirements\n\n            The solution must:\n\n            allow partial modification of a resource without having to\n               transmit the entire modified resource\n\n            allow byte-range patching\n\n            allows extensions so that patches can be done beyond simple\n               byte-range patching\n\n            allow ranges to be deleted, inserted, and replaced\n\n\n            3.10.3    The Request\n\n            The PATCH method contains a list of differences between the\n            original version of the resource identified by the Request-\n            URI and the desired content of the resource after the PATCH\n            action has been applied. The list of differences is in a\n            format defined by the media type of the entity (e.g.,\n            \"application/diff\") and must include sufficient information\n            to allow the server to convert the original version of the\n            resource to the desired version. \n\n            Since the semantics of PATCH are non-idempotent, responses\n            to this method are not cacheable. \n\n            If the request appears (at least initially) to be\n            acceptable, the server MUST transmit an interim 100 response\n            message after receiving the empty line terminating the\n            request headers and continue processing the request.  \n\n            While server support for PATCH is optional, if a server does\n            support PATCH, it MUST support at least the application/xml\n            diff format defined below.  Support for the VTML difference\n            format [VTML] is recommended, but not required.\n\n\n            3.10.4    application/XML elements for PATCH\n\n            The resourceupdate XML elementXML element contains a set of\n            XML sub-entities that describe modification operations.  The\n            name and meaning of these XML elements is given below.\n            Processing of these directives MUST be performed in the\n            order encountered within the XML document.  A directive \n            operates on the resource as modified by all previous\n            directives (executed in sequential order).\n\n\n            3.10.4.1  ResourceUpdate\n\n            Name:\n                   http://www.ietf.org/standards/dav/patch/resourceupdat\n            e\r\f\n\n\n\n\n\n            Purpose:  Contains an ordered set of changes to a non-\n            collection, non-property resource.\n\n            Schema:   http://www.ietf.org/standards/dav/patch/\n\n            Parent:   <XML>\n\n            Value:*(Insert | Delete | Replace)\n\n\n            3.10.4.2  Insert\n\n            Name: http://www.ietf.org/standards/dav/patch/insert\n\n            Purpose:  Insert the XML elementXML element\u2019s contents\n            starting exactly at the specified octet.\n\n            Schema:   http://www.ietf.org/standards/dav/patch/\n\n            Parent:   ResourceUpdate\n\n            Value:The insert XML elementXML element MUST contain an\n            octet XML elementXML element that specifies an octet\n            position within the body of a resource.  A value of \u201cend\u201d\n            specifies the end of the resource.  The body of the insert\n            XML elementXML element contains the octets to be inserted.\n\n\n            3.10.4.3  Delete\n\n            Name: http://www.ietf.org/standards/dav/patch/delete\n\n            Purpose:  Removes the specified range of octets.\n\n            Schema:   http://www.ietf.org/standards/dav/patch/\n\n            Parent:   ResourceUpdate\n\n            Value:The Delete XML elementXML element MUST contain an\n            octet-range XML elementXML element. The value of this XML\n            elementXML element is empty.\n\n            Discussion: The octets which are deleted are removed, which\n            means the resource is collapsed and the length of the\n            resource is decremented by the size of the octet range.  It\n            is not appropriate to replace deleted octets with zeroed-out\n            octets, since zero is a valid octet value.\n\n\n            3.10.4.4  Replace\n\n            Name: http://www.ietf.org/standards/dav/patch/replace\n\n            Purpose:  Replaces the specified range of octets with the\n            contents of the XML element.  If the number of octets in the\n            XML element is different from the number of octets\n            specified, the update MUST be rejected.\n\n            Schema:   http://www.ietf.org/standards/dav/patch/\n\n            Parent:   ResourceUpdate\n\n            Value:The Replace XML element MUST contain an octet-range\n            XML element.  The contents of the entity are the replacement\n            octets.\n\n\n            3.10.4.5  Octet-Range Attribute\n\n            Name:\n                 http://www.ietf.org/standards/dav/patch/octet-range\n\n            Purpose:  Specifies a range of octets which the enclosing\n            property effects.\r\f\n\n\n\n\n\n            Schema:   http://www.ietf.org/standards/dav/patch/\n\n            Parent:        Insert, Delete, Replace\n\n            Value:         number [\u201c-\u201c (number | \u201cend\u201d)]\n\n                      Number = 1*Digit\n\n            Description: Octet numbering begins with 0. If the octet\n            contains a single number then the operation is to begin at\n            that octet and to continue for a length specified by the\n            operation. In the case of a delete, this would mean to\n            delete but a single octet. In the case of an insert this\n            would mean to begin the insertion at the specified octet and\n            to continue for the length of the included value, extending\n            the resource if necessary. In the case of replace, the\n            replace begins at the specified octet and overwrites all\n            that follow to the length of the included value.  Octet\n            values MUST specify locations in the state of the resource\n            prior to the processing of the PATCH method.\n\n\n            3.10.5    The Response\n\n            200 (OK) - The request entity body was processed without\n            error, resulting in an update to the state of the resource.\n\n            409 (Conflict) - If the update information in the request\n            message body does not make sense given the current state of\n            the resource (e.g., an instruction to delete a non-existent\n            line), this status code MAY be returned.\n\n            415 (Unsupported Media Type) - The server does not support\n            the content type of the update instructions in the request\n            message body.\n\n            416 (Unprocessable Entity) - A new status code.  The server\n            understands the content type of the request entity, but was\n            unable to process the contained instructions.\n\n\n            3.10.6    Examples\n\n\n            3.10.6.1  HTML file modification\n\n            The following example shows a modification of the title and\n            contents of the HTML resource\n            http://www.example.org/hello.html.\n\n            Before:\n\n                 <HTML>\n                 <HEAD>\n                 <TITLE>Hello world HTML page</TITLE>\n                 </HEAD>\n                 <BODY>\n                 <P>Hello, world!</P>\n                 </BODY>\n                 </HTML>\n\n            PATCH Request:                     Response:\n\n                 PATCH hello.html HTTP/1.1\n                 Host: www.example.org\n                 Content-Type: application/xml\n                 Content-Length: xxx\n\n                                               HTTP/1.1 100 Continue\n                 <XML>\n                 <XML:Namespace><ref>http://www.ietf.org/standards/dav/p\r\f\n\n\n\n\n\n                 atch/</><AS>D</></>\n                 <D:ResourceUpdate>\n                      <Replace><octet-range>14</>&003CTITLE&003ENew\n                 Title&003C/TITLE&003E</>\n                      <Delete><octet-range>38-50</>\n                      <Insert><octet-range>86</>&003CP&003ENew\n                 paragraph&003C/P&003E\n                 </>\n                 </></>\n                                               HTTP/1.1 200 OK\n            After:\n\n                 <HTML>\n                 <HEAD>\n                 <TITLE>New Title</TITLE>\n                 </HEAD>\n                 <BODY>\n                 <P>Hello, world!</P>\n                 <P>New paragraph</P>\n                 </BODY>\n                 </HTML>\n\n\n            3.11 Headers\n\n            3.11.1    Depth\n\n            The Depth header determines the depth to which a method is\n            propagated on a resource\u2019s children.\n\n                 Depth = \u201cDepth\u201d \u201c:\u201d DepthToken\n                 DepthToken = \"0\" | \"1\" | \"infinity\" | token\n\n\n            The optional token allows for extension. A server MUST\n            ignore a Depth header with an unknown value.\n\n\n            3.11.2    Destination\n\n            The Destination header specifies a destination resource for\n            methods such as COPY and MOVE, which take two URIs as\n            parameters.\n\n                 Destination= \u201cDestination\u201d \u201c:\u201d URI\n\n            3.11.3    Enforce-Live-Properties\n\n            The Enforce-Live-Properties header specifies properties that\n            MUST be \u201clive\u201d after they are copied (moved) to the\n            destination resource of a copy (or move). If the value \u201c*\u201d\n            is given for the header, then it designates all live\n            properties on the source resource. \n\n                 EnforceLiveProperties = \"Enforce-Live-Properties\u201d \u201c:\"\n                 (\u201c*\u201d | 1#( Property-Name ))\n                 Property-Name = <\u201c> URI <\u201c>\n\n\n            3.11.4    Duplicate-Properties\n\n            The Duplicate-Properties header instructs the server whether\n            to duplicate the source resource\u2019s properties onto the\n            destination resource during a COPY or MOVE.  A value of\n            \u201cfalse\u201d requires that the server MUST NOT duplicate on the\n            destination resource any properties that are defined on the\n            source resource.  By default, the value of this header is\n            \u201ctrue,\u201d and a client MAY omit this header from a request\n            when its value is \u201ctrue.\u201d\r\f\n\n\n\n\n\n                 Duplicate-Properties = \u201cDuplicate-Properties\u201d \u201c:\u201d\n                 (\u201ctrue\u201d | \u201cfalse\u201d)\n\n            3.11.5    Overwrite\n\n            The Overwrite header specifies whether the server should\n            overwrite the state of a non-null destination resource\n            during a COPY or MOVE.  A value of \u201cfalse\u201d states that the\n            server MUST NOT perform the COPY or MOVE operation if the\n            state of the destination resource is non-null. By default,\n            the value of Overwrite is \u201cfalse,\u201d and a client MAY omit\n            this header from a request when its value is \u201cfalse.\u201d While\n            the Overwrite header appears to duplicate the functionality\n            of the If-Match: * header of HTTP/1.1, If-Match applies only\n            to the Request-URI, and not to the Destination of a COPY or\n            MOVE.\n\n                 Overwrite = \u201cOverwrite\u201d \u201c:\u201d (\u201ctrue\u201d | \u201cfalse\u201d)\n\n            3.11.6    Destroy Header\n\n            When deleting a resource the client often wishes to specify\n            exactly what sort of delete is being enacted. The Destroy\n            header, used with PEP, allows the client to specify the end\n            result they desire. The Destroy header is specified as\n            follows:\n\n                 DestroyHeader = \"Destroy\" \":\" #Choices\n                 Choices = \"VersionDestroy\" | \"NoUndelete\" | \"Undelete\"\n                 | Token\n\n            The Undelete token requests that, if possible, the resource\n            should be left in a state such that it can be undeleted. The\n            server is not required to honor this request.\n\n            The NoUndelete token requests that the resource MUST NOT be\n            left in a state such that it can be undeleted.\n\n            The VersionDestroy token includes the functionality of the\n            NoUndelete token and extends it to include having the server\n            remove all versioning references to the resource that it has\n            control over.\n\n\n            3.11.7    Collection-Member Header\n\n            The Collection-Member header specifies the URI of an\n            external resource to be added/deleted to/from a collection.\n\n                 CollectionMember = \u201cCollection-Member\u201d \u201c:\u201d PropType SP\n                 URI\n                 PropType = \u201cpropagation\u201d \u201c=\u201d (\u201cprop\u201d | \u201cnoprop\u201d)\n\n\n            3.12 Links\n\n            3.12.1    Source Link Property Type\n\n            Name: http://www.ietf.org/standards/dav/link/source\n\n            Purpose:  The destination of the source link identifies the\n            resource that contains the unprocessed source of the link\u2019s\n            source.\n\n            Schema:   http://www.ietf.org/standards/dav/link/\n\n            Parent:   Any.\n\n            Value:An XML document with zero or more link XML elements.\n\n            Discussion: The source of the link (src) is typically the\r\f\n\n\n\n\n\n            URI of the output resource on which the link is defined, and\n            there is typically only one destination (dst) of the link,\n            which is the URI where the unprocessed source of the\n            resource may be accessed.  When more than one link\n            destination exists, DAV asserts no policy on partial\n            ordering.\n\n\n\n            4  State Tokens\n\n            4.1 Overview\n\n            4.1.1     Problem Description\n\n            There are times when a principal will want to predicate\n            successful execution of a method on the current state of a\n            resource.  While HTTP/1.1 provides a mechanism for\n            conditional execution of methods using entity tags via the\n            \u201cIf-Match\u201d and \u201cIf-None-Match\u201d headers, the mechanism is not\n            sufficiently extensible to express conditional statements\n            involving more generic state indicators, such as lock\n            tokens. \n\n            The fundamental issue with entity tags is that they can only\n            be generated by a resource. However there are times when a\n            client will want to be able to share state tokens between\n            resources, potentially on different servers, as well as be\n            able to generate certain types of lock tokens without first\n            having to communicate with a server.\n\n            For example, a principal may wish to require that resource B\n            have a certain state in order for a method to successfully\n            execute on resource A. If the client submits an e-tag from\n            resource B to resource A, then A has no way of knowing that\n            the e-tag is meant to describe resource B.\n\n            Another example occurs when a principal wishes to predicate\n            the successful completion of a method on the absence of any\n            locks on a resource. It is not sufficient to submit an \u201cIf-\n            None-Match: *\u201d as this refers to the existence of an entity,\n            not of a lock.\n\n            This draft defines the term \u201cstate token\u201d as an identifier\n            for a state of a resource. The sections below define\n            requirements for state tokens and provide a  state token\n            syntax, along with two new headers which can accept the new\n            state token syntax.\n\n\n            4.1.2     Solution Requirements\n\n\n            4.1.2.1   Syntax\n\n            Self-Describing. A state token must be self describing such\n            that upon inspecting a state token it is possible to\n            determine what sort of state token it is, what resource(s)\n            it applies to, and what state it represents.\n\n            This self-describing nature allows servers to accept tokens\n            from other servers and potentially be able to coordinate\n            state information cross resource and cross site through\n            standardized protocols. For example, the execution of a\n            request on resource A can be predicated on the state of\n            resource B, where A and B are potentially on different\n            servers.\n\n            Client Generable. The state token syntax must allow, when\r\f\n\n\n\n\n\n            appropriate, for clients to generate a state token without\n            having first communicated with a server.\n\n            One drawback of entity tags is that they are set by the\n            server, and there is no interoperable algorithm for\n            calculating an entity tag. Consequently, a client cannot\n            generate an entity tag from a particular state of a\n            resource.  However, a state token which encodes an MD5 state\n            hash could be calculated by a client based on a client-held\n            state of a resource, and then submitted to a server in a\n            conditional method invocation.\n\n            Another potential use for client generable state tokens is\n            for a client to generate lock tokens with wild card fields,\n            and hence be able to express conditionals such as: \u201conly\n            execute this GET if there are no write locks on this\n            resource.\u201d\n\n\n            4.1.2.2   Conditonals\n\n            Universal. A solution must be applicable to all requests.\n\n            Positive and Negative. Conditional expressions must allow\n            for the expression of both positive and negative state\n            requirements.\n\n            4.2 State Token Syntax\n            State tokens are URLs employing the following syntax:\n\n            State-Token = \u201cStateToken:\u201d Type \u201c:\u201d Resources \u201c:\u201d State-\n            Info\n            Type = \u201cType\u201d \u201c=\u201d Caret-encoded-URL\n            Resources = \u201cRes\u201d \u201c=\u201d Caret-encoded-URL\n            Caret-encoded-URL = \u201c^\u201d Resource \u201c^\u201d\n            Resource = <A URI where all \u201c^\u201d characters are escaped>\n            State-Info = *(uchar | reserved)  ; uchar, reserved defined\n            section 3.2.1 of RFC 2068\n\n\n            This proposal has created a new URL scheme for state tokens\n            because a state token names a network resource using its\n            normal name, which is typically state-invariant, along with\n            additional information that specifies a particular state of\n            the resource.  Encoding the state information into the\n            native URL scheme of the network resource was not felt to be\n            safe, since freedom from name space collisions could not be\n            guaranteed. If this proposal is accepted, the StateToken URL\n            scheme will need to be defined and registered with IANA.\n\n            State Token URLs begin with the URL scheme name \u201cStateToken\u201d\n            rather than the name of the particular state token type they\n            represent in order to make the URL self describing. Thus it\n            is possible to examine the URL and know, at a minimum, that\n            it is a state token.\n\n            Labeled name/value pairs are used within the token to allow\n            new fields to be added. Processors of state tokens MUST be\n            prepared to accept the fields in whatever order they are\n            present and MUST ignore any fields they do not understand.\n\n            The \u201cType\u201d field specifies the type of the state information\n            encoded in the state token. A URL is used in order to avoid\n            namespace collisions.\n\n            The \u201cRes\u201d field identifies the resource for which the state\n            token specifies a particular state. Since commas and spaces\n            are acceptable URL characters, a caret is used to delimit a\n            URL. Since a caret is an acceptable URL character, any\r\f\n\n\n\n\n\n            instances of it must be escaped using the % escape\n            convention.\n\n            The State-Info production is expanded upon in descriptions\n            of specific state token types, and is intended to contain\n            the state description information for a particular state\n            token.\n\n            4.3 State Token Conditional Headers\n\n            4.3.1     If-State-Match\n\n            If-State-Match = \"If-State-Match\" \":\" (\u201cAND\u201d | \u201cOR\u201d) 1#(\u201c<\u201d\n            State-Token \u201c>\u201d)\n\n            The If-State-Match header is intended to have similar\n            functionality to the If-Match header defined in section\n            14.25 of RFC 2068.\n\n            If the AND keyword is used and all of the state tokens\n            identify the state of the resource, then the server MAY\n            perform the requested method. If the OR keyword is used and\n            any of the state tokens identifies the current state of the\n            resource, then server MAY perform the requested method.  If\n            neither of the keyword requirements is met, the server MUST\n            NOT perform the requested method, and MUST return a 412\n            (Precondition Failed) response.\n\n            4.3.2     If-None-State-Match\n\n            If-None-State-Match = \"If-None-State-Match\" \u201c:\u201d 1#(\u201c<\u201d\n            State-Token \u201c>\u201d)\n\n            The If-None-State-Match header is intended to have similar\n            functionality to the If-None-Match header defined in section\n            14.26 of RFC 2068.\n\n            If any of the state tokens identifies the current state of\n            the resource, the server MUST NOT perform the requested\n            method.  Instead, if the request method was GET, HEAD,\n            INDEX, or GETMETA, the server SHOULD respond with a 304 (Not\n            Modified) response, including the cache-related entity-\n            header fields (particularly ETag) of the current state of\n            the resource.  For all other request methods, the server\n            MUST respond with a status of 412 (Precondition Failed).\n\n            If none of the state tokens identifies the current state of\n            the resource, the server MAY perform the requested method.\n\n            Note that the \u201cAND\u201d and \u201cOR\u201d keywords specified with the If-\n            State-Match header are intentionally not defined for If-\n            None-State-Match, because this functionality is not\n            required.\n\n            4.4 State Token Header\n            State-Token-Header = \u201cState-Token\u201d \u201c:\u201d 1#(\u201c<\u201d State-Token\n            \u201c>\u201d)\n            The State Token header is intended to have similar\n            functionality to the etag header defined in section 14.20 of\n            RFC 2068. The purpose of the tag is to return state tokens\n            defined on a resource in a response. The contents of the\n            state-token are not guaranteed to be exhaustive and are\n            generally used to return a new state token that has been\n            defined as the result of a method. For example, if a LOCK\n            method were successfully executed on a resource the response\n            would include a state token header with the lock state token\n            included.\r\f\n\n\n\n\n\n            4.5 E-Tags\n            E-tags have already been deployed using the If-Match and If-\n            None-Match headers.  Introducing two mechanisms to express\n            e-tags would only confuse matters, therefore e-tags should\n            continue to be expressed using quoted strings and the If-\n            Match and If-None-Match headers.\n\n\n\n            5  Locking\n\n            5.1 Problem Description - Overview\n            Locking is used to arbitrate access to a resource amongst\n            principals that have equal access rights to that resource.\n\n            This draft allows locks to vary over two parameters, the\n            number of principals involved and the type of access to be\n            granted. This draft will only provide for the definition of\n            locking for one access type, write. However, the syntax is\n            extensible enough to allow for the specification of other\n            access types. It is a goal of this proposal that it use the\n            same access verbs as will be defined in the access control\n            draft.\n\n\n            5.1.1     Exclusive Vs. Shared Locks\n\n            The most basic form of LOCK is an exclusive lock. This is a\n            lock where the access right in question is only granted to a\n            single principal. The need for this arbitration results from\n            a desire to avoid having to constantly merge results. In\n            fact, many users so dislike having to merge that they would\n            rather serialize their access to a resource rather than have\n            to constantly perform merges.\n\n            However, there are times when the goal of a lock is not to\n            exclude others from exercising an access right but rather to\n            provide a mechanism for principals to indicate that they\n            intend to exercise their access right.  Shared locks are\n            provided for this case. A shared lock allows multiple\n            principals to receive a lock, hence any principal with\n            appropriate access can get the lock.\n\n            With shared locks there are two trust sets that affect a\n            resource.  The first trust set is created by access\n            permissions. Principals who are trusted, for example, may\n            have permission to write the resource, those who are not,\n            don't.  Among those who have access permission to write the\n            resource, the set of principals who have taken out a shared\n            lock also must trust each other, creating a (probably)\n            smaller trust set within the access permission write set.\n\n            Starting with every possible principal on the Internet, in\n            most situations the vast majority of these principals will\n            not have write access to a given resource.  Of the small\n            number who do have write access, some principals may decide\n            to guarantee their edits are free from overwrite conflicts\n            by using exclusive write locks in conjunction with a\n            precondition header (If-State-Match) that checks for\n            existence of the lock prior to writing the resource. Others\n            may decide they trust their collaborators (the potential set\n            of collaborators being the set of principals who have write\n            permission) and use a shared lock, which informs their\n            collaborators that a principal is potentially working on the\n            resource.\n\n            The WebDAV extensions to HTTP do not need to provide all of\n            the communications paths necessary for principals to\r\f\n\n\n\n\n\n            coordinate their activities.  When using shared locks,\n            principals may use any out of band communication channel to\n            coordinate their work (e.g., face-to-face interaction,\n            written notes, post-it notes on the screen, telephone\n            conversation, email).  The intent of a shared lock is to let\n            collaborators know who else is potentially working on a\n            resource..\n\n            Why not use exclusive write locks all the time?  Experience\n            from initial Web distributed authoring systems has indicated\n            that exclusive write locks are often too rigid.  An\n            exclusive write lock is used to enforce a particular editing\n            process: take out exclusive write lock, read the resource,\n            perform edits, write the resource, release the lock.  What\n            happens if the lock isn't released?  While the time-out\n            mechanism provides one solution, if you need to force the\n            release of a lock immediately, it doesn't help much. \n            Granted, an administrator can release the lock for you, but\n            this could become a significant burden for large sites.\n            Further, what if the administrator can't be reached\n            immediately?\n\n            Despite their potential problems, exclusive write locks are\n            extremely useful, since often a guarantee of freedom from\n            overwrite conflicts is exactly what is needed.  The\n            solution: provide exclusive write locks, but also provide a\n            less strict mechanism in the form of shared locks which can\n            be used by a set of people who trust each other and who have\n            access to a communications channel external to HTTP which\n            can be used to negotiate writing to the resource.\n\n\n            5.1.2     Required Support\n\n            A DAV compliant server is not required to support locking in\n            any form. If the server does support locking it may choose\n            to support any combination of exclusive and shared locks for\n            any access types.\n\n            The reason for this flexibility is that server implementers\n            have said that they are willing to accept minimum\n            requirements on all services but locking. Locking policy\n            strikes to the very heart of their resource management and\n            versioning systems and they require control over what sort\n            of locking will be made available. For example, some systems\n            only support shared write locks while others only provide\n            support for exclusive write locks. As each system is\n            sufficiently different to merit exclusion of certain locking\n            features, the authors are proposing that locking be allowed\n            as the sole axis of negotiation within DAV.\n\n            5.2 LOCK Method\n\n            5.2.1     Operation\n\n            A lock method invocation creates the lock specified by the\n            Lock-Info header on the request-URI. Lock method requests\n            SHOULD NOT have a request body. A user-agent SHOULD submit\n            an Owner header field with a lock request.\n\n            A successful response to a lock invocation MUST include a\n            Lock-Token header. If the server supports a time based lock\n            removal mechanism on the resource, a successful lock\n            invocation SHOULD return a Time-Out header.\r\f\n\n\n\n\n\n            5.2.2     The Effect of Locks on Properties and Containers\n\n            By default a lock affects the entire state of the resource,\n            including its associated properties. As such it is illegal\n            to specify a lock on a property. For containers, a lock also\n            affects the ability to add or remove members. The nature of\n            the effect depends upon the type of access control involved.\n             The Depth header expresses the general semantics of a LOCK\n            method request when invoked on a collection (note that\n            specific lock types may restrict the effect of a lock, for\n            example limiting the allowable values of the Depth header):\n\n            A Depth header (defined in the namespace draft) may be used\n               on a LOCK method when the LOCK method is applied to a\n               collection resource. The legal values for Depth on a LOCK\n               are 0, 1, and Infinity. A Depth of 0 instructs the\n               resource to just lock the container. As previously\n               mentioned, depending on the type of lock, the lock affects\n               the ability to add or remove members of the container.\n\n            @.A Depth of 1 means that the container is locked and a LOCK\n               is executed on the container\u2019s propagate members with a\n               Depth of 0 and If-Range, If-Modified-Since, If-Unmodified-\n               Since, If-Match and If-None-Match headers are dropped.\n               However, the effects of the LOCK MUST be atomic in that\n               either the container and all of its members are locked or\n               no lock is granted. The result of a Depth 1 lock is a\n               single lock token which represents the lock on the\n               container and all of its members. This lock token may be\n               used in an If-State-Match or If-Not-State-Match header\n               against any of the resources covered by the lock. Since\n               the lock token represents a lock on all the resources, an\n               UNLOCK using that token will remove the lock from all\n               included resources, not just the resource the UNLOCK was\n               executed on.\n\n            @.A Depth of infinity means that the LOCK is recursively\n               executed, with a Depth of infinity, on the collection and\n               all of its propagate members and all of their propagate\n               members. As with a Depth of 1, the LOCK must be granted in\n               total or not at all. Otherwise the lock operates in the\n               same manner as a Depth of 1 lock.\n\n            The default behavior when locking a container is to act as\n            if a \u201cDepth: 0\u201d header had been placed on the method.\n\n\n            5.2.3     Locking Replicated Resources\n\n            Some servers automatically replicate resources across\n            multiple URLs. In such a circumstance the server MAY only\n            accept a lock on one of the URLs if the server can guarantee\n            that the lock will be honored across all the URLs.\n\n\n            5.2.4     Interaction with other Methods\n\n            Only two methods, MOVE and DELETE, have side effects which\n            involve locks. When a resource is moved, its lock SHOULD be\n            moved with it. However this may not always be possible and\n            there is currently no proposal to create a header which\n            would specify that the lock request should fail if the\n            resource\u2019s locks can not be maintained. A COPY MUST NOT copy\n            any locks on the source resource over to the destination\n            resource. Deleting a resource MUST remove all locks on the\n            resource.\r\f\n\n\n\n\n\n            5.2.5     Lock Compatibility Table\n\n            The table below describes the behavior that occurs when a\n            lock request is made on a resource.\n\n            Current lock state/      Shared Lock       Exclusive Lock\n            Lock request\n            None                     True              True\n            Shared Lock              True              False\n            Exclusive Lock           False             False*\n            Legend: True = lock MAY be granted.  False = lock MUST NOT\n            be granted.  *=if the principal requesting the lock is the\n            owner of the lock, the lock MAY be regranted.\n\n            The current lock state of a resource is given in the\n            leftmost column, and lock requests are listed in the first\n            row.  The intersection of a row and column gives the result\n            of a lock request.  For example, if a shared lock is held on\n            a resource, and an exclusive lock is requested, the table\n            entry is \u201cfalse\u201d, indicating the lock must not be granted.\n\n            If an exclusive lock is re-requested by the principal who\n            owns the lock, the lock MAY be regranted. If the lock is\n            regranted, the same lock token that was previously issued\n            MUST be returned.\n\n\n            5.2.6     Status Codes\n\n            412 \u201cPrecondition Failed\u201d \u2013 The included state-token was not\n            enforceable on this resource.\n\n            416 \u201cLocked\u201d \u2013 The resource is locked so the method has been\n            rejected.\n\n\n            5.2.7     Example\n\n            LOCK /workspace/webdav/proposal.doc HTTP/1.1\n            Host: webdav.sb.aol.com\n            Lock-Info: LockType=Write LockScope=Exclusive\n            Owner: <http://www.ics.uci.edu/~ejw/contact.html>\n\n\n            HTTP/1.1 200 OK\n            State-Token: StateToken:Type=^DAV:/LOCK/DAVLOCK^:Res=^http:/\n            /www.ics.uci.edu/workspace/webdav/proposal.doc^:LockType=Wri\n            te:LockScope=Exclusive:ServerID=12382349AdfFFF\n            Time-Out: ClockType=Activity TimeType=second;604800\n\n            This example shows the successful creation of an exclusive\n            write lock on resource\n            http://webdav.sb.aol.com/workspace/webdav/proposal.doc. The\n            resource http://www.ics.uci.edu/~ejw/contact.html contains\n            contact information for the owner of the lock. The server\n            has an activity-based timeout policy in place on this\n            resource, which causes the lock to automatically be removed\n            after 1 week (604800 seconds). The response has a Lock-Token\n            header that gives the state token URL for the lock token\n            generated by this lock request.\n\n\n            5.2.8     Lock-Info Request Header\n\n            The Lock-Info header specifies the scope and type of a lock\n            for a LOCK method request. The syntax specification below is\n            extensible, allowing new type and scope identifiers to be\n            added.\r\f\n\n\n\n\n\n            LockInfo = \u201cLock-Info\u201d \u201c:\u201d DAVLockType SP DAVLockScope CRLF\n            DAVLockType = \u201cLockType\u201d \u201c=\u201d DAVLockTypeValue\n            DAVLockTypeValue = (\u201cWrite\u201d | *(uchar | reserved))\n            DAVLockScope = \u201cLockScope\u201d \u201c=\u201d DAVLockScopeValue\n            DAVLockScopeValue = (\u201cExclusive\u201d |\u201dShared\u201d | *(uchar |\n            reserved))\n\n            5.2.9     Owner Request Header\n\n\n            5.2.9.1   Problem Description\n\n            When discovering the list of owners of locks on a resource,\n            a principal may want to be able to contact the owner\n            directly. For this to be possible the lock discovery\n            mechanism must provide enough information for the lock owner\n            to be contacted.\n\n\n            5.2.9.2   Solution Requirements\n\n            Not all systems have authentication procedures that provide\n            sufficient information to identify a particular user in a\n            way that is meaningful to a human. In addition, many systems\n            that do have sufficient information, such as a name and e-\n            mail address, do not have the ability to associate this\n            information with the lock discovery mechanism. Therefore a\n            means is needed to allow principals to provide\n            authentication in a manner which will be meaningful to a\n            human.\n\n            The From header (defined in RFC 2068), which contains only\n            an email mailbox, is not sufficient for the purposes of\n            quick identification. When desperately looking for someone\n            to remove a lock, e-mail is often not sufficient. A\n            telephone number (cell number, pager number, etc.) would be\n            better. Furthermore, the email address in the From field may\n            or may not support including the owners name and that name\n            is often set to an alias anyway. Therefore a header more\n            flexible than From is required.\n\n\n            5.2.9.3   Syntax\n\n            Owner = \"Owner\" \":\" ((\u201c<\u201d URI \u201c>\u201d)  | quoted-string)\n\n            The URI SHOULD provide a means for either directly\n            contacting the principal (such as a telephone number or e-\n            mail URI), or for discovering the principal (such as  the\n            URL of a homepage).  The quoted string SHOULD provide a\n            means for directly contacting the principal, such as a name\n            and telephone number.\n\n\n            5.2.10    Time-Out Header\n\n\n            5.2.10.1  Problem Description\n\n            In a perfect world principals take out locks, use the\n            resource as needed, and then remove the lock when it is no\n            longer needed. However, this scenario is frequently not\n            completed, leaving active but unused locks. Reasons for this\n            include client programs crashing and loosing information\n            about locks, users leaving their systems for the day and\n            forgetting to remove their locks, etc. As a result of this\n            behavior, servers need to establish a policy by which they\n            can remove a lock without input from the lock owner. Once\n            such a policy is instituted, the server also needs a\n            mechanism to inform the principal of the policy.\r\f\n\n\n\n\n\n            5.2.10.2  Solution Requirements\n\n            There are two basic lock removal policies, administrator and\n            time based remove. In the first case a principal other than\n            the lock owner has sufficient access rights to order the\n            lock removed, even though they did not take it out. User-\n            agents MUST assume that such a mechanism is available and\n            thus locks may arbitrarily disappear at any time. If their\n            actions require confirmation of the existence of a lock then\n            the If-State headers are available.\n\n            The second solution, is the time based removal policy.\n            Activity based systems set a timer as soon as the lock is\n            taken out. Every time a method is executed on the resource,\n            the timer is reset. If the timer runs out, the lock is\n            removed.\n\n            Finally, some systems only allow locks to exist for the\n            duration of a session, where a session is defined as the\n            time when the HTTP connection that was used to take out the\n            lock remains connected. This mechanism is used to allow\n            programs which are likely to be improperly exited, such as\n            JAVA programs running in a browser, to take out locks\n            without leaving a lot of ownerless locks around when they\n            are improperly exited.\n\n\n            5.2.10.3  Syntax\n\n            TimeOut = \"Time-Out\" \":\" ((TimeOutType SP Session) |\n            TimeOutVal |\n                      Session) CRLF\n            TimeOutType = ClockType SP TimeType\n            ClockType = \u201cClockType\u201d \u201c=\u201d ClockTypeValue\n            ClockTypeValue = \u201cActivity\u201d\n            TimeType = \u201cTimeType\u201d \u201c=\u201d TimeTypeValue\n            TimeTypeValue = \u201cSecond\u201d \u201c;\u201d DAVTimeOutVal\n            DAVTimeOutVal = 1*digit\n            Session = \u201cSession\u201d \u201c=\u201d (\u201cYes\u201d | \u201cNo\u201d)\n\n\n            The \u201cSecond\u201d TimeType specifies the number of seconds that\n            may elapse before the lock is automatically removed. A\n            server MUST not generate a time out value for \u201csecond\u201d\n            greater than 2^32-1.\n\n            If no time based system is in use then a Time-Out header\n            MUST NOT be returned. The Time-Out header MUST only be\n            returned in a response to a LOCK request.When session is set\n            to yes then whatever clocktype and timetype is being used,\n            their effects are scoped within that particular session. So\n            an absolute lock with a ten day expiration period will only\n            remain active so long as the session remains active. A\n            DAVTimeOutVal value must be greater than zero.\n\n            Clients MAY include TimeOut headers in their LOCK requests.\n            However the server is not required to honor or even consider\n            the request. The primary purpose in allowing clients to\n            submit a TimeOut header is to inform the server if the\n            client is requesting a session based lock. If a timeout is\n            associated with the lock, the server MUST return a TimeOut\n            header with a valid value.\r\f\n\n\n\n\n\n            5.2.11    State-Token Header\n\n\n            5.2.11.1  Problem Definition\n\n            Program A, used by User A, takes out a write lock on a\n            resource. Program B, also run by User A, then proceeds to\n            perform a PUT to the locked resource. The PUT will succeed\n            because locks are associated with a principal, not a\n            program, and thus program B, because it is acting with\n            principal A\u2019s credential, will be allowed to perform the\n            PUT. In reality program B had no knowledge of the lock and\n            had it had such knowledge, would not have overwritten the\n            resource. Hence, a mechanism is needed to prevent different\n            programs from accidentally ignoring locks taken out by other\n            programs with the same authorization.\n\n\n            5.2.11.2  Solution Requirement\n\n            The solution must not require principals to perform\n            discovery in order to prevent accidental overwrites as this\n            could cause race conditions.\n\n            The solution must not require that clients guess what sorts\n            of locks might be used and use if-state-match headers with\n            wildcards to prevent collisions. The problem with trying to\n            \u201cguess\u201d which locks are being used is that new lock types\n            might be introduced, and the program would not know to\n            \u201cguess them\u201d. So, for example, a client might put in an if-\n            state-match header with a wildcard specifying that if any\n            write lock is outstanding then the operation should fail.\n            However a new read/write lock could be introduced which the\n            client would not know to put in the header.\n\n\n            5.2.11.3  State-Token Header\n\n            The State-Token header is returned in a successful response\n            to the LOCK method or is used as a request header with the\n            UNLOCK method.\n\n            The State-Token header containing a lock token owned by the\n            request principal is used by the principal on arbitrary\n            method to indicate that the principal is aware of the\n            specified lock. If the State-Token header with the\n            appropriate lock token is not included the request MUST be\n            rejected, even though the requesting principal has\n            authorization to make modifications specified by the lock\n            type. This injunction does not apply to methods that are not\n            affected by the principal\u2019s lock.\n\n            For example, Program A, used by user A, takes out a write\n            lock on a resource. Program A then makes a number of PUT\n            requests on the locked resource, all the requests contain a\n            State-Token header which includes the write lock state\n            token. Program B, also run by User A, then proceeds to\n            perform a PUT to the locked resource. However program B was\n            not aware of the existence of the lock and so does not\n            include the appropriate state-token header. The method is\n            rejected even though principal A is authorized to perform\n            the PUT. Program B can, if it so chooses, now perform lock\n            discovery and obtain the lock token. Note that program A and\n            B can perform GETs without using the state-token header\n            because the ability to perform a GET is not affected by a\n            write lock.\r\f\n\n\n\n\n\n            Note that having a lock state token provides no special\n            access rights. Anyone can find out anyone else\u2019s lock state\n            token by performing lock discovery. Locks are to be enforced\n            based upon whatever authentication mechanism is used by the\n            server, not based on the secrecy of the token values.\n\n            5.3 Write Lock\n            A write lock prevents a principal without the lock from\n            successfully executing a PUT, POST, DELETE, MKCOL,\n            PROPPATCH, PATCH, ADDREF or DELREF on the locked resource.\n            All other methods, GET in particular, function independent\n            of the lock.\n\n            While those without a write lock may not alter a property on\n            a resource it is still possible for the values of live\n            properties to change, even while locked, due to the\n            requirements of their schemas. Only dead properties and live\n            properties defined to respect locks are guaranteed to not\n            change while locked.\n\n            It is possible to assert a write lock on a null resource in\n            order to lock the name. Please note, however, that locking a\n            null resource effectively makes the resource non-null as the\n            resource now has lock related properties defined on it.\n\n            Write locking a container also prevents adding or removing\n            members of the container. This means that attempts to\n            PUT/POST a resource into the immediate name space of the\n            write locked container MUST fail if the principal requesting\n            the action does not have the write lock on the container. In\n            order to keep the behavior of locking containers consistent\n            all locks on containers MUST contain a Depth header equal to\n            infinity, any other value is illegal.\n\n            5.4 Lock Tokens\n\n            5.4.1     Problem Description\n\n            It is possible that once a lock has been granted it may be\n            removed without the lock owner\u2019s knowledge. This can cause\n            serialization problems if the lock owner executes methods\n            thinking their lock is still in effect. Thus a mechanism is\n            needed for a principal to predicate the successful execution\n            of a message upon the continuing existence of a lock.\n\n\n            5.4.2     Proposed Solution\n\n            The proposed solution is to provide a lock token in the\n            response of a lock request. The lock token is a type of\n            state token and describes a particular lock. The same lock\n            token must never be repeated on a particular resource. This\n            prevents problems with long held outstanding lock tokens\n            being confused with newer tokens. This uniqueness\n            requirement is the same as for e-tags. This requirement also\n            allows for tokens to be submitted across resources and\n            servers without fear of confusion.\n\n\n            5.4.3     Lock Token Definition\n\n            The lock token is returned in the State-Token header in the\n            response to a LOCK method. The lock token can also be\n            discovered through lock discovery on a resource.\n\n            Lock-Token-URL = \u201cStateToken:\u201d Type \u201c:\u201d Resources \u201c:\u201d State-\n            Info\n            Type = \u201cType\u201d \u201c=\u201d \u201c^DAV:/LOCK/DAVLOCK^\u201d\r\f\n\n\n\n\n\n            Resources = \u201cRes\u201d \u201c=\u201d 1*(\u201c^\u201d Caret-Encoded-URI \u201c^\u201d)\n            Caret-Encoded-URI = <This is a URI which has all \u201c^\u201ds %\n            encoded.>\n            State-Info = DAVLockScope \u201c:\u201d DAVLockType \u201c:\u201d ServerID  ;\n            DAVLockScope, DAVLockType defined in Lock-Info header\n            ServerID = \u201cServerID\u201d \u201c=\u201d *(uchar | reserved)\n\n\n            The ServerID is a field for use by the server. Its most\n            basic purpose is to put in a unique identifier to guarantee\n            that a server will never confuse an old lock token with a\n            newer one. However the server is free to use the field to\n            record whatever information it deems fit. The field is\n            opaque to clients.\n\n            5.5 UNLOCK Method\n\n            5.5.1     Problem Definition\n\n            The UNLOCK method removes the lock identified by the lock\n            token in the State-Token header from the Request-URI.\n\n\n            5.5.2     Example\n\n            UNLOCK /workspace/webdav/proposal.doc HTTP/1.1\n            Host: webdav.sb.aol.com\n            State-Token: StateToken:Type=^DAV:/LOCK/DAVLOCK^:Res=^http:/\n            /www.ics.uci.edu/workspace/webdav/proposal.doc^:LockType=Wri\n            te:LockScope=Exclusive:ServerID=12382349AdfFFF\n\n\n            HTTP/1.1 200 OK\n\n            In this example, the lock from example of Section 2.9 is\n            removed from the resource at\n            http://webdav.sb.aol.com/workspace/webdav/proposal.doc\n\n            5.6 Discovery Mechanisms\n\n            5.6.1     Lock Type Discovery\n\n\n            5.6.1.1   Problem Definition\n\n            Since server lock support is optional, a client trying to\n            lock a resource on a server can either try the lock and hope\n            for the best or can perform some form of discovery to\n            determine what lock types the server actually supports, then\n            formulate a supported request.  This is known as lock type\n            discovery. Lock type discovery is not the same as\n            discovering what access control types are supported, as\n            there may be access control types without corresponding lock\n            types.\n\n\n            5.6.1.2   SupportedLock Property\n\n            Name: http://www.ietf.org/standards/dav/lock/supportedlock\n\n            Purpose: To provide a listing of the lock types supported by\n            the resource.\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Values: An XML document containing zero or more LockEntry\n            XML elements.\n\n            Description: The SupportedLock property of a resource\r\f\n\n\n\n\n\n            returns a listing of the combinations of scope and access\n            types which may be specified in a lock request on the\n            resource. Note that the actual contents are themselves\n            controlled by access controls so a server is not required to\n            provide information the client is not authorized to see. If\n            SupportedLock is available on \u201c*\u201d then it MUST define the\n            set of locks allowed on all resources on that server.\n\n\n            5.6.1.3   LOCKENTRY XML Element\n\n            Name: http://www.ietf.org/standards/dav/lockentry\n\n            Purpose: Defines a DAVLockType/LockScope pair which may be\n            legally used with a LOCK on the specified resource.\n\n            Schema: HYPERLINK http://www.ietf.org/standards/dav/\n\n            Parent: A SupportedLock entry\n\n            Values: LockType LockScope\n\n\n            5.6.1.4   LOCKTYPE XML Element\n\n            Name: http://www.ietf.org/standards/dav/locktype\n\n            Purpose: Lists a DAVLockType\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: LOCKENTRY\n\n            Values: DAVLockTypeValue\n\n\n            5.6.1.5   LOCKSCOPE XML Element\n\n            Name: http://www.ietf.org/standards/dav/lockscope\n\n            Purpose: Lists a DAVLockScope\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: LOCKENTRY\n\n            Values: DAVLockScopeValue\n\n\n            5.6.2     Active Lock Discovery\n\n\n            5.6.2.1   Problem Definition\n\n            If another principal locks a resource that a principal\n            wishes to access, it is useful for the second principal to\n            be able to find out who the first principal is.\n\n\n            5.6.2.2   Solution Requirements\n\n            The lock discovery mechanism should provide a list of who\n            has the resource locked, what locks they have, and what\n            their lock tokens are. The lock tokens are useful in shared\n            lock situations where two principals in particular may want\n            to guarantee that they do not overwrite each other. The lock\n            tokens are also useful for administrative purposes so that\n            an administrator can remove a lock by referring to its\n            token.\n\n\n            5.6.2.3   LOCKDISCOVERY Property\n\n            Name: http://www.ietf.org/standards/dav/lockdiscovery\n\n            Purpose: To discover what locks are active on a resource\r\f\n\n\n\n\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Values= An XML document containing zero or more ActiveLock\n            XML elements.\n\n            Description: The LOCKDISCOVERY property returns a listing of\n            who has a lock, what type of lock they have, the time out\n            type and the time remaining on the time out, and the\n            associated lock token. The server is free to withhold any or\n            all of this information if the requesting principal does not\n            have sufficient access rights to see the requested data.\n\n\n            5.6.2.4   ACTIVELOCK XML Element\n\n            Name: http://www.ietf.org/standards/dav/activelock\n\n            Purpose: A multivalued XML element that describes a\n            particular active lock on a resource\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: A LOCKDISCOVERY entry\n\n            Values= LOCKTYPE LOCKSCOPE OWNER TIMEOUT LOCKTOKEN\n\n\n            5.6.2.5   OWNER XML Element\n\n            Name: http://www.ietf.org/standards/dav/lock/owner\n\n            Purpose: Returns owner information\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: ACTIVELOCK\n\n            Values= XML:REF | {any valid XML string}\n\n\n            5.6.2.6   TIMEOUT XML Element\n\n            Name: http://www.ietf.org/standards/dav/timeout\n\n            Purpose: Returns information about the timeout associated\n            with the lock\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: ACTIVELOCK\n\n            Values= CLOCKTYPE TIMETYPE TIMEOUTVAL\n\n\n            5.6.2.7   CLOCKTYPE XML Element\n\n            Name: http://www.ietf.org/standards/dav/clocktype\n\n            Purpose: Returns the clock type used with this lock\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: TIMEOUT\n\n            Values=  ClockTypeValue\n\n\n            5.6.2.8   TIMETYPE XML Element\n\n            Name: http://www.ietf.org/standards/dav/clocktype\n\n            Purpose: Returns the time type used with this lock\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: TIMEOUT\n\n            Values= TimeTypeValue\r\f\n\n\n\n\n\n            5.6.2.9   TIMEOUTVAL XML Element\n\n            Name: http://www.ietf.org/standards/dav/timeoutval\n\n            Purpose: Returns the amount of time left on the lock\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: TIMEOUT\n\n            Values= DAVTimeOutVal\n\n\n            5.6.2.10  LOCKTOKEN XML Element\n\n            Name: http://www.ietf.org/standards/dav/statetoken\n\n            Purpose: Returns the lock token\n\n            Schema: http://www.ietf.org/standards/dav/\n\n            Parent: ACTIVELOCK\n\n            Values= XML:REF\n\n            Description: The REF contains a Lock-Token-URL.\n\n\n\n            6  Version Control\n            [TBD]\n\n\n\n            7  Internationalization Support\n            [TBD]\n\n\n\n            8  Security Considerations\n            [TBD]\n\n\n\n            9  Acknowledgements\n            Roy Fielding, Richard Taylor, Larry Masinter, Henry Sanders,\n            Judith Slein, Dan Connolly, David Durand, Henrik Nielsen,\n            Paul Leach. Kenji Ota, Kenji Takahashi. Jim Cunningham.\n            Others, TBD.\n\n\n            10 References\n            [Berners-Lee, 1997] T. Berners-Lee, \"Metadata Architecture.\"\n            Unpublished white paper, January 1997.\n            http://www.w3.org/pub/WWW/DesignIssues/Metadata.html.\n\n            [Bray, 1997] T. Bray, C. M. Sperberg-McQueen, \u201cExtensible\n            Markup Language (XML): Part I. Syntax\u201d, WD-xml-lang.html,\n            http://www.w3.org/pub/WWW/TR/WD-xml-lang.html.\n\n            [Connolly, 1997] D. Connolly, R. Khare, H.F. Nielsen, \u201cPEP -\n            an Extension Mechanism for HTTP\u201d, Internet draft, work-in-\n            progress. draft-ietf-http-pep-03.txt,\n            ftp://ds.internic.net/internet-drafts/draft-ietf-http-pep-\n            03.txt.\n\n            [Lasher, Cohen, 1995] R. Lasher, D. Cohen, \"A Format for\n            Bibliographic Records,\" RFC 1807. Stanford, Myricom. June,\n            1995.\n\n            [Maloney, 1996] M. Maloney, \"Hypertext Links in HTML.\"\n            Internet draft (expired), work-in-progress, January, 1996.\r\f\n\n\n\n\n\n            [MARC, 1994] Network Development and MARC Standards, Office,\n            ed. 1994. \"USMARC Format for Bibliographic Data\", 1994.\n            Washington, DC: Cataloging Distribution Service, Library of\n            Congress.\n\n            [Miller et.al., 1996] J. Miller, T. Krauskopf, P. Resnick,\n            W. Treese, \"PICS Label Distribution Label Syntax and\n            Communication Protocols\" Version 1.1, W3C Recommendation\n            REC-PICS-labels-961031. http://www.w3.org/pub/WWW/TR/REC-\n            PICS-labels-961031.html.\n\n            [WebDAV, 1997] WEBDAV Design Team. \u201cA Proposal for Web\n            Metadata Operations.\u201d Unpublished manuscript.\n            http://www.ics.uci.edu/~ejw/authoring/proposals/metadata.htm\n            l\n\n            [Weibel et al., 1995] S. Weibel, J. Godby, E. Miller, R.\n            Daniel, \"OCLC/NCSA Metadata Workshop Report.\"\n            http://purl.oclc.org/metadata/dublin_core_report.\n\n            [Yergeau, 1997] F. Yergeau, \u201cUTF-8, a transformation format\n            of Unicode and ISO 10646\u201d, Internet Draft, work-in-progress,\n            draft-yergeau-utf8-rev-00.txt,\n            http://www.internic.net/internet-drafts/draft-yergeau-utf8-\n            rev-00.txt.\n\n\n\n            11 Authors' Addresses\n            Yaron Y. Goland\n            Microsoft Corporation\n            One Microsoft Way\n            Redmond, WA 98052-6399\n            Email yarong@microsoft.com\n\n\n            E. J. Whitehead, Jr.\n            Dept. Of Information and Computer Science\n            University of California, Irvine\n            Irvine, CA 92697-3425\n            Email: ejw@ics.uci.edu\n\n            Asad Faizi\n            Netscape\n            685 East Middlefield Road\n            Mountain View, CA 94043\n            Email: asad@netscape.com\n\n\n            Stephen R Carter\n            Novell\n            1555 N. Technology Way\n            M/S ORM F111\n            Orem, UT 84097-2399\n            Fax (801) 228 5176\n            Email srcarter@novell.com\n\n            Del Jensen\n            Novell\n            1555 N. Technology Way\n            M/S ORM F111\n            Orem, UT 84097-2399\n            Fax (801) 228 5176\n            Email dcjensen@novell.com\r\f\n\n\n\n\n\n            Appendix 1 - Content Type Application/XML\n            This is a digest of the XML data specification available at\n            http://www.w3.org/TR/WD-xml-lang.html\n\n            Syntax\n            The application/XML content type contains an XML document.\n            Its syntax is as defined below.\n\n            XML = XMLStart *XMLEntity Close\n\n            XMLStart = \u201c<\u201d \u201cXML\u201d \u201c>\u201d\n\n            XMLEntity= Open *(XMLText | XMLEntity) Close\n\n            Close = \u201c</>\u201d | \u201c<\u201d\u201c/\u201dEntity-Name Markup\u201c>\u201d\n\n            Open = \u201c<\u201d Entity-Name *Attribute \u201c>\u201d\n\n            Attribute = Entity-Name \u201c=\u201d Quoted-String\n\n            XMLText = <An Octet Stream which uses XML encoding for \u201c<\u201d\n            and \u201c>\u201d>\n\n            Entity-Name = ([As-Tag \u201c:\u201d] Name) | (As-Tag \u201c:\u201d)\n\n            As-Tag = 1*Alpha\n\n            Name = (alpha | \u201c_\u201d) *(alpha | digit | \u201c.\u201d | \u201c-\u201c | \u201c_\u201d |\n            other)\n\n            Other = <Other characters must be encoded>\n\n            XML element\n            An XML element, as defined in the BNF, is an open tag with\n            content followed by a close tag. In order to prevent\n            confusion with the term entity as used in HTTP, the term XML\n            element will be used.\n\n            The first XML element of a XML document MUST be the <XML>\n            XML element. This XML element tells the parser that it is\n            dealing with an XML document. So long as this XML element is\n            present the parser can be sure that it can parse the\n            document, even if XML has been extended. If XML is ever\n            altered in a manner that is not backwards compatible with\n            this specification then the content-type and the outer most\n            XML element MUST be changed.\n\n            Entity-Name\n            All XML element names must map to URIs. However due to\n            historical restrictions on what characters may appear in an\n            XML element name, URIs cannot be expressed in an XML element\n            name. This issue is dealt with in more detail in section 10.\n\n            Entity-Names without [AS] are relative URIs whose base is\n            the enclosing Entity-Name. If the enclosing Entity-Name is\n            <XML> then the Entity-Name MUST use an [AS].\n\n            Close\n            The close production marks the end of a XML element.\n\n            XML Encoding\n            In different contexts certain characters are reserved, for\n            example \u201c/\u201d can not be used in an XML element name and\n            \u201c>\u201d/\u201d<\u201d can not be used in a value. As such these values\n            must be encoded as follows:\n\n            Encoding = Decimal | Hex4\n\n            Decimal = \u201c&\u201d Non-Zero *(\u201c0\u201d | Non-Zero)\r\f\n\n\n\n\n\n            Hex4 = \u201c&u-\u201c 4(Hex)\n\n            Non-Zero = \u201c1\u201d | \u201c2\u201d | \u201c3\u201d | \u201c4\u201d | \u201c5\u201d | \u201c6\u201d | \u201c7\u201d | \u201c8\u201d |\n            \u201c9\u201d\n\n            Hex = \u201c0\u201d | Non-Zero | \u201cA\u201d | \u201cB\u201d | \u201cC\u201d | \u201cD\u201d | \u201cE\u201d | \u201cF\u201d\n\n            The numbers MUST map to the UTF8 character encodings. Please\n            note that the \u201c&\u201d character must always be encoded.\n\n            Markup Modifier\n            The markup modifier, (\u201c-\u201d, after the end of an XML element)\n            instructs the principal how to treat a XML element with an\n            unknown name. If the modifier is used and the XML element is\n            not recognized then the XML element name MUST be stripped\n            and the XML element\u2019s contents promoted one level in the\n            parse tree. If the modifier is not used and the XML element\n            name is unknown then the XML element and its contents MUST\n            be ignored.\n\n            XML Syntax Shorthand\n            The following template is recommended for efficiently\n            providing a description of an XML element.\n\n            Name: The name of the XML element\n\n            Purpose: A one line description of the XML element\u2019s\n            purpose.\n\n            Schema: The schema, if any, that the XML element belongs to\n\n            Parent: XML elements that this XML element may be a child\n            of.\n\n            Values: A description, usually a BNF, of the simple and\n            compound values that the XML element supports.\n\n            Description: Further information.\n\n            Example: An example of the XML element\u2019s use.\n\n            Appendix 2 - Parameter Syntax for Content-Type\n            Application/XML\n            HTTP 1.1 provides for a mechanism to include a parameter\n            with a content type. In order to prevent namespace\n            collisions the parameters for application/XML must use the\n            following syntax:\n\n            Parameter = #(<\u201d>URI<\u201d>  [\u201c=\u201d (token | Quoted-String)])\n\n            Schema Content-Type Parameter\n            Parameter = <\u201d> http://www.w3.org/standards/xml/content-\n            type/schema <\u201d> \u201c=\u201d <\u201d> #URI <\u201d>\n\n            The http://www.w3.org/standards/xml/content-type/schema/ URL\n            is used as a parameter to an application/xml content type.\n            The URL indicates that its value lists some subset of the\n            schemas defined in NameSpace parameters within the enclosed\n            document. The URI can also be used in requests to indicate\n            schemas that should appear in the result.\n\n            An example of the use of this parameter is to include it in\n            an accept-type header on a request to indicate that the\n            response should contain the specified namespace. Thus the\n            client is able to inform the server of its support for a\n            particular set of namespaces. The server is not required to\n            return a result with the specified namespaces.\r\f\n\n\n\n\n\n            Appendix 3 \u2013 URI Path Encoding\n\n            Problem Definition\n            A mechanism is needed to refer to specific DAV properties in\n            a manner that can handle simple, composite, and multivalued\n            DAV properties.\n\n            Solution Requirement\n            The reference mechanism must use the standard URL syntax so\n            it can be used with both currently existing and future URLs.\n            For example, the syntax could be appended to an HTTP URL to\n            specify a HTTP property on that URL.\n\n            Path Component\n            URIPath = \u201c/\u201d [segment]\n\n            Segment = (\u201c(\u201c Abs-URI \u201c)\u201d | Rel-URI)[Index]*( \u201c;\u201d param)\n\n            Index = [\u201c(\u201c [\u201c-\u201c]*digit \u201c)\u201d]\n\n            Abs-URI = < An absolute or relative URI which has been URI-\n            Path encoded >\n\n            Rel-URI = < A relative URI for which URI-Encoding(Rel-URI)\n            == Rel-URI >\n\n            URI-Path encoding consists of the following algorithm:\n\n            URL encode all \u201c!\u201d characters\n\n            Map all \u201c/\u201d characters to \u201c!\u201d characters\n\n            Please note that all relative URIs are relative to the URI\n            in the path segment preceding them. Hence the URI in the\n            first path segment MUST be an absolute URI.\n\n            The purpose of the encoding is to allow URLs to be used as\n            segments without having to use % encoding on all the \u201c/\u201d\n            which produces a URL form which is extremely difficult for\n            humans to deal with, and which changes the semantics of the\n            URL.\n\n            Appendix 4 - XML URI\n            The \u201cXML\u201d scheme is to be registered with IANA as a reserved\n            namespace that will be owned by the XML group through the\n            W3C.\n\n            The new URI is defined as:\n\n            XML = \u201cXML\u201d \u201c:\u201d XML-Path\n\n            Appendix 5 - XML elements\n\n            Ref XML element\n            Name: XML:Ref\n\n            Purpose: A XML element that indicates that its contents are\n            a URI.\n\n            Schema: XML\n\n            Parent: Any\n\n            Value = URI\n\n            Namespace\n\n            Namespace XML element\n\n            Name: XML:Namespace\r\f\n\n\n\n\n\n            Purpose: To inform the parser that a particular schema is in\n            use and to provide a shorthand name for referring to XML\n            elements related to that schema.\n\n            Schema: XML\n\n            Parent: Any\n\n            Value = (Ref [AS])\n\n            Description: This XML element contains two XML elements, Ref\n            and AS. The purpose of the XML element is to inform the\n            parser that a schema, identified by the value of the Ref XML\n            element, is in use and, when appropriate, to provide a\n            shorthand name to refer XML elements derived from that\n            schema using the AS XML element. The AS mechanism is needed\n            for efficiency reasons and because a URI can not be fully\n            specified in an XML open tag. The Namespace XML element\u2019s\n            scope is all siblings and their children.\n\n\n            AS XML element\n\n            Name: XML:AS\n\n            Purpose: To provide a short name for the URI of the schema\n            provided in the Ref XML entity of a namespace XML entity.\n\n            Schema: XML\n\n            Parent: XML:Namespace\n\n            Value = 1*Alpha\n\n            Description: The AS XML entity is used to provide a\n            shorthand reference for the URI in the Ref XML entity of a\n            Namespace XML entity. The value contained in the AS XML\n            entity is generated at the XML producer\u2019s discretion, the\n            only requirement is that all AS values MUST be unique within\n            the contents of the parent of the namespace element.\n\n            All XML entity open tags contain a name of the form As-\n            Tag:Name. The As-Tag is the value defined in an AS XML\n            entity inside of a Namespace. To resolve the As-Tag:Name\n            into a properly formatted URI replace \u201cAs-Tag:\u201d with the URI\n            provided in the Ref that the AS was defined with. Also note\n            that AS value also applies to any URIs defined in a Ref\n            inside of Namespace.\n\n            For example,\n\n                 <XML>\n                      <XML:Namespace><Ref>http://blah;DAV/</><AS>B</></>\n                      <XML:Namespace><Ref>B:(B:)/</><AS>C</></>\n                      <C:Moo></>\n                 </>\n            So B:(B:) translates to http://blah;DAV/(http:!!blah;DAV!)/\n            and C:Moo translates to\n            http://blah;DAV/(http:!!blah;DAV!)/Moo.\n\n\n            Required XML element\n\n            Name: XML:Required\n\n            Purpose: To indicate that the read MUST understand the\n            associated Namespace in order to successfully process the\n            XML document.\n\n            Schema: XML\n\n            Parent: XML:Namespace\r\f\n\n\n\n\n\n            Value: None\n\n\n            The XML URI and Namespace\n\n            In order to prevent a logical loop the XML namespace is said\n            to be declared, with the AS value of \u201cXML\u201d as a consequence\n            of the <XML> enclosing property.\r\f\n", "encoding": "Windows-1252"}