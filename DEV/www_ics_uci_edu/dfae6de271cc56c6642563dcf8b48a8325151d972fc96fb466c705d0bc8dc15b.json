{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/ExceptionsAndFiles/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Exceptions and Files</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Exceptions and Files</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Understanding the difference between success and failure</p>\r\n\r\n<p>When a <i>function</i> is <i>called</i> in Python, that function is being asked to do some kind of job.  The function does the job and <i>returns</i> a result &mdash; always an object of some type, though that object might be the special object <b>None</b> if the function's role is to generate some kind of side effect (such as printing output) rather than calculating and giving you back a result.  As you've seen, many functions accept <i>parameters</i>, which allow the function to do a slightly different job each time it's called; for example, a function that downloads an image from the Internet would probably take at least one parameter, the address from which the image should be downloaded, so that the function could potentially be used to download any image instead of just one particular image.</p>\r\n\r\n<p>The interaction between a function and its caller in Python has at least some similarity to certain kinds of interactions between people.  Think about what happens you ask a friend to do something for you, like \"Here's $5.  Can you drive over to Starbucks and buy me a latte?\", which, conceptually, is a lot like calling a function in Python (with \"$5\" and \"Starbucks\" as its parameters and \"latte\" as its expected result).  Even assuming your friend understands your instructions perfectly and is willing to do it, are you guaranteed to get the result you asked for &mdash; in this case, a latte? &mdash; or are there circumstances where you won't get it?  Of course, failure is certainly a possibility here.  Your friend's car might not be in working order, or it might be in use by someone else, or your friend might not even have one!  Starbucks might be closed, or they might have run out of coffee.  A latte might cost more than $5, and your friend might not have any more money than you provided.</p>\r\n\r\n<p>Now let's think again about a Python function that downloads an image from the Internet.  Even assuming that the function is perfectly written, can anything go wrong there?  Sure!  Your Internet connection might not be working.  The web site from which you're trying to download the image might be down, it might not contain the image you asked for, or it might not exist at all.  What result should the function return in these cases?  Going back to the previous example, when you send someone to Starbucks and it turns out that Starbucks is closed, you get no result at all; instead of handing you a latte, your friend might instead inform you that the job couldn't be done and <i>why</i>.  \"Sorry,\" your friend might say, \"I couldn't get that coffee for you, because Starbucks was closed.\"  Or, right away, your friend might say, \"Are you crazy?  I don't have a car, remember?!\"  Either way, you're not getting the coffee you wanted.</p>\r\n\r\n<p>In Python, when a function is called, it is being asked to do a job.  Broadly speaking, just like in the case of sending your friend for coffee, there are two possible outcomes, even assuming the function has no bugs:</p>\r\n\r\n<ul>\r\n  <li>The function will complete its job successfully and return an object of a type you expect.</li>\r\n  <li>The function will fail to complete its job.  Functions fail differently than they succeed in Python; rather than just returning an object that indicates failure, they don't return an object at all, but instead <i>raise an exception</i>.</li>\r\n</ul>\r\n\r\n<p>Despite their name, there's nothing exceptional about exceptions.  They're not rare, they're not necessarily indicative of bugs, and they don't cause well-written programs to crash.  An exception just means a function failed to complete its job.  Where some finesse is required is in deciding what should be done about it.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">What happens when an exception is raised</p>\r\n\r\n<p>An exception that is not handled anywhere in a program will cause a crash and you'll see a <i>traceback</i>, which specifies information about the unhandled exception and where the program was in its execution at the time the exception was raised.  For example, consider this nonsensical Python module.</p>\r\n\r\n<blockquote>\r\n<a href=\"oops.py\"><b><i>oops.py</i></b></a>\r\n<pre>\r\ndef f():\r\n    x = 3\r\n    g(x)\r\n\r\ndef g(n):\r\n    print(len(n))\r\n\r\nif __name__ == '__main__':\r\n    f()\r\n</pre>\r\n</blockquote>\r\n\r\n<p>If you run this module in IDLE, you'll see the following result, which offers some insight about what happens when an exception is called in Python.</p>\r\n\r\n<blockquote><pre>\r\nTraceback (most recent call last):\r\n  File \"C:\\Example\\oops.py\", line 11, in <module>\r\n    f()\r\n  File \"C:\\Example\\oops.py\", line 3, in f\r\n    g(x)\r\n  File \"C:\\Example\\oops.py\", line 7, in g\r\n    print(len(n))\r\nTypeError: object of type 'int' has no len()\r\n</pre></blockquote>\r\n\r\n<p>When you see a traceback like this, it's important to actually pay attention to what it says.  Reading a traceback from the bottom up provides a lot of useful information, even if you don't quite understand the error message at first, because tracebacks don't only tell us <i>what</i> the error was, but also <i>where</i> the error occurred.</p>\r\n\r\n<ul>\r\n  <li>The type of the exception &mdash; exceptions are objects in Python, just like everything else &mdash; is a <b>TypeError</b>.</li>\r\n  <li>A more descriptive account of the problem is <b>object of type 'int' has no len()</b>.  That's a hint that we were trying to get the length of an integer, but that integers have no length.</li>\r\n  <li>The exception was actually raised on line 7 of <b>oops.py</b>, by code in the function <b>g()</b>.  (The traceback even shows us the code that's on line 7: <b>print(len(n))</b>.)</li>\r\n  <li>The function <b>g()</b> had been called by the function <b>f()</b>, on line 3 of <b>oops.py</b>.</li>\r\n  <li>The function <b>f()</b> had been called by the \"main\" <b>if</b> statement, on line 11 of <b>oops.py</b>.</li>\r\n</ul>\r\n\r\n<p>This is the trail of evidence that's been left for us, describing the symptom of our problem.  It's our job to take that evidence and determine the underlying cause.  Given all the information here, it doesn't take long to figure out what happened:</p>\r\n\r\n<ul>\r\n  <li><b>f()</b> was called.</li>\r\n  <li><b>f()</b> initialized a local variable <b>x</b> to the integer value 3.  So <b>x</b> had the type <b>int</b>.</li>\r\n  <li><b>f()</b> called <b>g()</b> and passed <b>x</b> to <b>g()</b>'s parameter <b>n</b>.  So, within <b>g()</b>, <b>n</b> also had type <b>int</b>.</li>\r\n  <li><b>g()</b> attempted to get the length of <b>n</b>.  But <b>n</b> was an <b>int</b> and <b>int</b>s have no length!  The call to <b>len()</b> failed &mdash; it couldn't do what we asked &mdash; so it raised an exception.</li>\r\n</ul>\r\n\r\n<p>When an exception is raised by a function, that function can be considered to have failed; it couldn't complete the job that it was asked to do.  This sets off a chain reaction of sorts, albeit one that can be stopped.  If a function raises an exception, control is given back to whatever function called it, which has two options:\r\n    <ol>\r\n      <li>Handle the exception.</li>\r\n      <li>Choose not to handle the exception.  In this case, the calling function will also fail &mdash; the failure of one function has implied the failure of the one that called it &mdash; and control is given back to whatever function called the caller, who will have the same two options.</li>\r\n    </ol>\r\n  </li>\r\n</ul>\r\n\r\n<p>The cascading failure of functions continues until a function handles the exception, or until all active functions fail, at which point the program will crash and you'll see a traceback.  In this example above, that's why we saw the traceback: <b>g()</b> raised the exception and didn't handle it; <b>f()</b> didn't handle it, either; and the <b>if</b> statement in the \"main\" block didn't handle it, either.  Since the exception was never handled, the program crashed, and the traceback was shown.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Catching an exception</p>\r\n\r\n<p>We specify what should happen in a function when exceptions are raised by writing a <b>try</b> statement.  A <b>try</b> statement is built out of <i>clauses</i> and is structured like this:</p>\r\n\r\n<blockquote><pre>\r\ntry:\r\n    <i>statements that will be attempted once</i>\r\n    <i>if any exception is raised, control leaves the \"try\" clause immediately</i>\r\nexcept:\r\n    <i>statements that will execute after any statement in the \"try\" clause raises an exception</i>\r\nelse:\r\n    <i>statements that will execute after leaving the \"try\", but only if no exception was raised</i>\r\nfinally:\r\n    <i>statements that will always execute after leaving the \"try\", whether an exception was raised or not</i>\r\n    <i>note that these statements will happen after any in the \"except\" or \"else\" that also need to execute</i>\r\n</pre></blockquote>\r\n\r\n<p>There are a few combinations of these clauses that are legal; other combinations are illegal because they are nonsensical.  (Think about why.)  In both cases, the clauses must be listed in the order below:</p>\r\n\r\n<ul>\r\n  <li>A <b>try</b> and a <b>finally</b> and nothing else</li>\r\n  <li>A <b>try</b>, at least one <b>except</b>, (optionally) an <b>else</b>, and (optionally) a <b>finally</b></li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Being careful about what kinds of exceptions you catch</p>\r\n\r\n<p>Exceptions are Python objects; like all objects, they have a type.  An exception's type classifies what kind of failure occurred.  When you see a traceback, the exception's type is included in what's displayed, which helps you to understand what went wrong.  For example, the last line of the traceback in the example above said this:</p>\r\n\r\n<blockquote><pre>\r\nTypeError: object of type 'int' has no len()\r\n</pre></blockquote>\r\n\r\n<p>In this case, the type of exception that was raised was one called <b>TypeError</b>, a type built into Python that represents a problem revolving around incompatibility of types with the operations you're trying to perform on them (e.g., trying to take the length of an integer, or trying to add an integer and a string together).  There are other types of exceptions that are built into Python that you might have seen before, as well, such as <b>ValueError</b>, <b>NameError</b>, and <b>IndexError</b>; these represent other ways that functions can fail.  As we'll see a little later this quarter, you can also define new types of exceptions, which classify kinds of failures that are specific to the programs you write, as opposed to the ones built into Python, which are more general and could apply to many programs.</p>\r\n\r\n<p><b>except</b> clauses can optionally &mdash; and, more often than not, they do &mdash; specify a type of exception that they handle.  Python only executes <b>except</b> clauses when the type of exception matches the type that the <b>except</b> clause can handle.  <b>except</b> clauses with no type listed can handle any kind of exception, though these are somewhat dangerous in practice, because they'll handle every kind of problem the same way, meaning even a program bug (like misspelling the name of a variable) will be handled the same way as the kinds of problems you expect (like a file not existing when your program tries to open it).</p>\r\n\r\n<p>So why is it potentially dangerous to write <b>except</b> clauses that don't specify a type?  Consider these three short Python functions:</p>\r\n\r\n<blockquote><pre>\r\ndef foo():\r\n    return 14\r\n\r\ndef bar():\r\n    b1 = 3 * foo()\r\n    return bi\r\n\r\ndef example():\r\n    try:\r\n        answer = bar()\r\n        print('The answer is {}'.format(answer))\r\n    except:\r\n        print('ERROR')\r\n</pre></blockquote>\r\n\r\n<p>Read these functions carefully and then decide what would happen if we did this in the Python shell:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>example()</b>\r\n</pre></blockquote>\r\n\r\n<p>The answer might surprise you if you didn't read carefully.  All we'll see is this:</p>\r\n\r\n<blockquote><pre>\r\nERROR\r\n</pre></blockquote>\r\n\r\n<p>But why?  Let's trace through it:</p>\r\n\r\n<ul>\r\n  <li><b>example()</b> is called.</li>\r\n  <li>Control enters the <b>try</b> clause.</li>\r\n  <li>The statement <b>answer = bar()</b> is an assignment statement.  The assignment of <b>answer</b> can't happen until we know what <b>bar()</b> returns, so <b>bar()</b> is called.</li>\r\n  <li><b>bar()</b> begins with the statement <b>b1 = 3 * foo()</b>.  Again, the assignment can't happen until we know what value will be assigned, which depends on the value returned from <b>foo()</b>.  So <b>foo()</b> is called.</li>\r\n  <li><b>foo()</b> returns 14.</li>\r\n  <li>Now that <b>foo()</b> has returned 14, <b>bar()</b> can calculate <b>3 * foo()</b> as <b>3 * 14</b>, which gives the result 42, which is assigned into <b>b1</b>.</li>\r\n  <li>Still in the <b>bar()</b> function, we reach the line that reads <b>return bi</b>.  This line actually has a subtle typographical error in it.  We probably intended to say <b>return b1</b> here, but we mistyped <b>b1</b> as <b>bi</b> instead.  Because there is no variable called <b>bi</b>, Python raises an exception &mdash; a <b>NameError</b> &mdash; that (rightly) causes the <b>bar()</b> function to fail.</li>\r\n  <li>Since <b>bar()</b> failed, control passes back to the code that called it, which is the line <b>answer = bar()</b> in the <b>example()</b> function.  Since the call to <b>bar()</b> failed, the assignment can't occur; instead, <b>example()</b> has the standard two choices: handling the exception or allowing the failure to cascade.  In this case, though, <b>answer = bar()</b> is within a <b>try</b> clause that has an <b>except</b> clause that has no type specified.  This means that if <i>anything</i> goes wrong in that <b>try</b>, we'll immediately jump into the <b>except</b>; whatever code is in the <b>except</b> clause will run, and then the error will be considered to have been handled.  Our <b>except</b> clause simply prints the word <b>ERROR</b>.</li>\r\n</ul>\r\n\r\n<p>So what is the net effect of this?  The <b>example()</b> function claims to be quite resilient: If anything goes wrong, it claims to be able to handle the problem.  Thinking naively about it, one might consider this to be a good design decision: <b>example()</b> is crash-proof!  But think more carefully.  Has it really handled the problem?  \"Swallowing\" an exception and printing a generic error message is, in a lot of ways, worse than just letting the program crash.  We still didn't get the result we wanted from calling <b>example()</b>, but instead of giving us an error message we can use &mdash; a traceback that indicates what went wrong and where &mdash; we instead see the word <b>ERROR</b> and are left with no idea of what went wrong.</p>\r\n\r\n<p>Consider, instead, if we'd written <b>example()</b> this way instead:</p>\r\n\r\n<blockquote><pre>\r\ndef example():\r\n    answer = bar()\r\n    print('The answer is {}'.format(answer))\r\n</pre></blockquote>\r\n\r\n<p>Now, calling <b>example()</b> will have a different result:</p>\r\n\r\n<blockquote><pre>\r\n&gt;&gt;&gt; <b>example()</b>\r\nTraceback (most recent call last):\r\n  File \"&lt;pyshell#13&gt;\", line 1, in &lt;module&gt;\r\n    example()\r\n  File \"&lt;pyshell#12&gt;\", line 2, in example\r\n    answer = bar()\r\n  File \"&lt;pyshell#6&gt;\", line 2, in bar\r\n    return bi\r\nNameError: name 'bi' is not defined\r\n</pre></blockquote>\r\n\r\n<p>The outcome is the same in one sense: We didn't get the result we wanted.  But this time we got an error message that told us exactly what went wrong and where.  Especially when we're working on writing a new program, hiding these kinds of details makes our job much more difficult.  It's easy to misspell a variable name, to use the name of a function instead of calling it, and so on; for those errors to cause our program to misbehave without telling us <i>why</i> will make it extremely difficult to find and correct these inevitable mistakes.</p>\r\n\r\n<p class=\"subtitle\">Catching only one type of exception</p>\r\n\r\n<p>An <b>except</b> clause can specify a type of exception by simply listing its name after the word <b>except</b>.</p>\r\n\r\n<blockquote><pre>\r\ndef read_number_and_print_square() -&gt; None:\r\n    try:\r\n        number = int(input())\r\n        print('The square of the number you entered is {}'.format(number * number))\r\n    except ValueError:\r\n        print('That is not a number')    \r\n</pre></blockquote>\r\n\r\n<p>In this example, we're catching only the one type of exception that we reasonably expect might go wrong.  The call to <b>int()</b> may fail if the user's input is something that can't be converted into an integer; if that's the case, it will raise a <b>ValueError</b>.  So, here, we've handled just the <b>ValueError</b>.  If we had misspelled the name of a variable or made any other minor mistake in writing this function, it would have manifested itself in a different kind of exception, one that this function does not know how to handle.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Understanding how and when to handle exceptions</p>\r\n\r\n<p>Once you understand the mechanics of how a construct in Python behaves, your next task is understanding the appropriate ways to use it; no part of a programming language is right for every circumstance.  We've now seen how you can handle exceptions, but the more nuanced problem is understanding <i>when</i> to handle them and <i>when not</i> to handle them.  Here are a few guidelines to consider.</p>\r\n\r\n<ul>\r\n  <li>When you're writing a function <b>f</b> that calls another function <b>g</b>, one thing you want to be thinking about is whether <b>g</b> raises exceptions (i.e., whether <b>g</b> can fail to complete its job).  If so, you then need to consider whether the failure of <b>g</b> also implies the failure of <b>f</b>, or whether <b>f</b> could reasonably carry on <i>the same job</i> in some way.  If <b>f</b> fails whenever <b>g</b> fails, you won't want to catch the exception in <b>f</b>; if <b>f</b> could reasonably continue, <b>f</b> should catch the exception and then continue its work.</li>\r\n  <li>All in all, in my experience, it's more common for a function <i>not</i> to catch an exception than it is to catch it.  This is especially true when you tend to write relatively short, simple functions, and break larger, more complex functions into smaller ones &mdash; as you should be doing &mdash; because it's more likely that the failure of one will cause a cascading failure of several others that are each doing a smaller slice of something bigger.</li>\r\n  <li>The <b>finally</b> clause is primarily used for what you might call <i>cleanup</i>.  This is most especially true when a function acquires some kind of external resource &mdash; like a file or a connection across a network &mdash; that only it (and the functions it calls) will use.  In the case of a file, for example, a <b>finally</b> clause provides an obvious place to close the file if it was opened successfully.</li>\r\n  <li>When you don't want to catch an exception, but you do want to ensure that cleanup is done when an exception is raised, a <b>try</b>/<b>finally</b> (with no <b>except</b> or <b>else</b>) is appropriate.  That way, if the code in the <b>try</b> statement completes successfully <i>or</i> if an exception is raised and the function is fails, the cleanup in the <b>finally</b> will always be done.</li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>With that in mind, here is the code example from the previous lecture.</p>\r\n\r\n<ul>\r\n  <li><a href=\"line_count.py\">The <b>line_count</b> module</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}