{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/01.intro", "content": "What is a data structure?\n\n\tModule:\n\t\tset of variables and subroutines\n\t\tencapsulating some interface\n\n\tObject-oriented:\n\t\tinteracting set of objects that implements some functionality\n\n\nWhat do we study?\n\n\tWhat sets of operations are commonly needed?\n\n\tHow can we implement them efficiently?\n\t\t(various forms of analysis, amortized, etc)\n\n\tHow can we form new specialized data structures by combining\n\texisting ones in simple ways?\n\n\nWhy data structures?\n\tTheoretical: how do I find a fast algorithm?\n\tFast ds = fast alg\n\n\t\tsorting examples -- selection sort => heap sort; ins sort\n\n\tProgramming in the small\n\t(even when overall program does something non-theoretical)\n\n\t\tinterval tree for fast tree scrolling example\n\n\tSoftware design principles (modular object oriented design)\n\n\n\nPython syntax\n    key diffs from C etc:\n\tno variable declarations\n\t\t(data has a type but variables can hold any type data)\n\tblock structure determined by indentation instead of brackets\n\nsimple example\n\n    fib = [1, 1]\n\n    def fibonacci(n):\n\twhile n < len(fib):\n\t    fib.append(fib[-1]+fib[-2])\n\treturn fib[n]\n\n\nBasic data types\n\n\tobject, string, list, dict\n\n\tlist indexing zero-based, neg=from end\n\n\nObject oriented vs dictionary oriented representations:\nhow to represent trees\n\nspecial tree node object having data\n    parent\n    left, right children\n    1st child, next sibling\n    list of all siblings\n\ndictionary or dictionaries mapping tree nodes to these items\n\tadvantage: flexibility\n\ttree nodes can be anything\n\tsame object can be in multiple trees\n\n\tdisadvantage: slower (dictionary lookup per access)\n\n\nhow to represent sequences of objects?\n\tsingly linked list\n\t\teasy forward traversal, ins/del at start\n\t\thard to index\n\tdoubly linked list\n\t\teasy traversal, ins/del anywhere\n\t\thard to index\n\tarray\n\t\teasy to index\n\t\thard to ins/del anywhere\n\n\tpython choice (also Java vector):\n\t\tpartially filled array\n\t\tresize when gets filled\n\t\teasy to index\n\t\teasy to ins/del at end\n\t\thard to ins/del elsewhere\n\n\t\tresize strategy?\n\t\t\tPython: always double\n\t\t\tJava: double by default, or fixed increment\n\t\n\t\tHOW TO COMPARE?\n\t\t\nWORST CASE ANALYSIS (PER OPERATION)\n\tindex, del: constant\n\tins: linear\n\nAMORTIZED:\nprove that, if we perform a sequence of n operations,\ntotal time of the sequence is small\n(amortized complexity = average = total/n for worst case sequence)\nhere, worst case = repeat n*insertions (to trigger many resizes)\n\nfixed increment I: resize after every I inserts\ntime per resize = proportional to current size\nso total = Theta(I) + Theta(2I) + Theta(3I) + ... + Theta(n) = Theta(n^2/I).\nAmortized complexity per operation: n/I = O(n) [I is a constant]\n\ndouble:\ntotal = Theta(1) + Theta(2) + Theta(4) + ... + Theta(n) = Theta(2n) = Theta(n)\nAmortized complexity per operation: O(1)\n", "encoding": "ascii"}