{"url": "https://www.ics.uci.edu/~ejw/authoring/webdav-draft-06.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<HTML>\n<HEAD>\n   <TITLE>Extensions for Distributed Authoring and Versioning</TITLE>\n   <META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n   <META NAME=\"Template\" CONTENT=\"C:\\PROGRAM FILES\\MICROSOFT OFFICE\\OFFICE\\HTML.DOT\">\n   <META NAME=\"GENERATOR\" CONTENT=\"Mozilla/3.01Gold (X11; I; SunOS 5.5 sun4d) [Netscape]\">\n</HEAD>\n<BODY LINK=\"#0000FF\" VLINK=\"#800080\">\n\n<PRE>WEBDAV Working Group                                                      Y. Goland, Microsoft\nINTERNET-DRAFT                                               E. J. Whitehead, Jr., U.C. Irvine\n                                                                          Asad Faizi, Netscape\n                                                                     Stephen R. Carter, Novell\n                                                                            Del Jensen, Novell\n\n&lt;webdav-draft-06.html&gt;                                                January 23, 1997\n\nExpires June, 1997\n\nAuthor's draft: v0.6\n</PRE>\n\n<H1 ALIGN=CENTER>Extensions for Distributed Authoring and Versioning on\nthe World Wide Web </H1>\n\n<H2>Status of this Memo </H2>\n\n<P>This document is an Internet-Draft. Internet-Drafts are working documents\nof the Internet Engineering Task Force (IETF), its areas, and its working\ngroups. Note that other groups may also distribute working documents as\nInternet-Drafts.</P>\n\n<P>Internet-Drafts are draft documents valid for a maximum of six months\nand may be updated, replaced, or made obsolete by other documents at any\ntime. It is inappropriate to use Internet-Drafts as reference material\nor to cite them other than as &quot;work in progress&quot;. </P>\n\n<P>To learn the current status of any Internet-Draft, please check the\n&quot;<I>1id-abstracts.txt</I>&quot; listing contained in the Internet-Drafts\nShadow Directories on <I>ftp.is.co.za</I> (Africa), <I>nic.nordu.net</I>\n(Europe), <I>munnari.oz.au</I> (Pacific Rim), <I>ds.internic.net</I> (US\nEast Coast), or <I>ftp.isi.edu</I> (US West Coast). </P>\n\n<P>Distribution of this document is unlimited. Please send comments to\nthe WWW Distributed Authoring and Versioning (WEBDAV) working group at\n&lt;<I>w3c-dist-auth@w3.org&gt;</I>, which may be joined by sending a message\nwith subject &quot;subscribe&quot; to <I>&lt;w3c-dist-auth-request@w3.org&gt;</I>.\nDiscussions of the WEBDAV working group are archived at <I>&lt;URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth&gt;</I>.\nThe HTTP working group at <I>&lt;http-wg@cuckoo.hpl.hp.com&gt;</I> also\ndiscusses the HTTP protocol. Discussions of the HTTP working group are\narchived at <I>&lt;URL:http://www.ics.uci.edu/pub/ietf/http/&gt;.</I> General\ndiscussions about HTTP and the applications which use HTTP should take\nplace on the <I>&lt;www-talk@w3.org&gt;</I> mailing list. </P>\n\n<H2>Abstract </H2>\n\n<P>[Ed. Note: TBD]</P>\n\n<H2>1. Introduction </H2>\n\n<H3>1.1 Purpose </H3>\n\n<P>The purpose of this document is to extend the HTTP 1.1 [HTTP11] protocol\nto support features which satisfy the Distributed Authoring and Versioning\nrequirements set down in [INSERT REFERENCE TO UNIFIED DAV REQUIREMENTS\nDRAFT].</P>\n\n<H3>1.2 Terminology</H3>\n\n<P>The following entries define how a term is used within this document.</P>\n\n<P>Unless otherwise noted, the use of terminology in this document is consistent\nwith the definitions of terms given in [HTTP11]. </P>\n\n<P><I>Editor: Sections references need to be entered.</I></P>\n\n<DL>\n<DT><B>arbiter</B></DT>\n\n<DD>A resource which performs actions on the behalf of other resources.</DD>\n\n<DT><B>attribute</B></DT>\n\n<DD>An attribute is a name/value pair which contains meta-information regarding\na resource. See section x.x.</DD>\n\n<DT><B>attribute set</B> </DT>\n\n<DD>An attribute set is a collection of attributes. See section x.x.</DD>\n\n<DT><B>set edit announcement</B></DT>\n\n<DD>A set edit announcement is a declaration by a principal that they intend\nto edit a resource. No action other than the declaration is implied by\na set edit announcement. See section x.x.</DD>\n\n<DT><B>remove edit announcement</B></DT>\n\n<DD>A remove edit announcement is a declaration by a principal that they\nno longer intend to edit a resource. See section x.x.</DD>\n\n<DT><B>check-out root</B></DT>\n\n<DD>One or more versioned resources within a particular version tree which\nare operated on by a CHECKOUT method. </DD>\n\n<DT><B>command comments</B> </DT>\n\n<DD>Command Comments associate either a string or a URI with an HTTP message.\nSee section x.x.</DD>\n\n<DT><B>copy</B> </DT>\n\n<DD>A copy performs a duplication of a resource, making it available at\nboth the original and new location in the URI namespace. Due to contextual\ndifferences, it may not be possible to create an exact copy of a resource.\nA copy only requires best effort on the part of the copy agent. See section\nx.x.</DD>\n\n<DT><B>collection</B></DT>\n\n<DD>A group of URIs which are manipulated as a unit. See section x.x.</DD>\n\n<DT><B>destroy</B> </DT>\n\n<DD>To destroy a resource is to request that the resource be permanently\nremoved from storage. This differs from delete in that some versioning\nsystems handle delete as a request to no longer make the specified resource\navailable under the specified URI. See section x.x.</DD>\n\n<DT><B>diff</B> </DT>\n\n<DD>A diff is a mechanism whereby two or more resources are compared and\nthe differences enumerated. See section x.x.</DD>\n\n<DT><B>history</B> </DT>\n\n<DD>A history lists the URIs of the versions of a resource along with related\ninformation. See section x.x.</DD>\n\n<DT><B>merge</B> </DT>\n\n<DD>A merge is the process whereby information from multiple resources\nis folded into a single resource. Merges can occur at the client or the\nserver. See section x.x.</DD>\n\n<DT><B>move</B> </DT>\n\n<DD>A move is logically an atomic action consisting of a copy followed\nby a delete of the source resource. Please see the definition of copy in\nthis section. See section x.x.</DD>\n\n<DT><B>no-modify lock</B> </DT>\n\n<DD>A no-modify lock prevents a locked resource from being edited until\nall no-modify locks on the resource are released. See section x.x.</DD>\n\n<DT><B>notify request</B> </DT>\n\n<DD>A notify request instructs the recipient to send information regarding\nthe progress of a request. See section x.x.</DD>\n\n<DT><B>principal</B> </DT>\n\n<DD>A principal is the source of a message. For example: persons, computers,\nand programs. </DD>\n\n<DT><B>read lock</B> </DT>\n\n<DD>A read lock prevents principals who do not posses a read lock on a\nresource from reading that resource. See section x.x.</DD>\n\n<DT><B>redirect</B></DT>\n\n<DD>A redirect instructs a server to return one of the 3xx series codes.\nSee section x.x.</DD>\n\n<DT><B>relationship</B> </DT>\n\n<DD>A relationship is a unidirectional typed link. See section x.x.</DD>\n\n<DT><B>shared mode</B> </DT>\n\n<DD>Shared mode modifies a lock request such that the lock may be shared\nbetween multiple principals. See section x.x.</DD>\n\n<DT><B>version identifier</B></DT>\n\n<DD>The identifier used to name a version of a resource. </DD>\n\n<DT><B>working resource</B></DT>\n\n<DD>The writeable resource created by some versioning engines as the result\nof a CHECKOUT method invocation.</DD>\n\n<DT><B>write lock</B> </DT>\n\n<DD>A write lock prevents principals who do not possess a write lock on\na resource from editing that resource. See section x.x.</DD>\n</DL>\n\n<H3>1.3 Notational Conventions and Generic Grammar </H3>\n\n<P>This specification uses the Augmented BNF and Basic Rules as defined\nin Section 2 of [HTTP11]. </P>\n\n<H3>1.4 Design Conventions</H3>\n\n<P>The following design conventions have been adopted by the HTTP Distributed\nAuthoring and Versioning (DAV) group.</P>\n\n<OL>\n<LI>Whenever reasonable new functionality will be expressed as new methods.\nWhen sensible the commands for such a method will be included in the message\nbody of the request.</LI>\n\n<LI>This resolution was adopted in order to solve a debate about how to\nexpress new functions such as copy and diff. One group wished to use POST\nand MIME types to express new commands. Another group wished to use new\nmethods and MIME types to express new commands. A third group wished to\nuse new methods and new method headers to express new commands. The group\nsettled on using new methods and MIME types to express new commands. The\nnew methods would allow for quick parsing by proxies and servers but the\nMIME types would allow for flexibility in specifying the command. It was\nalso felt that introducing method specific headers would violate the letter\nand spirit of the HTTP protocol.</LI>\n\n<LI>Methods should only perform a single action.</LI>\n\n<LI>The original design of many of the methods in this document allowed\nfor multiple requests of the same type to be packaged together. So, for\nexample, one could send a Copy method which specified that 1000 different\nURIs should be copied. It was decided that in the face of pipelining, compressed\nheaders, and other innovations there was no need to add this level of complexity\nto the protocol. This decision was based upon the assumption that a new\nmethod or MIME type would be introduced which would allow for any number\nof HTTP requests to be bundled together. It was further assumed that such\na method or MIME type would carry with it the option to specify that the\ncontents be processed atomically.</LI>\n\n<LI>URLs are opaque tokens and should be treated as such.</LI>\n\n<LI>It is often possible to decrease the number of trips to retrieve a\nparticular piece of data by putting suffixes on URLs. However URLs are\nintended to be opaque tokens. The above design principal not prevent the\nuse of suffixes but rather requires that the server indicates that a particular\nURL understands a particular type of suffix.</LI>\n\n<LI>Only addressable entities will be subject to the commands in this document.</LI>\n\n<LI>Response must be machine processable. Currently HTTP responses rely\nupon humans being available to view the response and take appropriate action.\nThis level of error encoding is not sufficient for WEBDAV purposes where\nall actions and results of all actions must be fully machine processable.\nHowever, a corollary of this design principal is that response messages\nare not required to provide information about incorrect syntax, only to\npoint out that incorrect syntax has been submitted. It is legitimate to\nassume that the client and server are both capable of generating proper\nsyntax. However, this corollary in no way effects the general principal\nof being generous in the sorts of messages accepted.</LI>\n</OL>\n\n<DIR>\n<DIR>\n<LI>It is sometimes desirable to have a non-addressable entity. For example,\nan accept header may specify a content-language. The response may contain\na representation in that language but may not contain a content-location\nheader. In that case the representation of that resource in that language\nwill not alterable with the commands given in this document.</LI>\n</DIR>\n</DIR>\n\n<P>&nbsp;</P>\n\n<H2>2. Schema Methods</H2>\n\n<P><I>[Ed. Note: Misplaced this section - should follow links. Will correct\nlater.]</I></P>\n\n<H3>2.1 Introduction</H3>\n\n<P>DAV methods provide diverse abilities, and no current system supports\nall of them. As such the client requires a mechanism to determine what\nfeatures of a method a server supports. DAV provides such a mechanism controlling\nhow methods are defined and then providing for a feature discovery mechanism.\nDAV also provides for a version number to allow servers to alter method\nsemantics without breaking older clients.</P>\n\n<H3>2.2 Method Formatting</H3>\n\n<P>Part of the feature discovery mechanism is a regulated format for method\nrequest bodies. This format allows for individual method functions to be\nidentified and for the server to be able to describe its support for those\nfunctions. Methods that support this format are referred to as Schema Methods.\nAll Schema Methods MUST use this format. [Author's Note: We will have to\nchange the name.]</P>\n\n<P>A Schema Method takes the following form:</P>\n\n<P><TT>Request-Body = Schema-Version CRLF *(Schema-Entry CRLF)<BR>\nSchema-Version = 1*Digit.1*Digit<BR>\nSchema-Entry = AttributeName &quot;:&quot; (Enumerated_List | Comma_List\n| Open_Value)<BR>\nAttributeName = Token<BR>\nEnumerated_List = #Token<BR>\nComma_List = #Token<BR>\nOpen_Value = Text-No-CRLF<BR>\nText-No-CRLF = ; Text which doesn't contain a CRLF</TT></P>\n\n<P>The method's request body always begins with a Schema-Version that is\nfollowed by a series of Schema-Entries. These entries always consist of\na name followed by a colon followed by either a predefined list of values,\na comma separated list of tokens, or an open value which can contain any\nlegal text but a CRLF.</P>\n\n<P>The Schema-Version major number describes a set of schema entries and\ntheir defined values for a particular method. The major number MUST increase\nif the semantics of a previously defined schema entry is altered or if\nthe Schema Method format is changed.</P>\n\n<P>The Schema-Version minor number is used for feature negotiation purposes.\nAs defined below feature negotiation allows the server to list each schema-entry\nand indicate if the entry is required, optional, or unsupported. A server\nMAY add new schema-entries to a method without changing the minor schema-version\nnumber so long as those entries are optional. If a new required schema-entry\nis introduced then the minor number MUST be increased.</P>\n\n<H3>2.3 Schema Entry Negotiation &amp; Response Format</H3>\n\n<P>With the Schema Method format it becomes possible for a server to provide\ninformation to a client regarding the schema-entries it supports and the\nmanner in which it supports them. This mechanism is completely mechanistic\nso any Schema Method can be negotiated upon. This section describes the\nresponse format used by a server to declare the nature of its support for\na Schema Method.</P>\n\n<P>The format is to list each schema entry, mark it as required, optional,\nor unsupported, and then indicate what values it may take on. Schema entries\nwith predefined lists of values the server lists which of those values\nis supported. For schema entries with a comma delaminated list of tokens,\nthe server indicates how many tokens it will accept. No additional information\nis provided for schema entries that use the Text-No-CRLF production.</P>\n\n<P>A client MAY include schema entries whose values are enumerated lists\nfor which there is only a single legal value. A client MUST NOT include\nschema entries that have been marked as unsupported. A client MAY include\na schema entry that is marked as optional. A client MUST include schema\nentries that are marked as required. A client MUST only use values that\nthe server has indicated it will accept. If definition of a Schema Method\ndoes not state that a schema entry is required then the server MAY make\nthat entry required, optional, or unsupported. The Schema-Version production\nMUST be included in all request bodies of all Schema Methods. The definition\nof a Schema Method MAY put restrictions on the interaction of schema entries,\nsuch as declaring that if one schema-entry is required then so must another.</P>\n\n<P>The format for providing Schema Method negotiation information is a\nweb collection that is contained in a response of type Text/HTML.</P>\n\n<P><B>WC Attributes:<BR>\n<BR>\n</B><TT>Type = &quot;DAV/VersionSupport&quot;<BR>\nName = MethodName<BR>\nSchema-Version = SupportedVersions<BR>\nSupportedVersions = #(VersionRange | MajorNumber | Individual)<BR>\nVersionRange = Schema-Version &quot;to&quot; Schema-Version<BR>\nMajorNumber = 1*Digit &quot;.&quot; &quot;*&quot;<BR>\nIndividual = Schema-Version</TT></P>\n\n<P><B>WCDATA Entry:</B></P>\n\n<P><TT>Entry = AttributeName (Required_Optional | &quot;Unsupported&quot;)\nCRLF<BR>\nAttributeName = Token<BR>\nRequired_Optional = (&quot;Required&quot; | &quot;Optional&quot;) [(EnumList\n| NumLegalEntries)]<BR>\nEnumList = &quot;Enumerated_List&quot; &quot;:&quot; &quot;[&quot;#Token&quot;]&quot;\n| &quot;AsDefined&quot;<BR>\nNumLegalEntries = &quot;Number_Entries&quot; &quot;:&quot; 1*Digit | &quot;Infinite&quot;\n| &quot;AsDefined&quot; </TT></P>\n\n<P>The &quot;AsDefined&quot; value is used when the definition of possible\nvalues is too complex to be expressed in this simple negotiation format.</P>\n\n<P>The VersionRange production allows the server to declare support for\nall versions within a specified range. The MajorNumber production allows\nthe server to declare support for all versions within a major version.\nThe Individual version production allows the server to declare support\nfor an individual version.</P>\n\n<P>Multiple web collections may be specified as necessary if support differs\nbased on schema-version.</P>\n\n<H3>2.4 Schema Method Support Discovery</H3>\n\n<P>Two mechanisms are provided for discovering server support for a Schema\nMethod. One is by checking for a link and the other is by using a discovery\nmethod. A server MUST support at least one of these two mechanisms.</P>\n\n<H3>2.4.1 SchemaMethod Link</H3>\n\n<P>The type of the schema method link is defined as follows:</P>\n\n<P>SchemaMethodLink = <TT>&quot;DAV.SchemaMethod.&quot; MethodName<BR>\nMethodName = Token</TT></P>\n\n<P>This destination of this link is the support provided by the source\nfor the method specified. The result will be a text/html response body\ncontaining a series of web collections describing the systems support for\nthat Schema Method.</P>\n\n<P>[NOT YET DEFINED - A Web Collection to indicate that there is variation\nof function based on namespace.]</P>\n\n<H3>2.4.2 SCHEMASUPPORT</H3>\n\n<H3>2.4.2.1 Method Definition</H3>\n\n<H3>2.4.2.2 Request Body</H3>\n\n<H3>2.4.2.3 Response Body</H3>\n\n<H3>2.4.2.4 Error Conditions</H3>\n\n<P>[2.4.2 NOT YET DEFINED - It will provide for the submission of a schema\nmethod name and information about schema versions supported by the client.\nThe server will then return a web collection specifying the sort of support\nprovided for the schema method and schema versions indicated.]</P>\n\n<H2>3. Links</H2>\n\n<H3>3.1 Introduction</H3>\n\n<P>In [HTTP11] link and unlink methods were introduced. The idea was to\nallow for two or more arbitrary resources to be associated with each other.\nIn essence, its purpose was to extend the linking facilities available\non the Web to all content types, not just HTML.</P>\n\n<P>This document proposes a link facility consisting of links which are\ntyped and unidirectional, containing an explicit source and destination.</P>\n\n<H3>3.2 Link Types</H3>\n\n<P>Links are typed. These types explain the purpose and behavior of a link.\nIt is possible that multiple links defined on the same resource may have\nthe same type, e.g., a resource with multiple authors.</P>\n\n<P>A link type usually belongs to a link schema, such as the &quot;LockInfo&quot;\ntype which belongs to the &quot;DAV&quot; schema. By convention, links\nwhich belong to a schema are specified as: schema &quot;.&quot; typename.\nThus, the LockInfo type would be specified as &quot;DAV.LockInfo&quot;.\nThis creates a type namespace which is less susceptable to namespace collision\nthan a single, flat namespace. However, use of the &quot;.&quot; to denote\nhierarchy is only a convention, since types are properly considered to\nbe opaque tokens.</P>\n\n<H3>3.3 LINK</H3>\n\n<H3>3.3.1 Method Definition</H3>\n\n<P>The LINK method requests that a single typed unidirectional hypertext\nlink be created on the Request-URI. This link consists of three fields,\na source URI, a destination URI, and a type, which is an opaque token.\nThe source URI is the beginning of the link, the destination URI is the\nendpoint of the link, and the type describes the relationship between the\nsource and destination resources. A link may be interpreted as a binary\nrelationship between the source and destination resources, which has the\nmeaning, &quot;the destination resource contains information of relation\n&lt;type&gt; to the source resource.&quot; A link may also be interpreted\nas an attribute-value pair, where the attribute name is the link type,\nand the value is pointed to by the destination of the link.</P>\n\n<P>The specification of the requested link is made in the message body\nof the LINK request, which SHOULD be of content type &quot;application/link&quot;.\nThe source URI of the link will typically correspond to the Request-URI\nof the LINK request, but MUST not be required to do so. Either the source\nURI or the destination URI of the link MUST correspond to the Request-URI\nof the LINK request. This ensures that the Request-URI is part of the link\nbeing defined.</P>\n\n<P>If the source URI is ommitted in the link specification, the source\nURI defaults to the Request-URI. If the destination URI is ommitted in\nthe link specification, the destination URI defaults to the Request-URI.\n</P>\n\n<P>Some servers may automatically allocate part of their namespace for\nlink information of a specific type. For example, the creation date of\na resource at URL &lt;http://www.ics.uci.edu/resource.html&gt; might be\naccessed from &lt;http://www.ics.uci.edu/resource.html?create_date&gt;.\nIn this case, a user-agent would not want to specify the destination of\na link of type &quot;create_date,&quot; and instead would want the server\nto automatically fill-in the correct destination URI. If the server should\nspecify the source or destination URI of a link, then the key word &quot;SET&quot;\nis entered for the source or destination URI in the link specification.</P>\n\n<H3>3.3.2 Request Body</H3>\n\n<P>The request body of a LINK method request is of content type application/link,\ndefined as:</P>\n\n<PRE>Link = Version CRLF [ Source CRLF ] [ Destination CRLF ] Type CRLF \nSchema-Version = &quot;Schema-Version&quot; &quot;:&quot; 1*Digit &quot;.&quot; 1*Digit \nSource = &quot;Source&quot; &quot;:&quot; ( URI | &quot;SET&quot; ) \nDestination = &quot;Destination&quot; &quot;:&quot; ( URI | &quot;SET&quot; ) \nType = &quot;Type&quot; &quot;:&quot; token</PRE>\n\n<P>The Schema-Version field specifies the version of the specification\nof the application/link media type. By definition, the version of the application/link\nmedia type specified in this document is &quot;1.0&quot;.</P>\n\n<P><B>Example</B></P>\n\n<PRE>Source: http://www.ics.uci.edu/~ejw/reports/Q1.html \nDestination: http://www.ics.uci.edu/~ejw/reports/Q1_author.html \nType: Author</PRE>\n\n<P>This link states that the destination URI contains information about\nthe author of the source URI. It may also be interpreted as the value of\nthe author attribute of the source URI can be found in the resource pointed\nto by the destination URI.</P>\n\n<H3>3.3.3 Response Body</H3>\n\n<P>The request body of a LINK method request is of content type application/linkresult,\ndefined as:</P>\n\n<PRE>LinkResult = Version CRLF LinkSource CRLF LinkDestination CRLF Type CRLF \nLinkSource = &quot;Source&quot; &quot;:&quot; URI \nLinkDestination = &quot;Destination&quot; &quot;:&quot; URI \nType = &quot;Type&quot; &quot;:&quot; token\n</PRE>\n\n<H3>3.3.4 Error Conditions</H3>\n\n<P>a) there is a syntax error in the application/link message body (e.g.,\nmissing field values, missing type value) </P>\n\n<P>b) the source URI and the destination URI fields are both missing </P>\n\n<P>c) Both the source URI and the destination URI are specified, and neither\nmatch the Request-URI.</P>\n\n<P>d) Unsupported Type - The server does not allow links of the specified\ntype to be created. </P>\n\n<P>e) The server does not have room to store the requested link. </P>\n\n<P>f) The server is unable to fulfill a request to automatically set an\nendpoint of the link.</P>\n\n<H3>3.5 UNLINK</H3>\n\n<H3>3.5.1 Method Definition</H3>\n\n<P>The UNLINK method requests the removal of any link defined on the Request-URI\nwhich exactly matches the link specification in the request message body,\nwhich must be of content type application/unlink.</P>\n\n<P>If there are any links which exactly match the link specification, a\ndescription of the removed links is returned in a response body of type\napplication/unlinkresult.</P>\n\n<H3>3.5.2 Request Body</H3>\n\n<P>The request body of an UNLINK method request is of content type application/unlink,\ndefined as:</P>\n\n<PRE>UnLink = Version CRLF Source CRLF Destination CRLF Type CRLF</PRE>\n\n<PRE>Schema-Version = &quot;Schema-Version&quot; &quot;:&quot; 1*Digit &quot;.&quot; 1*Digit \nLinkSource = &quot;Source&quot; &quot;:&quot; URI \nLinkDestination = &quot;Destination&quot; &quot;:&quot; URI \nType = &quot;Type&quot; &quot;:&quot; token</PRE>\n\n<P>The Schema-Version field specifies the version of the specification\nof the application/unlink media type. By definition, the Schema-Version\nof the application/unlink media type specified in this document is &quot;1.0&quot;.</P>\n\n<H3>3.5.3 Response Body</H3>\n\n<P>The response body of an UNLINK method is of content type application/unlinkresult,\ndefined as:</P>\n\n<PRE>UnLinkResult = Version CRLF 1*(LinkSource CRLF LinkDestination CRLF Type CRLF)</PRE>\n\n<PRE>Schema-Version = &quot;Schema-Version&quot; &quot;:&quot; 1*Digit &quot;.&quot; 1*Digit \nLinkSource = &quot;Source&quot; &quot;:&quot; URI \nLinkDestination = &quot;Destination&quot; &quot;:&quot; URI \nType = &quot;Type&quot; &quot;:&quot; token\n</PRE>\n\n<H3>3.5.4 Error Conditions</H3>\n\n<P>a) there is a syntax error in the application/unlink message body (e.g.,\nmissing fields, missing field values, missing type value) </P>\n\n<P>b) Both the source URI and the destination URI are specified, and neither\nmatch the Request-URI.</P>\n\n<P>c) No links match the specification in the request message body. </P>\n\n<H3>3.6 LINKSEARCH</H3>\n\n<H3>3.6.1 Method Definition </H3>\n\n<P>The LINKSEARCH method is used to search on the link tuple space. The\nsearch occurs in the URI namespace. Search points and scope define the\narea of name space to be searched. The search points are URIs from which\nthe search should start. The scope defines the number of levels into the\nURI namespace the search should go down. The search syntax is in prefix\nnotation in order to ease processing by the server.</P>\n\n<H3>3.6.2 Request Body </H3>\n\n<P>The Request-URI is the search arbiter, and it is the job of that resource\nto process the request and return the results. </P>\n\n<P>The media type is application/linksearch.</P>\n\n<P>This syntax is adapted from [RFC1959] and [RFC1960]. </P>\n\n<PRE>LinkSearchMethod = Schema-Version CRLF [SearchPoints] CRLF SearchPattern CRLF Scope CRLF\nSearchPoints = &quot;SearchPoints&quot; &quot;:&quot; 1#URI \nSearchPattern = &quot;SearchPattern&quot; &quot;:&quot; 1*SearchOperations\nSearchOperations = And | Or | Not | Item\nAnd = &quot;&amp;&quot; 2*SearchOperations\nOr = &quot;|&quot; 2*SearchOperations\nNot = &quot;!&quot; SearchOperations \nItem = Operator CompareTo MatchPattern\nOperator = &quot;=&quot; | &quot;!=&quot;\nCompareTo = &quot;Source&quot; | &quot;Destination&quot; | &quot;Type&quot;\nMatchPattern = 1*(token | &quot; *&quot;) CRLF \nScope = &quot;Scope&quot; &quot;:&quot; 1*Digit | &quot;Sub&quot; </PRE>\n\n<P>The SearchPoints are URIs on which the search is to be performed. If\nat least one URI is not listed in SearchPoints then the search point becomes\nthe request-URI. </P>\n\n<P>The operator is equals &quot;=&quot; or not equals &quot;!=&quot;. Source\nand Destination equality are dependent upon the type of URIs. Please refer\nto the definition of the referenced URI type to determine equality rules.\nThe server MUST NOT compare URIs with which it is not familiar. Two types\nare equal if their tokens are octet for octet equal. </P>\n\n<P>The MatchPattern allows for wildcard matching. Inserting spaces prevents\nthe wildcard character to not be confused with characters in the token.\nA wildcard character matches zero or more characters. </P>\n\n<P>The scope operator specifies how deep into the URI namespace the search\nshould go. A scope of 0 means the search is only on the search point(s).\nA scope higher than zero means the search should proceed scope levels down\nthe URI namespace. A scope of &quot;sub&quot; means the search should go\nall the way down to the leaves of the namespace. </P>\n\n<P>Redirects may only be followed if the new location is within the defined\nsearch space. </P>\n\n<H3>3.6.3 Response Body</H3>\n\n<P>The response body will be of type text/html and contain a web collection\nwith type &quot;DAV/LinkSearchResponse&quot;. That web collection will\nitself contain a series of web collections that have the following definition:</P>\n\n<P><B>WC Attributes</B></P>\n\n<P><TT>Type = &quot;DAV/LinkResponse&quot;</TT></P>\n\n<P><B>WCDATA Entry</B></P>\n\n<P><TT>Entry = [OnSource] [OnDestination] Type<BR>\nOnSource = [&quot;ON&quot;] &quot;Source&quot; &quot;:&quot; URI CRLF<BR>\nOnDestination = [&quot;ON&quot;] &quot;Destination&quot; &quot;:&quot;\nURI CRLF<BR>\nType = &quot;Type&quot; &quot;:&quot; token CRLF</TT></P>\n\n<P>Each DAV/LinkResponse indicates the source, destination, and type of\na link result. The &quot;ON&quot; tag indicates if the source and/or destination\nis aware of the link's existence.</P>\n\n<H3>3.6.4 Error Conditions</H3>\n\n<P><I>Editor: these error conditions will be merged with the response codes\nin the following section in a future rev. of the document.</I></P>\n\n<P>URI Doesn't Exist (From Here on Down) (Incomplete) - </P>\n\n<P>URI Access is Forbidden (From Here on Down) (Incomplete) - 403 Forbidden\n</P>\n\n<P>URI Access is Not Allowed (From Here on Down) (Incomplete) - 401 Unauthorized\n</P>\n\n<P>URI Not Found (From Here on Down) (Incomplete) - 404 Not Found </P>\n\n<P>Arbiter does not Support Search on this URI (From Here on Down) (Incomplete)\n- 406 Not Acceptable </P>\n\n<P>URI does not Support Search (From Here on Down) (Incomplete) - 405 Method\nNot Allowed </P>\n\n<P>URI has been redirected out of search space (Temporarily | Permanently)(From\nHere on Down)(Incomplete) - 301 Moved Permanently, 302 Moved Temporarily\n</P>\n\n<P>Unknown URI Type in Comparison (Include URI) </P>\n\n<H3>3.6.5 Response Codes </H3>\n\n<P>202 Accepted - The request has been accepted and an appropriate response\ngenerated. </P>\n\n<P>203 Non-Authoritative Information - The request has been accepted but\nthe response may be based on outdated or non-authoritative link information.\n</P>\n\n<P>413 Request Entity Too Large - The results of the request are larger\nthan the server is willing to return. The request should be made again\nusing an appropriate range header. No body is returned.</P>\n\n<P>&nbsp;</P>\n\n<H3>3.7 GETLINKS </H3>\n\n<H3>3.7.1 Method Definition </H3>\n\n<P>GETLINKS is a convenience method that takes a type and returns a webmap\ncontaining link tuples whose source or destination equals the Request-URI\nand whose type matches the submitted typed. </P>\n\n<H3>3.7.2 Request Body </H3>\n\n<P>The media type of the request body is application/GETLINKS.</P>\n\n<PRE>GetLinksMethod = Schema-Version CRLF TaggedType CRLF\nTaggedType = &quot;Type&quot; &quot;:&quot; #type | &quot;All&quot;\n</PRE>\n\n<H3>3.7.3 Response Body </H3>\n\n<P>A text/html media type containing a web collection of type DAV/GetLinksResponse\nthat contains DAV/LinkResponse entries.</P>\n\n<H3>3.7.4 Response Codes </H3>\n\n<P>See the return codes for the LinkSearch method. </P>\n\n<P>&nbsp;</P>\n\n<H3>3.8 GETLINKVAL</H3>\n\n<H3>3.8.1 Method Definition </H3>\n\n<P>GetLinkVal is a convenience method that takes a type and returns a message/multipart.\nThe first entry in the message/multipart is a Web Collection with link\ntuples whose source or destination equal the Request-URI and whose type\nmatches the submitted type. The rest of the entries in the message/multipart\nare the result of a GET submitted on the source or destination of the link\nthat does not equal the Request-URI. </P>\n\n<H3>3.8.2 Request Body </H3>\n\n<P>The request body for method GETLINKVAL is of content type application/getlinkval,\ndefined below:</P>\n\n<PRE>GetLinkValMethod = Schema-Version CRLF TaggedType CRLF \n</PRE>\n\n<H3>3.8.3 Response Body</H3>\n\n<P>The response body is multipart/related. The first entry is of type text/html\ncontaining a DAV/GetLinkValResponse Web Collection containing DAV/LinkResponse\nweb collections. Following the text/html is a series of responses containing\nGET results.</P>\n\n<H3>3.8.4 Response Codes </H3>\n\n<P>See return codes for the LinkSearch method. </P>\n\n<H3>3.9 SETLINKVAL</H3>\n\n<H3>3.9.1 Method Definition</H3>\n\n<P>SETLINKVAL is a convenience method that combines LINK and PUT. It is\nused to create a link and to specify the contents of one end of the link.</P>\n\n<H3>3.9.2 Request Body</H3>\n\n<P>The request body consists of a MIME multipart. The first entry is the\nrequest body contained below which is of type Application/SETLINKVAL. The\nsecond entry is the headers and body of the information to be PUT.</P>\n\n<P><TT>SETLINKVAL = Schema-Version CRLF LINK CRLF PutDestination CRLF ;\nLINK in Section 3.3.2<BR>\nPutWhere = &quot;Put-Where&quot; &quot;:&quot; &quot;Source&quot; | &quot;Destination&quot;</TT></P>\n\n<H3>3.9.3 Response Body</H3>\n\n<P>A web collection that contains the results from LINK and PUT.</P>\n\n<H3>3.9.4 Response Codes</H3>\n\n<P>TBD.</P>\n\n<P>&nbsp;</P>\n\n<H2>4. Distributed Authoring and Versioning Link Schema</H2>\n\n<P>This section specifies only those link types which are absolutely necessary\nto implement the functionality described in this specification. Link types\nother than the ones described within are possible, but must be defined\nin other documents. Since there are many different possible relationships\nwhich can exist between resources, there are many different link types\nwhich can exist to describe these relationships. It is difficult, if not\nimpossible to enumerate and describe all of these relationships, especially\nsince the meaning of the same type may vary depending on usage context.\nThis specification has therefore chosen not to try and enumerate all possible\nlink types, instead providing a mechanism for discovering which link types\n(DAV.SupportedLinkTypes), and which sets of link types (DAV.SupportedLinkSchemas)\nare supported on a resource.</P>\n\n<P>A server is not required to support all of the DAV Link Types. However,\nif a server supports a DAV Link Type, it SHOULD maintain the consistency\nof that relationship by ensuring the contents of the Destination URI are\nalways up-to-date.</P>\n\n<P>The DAV Link Types specified in this document form the &quot;DAV&quot;\nlink schema. </P>\n\n<P>All DAV schema links have a source URI which is the resource being described\nby the link. The destination URI alway points to a resource whose content\ntype, and contents are described below for each DAV link type.</P>\n\n<H3>4.1 DAV.Versioning.History</H3>\n\n<H3>4.1.1 Link Definition</H3>\n\n<P>The history link returns information about the history of a versioned\ndocument. This information is contained within a DAG that describes the\nancestors and children of various versions in the tree. The history link\nMUST be defined on the tree handle and SHOULD be defined on individual\nversions. Versions that do not have a history link MUST have a tree link\ndefined on them. </P>\n\n<H3>4.1.2 Link Type</H3>\n\n<P>The history link has type DAV.Versioning.History.</P>\n\n<H3>4.2.3 Destination Body</H3>\n\n<P>The destination body of the history link is a text/html file containing\na series of web collections of type &quot;DAV/History&quot;.</P>\n\n<P>WC Tag Attributes:</P>\n\n<PRE>Type = &quot;DAV/History&quot;\nName = VersionToken</PRE>\n\n<P>WCAT Tag Attributes and/or WCDATA Entry:</P>\n\n<PRE>Rel = (&quot;ParentEntry&quot; | &quot;ChildEntry&quot; | &quot;SiblingEntry&quot;)\nVersion = Token\nHREF = Pointer to a web collection w/more information</PRE>\n\n<PRE>Rel = (&quot;Parent&quot; | &quot;Child&quot; | &quot;Sibling&quot;)\nVersion = Token\nHREF = Pointer to a parent, child, or sibling.</PRE>\n\n<P>The Rel/Version/HREF triples above can be used with WCAT or WCDATA.\nThe *Entry links provide pointers to web collections with more information\nabout the family member. The version tag provides the version of the relative\nbeing pointed to. The second Rel/Version/HREF triple provides a pointer\ndirectly to the versioned resource. All attributes defined on HCs MAY also\nbe used here to provide information such as creation date, author, owner,\netc.</P>\n\n<H3><B>4.2 DAV.Versioning.CheckedOut</B></H3>\n\n<P>A server MAY create a link of type DAV.Versioning.CheckedOut on the\ncheck out root(s), the working resource, or both. The destination resource\nof a DAV.Versioning.CheckedOut link is of content type application/checkoutresult,\nwhich contains the same information as the response body to the CHECKOUT\nmethod. invocation which caused the creation of this link. An optional\nWeb Collection attribute, &quot;Principal&quot; may also be included, which\nholds information about the principal(s) who initiated the check out. </P>\n\n<H3><B>Principal</B></H3>\n\n<P><B>WC Attributes:</B></P>\n\n<BLOCKQUOTE>\n<DIR>\n<LI><B>Type = &quot;DAV/Identifier&quot;</B></LI>\n</DIR>\n</BLOCKQUOTE>\n\n<P><B>WCDATA Attributes:</B></P>\n\n<BLOCKQUOTE>\n<DIR>\n<LI><B>ContactURI = &quot;URI&quot;</B></LI>\n</DIR>\n</BLOCKQUOTE>\n\n<H3><B>4.3 DAV.Versioning.DefaultPublished. </B></H3>\n\n<P>A server MAY create a link of type DAV.Versioning.DefaultPublished on\nthe version tree handle and all members of the version tree pointed to\nby the handle. The destination resource of a DAV.Versioning.DefaultPublished\nlink is a member of the version tree, and points to the version which has\nbeen designated as being appropriate for display to non-editors. The DAV.Versioning.DefaultPublished\ndestination resource SHOULD be returned to non-DAV aware clients who perform\na GET on a version tree handle.</P>\n\n<H3><B>4.4 DAV.Versioning.NextVersion </B></H3>\n\n<P>A server MAY create a link of type DAV.Versioning.NextVersion on a versioned\nresource. The destination resource of a DAV.Versioning.NextVersion link\nis the version that immediately succeeds the source. A resource MAY have\nmultiple DAV.Versioning.NextVersion links.</P>\n\n<H3>4.5&nbsp;DAV.SupportedLinkTypes</H3>\n\n<P>Destination resource content type: Web Collection <BR>\nSynytax: TBD</P>\n\n<P>The contents of the destination resource is a list of the link types\nwhich the server will definitely allow to be created on the source URI.\nThe server may allow the creation of links with types other than those\ncontained in the destination resource, but this is not guaranteed.</P>\n\n<P>If a server supports a particular schema, then all link types in the\nsupported schema SHOULD be returned in the destination resource of a SupportedLinkTypes\nlink.</P>\n\n<P>If a server implements the LINK method, it MUST also implement the SupportedLinkTypes\nlink.</P>\n\n<H3>4.6 DAV.SupportedLinkSchemas</H3>\n\n<P>Destination resource content type: Web Collection <BR>\nSyntax: TBD</P>\n\n<P>The contents of the destination resource is a list of link schemas.\nIf a link schema is listed, it means that the server SHOULD allow the creation\nof links with types belonging to that schema. The server may allow the\ncreation of links with types which do not belong to a schema listed in\nthe destination resource, but this is not guaranteed.</P>\n\n<P>If a server implements the LINK method, it SHOULD also implement the\nSupportedLinkSchemas link.</P>\n\n<H2>5. Relationships</H2>\n\n<P>[Ed. Note: This section will be removed from the spec and appended]</P>\n\n<P>&nbsp;</P>\n\n<H2>6. Locking</H2>\n\n<H3>6.1 Introduction</H3>\n\n<P>The mechanism for locking and unlocking a resource involves the use\nof a &quot;lock token&quot; (LockToken) which is used to reference the\ninstantiation of the lock. Each lock token instantiates the occurrence\nof a lock on one resource or a specified portion of a resource (i.e., a\nlock on a range of a resource). The locking of multiple resources will\ncause the instantiation of an equal number of lock tokens. </P>\n\n<P>Lock tokens represent a lock that is specific to the context of a server\nand therefore can not be transferred to another server. Nor is it allowable\nto transfer the LockToken to another &quot;client space&quot; even if both\nare instantiated on the same server. A &quot;client space&quot; is defined\nas the data space in the context of the client obtaining the lock. More\nthan one thread can be active in a given &quot;client space.&quot; </P>\n\n<P>A mechanism is provided to ensure that a method is executed only if\na lock is in place. This mechanism allows a lock header to be included\nin the method request. The method will be executed only if the LockToken\nis still valid. Multiple LockTokens may be include in the lock header.\nLock headers may reference any LockToken allowing the submission of a method\non a resource with a LockToken that refers to another resource. </P>\n\n<P>A lock may designate &quot;write exclusive&quot; on a given resource.\n&quot;Write exclusive&quot; is currently the only type of lock supported.\nA single range for the &quot;write exclusive&quot; lock may be defined\nand overlapping ranges are never allowed. Thus a lock on the entire resource\nwould be exclusive of any and all range locks on the same resource. Multiple\nrange locks may be instantiated for a given resource (even among multiple\n&quot;user spaces&quot;), but overlapping ranges are not permitted. The\nfollowing table describes the allowable states: </P>\n\n<TABLE BORDER=1 CELLPADDING=5 >\n<TR>\n<TD align=\"center\">\n<H4>Request</H4>\n</TD>\n\n<TD align=\"center\">\n<H4>State</H4>\n</TD>\n\n<TD align=\"center\">\n<H4>Result</H4>\n</TD>\n</TR>\n\n<TR>\n<TD>full</TD>\n\n<TD>full</TD>\n\n<TD>denied</TD>\n</TR>\n\n<TR>\n<TD>full</TD>\n\n<TD>partial</TD>\n\n<TD>denied</TD>\n</TR>\n\n<TR>\n<TD>full</TD>\n\n<TD>none</TD>\n\n<TD>granted</TD>\n</TR>\n\n<TR>\n<TD>partial</TD>\n\n<TD>full</TD>\n\n<TD>denied</TD>\n</TR>\n\n<TR>\n<TD>partial</TD>\n\n<TD>partial</TD>\n\n<TD>granted*</TD>\n</TR>\n\n<TR>\n<TD>partial</TD>\n\n<TD>none</TD>\n\n<TD>granted</TD>\n</TR>\n</TABLE>\n\n<P>* if no overlap </P>\n\n<P>Once defined the definition of the lock range may not be modified. The\nonly mechanism supported is to release the lock and instantiate a new lock\nwith a defined range. </P>\n\n<P>The size of a resource may not be changed within the defined region\nof a lock range unless the range includes +n (n&gt;0) octets beyond the\nend of the resource (eof). By definition, locking a range beyond the eof\nprovides the owner with the ability to add to the eof and therefore extend\nthe resource. </P>\n\n<P>If an entire resource is locked and the lock owner deletes the resource\nthen the write lock remains. Further actions on the resource (e.g. PUT)\nare allowed because the LockToken is still instantiated. </P>\n\n<P>Each lock may have a time out associated with it. If no time out value\nis associated with the lock then the lock will never time out (implementors\nshould have some mechanism for destroying a lock at an administrative level).\nOtherwise the lock will expire if the designated amount of time has elapsed\nwithout a method being invoked on the resource by the lock owner. The time\nout value may be modified without affecting the rest of the the lock by\nsubmitting a lock request for the LockToken with no other values associated\nwith it other than a new time out value.</P>\n\n<H3>6.2 LOCK</H3>\n\n<H3>6.2.1 Method Definition</H3>\n\n<P><I>[Ed. Note: Need description of LOCK method.]</I></P>\n\n<P>The Request-URI of the LOCK method is the URI of the resource to be\nlocked.</P>\n\n<H3>6.2.2 Request Body</H3>\n\n<P>The lock request specifies the target of the lock, parameters of the\nlock, and requests that a lock be set on the resource. </P>\n\n<P>The request body of a LOCK method is of content type application/lock,\ndefined as:</P>\n\n<PRE>\nLockBody = Schema-Version LockEntry CRLF TimeOut CRLF \n           [LockRange CRLF] [LockOwner CRLF]\nLockEntry = &quot;LockEntry&quot; &quot;:&quot; LockWriteExclusive \nLockWriteExclusive = &quot;write exclusive&quot; \nTimeOut = &quot;TimeOutSeconds&quot; &quot;:&quot; TimeOutVal \nTimeOutVal = 1*digit | &quot;Infinite&quot; \nLockRange = &quot;LockRange&quot; &quot;:&quot; 1*digit &quot;-&quot; (1*digit | &quot;eof++&quot;) \nLockOwner = &quot;LockOwner&quot; &quot;:&quot; URI</PRE>\n\n<P>Example: </P>\n\n<PRE>LOCK /users/johndoe/davspec.html HTTP/1.1\nContent-Type: application/lock</PRE>\n\n<PRE>Schema-Version: 1.0\nLockEntry: write exclusive \nTimeOut: 2400 \nLockRange: 100-eof++ \nLockOwner: mailto:johndoe@foo.com \n</PRE>\n\n<H3>6.2.3 Response Body</H3>\n\n<P>The response body of a LOCK method is of content type application/LockResponse,\ndefined below. The syntax of this content type is that of a Web Collection.</P>\n\n<PRE>\nResourceLockResponse = WC_Open LockResponse WC_Close \nWC_Open = &quot;&lt;&quot;WC VERSION=&lt;&quot;&gt;1.0&lt;&quot;&gt; TYPE=&quot; (&quot;DAV/Lock&quot;|&quot;DAV/Unlock&quot;) \n          &quot;&lt;&quot;&gt;NAME=&lt;&quot;&gt;&quot; LockToken &quot;&lt;&quot;&gt;&gt;&quot; \nLockToken = token\n\nLockResponse = *WCAT LockData *WCAT \nLockData = &quot;&lt;WCDATA&gt;&quot; LockURI LockBody LockGranted &quot;&lt;/WCDATA&gt;&quot;\n            ; LockBody production from Section 6.2.2\n\nLockURI = &quot;ResourceLocked&quot; &quot;:&quot; URI\nLockGranted = &quot;LockGranted&quot; &quot;:&quot; RFC1123-date [*digit]  ;*digit for milliseconds\nWC_Close = &quot;&lt;/WC&gt;&quot; </PRE>\n\n<P>Example:</P>\n\n<P>This is a possible response body from the lock request example in Section\n6.2.2.</P>\n\n<PRE>&lt;WC VERSION=&quot;1.0&quot; TYPE=&quot;DAV/Lock&quot; NAME=&quot;LK_Xj5N75&quot;&gt;\n&lt;WCDATA&gt;\nResourceLocked: http://www.foo.com/users/johndoe/davspec.html\nSchema-Version: 1.0\nLockEntry: write exclusive \nTimeOut: 2400 \nLockRange: 100-eof++ \nLockOwner: mailto:johndoe@foo.com \nLockGranted: Thu, 23 Jan 1997 15:11:27 GMT\n&lt;/WCDATA&gt;\n&lt;/WC&gt;</PRE>\n\n<H3>6.2.4 Error Conditions</H3>\n\n<P>Lock already owned: <BR>\nLock range overlaps: <BR>\nInvalid range: <BR>\nResource not found: <BR>\nDenied: <BR>\nGeneral Failure: </P>\n\n<P>&nbsp;</P>\n\n<H3>6.3 UNLOCK</H3>\n\n<H3>6.3.1 Method Definition</H3>\n\n<P><I>[Ed. Note: Need description of Unlock method]</I></P>\n\n<P>The Request-URI of the UNLOCK method specifies the URI of the resource\nto be unlocked.</P>\n\n<H3>6.3.2 Request Body</H3>\n\n<P>The request body of an UNLOCK method is of content type application/unlock,\ndefined below:</P>\n\n<PRE>UnlockRequest = Schema-Version UnLockToken\nUnLockToken = &quot;UnLock-Token&quot; &quot;:&quot; LockToken \n</PRE>\n\n<H3>6.3.3 Response Body</H3>\n\n<P>The response body of an UNLOCK method is of content type application/UnlockResult,\nwhich is defined by the production <TT>ResourceLockResponse</TT>, defined\nin Section 6.2.3.</P>\n\n<H3>6.3.4 Error Conditions</H3>\n\n<P>Lock not found: <BR>\nLock not owned: <BR>\nLock timed out: <BR>\nDenied: <BR>\nGeneral Failure:</P>\n\n<P>&nbsp;</P>\n\n<H3>6.4 Lock Discovery </H3>\n\n<P><I>[Ed. Note: &quot;LockInfo&quot; link and associated &quot;LockDiscovery&quot;\nWC should be included in the section on DAV Link&nbsp;Schema links]</I></P>\n\n<H3>6.4.1 Lock Discovery via GetLinkVal</H3>\n\n<P>When a lock is taken out the system SHOULD record who owns the lock.\nOwnership information can be taken from the From header, from identification\nprovided by authentication, or from the LockOwners field. </P>\n\n<P>Lock Discovery is enabled via a DAV Schema link of type DAV.LockInfo.\nLock Discovery is performed by using the GetLinkVal method on links of\nthis type.</P>\n\n<P>The LockInfo Link is structured as:</P>\n\n<BLOCKQUOTE>\n<P>src = URI of the resource<BR>\ndest = URI of the lock discovery WC<BR>\ntype = &quot;LockInfo&quot; </P>\n</BLOCKQUOTE>\n\n<H3>6.4.2 Lock Discovery Destination Resource</H3>\n\n<P>The DAV.LockInfo destination resource is of content type text/html,\nwhich uses the Web Collection syntax:</P>\n\n<PRE>LockDiscoveryResponse = WC_Open LockResponse OtherFields WC_Close \nWC_Open = &quot;&lt;&quot;WC VERSION=&lt;&quot;&gt;1.0&lt;&quot;&gt; TYPE=&lt;&quot;&gt;DAV/LockDiscovery&lt;&quot;&gt;\n          NAME=&lt;&quot;&gt;&quot; LockToken &quot;&lt;&quot;&gt;&gt;&quot;\nLockResponse = *WCAT LockData *WCAT \nLockData = &quot;&lt;WCDATA&gt;&quot; LockBody LockGranted &quot;&lt;/WCDATA&gt;&quot; \nLockGranted = RF1123-date [*digit] \nOtherFields = (implementation specific) * \n&quot;Owner&quot; &quot;:&quot; 1*octet ** \nWC_Close = &quot;&lt;/WC&gt;&quot; </PRE>\n\n<P>* not negotiable, safely dropped by client <BR>\n** if available </P>\n\n<P>&nbsp;</P>\n\n<H2>7. Name Space Manipulation</H2>\n\n<H3>7.1 COPY</H3>\n\n<H3>7.1.1 Method Definition</H3>\n\n<P>This method requests the server to manipulate the mapping for the resource\nin the namespace such that a new location (mapping) is created for the\nRequest-URI in the namespace, while maintaining the existing location (mapping)\nin the namespace. The actual implementation is left to the discretion of\nthe server. The presence of hyperlinks within a resource creates special\nproblem in Web resources. The fact that these hyperlinks could be either\nabsolute or relative create yet another level of complexity.</P>\n\n<P>The Request-URL will be the URL for the source resource which will be\ncopied to the destination. In case of a versioned resource, depending on\nthe implementation, it may be either the root of the version tree, in which\ncase it may mean to copy the whole tree or a specific version (depending\non the value of request-version), or it may be the version tree history.\nIn case of non-versioned resource, it will refer to the resourse itself.</P>\n\n<P>The message body will contain the URL of the destination of the COPY.\nThe OVERWRITE header, as defined by this spec., defines the behavior of\nthe server if a resource already exists as referred to by destination URL.\nIf the value of the overwrite header is true (default), then any existing\nresource referenced by the destination URL will be overwritten. If the\nvalue of overwrite header is false then the copy will fail when the URL\nof an existing resource matches that of the destination URL. In case of\nnon-versioned collections, COPY can be used as one of the ways to add to\nthe collection.</P>\n\n<H3>7.1.2 Request Body</H3>\n\n<P>The information about the destination and the switch to determine if\nthe links need to copied as well, will be passed in the message body which\nshould be of the content type &quot;application/copy&quot;. Also defined\nin the body is a switch called &quot;copylink&quot;. If the value of this\nswitch is set to true, then the server should copy all the links that it\ndeems pertinent. This spec. leaves it to the discretion of the server to\ndetermine which links are or are not appropriate in the context of copy.\nWhen links are copied the following condition MUST be met: </P>\n\n<UL>\n<LI>The types of the links should be maintained across the copy.</LI>\n\n<LI>If the source field of a link matches Request-URI, then the source\nfield of the link on the copy destination should be destination URI.</LI>\n</UL>\n\n<P>The defination of the content type Application/Copy is as follows:</P>\n\n<BLOCKQUOTE>\n<PRE>copy = Schema-Version CRLF destination CRLF copylink CRLF [request-version CRLF]\nSchema-Version = 1*DIGIT &quot;.&quot; 1*DIGIT\ndestination = &quot;destination&quot; &quot;:&quot; URI\ncopylink = &quot;copylink&quot; &quot;:&quot; value\nvalue = &quot;true&quot; | &quot;false&quot;\nrequest-version = &quot;Request-Version&quot; &quot;:&quot; token\n</PRE>\n</BLOCKQUOTE>\n\n<H4>Note: COPY and Version Trees</H4>\n\n<BLOCKQUOTE>\n<P>The request-version token may be used to refer to a versioned resource\nby its version ID, in which case the Request-URI must point to the version\ntree handle. If the Request-URI points to the version tree handle and the\nrequest-version field is not provided, then the whole tree will be copied\nto the new location.</P>\n\n<P>The following rules apply when a versioned resource is invloved in a\ncopy operation:</P>\n\n<UL>\n<LI>A versioned resource can be copied into a non-versioned space.</LI>\n\n<LI>A versioned resource cannot be copied into another versioned resource.</LI>\n\n<LI>A non-versioned resource cannot be copied into a versioned resource.</LI>\n</UL>\n</BLOCKQUOTE>\n\n<H3>7.1.3 Response Body</H3>\n\n<P>The response body returns the status code back.</P>\n\n<H3>7.1.4 Error Conditions</H3>\n\n<P>The following status codes may be returned:</P>\n\n<P>OK - The server has successfully copied the resource, and all the links,\nif applicable, to the new location in the namespace.</P>\n\n<P>Copy failed due to some internal error:</P>\n\n<BLOCKQUOTE>\n<P>The source is missing<BR>\nThe desitination exists (and the overwrite switch is false)<BR>\nOne or more links (in case copylink switch is true) failed to copy due\nto some internal error.</P>\n</BLOCKQUOTE>\n\n<P>&nbsp;</P>\n\n<H3>7.2 COPYHEAD</H3>\n\n<H3>7.2.1 Definition</H3>\n\n<P>This is a discovery method to be used with COPY method. Since it is\nthe server's discretion to choose the links that it deems appropriate to\ncopy with the new resource location, these links have to be discoverable.\nCOPYHEAD provides this discovery mechanism to the client. The Request-URI\nwill be the URI for the source resource which will be copied to the destination.\nIn case of a versioned resource, it will be the version tree handle. In\ncase of non-versioned resource, it will refer to the resourse itself. The\ninformation about the destination (and the switch to determine if the links\nneed to copied as well) will be passed in the message body which should\nbe of the content type &quot;Application/Copyhead&quot;.</P>\n\n<H3>7.2.2 Request Body</H3>\n\n<P>The definition of application/copyhead is exactly the same as application/copy.</P>\n\n<H3>7.2.3 Response Body</H3>\n\n<P>The response will be a Web Collection. It will contain a list of all\nthe links that the server deems appropriate to copy with the destination\nURI.</P>\n\n<PRE>Response = WC_OPEN HEAD_INFO WC_CLOSE\nWC_OPEN = &quot;&lt;WC version=&quot;&amp;lt;&amp;quot;&quot;&gt; 1.0 &lt;&quot;&gt; Type = &lt;&quot;&gt; &quot;(&quot;DAV/COPYHEAD&quot; | &quot;DAV/MOVEHEAD&quot;)&quot; &lt;&quot;&gt;&gt;&quot;\nHEAD_INFO = REQUEST RESPONSE_CODE LINK_RESPONSE TIME_STAMP\nWC_CLOSE = &quot;&lt;/WC&gt;&quot;\nREQUEST = &quot;&lt;WCDATA&gt;&quot; REQ_BODY &quot;&lt;/WCDATA&gt;&quot;\nREQ_BODY = actual request line and headers (without any message body) \n           of the COPY request for which the discovery is being made.\nRESPONSE_CODE = &quot;&lt;WCDATA&gt;&quot; CODE &quot;&lt;/WCDATA&gt;&quot;\nCODE = exact copy of HTTP status line.\nLINK_RESPONSE = Web Collection response format for each link (see section on LINK) \nTIME_STAMP = &quot;&lt;WCDATA&gt;&quot; TIME &quot;&lt;/WCDATA&gt;&quot;\nTIME = &quot;Time&quot; &quot;:&quot; RFC 1123 date [*digit]</PRE>\n\n<P>To copy a resource pointed to by http://foo.bar.com/foobar.html, with\na link of the type &quot;Author&quot; and destination URI http://foo.bar.com/junk,\nthe copyhead response will be as follows:</P>\n\n<PRE>&lt;WC version=&quot;1.0&quot; Type=&quot;DAV/COPYHEAD&quot;&gt; \n&lt;WCDATA&gt; \nCOPYHEAD http://foo.bar.com/foobar.html HTTP/1.1 \nContent-type : application/copyhead </PRE>\n\n<PRE>{instance of content type application/copy goes here}\n&lt;/WCDATA&gt; \n&lt;WCDATA&gt; Status : 200 OK &lt;/WCDATA&gt; \n&lt;WC version=&quot;1.0&quot; Type=&quot;DAV/LINK&quot;&gt; \n&lt;WCDATA&gt; \nON Source : http://foo.bar.com/foobar.html \nDest : http://foo.bar.com/junk \nType : Author \n&lt;/WCDATA&gt; \n&lt;/WC&gt; \n&lt;WCDATA&gt; Time : some time value &lt;/WCDATA&gt; \n&lt;/WC&gt;\n</PRE>\n\n<H3>7.3 MOVE</H3>\n\n<H3>7.3.1 Method Definition</H3>\n\n<P>This method requests the server to manipulate the resource/namespace\nmapping; a new location (mapping) is created for the Request-URI in the\nnamespace, and the existing location (mapping) in the namespace is removed.\nThe actual implementation is left to the discretion of the server.</P>\n\n<P>Move can be considered as an atomic, logical operation combining a COPY\nfollowed by a DELETE on the source URI. This means MOVE inherits all the\ncomplexities of COPY operation, and add a few more of its own due to the\nfact that it changes the resource location in the namespace.</P>\n\n<P>For instance: from the perspective of the client, a MOVE on a resource\nmay result in a REDIRECT to the new location namespace. WEBDAV does not\nrequire a server to issue a redirect on &quot;moved&quot; URIs in order\nto be compliant, but one might argue that some sort of discovery for &quot;server\ncapability&quot; be provided.</P>\n\n<P>Also there is an issue of &quot;level of intelligence&quot; of move.\nOne argument is that due to the special nature of HTML media types, move\nshould automatically perform some link management on links after a MOVE.\nWhile it is impossible to manage all links pointing to a resource due to\nlack of control over all of the links pointing to the resource, it is conceivable\nthat links from a resource, and links within a resource might be manageable.\nThe opposing argument to this is that allowing a move operation to have\nside-effects which could modify the resource being moved - or worse yet\nmodify resources which were not being moved - can have unexpected consequences.\nIt is important to know the consequences of an operation before executing\nthe operation.</P>\n\n<P>WEBDAV is silent on MOVE/link interaction issues, specifying a simple\nMOVE with a discoverable list of links to be moved with the resource. Beyond\nthat WEBDAV does not make any recommendation or suggestions about the actual\nimplementation of the MOVE operation.</P>\n\n<P>In case of non-versioned collections, move can be used as one of the\nways to add to the collection.</P>\n\n<H3>7.3.2 Request Body</H3>\n\n<P>This section defines the content type application/move.</P>\n\n<PRE>Move = Schema-Version CRLF destination CRLF movelink CRLF [request-versionCRLF]\nSchema-Version = 1*DIGIT &quot;.&quot; 1*DIGIT\ndestination = &quot;destination&quot; &quot;:&quot; URL\nmovelink = &quot;movelink&quot; &quot;:&quot; value\nvalue = &quot;true&quot; | &quot;false&quot;\nrequest-version = &quot;Request-Version&quot; &quot;:&quot; token\n</PRE>\n\n<H4>Note: COPY and Version Trees</H4>\n\n<BLOCKQUOTE>\n<P>The request-version token may be used to refer to a versioned resource\nby its version ID, in which case the Request-URI must point to the version\ntree handle. If the Request-URI points to the version tree handle and the\nrequest-version field is not provided, then the whole tree will be moved\nto the new location.</P>\n\n<P>The following are the rules that apply when a versioned resource is\ninvloved in a move operation:</P>\n\n<UL>\n<LI>A versioned resource can be moved into a non-versioned space.</LI>\n\n<LI>A versioned resource cannot be moved into another versioned resource.</LI>\n\n<LI>A non-versioned resource cannot be moved into a versioned resource.</LI>\n</UL>\n</BLOCKQUOTE>\n\n<H3>7.3.3 Response Body</H3>\n\n<P>The response body returns the status code.</P>\n\n<H3>7.3.4 Error Conditions</H3>\n\n<P>The following status codes may be returned:</P>\n\n<P>OK - The server has successfully moved the resource, and all the links,\nif applicable, to the new location in the namespace. </P>\n\n<P>Move failed due to some internal error:</P>\n\n<UL>\n<LI>The source is missing</LI>\n\n<LI>The desitination exists (in case overwrite switch is false)</LI>\n\n<LI>One or more links (in case movelink switch is true) failed to move\ndue to some internal error.</LI>\n</UL>\n\n<P>&nbsp;</P>\n\n<H3>7.4 MOVEHEAD</H3>\n\n<H3>7.4.1 Header Definition</H3>\n\n<P>This is a discovery method to be used with MOVE method. Since it is\nthe server's discretion to choose the links that it deems appropriate to\nmove with the new resource location, these links have to be discoverable.\nMOVEHEAD provides this discovery mechanism to the client. The Request-URI\nis the URI for the resource to be moved. In case of a versioned resource,\nit will be the version tree handle. In case of non-versioned resource,\nit will refer to the resourse itself. The information about the destination\n(and the switch to determine if the links need to moved as well) are passed\nin the message body (content type &quot;Application/Movehead&quot;).</P>\n\n<H3>7.4.2 Request Body</H3>\n\n<P>The definition of application/movehead is exactly the same as move</P>\n\n<H3>7.4.3 Response Body</H3>\n\n<P>The response is a Web Collection of type DAV/MOVEHEAD with BNF identical\nto that for DAV/COPYHEAD. It will contain a list of all the links that\nthe server deems appropriate to move with the destination URI.</P>\n\n<P>To move a resource pointed to by http://foo.bar.com/foobar.html, with\na link of the type &quot;Author&quot; and destination URI http://foo.bar.com/junk,\nthe movehead response will be as follows:</P>\n\n<PRE>&lt;WC version=&quot;1.0&quot; Type=&quot;DAV/MOVEHEAD&quot;&gt; \n&lt;WCDATA&gt; \nMOVEHEAD http://foo.bar.com/foobar.html HTTP/1.1 \nContent-type: application/movehead </PRE>\n\n<PRE>{instance of application/move goes here.}\n&lt;/WCDATA&gt; \n&lt;WCDATA&gt; Status : 200 OK &lt;/WCDATA&gt; \n&lt;WC version=&quot;1.0&quot; Type=&quot;DAV/LINK&quot;&gt; \n&lt;WCDATA&gt; \nON Source : http://foo.bar.com/foobar.html \nDest : http://foo.bar.com/junk \nType : Author &lt;/WCDATA&gt; \n&lt;/WC&gt; \n&lt;WCDATA&gt; Time : some time value &lt;/WCDATA&gt; \n&lt;/WC&gt;</PRE>\n\n<P>&nbsp;</P>\n\n<H3>7.5 DESTROY</H3>\n\n<P>To destroy a resource is permanently remove a resource from storage.\nTo delete a resource is to request that the resource no longer be made\navailable for editing. Destory differs from delete in that a versioning\nsystem may allow a deleted resource to be visible, but not&nbsp;editable,\nwhile a destroy causes the resource, and all knowledge about the resource\nto be removed from the server. &nbsp;A destroy is performed by the DESTROY\nmethod. The request-URI of the DESTROY method is the resource to be destroyed.</P>\n\n<P>&nbsp;</P>\n\n<H3>7.6 UNDELETE</H3>\n\n<P>An undelete undoes the action of a delete, making a deleted resource\navailable for editing. &nbsp;An undelete is performed by executing the\nUNDELETE method. The request-URI is the resource to be undeleted. </P>\n\n<P>&nbsp;</P>\n\n<H2>8. URI Collections</H2>\n\n<H3>8.1 URI Collection Behavior</H3>\n\n<P>According to The Random House College Dictionary - Revised Edition,\nCollection is defined as &quot;2. Something that is collected, as a group\nof objects...&quot; In the most generic sense a URI Collection brings together\na group of URIs and provides information about them. This specification\nwill not be defining such a collection, mostly because it is a pretty idea\nwith no where to go. At least for now. In the future systems will be available\nthat will be able to make profitable use of a generic collection. For now\nthis specification defines the Hierarchical Collection (HC). The HC is\nmeant to walk, talk, and look just like a directory in a file system. URIs\nare added to an HC as either relative or absolute. All relative URIs in\nan HC are relative to the Request-URI. This restriction is in place in\norder to replicate normal file system behavior. Thus if the collection\nis copy, moved, or otherwise manipulated within the name space it will\nbe possible to copy, move, etc. its component parts. This behavior is referred\nto as propagation. The idea is that a command executed on the collection\ncan be propagated to all the relative URIs. The PropagateLevel header controls\npropagation behavior. This header specifies the number of levels a command\nshould be propagated. Absolute URIs are added as links and thus commands\nare not propagated through them. Thus, if a collection is copied, the COPY\nmethod will be executed on all the relative URIs but not on the absolute\nURIs. Of course all the absolute URI entries will still be members of the\ncollection, they simply won't have the COPY method executed on them. </P>\n\n<P>Executing the MAKECOLLECTION method creates HCs. This is the same as\nexecuting a MKDIR on a file system. If a MAKECOLLECTION is executed on\na Request-URI which is not itself a member of a collection then either\nthe system will automatically create all the necessary collections or it\nwill reject the method. Once the collection is created any URI PUT under\nthe collection's namespace will &quot;magically&quot; appear inside the\ncollection. Again, this behavior mimics that of a normal file system. Adding\na relative URI directly to a collection will either be rejected or cause\na NULL file to appear. Removing a URI directly from a collection will cause\na link to disappear in the case of an absolute URI or will cause the file\nto be deleted in the case of a relative URI.</P>\n\n<H3>8.2 CREATECOLLECTION Method</H3>\n\n<H3>8.2.1 Method Definition</H3>\n\n<P>The CREATECOLLECTION method indicates to the server that the clients\nwishes a specified URI to act as a collection.</P>\n\n<H3>8.2.2 Request Body</H3>\n\n<P>The contents of message/collection identify what sort of collection\nis being created. This document defines the Hierarchical Collection (HC).\nA HC only supports a hierarchical name space and is meant to replicate\nthe behavior of a file system directory.</P>\n\n<P>A HC contains URIs. URIs may be entered as relative or absolute. Relative\nURIs must be relative to the request-URI. A relative URI is a propagate\nentry. If a PropagateLevel header is included with a method executed on\na HC then the method will be propagated through all relative URIs. Absolute\nURI entries do not propagate.</P>\n\n<P><TT>MessageCollection = Version CRLF CollectionType CRLF<BR>\nCollectionType = &quot;Collection Type&quot; &quot;:&quot; (&quot;HC&quot;\n| Text)</TT></P>\n\n<H3>8.2.3 Response Body</H3>\n\n<P><TT>CREATECOLLECTIONERROR = WC_OPEN Type WC_CLOSE<BR>\nContentError = &quot;DAV/Error/CreateCollection&quot;<BR>\nType = &quot;Do Not Support Type&quot; &quot;:&quot; (&quot;HC&quot; |\nText)</TT></P>\n\n<H3>8.2.4 Response Codes</H3>\n\n<P>&nbsp;</P>\n\n<H3>8.3 ADDRESOURCE</H3>\n\n<P><I>Editor: this section needs to incorporate the correct text from Yaron.</I></P>\n\n<H3>8.3.1 Content Type Definition</H3>\n\n<P>This content type is used to add a link to a collection. In the case\nof an HC most systems will not accept a relative URI. Rather, to add a\nnew entry to an HC, the resource should be created using a PUT or similar\nmethod. If the server does accept a relative URI for an HC then the result\nSHOULD be the creation of an empty resource.</P>\n\n<H3>8.3.2 Request Body</H3>\n\n<P><TT>AddResource = Version CRLF URIType CRLF URIEntry CRLF<BR>\nURIType = &quot;Type&quot; &quot;:&quot; (&quot;Relative&quot; | &quot;Absolute&quot;)<BR>\nURIEntry = &quot;URI&quot; &quot;:&quot; (relativeURI | absoluteURI)</TT></P>\n\n<P>URIType indicates the type of URI while URIEntry indicates the actual\nURI. URIType is included for negotiation purposes. If the URI is relative\nthen it is relative to the request-URI. The productions relativeURI and\nabsoluteURI are defined in section 3.2.1 of rfc2068.</P>\n\n<H3>8.3.3 Response Body</H3>\n\n<P>The content type of the response body is text/HTML and contains a Web\ncollection.</P>\n\n<P>&nbsp;</P>\n\n<H3>8.4 REMOVERESOURCE</H3>\n\n<H3>8.4 1 Method Definition</H3>\n\n<P>This content type is used to remove a URI from a collection. In the\ncase of an HC most systems will not accept a relative URI. Rather, to delete\nan HC entry, the resource should be DELETEd or DESTROYed. If the server\ndoes accept a relative URI for an HC then the result SHOULD be the deletion\nof the resource.</P>\n\n<H3>8.4.2 Request Body</H3>\n\n<P><TT>RemoveResource = AddResource</TT></P>\n\n<H3>8.4.3 Response Body</H3>\n\n<P>The content type of the response body is text/HTML and contains a Web\ncollection.</P>\n\n<P>&nbsp;</P>\n\n<H3>8.5 PropagateLevel Header</H3>\n\n<H3>8.5.1 Header Definition</H3>\n\n<P>The PropagateLevel header controls how many levels a method will be\npropagated down a collection. Zero means the method should only be executed\non the collection. Infinity means the method should be propagated as far\ndown as possible. A loop is impossible with HCs because its name space\nis a tree and absolute URIs do not propagate. Other collection types will\nhave to define their own mechanisms to detect and prevent loops.</P>\n\n<H3>8.5.2 Request Body</H3>\n\n<P><TT>PropagateLevel = &quot;PropagateLevel&quot; &quot;:&quot; (1*Digit\n| &quot;Infinity&quot;)</TT></P>\n\n<H3>8.5.3 Response Body</H3>\n\n<P>The following web collection can be included in any web collection based\nbody.</P>\n\n<P><B>WC Attributes</B></P>\n\n<P><TT>Type = &quot;DAV/Error/Prop/FailedAt&quot;</TT></P>\n\n<P><B>WCDATA Entry</B></P>\n\n<P><TT>Entry = &quot;Propagation Mechanism Failed at&quot; &quot;:&quot;\n*(Relative | Absolute_URI CRLF)<BR>\nRelative = &quot;Base&quot; &quot;:&quot; Absolute_URI &quot;Relative&quot;\n&quot;:&quot; *Relative_URI CRLF</TT></P>\n\n<P>&nbsp;</P>\n\n<H2>9. Version Control</H2>\n\n<H3>9.1 Introduction</H3>\n\n<P>This specification provides interface definitions which clients may\nuse to perform the common versioning operations check in, check out, version\nhistory retrieval, and merge. A fundamental assumption of this specification\nis that the semantics of versioning operations are defined by the server,\nand may vary from server to server, depending on the versioning engine\nemployed. As a consequence, this specification provides a common interface\nfor accessing the functionality of many different versioning engines. </P>\n\n<P>Since versioning functionality may vary from server to server, or even\nin different namespaces on the same server, a discovery mechanism is provided\nfor clients to determine precisely what effect a CHECKOUT or a CHECKIN\nmethod invocation will have on the state of the server. A client may query\nthe server for its CHECKIN and CHECKOUT semantics by retrieving the destination\nresource of the DAV.Discovery.CHECKOUT and DAV.Discovery.CHECKIN links.\nIt is expected that a client will query the value of the DAV.Discovery.CHECKOUT\nlink before performing a check out, and the DAV.Discovery.CHECKIN link\nbefore performing a check in, so it knows exactly what will occur when\nit issues the CHECKOUT or CHECKIN request. </P>\n\n<P>Similarly, the who and when of setting a version identifier varies significantly:\n</P>\n\n<OL>\n<LI>A version identifier MAY be specified by the client upon check out.\n</LI>\n\n<LI>Upon check out, the server MAY accept the client version identifier,\nor the server MAY assign a version identifier, or the server MAY not assign\nany version identifier. </LI>\n\n<LI>If the version identifier has not already been set, the client MAY\nspecify a version identifier upon check in. </LI>\n\n<LI>Upon check in, the server MAY accept the client version identifier,\notherwise the server MUST assign a version identifier unless one has already\nbeen assigned (e.g., during check out).</LI>\n</OL>\n\n<H3>9.2 Versioning Data Model</H3>\n\n<P>A version tree is a directed acyclic graph of versioned resources. Arcs\nin the version graph indicate &quot;is-version-of&quot; (or &quot;is-successor-of&quot;)\nrelationships. Each versioned resource is a first-class resource, addressable\nby a URI. A version tree MUST have a handle resource, known as the version\ntree handle, which is used to refer to the version tree as a whole. The\ncontents of the handle resource MUST be a single URI (a pointer), which\nis used by the versioning engine to identify the version tree as a whole.\nThe version handle resource MAY point to either the root object of the\nversion tree, or the history resource for the version tree. </P>\n\n<P>The version tree handle MUST have server generated links of type DAV.Versioning.DefaultPublished,\nDAV.Discovery.CHECKIN, and DAV.Discovery.CHECKOUT, and MAY have a server\ngenerated link of type History. Each versioned resource MAY have server\ngenerated links of the following types: DAV.Versioning.History, DAV.Versioning.DefaultPublished,\nDAV.Versioning.NextVersion, DAV.Discovery.CHECKOUT, DAV.Discovery.CHECKIN.\n</P>\n\n<UL>\n<LI>The destination resource of the DAV.Versioning.History link SHOULD\ndescribe the version tree, and contain comment information. </LI>\n\n<LI>The destination of the DAV.Versioning.DefaultPublished link, if this\nlink exists, points to the version which should be returned by default\nif a GET is performed on the version tree handle URI by a DAV unaware client.</LI>\n\n<LI>The destination URI of the each DAV.Versioning.NextVersion link, if\nany such links exist, MUST point to a successor resource in the version\ntree. </LI>\n\n<LI>The destination resource of the DAV.Discovery.CHECKOUT link, if this\nlink exists, must contain information describing the capabilities of the\nCHECKOUT method as implemented by the server on the source resource. </LI>\n\n<LI>The destination resource of the DAV.Discovery.CHECKIN link, if this\nlink exists, must contain information describing the capabilities of the\nCHECKIN mtethod as implemented by the server on the source resource. </LI>\n</UL>\n\n<P>Versioning is an orthogonal issue to content negotiation. Each particular\nvariant of a resource MAY be independently versioned, and MAY have its\nown version tree. </P>\n\n<P><B>TBD: A Figure showing a sample version tree (using text characters)</B></P>\n\n<P>&nbsp;</P>\n\n<H3>9.3 CHECKOUT</H3>\n\n<H3>9.3.1 Method Definition</H3>\n\n<P>A CHECKOUT is a declaration by a client that it might edit a versioned\nresource. The CHECKOUT method is intended to map to the notion of check\nout supported by the server's versioning engine. The Request-URI of the\ncheck out method is a version tree handle, which identifies the version\ntree on which the CHECKOUT will be performed. </P>\n\n<P>A server MAY create a working resource as the result of a check out.\nIf the server creates a working resource, it MUST return the URI of this\nresource in the response body. </P>\n\n<P>All of the activity which occurs during CHECKOUT method invocation MUST\nbe performed atomically. </P>\n\n<H3>9.3.2 Checkout Capability Discovery</H3>\n\n<P><I>Editor: this section will be subsumed by a more general method discovery\nmechanism.</I></P>\n\n<H3>9.3.3 Request Body</H3>\n\n<P>The request body of the CHECKOUT method is of content type application/checkout,\ndefined as: </P>\n\n<PRE>Checkout        = Schema-Version CRLF [Derived-From CRLF] [Request-Version CRLF]\n                  [Request-Lock CRLF] [Request-Intent CRLF] \n                  [Request-Working-Loc CRLF] [Request-Visibility CRLF]  </PRE>\n\n<PRE>Schema-Version  = &quot;Schema-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT\n\nDerived-From    = &quot;Derived-From&quot; &quot;:&quot; #token\n\nRequest-Version = &quot;Request-Version&quot; &quot;:&quot; token\n\nRequest-Lock    = &quot;Request-Lock&quot; &quot;:&quot; &quot;Exclusive&quot; &quot;Write&quot;\n\nRequest-Intent  = &quot;Request-Intent&quot; &quot;:&quot; (&quot;true&quot; | &quot;false&quot;)\n\n<TT>Request-Working-Loc = &quot;Request-Working-Loc&quot; &quot;:&quot; (&quot;Client&quot; | &quot;Server&quot;)\n\nRequest-Visibility = &quot;Request-Visibility&quot; &quot;:&quot; Visible-When [Visible-Where]\nVisible-When    = (&quot;Always&quot; | &quot;If_Locked&quot; | &quot;Never&quot;) \nVisible-Where   = (&quot;On_CheckOut_Root&quot; | &quot;On_Working&quot; | &quot;On_Both&quot;)</TT></PRE>\n\n<P>The Schema-Version is the version number of the syntax specification\nof the application/checkout content type. </P>\n\n<P>Derived-From specifies the version identifier of the check-out root(s)\nfrom which the working resource (if it exists) is derived. If more than\none version identifier is specified in the Derived-From value, the working\nresource MAY be the result of a merge of the specified versions, and the\nexact semantics of this merge operation will vary across versioning engines.\n</P>\n\n<P>Request-Version specifies a client's request to set the version identifier\nof the working resource. The server MAY set the version identifier of the\nworking resource to this value. If this field is omitted from the request\nmessage body, the server MAY perform a check out from a default check out\nroot (often the latest version). </P>\n\n<P>Request-Lock is used by the client to request a lock when a server supports\noptional locking on check out.</P>\n\n<P>Request-Intent is used by the client to request the server to establish\nan intent to edit on check out. An intent to edit MAY result in the association\nof authentication or user information with either the check out root, or\nthe working resource. </P>\n\n<P>Request-Working-Loc is used by the client to request where the working\nresource is located. If the client specifies &quot;Client,&quot; then the\nserver SHOULD not create a working resource on the server. If the server\ndoes not create a working resource on the server, the client SHOULD retrieve\nits working resource from the check out root after successful completion\nof the CHECKOUT. If the client specified &quot;Server,&quot; then the server\nSHOULD create a working resource on the server.</P>\n\n<P>Request-Visibility is used by the client to request whether to create\na DAV.Versioning.CheckedOut link, and the resource which will store the\nlink.&nbsp;Visible-When describes whether the DAV.Versioning.CheckedOut\nlink SHOULD always be created (&quot;Always&quot;), SHOULD only be created\nif the check out performs a lock (&quot;If_Locked&quot;), or SHOULD never\nbe created (&quot;Never&quot;). Visible-Where describes where the link\nSHOULD be stored: on the check out root (&quot;On_CheckOut_Root&quot;),\non the working resource (&quot;On_Working&quot;), or on both the check\nout root and the working resource.</P>\n\n<H3>9.3.4 Response Body</H3>\n\n<P>The response body of a CHECKOUT method invocation is of content type\napplication/checkoutresult, defined as: </P>\n\n<PRE>CheckoutResult     = WC-Open CheckoutResultData WC-Close\n\nWC-Open            = &quot;&lt;WC VERSION =&lt;&quot;&gt;1.0&lt;&quot;&gt; TYPE =&lt;&quot;&gt;DAV/CheckoutResult&lt;&quot;&gt;&gt;&quot;\n\nCheckoutResultData = *WCAT WCCheckoutData WCAT\n\nWCAT               = {arbitrary, server-defined Web Collection attributes}\n\nWCCheckoutData     = &quot;&lt;WCDATA&gt;&quot; DerivedTree DerivedRoot [WorkURI]\n\n                     [WorkVersion] [Visibility]<FONT COLOR=\"#0000FF\"> </FONT>&quot;&lt;/WCDATA&gt;&quot;\n\n\n\nDerivedTree        = &quot;Derived-Tree&quot; &quot;:&quot; URI CRLF\n\nDerivedRoot        = &quot;Derived-Root&quot; &quot;:&quot; #URI CRLF\n\nWorkURI            = &quot;Working-URI&quot;  &quot;:&quot; URI CRLF\n\nWorkVersion        = &quot;Working-Version&quot; &quot;:&quot; token CRLF\n\nVisibility         = &quot;Visibility&quot; &quot;:&quot; ( Visibility-Where | &quot;Never&quot; ) CRLF\n\nWC-Close           = &quot;&lt;/WC&gt;&quot;</PRE>\n\n<P>Derived-Tree is the location of the version tree handle on which the\ncheck out was performed. </P>\n\n<P>Derived-Root is the location of the (possibly many) versioned resources\non which the check out operation was performed. </P>\n\n<P>WorkURI is the location of the working resource generated by the server\non check out, if it exists. </P>\n\n<P>WorkVersion is the version identifier of the working resource, if it\nwas set on check out. </P>\n\n<P>Visibility is the location where the client can retrieve the DAV.Versioning.CheckedOut\nlink.</P>\n\n<H3>9.3.5 Error conditions</H3>\n\n<P>An error condition occurs if the following conditions hold: </P>\n\n<P>If a client requests a version identifier on check out, but the server:<BR>\na) cannot set a version identifier<BR>\nb) refuses to set a version identifier </P>\n\n<P>If a client requests a lock, but the server doesn't support locking.\n</P>\n\n<P>If the client requests an intent to edit, but the server doesn't support\nintent to edit. </P>\n\n<P>If the client doesn't specify a Derived-From version, and the server\nhas no default value. </P>\n\n<P>Syntax error in the request body. If a client requests a feature the\nserver doesn't support then it has committed a syntax error because the\ndiscovery told the client what the server supports.</P>\n\n<P>&nbsp;</P>\n\n<H3>9.4 CHECKIN</H3>\n\n<H3>9.4.1 Method Definition</H3>\n\n<P>A CHECKIN is a declaration by a client that it wishes to place a resource\nunder version control. The CHECKIN method is intended to map to the notion\nof check in supported by the versioning engine. The Request-URI for a CHECKIN\nmethod invocation is the version tree handle of the version tree which\nis being operated on. </P>\n\n<P>A check in SHOULD clear any server state which is set as a result of\na check out. For example, if a server locks a resource on check out, it\nshould remove the lock upon check in. </P>\n\n<P>To place a resource under version control for the first time, a check\nin is performed on the resource. In this case, the Request-URI is the desired\nlocation of the version tree handle, and the Working-URI or the check in\nbody gives the contents of the resource to be placed under version control.\n</P>\n\n<P>All of the activity which occurs during CHECKIN method invocation MUST\nbe performed atomically. </P>\n\n<H3>9.4.2 Checkin Capability Discovery</H3>\n\n<P><I>Editor: this section will be subsumed by a more general purpose discovery\nmechanism</I></P>\n\n<H3>9.4.3 Request-Body</H3>\n\n<P>The request body of a CHECKIN method invocation MUST be in one of two\nforms: </P>\n\n<OL>\n<LI>An entity of content type application/checkin </LI>\n\n<LI>An entity of content type multipart/related, with two parts, an entity\nof content type application/checkin, and a second entity, of any content\ntype, containing a check in body. </LI>\n</OL>\n\n<P>If the request-body is of content type multipart/related, the checkin\noperation is defined to be a PUT of the checkin entity body (into a server-dependent\ntemporary resource), followed by a CHECKIN. </P>\n\n<P>The definition of content type application/checkin is: </P>\n\n<PRE>CheckIn          = Schema-Version CRLF [Derived-From CRLF]\n\n                   [Working-Resource CRLF] [Request-Version CRLF] \n\n<FONT COLOR=\"#0000FF\">                   </FONT>[Check-In-Location CRLF]\n\n\n\nSchema-Version   = &quot;Schema-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT\n\nDerived-From     = &quot;Derived-From&quot; &quot;:&quot; #token\n\nRequest-Version  = &quot;Request-Version&quot; &quot;:&quot; token\n\nWorking-Resource = &quot;Working-Resource&quot; &quot;:&quot; ( &quot;[&quot; URI &quot;]&quot; ) | \n\n                   (&quot;VersionID&quot; &quot;:&quot; token) | &quot;BODY&quot;</PRE>\n\n<P>The Schema-Version is the version number of the syntax specification\nof the application/checkout content type. </P>\n\n<P>Derived-From specifies the version identifier of the check-out root(s)\nfrom which the working resource (if it exists) is derived. If more than\none version identifier is specified in the Derived-From value, the checked-in\nresource MAY be entered as the successor of the Derived-From resources.\n</P>\n\n<P>Request-Version specifies a client's request to set the version identifier\nof the check in resource. The server MAY set the version identifier of\nthe check in resource to this value. If this field is omitted from the\nrequest message body, the server MUST set the version identifier if it\nhas not previously been set. </P>\n\n<P>Working-Resource specifies a URI or a version identifier of the working\nresource which is to be checked-in. If the value is &quot;BODY,&quot; the\nworking resource is contained in the check in body.</P>\n\n<P><I>Open issues: 1 - If a version has multiple parents the client wants\nto know where the version links will go. If the system supports multiple\ninheritance then that needs to be stated. If the system only supports single\ninheritance then the client needs to know, before hand, which version the\nnew version will be linked to. 2 - The syntax allows a client to specify\ndifferent derived-from resources on Check In then were listed on Check\nOut. Somewhere there is a versioning system that doesn't allow this. The\nclient needs to know this fact before performing the check out.</I></P>\n\n<H3>9.4.4 Response Body</H3>\n\n<P>There is no response body defined for the CHECKIN method. </P>\n\n<H3>9.4.5 Error Conditions</H3>\n\n<P>If the Derived-From token(s) do not exist, </P>\n\n<P>If the working URI is not located on this server, or the server is not\nauthorized to retrieve the working URI. </P>\n\n<P>If the PUT of the checkin entity body fails. </P>\n\n<P>Syntax error in the request body. </P>\n\n<P>&nbsp;</P>\n\n<H3>9.5 DIFF/MERGE</H3>\n\n<H3>9.5.1 Introduction</H3>\n\n<P>The request-URI of the DIFF method is an arbiter. The arbiter will compare\nthe entries and return the differences between them.</P>\n\n<P>The request-URI of the MERGE method is also an arbiter. The arbiter\nwill combine the entries and return the result.</P>\n\n<P>The Application/Diff content-type works with the DIFF method. The Application/Merge\ncontent-type works with the Merge method.</P>\n\n<P><TT>Application/Diff = Body<BR>\nApplication/Merge = Body<BR>\nBody = 1#(&quot;URI&quot; &quot;:&quot; URI | &quot;Entity&quot; &quot;:&quot;\nentity-body)</TT> </P>\n\n<P>&nbsp;</P>\n\n<H3>9.5.2 SERVERMERGE</H3>\n\n<H3>9.5.2.1 Method Definition</H3>\n\n<P>The SERVERMERGE method requests that the server merge a number of entities\non behalf of the client. The request-URI is a server side arbiter who performs\nthe merge on behalf of the client.</P>\n\n<H3>9.5.2.2 Request Body</H3>\n\n<P>The request body may take on one of two possible formats. One format\nis application/servermerge, which is defined below. The second format is\nmessage/multipart related which will contain an entry of type application/servermerge\nas well as entities for the server to merge.</P>\n\n<P>Type = application/servermerge</P>\n\n<PRE><TT>Merge = Schema-Version CRLF MergeType CRLF [MergeEntities CRLF] \n        ReturnType CRLF [ReturnURI CRLF]\nMergeType = &quot;Merge Types&quot; &quot;:&quot; (&quot;URIs&quot; | &quot;Bodies&quot; | &quot;URIs&quot; &quot;Bodies&quot;)\nMergeEntities = &quot;Merge Entries&quot; &quot;:&quot; #URI\nReturnType = &quot;Return Result&quot; &quot;:&quot; (&quot;URI&quot; | &quot;Body&quot;)\nReturnURI = &quot;Return Location&quot; &quot;:&quot; URI</TT></PRE>\n\n<P>MergeType specifies what mechanisms are being used to refer to bodies\nto be merged. URIs means that a MergeEntities has been included while Bodies\nindicates that one or more message/multipart related have been included.\nReturnType specifies how the results are to be returned, either as part\nof the response or recorded in a URI. ReturnURI specifies the URI for the\nresult to be recorded in if the user selects that return mechanism. A server\nMAY support any combination of values for MergeType and ReturnType. It\nMUST provide for discovery of supported values.</P>\n\n<H3>9.5.2.3 Response Body</H3>\n\n<P>Only support # bodies to be merged</P>\n\n<P>Can not resolve URI </P>\n\n<P>Can not store in URI</P>\n\n<P>Can not merge included types</P>\n\n<P>Merge Failed</P>\n\n<P>Merge Succeeded</P>\n\n<H3>9.5.2.4 Response Codes</H3>\n\n<P>[Will fold in from above.]</P>\n\n<P>&nbsp;</P>\n\n<H3>9.6 Command Comments </H3>\n\n<P>Command comments are entity headers. </P>\n\n<P><TT>Command_Comment = &quot;Comment&quot; &quot;:&quot; CommentVal<BR>\nCommentVal = URI | comment</TT> </P>\n\n<P>This is the standard comment facility used by versioning systems. Servers\nthat do not understand the header or do not wish to make use of the information\nare free to ignore the information. No specification is made regarding\nhow this information is to be retrieved. It is likely, however, that most\nsystems will make the command comments available through their history\nattribute. </P>\n\n<H3>9.7&nbsp;FREEZE (a.k.a. UNVERSION) </H3>\n\n<P><I>Editor: this method should be viewed as proposed functionality.</I></P>\n\n<H3>9.7.1 Method Definition</H3>\n\n<P>This method request the server to freeze the version tree in the current\nstate, and copy the default published version outside of versioning space\nso that it is accessible as an unversioned resource to the client. After\nthe version tree is frozen, the clients will not be able to perform any\noperation except CHECKIN at which time the tree will be taken out of the\nfrozen state and put back into the version space. The Request-URI is the\nURI of the version tree handle.</P>\n\n<H3>9.7.2 Request Body </H3>\n\n<P>None.</P>\n\n<H3>9.7.3 Response</H3>\n\n<P>The response will only consist of the status code as returned by the\nserver.</P>\n\n<H3>9.7.4 Error Conditions</H3>\n\n<P>The error codes could any of the following: </P>\n\n<P>OK - the server successfully froze the version tree and copied the Default\nPublished Version into non-version space. <BR>\nFREEZE failed because the server could not freeze the tree. <BR>\nFREEZE failed because the server could not copy the default published version\nto unversioned space <BR>\nFREEZE failed because the server could not determine the Default Published\nVersion <BR>\nThe source (tree) is missing </P>\n\n<H2>10. Ancillary Methods and Headers</H2>\n\n<H3>10.1 MaxLength Header </H3>\n\n<H3>10.1.1 Header Definition </H3>\n\n<P>The max length header requests that the server not return any results\ngreater than specified in the header. The header also specifies if partial\nresults are preferred to no results in the case when the result entity\nis greater than allowed by the header. </P>\n\n<H3>10.1.2 Header Body </H3>\n\n<PRE>MaxLengthHeader = &quot;MaxLength&quot; &quot;:&quot; Size Partial CRLF\nSize = &quot;Size&quot; &quot;:&quot; Bytes-Unit 1*Digit\nPartial = &quot;Partial&quot; &quot;:&quot; (&quot;Acceptable&quot; | &quot;Not Acceptable&quot;) </PRE>\n\n<P>&nbsp;</P>\n\n<H3>10.2 If-Lock Header </H3>\n\n<H3>10.2.1 Header Definition </H3>\n\n<P>The If-Lock header makes any request to which it has been appended conditional\non the lock(s) referred to by the included token(s) still being active.\nThis header can not be dropped. </P>\n\n<H3>10.2.2 Header Body </H3>\n\n<PRE>IfLockHeader = &quot;If-Lock&quot; &quot;:&quot; #LockToken CRLF </PRE>\n\n<P>&nbsp;</P>\n\n<H3>10.3 Command-Comments Header (CCMD)</H3>\n\n<H3>10.3.1 Header Definition</H3>\n\n<P>Command-Comments (short form CCMD) is a request-header which is used\nto transmit comment information on any HTTP request method to the server.\nThe server MAY provide persistent storage for the comments. The server\nMAY log the comments. The server MAY ignore the comments. </P>\n\n<H3>10.3.2 Header Body</H3>\n\n<P>The definition of the syntax of the Command-Comments header is as follows:\n</P>\n\n<PRE>CommandComments  = (&quot;CCMD&quot; | &quot;Command-Comments&quot;) &quot;:&quot; LangTaggedString\n\nLangTaggedString = Lang UTF-8   ; See RFC 2044 for UTF-8 definition\nLang             = &quot;(&quot; LangTag &quot;)&quot;\nLangTag          = 1*8ALPHA *(&quot;-&quot;1*8ALPHA)</PRE>\n\n<P>&nbsp;</P>\n\n<H3>10.4 Overwrite Header</H3>\n\n<H3>10.4.1 Header Definition</H3>\n\n<P>Overwrite is a request-header which specifies whether the destination\nof the method should or should not be overwritten. </P>\n\n<H3>10.4.2 Header Body</H3>\n\n<PRE>Overwrite = &quot;Overwrite&quot; &quot;:&quot; (&quot;Yes&quot; | &quot;No&quot;)</PRE>\n\n<P>If the value of Overwrite is &quot;Yes,&quot; a destination resource\nwill be replaced if it exists. If the value of Overwrite is &quot;No,&quot;\nthe server will not replace the destination resource if it exists. </P>\n\n<P>This header may be applied to the PUT method, and thus modifies the\ndefinition of PUT given in Section 9.6 of [HTTP/1.1].</P>\n\n<H2>APPENDIX</H2>\n\n<H3>A. Definition of LinkSearch Header</H3>\n\n<P><I>Editor: This is a proposed feature.</I></P>\n\n<P>The LinkSearch method can be expensive, especially when a number of\nattributes must be retrieved over time.</P>\n\n<P>A more economical mechanism is to append a search string to URL using\n&quot;?&quot;. However, the URL could be confused with any of a number\nof search syntax's. The solution proposed by this document is to create\na new header called LinkSearch.</P>\n\n<P><TT>LinkSearch = &quot;LinkSearch&quot; &quot;:&quot; HTTP_url ; See\nsection 3.2.2 of [HTTP11]</TT></P>\n\n<P>If the HTTP URL does not end in a &quot;/&quot; then a &quot;?&quot;\nmay be appended to it and the attribute search syntax defined below may\nbe used to search for attributes on that particular resource. If the URL\ndoes end with a &quot;/&quot; then any resource whose name is a child of\nthe specified HTTP URL may be searched on directly.</P>\n\n<P>To perform a search a string matching the following syntax should be\nused.</P>\n\n<P><TT>LinkSearchSuffix = &quot;?&quot; Attribute<BR>\nAttribute = token</TT></P>\n\n<P>So, if the LinkSearch value is <A HREF=\"http://foo/bar\">http://foo/bar</A>\nthen a search on a link type of author would be performed using http://foo/bar?author.\nIf the returned value is <A HREF=\"http://foo/bar/\">http://foo/bar/</A>\nthen the author search may be performed on <A HREF=\"http://foo/bar/\">http://foo/bar/</A>?author\nand any of its children, such as http://foo/bar/doublebar?author.</P>\n\n<P>By returning the LinkSearch header the server is agreeing to manipulate\nthe search URL as it would the URL of the resource it resolves to. Thus\nit becomes the responsibility of the server to resolve the search URL whenever\nit is included in a command.</P>\n\n<P>If it is impossible to resolve the search request to a single result\nthen a 416 Not Unique error should be returned. This error specifies that\nthe URI was not resolvable to a unique resource.</P>\n\n<P>If the search URI does not resolve to any attribute then any request\ncontaining that URI should return a 404 Not Found error.</P>\n\n<H3>B. Definition of LinkPrefix Header</H3>\n\n<P><I>Editor: this is a proposed feature.</I></P>\n\n<P>In some cases a server may have an arbiter which handles all searches\non resources. To allow for the use of the arbiter but still gain the advantages\nof URL based searching the LinkPrefix is introduced.</P>\n\n<P><TT>LinkPrefix = &quot;LinkPrefix&quot; &quot;:&quot; HTTP_url</TT></P>\n\n<P>To retrieve a particular attribute the following syntax should be used:</P>\n\n<P><TT>LinkPrefixSuffix = &quot;?&quot; URL LinkSearchSuffix</TT></P>\n\n<P>Thus the returned URL has the URL to be searched on appended to it followed\nby the actual search syntax as previously specified. This allows for quick\nretrieval of attribute values but with the benefit of processing requests\nat a single resource.</P>\n\n<P>The URI returned by LinkPrefix has the same use semantics as the URI\nreturned by LinkSearch.</P>\n\n<P>&nbsp;</P>\n\n<H2>Required Features</H2>\n\n<P>[Ed. Note: preliminary and incomplete]</P>\n\n<P>Introduce the concept of Distributed Authoring compliance, Versioning\ncompliance, and totally optional features. Use the list from presentation.</P>\n\n<H2>Acknowledgements</H2>\n\n<P>[Ed. Note: preliminary and incomplete]</P>\n\n<P>Roy Fielding, Richard Taylor, Larry Masinter, Henry Sanders, Judith\nSlein, Dan Connolly, David Durand, Henrik Nielsen, Paul Leach. Kenji Ota,\nKenji Takahashi. Jim Cunningham. Others, TBD. </P>\n\n<H2>References</H2>\n\n<P>[Ed. Note: preliminary and incomplete]</P>\n\n<P>[HTTP11] R. T. Fielding, J. Gettys, J. C. Mogul, H. F. Nielsen, and\nT. Berners-Lee. &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot; Internet-Draft\ndraft-ietf-http-v11-spec-07.txt, expires February 12, 1997. </P>\n\n<P>[ORANGE] DoD 5200.28-STD, &quot;Department of Defense Trusted Computer\nSystem Evaluation Criteria&quot;, December, 1985. </P>\n\n<P>[RFC1521] N. Borenstein, N. Freed. &quot;MIME (Multipurpose Internet\nMail Extensions) Part One: Mechanisms for Specifying and Describing the\nFormat of Internet Message Bodies.&quot; RFC 1521, Bellcore, Innsoft, September,\n1993. </P>\n\n<P>[URL] T. Berners-Lee, L. Masinter, M. McCahill. &quot;Uniform Resource\nLocators (URL).&quot; RFC 1738, CERN, Xerox PARC, University of Minnesota,\nDecember, 1994. </P>\n\n<P>[RFC1959]</P>\n\n<P>[RFC1960]</P>\n\n<P>[WEBC] - References to web collections.</P>\n\n</BODY>\n</HTML>\n", "encoding": "ascii"}