{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/usingclasses/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n<title>Objects, Using Class Libraries/JavaDoc</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Objects, Using Class Libraries/Javadoc</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III\r\n<br>\r\nICS-21/-22/-23\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will begin our study of object-oriented programming (OOP).\r\n  We start by generalizing the concepts of variables and operators for\r\n      the <b>String</b> class, which is a special example of a reference type.\r\n  In doing so, we will examine four important technical terms (class, object,\r\n    variable, and reference) and highlight the relationships among them.\r\n  We also begin discussing the <b>new</b> operator, which returns a reference\r\n    to a new object constructed from any specified class.\r\n  <p>\r\n  Next we will learn how to recognize and use the three fundamental features\r\n    of classes (constructors, methods, and fields) to construct and\r\n    manipulate a wide variety of objects.\r\n  We will also learn how to read the Javadoc (documentation) for classes,\r\n    which includes detailed and cross-indexed information about the use and\r\n    meaning of each feature available in a class.\r\n  We will examine a sampling of classes from Sun's standard Java library and\r\n    from ICS-21/22/23's Java library, learning how to manipulate objects\r\n    constructed from these classes in interesting ways.\r\n  <p>\r\n  Finally, we will examine two more classes, which perform file input/output,\r\n     in detail: <b>TypedBufferReader</b> and <b>TypedBufferWriter</b>.\r\n  We will reinforce the material covered earlier and learn useful patterns for \r\n    file input and output using these classes, including more about exception\r\n    handling, which was briefly discussed in the previous lecture.\r\n  <p>\r\n  Each object is a small tool that we can use/manipulate to help us perform\r\n    some part of a programming task.\r\n  There are libraries of classes from which we can construct all the tools\r\n    that we need to make it easier for us to solve programming problems.\r\n   We will also learn how to build our own tools by learning how to write our\r\n     own classes.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Types -->\r\n\r\n<a name=\"Types\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Reference Types: Classes and Objects</b></td>\r\n<td width =\"80%\">\r\n  Every Java type is either a primitive type or a reference type.\r\n  We have already learned a lot about the primitive types (<b>int</b>,\r\n    <b>double</b>, <b>boolean</b>, and <b>char</b>) and about their literals,\r\n    operators, and methods (in the <b>Math</b> and <b>Prompt</b> classses).\r\n  Now we will begin learning about reference types, which are richer (there\r\n    are thousands in the standard Java library) and more powerful (but a bit\r\n    more complicated to use).\r\n  <p>\r\n  A reference type is most simply the name of a class; these names are just\r\n    Java identifiers, which by convention start with a capital letter.\r\n  In fact, we have already learned a bit about one reference type: the\r\n    <b>String</b> class.\r\n  Before exploring this class in more detail, let's discuss the fundamental\r\n    relationship between classes and objects.\r\n  Read and reread the following paragraphs until they make good sense; think\r\n    of other examples, discuss this material with friends, and talk to the\r\n    staff about it.\r\n  <p>\r\n  Generally, a class is like a blueprint.\r\n  We can construct new objects from a class by using Java's <b>new</b>\r\n    operator, which acts like a skilled worker who can read any blueprint\r\n    and construct objects from them.\r\n  Each object stores its own special state (information about that object),\r\n    which may be the same or different than other objects constructed from\r\n    the same class.\r\n  <p>\r\n  In Java, <b>new</b> is a unary prefix operator, which takes as an operand the\r\n    name of any class (following the class name, inside parentheses, is any\r\n    information that the class requires to specify the initial state of the\r\n    object being constructed).\r\n  We illustrate objects by ovals; each is labelled by its class name and each\r\n    encloses its current state.\r\n  Methods can examine and change the state of an object.\r\n  <p>\r\n  For example, we might have the blueprints (class) for constructing a certain\r\n    model of a Sony radio.\r\n  We can construct as many radios (objects) as we want from the same blueprint\r\n    (class).\r\n  The state of one radio (object) might be turned off; the state of two others\r\n    might be turned on, playing 89.5 FM at volume level 2; the state of yet\r\n    another  might be playing 503 AM at volume level 3.\r\n  The four objects just described might be pictured informally as follows.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/sony.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Now, let's return to the <b>String</b> class, which is part of the standard\r\n    Java library; the state of an object constructed from this class is just\r\n    a sequence of characters.\r\n  What makes this class unique is that it is the only one that has\r\n    literals: of course, all primitive types have literals, but no other\r\n    classes do.\r\n  When we write a <b>String</b> literal in our code, Java automatically\r\n    constructs a new object from the <b>String</b> class with the literal\r\n    as its contents.\r\n  But, to construct objects from ANY OTHER CLASS in Java, we need to use the\r\n    <b>new</b> operator.\r\n  To get into this habit, we will redundantly write <b>new String(\"...\")</b>\r\n    in this lecture whenever we want to construct a new object from the \r\n    <b>String</b> class (even though writing just <b>\"...\"</b> in our\r\n    code would accomplish almost exactly the same result -I say ALMOST because\r\n    there is still one missing detail that is too complicated to explain here).\r\n  <p>\r\n  Thus, <b>new String(\"...\")</b> is an expression that has a value: it tells\r\n    Java to apply the <b>new</b> operator to the <b>String</b> class.\r\n  The result returned (all operators return results) is a reference to a newly\r\n    constructed object from the <b>String</b> class.\r\n  The object itself, represented by a labelled oval) stores the sequence of\r\n    characters; we can then store the reference to that object inside a\r\n    variable that is declared to be of type <b>String</b>.\r\n  References always appear as ARROWS: their tail is INSIDE the variable's box\r\n    and their head POINTS TO an object (its arrow head touches the oval).\r\n  In summary the <b>new</b> operator has two aspects to its behavior.\r\n  <ul>\r\n    <li>It constructs an object from a class and initializes its state.\r\n    <li>It returns as a result a reference to the object that it constructs.\r\n  </ul>\r\n  <p>\r\n  Note: objects have classes but DO NOT have names.\r\n  Reference variables, which have names and types, store references that refer\r\n    to objects.\r\n  The type of a reference variable must always be compatible with the\r\n    class of the object to which it refers.\r\n  For simple object-oriented programming, the type will be the same as the \r\n   class.\r\n  But, once we begin examining interfaces and and class hierarchies, the\r\n    relationship between variable types and object classes will become \r\n    richer and more powerful, but more complicated too.\r\n  <p>\r\n  For now, we will keep things simple: the type of a variable will always be\r\n    the same as the class of the object that it refers to.\r\n  Putting all these ideas together, we can illustrate the declaration\r\n    <b>String s = new String(\"Java\");</b> by\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/stringref.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Here, we declare the variable <b>s</b> to be of type <b>String</b> (meaning\r\n    it can refer to <b>String</b> objects); in addition, we initialize this\r\n    variable to store the reference that <b>new</b> returns as a result of\r\n    constructing the <b>String</b> object whose state is initialized to\r\n    <b>\"Java\"</b>.\r\n  Thus, there are really two initializations: the state of the object is\r\n    initialized to <b>\"Java</b> and the state of the variable is initialized\r\n    to a reference that refers to this object.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Declaring Reference Variables -->\r\n\r\n<a name=\"ReferenceVariables\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Declaring Reference Variables</b></td>\r\n<td width =\"80%\">\r\n  Thus, we can use the standard Java syntax for declarations to declare (and\r\n     initialize) reference variables.\r\n  For refrence variables, we have three different choices: we can declare the\r\n    variable and\r\n  <ul>\r\n    <li> not initialize it\r\n    <li> initialize it to the value <b>null</b>\r\n         (a keyword, indicating that it refers to no object)\r\n    <li> initialize it to refer to some object\r\n         (either a <b>new</b>ly constructed object or an\r\n           object that has already been constructed\r\n  </ul>\r\n  We illustrate each of these three possibilites in the code and picture below.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/declarations.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  We say that a reference variable is uninitialized, stores <b>null</b>, or\r\n    stores a reference to an object.\r\n  We will rarely see <b>null</b> literals in the early part of ICS-21, but\r\n    we will see them at the end, when we start discussing arrays.\r\n  We we will use <b>null</b> frequently in ICS-22 and ICS-23, once we start\r\n    learning about using self-referential classes to construct linked lists.\r\n  <p>\r\n  We say that the <b>String</b> variable <b>s3</b> stores a reference to a\r\n    <b>String</b> object (the object is constructed by <b>new</b>, which\r\n    returns a reference to the object it constructed) whose state is\r\n    initialized to <b>\"abc\"</b>;\r\n  Say this sentence out loud a few times; get a feeling for these words,\r\n    which we will use over and over again, always in the  same technical sense.\r\n  Finally, we frequently talk about the state of an object (what information\r\n    it stores); we will soon learn about methods that can examine and change\r\n    the state of an object.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/nomenclature.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  All variables, primitive and reference, store state.\r\n  But with reference variables, we speak of two states: the standard state of\r\n    the variable (the one reference it stores) and in addition the state of the\r\n    object (all the information it stores).\r\n  <ol>\r\n    <li>A variable (box) stores its state (one value); if this value is a\r\n        non-<b>null</b> reference, it refers to an object\r\n    <li>That object (oval) stores its state (which can comprise many values\r\n          mixing together a variety of types).\r\n  </ol>\r\n  So, we must distinguish the state of the variable (a reference) from\r\n    the state of the object it refers to (in this case, a sequence of\r\n    characters).\r\n  We did not have this complexity with primitive variables: they stored\r\n     just their (single value) state directly.\r\n  We can use reference variables to do more interesting things; but there is\r\n    no free lunch: the penalty for usefulness is extra complexity.\r\n  <p>\r\n  Finally, we will also use the word <b>instance</b> as a synonym for object;\r\n    each  object is an instance of the class from which it was constructed.\r\n  Recall that we construct instances from a class by using the <b>new</b>\r\n     opererator, with the name of that class and the information specifying\r\n     the initial state of the newly constructed object.\r\n  So, in the picture above, we can also say that the variable <b>s3</b> refers\r\n    to an instance of the <b>String</b> class; one whose state is initialized\r\n    to <b>\"abc\"</b>.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Constructing and Sharing -->\r\n\r\n<a name=\"ConstructingSharing\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Constructing new objects; sharing old objects; the meaning of = for references</b></td>\r\n<td width =\"80%\">\r\n  We will now explore two different code fragments, and gain insight into\r\n    the semantics of the <b>=</b> operator when applied to variables that\r\n    store references.\r\n  First, examine the following two declarations.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/decl1.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Here we declare two variables.\r\n  Into each we place a reference to a <b>new</b> object: recall that the\r\n    expression <b>new String(\"...\")</b> ALWAYS constructs a new object (an\r\n    instance of the <b>String</b> class) and returns a result that is a\r\n    reference to that object.\r\n  The Java declarations specify to store the reference to each of these\r\n    objects into its associated variable.\r\n  Although each object stores the same state (the characters inside it), Java\r\n    constructs new, distinct objects in each declaration.\r\n  Ignore the red boxes for now.\r\n  <p>\r\n  Let's contrast this situation with the following two declarations\r\n   (followed by an expression statement: we could have combined the\r\n    second declaration and expression statement, and equivalently written\r\n    just the declaration <b>String s2 = s1;</b>).\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/decl2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n   Here, we also declare two variables; but we construct only one <b>new</b>\r\n     object.\r\n   The variable <b>s2</b> originally is uninitiallized (note the <b>?</b>).\r\n   Then <b>s1</b>'s reference (the value stored in that variable) is stored\r\n     into <b>s2</b> as well (in the statement <b>s1 = s2</b>;) we cross out\r\n     the <b>?</b> as well.\r\n   So in this case, <b>s1</b> and <b>s2</b> now both refer to the same object;\r\n     we also say that <b>s1</b> and <b>s2</b> <b>share</b> an object.\r\n  <p>\r\n  Note that a reference (arrow) always leads from a variable's box to an\r\n    object's oval; it never leads to a another variable's box!    \r\n  <p>\r\n  One of the most important things that you will learn this quarter is the\r\n    semantics of the <b>=</b> operator on references.\r\n  Its use will arise, over and over again, in more and more complex\r\n    circumstances.   \r\n  <p>\r\n  <b>We store/copy a reference into a variable by making that variable refer\r\n       to the same object that the reference refers to</b>.\r\n  <p>\r\n  Because <b>s1</b> stores a reference to the object shown, we store that\r\n    reference into <b>s2</b> by making <b>s2</b> refer to the same object.\r\n  I cannot overemphasize how important it is for budding object-oriented\r\n    programmers to memorize these semantics.\r\n  Repeat the boldfaced sentence aloud a few times; it must become part of you.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Operators and Methods -->\r\n\r\n<a name=\"Methods\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Operators and Methods on Objects</b></td>\r\n<td width =\"80%\">\r\n  We have already learned that one of the overloaded prototypes of the\r\n    <b>+</b> operator takes as operands two <b>String</b> operands.\r\n  Now we fill in some details: it takes two references to <b>String</b>\r\n    objects as operands and returns a result that is a reference to a new\r\n    <b>String</b> object whose state is the catenation of the state of its\r\n    two operands (without changing the state of either operand).\r\n  We can illustrate this behavior with the following code and picture.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/catenate.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Thus, operators can also construct new objects implicitly.\r\n  The <b>+</b> operator implicitly constructs a new object whose state is\r\n    determined by the states of its operand objects; it returns a reference to\r\n    this new object that it constructs.\r\n  In the code above, the reference to this object is stored into <b>s3</b> as\r\n     an initialization in its declaration.\r\n  <p>\r\n  Now lets discuss generalizing method calls for reference types.\r\n  The notation that we will discuss is the most important notational aspect of\r\n    Object-Oriented Programming.\r\n  We will use an analogy to discuss calling methods on the objects referred to\r\n     by variables.\r\n  We might say using English syntax, \"John, stand up\" to get the object\r\n    referred to by the name of \"John\" to change his state by standing up.\r\n  In Java syntax we would write this as the expression statement,\r\n     <b>john.standUp();</b>\r\n  <p>\r\n  Likewise, we might say, \"John, drink a glass of milk.\"\r\n  In Java syntax we would write this as the expression statement,\r\n    <b>john.drink(glassOfMilk);</b> where <b>glassOfMilk</b> refers to some\r\n    other object (the glass of milk that John is supposed to drink): by\r\n    performing this method, the state of the milk glass object becomes empty,\r\n    while John's state becomes full.\r\n  <p>\r\n  Generally, we use a variable name to specify which object to call a\r\n    method on (the object it refers to); the method is like a verb telling the\r\n    object what to do, and the information (if any) provided in the\r\n    parentheses corresponds to direct objects related to the verb (if it is\r\n    a transitive verb).\r\n  <p>\r\n  Syntactically we write the name of the variable, followed by a\r\n    period (a separator), followed by the name of \r\n    the method, all followed by a pair of open/close parentheses\r\n    (separators/delimiters).\r\n  If there are any operands to the method (like direct objects in English), we\r\n    list them inside the parentheses, separated by commas (separators).\r\n  If there are no operands, we still MUST include the open/close parentheses.\r\n  <p>\r\n  Let's take a look at the syntax and semantics of the <b>toUpperCase</b>\r\n     method: it is called in the form <br>\r\n&nbsp &nbsp <i>object-reference</i><b>.toUpperCase()</b><br>\r\n    and returns as a result a reference to a newly constructed\r\n    <b>String</b> object whose state is the upper-case version of the state of\r\n    the object to which  <i>object-reference</i> refers.\r\n  We can illustrate this behavior with the following code and picture.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/uppercase.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The <b>toUpperCase</b> method is called on the object referred to by the\r\n    variable <b>s1</b>; this method implicitly constructs a new object whose\r\n    state is determined solely by the state of its <i>object-reference</i>\r\n    (there are no other operands between the parentheses); it returns a\r\n    reference to this new object.\r\n  The reference to this object is stored into <b>s2</b> as an initialization\r\n    in its declaration.\r\n  <p>\r\n  Instead, we might have written the code shown below.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/uppercase2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  <p>\r\n  Here, when the <b>toUpperCase</b> method returns its result (a reference\r\n    to a new object), it is stored back into variable <b>s1</b>.\r\n  Because a variable may store <b>only one</b> reference at a time, we cross\r\n    out the other (previously stored) reference.\r\n  What happens to the original object when, as is the case here, there are no\r\n    references to it?\r\n  Java can reclaim it (the storage it occupies) for use later: when\r\n    <b>new</b> has to construct another object.\r\n  This concept is called <b>automatic garbage collection</b> and we \r\n    will continue to discuss it in increasing depth throughout the \r\n    ICS-21//22/23 sequence.\r\n  <p>\r\n  Conceptually, this declaration and assignment is similar to\r\n    <b>int i = 5; i = -i;</b>, because the variable first stores <b>5</b> and\r\n    then the value of the <b>int</b> variable is used to compute another value\r\n   (<b>-5</b>) which is stored back into the variable.\r\n  Whether a variable stores a primitive value or reference, it can store only\r\n    one values at a time; storing a new value in a variable means replacing \r\n    (and totally forgetting about) the  old value.\r\n  <p>\r\n  Let's take a look at the syntax and semantics of the <b>replace</b>\r\n     method: it is called in the form <br>\r\n&nbsp &nbsp <i>object-reference</i><b>.replace(</b><i>old character</i><b>,</b><i>new character</i><b>)</b><br>\r\n    and returns as a result a reference to a newly constructed <b>String</b>\r\n    object whose state is almost the same as the state of the\r\n    <i>object-reference</i>, but with each occurence of <i>old character</i>\r\n    replaced by <i>new character</i>.\r\n  We can illustrate this behavior with the following code and picture.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/replace.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The <b>replace</b> method is called on the object referred to by the\r\n    variable <b>s1</b>; this method implicitly constructs a new object whose\r\n    state is determined by the state of its <i>object-reference</i> and its\r\n    two operands (between the parentheses); it returns a reference to this new\r\n    object.\r\n  The reference to this object is stored into <b>s2</b> as an initialization in\r\n   its declaration.\r\n  <p>\r\n  The <b>String</b> class contains many many more methods for examining and\r\n    creating new objects.\r\n  For example, after the above declarations, writing <b>s2.length()</b>\r\n    returns as a result the <b>int</b> value <b>7</b>.\r\n  In fact, since the <b>replace</b> method itself returns a reference to a\r\n    <b>String</b>, we can write the more complicated expression\r\n<pre><b>  String s2 = s1.replace('d','p').toUpperCase();</b></pre>\r\n  This is known as a <b>cascaded method call</b> (they are left associative).\r\n  It is similar to the composition of functions in mathematics <b>g(f(x))</b>,\r\n    which is right associative.\r\n  When <b>replace</b> is called on the object <b>s1</b> refers to, it returns\r\n    a reference to its result (another <b>String</b> object); at that point,\r\n    the <b>toUpperCase</b> method is called on the reference to that object,\r\n    which returns a reference to its result: another <b>String</b> object whose\r\n    state is <b>\"CANPIPE\"</b>.\r\n  <p>\r\n  Note that the result here is the same as calling\r\n    <pre><b>  String s2 = s1.toUpperCase().replace('D','P');</b></pre>\r\n    which reverses the order of the method calls, and also changes the operands\r\n    of <b>replace</b> to appear in upper case.\r\n  We will discuss more <b>String</b> methods (and cascaded method calls)\r\n    later in this lecture.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- equality operators -->\r\n\r\n<a name=\"Equality\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The == and != Operators</b></td>\r\n<td width =\"80%\">\r\n  We have now seen how the <b>+</b> operator and <b>toUpperCase</b> and\r\n   <b>replace</b> methods work on references to <b>String</b> objects, and\r\n   how the <b>=</b> operator works on references in general.\r\n  <p>\r\n  Now we will discuss the semantics of the <b>==</b> and <b>!=</b> operators\r\n    when applied to any and all references.\r\n  If we compare two references (typically each is stored in a variable) with\r\n    <b>==</b>, the result is <b>true</b> when both refer to the same object\r\n    (both variables store the same reference).\r\n  We call <b>==</b> the \"object identity\" operator, because it determines\r\n    whether or not two references refer to the same object.\r\n  This comparision DOES NOT DEPEND ON THE STATE stored inside the objects; it\r\n    depends only on the identity of the objects.\r\n  <p>\r\n  Thus, in the red box in the first picture in the previous section,\r\n    <b>s1==s2</b> returns a result of <b>false</b>, because these variables\r\n    store different references; i.e., refer to different objects. \r\n  It make NO DIFFERENCE to <b>==</b> that the states of these two different\r\n    objects are the same.\r\n  Likewise, in the red box in the second picture, <b>s1==s2</b> returns a\r\n    result of <b>true</b>, because these variables do store the same reference;\r\n    i.e., they each refer to the same object.\r\n  <p>\r\n  As you would suspect, the <b>!=</b> operator performs the same kind of\r\n    comparison, but returns the opposite value: <b>true</b> if they are\r\n    different objects and <b>false</b> if they are the same object.\r\n  <p>\r\n  The next section discusses how we can test something different, whether the\r\n    STATES stored inside two objects are the same.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- equals method -->\r\n\r\n<a name=\"EqualsMethod\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The equals Method</b></td>\r\n<td width =\"80%\">\r\n  Finally, there is an alternative way to test whether two <b>String</b>\r\n    objects store the same STATE.\r\n  It uses the <b>equals</b> method.\r\n  As illustrated in the red boxes in the pictures above, both calls to this\r\n    method return <b>true</b>: the first asks the object referred to by\r\n    <b>s1</b> to check whether its STATE is the same as the state of the\r\n    object referred to by <b>s2</b>; although the two objects are different,\r\n    their STATES are the same.\r\n  The second call asks the object referred to by <b>s1</b> to check\r\n    whether its STATE is the same as the state of the object referred to by\r\n    <b>s2</b>; here, <b>s1</b> and <b>s2</b> refer to the same object, so\r\n    it is asking one object to see whetherh its STATE is the same as itself,\r\n    which is always <b>true</b>.\r\n  <p>\r\n In fact, here is a Java theorem: <b>s1 == s2</b> implies\r\n     <b>s1.equals(s2)</b>.\r\n  But, if  <b>s1.equals(s2)</b> evaluates to <b>true</b>, we cannot know\r\n    whether or not <b>s1 == s2</b> also evaluates to <b>true</b>.\r\n  Thus, the <b>==</b> operator is testing a stronger property than the \r\n    <b>equals</b> method.\r\n  <p>\r\n  In the examples above, we could also write either <b>s1.equals(s2)</b> or\r\n    <b>s2.equals(s1)</b> to test for identical states (the object doing the\r\n    testing and the object being tested are interchangable).\r\n  Both method calls always produce the same result.\r\n  <p>\r\n  Recall that with a reference variable and object, two things are stored: the\r\n    variable stores its state (a reference), and the reference refers to an\r\n    object that stores its state (some information).\r\n  It is logical that we need two different ways to compare these two different\r\n    states for equality.\r\n  Thus, <b>==</b> checks whether the variables store the same state;\r\n     <b>s1.equals(s2)</b> (and <b>s2.equals(s1)</b>) checks whether the objects\r\n     they refer to (they may or may not be the same) store the same state.\r\n  <p>\r\n   It is reasonable to require two different ways to check these two different\r\n    forms of equality, but it causes lots of confusion for students just\r\n    learning object-oriented programming.\r\n  Try to reread this material until it becomes intuitive; we will certainly\r\n    see many examples of their use.\r\n  Whenever you think about testing equality, a little light should go off in\r\n    your head that makes you pause and ask which of the two forms of equality\r\n    to check.\r\n  If <b>s1</b> and <b>s2</b> store references to <b>String</b> objects, you are\r\n    much more likely ask whether they are <b>equals</b> than whether they\r\n    are <b>==</b> (and the same is true for other classes).\r\n  <p>\r\n  <b>In ICS-21, you almost always want to use <b>.equals</b> to check\r\n       for <b>String</b> equality</b>.\r\n  Forgetting this fact will cause you to waste hours debugging your programs.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<a name=\"eqvseq\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>== vs equals<br>(one last time)</b></td>\r\n<td width =\"80%\">\r\nWhen comparing for equality, which must specify which equality: that of the\r\n   <b>==</b> operator or that of the <b>equals</b> method.\r\nWe can use a simple analogy to differentiate between these two possibilities.\r\n<p>\r\nImagine a house full of people and TVs.\r\nEach person represents a reference variable; each TV represents an object; the\r\n  channel to which the TV is tuned represents the state of the TV.\r\nJust as each reference variable refers to an object, each person is watching\r\n   a TV.\r\n<p>\r\nAssume we declare and intialize the variables <b>johnsTV</b> and <b>bobsTV</b>.\r\nWe might want to know whether John and Bob are watching the same TV: that is\r\n  analogous to evaluating <b>johnsTV == bobsTV</b>.\r\nWe might want to know whether John and Bob are watching the same channel: that\r\n   is analogous to evaluating <b>johnsTV.equals(bobsTV)</b> or\r\n   <b>bobsTV.equals(johnsTV)</b>, because we don't care which TV they are\r\n   watching (which object they are referring to), we care only whether their\r\n   TVs are on the same channel (their objects store the same state).\r\n<p>\r\nOf course, if John and Bob are watching the same TV (<b>johnsTV == bobsTV</b>)\r\n   then we know for sure that they must be watching the same channel\r\n   (<b>johnsTV.equals(bobsTV)</b> or <b>bobsTV.equals(johnsTV)</b>) too.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Class Terminology -->\r\n\r\n<a name=\"ClassTerminology\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Class Terminology</b></td>\r\n<td width =\"80%\">\r\n  We will now begin a more systematic examination of Java classes.\r\n  Our focus is still on learning about classes by reading them, and using\r\n    the knowledge that we gain to write programs that correctly construct\r\n    and manipulate objects from these classes.\r\n  We will identify and discus a large number of technical terms that help\r\n    us talk precisely about classes; we will use these terms repeatedly\r\n    during the quarter.\r\n  <p>\r\n  A class defines and documents three kinds of <b>members</b>.\r\n  <ul>\r\n    <li><b>Constructors</b>: used by <b>new</b> to create objects \r\n    <li><b>Methods</b>: operations we can apply to objects to examine/change\r\n            their state\r\n    <li><b>Fields</b>: variables inside objects that represent its state\r\n  </ul>\r\n  We will also further classify methods (which are by far the most interesting\r\n     members) as either\r\n  <ul>\r\n    <li><b>accessors/queries</b>: examine, but DO NOT change the state of\r\n             objects\r\n    <li><b>mutators/commands&nbsp</b>: change the state of objects\r\n  </ul> \r\n  Likewise, we will classify fields as either\r\n  <ul>\r\n    <li><b>instance variables</b>: each object -an instance of a class-\r\n             stores its own instance variables\r\n    <li><b>static fields</b>: all objects constructed from the same class\r\n             share the same common static fields\r\n  </ul>\r\n  <p>\r\n  Also of paramount importance when reading/using classes is the concept of\r\n    <b>access modifiers</b>.\r\n  Each member specifies its own access modifier(s), which control(s) how\r\n    programmers can access/use it.\r\n  In this lecture we will study the <b>public</b>, <b>private</b>,\r\n     <b>static</b>, and <b>final</b> access modifiers (which are all Java\r\n     keywords). \r\n  <ul>\r\n    <li>A member with a <b>public</b> access modifier can be used by any\r\n          programmer.\r\n        Typically, most constructors and methods use the <b>public</b> access\r\n           modifier.\r\n    <li>A member with a <b>private</b> access modifier can be used only by the\r\n          programmer writing the class (not by a programmer using the class).\r\n        Typically, most instance variables use the <b>private</b> access\r\n           modifier.\r\n    <li>A member with a <b>static</b> access modifier is shared by every object\r\n           in the class.\r\n    <li>A member with a <b>final</b> access modifier is in some sense\r\n           <i>unchangable</i>; for fields, this simply means that once the\r\n           they are initialized, they may not be stored into again (just like\r\n           the inclusion of <b>final</b> when declaring local variables).\r\n        So, the Java compiler will detect and report an error if we try to\r\n          use a state-change operator to store into a <b>final</b> field\r\n          that has already been initialized.\r\n </ul>\r\n  For programmers reading a class (to understand how to use it) only\r\n    <b>public</b> members are important (mostly constructors and methods).\r\n  A programmer implementing (or maintaining the implementation of) a class must\r\n    also understand its <b>private</b> members (mosty instance variables, \r\n    but sometimes constructors and methods too).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Member EBNF -->\r\n\r\n<a name=\"MemberEBNF\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>EBNF of Members</b></td>\r\n<td width =\"80%\">\r\n  We will now examine the EBNF rules governing how members are defined in\r\n    classes.\r\n  When we learn how to write our own classes, we will be guided by these same\r\n    rules.\r\n  Because there are so many, first we will look at rules describing the\r\n     big picture.\r\n  <p>\r\n&nbsp &nbsp <i>access-modifiers</i> &nbsp &nbsp &nbsp &nbsp &nbsp <= [<b>public</b>|<b>private</b>] [<b>static</b>] [<b>final</b>]<br>\r\n&nbsp &nbsp <i>member-definition</i> &nbsp &nbsp &nbsp &nbsp<= <i>constructor-definition</i> | <i>method-definition</i> | <i>field-definition</i><br>\r\n&nbsp &nbsp <i>full-member-definition</i> <= <i>access-modifiers</i> <i>member-definition</i><br>\r\n  <p>\r\n  Access modifiers can actually appear in any order; but for consistency,\r\n    we show the standard ordering here.\r\n  We will learn about more access modifiers later, and augument this EBNF rule.\r\n  <p>\r\n  Next we examine the details of the constructor and method definitions; they\r\n    are very similar and share many EBNF rules.\r\n  They also look a lot like the definitions of prototypes.\r\n  <p>\r\n&nbsp &nbsp <i>parameter</i> &nbsp<= <i>type</i> <i>identifier</i><br>\r\n\r\n&nbsp &nbsp <i>parameters</i> <= ([<i>parameter</i>{,<i>parameter</i>}])<br>\r\n\r\n&nbsp &nbsp <i>return-type</i> <= <i>type</i> | void<p>\r\n\r\n  <p>\r\n&nbsp &nbsp <i>constructor-definition</i> <= <i>identifier</i> <i>parameters</i><br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n  [<b>throws</b> <i>exception-types</i>] <br> \r\n\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n      <i>block-statement</i><p>\r\n\r\n&nbsp &nbsp <i>method-definition</i> &nbsp &nbsp &nbsp\r\n      <= <i>return-type</i> <i>identifier</i> <i>parameters</i><br>\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n [<b>throws</b> <i>exception-types</i>] <br>\r\n\r\n&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\r\n      <i>block-statement</i>\r\n  <p>\r\n  The only difference in last two EBNF rules is that a\r\n    <i>method-definition</i> must specify a <i>return-type</i> (which can be\r\n      <b>void</b>, meaning returns nothing),\r\n   while the <i>constructor-definition</i>  cannot specify a\r\n     <i>return-type</i>.\r\n  In addition, as a syntax constraint, the <i>identifier</i> naming the\r\n    constructor MUST have the SAME NAME as the class in which it is defined.\r\n  <p>\r\n  Notice that these definitions look a lot like prototypes\r\n    (especially in regards to the <i>parameters</i> rule; the only difference\r\n    is that the parameters here have names and types, not just types)\r\n    and each is ended by a <i>block-statement</i> indicating how to\r\n    execute its code (when we learn how to write classes, we will focus on\r\n    the statements inside these blocks).\r\n  <p>\r\n  Finally, the EBNF rules for the third member, a field definition, looks just\r\n    like a local variable definition.\r\n  <p>\r\n  &nbsp &nbsp <i>field-definition</i> <= <i>type</i> <i>identifier</i> [= <i>expression</i>];\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Static Members -->\r\n\r\n<a name=\"StaticMembers\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Static Classes: Methods and Fields</b></td>\r\n<td width =\"80%\">\r\n  Members declared with the <b>static</b> access modifier are very special.\r\n  Such members are common in very simple classes, such as <b>Math</b> and\r\n    <b>Prompt</b>, which define ALL their members to be <b>static</b>.\r\n  They are much rarer in the more interesting classes that we will spend most\r\n    of our time reading and writing this quarter.\r\n  But, classes with <b>static</b> members are very important for writing even\r\n    tiny programs, so we describe how to use <b>static</b> members first.\r\n  <p>\r\n  What is most special about <b>static</b> members is how we refer to them:\r\n    the standard way is by its class name, followed by a period, followed by \r\n    the member's name.\r\n  Thus, unlike all the <b>String</b> methods that we discussed, we do not\r\n    construct objects from these classes and call methods on the objects!\r\n  <p>\r\n  So, for example, the <b>Math</b> class defines the the following members\r\n    (among  many many others)\r\n<b><pre>  public static double sqrt    (double a)    {...}\r\n  public static int    max     (int a, int b){...}\r\n  public static double random  ()            {...}\r\n\r\n  public static final double PI = 3.14159265358979323846;</pre>\r\n</b>\r\n  Notice that all these members are <b>public</b>, so we can access/refer to\r\n    them.\r\n  They are also all <b>static</b>, so we will refer to these members as\r\n    <b>Math.sqrt</b>, <b>Math.max</b>, <b>Math.random</b>, and <b>Math.PI</b>.\r\n  (I have elided the blocks of the three methods: we are concerned here only\r\n     with how to call these methods, not what code is executed when we do.)\r\n  Furthermore, the <b>sqrt</b> method returns a <b>double</b>; it has one\r\n    <b>double</b> parameter named <b>a</b>;\r\n    the <b>max</b> method returns an <b>int</b>; it has two <b>int</b>\r\n     parameter named <b>a</b> and <b>b</b>.\r\n    the <b>random</b> method returns a <b>double</b>; it has no parameters.\r\n  <p>\r\n  From this point onward, we will use the term <b>parameter</b> to specify\r\n    the variable names appearing inside the parentheses defining methods\r\n    (sometimes we call them <b>parameter variables</b>).\r\n  When we call such a method, we will now use the term <b>arguments</b> to\r\n    describe the values that are transmitted to the method (we will still use\r\n    the term <b>operand</b> when discussing operators).\r\n  So, in the expression <b>Math.max(x,7)</b> we say that the arguments to\r\n    the <b>Math.max</b> method are <b>x</b> and <b>7</b>.\r\n  <p>  \r\n  Note that when we call a method, Java first evaluates its arguments; then\r\n    it transmits these values to the method by storing them into the method's\r\n    parameters; this is how parameters are initialized.\r\n  So, the number of arguments in a method call must match the number of\r\n    parameters in one of its definition (there may be many definitions,\r\n    because the method name may be overloaded).\r\n  Typically the statements in the elided block refers to the values stored in\r\n    the parameters, when performing its computation.\r\n  <p>\r\n  So, if we write the expression <b>Math.sqrt(25.)</b>, we are calling\r\n    the <b>static sqrt</b> method in the <b>Math</b> class and passing\r\n    it the argument <b>25.</b>; this value is stored in the parameter\r\n    <b>a</b>; the method then computes and returns a result of <b>5.</b>\r\n  <p>\r\n  Likewise, if we have declared <b>int x = 5;</b> and write the expression\r\n    <b>Math.max(x+4,7)</b> we are calling the <b>static max</b> method\r\n    in the <b>Math</b> class and passing it the arguments <b>9</b> (the\r\n    value of <b>x+4</b>) and <b>7</b>; these values are stored in the\r\n    parameters <b>a</b> and <b>b</b> respectively; then, the method computes\r\n    and returns a result of <b>9</b>.\r\n  <p>\r\n  Because the method <b>random</b> has no parameters, we must call it without\r\n    any arguments; but, we still must include the parentheses.\r\n  The code fragment below  prints 10 random numbers.\r\n<b><pre>  for (int i=1; i&lt;=10; i++)\r\n    System.out.println(Math.random());</pre></b>\r\n  <p>\r\n  Finally, we can use the field <b>Math.PI</b> in any statement, except one\r\n    that attempts to change its value (recall that it is declared with a\r\n    <b>final</b> access  modifier).\r\n  Thus, for example, we can write <b>area = Math.PI*r*r</b> but not\r\n    <b>Math.PI = 3.0;</b> (in the latter case, the Java compiler will detect\r\n    and report an error).\r\n  By convention, identifiers specifying <b>static</b> fields, like <b>PI</b>\r\n    are completely capitalized, with different words separated by the\r\n    underscore character; but this convention is not as widely followed as\r\n    the others we have seen (for variable/method names and class names).\r\n  <p>\r\n  Likewise, the <b>Prompt</b> class appears in the course library (not\r\n    standard Java library).\r\n  It also defines all its members to be <b>static</b>; some are\r\n<b><pre>\r\n  public static int forInt (String message)                   {...}\r\n  public static int forInt (String message, int low, int high){...}</pre>\r\n</b>\r\n  Notice that these definitions overload the method name <b>forInt</b>,\r\n    but as required the two signatures (parameter structures) are different.\r\n  We might use these methods as follows\r\n<b><pre>\r\n  int primeCheck = Prompt.forInt(\"Enter number to check for primality\");\r\n  int selection  = Prompt.forInt(\"Enter selection,1,10);</pre></b>\r\n  <p>\r\n  Java knows the first use of <b>forInt</b> refers to the first definiition,\r\n    the one with a single <b>String</b> parameter, to match the single\r\n    <b>String</b> argument in the parenthesis.\r\n Java knows the second use of <b>forInt</b> refers to the second definiition,\r\n    the one with one <b>String</b> parameter followed by two <b>int</b>\r\n    parameters, to match the one <b>String</b> argument followed by two\r\n    <b>int</b>arguments in the parenthesis.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- The DiceEnsemble Class -->\r\n\r\n<a name=\"DieClass\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Reading the DiceEnsemble Class</b></td>\r\n<td width =\"80%\">\r\n  We are now ready to switch our attention back to the more common and\r\n    interesting classes in Java: classes having constructors and whose\r\n    methods are not <b>static</b>.\r\n  When discussing these classes, we will carefully examine their <b>public</b>\r\n    constructors and methods; but because their fields are all <b>private</b>, \r\n    we will not discuss these members in detail here (but we will, when we\r\n    learn how to write our own classes and methods).\r\n  <p>\r\n  We will use the definition of members in the <b>DiceEnsemble</b> class as\r\n    our primary example in this section.\r\n  This class is a computer model of a collection of dice.\r\n  The objects constructed from this class perform intuitively, but the class\r\n    is complicated enough to illustrate most interesting aspects of classes.\r\n  <p>\r\n  There can be any number of dice in an ensemble, and the dice can have\r\n     any number of sides; but in this model, all the dice must have the same\r\n     number of sides.\r\n  The model focuses on the operations of rolling the dice and reading the \r\n     number of pips showing (the number of dots on the top face of a die).\r\n  These are the typical things we do with dice in the real world.\r\n  We cannot ask for the weight of the dice, nor their color, nor a variety\r\n    of other properties that physical dice exhibit.\r\n  On the other hand, we can ask any dice ensemble object how often it has\r\n    been thrown; that part of the model exceeds what we can do with physical\r\n    dice.\r\n  <p>\r\n  First, let's overview the definitions of all thirteen members in this class.\r\n  There are (in order) two constructors, eight methods (one mutator/command and\r\n    seven accessors/queries), and three instance variables.\r\n  Verify that each definition matches one of the EBNF rules presented above.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n<b><pre>\r\n  public DiceEnsemble () \r\n  {...}\r\n\r\n  public DiceEnsemble (int numberOfDice, int sidesPerDie)\r\n    throws IllegalArgumentException\r\n  {...}\r\n\r\n  public DiceEnsemble roll ()\r\n  {...}\r\n\r\n  public int getNumberOfDice ()\r\n  {...}\r\n\r\n  public int getSidesPerDie ()\r\n  {...}\r\n\r\n  public int getPips (int dieIndex)\r\n    throws IllegalArgumentException,IllegalStateException\r\n  {...}\r\n\r\n  public int getPipSum ()\r\n    throws IllegalStateException\r\n  {...}\r\n\r\n  public int getRollCount ()\r\n  {...}\r\n\r\n  public boolean allSame ()\r\n   throws IllegalStateException\r\n  {...}\r\n\r\n  public String toString ()\r\n  {...}\r\n    \r\n  private int   sidesPerDie;\r\n  private int   rollCount;\r\n  private int[] pips;</pre></b> \r\n  \r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Recall that the two constructors (the first two members) specify no\r\n    <i>return-type</i> and are named by the class name, <b>DiceEnsemble</b>;\r\n    because there are two definitions, the constructor for this class is\r\n    overloaded.\r\n  <p>\r\n  The seven methods are named <b>roll</b>, <b>getNumberOfDice</b>,\r\n    <b>getSidesPerDie</b>, <b>getPips</b>, <b>getPipSum</b>,\r\n    <b>getRollCount</b>, and <b>toString</b> - a very specially named method.\r\n  Accessor/query methods are often called \"getters\" and their names often start\r\n    with <b>get</b>, as most of these do; they get information about the\r\n    state of the object that is otherwise inaccessible (see the <b>private</b>\r\n    fields below).\r\n  <p>\r\n  The three fields (<b>sidesPerDie</b>, <b>rollCount</b>, and <b>pips</b>) are\r\n    all <b>private</b> instance variables; this means that each object stores\r\n    its own state in these variables, but users of objects constructed from\r\n    this class cannot access the values of these variables directly by their\r\n    names.\r\n  <p>\r\n  Now, let's individually explore the constructors and methods in more detail.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Constructors -->\r\n\r\n<a name=\"Constructors\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Using Constructors</b></td>\r\n<td width =\"80%\">\r\n  Recall from our discussion of <b>String</b> that we use the <b>new</b> \r\n   operator to construct new objects from a class.\r\n  We can now say more precisely that what actually follows the <b>new</b>\r\n    operator is a constructor for the class (which, as you recall, must have\r\n    the same name as the class).\r\n  The information inside its parentheses are the arguments that the constructor\r\n    needs to initialize the state of the object.\r\n  The number, order, and types of the argument(s) must match the number, order,\r\n    and types of the parameter(s) of a constructor; each argument is evaluated\r\n    and transmitted to its matching parameter in the constructor, where its\r\n    value is used to initialize the state of the object.\r\n  <p>\r\n  The <b>DiceEnsemble</b> class has two constructors (so construction is\r\n    overloaded).\r\n  As required, they have different signatures: no parameters or two <b>int</b>\r\n    parameters.  \r\n  They appear as\r\n<b><pre>\r\n  public DiceEnsemble () \r\n  {...}\r\n\r\n  public DiceEnsemble (int numberOfDice, int sidesPerDie)\r\n    throws IllegalArgumentException\r\n  {...}</pre></b>\r\n  Generally, constructors are easy to locate when scanning the members of a\r\n     class, because they have the same name as the class and have no return\r\n     types.\r\n  Pragmatically, constructor definitions typically appear first in a class\r\n    (although in another popular style, fields appear first and constructors\r\n    appear second).\r\n  The first constructor, which has no parameters, is designed always to\r\n    return a reference to an object representing an ensemble of two,\r\n    six-sided dice.\r\n  <p>\r\n  The second constructor allows the programmer to specify the number and\r\n    sides of the dice.\r\n  It will fail to construct an object (and instead throw\r\n    <b>IllegalArgumentException</b>), if it is given bad arguments for either\r\n    its <b>numberOfDice</b> or <b>sidesPerDie</b> parameter.\r\n  (We discuss the details later, but it certainly wouldn't make sense to have\r\n    <b>-2</b> dice in an ensemble).\r\n  <p>\r\n  The following examples illustrate a few different ways to construct\r\n    <b>DiceEnsemble</b> objects.\r\n  In each case, the signature of one of the constructors is followed: no\r\n    parameters or two <b>int</b> parameters.  \r\n<b><pre>  DiceEnsemble d1 = new DiceEnsemble(2,6);    //2 dice, each 6-sided\r\n  DiceEnsemble d2 = new DiceEnsemble();       //Same as above; see Javadoc\r\n  DiceEnsemble d3 = new DiceEnsemble(1,4096); //1 die with 4096 sides!\r\n  DiceEnsemble d4 = new DiceEnsemble(10,2);   //10 dice, each 2-sided</pre></b>\r\n  After construction, each <b>DiceEnsemble</b> variable stores a reference\r\n    to a different object whose state has been initialized by the constructor.\r\n  For example, here is a picture for variable <b>d1</b> and the object that it\r\n    refers to.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/diceobject.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  In this picture we show the <b>private</b> instance variables for an object\r\n    constructed from <b>DiceEnsemble</b>: <b>sidesPerDie</b>, <b>rollCount</b>,\r\n    and <b>pips</b>.\r\n  It is the purpose of the constructor to initialize these variables.\r\n  We show such instance variables just like other variables: as a labelled\r\n     box; so here there are three of them comprising the state of the object.\r\n  <p>\r\n  You can see that one constructor argument, the one stored in the parameter\r\n    <b>sidesPerDie</b>, is stored directly in an instance variable with the\r\n    same name.\r\n  Another instance variable, <b>rollCount</b>, is always initialized to\r\n    <b>0</b>.\r\n  Finally, the last instance variable, <b>pips</b>, refers to an array of\r\n    length two: it stores the number of pips on each die (shown as <b>0</b>\r\n    here, because the dice have not been rolled yet).\r\n  What determines the size of that array? The argument transmitted to the\r\n    <b>numberOfDice</b> parameter.\r\n  We will cover the details of arrays soon, learning that they are just a\r\n    special kind of object, with their own instance variables pictured above.\r\n  <p>\r\n  So, instance variables are just that: variables stored locally in each \r\n    instance of a class (i.e., in each object).\r\n  While every object has the same instance variables, their values depend\r\n    on which constructor was called and which arguments it was sent.\r\n  To further illustrate this point, here is a picture for variable <b>d4</b>\r\n    and the object it refers to.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/diceobject2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Notice that this object has exactly the same instance variables, but their\r\n    values are different because the constructor was passed different\r\n    arguments.\r\n  This object represents a dice ensemble with ten, two-sided dice.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Methods -->\r\n\r\n<a name=\"UsingMethods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Using Methods</b></td>\r\n<td width =\"80%\">\r\n  Recall from our discussion of <b>String</b> that once we have constructed\r\n    an object, and stored a reference to it in a variable, we can use the\r\n    variable's name to make the object do some useful work for us by calling\r\n    one or more of its methods.\r\n  Let's examine what some individual methods do and finally put a bunch of\r\n    method calls together, with some control structures, to perform some\r\n    interesting task.\r\n  It might seem surprising, but most of the methods that we discuss are\r\n    parameterless; actually, this happens more often than not in\r\n    object-oriented programming.\r\n  <p>\r\n  First, the following methods are simple accessors/queries.\r\n<b><pre>\r\n  public int getNumberOfDice ()\r\n  {...}\r\n\r\n  public int getSidesPerDie ()\r\n  {...}</pre></b>\r\n  Each returns some never-changing part of the state of the object: the number\r\n    of dice in the ensemble and the number of sides on each die in the\r\n    ensemble.\r\n  Calling <b>d4.getNumberOfDice()</b> returns a result of <b>10</b>;\r\n    calling <b>d4.getSidesPerDie()</b> returns a result of <b>2</b>.\r\n  Thus, we can always query a <b>DiceEnsemble</b> object for this information.\r\n  <p>\r\n  For any of the other methods to make sense, we must first examine the\r\n    <b>roll</b> method.\r\n  I could have made the return type of this method <b>void</b> (and sometimes\r\n    I wish I had).\r\n  In the discussion below, I will assume that <b>void</b> is in fact its return\r\n    type, but I will tell to the truth about this method at the end of this\r\n    section (when we use the return type for casecaded method calls).\r\n  <p>\r\n  The <b>roll</b> method has the following definition (pretend).\r\n<b><pre>\r\n  public void roll ()\r\n  {...}</pre></b>\r\n  Because its return type is <b>void</b> (keep pretending), we can guess that\r\n    this method is a mutator/command: it returns no result, but instead changes\r\n    the state of an object.\r\n  So how does this class model rolling a dice ensemble: first it increments\r\n    <b>rollCount</b> and then it generates random numbers and uses them to\r\n    change the values in the <b>pips</b> array to correspond to the number of\r\n    pips showing on each die.\r\n  For example, if we called <b>d1.roll();</b> the state of the object might\r\n    be changed (refer to the picture above for the \"before\" picture) to one\r\n    where the dice show <b>5</b> and <b>3</b> as pips.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/diceobjectrolled.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  The following methods are also accessors/queries.\r\n  But they return information based on the state of\r\n    a <b>DiceEnsemble</b> object that <b>roll</b> can change:\r\n    the <b>rollCount</b> and <b>pips</b> instance variables.\r\n<b><pre>  public int getRollCount ()\r\n  {...}\r\n\r\n  public int getPipSum ()\r\n    throws IllegalStateException\r\n  {...}\r\n\r\n  public boolean allSame ()\r\n   throws IllegalStateException\r\n  {...}\r\n\r\n  public int getPips (int dieIndex)\r\n    throws IllegalArgumentException,IllegalStateException\r\n  {...}</pre></b>\r\n  The first method just returns the current value stored in the\r\n    <b>rollCount</b> instance variable.\r\n  Recall that this instance variable is declared <b>private</b>.\r\n  Thus, a programmer cannot access this variable directly; but, the\r\n    <b>getRollCount</b> method, which a programmer can access because it\r\n    is <b>public</b>, returns whatever value is stored there.\r\n  So, the constructor initializes this instance variable to <b>0</b>;\r\n    the <b>roll</b> method increments it; and the <b>getRollCount</b>\r\n    method returns its current value.\r\n  If we call <b>getRollCount</b> before calling <b>roll</b>, it would return\r\n    <b>0</b>.\r\n  <p>\r\n  The next method is the accessor/query <b>getPipSum</b>.\r\n  Generally, it returns the sum of the pips on all the dice.\r\n  But, if we have not yet rolled the dice, this method cannot return\r\n    a reasonable result, so it throws the <b>IllegalStateException</b>,\r\n    indicating that the object is in a bad state for calling\r\n    <b>getPipSum</b>.\r\n  <p>\r\n  The <b>allSame</b> method works similarly.\r\n  Generally, it returns whether or not (a <b>boolean</b>) all the pips show\r\n    the same value (for two dice, this means we rolled a double).\r\n  But, if we have not yet rolled the dice, this method cannot return\r\n    a reasonable result either, so it also throws the same\r\n    <b>IllegalStateException</b>, indicating that the object is in a bad state\r\n    for calling <b>allSame</b>\r\n  <p>\r\n  The <b>getPips</b> accessor/query method is a bit more interesting, because\r\n    it defines a parameter.\r\n  This class numbers the dice from one up to the number of dice in the\r\n     ensemble; this method allows a programmer to specify the index of the\r\n     die he/she is interested in, and it returns the number of pips on that\r\n     die.\r\n  Once again, if we have not yet rolled the dice, this method cannot return\r\n    a reasonable result either, so it also throws the same\r\n    <b>IllegalStateException</b>.\r\n  <p>\r\n  But, we might also specify a bad <b>dieIndex</b>: a number smaller than one\r\n    or greater than the number of dice in the ensemble; in either case,\r\n    this method cannot return a reasonable result; in this case it is not\r\n    the state of the object that is bad, but the value of the argument, so\r\n    this method instead throws the <b>IllegalArgumentException</b>.\r\n  Note that if we were using a <b>try-catch</b> statement, we might be able\r\n    to recover from this exception by calling <b>getPips</b> again, but with\r\n    a different argument for <b>dieIndex</b>.\r\n  But, we cannot recover from the <b>IllegalStateException</b> by doing so:\r\n    in this case we would have to call <b>roll</b> before doing anything else.\r\n  Thus, having different exceptions for different problems seems reasonable.\r\n  <p> \r\n  Finally, every class should have a parameterless <b>toString</b> method that\r\n    returns a <b>String</b> representing the state of an object.\r\n  We use this method  mostly for debugging purposes: for printing the state\r\n    of objects while our program executes.\r\n  If, after rolling the <b>d1</b>, we called\r\n    <b><pre>  System.out.println(\"d1 = \" + d1.toString());</pre></b>\r\n   Java would print (based on the state shown in the picture above)\r\n    <b><pre>  d1 = DiceEnsemble[sidesPerDie=6,rollCount=1,pips=[5,3]]</pre></b>\r\n   Many <b>toString</b> methods return their result in a standard form, as\r\n    this one does:  the class name of the object, followed by a backeted list\r\n    of all its instance variables and their values, separated by commas.\r\n  What is truly special about this method is that Java calls it, implicitly,\r\n    if it ever needs to convert an object into a <b>String</b>.\r\n  So, we can instead write just\r\n    <b><pre>  System.out.println(\"d1  \" + d1);</pre></b>\r\n    and Java would still print the same thing: it will implicitly call\r\n    <b>toString</b> on <b>d1</b> to convert it into its <b>String</b>\r\n    representation, so that it can apply the catenate operator.\r\n  <p>\r\n  Now let's write some more complicated and interesting code using combinations\r\n    of these methods.\r\n  First, <b>getPipSum</b> is a very useful method, but we can compute its\r\n    value with our own code, using other available methods\r\n   (here, we do so for the object that <b>d1</b> refers to):\r\n<b><pre>  int pipSum = 0;\r\n  for (int i=1; i&lt;=d1.getNumberOfDice(); i++)\r\n    pipSum += d1.getPips(i);</pre></b>\r\n  For a final example, we can use the following code fragment to roll and\r\n    print a sequence of dice rolls; the code prompts the user to enter the\r\n      number of rolls to perform.\r\n<b><pre>  DiceEnsemble dice        = new DiceEnsemble(2,6);\r\n  int          timesToRoll = Prompt.forInt(\"Enter # of times to roll dice\");\r\n  for (;;) {\r\n    dice.roll();\r\n    if (dice.getRollCount() > timesToRoll)\r\n      break;\r\n    System.out.print(dice.getPipSum() + \" \");  //put in a space separator\r\n  }</pre></b>\r\n  <p>\r\n  If we wanted to, we could have prompted the user for the number of dice and\r\n    and the number of sides per die too, and used these values when\r\n    constructing the dice ensemble.\r\n  OK, time to tell the truth abot <b>roll</b>.\r\n  The <b>roll</b> method actually does not return <b>void</b>, but instead\r\n    returns a reference to a <b>DiceEnsemble</b> object; in fact, it return\r\n    a reference to the exact same <b>DiceEnsemble</b> object that it is called\r\n    on (although the state of that object has been changed by <b>roll</b>\r\n    before it returns its reference).\r\n  This method now is a bit of a hybrid: it is a mutator/command, but it also\r\n    returns a result just like an accessor/query.\r\n  <p>\r\n  How does this change affect what we have said?\r\n  First, all the above code is perfectly legal.\r\n  We can still write a <b>d1.roll()</b> as a legal expression statement; we\r\n    just elect not to do anything with the reference tht this method returns.\r\n  It still satisfies all the syntax constraints of an expression statement.\r\n  <p>\r\n  But, now we can do something that we couldn't do with a <b>void</b> method:\r\n    we can cascade method calls.\r\n  For example, we can replace the last two statements in the loop above with\r\n    the single statement <b>System.out.print(dice.roll().getPipSum());</b>\r\n  Here we call the <b>roll</b> method on the object to which <b>dice</b>\r\n    refers; this method changes the state of that object and then returns as a\r\n    result a reference to THE SAME OBJECT; this reference is immediately used \r\n    to call the <b>getPipSum</b> method on the new state of that object.\r\n  <p>\r\n  Generally, we can always take a <b>void</b> method and make it return a\r\n    reference to the object that it was called on.\r\n  Doing so will allow cascaded method calls, which might make our code easier\r\n    to write.\r\n  In fact, now we can rewrite this code fragment equivalently as:\r\n<b><pre>  DiceEnsemble dice        = new DiceEnsemble(2,6);\r\n  int          timesToRoll = Prompt.forInt(\"Enter # of times to roll dice\");\r\n  for (;;) {\r\n    if (dice.roll().getRollCount() > timesToRoll)\r\n      break;\r\n    System.out.print(dice..getPipSum() + \" \");  //put in a space separator\r\n  }</pre></b>\r\nor even using a <b>for</b> loop.\r\n<b><pre>  DiceEnsemble dice = new DiceEnsemble(2,6);\r\n  for (int timesToRoll = Prompt.forInt(\"Enter # of times to roll dice\");\r\n       dice.roll().getRollCount() <= timesToRoll;\r\n       /*see continuation test for state change*/)\r\n    System.out.print(dice.getPipSum());</pre></b>\r\n  Is this a good or bad thing?\r\n  <p>\r\n  Let's examine the semantics of a local reference variable declared\r\n    <b>final</b>.\r\n  Recall that a local primitive variable decalared <b>final</b> must be\r\n    initialized and cannot have its value changed.\r\n  This rule is exactly the same one for reference variables, but because they\r\n    store state (references that refers to objects that have state), we must\r\n    look at it a bit more closely.\r\n  <p>\r\n  Using <b>final</b> with a reference type variable DOES mean that once we\r\n    initialize it, it always refers to the same object\r\n  It DOES NOT mean that the state of the object remains unchanged: we can still\r\n     call mutator/command methods on a <b>final</b> variable, changing not its\r\n     state but the the state of the object it refers to. \r\n  So, if we declare <b>final DiceEnsemble d = new DiceEnsemble(2,6);</b> we\r\n     CAN write <b>d.roll();</b>, but we CANNOT write\r\n     <b>d = new DiceEnsemble(1,6);</b> which attempts to change the reference\r\n     stored in the <b>final</b> variabls <b>d</b>).\r\n   Again, the difference between what is stored in a variable (a reference)\r\n     and what is stored in the object it refers to (the object's state) is\r\n     crucial to understanding this distinction.\r\n  <p>\r\n  Finally, if a variable stores <b>null</b>, it refers to no object.\r\n  So calling a method on that variable cannot ever work correctly: when Java\r\n     uses the variable to find the object it refers to (so that it can call the\r\n     method using the state of that object), it fails to find any object at\r\n     all, so it automatically throws a <b>NullPointerException</b>; it should\r\n     really be called a null \"reference\" exception, because we don't use the\r\n     word \"pointer\" in Java; that is a C/C++ word.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Fields -->\r\n\r\n<a name=\"UsingFields\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Fields</b></td>\r\n<td width =\"80%\">\r\n  Because most fields are instance variables, and most instance variables are\r\n    defined to be <b>private</b>, we do not really need to know anything about\r\n    them to understand how to use a class: only the person writing the class\r\n    can use its <b>private</b> members.\r\n  Later, when we learn how to write our own classes, we will investigate and\r\n    manipulate such <b>private</b> fields thoroughly.\r\n  <p>\r\n  If we did declare a field to be <b>public</b> (and programmers rarely do;\r\n    and if they do, they are most likely to declare it <b>final</b> as\r\n    well), say <b>public int sidesPerDie;</b>, and if variable <b>d</b>\r\n    referred to a <b>DiceEnsemble</b> object, then we could write\r\n    <b>System.out.println(d.sidesPerDie);</b> to access the value of that\r\n      member (not too bad) or <b>d.sidesPerDie = -2;</b> to store into that\r\n      member (terrible; it will stop all the other methods from working).\r\n  Thus, by the class-writer declaring this instance variable to be \r\n    <b>private</b>, he/she has guaranteed that instances of the class cannot\r\n    be corrupted by incompetent or malicious programmers.\r\n  <p>\r\n  When <b>private</b> instance variables were first introduced in programming\r\n    languages (the early 1970s), there was a big debate as to whether they\r\n    were good or bad.\r\n  Many famous computer scientists argued about the advantages and disadvantage\r\n    of hiding information from programmers.\r\n  It was a hot topic.\r\n  But now, in the 21st century, there is almost complete agreement that\r\n    information hiding is good, and that features like <b>private</b> instance\r\n    variables should be used whenever possible.\r\n  We will return to this discussion when we learn how to write classes.\r\n  At that point, we will learn more formally how <b>private</b> instance\r\n    variables help programmers who write classes ensure that all objects obey\r\n    certain class invariants, no matter how the objects are used by other\r\n    programmers.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- OOP -->\r\n\r\n<a name=\"OOP\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>OOP Summary</b></td>\r\n<td width =\"80%\">\r\n  So, what is object-oriented programming (OOP) about?\r\n  Much of it concerns finding useful classes for the problems that we need to\r\n    solve, constructing objects from these classes, and calling methods on\r\n    these objects to help solve our problems.\r\n  We have certainly discussed a large number of technical terms that help\r\n    us talk precisely about what we are doing -but the code that we actually\r\n    have to write in our programs is quite simple.\r\n  <p>\r\n  Let's return to our analogy one last time.\r\n  A class is like a blueprint; the <b>new</b> operator is like a skilled\r\n    worker who can read any blueprints and construct objects from them.\r\n  Because objects don't themselves have names, we store references to\r\n    objects in variables names.\r\n  Sometimes a program constructs just one object from a class; sometimes more\r\n     than one.\r\n  Each constructed object is similar to the others from its class: each has\r\n    the same instance variables (locations to store state), and each can be\r\n    used to call the same methods.\r\n  We use the arguments to a constructor to initialize the state of an object\r\n    once it is built.\r\n  Depending on which methods we call, the values of the instance variables\r\n     might change.\r\n  <p>\r\n  A common mistake for beginners is to confuse the name of a class with the\r\n    name of a variable that refers to an object constructed from that class.\r\n  What really makes the problem insidious, is this second form is exactly \r\n    what we use when calling <b>static</b> methods!\r\n  So, for example, writing <b>DiceEnsemble.roll();</b> is meaningless:\r\n    <b>DiceEnsemble</b> is the name of a class, not the name of a variable that\r\n     refers to an object constructed from that class; <b>roll</b> is the\r\n     name of a method, but it is not a <b>static</b> method.\r\n  If we declared <b>DiceEnsemble d = new DiceEnsemble(2,6);</b> then writing\r\n    <b>d.roll();</b> is fine.\r\n  And, writing <b>Math.max(3,7)</b> is fine too, because <b>max</b> is the\r\n    name of a <b>static</b> method defined in the <b>Math</b> class.\r\n  Learn to distinguish between these two confusing cases.\r\n  <p>\r\n  We can think of the period (<b>.</b>) as an operator: the member selector\r\n    operator.\r\n  Each period is prefixed by the name of a class (or a reference to an object\r\n    constructed from that class) and suffixed by the member name selected from\r\n    the relevant class.\r\n  In fact, we can augment our precedence table with this operator (level 15)\r\n    and the <b>new</b> operator (level 13); for completeness, I have also\r\n    included <b>?</b> and <b>:</b> (the operators for\r\n    <b>conditional expression</b> when used in combination, which have very\r\n    low precedence, at level 2).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead>\r\n  <tr align=\"left\">\r\n  <th>Operator</th><th>Name</th><th>Precedence</th><th>Associativity</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr align=\"left\"><td><pre><b>.<br>++ --</b></pre></td><td>member selector<br>postfix increment/decrement</td><td>15</td><td>left<br>none: all unary</td>\r\n  <tr align=\"left\"><td><pre><b>+ - ! ++ --</b></pre></td><td>unary plus/minus/negate<br>prefix increment/decrement</td><td>14</td><td>none: all unary</td>\r\n  <tr align=\"left\"><td><pre><b>new<br>(type)</b>expression</pre></td><td>constructor operator<br>casting (see below)</td><td>13</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>* / %</b></pre></td><td>multiply divide remainder</td><td>12</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>+ -</b></pre></td><td>add, subtract</td><td>11</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>< <= > >=</b><pre><b>instanceof</b></pre></td><td>inequality relational</td><td>9</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>== !=</b></pre></td><td>equality relational</td><td>8</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>&&</b></pre></td><td>logical and</td><td>4</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>||</b></pre></td><td>logical or</td><td>3</td><td>left</td>\r\n  <tr align=\"left\"><td><pre><b>?:</b></pre></td><td>conditional expression</td><td>2</td><td>none</td>\r\n  <tr align=\"left\"><td><pre><b>= += -= *= /= %=</b></pre></td><td>state change</td><td>1</td><td>right</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n<p>\r\nNote that in the cascaded call <b>dice.roll().getRollCount();</b>\r\n  first <b>roll</b> is called on <b>dice</b>, and then <b>getRollCount</b>\r\n  is called on the result that <b>roll</b> returns (a reference to \r\n  <b>dice</b> with its state updated).\r\nThis is because period (<b>.</b>) is left associative.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Importing Packages -->\r\n\r\n<a name=\"ImportingPackages\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Importing Classes from Packages</b></td>\r\n<td width =\"80%\">\r\n  Large software systems, like the standard Java library, comprise thousands\r\n    of different classes.\r\n  Programmers often need some way to organize these classes, and Java\r\n    provides a <b>package</b> mechanism for this purpose.\r\n  In this section we will learn how to access classes that declared in\r\n    packages.\r\n  First, we have the following EBNF rule that describes package names.\r\n  <p>\r\n  &nbsp &nbsp <i>package-name</i> <= <i>identifier</i>{.<i>identifier</i>}\r\n  <p>\r\n  For example, <b>java.lang</b> is one important package name for anyone\r\n    using Java; <b>edu.uci.ics.pattis.introlib</b> is an important package\r\n    name for anyone IN THIS COURSE using Java (that is the package in which\r\n    the <b>Prompt</b> class is declared).\r\n  Package names must be unique; one way to guarantee uniqueness is by using a\r\n    variant of an internet address (pattis@ics.uci.edu) which are guaranteed \r\n    (by the people runing the internet) to be unique.\r\n  <p>\r\n  The Javadoc for a class tells us in which package it is declared.\r\n  We can always use the <b>full name</b> of a class, prefacing the class name\r\n    with its package name.\r\n  Thus, we could refer to the <b>BigInteger</b> class by\r\n    <b>java.math.BigInteger</b> and the <b>Prompt</b> class by\r\n    <b>edu.uci.ics.pattis.introlib.Prompt</b>; OK, it is pretty obvious we need\r\n    a shortcut.\r\n  <p>\r\n  To be able to write a class name by itself, we must import it with an\r\n    <i>import-declaration</i>, whose EBNF rule appears below (<b>import</b>\r\n    is a keyword).\r\n  Once a class is imported, we can use the class name by itself, without\r\n    its package name as a prefix.\r\n  <p>\r\n  &nbsp &nbsp <i>import-declaration</i> <= <b>import</b> <i>package-name</i>.*; &nbsp | &nbsp <b>import</b> <i>package-name</i>.<i>identifier</i>;\r\n  <p>\r\n  The first alternative imports ALL classes declared in a package; the second\r\n    imports just the single class in that package named by <i>identifier</i>.\r\n  I prefer writing the pair of imports\r\n  <pre><b>  import edu.uci.ics.pattis.introlib.Prompt;\r\n  import edu.uci.ics.pattis.introlib.DiceEnsemble;</b></pre>\r\n  instead of the shorter and equivalent\r\n  <pre><b>  import edu.uci.ics.pattis.introlib.*;</b></pre>\r\n  because it explicitly identifies the names of all the classes that I am using\r\n    from a package.\r\n  By commenting-out one of these imports, the compiler will generate errors in\r\n    every statement where that class is used (it is sometimes very useful to\r\n    know all the places in your code where a class is used).\r\n  <p>\r\n  Here is another interesting facet of package and class names.\r\n  The standard Java library declares a class named <b>Timer</b> in its\r\n    <b>java.util</b> package.\r\n  Without knowing about this class, I wrote a <b>Timer</b> class in my  \r\n    <b>edu.uci.ics.pattis.introlib</b> package, which does something very\r\n    different.\r\n  If I want to use only one of these classes, in a program, I just import it.\r\n  But if I want to use both, I cannot import both: the compiler will detect\r\n    and report an error if I try to import the same class name from two\r\n    different packages.\r\n  What I can do is import one class (say, the one I use most often)\r\n    and then just refer to the other class by its full name.\r\n  So long as package names are different, even if class names are the same,\r\n    there is a way to specify to Java exactly what we want to do (although\r\n    it might be a bit verbose).\r\n  <p>\r\n  Note that both the <b>Math</b> and <b>String</b> classes are declared in the\r\n    <b>java.lang</b> package.\r\n  What makes this package so special, is that we never have to import its\r\n    classes explicitly; they are automatically available.\r\n  It is as if every program implicitly contains <b>import java.lang.*;</b>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- JavaDoc -->\r\n\r\n<a name=\"JavaDoc\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>JavaDoc</b></td>\r\n<td width =\"80%\">\r\n  One of the foremost reasons that I like teaching Java is Javadoc.\r\n  Javadoc is a system for documentation that was developed at the same\r\n    time as Java; it is included with the standard Java distribution.\r\n  The thousands of classes in the standard Java library are all documented\r\n    using Javadoc.\r\n  In this lecture we learn about Javadoc as consumers: how to read the output\r\n    of Javadoc, so that we can learn how to explore and use prewritten classes.\r\n  In a later lecture we will learn more about Javadoc, as producers: how to\r\n    write the input to Javadoc, so that we can document the classes that we\r\n    write.\r\n  <p>\r\n  Java was one of the first languages developed after the popularization of\r\n    web browsers.\r\n  In a dramatic departure from the past, where there were few documentation\r\n    systems -much less official ones- for languages, Java and Javadoc were\r\n    developed together synergistically.\r\n  The Javadoc system takes as input annotated (with special comments, tags,\r\n    and links) Java classes and produces easy-to-read web pages documenting\r\n    them.\r\n  Their format, always the same, is designed to include a tremendous amount\r\n    of useful information about each class and all its members.\r\n  Javadoc also automatically highlights and cross-indexes information about\r\n    the use and meaning of each member available in a class.\r\n  <p>\r\n  In this section, we will discuss most aspects of browsing Javadoc, using the\r\n    the <b>Math</b> and <b>DiceEnsemble</b> classes as examples.\r\n  To start, let's examine the web page that first appears for the\r\n    <a href=\"http://java.sun.com/javase/6/docs/api/\" target=\"_blank\">\r\n    Javadoc of Sun's API</a>.\r\n  It will be useful for you to click this link now, so you can follow\r\n    (dynamically on the web) along with the static screen-shots presented in\r\n    this document\r\n   (if you are like me, you are going to try to click them and get really\r\n     frustrated:).\r\n  You should see the following.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/standard.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nUse the small upper-left hand (Package) pane for selecting from which package\r\n  you want to see the classes: it determines what information is displayed in\r\n  the narrow lower-left hand (Class) pane, which is a list -in alphabetical\r\n  order- of all the classes in the selected package.\r\nInitially, the package pane has <b>All Classes</b> selected, which appears at\r\n  its top, selected.\r\nYou can try clicking other packages (e.g., <b>java.awt</b>, <b>java.io</b>,\r\n  <b>java.lang</b>, <b>java.util</b>, etc.), but\r\n  before continuing, make sure <b>All Classes</b> is selected.\r\n<p>\r\nThe big (Documentation) pane on the right initially overviews (see the word\r\n  <b>Overview</b> highlighted in the header of this pane) information about\r\n  the packages available; but, as we will soon see, it mostly is used to\r\n  display the documentation for specific classes and interfaces.\r\nTo display the documentation for the <b>Math</b> class, scroll the\r\n  class pane so that the <b>Math</b> link is visible, and then click it.\r\n(another way to find this link is to click inside the lower left window,\r\n  then type <b>control f</b> and then type in the <b>Find</b> window\r\n  the word <b>Math</b> and then click <b>Next</b>).\r\nYou should see\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/mathmain.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNow the word <b>Class</b> is highighted in the header and the rest of this\r\n  pane shows the documentation of the <b>Math</b> class.\r\nRight under the header it shows in bold-face the package that this class comes \r\n  from (<b>java.lang</b>), followed by the word <b>Class</b> and the name of\r\n  the class (<b>Class Math</b>) in a big bold-face font.\r\nThe information directly underneath is related to the class-hierarchy -\r\n  the ancestors of this class is <b>java.lang.object</b>: when we learn about\r\n  inheritance, we will study Javadoc again and return to this section for a\r\n   more detailed study.\r\n<p>\r\nDirectly underneath the line, Javadoc displays information that is used to\r\n  define the basic features of a class.\r\nWhen we learn about writing classes, interfaces, and inheritance, we will\r\n  study Javadoc again and return to this section for a more detailed study.\r\nThis information is followed by an textual overview of the class.\r\n<p>\r\nScroll down in the actual Javadoc window (the window on this web page is\r\n  just a picture: you cannot scroll it) you will see the <b>Since</b>\r\n  information, which identifies the release of Java when this class was added\r\n   to the standard Java library.\r\n<p>\r\nThe rest of this web page is divided into two major sections: <b>Summary</b>\r\n  and <b>Detail</b>.\r\nWe will start by examining the summary information.\r\nScroll down on the documentation pane until you see\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/mathsummaries.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThe summary section normally includes tables for fields, constructors, and\r\n  methods.\r\nBut, because every member of this class is <b>static</b>, there is no need\r\n  for a constructor, so that table is omitted.\r\nThese tables display information for all the <b>public</b> members defined in\r\n   the class, and only the <b>public</b> members.\r\nNote, you won't see the access modifier <b>public</b> appearing in any summary\r\n  box on the left, because these boxes display only <b>public</b> members;\r\n  if a member is declared <b>private</b>, it doesn't appear in these tables.\r\n<p>\r\nLet's start at the field summary.\r\nFirst of all, these members always appear in alphabetical order.\r\nEach field is described in a horizontally split box: it displays, on the\r\n  left, some of its access modifiers (not all) and its type; on the right it\r\n  displays its name and a one sentence description of the field.\r\n<p>\r\nLikewise for the method summary (which also appear in alphabetical order).\r\nEach method is described in a horizontally split box: it displays, on the\r\n  left, some of its access modifiers and its return type; on the right it\r\n  displays its signature and a one sentence description of the method (the\r\n  same one from the <b>Summary</b>.\r\nAs is the case with fields, each method name is hyperlinked to a more detailed\r\n  description of that member that appears in the <b>Detail</b> section.\r\nFor now, scroll to the end of the <b>Summary</b> section until you see the\r\n  following (or, alternatively, click the <b>E</b> in the field summary\r\n  and scoll up a bit).\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/mathinherited.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThis part of the page starts by displaying the summary of the <b>toDegrees</b>\r\n  method, and the <b>ulp</b> method ends the <b>Summary</b> section.\r\nNext it shows a small box headed by a hyperlink to the class that this one\r\n  extends; its contents contain hyperlinks to all the methods in that class.\r\nAgain, when we learn about writing classes, interfaces, and inheritance, we\r\n  will study Javadoc again and return to this section for a more detailed\r\n  study.\r\n<p>\r\nFinally, the <b>Detail</b> sections start: first for fields, then for\r\n  constructors (but there aren't any in this class), and finally for methods.\r\nEach field's name is displayed in a big bold-face font, followed by all\r\n  the fields's access modifiers and its name again, followed by a more\r\n  detailed description of the field.\r\nThe description always starts with the one sentence appearing in the summary;\r\n  because the fields in the <b>Math</b> class are so simple, there is no more\r\n  detail in their descriptions.\r\nFinally, at the bottom of this page, the <b>Detail</b> section for the\r\n  methods start.\r\nScroll down again, until you see\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/mathdetail.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nEach method is easily reachable via a hyperlink from its listing in the\r\n  <b>Summary</b> section.\r\nAs you scroll down, you will notice that these methods DO NOT appear in \r\n  alphabetical order; instead they appear in the same order as the\r\n  methods were defined in the <b>.java</b> file from which this Javadoc\r\n  was created.\r\nIf a programmer clusters together related methods in the <b>.java</b> file,\r\n  these methods will be clustered in the <b>Detail</b> section of Javadoc too;\r\n   of course, if these methods appear in alphabetical order in the file, they\r\n   will appear in alphabetical order here too: the programmer chooses\r\n   (recall the <b>Summary</b> section always alphabetizes its members)\r\n<p>\r\nEach methods's name is displayed in a big bold-face font, followed by all\r\n  the method's access modifiers and its signature, followed by a more\r\n  detailed description of the method.\r\nThe description always starts with the one sentence that appears in the \r\n summary, which acts as the \"topic sentence\" for the larger descritioon hear\r\nAfter this description is a section of highlighted information including\r\n  short descriptions of the method's <b>Parameters</b>, what exceptions it\r\n  <b>Throws</b> (none here), and what value it <b>Returns</b>.\r\n<p>\r\nI encourage you to explore the web page for this class; you might also\r\n  want to examine the web pages for the <b>StringTokenizer</b> and\r\n  <b>BigInteger</b> classes, which we will discuss soon; both are defined\r\n  and documented in the standard Java library.\r\nScroll to the top or bottom of the page and click the <b>Package</b>,\r\n  <b>Tree</b>, <b>Index</b>, and <b>Help</b> links to see other\r\n  interesting views of this library.\r\n<p>\r\nNext, lets examine web page that first appears for the \r\n    <a href=\"../../../common/classes/doc/index.html\" target=\"_blank\">\r\n    Javadoc of Course API</a>.\r\nClick this link and you should see the following.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/classlib.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThis page has a similar layout; it is simpler because it documents just\r\n  one packages, comprising about a dozen classes.\r\nClick the <b>DiceEnsemble</b> link and you should see.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/dicemain.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNotice the standard features shown for all classes: their package name, the\r\n  class name, and the prose description.\r\nThis class has no <b>public</b> fields, so the <b>Summary</b> section\r\n  includes just constructor and method tables.\r\nExamine the constructor summary: each entry includes its signature and a one\r\n  sentence description.\r\nLook further down to the methods table: recall that these appear\r\n  in alphabetical order.\r\nNow, click the hyperlink for the second, overloaded version of the\r\n  <b>DiceEnsemble</b> constructor.\r\nYou should see\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/dicedetail.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nEach constructor's name (they all have the same name!) is displayed in a big\r\n  bold-face font, followed by all its access modifiers and its signature;\r\n  notice how multiple parameters are displayed, and notice the\r\n  <b>throws IllegalArgumentException</b> after the signature.\r\nThis is followed by a more detailed description of the constructor.\r\nThe description always starts with the one sentence appearing in the summary,\r\n  but can be much longer.\r\nAfter this description is a section of highlighted information including\r\n  short descriptions of the constructor's <b>Parameters</b> and what\r\n   exceptions it <b>Throws</b>.\r\n<p>\r\nI encourage you to explore the web page for this class and others.\r\nIf you want run a driver program for this class, and experiment\r\n  calling its methods, download, unzip, and run the\r\n  <a href=\"../../programs/dicedemo.zip\">Dice Demo</a> project folder.\r\nYou might also want to examine the web pages for the <b>Prompt</b> class,\r\n  which we have used extensively, and the <b>Timer</b> class, which we will\r\n   discuss soon;; both are defined and documented in the course library.\r\nSuppose you are interested in exactly what <b>IllegalArgumentException</b>\r\n  is -it is another class is the standard Java Library; just click on its\r\n   hyperlink (whoops, for some reason there isn't a hyperlink to it! I'll try\r\n   to fix this, meanwhile look up <b>IllegalArgumentException<b> in the\r\n   standard Java Library -the same way we located the <b>Math</b> class)\r\n   and you should see\r\n</td>\r\n</tbody>\r\n</table>\r\n  <img src=\"images/iae.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nNow you know that this is a class in the <b>java.lang</b> package (the one\r\n  that every program automatically imports).\r\nIt has lots of ancestor classes.\r\nThere is some information about interfaces and subclasses (we will cover\r\n  these later in the quarter).\r\nAt the bottom is the <b>Summary</b> section for constructors.\r\nNote that many entries on this page are hyperlinked, so you can click\r\n  them to get more information, exploring the Javadoc for the standard\r\n  Java library further.\r\n<p>\r\nWell, that completes our first tour of Javadoc.\r\nThe ability to read Javadoc easily is one of those skills that is\r\n  tough to acquire, but doing so will pay for itself many times\r\n  over.\r\nWhenever I am programming in Java, I always immediately open a \r\n  Javadoc browser to help me.\r\nIn subsequent sections we will discuss more Java classes.\r\nPlease examine their Javadoc while reading this material.\r\nIn addition, use Javadoc to check out the many features of the <b>String</b>\r\n  class.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Programming By Contract -->\r\n\r\n<a name=\"Contract\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Programming by Contract</b></td>\r\n<td width =\"80%\">\r\n  In this section we discuss the idea of preconditions and postconditions,\r\n    and how they relate to constructors and methods.\r\n  When we learn how to write classes, we will also discuss data invariants,\r\n    which is a related topic.\r\n  <p>\r\n  We say that a constructor has a <b>precondition</b> if some properties\r\n    must be true of its arguments.\r\n  We say that a constructor has a <b>postcondition</b> if it guarantees\r\n    that some property is true about the object's state after the object is\r\n    constructed  (assuming that all its arguments satisfy their preconditions).\r\n  <p>\r\n  We say that a method has a <b>precondition</b> if some properties\r\n    must be true of the object it is called on and its arguments.\r\n  We say that a method has a <b>postcondition</b> if it guarantees\r\n    that some property is true about the returned value and the object's\r\n    states after the method returns (assuming that all its arguments satisfy\r\n    their preconditions).\r\n  <p>\r\n  In <b>DiceEnsemble</b> constructor, there is a precondition that the\r\n    arguments matching the <b>numberOfSides</b> and <b>sidesPerDie</b>\r\n    parameters must be at least 1: it doesn't make sense for 0 or negative\r\n    numbers to be transmitted to these parameters.\r\n  The constructor checks these preconditions first: if it determines that\r\n    either precondition fails, it cannot construct the required object;\r\n    instead, it throws an <b>IllegalArgumentException</b>.\r\n  <p>\r\n  Likewise, the <b>getPips</b> method has a precondition that the dice have\r\n    been rolled at least once, and the <b>dieIndex</b> parameter actually\r\n    specifies one of the dice in the ensemble.\r\n  If this method is called before the <b>roll</b> method is called, it throws\r\n    an <b>IllegalStateException</b>: the state of the object is not correct for\r\n    returning the values of any pips, if it has not been rolled yet.\r\n  Likewise, if this method is called with an argument for <b>dieIndex</b> that\r\n    is not in the correct range, it throws an <b>IllegalArgumentException</b>.\r\n  <p>\r\n  In the real world, for example, a microwave oven may beep at you (indicating\r\n    an illegal operation in the current state) if you try to start it when the\r\n    door is open. \r\n  <p>\r\n  By understanding this form of stylized documentation, we can view every\r\n     method as making a contract with the programmer: if the programmer calls\r\n     the method on an object whose state satisfies the required\r\n     preconditions, and with arguments that satisfy the required preconditions,\r\n     then the method will work correctly, producing a result that satisfies its\r\n     postcondition.\r\n  If the object's state or argument values fail to satisfy their preconditions,\r\n    the method will mostly likely discover this fact, and throw an exception,\r\n    although in such cirumstances it is allowed to return a result that does\r\n    not satisfy the postcondition.\r\n  Certainly, it is better for a method to throw an exception when it knows it\r\n    cannot satisfy its postcondition, than to return an incorrect answer\r\n    (with no indication that it is incorrect).\r\n  But in a contract, if the the preconditions aren't satisfied, anything\r\n    is allowable.\r\n  <p>\r\n  If you gave a task to a person who couldn't perform it,would you rather have\r\n    that person say, \"I cannot do it,\" or instead botch the job?\r\n  Likewise, would you rather someone answer a question with, \"I don't know\",\r\n    or give you a wrong answer?\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Other Useful Classes -->\r\n\r\n<a name=\"OtherClasses\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Other Useful Class</b></td>\r\n<td width =\"80%\">\r\nIn this section we will examine a few other classes from both the standard\r\n  Java library and the course library.\r\nWe focus on the standard OOP approach: constructing objects and then calling\r\n  methods on them to perform interesting operations.\r\n<p>\r\nFirst, you should use Javadoc to examine the <b>Prompt</b> class in\r\n  the course library and the <b>String</b> class in the standard\r\n  Java library.\r\nYou are already familiar with these classes: the former has all <b>static</b>\r\n  methods for prompting the user on the console screen, and the later\r\n  has very many methods for operating on strings.\r\nNote that the <b>String</b> class has no mutator/command methods; every\r\n  method is an accessor/query.\r\nSuch a class is called <b>immutable</b>.\r\nOnce the state of an object is initialized by a constructor from an immutable\r\n  class, it can never change.\r\nBut methods can return new objects whose state is based on old objects\r\n  (e.g., the <b>toUpperCase</b> and <b>replace</b> methods).\r\n<p>\r\nWhile examining the <b>String</b> class, look at methods like <b>charAt</b>,\r\n  <b>endsWith</b>, <b>indexOf</b>, <b>lstIndexOf</b>, <b>length</b>,\r\n  <b>startsWith</b>, <b>subsequence</b>, <b>toLowerCase</b>,\r\n  <b>toUpperCase</b>, <b>trim</b>\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>StringTokenizer</b></td>\r\n<td width =\"80%\">\r\nNow let's examine some interesting code that uses the <b>StringTokenizer</b>\r\n  class, from the standard Java library (in the <b>java.util</b> package</b>).\r\nThis class has three constructors and six methods, although the most\r\n  interesting and generally useful members are defined by\r\n<b><pre>  public StringTokenizer(String str){...}\r\n\r\n  public int     countTokens  ()                               {...}\r\n  public boolean hasMoreTokens()                               {...}\r\n  public String  nextToken    () throws NoSuchElementException {...}</pre></b>\r\nHere is a typical example of how we can coordinate these to solve a \r\n  simple task: finding the average length of all the words in a sentence.\r\n<b><pre>  String          sentence   = Prompt.forString(\"Enter sentence\");\r\n  StringTokenizer st         = new StringTokenizer(sentence);\r\n  int             numTokens  = st.countTokens();\r\n  int             numLetters = 0;\r\n  while (st.hasMoreTokens())\r\n    numLetters += st.nextToken().length();\r\n  System.out.println(\"In the sentence: \" + sentence + \"\\n\" +\r\n                     \"Average word length = \" + numLetters/numTokens);</pre></b>\r\nFor the input <b>To be or not to be</b>, the calculated output is <b>2</b>\r\n (thirteen letters in six words: <b>13/6</b>).\r\nNotice that <b>sentence</b> is used only as an argument in the constructor to\r\n  <b>StringTokenizer</b> and in the final output: it never changes its state.\r\nIt is <b>st</b> that is manipulated from that point onwards.\r\n<p>\r\nFirst, we use the <b>countTokens</b> methods to count and store the number of\r\n  tokens initially in <b>st</b>: here, whitespace separates tokens\r\n  (it DOES NOT use the technical definition of Java tokens).\r\nThen a loop continues so long as <b>st</b> still has more tokens to process;\r\n  if so, the next token is taken out of <b>st</b> by calling <b>nextToken</b>\r\n  (a mutator/command that also returns a copy of the <b>String</b> token that\r\n  it extracts); then a cascaded call to <b>length</b> on the returned\r\n  <b>String</b> returns an <b>int</b> that is accumulated in <b>numLetters</b>.\r\n<p>\r\nEventually, there will be no more tokens remaining in <b>st</b>, so the\r\n  loop terminates and the result is calculated and printed.\r\nNote that if we call <b>st.countTokens()</b> after the loop terminates, it will\r\n  return <b>0</b>, because this method returns the number of tokens that\r\n  ARE STILL in <b>st</b>; at the end, no tokens remain.\r\n<p>\r\nNote that  if we ever try to call <b>nextToken</b> when <b>hasMoreTokens</b>\r\n  returns <b>false</b> (or equivalently, <b>countTokens</b> returns <b>0</b>),\r\n  this method throws <b>NoSuchElementException</b>: there is no next value\r\n  to return.\r\nWe can use this behavior, along with our knowledge of <b>try-catch</b>, to\r\n  write an equivalent loop to process all the tokens and then terminate.\r\n<b><pre>  String          sentence   = Prompt.forString(\"Enter sentence\");\r\n  StringTokenizer st         = new StringTokenizer(sentence);\r\n  int             numTokens  = st.countTokens();\r\n  int             numLetters = 0;\r\n  for (;;)\r\n    try {\r\n      numLetters += st.nextToken().length();\r\n    }\r\n    catch (NoSuchElementException nsee){break;}\r\n  System.out.println(\"In the sentence: \" + sentence + \"\\n\" +\r\n                     \"Average word length = \" + numLetters/numTokens);</pre></b>\r\nGenerally, programmers would prefer the former code, which explicitly\r\n  checks for <b>hasMoreTokens</b>, but you should certainly understand\r\n  the <b>for</b>/<b>try-catch</b> code above.\r\n<p>\r\nFinally, examine the following code closely, which is supposed to accomplish\r\n  the same task as above.\r\n<b>IT DOES NOT WORK CORRECTLY</b> and it is important for you to determine why\r\n  by hand simulting the code.\r\n<b><pre>  String          sentence   = Prompt.forString(\"Enter sentence\");\r\n  StringTokenizer st         = new StringTokenizer(sentence);\r\n  int             numTokens  = st.countTokens();\r\n  int             numLetters = 0;\r\n  for (int i=0; i&lt;st.countTokens(); i++)\r\n    numLetters += st.nextToken().length();\r\n  System.out.println(\"In the sentence: \" + sentence + \"\\n\" +\r\n                     \"Average word length = \" + numLetters/numTokens);</pre></b>\r\nHand simulate this code (slowsly and carefully) on a <b>String</b> with five or\r\n  six tokens in it and be ready to answer a question about this code in class.\r\n<p>\r\nWhen using a <b>StringTokenizer</b> prefer a loop calling <b>hasMoreTokens</b>\r\n  explcitly (to check whether your code should be callling <b>nextToken</b>\r\n  and not \"obvious\" -but often wrong- counting code).\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Timer</b></td>\r\n<td width =\"80%\">\r\nNow let's examine some interesting code that uses the <b>Timer</b>\r\n  class, from my course library.\r\nThis class allows us to use its objects like stopwatches, to time various\r\n  parts of code.\r\nIt has one parameterless constructor and four methods (besides\r\n  <b>toString</b>)\r\n<b><pre>  public Timer(){...}\r\n\r\n  public void   start()      {...}\r\n  public void   stop()       {...}\r\n  public void   reset()      {...}\r\n  public double getElapsed() {...}</pre></b>\r\nSee Javadoc for a detailed explanation of what these members do.\r\nHere is a typical example of how we can coordinate these to solve a \r\n  simple task: finding the the time it takes for the user to enter an\r\n  answer to a question.\r\n<b><pre>  Timer answerTimer = new Timer();\r\n  answerTimer.start();\r\n  Prompt.forString(\"What is big and red and eats rocks?\");\r\n  answerTimer.stop();\r\n  System.out.println(\"Time = \" + answerTimer.getElapsed() + \" seconds\");</pre></b>\r\nIt actually doesn't matter whether the user gets the right or wrong answer\r\n  to the question: the returned <b>String</b> is not checked; all we are\r\n  interested in here is the time it took to answer this question.\r\n<p>\r\nAll newly constructed timers have the same state: they are turned off, with 0\r\n  elapsed seconds recorded.\r\nWhen the <b>start</b> method, a mutator/command, is called the timer is turned\r\n  on (just like a stopwatch).\r\nWhen the <b>stop</b> method, also a mutator/command, is called the timer is\r\n  turned off (ditto; note that both of these methods return <b>void</b>).\r\nWhen the <b>getElapsed</b> method, an accessor/query, is called the timer\r\n  returns the total number of seconds that elapsed while the timer was on; this\r\n  value is is accurate to 1 millisecond.\r\nWe can call this method whether the <b>Timer</b> object is current turned on\r\n  or off.\r\n<p>\r\nWe can turn the timer on and then off as many times as we want; it accumulates\r\n  time only when it is on (of course, we can call the <b>reset</b> method also,\r\n  to reset the timer to its initial  state of being off and having zero elapsed\r\n  seconds).\r\nWe can use objects from the <b>Timer</b> class to time any computer activity\r\n  that takes at least 1 millisecond, such as how long it takes to execute\r\n  some complicated loop in a program.\r\n</td>\r\n</tbody>\r\n</table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>BigInteger</b></td>\r\n<td width =\"80%\">\r\nFinally, let's examine some interesting code that uses the <b>BigInteger</b>\r\n  class, from the standard Java library (in the <b>java.math</b> package</b>).\r\nThis class allows us to compute with integers of an arbitrary size (not limited\r\n  to the size of <b>int</b> values).\r\nThe operations on <b>BigInteger</b> objects are are all specified via method\r\n  calls (not operators).\r\nAnd the class, like <b>String</b> is immutable: all method calls do not change\r\n  the state any existing objects, but they can produce new <b>BigInteger</b>\r\n  objects whoses states are based on the state of the objects used to call the\r\n   methods.\r\n<p>\r\nThis class has three public fields (representing the <b>BigInteger</b>\r\n  constants 1, 10, and 0), many constructors, and many many methods that\r\n  act like operators on <b>int</b> values), although we need only the following\r\n   members for our application below.\r\n<b><pre>\r\n  public static final BigInteger ONE = new BigInteger(\"1\");\r\n\r\n  public BigInteger(String val) throws NumberFormatException {...}\r\n\r\n  public BigInteger multiply(BigInteger val){...}\r\n  public String     toString()              {...}</pre></b>\r\n<p>\r\nHere is a typical example of how we can coordinate these to solve a \r\n  simple task: finding the factorial of a large <b>int</b> value; say\r\n  something like <b>1000!</b> (which has tens of thousands of digits).\r\nThe following simple code works for inputs up to about 10, but after that \r\n  <b>result</b> gets too big to store as an <b>int</b>.\r\nThat's the bad news; but the good news is that we can take this code and\r\n  easily generalize it for <b>BigInteger</b> results..\r\n<b><pre>  int x      = Prompt.forInt(\"Enter x for x!\");\r\n  int answer = 1;\r\n  for (int i=2; i<=x; i++)\r\n    answer = answer * i;\r\n  System.out.println(x+\"! = \" + answer);</pre></b>\r\nNow, let's do the generalization.\r\nThe important thing to know about the main constructor for <b>BigInteger</b>\r\n  is that it takes a <b>String</b> parameter that stores an optional plus or\r\n  minus, followed by all the digits in the <b>BigInteger</b> we want; if it\r\n  contains any other characters, this constructor throws the\r\n  <b>NumberFormatException</b>.\r\nSo, we could write <b>new BigInteger(\"1000000000000\")</b> to construct\r\n  the <b>BigInteger</b> value one-trillion (which is not representable as\r\n  an <b>int</b>; this is peanuts compared to the thousands of digits in\r\n  <b>1000!</b>).\r\n<p>\r\nHint, here is an important <b>idiom</b>: if <b>i</b> is declared to be an\r\n   <b>int</b> and stores an <b>int</b> value, then the expression <b>\"\"+i</b>\r\n   stores a <b>String</b> representation of that <b>int</b>: <b>\"\"+10</b> is\r\n   <b>\"10\"</b>; so if we want to construct a <b>BigInteger</b> from an\r\n   <b>int</b>, we use the constructor on the <b>int</b> catenated with the\r\n   empty string.\r\n<p>\r\nFinally, the <b>multiply</b> method multiplies two <b>BigInteger</b>s\r\n  producing a third, whose state is the product of the states of its\r\n  arguments.\r\nNote that we must call this method using object notation.\r\nRemember the <b>.equals</b> method (which was like a binary operator)?\r\n  <b>multiply</b> is simlar: called as <b>x.multiply(y)</b>.\r\n<p>\r\nNow, let's change our code to use <b>BigInteger</b>s only where needed: to\r\n  accumulate the huge product.\r\n<b><pre>\r\n  int        x      = Prompt.forInt(\"Enter x for x!\");\r\n  BigInteger answer = BigInteger.ONE;\r\n  for (int i=2; i<=x; i++)\r\n    answer = answer.multiply(new BigInteger(\"\"+i));\r\n  System.out.println(x+\"! = \" + answer);</pre></b>\r\nNotice that Java calls the <b>toString</b> method implicitly, when it needs to\r\n  convert <b>answer</b> into a <b>String</b> for catenation in the final\r\n  output.\r\nIt might be interesting to use a <b>Timer</b> to see how long this process\r\n  takes for large values of <b>x</b>.\r\n<p>\r\nBriefly examine the Javadoc for <b>BigInteger</b>, it includes arithmetic\r\n  operations as <b>methods</b> (e.g., <b>add</b>, <b>subtract</b>,\r\n  <b>multiply</b>, <b>divide</b>, <b>remainder</b>) which parallel the\r\n   arithmetic <b>operators</b> for <b>int</b> values.\r\nAlso briefly examine methods like <b>abs</b>, <b>max</b>, <b>min</b>,\r\n  and <b>gcd</b>, which could be, but are NOT, static methods in <b>Math</b>\r\n  class (the methods in the <b>Math</b> class operate on primitive types only).\r\n<p>\r\nFinally, examine the <b>compareTo</b> method which takes the place of all\r\n  the different relational operators (recall the Law of Trichotomy, because\r\n  what happens here is similar).\r\nIf we declare <b>BigInteger x,y;</b> and initialize these values, calling\r\n  <b>x.compare(y)</b> returns an <b>int</b> with the following properties:\r\n  the value is &lt; 0 if <b>x</b> is less than <b>y</b>;\r\n  the value is = 0 if <b>x</b> is the same as <b>y</b>;\r\n  the value is &gt; 0 if <b>x</b> is greater than <b>y</b>.\r\nSo, to check whether <b>x</b> is less than or equal to  <b>y</b>,\r\n  we would write the boolean expression <b>x.compareTo(y) &lt;= 0</b>.\r\nNote the arithmetic law: <b>x.compareTo(y) = -y.compareTo(x)</b>\r\nCan you explain why it is true using the Law of Trichotomy.\r\n<p>\r\nAlso, see the <b>compareTo</b> and <b>compareToIgnoreCase</b> methods in the\r\n  <b>String</b> class: they also return an <b>int</b> value with the same\r\n  semantics: comparing two <b>String</b>s according to their order in an\r\n  alphabetized dictionary.\r\n<p>\r\nWe have now learned members in about a half-dozen interesting class in Java,\r\n  seeing how to construct objects and call methods on them to get interesting\r\n  tasks done.\r\nI hope that you have also examined the Javadoc for all these classes, so\r\n  that you feel comfortable using this documentation system.\r\nFeel free to cut/paste the code here into the <b>Application.java</b> \r\n  file of some project; remember, though, to add the correct <b>import</b>\r\n  statements to your code.\r\n<p>\r\nYou can also download, unzip, and run\r\n<a href=\"../../programs/crapsstatistics.zip\">Craps Statistics</a> (uses\r\n  <b>DiceEnsemble</b> and <b>Timer</b>).\r\n<!--- Turned into an assignment\r\n or\r\n<a href=\"../../programs/collatzwithobjects.zip\">Collatz Conjecture</a> (uses\r\n  <b>BigInteger</b> and <b>Timer</b>) to examine programs that use these\r\n  classes.\r\n--->\r\nFinally, you can download, unzip, and run\r\n  <a href=\"../../programs/classexamples.zip\">Class Examples</a> project folder,\r\n  which has short snippets of code using a dozen different classes.\r\nThese examples show that it is easy to experiment with these (and other)\r\n  classes in any Java libraries.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Java File I/O -->\r\n\r\n<a name=\"RealFileIO\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Java File I/O</b></td>\r\n<td width =\"80%\">\r\n  There are dozens of classes that handle file I/O in Java; using various \r\n    combination of these classes, we can efficiently achieve many kinds of\r\n    interesting  behavior: buffered vs. non-buffered;\r\n    binary vs. text-files; sequential vs. random access; etc.\r\n  I have written the <b>TypedBufferReader</b> and <b>TypedBufferWriter</b>\r\n    classes (using classes in the standard Java library) to present a simple,\r\n    easy to understand and use, interface to the concept of file processing.\r\n  These classes are powerful enough for use in all the programs in this course.\r\n  <p>\r\n  After we are more familiar with reading/using classes (including\r\n     inheritance), we will\r\n    <ul>\r\n      <li>overview the standard Java classes for file I/O\r\n      <li>re-examine the code that implements the <b>TypedBufferReader</b> and \r\n            <b>TypedBufferWriter</b> classes.\r\n    </ul>\r\n  By the end of the course, you will have the skills needed to investigate\r\n    fancier file I/O by yourself.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- File Input Pattern -->\r\n\r\n<a name=\"FileInputPattern\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Simple File Input Patterns</b></td>\r\n<td width =\"80%\">\r\n  Reading a sequence of values from a file (until there are no more) is a\r\n    simple and useful operation.\r\n  This section shows a standard file input pattern to accomplish this task,\r\n    and applies it twice, without much variation, to files containing\r\n    different kinds of information.\r\n  <p>\r\n  Note that the contructor for the <b>TypedBufferReader</b> class requires a\r\n    <b>String</b>, but this <b>String</b> DOES NOT SPECIFY the name of the file\r\n    to be read.\r\n  Instead, it specifies how the user is to PROMPTED to enter a file name.\r\n  In fact, the constructor will continually reprompt the user with this\r\n    message until he/she enters a valid file name.\r\n  Of course, this information -and more- is all in its Javadoc.\r\n  I encourage you to browse the appropriate page while reading the rest of\r\n    this lecture.\r\n  <p>\r\n  Once we construct a <b>TypedBufferReader</b> object, we call methods on\r\n    it to attempt to read information from the file.\r\n  Again we follow standard OOP practice: construct an object and call its\r\n     methods to aid in performing some complicated task.\r\n  <p>\r\n  For a simple example, let us assume that we want to add together all the\r\n    <b>int</b> values in a file.\r\n  The relevant method in the <b>TypedBufferReader</b> class is\r\n  <b><pre>  public int readInt() throws EOFException,NumberFormatException</pre></b>\r\n  We can use the following code to process this file according to these\r\n    specifications.\r\n<pre><b>  TypedBufferReader inputFile = new TypedBufferReader(\"Enter file name \");\r\n  int sum = 0;\r\n  for (;;)\r\n    try {\r\n      int value = inputFile.readInt();  //or just the single line\r\n      sum += value;                     //sum += inputFile.readInt();\r\n    }\r\n    catch (EOFException eofe) {break;}\r\n\r\n  inputFile.close();\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n  Notice that the <b>try-catch</b> is the single statement inside the\r\n     <b>for</b> loop.\r\n  This code works as follows:\r\n  In each iteration, the first statement in the <b>try</b> block attempts to\r\n    read an <b>int</b> from the file.\r\n  If it is successful, that value is stored into <b>value</b> and then added\r\n     to <b>sum</b>; the <b>try-catch</b> is finished, and the <b>for</b> loop\r\n     executes it again.\r\n  <p>\r\n  But, if there are no more values in the file, the <b>readInt</b> method\r\n    throws <b>EOFException</b>.\r\n  Then, the <b>try</b> block is abandoned and the <b>catch</b> clause for this\r\n    exception is found; its matching block contains a <b>break-statement</b>,\r\n    which terminates the loop.\r\n  Now the <b>for</b> loop is finished, so Java continues by executing the\r\n    remaining statements after it: the first closes the file (that has had all\r\n    its values read) and the second prints the answer.\r\n  <p>\r\n  Now, let's examine very similar code that solves a more complicated problem.\r\n  Imagine that a file contains many lines, each of which contains a name,\r\n    three scores, and boolean telling whether the name and average of the\r\n    scores should be printed.\r\n  Such a file might look like <pre><b>  Fred    20  23  19 true\r\n  Barney  24  22  20 false\r\n  Wilma   21  24  25 false\r\n  Betty   23  19  22 true</b></pre>\r\n  and when processed should print the following (note that only <b>Fred</b>\r\n   and <b>Betty</b> specify that the average is to be printed)\r\n <pre><b>  Fred has average 20\r\n  Betty has average 21\r\n  4 values processed (some might not be printed)</b></pre>\r\n  We can use the following code to process this file according to these\r\n    specifications.\r\n<pre><b>  TypedBufferReader inputFile = new TypedBufferReader(\"Enter file name\");\r\n  int count = 0;\r\n  for (;;)\r\n    try {\r\n      String  name    = inputFile.readString();\r\n      int     s1      = inputFile.readInt();\r\n      int     s2      = inputFile.readInt();\r\n      int     s3      = inputFile.readInt();\r\n      boolean printIt = inputFile.readBoolean();\r\n      count++;\r\n      if (printIt)\r\n        System.out.println(name + \" has average \" + (s1+s2+s3)/3); \r\n    } \r\n    catch (EOFException eofe) {break;}\r\n\r\n  inputFile.close();\r\n  System.out.println(count + \" values processed (some might not be printed\");</b></pre>\r\n  Although this code has more complicated processing within the <b>try</b>\r\n     block, it is essentially the same pattern that we used before: continue\r\n     reading values until the <b>EOFException</b> is thrown, which breaks out\r\n     of the reading loop.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- File Output Pattern -->\r\n\r\n<a name=\"FileOutputPattern\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Simple File Output Pattern</b></td>\r\n<td width =\"80%\">\r\n  In this section, we will combine the previous code with some more code that\r\n    writes output  files.\r\n  We construct a <b>TypedBufferWriter</b> object, which requires a\r\n    <b>String</b> parameter specifying the name of a file.\r\n  Note the difference in the use of the parameter for the constructor between\r\n    this class and the <b>TypedBufferReader</b>.\r\n  In the larger code fragment below, we could write\r\n<pre><b>  TypedBufferWriter outputFile \r\n  = new TypedBufferWriter( Prompt.forString(\"Enter output file name\") );</b></pre>\r\n  to promput the user for the file name; but instead we automatically derive\r\n    the output file name from the input file name.\r\n  <p>\r\n  Once we have a variable refering to this object, we can use all the\r\n    <b>print</b> and <b>println</b> methods that we have used with\r\n    <b>System.out</b>.\r\n  Most important are the methods that print a <b>String</b>, because we\r\n    frequently use this type as a by-product of catenating many values\r\n    together.\r\n<pre><b>  TypedBufferReader inputFile \r\n    = new TypedBufferReader(\"Enter name of file \");\r\n  TypedBufferWriter outputFile \r\n    = new TypedBufferWriter(inputFile.getFileName()+\".output\"));\r\n  int count = 0;\r\n  for (;;)\r\n    try {\r\n      String  name    = inputFile.readString();\r\n      int     s1      = inputFile.readInt();\r\n      int     s2      = inputFile.readInt();\r\n      int     s3      = inputFile.readInt();\r\n      boolean printIt = inputFile.readBoolean();\r\n      count++;\r\n      if (printIt)\r\n        outputFile.println(name + \" has average \" + (s1+s2+s3)/3); \r\n    } \r\n    catch (EOFException eofe) {break;}\r\n\r\n  inputFile.close();\r\n  outputFile.close();\r\n  System.out.println(count + \" values processed (see \" + \r\n                     outputFile.getFileName() + \" for contents\");</b></pre>\r\n  Here, the name of the output file is constructed automatically, by catenating\r\n    together the name of the input file (retrieved through the\r\n    <b>getFileName</b> accessor/query) and the <b>\".output\"</b> literal.\r\n  Inside the loop, the information that was originally printed on\r\n    <b>System.out</b> is now printed to the output file.\r\n  Finally, like the input file, the output file is also closed after\r\n    everything is written in it.\r\n  Note too that the summary output still appears on the  user's console;\r\n    if we wanted to, we could have also printed this information into the file.\r\n  <p>\r\n  IMPORTANT: if you do not close an output file, it may lose the last few\r\n    lines sent to it.\r\n  To be safe, always close any input and output files whenever you are done\r\n    using them.\r\n  This also stop further informtion from being read from/written to the file.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Error Detection  -->\r\n\r\n<a name=\"ErrorDetection\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Error Detection in Input Files</b></td>\r\n<td width =\"80%\">\r\n  All the file reading code up to this point has assumed that files had the\r\n     correct type of data in them.\r\n  In this section and the next, we will begin to explore simple ideas in error\r\n    detection and recovery when reading input files.\r\n  We are just scratching the surface of this topic in this discussion; a more\r\n    complete discussion is beyond the scope of this course.\r\n  <p>\r\n  If we call a method to read some type of information out of a file, but a\r\n     value of that type is not there in the next position to be read, then the\r\n     method throws a <b>NumberFormatException</b> (even if what we are\r\n     trying to read is not a number, for uniformity).\r\n  The simplest thing to do in this case is abandon reading the file and process\r\n    whatever information has been already read correctly.\r\n  The following code implements this goal.\r\n<pre><b>  TypedBufferReader inputFile = new TypedBufferReader(\"Enter name of file \");\r\n  int count = 0;\r\n  for (;;)\r\n    try {\r\n      String  name    = inputFile.readString();\r\n      int     s1      = inputFile.readInt();\r\n      int     s2      = inputFile.readInt();\r\n      int     s3      = inputFile.readInt();\r\n      boolean printIt = inputFile.readBoolean();\r\n      count++;\r\n      if (printIt)\r\n        System.out.println(name + \" has average \" + (s1+s2+s3)/3); \r\n    } \r\n    catch (EOFException eofe) {break;}\r\n    catch (NumberFormatException noe) {\r\n      System.out.println(\"  Error reading file \" + inputFile.getFileName() +\r\n                         \" on line \" + inputFile.getLineNumber() +\r\n                         \"; problem token: \" + inputFile.getLastTokenUntyped());\r\n      System.out.println(\"Processed all earlier file entries\");\r\n      break;\r\n    }\r\n\r\n  inputFile.close();\r\n  System.out.println(count + \" values processed\");</b></pre>\r\n  Here, the exception thrown by failure to read the correct type of\r\n    information, <b>NumberFormatException</b> is caught; in this case, it\r\n    prints an error message, but then executes a <b>break</b> and continues\r\n    with the rest of the code following the loop (so only the earlier values\r\n    are correctly processed).\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Error Recovery  -->\r\n\r\n\r\n<a name=\"ErrorRecovery\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Error Recovery in Input Files</b></td>\r\n<td width =\"80%\">\r\n  We can go one step further and not only detect the error, but try to recover\r\n    from it.\r\n  Recovery means ignoring the bad line of input and continuing to process\r\n    those after it.\r\n  The following code implements this goal.\r\n<pre><b>  TypedBufferReader inputFile = new TypedBufferReader(\"Enter name of file \");\r\n  int count = 0;\r\n  for (;;)\r\n    try {\r\n      String  name    = inputFile.readString();\r\n      int     s1      = inputFile.readInt();\r\n      int     s2      = inputFile.readInt();\r\n      int     s3      = inputFile.readInt();\r\n      boolean printIt = inputFile.readBoolean();\r\n      count++;\r\n      if (printIt)\r\n        System.out.println(name + \" has average \" + (s1+s2+s3)/3); \r\n    } \r\n    catch (EOFException eofe) {break;}\r\n    catch (NumberFormatException nfe) {\r\n      System.out.println(\"  Error reading file \" + inputFile.getFileName() +\r\n                         \" on line \" + inputFile.getLineNumber() +\r\n                         \"; problem token: \" + inputFile.getLastTokenUntyped());\r\n      inputFile.ignoreRestOfLine();\r\n      System.out.println(\"  Ignoring this line\");\r\n    }\r\n\r\n  inputFile.close();\r\n  System.out.println(count + \" values processed\");</b></pre>\r\n  Here, the exception thrown by failure to read the correct type of information\r\n    is caught; in this case it prints an error message, but then does not\r\n     execute a <b>break</b>; instead it calls a method that skips the rest of\r\n     the information on the current line being read.\r\n  So, the <b>for</b> loop  does not terminate, but continues reading and\r\n    processing values from the next line: it terminates the loop only when the\r\n    <b>EOFException</b> is thrown.\r\n  <p>\r\n  This code, and one file to test it on (you can edit the file to create your\r\n    own tests) is available in \r\n    the <a href=\"../../programs/fileinput.zip\">File Input</a> project folder.\r\n  Note the declaration <b>import java.io.EOFException;</b>\r\n  Unlike most of the other exceptions that we have seen\r\n   (e.g., <b>NumberFormatException</b>, <b>IllegalArgumentException</b>,\r\n    <b>IllegalStateException</b>) this exception is not in the <b>java.lang</b>\r\n    package, from which classes are implicitly imported into every program.\r\n  So, we must use it a bit differently;\r\n  We could omit the import but write the exception handler as\r\n  <pre><b>  catch (java.io.EOFException eofe) {break;}</b></pre>\r\n  but this approach would soon lead to very verbose code; better to import\r\n    this class explicitly.\r\n  <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Buffering -->\r\n\r\n<a name=\"Buffering\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Buffering</b></td>\r\n<td width =\"80%\">\r\n  In this section we will explore how the term <b>buffer</b> applies to file\r\n    I/O.\r\n  Typically a file that we are reading or writing (big or small) is stored on\r\n    a hard disk.\r\n  As a memory device, a hard disk has two key properties\r\n  <ol>\r\n    <li>It takes a large amount of time to read/write a small amount of\r\n          information to a hard disk (when compared to accessing a \r\n          computer's memory).\r\n    <li>It takes only a bit more time to read/write a large amount of\r\n          information to a hard disk.\r\n  </ol>\r\n  That is, it takes an appreciable amount of time to find the place to get/put\r\n    the information on the disk, but it can quickly get/put lots of information\r\n     once this place has been found.\r\n  <p>\r\n  Let's examine the implications fo these properites when applied to output.\r\n  We often write small amounts of information into a file repeatedly.\r\n  If every time we write (even a small amount of) information to a file it\r\n     goes immediately to the  hard disk, the process will go quite slowly.\r\n  <p>\r\n  Instead we can use a buffer.\r\n  A buffer is a medium-sized block of memory that we use to collect output for\r\n     a file; a typical buffer can contain thousands of characters.\r\n  Then, instead of writing output directly into the file, it is more quickly\r\n     put into the memory buffer.\r\n  But typically not all the information going to the file can fit in such a\r\n    buffer (typically we use a buffer smaller than the ultimate file size).\r\n  When the buffer is full, the computer senses this fact and then writes all\r\n    the information currently in the buffer into the output file; now that the\r\n    buffer is empty, we can continue putting more information into it.\r\n  <p>\r\n  Using such a buffer minimizes the number of times information is written to\r\n    a file; each time information is written, a large amount is written\r\n    (which takes just a bit more time than writing a small amount; and\r\n     much less time than repeatedly writing a small amount).\r\n  Note also that such an output buffer might be partially filled when a\r\n    program terminates: in this case the information is lost: it never makes\r\n    it from the buffer to the output file.\r\n  But, if the program executres the <b>close</b> method on an output file, it\r\n    knows to force the remaining contents of the buffer to be written into the\r\n    otuput file (which is why it is important to close all output files).\r\n  <p>\r\n  Likewise, when an input file is read, a large part of it is transferred to\r\n    the memory buffer, where subsequent reading gets information, until all the\r\n    information in the buffer is read.\r\n  At this point, another large part of the file is transferred into the buffer\r\n    from the file, for the next batches of reads.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, a Tutor,\r\n    or any other student.\r\n  <ol>\r\n     <li>Draw the picture resulting from the following declarations.\r\n<pre><b>\r\n  String s1 = new String(\"ABC\");\r\n  String s2 = new String(\"XYZ\");\r\n  String s3 = new String(\"abc\");\r\n  String s4 = s1;\r\n  String s5 = new String(\"XYZ\");\r\n  s2 = new String(\"ABC\");\r\n</b></pre>\r\n      <li>Give the resulting picture from problem 1, determine the result of the\r\n            following tests:\r\n              <b>s1==s1</b>, \r\n              <b>s1==s2</b>, \r\n              <b>s1==s4</b>, \r\n              <b>s1.equals(s4)</b>, \r\n              <b>s1.equals(s2)</b>, \r\n              <b>s1.equals(s3)</b>, \r\n              <b>s1.equalsIgnoreCase(s3)</b>, \r\n              <b>s1==s5</b>, and\r\n              <b>s1.equals(s5)</b> \r\n\r\n      <p>\r\n      <li>Describe what it means for two objects to be identical, such that <b>==</b> (the\r\n           object identity operator) has a result of <b>true</b>.\r\n          Explain what value is produced by writing: <b>(new String(\"abc\")) == (new String(\"abc\"))</b>\r\n      <p>\r\n\r\n     <li>We defined an EBNF rule for access modifiers as\r\n     <p>\r\n       <i>access-modifiers</i> <= [public|private] [static] [final]\r\n     <p>\r\n     How many different access modifiers (combinations of these words) are legal?\r\n     <p>\r\n\r\n     <li>Write the result that each code fragment below prints. Drawing pictures is invaluable.\r\n<pre><b>  DiceEnsemble dice = new DiceEnsemble();\r\n  dice.roll();                                    //or dice.roll().roll();\r\n  dice.roll();\r\n  System.out.println(dice.getRollCount());\r\n\r\n\r\n  DiceEnsemble dice = new DiceEnsemble();\r\n  dice.roll();\r\n  dice = new DiceEnsemble();\r\n  dice.roll();\r\n  System.out.println(dice.getRollCount());\r\n\r\n\r\n  DiceEnsemble dice1 = new DiceEnsemble();\r\n  dice1.roll();\r\n  DiceEnsemble dice2 = dice1;\r\n  dice2.roll();\r\n  System.out.println(dice1.getRollCount());</b></pre>\r\n     <p>\r\n\r\n     <li>What is wrong with each of the following code fragments? Will the compiler detect\r\n           and report either error?\r\n<pre><b>  DiceEnsemble dice;\r\n  dice.roll();\r\n\r\n\r\n  DiceEnsemble dice = null;\r\n  dice.roll();</b></pre>\r\n    <p>\r\n\r\n    <li>\r\n    Browse the Javadoc for the <b>BigInteger</b> class.\r\n    Assume that we have declared <b>BigInteger x,y;</b>\r\n      and initialized these variables to refer to appropriate objects.\r\n      <ul>\r\n        <li>Examine the <b>abs</b> method in this class.\r\n            Assume <b>x</b> refers to a <b>BigInteger</b> with a negative\r\n              value.\r\n            If we write <b>x.abs()</b>, explain why <b>x</b> does not refer\r\n              to a <b>BigInteger</b> with a positive value.\r\n            Show how to accomplish this task.\r\n            <p>\r\n        <li>Examine the <b>min</b> method in this class.\r\n            Show how to write a declaration for a third <b>BigInteger</b>\r\n              named <b>z</b>, and how to initialize this variable to refer\r\n              to an object that is the bigger of <b>x</b> and <b>y</b>.\r\n            After <b>z</b> is initialized, does it share an object with\r\n              either <b>x</b> or <b>y</b>?\r\n            <p>\r\n        <li>Examine the <b>compareTo</b> method in this class.\r\n            Show how to write a <b>boolean</b> expression that evaluates to\r\n              <b>true</b> if <b>x<=y</b>.\r\n            Note that the relational operators do not work on any reference\r\n              types.\r\n      </ul>\r\n    <p>\r\n\r\n    <li>\r\n      Extend the file-reading code above so that after reading each name, it processes any number of scores \r\n        for that student (the list of scores is ended by a sentinel of -1).\r\n     This time, if any score is not an integer, just ignore it (don't increment the running count \r\n        or sum) but keep processing other scores.\r\n     You will need nested control structures.\r\n\r\n    <p>\r\n    <li>What does the following code print when it reads a file containing: <b>1 2 3 x x 4 5 6</b>?\r\n        Do this hand simulation carefully, paying close attention to the details of exception processing.\r\n<pre><b>  for (;;)\r\n    try {\r\n      int a = inputFile.readInt();\r\n      int b = inputFile.readInt();  \r\n      System.out.print(a + \"\" + b);\r\n    }catch (NumberFormatException nfe ) {System.out.print(\"B\");}\r\n     catch (EOFException          eofe) {System.out.print(\"E\"); break;}\r\n  System.out.println(\"D\");</b></pre>\r\n\r\n    <p>\r\n    <li>\r\n      Modify the error detection code so that it prints a special message if it discovers an end of file\r\n        while trying to read any data but the <b>String</b> information (meaning that the last set of values \r\n        in the input file is not complete).\r\n      <p>\r\n\r\n    <li>\r\n      Modify the error recovery code so that it will also terminate the loop (printing an appropriate\r\n        message), if more than ten <b>NumberFormatException</b>s occur.\r\n      <p>\r\n\r\n    <li>\r\n      Modify the error recovery code so that it will also terminate the loop (printing an appropriate\r\n        message), if more than ten <b>NumberFormatException</b>s occur <b>in a row</b>; this means ten\r\n        occur on ten consecutive lines in the file, without reading one line in the file correctly.\r\n      <p>\r\n<li>\r\nRead the Javadoc for the <b>Random</b> class (in the standard Java library)\r\n  and write a code fragment that prints 100 random numbers between <b>0</b>\r\n  and <b>10</b> inclusive.\r\n<p>\r\n<li>\r\nRead the Javadoc for the <b>ModularCounter</b> class (in the course Java\r\n  library) and rewrite the following code fragment (which we we have\r\n  studied before), declarations and all, which uses primitive types.\r\nDescribe why the just-written code fratment in simpler.\r\n<b><pre>  int minute; //in the range [0,59] inclusive\r\n  int hour;   //in the range [0..23] inclusive\r\n  ...\r\n  minute++;\r\n  if (minute == 60} {\r\n    minute = 0;\r\n    hour++;\r\n    emitBeeps(hour);\r\n    if (hour == 24)\r\n      hour = 0;\r\n    if (minute != 59)\r\n      minute++;\r\n  }</b></pre>\r\n<!---\r\n  ModularCounter minute = new ModularCounter(60);\r\n  ModularCounter hour   = new ModularCounter(24);\r\n  ...\r\n  minute.inc()\r\n  if (minute.getValue() == 0) {\r\n    emitBeeps(hour.getValue()+1);\r\n    hour.inc();\r\n  }\r\n--->\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n\r\n</body>\r\n</html>\r\n\r\n\r\n<!--\r\n  EBNF of call: arguments etc.\r\n ---> ", "encoding": "ascii"}