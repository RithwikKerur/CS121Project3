{"url": "https://www.ics.uci.edu/~jacobson/ics23/LabManual/02-BlackAndWhite.html", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n    \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<meta name=\"Generator\" content=\"Microsoft Word 97/98\">\n<title>Black and White - Assignment 2</title>\n<link rel=\"stylesheet\" href=\"../course.css\" type=\"text/css\">\n</head>\n\n<body>\n\n<div class=\"title\">\n<center>\n<h2>Black and White </h2>\n<h4>Assignment 2</h4>\n</center>\n</div>\n\n\n<div class=section>\n<hr>\n<h3>Introduction</h3>\n</div>\n<p>Othello is a well-known two-player strategy game.  For this project, you will develop portions of an intelligent program that plays Othello.  We&#146;ve provided you with a user interface and the game logic (code that implements the rules of the game) that will allow two human players to play the game.  You will write the search and strategy routines that will allow &#147;the computer&#148; to play the game.</p>\n\n<p>Othello &mdash;also known as Reversi &mdash;is played on a square board divided into an 8x8 grid.  The rules of the game, along with some good ideas for a sound strategy of play, are described in the <a href=\"http://en.wikipedia.org/wiki/Reversi\">Wikipedia entry on Reversi</a>&#151;do read it!</p>\n\n<p>Be sure you know how to play the game before attempting to complete this program; it will save you much time and effort. Since the provided program allows play with two human players, you can &#147;play against yourself&#148; to get some feel for the game&#146;s rules and strategy. The provided game will not allow you to play against a computer player until you create your AI class and write the necessary OthelloAIFactory class code (see below).</p>\n\n\n<div class=section>\n<hr>\n<h3>Starting Point</h3>\n</div>\n\n<p>All of the code that you&#146;ll need to complete the assignment is included in the zipped-up <a href=\"http://www.ics.uci.edu/~jacobson/ics23/LabManual/LabFiles/BlackAndWhite.zip\">BlackandWhile project folder</a>; download the file, unzip it, and add it to your workspace.  Much of the code is provided in compiled class files, in the <i>lib</i> folder.  The provided java source code (.java) files are heavily commented.</p>\n\n<p>To add this project to your 23 workspace, </p>\n<ol>\n<li>Move the BlackAndWhite folder into the folder containing your ICS 23 workspace.\n\n<li> Start up eclipse and select your workspace.\n\n<li> From the file menu, select <font class = \"codefacesmall\">Import...</font>, which will pop up a dialog box. under <font class = \"codefacesmall\">General</font>, select <font class = \"codefacesmall\">Existing projects into workspace</font>, then click <font class = \"codefacesmall\">Next ></font>.\n\n<li>Next to<font class = \"codefacesmall\"> Select root directory</font>, click the <font class = \"codefacesmall\">Browse</font> button. Find the BlackAndWhite folder that you copied into your workspace folder, select it, then click <font class = \"codefacesmall\">OK</font>.\n\n<li>Finally, click <font class = \"codefacesmall\">Finish</font>. You should now see a project called <font class = \"codefacesmall\">BlackAndWhite</font> in the Package Explorer. Your Problems window may show some warnings; each of these warnings indicates that there is a part of the program that has yet to be built. \n</ol>\n\n<p>You&#146;ll only need to work on two classes.  First, you need to create a new class that implements the OthelloAI interface.  Your class&#146; name <i>must begin with <font class = \"codefacesmall\">OthelloAI</font>, followed by your eight-digit student ID#</i>.  So, if your student ID# is 12345678, your class should be called <font class = \"codefacesmall\">OthelloAI12345678</font>. (if you are an Access student, use the id number Access provided you, with the &#147;X&#148; removed and as many leading zeroes as needed added to make the number 8 digits.)</p>\n\n<p>Second, you write one line of code in the <font class = \"codefacesmall\">OthelloAIFactory</font> class; see the class&#146; comments for details.</p>\n\n<p><i>Leave everything else as is. In particular, do not change the names of files, classes, interfaces or methods that we provide.</i></p>\n\n\n<div class=section>\n<hr>\n<h3>How to run the program</h3>\n</div>\n\n<p>The Othello class contains a <font class = \"codefacesmall\">main()</font> method, so to run the program, execute the Othello class. </p>\n\n<p> When you run Othello, a window will appear with a green area with the label <font class = \"codefacesmall\">click here to start game</font>.  Click the green area and you&#146;ll be asked to specify whether each player should be controlled by a human or the computer; for now, specify human for both, as you haven&#146;t implemented your AI yet.  Clicking on <font class = \"codefacesmall\">OK</font> starts the game.</p>\n\n<p>A human-controlled player makes a move by double-clicking an empty square on the grid.  Not all squares constitute valid moves; the mouse cursor will turn into a hand when a square is a valid one, much like when you hover over a link in your browser.  (Note that you have to place the cursor rather precisely in the square for the cursor to change, so move the mouse within the square a bit if you are in a square that you think is legal to use, but in which the cursor is not a hand.)  The computer simply moves when it is its turn.  The GUI animates the placing and flipping of tiles, so that you can see the moves in action.  Status messages display the score and remind you whose move it is.</p>\n\n<div class=section>\n<hr>\n<h3>Some necessary terminology</h3>\n</div>\n<p>You will be building a rudimentary <i>artificial intelligence</i> (AI) so that the computer can play a game of Othello against you (or against another instance of your artificial intelligence).  Your task for this project is fairly narrow, so you can disregard the vast majority of the code that we gave you, most of which implements either the GUI or the game logic.  In fact, most of the code has been provided in compiled form, rather than as source code, for this very reason.</p>\n\n<p>There are three main abstractions that you need to understand in order to write the code required for this project:</p>\n\n<ul>\n  <li><p>The contents of each grid cell are represented by the enumeration <font class = \"codefacesmall\">OthelloCell</font>, which has three possible values: <font class = \"codefacesmall\">OthelloCell.NONE</font> (for an empty cell), <font class = \"codefacesmall\">OthelloCell.BLACK</font> (for a cell containing a black tile) and <font class = \"codefacesmall\">OthelloCell.WHITE</font> (for a cell containing a white tile).  The cells&#146; locations are denoted by ordered pairs (<i>r</i>, <i>c</i>), where <i>r</i> is the row and <i>c</i> is the column.  As is customary with two-dimensional arrays in Java, the row numbers and column numbers begin at 0, so the range of possible locations is (0, 0) through (7, 7).</p></li>\n\n  <li><p>As your AI analyzes possibilities, it will be necessary for it to evaluate the current game situation.  Collectively, we call the description of the current situation a <i>game state</i> or, more tersely, a <i>state</i>.  A game state is comprised of the contents of each grid cell, the score of the game, a flag indicating whose turn it is, and a flag indicating whether the game has ended.</p></li>\n\n  <li><p>Since it&#146;s possible to have two AI&#146;s playing against each other, it makes sense to encapsulate the AI into a class, so that two objects of that class could be created and play against one another.  You implement your AI in a class that implements the OthelloAI interface, which consists of a method called <font class = \"codefacesmall\">chooseMove()</font> that analyzes all of the possible moves and picks the AI&#146;s next move.  Since a move is denoted by the square in which a new tile should be placed, <font class = \"codefacesmall\">chooseMove()</font> returns an object of type <font class = \"codefacesmall\">OthelloMove</font>, which contains a row number and column number.</p></li>\n</ul>\n\n\n<div class=section>\n<hr>\n<h3>Game trees</h3>\n</div>\n\n<p>You can think of the possible game states as being arranged, conceptually, in a kind of search tree called a <i>game tree</i>.  Each node of the tree contains a particular game state <i>g</i>.  Its children are the game states that can result from making each valid move from the state <i>g</i>.</p>\n\n<p>The root of the tree is the initial game state, the state of the Othello game before the first move is made.  The children of this initial state are all of the possible states that can arise from the black player (who moves first) making a valid opening move.  There are four such states, corresponding to the four possible moves that the black player is permitted to make at the opening.  (All other moves are illegal and, as such, are not to be considered.)</p>\n\n<p>Take a look at this partial Othello game tree:</p>\n\n<center><p class=\"center\"><img src=\"02-SearchTree.jpg\" /></p></center>\n\n<p>From the initial state, the root of the tree, there are four possibilities from which the black player can choose its initial move, so the root has four children.  From the first of these moves, the left-most child of the root,  there are three possible moves that the white player can make in response, so there are three children of this node. From each of these moves, other legal moves exist; they would appear as children of this node (these moves are not pictured). The tree continues to grow in this fashion, each new move producing more children. (Not surprisingly, the game tree can grow very large, very quickly.)</p>\n\nA game ends when there are no legal moves on the board, that is, we reach a <i>final state</i>; at this point, one player or the other has won the game. Since there are no legal moves on these boards, the nodes representing them will have no children; so, final states are leaves of the game tree.</p>\n\n\n<div class=section>\n<hr>\n<h3>Exhaustively searching all possibilities</h3>\n</div>\n\n<p>Each time a player chooses a move, s/he wants to pick the one that will lead to a winning game state.  Assuming you had the complete game tree at your disposal, you could determine your best move in three steps:</p>\n\n<ol>\n  <li>Choose the final state that gives you the best win. This is typically done by applying an <i>evaluation function</i> to each final game state.  This function typically returns a number, where higher numbers are considered better. So, choose the state with the highest value. </li>\n\n  <li>Determine the path from the current game state to the final state that you chose.</li>\n\n  <li>Make the move that takes you from the current game state down the path toward the chosen final state.</li>\n</ol>\n\n<p>Sadly, practical limitations make this easy-to-implement approach impossible.  First of all, the number of game states on each level of the tree grows exponentially as you work your way down the tree, since there are typically a large number of possible moves that can be taken from any particular game state.  There simply won&#146;t be enough memory to store the entire game tree.  (You can imagine that, if you build the game tree 20 levels deep, and there are four possible moves that can be made from any particular state, the number of nodes in the tree would be greater than 4<sup>20</sup>, which is a very large number indeed!)  Besides, even if there were enough memory available to store the tree, the processing time to create the entire game tree would be prohibitive.</p>\n\n<p>So we&#146;ll need to find a compromise, an approach that perhaps doesn&#146;t always find the best possible outcome, but that makes a good decision in a reasonable amount of time while using a reasonable amount of memory.</p>\n\n\n<div class=section>\n<hr>\n<h3>Heuristic search</h3>\n</div>\n\n<p>The study of artificial intelligence has much to say about good ways to search toward a goal when it&#146;s impractical to check all possible paths toward it.</p>\n\n<p>We can first make use of the following observation: Suppose black has made a move in the game, and white wants to figure out the best move to make, using the search tree approach we&#146;ve been discussing.  Then white need only concern her/himself with the subtree that has the current game state as its root.  Once a move is made, all the other moves that could have been made can be ignored, as it is now not possible to take those paths down the tree.  Thus, when analyzing the next move to make, we need only generate the part of the search tree that originates from the current game state.</p>\n\n<p>This approach reduces our storage needs significantly, and we don&#146;t waste time or memory processing parts of the tree that we can no longer reach.</p>\n\n<p>Even if we generate only the part of the tree that we need, that part will still be much too large to store until we&#146;re nearing the end of the game.  This is where a <i>heuristic search</i> comes into play.  In a heuristic search, we generate as much of the relevant subtree as is practical, using the resulting game states to guide us in selecting a move that we hope will be the best.</p>\n\n<p>There are several strategies that we could use.  At the heart our strategy is using an evaluation function to rate each particular game state in some way, so that we can decide which of a large number of game states is the best outcome for us.  A simple approach &mdash;though one that ignores some aspects of the game &mdash;is the following:</p>\n\n<p><i>eval(state) = number of tiles belonging to me &minus; number of tiles belonging to my opponent</i></p>\n\n<p>It&#146;s also important to note here that <i>you do not need to actually build a game tree in memory</i>.  Our algorithm will perform a sort of <i>depth-first search</i> on the game tree, meaning that we can use parameters in a recursive method (stored on the run-time stack) to perform the search, negating the need to actually build and store a game tree.  This will dramatically reduce the amount of memory needed to choose a move, since only one path in the tree will need to be stored on the run-time stack at any one time.</p>\n\n<p>Putting these ideas together, we can develop a search algorithm that will look for the move that leads to the game state that evaluates to the highest value.  That algorithm looks  like this:</p>\n\n<pre>\n\nint search(OthelloGameState s, int depth)\n{\n    if (depth == 0 or reached a final state)\n        return evaluation of s\n    else\n    {\n        if (it's my turn to move)\n        {\n            for each valid move that I can make from s\n            {\n                make that move on s yielding a state s'\n                search(s', depth - 1)\n            }\n            \n            return the <i>maximum</i> value returned from recursive search calls\n        }\n        else\n        {\n            for each valid move that my opponent can make from s\n            {\n                make that move on s yielding a state s'\n                search(s', depth - 1)\n            }\n            \n            return the <i>minimum</i> value returned from recursive search calls\n        }\n    }\n}\n</pre>\n\n<p>There are a few things we need to discuss about this algorithm.  First, notice that there are two cases of recursion: either it is the computer player&#146;s turn (who is currently making the decision) or its opponent&#146;s turn.  In each case, the algorithm is almost the same, except:</p>\n\n<ul>\n  <li>...when it is the computer player&#146;s turn, the <i>maximum</i> value is returned.  In other words, the computer player wants to make the best possible move it can.</li>\n\n  <li>...when it is the opponent&#146;s turn, the <i>minimum</i> value is returned.  This is because it is assumed that the opponent will also make the move that&#146;s in her/his best interest, and that move is in the computer&#146s <i>worst</i> interest.</li>\n</ul>\n\n<p>Either the black or the white player (or both!) might be a computer player.  So, when deciding whether it's &#147;my turn&#148; or &#147;my opponent&#146;s turn,&#148; you&#146;ll have to exercise some caution to ensure that you&#146;re making the right decision.</p>\n\n<p>Second, notice the <font class = \"codefacesmall\">depth</font> parameter, used to limit the depth of our search, to make sure that our search is of a manageable length.  Each time we recurse one level deeper, the depth is reduced by one, and we stop recursing when it reaches zero.</p>\n\n<p>Experiment to find a depth that can compute a move fairly quickly, but still gives the computer player the most &#147;look ahead&#148; feasible. (Hint: as the game progresses, the number of possible moves changes. At some point, the number of moves might become small enough that you can increase the search depth; you might also have to decrease the search depth if the number of moves increases. Adjusting the depth as the game progresses can make the computer much &#147;smarter&#148; without unduly delaying the game.)</li>\n\n<p>Third, observe that when one player makes a move, it isn&#146t necessarily the case that the other player will be making the next move; occasionally, in Othello, the same player gets to move twice in a row.  So, care must be taken in deciding whose turn it is.  The easiest way to deal with this problem is to remember that the current game state keeps track of whose turn it is, so query the game state when you need this information.</p>\n\n<p>Lastly, note that this algorithm returns the <i>evaluation</i> of the best move for state <i>s</i>, not the best state itself; nor does it return the evaluation for some other state reachable from <i>s</i> (for example, for one of the <i>s'</i> states). Calling <font class = \"codefacesmall\">search(<i>s</i>, 10)</font> for some state <i>s</i> asks the following question: \"Looking ten moves into the future, and assuming I and my opponent do the best we can do, how well will the state <i>s</i> turn out for me?\"  You&#146;ll need to exercise some care in actually implementing this algorithm so that <font class = \"codefacesmall\">chooseMove()</font> will be able to call <font class = \"codefacesmall\">search()</font> and use the result to help it choose the right move.</p>\n\n<p> Be sure to test your program for correct play and reasonable play; a good way to do so is to play against your own program (or have friends or classmates play against it) to see if it can be broken or beaten. Obviously, if playing breaks your program, you need to fix it. If people routinely beat the computer, consider fine-tuning your program&#146;s search depth until it does better. You may also wish to change the evaluation function or the game tree search algorithm, as discussed in Optional Work, below.</p>\n\n\n<div class=section>\n<hr>\n<h3>A Couple of Technical Points</h3>\n</div>\n\n<ul>\n<li><p> Your Othello<i>id</i> class must not write to <font class=\"codeFaceSmall\">System.out</font> or otherwise write to the console. Doing so would certainly confuse a game player, who is supposed to be interacting only with the Othello board. If you wish to use <font class=\"codeFaceSmall\">System.out</font> statements while debugging your work, that&#146;s fine, but be sure to comment them out (or remove them) before turning in your work.</p>\n\n<li><p>We don&#146;t require you to use additional classes to support your AI<i>id</i> class, but if you choose to do so, <i>make them inner classes</i>. This isolates those additional classes from the rest of the program, which, of course, has no need to &#147;see&#148; them.</p>\n</ul>\n\n\n<div class=section>\n<hr>\n<h3>Optional Work</h3>\n</div>\n\n<p> <i>Modify your evaluation function.</i> The core of your AI&mdash;what will set it apart from others&mdash;is the evaluation function it uses to decide how&#147;good&#148; each board configuration is. Our evaluation function may not always be&#151;may even never be&#151;the best to use: a move that puts more of your tiles on the board right now might set up the board so your opponent could later obtain a larger quantity of tiles than you did. Perhaps another move would have left the board so that your opponent would be in a worse position. So, modify your evaluation function, or write several that you can swap in and out of your program, and see how they do against a human and computer player, and against the evaluation function we gave above. (You might want to poke around the web looking for strategy guides or other information, taking into account, for example, that some squares on the Othello board are considered more important than others). Try playing against your own program to see if you can beat it. Write up what approaches you tried, your results and your conclusions, as comments in your Othello AI class. In particular, tell us which function worked best and why you believe it did.</p>\n\n<p><i>Write searches that use other heuristic techniques.</i> In addition to the heuristic search we used above, there are other approaches for heuristically searching a game tree. Try out one or more of them to see how well they perform relative to the depth-first search approach used above and when used against each other. (A simple way to do this is to modify your program so that, if both players are the computer, a different strategy is used by each one. Then, have the computer play itself several times and see what happens.) For instance, an approach called alpha-beta pruning, which is in essence a smarter depth-first search, is often a good technique to employ (and perhaps better than the one we have used here). If you do use one or more optional searches, include in your code all you wish us to see, along with your implementation of the min/max algorithm we provided above. Have a flag that determines which search is the one to use, and set it to the one you want to use in the tournament (see below).</p>\n\n<p> Again, write up your results and your conclusions as comments in your Othello AI class. Be sure to tell us which strategy worked best and why you think it did.</p>\n\n\n<div class=section>\n<hr>\n<h3>A Tournament</h3>\n</div>\n\n<p>After this project&#146;s due date has passed, we&#146;ll  gather all of your AIs together and run a tournament to determine who has the best one.  The rules we will use are as follows:</p>\n\n<ul>\n  <li>Each AI will play two games against each other AI, one as black and one as white.</li>\n  <li>The primary factor in determining the best AI is the total percentage of games won.  (Draws will count as 1/2 of a win and 1/2 of a loss.)  So, first and foremost, it&#146;s important to win games.</li>\n\n  <li>A secondary factor, to be used in the case of a tie, is the total number of tiles accumulated in all games.  This means that winning games big, as opposed to squeaking out close wins, is important if there&#146;s a tie.</li>\n\n  <li>Your AI will be given 5 seconds of CPU time to choose each of its moves. The computer used will at least as fast as the ones in lab.  Java has a few different library classes that can help you time how long it takes to make a move. Using the <font class=\"codefacesmall\">System.currentTimeMillis( )</font> method provides an easy way. It returns the current date and time, measured to the nearest millisecond, and reported as the number of elapsed milliseconds since midnight, January 1, 1970 (sometimes referred to as the &#147;Unix epoch,&#148; since this is how Unix-based systems have traditionally measured time). To measure how long a move takes, remember what time it is when you start the move:\n<br>\n<pre>\nlong startTime = System.currentTimeMillis();\n</pre>\n\n<p>As you evaluate that move, check the time again every so often:</p>\n\n<pre>\nlong endTime = System.currentTimeMillis();\n</pre>\n\nand subtract the startTime from the endTime.\nWhen the time approaches 5 seconds, terminate your evaluation, and make the move. </li>\n\n  <li>If your AI does not compile, takes too long to make a move, returns null, throws an exception, isn&#146;t named according to the naming convention, or violates any of the other rules laid out in the project write-up, it will be disqualified from the tournament.</li>\n</ul>\n\n<p>Where you rank in the tournament will have no bearing on your grade, but we hope it will help motivate you to make the best evaluation function you can.</p>\n\n<p>Good luck!</p>\n\n<div class=section>\n<hr>\n<h3>Deliverables</h3>\n</div>\n\n<p>Turn in only your the file containing your AI class, (which will include any additional inner classes you created, if any); for example, turn in the file labeled <font class = \"codefacesmall\">OthelloAI12345678.java</font> if your UCI ID is 12345678.  Do not turn in any of the other files provided to you. <i>Do not ZIP up or otherwise archive these files.</i></p>\n\n<div class=history>\n<hr>\n\nOriginally written by Alex Thornton, Fall 2007, with portions taken from <i>End of the Game</i> \n<br>&nbsp;&nbsp;by Alex Thornton and Norman Jacobson\n<br>Revised for ICS 23 Winter 2008 by Norman Jacobson, December 2007, with portions\n<br>&nbsp;&nbsp;(sometimes revised) from the January 2007 version of <i>End of the Game</i> \n<br>&nbsp;&nbsp;by Alex Thornton and Norman Jacobson\n<br>Minor revisions for clarity, by Norman Jacobson, December 2007 and January 2009\n<br>Minor revision to clarify that files turned are not to be ZIPped, by Norman Jacobson, February 2009\n<br>Minor revisions for clarity, and to fix a few typos, by Norman Jacobson, March 2009, May 2009 & March 2010\n<br>Revised to reflect use of Eclipse, by Norman Jacobson, March 2010\n<br>Made explicit that all searaches used (e.g., depth first serach and minmax) are to be left in the code, by Norman Jacobson, April 2010\n<br>Minor edits, by Norman Jacobson, March 2011\n<br>Revised to discuss how to measure elapsed time of a move, and to clean up a few passages, by Norman Jacobson, April and May 2011\n\n</body>\n</html>\n\n", "encoding": "ascii"}