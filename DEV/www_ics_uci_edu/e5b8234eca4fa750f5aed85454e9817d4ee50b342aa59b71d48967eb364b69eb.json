{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/testingfunctions/testingfunctions.txt", "content": "\t\t\t\tTesting Functions\r\n\r\nWriting functions is one of the most common activity for programmers, whether\r\nthey are writing functions for use in a specific script or writing functions\r\nin a library module (to be imported by many possible of scripts). In this\r\nlecture we will discuss a variety of ways to quickly test the functions we are\r\nwriting. In the process, we will write some functions to help us test other\r\nfunctions, and we will learn about the eval and exec functions that are defined\r\nin Python's builtins module and automatically imported into any modules that we\r\nwrite.\r\n\r\nWe will discuss, briefly, six ways of testing\r\n\r\n(1) Testing within a script module\r\n(2) Testing within a library module\r\n(3) Testing libraries with a driver script (the exec function)\r\n(4) Batch testing with files\r\n(5) Self checking\r\n(6) Self checking/batch testing with files\r\n\r\n------------------------------------------------------------------------------\r\n\r\n(1) Testing within a script\r\n\r\nWhen writing functions in a script, we can always write test code beneath them,\r\nthat calls the functions and prints their returned results. When we run the\r\nscript, first the functions are defined (those are just the earlier statements\r\nin the script that Python executes, just like any other statement), and then it\r\nwill continue executing the statements at the bottom, which call the functions\r\nto test them.\r\n\r\nWhile we can write complicated test code that prompts for the values to test,\r\noften it is easier to just call the functions with the values we want to test,\r\nand later edit the test code and rerun the script to test different values.\r\nEventually the tests will be replaced by other code in the script that actually\r\ncalls the functions to help solve the problem the scripts is solving. \r\n\r\nFor example if a script defines the number_match function, we can write a print\r\nstatement that tests it.\r\n\r\ndef number_match(number,singular,plural):\r\n    return singular if number == 1 else plural\r\n\r\nprint( number_match(1,'goose','geese'))\r\n\r\nIf we run the script and it prints the correct result,we can change the print to\r\n\r\nprint( number_match(2,'goose','geese'))\r\n\r\nand rerun the script to test this function on a different argument. Of course\r\nwe can write code like this to test the function on a variety of values (which\r\nis a bit of overkill for the number_match function)\r\n\r\nfor i in irange(0,10):\r\n    print(i, number_match(i,'goose',geese')\r\n\r\nWhen we are done testing a function, we can leave the test code in the script,\r\nbut comment it out so the script won't execute it. This allows us to uncomment\r\nthe code to retest the function if we change it, or think of a better way to\r\ntest it.\r\n\r\nAnother way to test is with assert statements. If we added the following\r\ncode to the bottom of a script\r\n\r\nassert number_match(1,'goose','geese') == 'goose'\r\nassert number_match(2,'goose','geese') == 'geese'\r\n\r\nthen if the code was correct it would not raise any AssertionError exceptions,\r\nbut it is was wrong the first failed assertion (whose boolean value was False)\r\nwould raise an AssertionError.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n(2) Testing within a library module\r\n\r\nWhen we write functions in a library module, we expect other modules to use\r\nthese functions by importing them from their module. So typically a library\r\nmodule should only define functions, and not include code that calls them.\r\nHere think of the math or prompt modules, which we import functions from. Of\r\ncourse, we can use a strategy similar to what we did for functions in script\r\nmodules, to test library functions as well (running their modules like scripts)\r\nbut in addition we can do something else.\r\n\r\nWhen Python runs a module as a script, it binds the special name __name__ to\r\nthe string '__main__'. All Python programs require running one script to get\r\nstarted. If a module is imported by a script or another module, its __name__\r\nis bound to the name of the module. Here is a simple example\r\n\r\nAssume the library.py module's block is\r\n\r\n  print('in library.py:',__name__)\r\n\r\n\r\nAssume the script.py module's block is\r\n\r\n  import library\r\n  print('in script.py:',__name__)\r\n\r\n\r\nIf we execute the library.py module as a script, it prints\r\n\r\n  library.py: __main__\r\n\r\nIf we execute script.py module as a script it prints\r\n\r\n  library.py: library\r\n  script.py: __main__\r\n\r\nWhy does it print this? Because the script.py module first imports library,\r\nwhich executes all the code in the library.py module; but when the code is\r\nexecuted __name__ is bound to just 'library' since it is not the script that\r\nis being run. Then the print in the script.py module is executed; since this is\r\nthe script we executed, its __name__ is bound to '__main__'.\r\n\r\nPython programmers use this mechanism to put testing code in their library\r\nmodules.  Then, if the library module is run as a script, the testing code is\r\nexecuted; but if the library module is just imported from some other module, the\r\ntesting code is not executed. Here is what such code looks like. Suppose the\r\nlibrary.py module is written as follows\r\n\r\ndef number_match(number,singular,plural):\r\n    return singular if number == 1 else plural\r\n\r\nif __name__ == '__main__':\r\n    for i in irange(0,10):\r\n        print(i, number_match(i,'goose',geese')\r\n    ....\r\n\r\nWhen this module is executed as a script, the number_match function is defined\r\nand then the if statement is executed. In this case the test is True so the\r\ntesting code inside the if's block is executed.\r\n\r\nWhen this module is imported by another module, the number_match function is\r\ndefined and then the if statement is executed. In this case the test is False\r\n(the imported module doesn't bind __name__ to '__main__') so the testing code\r\ninside the if's block is skipped.\r\n\r\nSo, with this mechanism, we can keep testing code \"live\" in a library module\r\n(not comment it out), but it will be executed only if we are running the\r\nlibrary module as a script, not if we import the library module.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n(3) Testing libraries with a driver script (the exec function)\r\n\r\nA driver script exists just to \"test drive\" other code. It acts as a mini-\r\ninterpreter for Python. Driver scripts are very simple to write, if we know\r\nabout Python's exec function. Its prototype is exec(command : str) -> NoneType,\r\nwhich means its parameter is a string that represents a Python command; it\r\nalways returns the value None (the only value in the NoneType; the print\r\nfunction also always return None). So typically when we exec some string it is\r\nto define some name or print some results. So, instead of writing\r\n\r\nx = 1\r\nprint(x)\r\n\r\nin a script, we could write the following and the result would be the same.\r\n\r\nexec('x = 1')\r\nexec('print(x)')\r\n\r\nBut this would be insane, because we can execute these commands more easily\r\nwithout calling the exec function. But what if we wanted to prompt the user to\r\nenter a command to execute in the middle of the script? That is, when we run\r\nthe script we don't know what command will actually be entered and executed.\r\nHere is one way to execute the user-entered command.\r\n\r\nexec(prompt.for_string('Command'))\r\n\r\nEven more interesting would be to put a statement like this into a loop, which\r\nrepeatedly prompts the user and executes his/her commands. But first, import\r\nall the names from module-to-test; this is the first reasonable use we have\r\nfound for this form of importing.\r\n\r\nfrom module-to-test import *              # * means import all names\r\nwhile True:\r\n    exec(prompt.for_string('Command'))\r\n\r\nBut if the command raised an exception, then the loop (and the whole script\r\nwould terminate). So instead, we can put the call to exec in a try/except\r\nstatement in a loop.\r\n\r\nfrom module-to-test import *\r\nimport traceback\r\nwhile True:\r\n    try:\r\n        exec(prompt.for_string('Command'))\r\n    except:\r\n        traceback.print_exc()\r\n\r\nHere, any exception raised calls traceback.print_exc() -from the imported\r\ntraceback module- which will print the exception on the console (just as Python\r\ndoes). After handling this exception, the while loop re-executes the try/except\r\nstatement, prompting the user for another command to execute and executing it.\r\nSo even if your testing command raises an exception, it is handled and still\r\nkeeps test.\r\n\r\nTry executing the following script\r\n\r\nimport prompt\r\nfrom math import sqrt\r\nimport traceback\r\nwhile True:\r\n    try:\r\n        exec(prompt.for_string('Command'))\r\n    except:\r\n        traceback.print_exc()\r\n\r\nWhen prompted first enter print(sqrt(2)) and then print(sqrt(-2)). Notice\r\nafter printing the raised exception for sqrt(-2) the 'Command: ' prompt\r\nappears again. Dometimes Python will show this prompt in the middle of the\r\nexception because it is doing 2 things at once (printing the exception\r\ninformation and reprompting: don't worry about this behavior).\r\n\r\nYou must terminate this program manually (press the red square in the console)\r\nbecause it is an infinite loop.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n(4) Batch testing with files\r\n\r\nOne problem with testing is that often we want to test a function using a bunch\r\nof different arguments, and then if we find a mistake, and correct the function,\r\nwe want to retest it on the same bunch of arguments. If we have to do this\r\nmanually, it can be very tedious and prone to error. But, with what we have\r\nlearned about reading files, and what we just learned about the exec command,\r\nwe can define a small function that automates the process. We assume that we\r\nhave written a file with all the tests we want to perform: each test must be\r\non its own line. It might look like\r\n\r\nprint(number_match(0,'goose','geese'))\r\nprint(number_match(1,'goose','geese'))\r\nprint(number_match(2,'goose','geese'))\r\n\r\nNow, here is a function that reads commands from a file, one line at a time,\r\nand prints each command and the results of executing that command.\r\n\r\ndef batch_test(file_name):\r\n    print('Starting batch_test')\r\n    for command in open(file_name):\r\n        try:\r\n            command = command.rstrip()\r\n            print('\\nCommand:',command)\r\n            exec(command)\r\n        except:\r\n            traceback.print_exc()\r\n    print('\\nDone batch_test')\r\n\r\nThis function prints an opening and closing message. Then it uses a for loop\r\nto iterate through every line in the file. It rebinds command to refer to the\r\ncommand string with the whitespace ('\\n') stipped off the right end, and then\r\nprints the command and execs the command. As in the previous section, we use a\r\ntry/except statement to handle any exceptions (printing them) but continuing\r\npast them to process all the command lines in the file.\r\n\r\nWe can augment the standard batch_test function by adding a confirm parameter,\r\nwhose default argument is False (in which case this function acts exactly like\r\nthe batch_test above). But, if confirm is True, after Python prints the command\r\n(but before execing it), it prompts the user for a confirmation (just pressing\r\nthe enter key) and waits for the user to do so before execing the command. Here\r\nis that function.\r\n\r\ndef batch_test(file_name,confirm=False):\r\n    print('Starting batch_test')\r\n    for command in open(file_name,'r'):\r\n        try:\r\n            command = command.rstrip()\r\n            print('\\nCommand:',command)\r\n            if confirm:\r\n                prompt.for_string('Press enter to do command','')\r\n            exec(command)\r\n        except Exception:\r\n            traceback.print_exc()\r\n    print('\\nDone batch_test')\r\n\r\nIf we defined this function in the same script that includes a driver (see the\r\nprevious section), we can enter normal commands in the driver, and also enter a\r\ncommand to call the batch_test function.\r\n\r\nIn the lecture on testing/debugging we discussed regression testing, whereby a\r\na modified function is retested on a series of test cases. This is exactly what\r\nbatch_test allows, although we must careully put together a file of test cases\r\nbefor running batch_test.\r\n\r\nSee the driverbatch project that goes with this lecture. It defines the\r\nnumber_match function in library.py; it includes the batch_test function and\r\ndriver loop in the file driverbatch.py, which is a script you can execute;\r\nfinally, it includes the driverbatch.txt file which contains commands used to\r\ntest number_match. When run, duplicate the following interaction.\r\n\r\n  Command: print(number_match(1,'goose','geese'))\r\n  goose\r\n  Command: batch_test('driverbatch.txt')\r\n  Starting batch_test\r\n\r\n  Command: print(number_match(0,'goose','geese'))\r\n  geese\r\n\r\n  Command: print(number_match(1,'goose','geese'))\r\n  goose\r\n\r\n  Command: print(number_match(2,'goose','geese'))\r\n  geese\r\n\r\n  Done batch_test\r\n  Command: \r\n\r\nThe first command (print) is entered manually. Then by calling batch_test\r\nit executes the 3 commands from the driverbatch.txt file.\r\n\r\nFinally press the red square in the Console tab to terminate the driver.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe following material (5-6) is a bit advanced. You are not responsible for it,\r\nbut I include it here for those students who are interested.\r\n\r\n(5) Self checking\r\n\r\nIn all the previous sections, we have printed results on the cosole and  then\r\neyeballed these results to see (literally) if they were correct. This isn't a\r\nterrible burden if we are entering a few commands, one-by-one, but if we are\r\ndoing batch testing, performing many automatic checks, eyeballing for\r\ncorrectness can be lengthy and error-prone. The idea of self checking is that\r\nwe provide not only the function call to check, but also the value it should\r\nproduce: then Python automatically check the result for us.\r\n\r\nIn this section we will examine the fundamentals of self checking for\r\nuser-entered commands; in the next (and last) section we will examine options\r\nfor self-checking batch files.\r\n\r\nWe can define a simple check function as follows\r\n\r\ndef check(computed,correct):\r\n    if computed == correct:\r\n        print('correct')\r\n    else:\r\n        print('incorrect')\r\n\r\nAs we saw in the section on testing a library module, after checking whether\r\n__name__ == '__main__' we execute a bunch of tests. But we have to look at the\r\ntests and then the output to see if they are correct. Instead we might write\r\n\r\nif __name__ == '__main__':\r\n    check(number_match(0,'goose','geese'),'geese')\r\n    check(number_match(1,'goose','geese'),'goose')\r\n    check(number_match(2,'goose','geese'),'geese')\r\n\r\nNow, if we run this library module as a script it will print only correct or\r\nincorrect, so it is easier to look at the output. But still, if we see an\r\nincorrect, we have to trace down which function call caused the problem. So,\r\nlet's rewrite the check function in a way that we can avoid this problem. To do\r\nso we will use the eval function, which is similar to exec: both take string\r\narguments, but while exec is for statements (and always returns None) eval is\r\nfor expressions and returns the value computed by the expression, which can be\r\nany object. So we specify its prototype as eval(str) -> object.\r\n\r\nWhile we are generalizing check, let's also make it silenty if the check passes,\r\nand print something only if the check fails. So we redefine check as\r\n\r\ndef check(to_compute,correct):\r\n    try:\r\n        computed = eval(to_compute)\r\n        if computed != correct:\r\n            print('Error:', to_compute,'->',computed,'but should be',correct)\r\n    except:\r\n        print('Error:', to_compute,'raised exception')\r\n\r\nNotice that we are now passing a string argument that is bound to to_compute,\r\nwhich calls eval on the string inside this function to compute its answer. If\r\nthe answer is wrong (or raises an exception) then information about the error\r\nis printed, otherwise nothing is printed. We could rewrite these tests as:\r\n\r\nif __name__ == '__main__':\r\n    check( \"number_match(0,'goose','geese')\" , 'geese')\r\n    check( \"number_match(1,'goose','geese')\" , 'goose')\r\n    check( \"number_match(2,'goose','geese')\" , 'geese')\r\n\r\nNow, if the function passes all the tests, nothing is printed; for every test\r\nit fails the expression, its value, and the correct value are all printed.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n(6) Self checking/batch testing with files\r\n\r\nWe finish this lecture by combining what we know about self-checking and batch\r\ntesting. This uses new Python features, but with a short discussion we can all\r\nunderstand their basic operation (even if we do not really understand well how\r\nto use them). The line\r\n\r\n  expression,correct = line.rstrip().split('-->')\r\n\r\nbinds expression to the string in line.rstrip() before the characters '->' and\r\nbinds correct to the string in line.rstrip() after the characters '->'.\r\nSo, if a file contains the line\r\n\r\nnumber_match(1,'goose','geese')-->goose\r\n\r\nThen expression binds to the string number_match(1,'goose','geese') and\r\ncorrect binds to the string goose. Now, as with batch testing we can read lines\r\nto test from a file, but these lines contain the correct answers, which the\r\nbatch_self_test function can check. As in the previous section, it will print\r\ninformation only if a test fails; it will also count the numnber of tests that\r\nsucceed and fail, and print this number at the end of the method.\r\n\r\ndef batch_self_check(file_name,seperator='-->'):\r\n    print('Starting batch_self_check')\r\n    correct_count, wrong_count = 0, 0\r\n    for line in open(file_name):\r\n        try:\r\n            expression,correct = line.rstrip().split(seperator)\r\n            computed = str(eval(expression))\r\n            if computed == correct:\r\n                correct_count += 1\r\n            else:\r\n                wrong_count += 1\r\n                print('Error:',expression,'->',computed,'but should be',correct)\r\n        except Exception:\r\n            print('Error:',expression,'raised exception')\r\n            traceback.print_exc()\r\n    print('Done batch_self_check:',correct_count,'correct;',wrong_count,'incorrect')\r\n\r\nThere are very many more sophisticated (and harder to understand) tools for\r\ntesting software, because programmers often make mistakes and do not catch them,\r\nand malfunctioning software can kill people (or wreck economies...). In this\r\nlecture we have discussed six different ways to test functions, each approach\r\nmore sophisticated than the ones preceeding it, but often building upon the\r\nearlier approaches.\r\n", "encoding": "ascii"}