{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/functions/functions.txt", "content": "\t\t\tDefining Functions in Modules\r\n\r\nIn the scripts we have written, we have already used many functions imported\r\nfrom various modules (at least builtins, prompt, predicate, math, goody, and\r\nrandom: can you name a function used from each of these modules)? We have also\r\nseen some functions in the lectures, although not really examined their details.\r\nFor example, in many of the lectures on control structures, we used functions\r\nto capture the computation of a full script. In this lecture we will explore\r\nhow to write functions in our own scripts, and write functions in modues that\r\nwe can use as libraries by importing into our scripts. But first, we will learn\r\ntwo simple statements, return and raise, and very importantly, review Python's\r\nrules for binding arguments to parameters.\r\n\r\nWe start by defininig the EBNF for Python's return statement, which is the only\r\nnew statement that we must know to write functions (although we will also cover\r\nthe raise statement later in this lecture, to show how code -typically\r\nfunctions- can raise exceptions.\r\n\r\n  return_statement <= return expression\r\n\r\nNote that return is a Python keyword. Just as a break statement can be used only\r\ninside the body (block) that a loop repeats, a return statement can be used only\r\ninside the body (block) that defines a function. We will see return statements\r\nwith  simple and complicated expressions, illustrated below.\r\n\r\n  return True  \t                      # return a literal  (it is an expression)\r\n  return a  \t                      # return a name     (it is an expression)\r\n  return sqrt((x1-x2)**2 + (y1-y2)**2)# return a \"real\" expression w. operators\r\n\r\nSemantically, whenever Python executes a return statement (always in the body\r\nof a function) it first evaluates the expression (which results in some object)\r\nand the function terminates returning that object as the result of the function.\r\nOnce a function executes return, it executes no more statements, no matter\r\nwhere it is executing (in a loop, in a try/catch, etc.) So when a return\r\nstatement is executed, that is it: the function terminates (although technically\r\nif it is in a block-try in a try/catch, which has an else:/finally: clause, the\r\nblock-else/block-finally is executed right before the function terminates).\r\n\r\nMore advanced functions frequently bind an answer to name that might be updated\r\nmany times in the function, and finally return that result; but literals and\r\nexpressions using operators (and even calling other function calls) frequently\r\nappear in return statements.\r\n\r\nBefore we review the EBNF for function headers, parameters, function calls, and\r\narguments formally, we will examine and discuss a simple concrete function\r\nexample and discuss these terms more informally (but quite extensively). First,\r\nbelow is the EBNF for a function-defintion, which is also a Python statement\r\n(maybe we should call it a function-definition-statement, but that is mouthful).\r\n\r\nfunction-definition <= def function-header:\r\n                           block\r\n\r\nWhen Python executes a function definition, it binds the name of the function\r\n(in the function header) to a function object. We can call/execute the function\r\nobject later by referring to it by using its name, followed by parentheses that\r\nindicate \"call the function\". The parentheses contain all the arguments needed \r\nto match the parameters. We discuss this process in more detail below.\r\n\r\nThe EBNF combines the keyword def, with a function-header (typically just the\r\nname of the function followed by the names of its parameters in parentheses),\r\nfollowed by a colon: and of course, what always follows a colon in the EBNF we\r\nhave seen for control structures, is a block (which here is called the body of\r\nthe function: a mini-script Python executes when we call the function), which\r\ncan contain any number of return statements. As with break statements, we want\r\nto limit the number of return statements in a function body, but we will not\r\nbe as restrictive with return statements: even the first example we show will\r\nhave two return statements: when either one executes, the function returns its\r\nexpression.\r\n\r\nSo let's explore that that first example. It is often useful to be able to\r\ncompute the minimum of two float values. We have seen how to do this using an\r\nif statement, so we will now write the min function, containing this simple\r\ncontrol structure along with two returns: one in each block.\r\n\r\ndef min(x : float, y : float) -> float:\r\n    if x <= y:\r\n        return x\r\n    else:\r\n        return y\r\n\r\nIn this example we have chosen to specify annotations in the function header;\r\nwe use\r\n   x : float, y: float\r\nto specify that this function has two parameters; the parameter x should refer\r\nto a float value object and the parameter y should refer to a float value\r\nobject. Also, we use\r\n  -> float\r\nto specify that this function will return a reference to a float value object.\r\n\r\nThese annotations are NOT CHECKED by Python (much more on this topic later in\r\nICS-31 and throughout the entire 30s sequence). Annotations are, like comments,\r\nfor our benefit only. To Python the following function definition, without\r\nannotations, has exactly the same meaning\r\n\r\ndef min(x,y):\r\n    if x <= y:\r\n        return x\r\n    else:\r\n        return y\r\n\r\nWe will soon learn that this definition might even be better suited to this\r\nfunction, because min works correctly on types other than float. But for now \r\nlet's assume we use this function only to compute the minimum of two float\r\nvalues.\r\n\r\nPlease note that like most functions, this function's body does not prompt\r\nthe user for information, nor does it print anything. It gets its \"input\" via\r\nits parameters, and does its \"output\" by returning a value. We might use this\r\nfunction definition, by calling the function to solve the following task.\r\n\r\n  We buy an item at a special sale, where for the ultimate cost, we pay either\r\n  90% of its price or is its price minus $5, whichever is cheaper.\r\n\r\nHere is a script that prompts the user for the price and prints the cost we\r\nmust pay, by calling the min function (which would occur earlier in the script).\r\n\r\nprice = prompt.for_float('Enter price of item as dollars.cents')\r\ncost  = min(.90*price, price-5.00)\r\nprint('The sale cost of this item is',cost)\r\n\r\nIn the second line of code, we call the min function and bind the result it\r\nreturns to the name cost. We call a function by writing its name, followed in\r\nparentheses (whenever we use parentheses, it means a function call) by its\r\narguments (typically one for each parameter in the function's header, although\r\nwe will discuss default parameter values soon).\r\n\r\nThe function header has all its parameter names separated by commas; likewise,\r\nthe function call has all its argument values separated by commas.\r\n\r\nSemantically when we call a function, Python first evaluates each argument (each\r\ncan be a simple or complicated expression) and transmits or passes a reference\r\nto each resulting object to its matching parameter name; this just means that\r\nPython uses the value of each argument, in the function call, to initialize its\r\nmatching parameter name, in the function definition. It is equivalent to writing\r\na sequence of assignment statements: first-parameter = first-argument, then\r\nsecond-parameter = second-argument, etc. So in this example calling min, it is\r\nlike writing x = .90*price and y = price-5.00.\r\n\r\nOnce the parameter names are bound to their matching argument values, Python\r\nexecutes statements in the body (block) of the function until it executes a\r\nreturn statement telling it what value the function returns. If Python executes\r\nthe last statement in a function (there are no more to execute) without\r\nexecuting a return statement, Python automatically executes the equivalent of\r\nreturn None.\r\n\r\nIf None starts showing up in your computations, look for a function call that\r\nreturned None, because the function called is mistakenly missing a return\r\nstatement in its body. Of course, some functions do return None on purpose, as\r\nthe print function does. It is called for its effect -to display information in\r\nthe console- not to compute/return an interesting value.\r\n\r\nSo, here is an example of the script running. In some sense we are back to\r\nwriting code as in Program #1, although now we will explore how the function\r\nwe wrote works in detail.\r\n\r\n  Enter price of item: 100.\r\n  The sale cost of this item is 90.0\r\n\r\nIn this run, the user enters the float value 100.00. Python executes the\r\nfunction call by \r\n\r\n  (1) ...computing the value of the first argument as 90.0 and the value of the\r\n      second argument as 95.0\r\n\r\n  (2) ...binding the parameter named x to the value object 90.0 and the\r\n       parameter named y to the value object 95.0\r\n\r\n  (3) ...executing the body of the function. The if's test is true: x <= y\r\n      (90.0 <= 95.0) so it executes the return statement, which terminates the\r\n       function and returns the object x refers to, 90.0\r\n\r\nWhen the function call terminates, its parameters (and any names defined\r\nin the function's body (block) disappear. Whenever the function is called\r\nagain, it starts over with all new bindings for the parameters and any local\r\nnames used in the function (we'll see a few functions with local names soon).\r\n\r\nEvery function call executes similarly, using these three same steps, although\r\nstep (3) can execute more complicated function bodies with more complicated\r\nstatements.\r\n\r\nThe idea of calling a function to get a result is analogous to calling someone\r\nto get an answer to a question (e.g., what is the value of...). We tell them\r\nthe relevant information (pass them arguments) and then wait until they deliver\r\ntheir answer. We don't need to worry about HOW they determine the answer, it is\r\nenough to know how to call them and what information they need to determine the\r\nanswer.\r\n\r\n------------------------------\r\n\r\nDebugger Interlude\r\n\r\nCopy/paste the min function definition and three lines of code into an Eclipse\r\nscrpt and run the script to ensure it produces the correct result. Remember to\r\ninclude import prompt at the top. You will note that the definition of min is\r\nflagged with a warning that reads:\r\n\r\n  \"Assignment to reserved built-in symbol: min\".\r\n\r\nThis is bacause the name min is automatically imported from the builtins module\r\n(and yes, it is a function that computes the minimum of its arguments). We have\r\nrebound the name min to refer to the function object that we specified, and\r\nthis is OK, although rebinding other functions (like print, which is also\r\nautomatically imported from builtins) can cause Python execute our scripts in\r\nvery strange ways.\r\n\r\nNow switch to the Debugger Perspective and run this script again. First set a\r\nbreakpoint on the first line after the function definition (the line in the\r\nscript calling prompt.for_float), and the use the step-over button (the arrow\r\ngoing over an little block) to execute the three lines.  \r\n\r\n  After stepping over the second line, look at the namess window. After some\r\n  special double-underscore names, we will see cost, min, price, and prompt:\r\n  the four names defined in this script. Notice how the cost and price values\r\n  display, as expected; notice how the min and prompt values display, as a\r\n  special function object <function ...> and a special module object\r\n  <module ...> respectively.\r\n\r\nNow debug the program again. But this time when the debugger indicates it is\r\nabout to execute the second line, using the step-into button (the arrow going\r\nbetween two little blocks). Note that the focus (the highlighted line that\r\nPython indicates it will execute next) shifts to the first line of the min\r\nfunction: the if statement. So instead of stepping over the line of code that\r\ncalled the  function (and executing all its code, including the entire function\r\ncall) we step into the function, to watch it execute in detail.\r\n\r\n  Again, look at the Variables tab/window. The debugger has shifted focus to the\r\n  function and shows its parameter names (x and y) and their bindings (the\r\n  values 90.0 and 95.0 if you entered the values I did above). So, the function\r\n  has been called and the arguments have been transmitted/passed to their\r\n  parameters, but it has not executed the function's body yet.\r\n\r\n  Now look at the Debug tab and look under \"Main Thread\". The first indented\r\n  entry on my computer shows \"min [functions.py:4]\" indicating that Python is\r\n  currently executing the min function on line 4 of the script (that is the line\r\n  the min's if statement appears on, when I cut/pasted the code into a script).\r\n  I put this script into a module named \"functions\", so the line beneath this\r\n  one says \"<module> [functions.py:10]\". If we click that entry, the debugger\r\n  shifts its focus to the line in the script where this function is called (in\r\n  my script on line 10): it is highlighted, and the Variable tab/window again\r\n  shows the name in the module. Click \"min [functions.py:4]\" again and the focus\r\n  shifts back to the min function: its statement and variables.\r\n\r\nSo, in this way we can carefully examine the execution of a function (if we\r\nwant) and flip back and forth between the body of a function and the statement\r\nin the module that called it: in the former we can see the parameters, in the\r\nlater the arguments.\r\n\r\nUsing the step-over button (there are no function calls in min, so technically\r\nwe can use either step- button) watch how it executes the if, then executes the\r\nreturn statement in the if's first block. When we step-over the return statement\r\n\r\n  (1) \"min [functions.py:4]\" disappears from under Main Thread in the Debug tab\r\n\r\n  (2) Focus returns to the statement calling min, and the Variables tab is\r\n      updated \r\n\r\nThe function is done and we are back to the statement in our program that called\r\nthe min function.\r\n\r\nSo, we have now learned what we can control how we use the debugger to execute\r\nfunctions in our scripts: step-over executes the entire function without\r\nshowing us any details; step-into treats the function like a mini-scipt that we\r\ncan step through just like any script (once the parameters are bound to their\r\nmatching arguments). This gives us a coarse-grained or fine-grained control of\r\nour functions when we step through them. In fact, we can step into any function\r\nthat we write or import.\r\n\r\nIf we are finished stepping inside a function, and we want to return to the\r\nstatement that called the function, we can easily do so by using the step-return\r\nbutton (the arrow going out from between two little blocks). Rerun the debugger\r\nand after stepping into min, immediately step-return out of it.\r\n\r\nNote that the stepping operations are used so often, they are also bound to\r\nthe keys F5, F6, F76, and F8 (stop-into, step-over, step-return, and resume).\r\n\r\nAlso, we can set a [un]conditionial breakpoint on any line INSIDE a function,\r\nand the debugger will stop there whenever it calls the function and reaches that\r\nline (just as it would for setting breakpoints in a script).\r\n\r\nFinally, before we leave this interlude, go back to the PyDev perspective.\r\nThen replace the call to min in the script with the following (which includes\r\njust one argument).\r\n\r\ncost  = min(.90*price)\r\n\r\nRerun this script. Python can still execute the first statement, which prompts\r\nfor the price. But when Python tries to execute the second statement it will\r\ndetect that it cannot successfully call the min function, because min's header\r\nlists two parameters (and neither with a default argument) but the rewitten\r\ncall now contains only one argument. Because it cannot successfully initialize\r\nall the parameter names, Python raises the TypeError exception and prints the\r\nfollowing.\r\n\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\zexperiment\\functions.py\", line 10, in <module>\r\n    cost  = min(.90*price)\r\nTypeError: min() missing 1 required positional argument: 'y'\r\n\r\nWhat this exception means by TypeError is that the prototype of min (which\r\nreally means the header, showing two parameters) is not successfully matched by\r\nthis call to min, which transmits/passes just one argument. This is not the\r\nkind of exception that we write a try/except to handle: something is wrong with\r\nour script and we need to fix it to call min with the correct number of\r\narguments.\r\n\r\nLikewise, if we changed the same line to\r\n\r\ncost  = min(.90*price, price-5., \"Can't you give me a better value?\")\r\n\r\nPython would detect that it cannot successfully call the min function (the call\r\nnow supplies three arguments, but the function still only defines two parameter\r\nnames) so Python will raise the following exception.\r\n\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\zexperiment\\functions.py\", line 10, in <module>\r\n    cost  = min(.90*price, price-5., \"Can't you give me a better value?\")\r\nTypeError: min() takes 2 positional arguments but 3 were given\r\n\r\nOf final interest, if we changed the same line to (function name is now mini)\r\n\r\ncost  = mini(.90*price, price-5.)\r\n\r\nEclipse would show this line as a syntax error because there is no mini function\r\neven defined. But Python will still execute the script if we tell it to run the\r\nscript. Wen it reaches this line it will detect an error and raise the\r\nfollowing exception.\r\n\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\Pattis\\workspace\\zexperiment\\functions.py\", line 10, in <module>\r\n    cost  = mini(.90*price, price-5.)\r\nNameError: name 'mini' is not defined\r\n\r\nSo, Eclipse indicates some errors before running our script and some after\r\nPython starts running the script. If we run a script for which Eclise indicates\r\nan error, Python will raise an exception when it reaches that error. Generally\r\nwe try to fix all the errors Eclipse shows before telling Python to run the\r\nScript.\r\n\r\nFinally, if we really wanted to write a simple discount function, we could write\r\nit along with min, as\r\n\r\ndef discount(price):\r\n    return minimum(.90*price,price-5.00)\r\n\r\nHere, discount returns the minimum of the price calculated two ways. Our script\r\nwould become\r\n\r\nprice = prompt.for_float('Enter price of item as dollars.cents')\r\ncost  = discount(price)\r\nprint('The sale cost of this item is',cost)\r\n\r\nIn fact, we don't need to store the computed discount, and can write the 2-line\r\nscript\r\n\r\nprice = prompt.for_float('Enter price of item as dollars.cents')\r\nprint('The sale cost of this item is', discount(price))\r\n\r\nWe could even \"simplify\" this to have no price name, by calling discount\r\ndirectly on whatever value the user input:\r\n\r\nprint('The sale cost of this item is', \r\n      discount(prompt.for_float('Enter price of item as dollars.cents')))\r\n\r\nBut I would argue that this is too compact and would prefer either of the\r\nscripts written above it.\r\n\r\n------------------------------\r\n\r\nEquivalent min functions\r\n\r\nHere is a second way to write an equivalent min function. Ideally, a function\r\nshould contain just one return statement, at its end. In fact, we can prove\r\nmathematically that there is always a way to write any function with just one\r\nreturn statement. But sometimes functions are easier to write (and understand)\r\nif they have multiple return statements.\r\n\r\nThus, we will adopt a more pragmatic approach, putting simplicity as the\r\nparamount aspect of the code that we write: if multiple return statements make\r\na function simpler to write and easier to understand, use them. But be able to\r\nargue why; don't just use them because you are sloppy. I would argue, for\r\nexample, that the min function defined above, which has two return statements,\r\nis simpler than the one below, which has only one return statement.\r\n\r\ndef min (x,y):\r\n    if x <= y\r\n        answer = x\r\n    else:\r\n        answer = y\r\n    return answer\r\n\r\n\r\nInstead of one if statement, this function's body is a sequence of two\r\nstatements: one that decides how to define answer, and one that returns that\r\nvalue. The original function just chooses which of its parameters to return,\r\nand returns it immediatley, without defining any additional local names. As\r\nsoon as Python knows whether x <= y, it knows which value to return, and\r\nreturns it. Therefore, I think that the original function is simpler to write\r\nand easier to understand.\r\n\r\n------------------------------\r\n\r\nConditional Expressions vs. Conditional Statements:\r\n\r\nIn fact, we can write the min function using a conditional expression, which we\r\nwill now discuss. Note that Python has an conditional STATEMENT (the if\r\nstatement, which we have studied), which uses the if keyword and possibly\r\nthe elif/else keywords. It also has a conditional EXPRESSION, which always uses\r\nthe if/else keywords.\r\n\r\nA conditional statement decides which (if any) other statements to execute; a\r\nconditional expression decides which of two other expressions to evaluate, to\r\ncompute the result of the entire expression.\r\n\r\nThe form of a conditional expression is as follows:\r\n\r\n  expression-T if expression-B else expression-F\r\n\r\nOften I put conditional expressions inside parentheses for clarity, but it is\r\nneeded only if operator precedence dicates we use these parentheses.\r\n\r\nSemantically, the result of this expression is either the value of expression-T\r\n(if expression-B evaluates to True) or  expression-F (if expression-B evaluates\r\nto False). Python first evaluates expression-B, and the evaluates exactly one\r\nof the two other expressions. Like other short-circuit operators in Python\r\n(and/or) it evaluates only the subexpressions it needs to evaluate to determine\r\nits result.\r\n\r\nFor a first example, we can write the min function using a simpler conditional\r\nexpression.\r\n\r\ndef min (x,y):\r\n    return (x if x <=y else y)\r\n\r\nHere we have a block that is just one return statement; the conditional\r\nexpression decides what gets returned, either the value x or y refers to,\r\nbased on how x compares to y.\r\n\r\nThere is another example of using a conditional expression in the next section.\r\nNot all conditional statements can be converted into conditional expressions;\r\ntypically only simple ones can, but doing so often simplifies the code even\r\nmore. So attempt to use conditional expression, but use good judgement after\r\nyou fail, or see that the code looks too complicated.\r\n\r\nHere is another example; it always prints x's value followed by some message.\r\n\r\nif x % 2 == 0:\r\n    print(x,'is even')\r\nelse:\r\n    print(x,'is odd')\r\n\r\nWe can rewrite it as a single call to the print function: we show two ways.\r\nThe first prints x's value and then, using a conditional expression, what \r\nstring to print at the end.\r\n\r\nprint(x, ('is even' if x%2 == 0 else 'is odd'))\r\n\r\nWe can also write it as a one argument call to the print function, but using the\r\nconcatenate operator, which requires explicitly converting x to a string:\r\nstr(x).\r\n\r\nprint(str(x) + (' is even' if x%2 == 0 else ' is odd'))\r\n\r\nIn fact, we could \"factor out\" the ' is ' string and write this as\r\n\r\nprint(str(x) + ' is ' + ('even' if x%2 == 0 else 'odd'))\r\n\r\nwhich turns out to be on one character longer than the print above: but, is it\r\nsimpler or more complicated?\r\n\r\nAs a final example, here is a function that returns the singular or plural\r\nvalue of a word based on a number. I have commented out the equivalent if\r\nstatement and its multiple returns.\r\n\r\ndef number_match(number : int, singular : str, plural : str) -> str:\r\n     return (singular if number == 1 else plural)\r\n#    if number == 1:\r\n#        return singular\r\n#    else:\r\n#        return plural\r\n\r\nWe can call this function as follows\r\n\r\nprint(brush_count, number_match(brush_count,'brush','brushes'))\r\n\r\nIt might be more useful to write the following function, which doesn't repeat\r\nthe 'brush' part of 'brush' and 'brushes'. It is an art to determine the the\r\nmost useful form of a function. Think and experiment.\r\n\r\ndef number_match_suffix(number : int, root : str, plural_suffix : str) -> str:\r\n    return root + ('' if number == 1 else plural_suffix)\r\n\r\nWhich we can call as follows\r\n\r\nprint(brush_count, number_match_suffix(brush_count,'brush','es'))\r\n\r\nOf course, it would be problematic to print 1 goose vs. 2 geese with\r\nnumber_match_suffix, but easy to do with the original number_match.\r\n\r\nWhat all these uses have in common is that we started with a very simple if/else\r\nstatement whose blocks did the same things: returning or printing. If this is\r\nthe case, we can often simplify the code with an if expression. Once students\r\nlearn about conditional expressions, they try to remove every if statement,\r\nconverting it to a conditional expression: it OK to try, but if you fail or end\r\nup with something that looks much more complex, stick with the if/else\r\nstatement.\r\n\r\n------------------------------\r\n\r\nPolymorphic Functions\r\n\r\nLet's return to an issue dealing with annotations. All versions of the min\r\nfunction require of their parameters only that their argument values can be\r\ncompared using the <= operator. So long as the types of the arguments are the\r\nsame (e.g., both int, float, string, even bool) this function will return as\r\na result the minimum of the two values. In fact, because of implicit conversion\r\nthings like min(1,.5) and min(1,False) return results: .5 and False\r\nrespectively (do you know why the second call returns False and not 0.0?)\r\n\r\nA function that works correctly on many different types is called polymorphic.\r\nThe term poly+morphous means many+forms, so these function work on many forms\r\n(programmers would say, \"many types of data\"). We have used the term overloaded\r\nto refer to the same phenomenon.\r\n\r\nThere are arguments for which this function cannot compute an answer and raises\r\nan exception: if we call min(1,'2') Python detects the problem and reports the\r\nfollowing exception: TypeError: unorderable types: int() <= str(), which means\r\nthere is no defintion in Python of <= whose left argument is an int and whose\r\nright argument is str (and no implicit promotion solves this problem).\r\n\r\nSo annotating min's parameters by using int, or float, or str would not tell\r\nthe whole story. We can annotate these parameter with : Object, although that\r\ndoesn't tell the whole story either, because the arguments matching the\r\nparameters cannot be any arbitry objects, they must be comparable objects.\r\n\r\nSo, we will use annotations when they add useful information, but not use them\r\nwhen they won't\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunctions: simple examples and use (simple parameters, no default arguments)\r\n\r\nIn this section we first describe how to write a function (a beginner's lesson)\r\nand then we will show and commment on many sample functions. As described\r\nbefore, a function is basically a mini-script that receives its input through\r\nits parameters and produces its output by returning a result.\r\n\r\nSo, to write a function a beginnner would first write a script that prompted\r\nfor the input, did the computation, and printed the output. Then the computation\r\npart of the script would be put in the body of a function. Its header would\r\ninclude a descriptive name for the function, and all the parameters needed for\r\nthe function to compute. It would include one or more return statements to\r\nproduce the result. Note that every parameter name should be used (refered to)\r\nsomewhere inside the function, otherwise it shouldn't be a parameter.\r\n\r\nWe can test such a function by moving the prompt statements remaining in the\r\nscript after the function definition, and then placing a call to the function\r\npassing ther results of these prompts are arguments, and either storing the\r\nresult in a name and printing it, or just printing the result returned by the\r\nfunction directly. See how we tested the min function above.\r\n\r\nNow, let's look at sample functions.\r\n\r\nFirst, here are two functions that compute whether a year is a leap year.\r\n\r\ndef is_leap_year (year : int) -> bool:\r\n    return  (year%4 == 0 and year%100 != 0) or year%400 == 0\r\n\r\ndef is_leap_year (year : int) -> bool:\r\n    if  year%400 == 0:\r\n        return True\r\n    elif year%100 == 0\r\n        return False\r\n    elif year%4:\r\n        return True\r\n    else:\r\n        return False\r\n\r\nThis function hides a very messy calculation inside a well-named and easy to\r\ncall function. A year is a leap year if it is divisible by 4 but not 100, unless\r\nit is also divisible by 400; this function is correct for the next few thousand\r\nyears. It has just one parameter: the year on which to do the calculation, and\r\nalways returns a bool (True or False) value.\r\n\r\ndef distance (x1 : float, y1 : float, x2 : float, y2 : float) -> float:\r\n    return math.sqrt( (x1-x2)**2 + (y1-y2)**2 )\r\n\r\nActually, this function works with combination of ints and floats, but it always\r\nreturns a float result (because of of the square root: even math.sqrt(4)\r\nreturns a result of 2.0 (a float). We could write it more succinctly as\r\n\r\ndef distance (x1,y1, x2,y2) -> float:\r\n    return math.sqrt( (x1-x2)**2 + (y1-y2)**2 )\r\n\r\nThis function computes the simple Euclidean distance between two points on a\r\nplane, which must be specified as four parameters: the X- and Y-coordinate of\r\neach point (although a better function would use two parameters, each an\r\ninstance of a Point class, to represent these four values; we will get to using\r\nand defining classes soon). Some functions have quite a few parameters (see\r\nbelow for even more).\r\n\r\ndef in_circle (point_x, point_y,  center_x, center_y, radius,) -> bool:\r\n    return distance(center_x,center_y,point_x,point_y) <= radius\r\n\r\nThis function calls the previously written distance function to compute whether\r\na point (whose coordinates are point_x and point_y) falls within a circle (whose\r\ncenter's coordinates are center_x and center_y, and whose radius is radius). It\r\nreturns True if the distance from the center of the circle to the points does\r\nnot exceed the radius of the circle. Note that four of the coordinate\r\nparameters to in_circle become arguments to the call of distance; this role\r\nswitch is common in functions calling other functions.\r\n\r\nBy layering functions on top of functions (with later ones calling earlier ones)\r\neach is kept small, but each new function accomplishes much more because it\r\ncalls other functions and leverages by building on their power. This layer\r\nmechanism enables power programming: distance/in_circle is one simple example.\r\n\r\nHere are another function that appeared first in the if lecture, when\r\nillustrating cascaded if statements\r\n\r\ndef compute_grade(test_percent):\r\n    if test_percent >= 90:\r\n        return 'A'\r\n    elif test_percent >= 80:\r\n        return 'B'\r\n    elif test_percent >= 70:\r\n        return 'C'\r\n    elif test_percent >= 60:\r\n        return 'D'\r\n    else:\r\n        return 'F'\r\n\r\nWe will soon be able to write code that can read student names and test scores\r\nfrom a file, and we could use this function to help us print the name and grade\r\nof every student.\r\n\r\nWe have already used the factorial function that we imported from the math\r\nlibrary. If it were not there, we could write it ourselves, as follows.\r\n\r\ndef factorial(n : int) -> int:\r\n    answer = 1\r\n    for i in irange(2,n):\r\n        answer *= i\r\n    return answer\r\n\r\nThis function is interesting because it defines two local names (answer and i,\r\nalong with its parameter n). We accumulate the product of all the integers 1 up\r\nto n in the local name answer, by initializing it and repeatedly multiplying it\r\nby the next integer; finally we return the value it has accumulated.\r\n\r\nWhen writing functions, beginners sometimes have difficulty determining when to\r\ndefine a parameter name and when to define a local name. Here is where thinking\r\nabout prototypes helps: any information that must be communicated to the\r\nfunction by arguments must be stored in a parameter; local names help in the\r\ncomputation, but do not need to be initialized by arguments. We need n to\r\nspecify the factorial that we are computing, but answer is always initialized\r\nto 1 and i comes from iterating over an irange. Functions should have the fewest\r\nnumber of parameters necessary; if a name can be defined locally, it should be.\r\nRemember that when functions terminate, all parameter names and local names\r\ndisappear.\r\n\r\nHere are two more functions we defined in the for loop lecture.\r\n\r\ndef vowel_count(s : str) -> int:\r\n    count = 0\r\n    for c in s:\r\n        if c in 'aeoiuAEIOU':\r\n            count += 1\r\n    return count\r\n\r\n\r\ndef is_legal(word : str, dict_file_name : str) -> bool:\r\n    # look for a word in the dictionary file\r\n    for l in open(dict_file_name):\r\n        if word == l.rstrip():\t# found it; legal\r\n            return True\r\n\r\n    return False\t\t# couldn't find it in the dictionary: illegal\r\n\r\nThe  first returns a count of the vowels in its parameter s (using local names\r\ncount and c), initializing and accumulating the answer in the local name count.\r\n\r\nThe second determines if its word parameter is legal, by looking for it on every\r\nline in in the file whose name is dict_file_name. There is only one local name,\r\nl, which iterates over the lines in the file, whose rstipped values are compared\r\nto word for equality. Here the return statements each use literals: either True\r\nif one of the lines is found to be the word, and False (outside/after the loop, \r\nexecuted after the loop terminates) if no line had the word. Note that the\r\nreturn True statement that appears in the for loop, when executed, terminates\r\nthe function, and therefore also terminates the for loop it is in: it does not\r\nhave to execute a break statement to terminate the loop: once it knows the\r\nanswer, it can execute return and be done with the function.\r\n\r\nHere are two similar is_legal functions (notice how each uses else:) one of\r\nwhich is CORRECT and one of which is INCORRECT. Can you spot the wrong one? More\r\nimportantly, can you explain why it is wrong? They are different only in the\r\nindentation of the else: return False\r\n\r\ndef is_legal(word : str, dict_file : str) -> bool:\r\n    for l in open(dict_file):\r\n        if word == l.rstrip():\r\n            return True\r\n        else:\t\t\t\t# Here is the else: note its indentation\r\n           return False\r\n\r\n\r\ndef is_legal(word : str, dict_file : str) -> bool:\r\n    for l in open(dict_file):\r\n        if word == l.rstrip():\r\n            return True\r\n    else:\t\t\t\t# Here is the else: note its indentation\r\n        return False\r\n\r\nIn the first case, it starts the loop and based on the first word it reads,\r\nreturns True or False, without examining any other words. This is wrong. In\r\nthe second case, the else: is part of the for loop, and is executed if the loop\r\nfinishes without executing a break statement: there are no break statements in\r\nthis loop the return False is always executed if the loop finishes without\r\nreturning True.\r\n\r\nHere is a function that returns how many time its test_number parameter must go\r\nthrough the collatz process before it becomes 1.\r\n\r\ndef cycle_count(test_number : int) -> int:\r\n    count = 0\r\n    while test_number != 1:\r\n        count += 1\r\n        if test_number % 2 == 0:\r\n            test_number = test_number//2\r\n        else:\r\n            test_number = 3*test_number + 1\r\n\r\n    return count\r\n\r\nIt initializes count to 0, increments it during each iteration of the loop\r\n(before deciding how to update test_number) and finally returns the resulting\r\nvalue stored in count.\r\n\r\nAnd finally, here is a functional version of prompting for an int and trapping\r\nuser-entry errors. Of course, the entire purpose of this function is to do\r\nsafe input, so it does prompting and printing (in the case of errors) unlike any\r\nof these other functions. If you compare this code with the original, you will\r\nsee that we added a prompt string (named message) as a parameter, and we\r\ndirectly return the result of calling int(string_rep), which either returns the\r\ncorrect int value or raises an exception that is handled and therefore stays\r\nwithin the loop. The exception interrupts the return statment.\r\n\r\ndef prompt_for_int(message : str) -> int:\r\n    while True:\r\n        try:\r\n            string_rep = input(message+': ')\r\n            return int(string_rep)\r\n        except ValueError:\r\n            print('Entry error (',string_rep,') is not a legal int')\r\n\r\nAn example call is\r\n\r\nx = prompt_for_int('Enter x')\r\n\r\nThese 10 functions appear in a functionproject download that accompanies this\r\nlecture. We can create a project containing this module, and then write\r\nanother module in that project to import its functions, call them, and print\r\nthe returned values. Or, we can just print the values returned by calling these\r\nfunctions inside the module they appear in. See below for more details.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFunctions in scripts/Functions in modules\r\n\r\nSome functions fulfill a very specific purpose in the module in which they are\r\nwritten. Other functions are more general, and might be reused in more than\r\none script. We can place these general functions in a module and place the\r\nmodule in the courselib folder, so we can reuse its functions. Any module in\r\nthe courselib is automatically available for import into our scripts, or any\r\nother modules. I have written a variety of general-purpose modules that are\r\nalready in the courselib. It makes sense to catergorize similar functions and\r\nput them in the same module: it makes it easier for programmers to remember\r\nwhat to import and from where.\r\n\r\nIt is a bit too early in your programming career to be thinking about writing\r\ngeneral-purpose functions: I'm more concerned that you know how to call the\r\ngeneral purpose functions already in Python's (and the courselib) library. Also,\r\nby using general purpose functions, you'll get some insight into what makes\r\nreusable/library functions, and when it comes time to write your own, you'll\r\nhave acquired some programming taste.\r\n\r\nOne final word of caution. If you put functions/modules into your courselib, we\r\nwill not have access to this code when we grade your assignments. So if you are\r\nasked to submit a script, you must put all the functions you wrote for that\r\nassignment in the script Don't submite code that imports from any modules you\r\nyourself wrote in courselib.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nEBNF details/review (named parameters and default arguments)\r\n\r\nIn this lecture we have discussed parameter/argument binding, but only for\r\nsimple functions (where the parameters are bound to their matching argument\r\nby position). We have seen other functions (notably print) where we specify\r\nsome parameters by position and others by names; and if we don't specify the\r\nnames of these parameters, they are initialized with default arguments.\r\n\r\nAs we become more sophisticated as programmers, and write more generally useful\r\nfunctions, we are more likely to write functions that specify default arguments\r\nfor some parameter, and call these functions using a combination of positional\r\nand named arguments. To this end we review the EBNF for defining and calling\r\nfunctions. These details appear in Chapter 4; see sections 4.2/4.3 for details.\r\n\r\nqualified-name   <= identifier{.identifier}\r\nannotation       <= type-name\r\ndefault-argument <= =expression\r\nparameter        <= name[:annotation][default-argument] | *[name[annotation]]\r\nfunction-header  <= qualified-name([parameter{,parameter}]) [->annotation]\r\n\r\nParaphrased, each function name and its parameter are indentifiers, with the\r\nparameters separated by commas. Each parameter can optionally be annotated and\r\nhave a default argument.\r\n\r\nexpression    <= qualified-name | function-call\r\nargument      <= [name=]expression\r\nfunction-call <= expression([argument{,argument}])\r\n\r\nParaphrased, each function call is typically an identifier, following by\r\nparentheses, in which arguments are separated by commas. Each argument can be\r\njust an expression, or an expression prefaced by the name of a parameter.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nArgument/Parameter Matching (leaves out **kargs, talked about later)\r\n\r\nLet's explore the argument/parameter matching rules first discussed in Chapter\r\n4. First we classify arguments and parameters, according the options they\r\ninclude. We will explore these rules generally first, and then apply them\r\ncarefully to many examples.\r\n\r\nArguments\r\n  positional argument: an argument not preceded by name= option\r\n  named      argument: an argument preceded by name= option\r\n\r\nParameters\r\n  name-only parameter       : a parameter with no default value\r\n  default-argument parameter: a parameter including a default argument value\r\n\r\nWhen Python calls a function, it defines every parameter name in the\r\nfunction's header, and binds to each (just like an assignment statement) the\r\nargument value object matching that parameter name. In the rules below, we\r\nwill learn how Python matches arguments to parameters according to three\r\ncriteria: positions, parameter names, and default arguments for parameter\r\nnames.\r\n\r\nHere are Python's rules for matching arguments to parameters.\r\nThe rules are applied in this order (e.g., once you reach M3 we\r\ncannot go back to M1).\r\n\r\nM1. Match positional argument values in the call sequentially to the\r\n    parameters named in the header's corresponding positions (both name-only\r\n    and default-argument parameters are OK). Stop when reaching any named\r\n    argument in the call or the * parameter in the header.\r\n\r\nM2. If matching a * parameter in the header, match all remaining positional\r\n    argument values to it. Python creates a tuple that stores all these\r\n    arguments\r\n\r\nM3. Match named-argument values in the call to their like-named parameters\r\n    in the header (both name-only and default-argument parameters are OK)\r\n\r\nM4. Match any remaining default-argument parameters in the header, un-\r\n    matched by rules M1 and M3, with their specified default arguments.\r\n\r\nM5. Exceptions: If at any time (a) an argument cannot match a parameter\r\n    (e.g., a positional-argument follows a named-argument) or (b) a parameter\r\n    is matched multiple times by arguments; or if at the end of the process\r\n    (c) any parameter has not been matched, raise an exception: SyntaxError\r\n    for (a) and TypeError for (b) and (c). These exceptions report that the\r\n    function call does not correctly match its header.\r\n\r\n(When we talk about **kargs we will see what happens when there are extra named\r\narguments in a function call: names besides those of parameters).\r\n\r\nWhen this argument-parameter matching process if finished, Python defines,\r\n(in the function's namespace), a name for every parameter and binds each to\r\nthe argument it matches using the above rules. Passing parameters is similar\r\nto performing a series of assignment statements between parameter names and\r\ntheir argument values.\r\n\r\nIf a function call raises no exception, these rules ensure that each parameter\r\nin the function header matches the value of exactly one argument in the\r\nfunction call. After Python binds each parameter name to its argument, it\r\nexecutes the body of the function, which computes and returns the result of\r\ncalling the function\r\n\r\nHere are some examples:\r\n\r\ndef f(a,b,c=10,d=None):\r\n   pass\r\ndef g(a=10,b=20,c=30):\r\n    pass\r\ndef h(a,*b,c=10):\r\n    pass\r\n\r\nCall              | Parameter/Argument Binding (matching rule)\r\n------------------+--------------------------------------------\r\nf(1,2,3,4)\t  | a=1, b=2, c=3, d=4(M1)\r\nf(1,2,3)\t  | a=1, b=2, c=3(M1) d=None(M4)\r\nf(1,2)\t\t  | a=1, b=2(M1) c=10, d=None(M4)\r\nf(1)\t\t  | a=1(M1) c=10, d=None(M4), TypeError(M5c:b)\r\nf(1,2,b=3) \t  | a=1, b=2(M1) b=3(M3), TypeError(M5b:b)\r\nf(d=1,b=2)\t  | d=1, b=2(M3) c=10(M4), TypeError(M5c:a)\r\nf(b=1,a=2)\t  | b=1, a=2(M3) c=10, d=None(M4)\r\nf(a=1,d=2,b=3)\t  | a=1, d=2, b=3(M3), c=10(M4)\r\nf(c=1,2,3)\t  | c=1(M3), SyntaxError(M5a:2)\r\ng()\t\t  | a=10, b=20, c=30(M4)\r\ng(b=1)\t\t  | b=1(M3), a=10, c=30(M4)\r\ng(a=1,2,c=3)\t  | a=1(M3), SyntaxError(M5a:2)\r\nh(1,2,3,4,5)\t  | a=1(M1), b=(2,3,4,5)(M2), c=10(M4)\r\nh(1,2,3,4,c=5)    | a=1(M1), b=(2,3,4)(M2), c=5(M4)\r\nh(a=1,2,3,4,c=5)  | a=1(M3), SyntaxError(M5a:1)\r\nh(1,2,3,4,c=5,a=1)| a=1(M1), b=(2,3,4)(M2), c=5(M3), TypeError(M5b:a)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe raise statement (and assertions that can raise exceptions)\r\n\r\nWe have already discussed how to handle raised exceptions with try/except\r\nstatement. Now is an appropriate time to begin discussing the other end of\r\nexception processing: how to raise them after detecting a problem. The EBNF\r\nrule for raising an exception (using the keyword raise) is similar to return.\r\n\r\n    raise_statement <= raise expression\r\n\r\nExpression it typically the name of some exception (see the end of the\r\ntry/except lecture for a list) followed by () in which we put a string that\r\nidentifies the problem.\r\n\r\nFor example, given that our factorial method only works for non-negative\r\nintegers, we might modify it as follows, to detect a bad argument and raise\r\nthe ValueError exception with an appropriate message (rather than return 1,\r\nwhich is what our original code would do for a negative number; that would be\r\nan intent error that would occur silently, unless we raised an exception).\r\n\r\ndef factorial(n : int) -> int:\r\n    if n < 0:\r\n        raise ValueError('math.factorial: n ('+str(n)+') must be non-negative')\r\n\r\n    answer = 1\r\n    for i in irange(2,n):\r\n        answer *= i\r\n    return answer\r\n\r\nA simple if statement, the first in the function, determines whether or not the\r\nargument passed to the parameter name n is bad, and if so raises an exception.\r\nIt is common to check all the necessary preconditions on arguments at the start\r\nof a function's body, grouping such code together and separating it from the\r\ncode that actually performs the function's computation (which executes only\r\nafter all the preconditions on the parameters have been checked, and non raise\r\nan exception).\r\n\r\nIn this example, if the argument matching parameter n is a negative value,\r\nPython and raises the ValueError exception. When a raise statement raises an\r\nexception, Python abandons the sequential execution of the block in which it\r\nappears, and goes back to the site making the call to the function to determine\r\nif the call is in a try/except statement that handles the exception. \r\n\r\nTypically an exception message includes the module name, the function name, and\r\nsome error message that might list the values that were found objectionable.\r\n\r\nWe can also use Python's assert statement which has the EBNF\r\n\r\n  assert_statement <= assert expression-B, expression-S\r\n\r\nwhere expression-B evalutes to a bool and expression-S evaluates to a string.\r\n\r\nSemantically, if expression-B evaluates to True, nothing happens (and the next\r\nstatement in the sequence is executed); if expression-B evaluates to False,\r\nPython executes the equivalent of raise AssertionError(expression-S). So, if we\r\nwant to raise the AssertionError exception instead of ValueError, we can replace\r\nthe if/raise combination with just\r\n\r\n    assert n>=0, 'math.factorial: n ('+str(n)+') must be non-negative'\r\n\r\nNotice the test is opposite, saying what must be True for the exception NOT to\r\nbe raised. We will continue to discuss exceptions throughout the quarter; for\r\nnow, it is enough that you know how to raise exceptions with if/raise or with\r\nassert, and how to handle them with try-except statements.\r\n\r\nMeanwhile, it is very easy to experiment with raise and assert in the Python\r\ninterpreter.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nStatements that don't do anything\r\n\r\nIt is possible to write something like x+1 as a statement in Python. This\r\ninstructs Python to compute the value x+1, but not store it anywhere (no\r\nassignment statement) or print it (no print statement). Typically a statement\r\nlike this is an intent error: we meant to store or print the result.\r\n\r\nIt is common for begining programmers to forget to write return for their\r\nreturn statements, and just write expression whose value should be returned.\r\nRecall that if the last statement in a function is not a return statement, then\r\nPython will return None for the function.\r\n\r\nFor example if we wrote the INCORRECT function\r\n\r\ndef f(x):\r\n    x+1\r\n\r\nCalling print(f(1)) would print None. It does not return the value of x+1, it\r\ncomputes that value and then does nothing with it. And since the end of the\r\nfunction's body has now been executed, Python automatically returns None.\r\n\r\nHere is the CORRECT way to write this function.\r\n\r\ndef f(x):\r\n    return x+1\r\n\r\nCalling print(f(1)) would print 2.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nA bit of magic for a later lecture\r\n\r\nThe predicate module defines the function length_equal. If we call this function\r\nwith an int, it returns a function object: this function object takes a string\r\nas a parameter and returns a boolean, whether the strings length is equal to\r\nspecified length.\r\n\r\nThus, we can write either:\r\n\r\nf = length_equal(3)    # f refers to the function object length_equal(3) returns\r\nprint( f('abc') )      # Call the function object with the string 'abc'\r\n\r\nwhich prints True; or we can write\r\n\r\nprint( length_equal(3)('abc') )\r\n\r\nHere length_equal(3) returns a reference to a function object, by following it\r\nwith ('abc') we are calling that function object with the string 'abc'.\r\n\r\nHere is how the length_equal function is defined. \r\n\r\ndef length_equal(i):\r\n    def len_eq(s):\r\n        return len(s) == i\r\n    return len_eq\r\n\r\nNotice inside length_equal, the name len_eq is bound to a function that has a\r\nstr parameter and returns a bool result; then the length_equal function returns\r\na reference to this function object.\r\n\r\nThis a a very powerful feature in Python, but confusing to beginning\r\nprogrammers. So, we will see it a few times before we need it.\r\n\r\n------------------------------------------------------------------------------\r\n\r\n1) What does the following print?\r\n\r\ndef wtf():\r\n    return 0\r\n    return 1\r\n\r\nprint(wtf(),wtf())\r\n", "encoding": "ascii"}