{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/listprocessing/listprocessing2.txt", "content": "\t\t\t\tList Comprehensions\r\n\r\nComprehensions are compact ways to specify interesting lists of values (which\r\nwill be generalized to tuples, sets, and dictionaries, when we discuss those\r\ndata structures). That is, they compactly solve some \"list creation\" problems\r\nbut cannot solve all list problems: we use them to create new lists but not\r\nmutate existing lists.\r\n\r\nThe general form of a list comprehension is shown below: it uses some special\r\nPython code (with keywords for/in/if) inside [], which are used to create\r\nPython lists. In the following comprehension, f means any function (or\r\nexpression: we can also just write var because a name by itself is a simple\r\nexpression having a value) using var and p means any predicate (or bool\r\nexpresssion) using var.\r\n\r\n  [f(var) for var in iterable if p(var)]\r\n\r\nHere is the meaing of this list comprehension, followed by some examples that\r\nuse the various iterables we know: string, range/irange, open. A list\r\ncomprehension collects together into a list (because of the outer []) a\r\nsequence of values specified by f(var), for var taking on every value produced\r\nby iterable, but each value appears only if p(var) is True.\r\n\r\nNote that the \"if p(var)\" part is optional and we can also write comprehensions\r\nas follows (in which case it has the same meaning as p(var) always being True).\r\n\r\n  [f(var) for var in iterable]\r\n\r\nwhich is equivalent to writing\r\n\r\n [f(var) for var in iterable if True]\r\n\r\nHere is a first simple example, using a string iterable.\r\n\r\n  [x for x in 'richardepattis' if x not in 'aeiou']\r\n\r\nHere, x is the var, f(var) is just x, and p(var) is x not in 'aeiou'. The result\r\nis the list ['r', 'c', 'h', 'r', 'd', 'p', 't', 't', 's']: all the non-vowels\r\nletter in my name. So, \"for x in 'richardepattis'\" produces all the letters,\r\n\"if x not in 'aeiou'\" filters out all vowels, and \"x\" just means use each\r\nletter. \r\n\r\nWe can use the join method (with and empty string as the joining string) and\r\nwrite\r\n\r\n  ''.join([x for x in 'richardepattis' if x not in 'aeiou'])\r\n\r\nwhich results in the string 'rchrdptts'.\r\n\r\nIn this second example, we use an irange iterable\r\n\r\n  [i**2 for i in irange(1,10)]     # note: irange not range\r\n\r\nHere, i is the var, f(var) is i**2, and p(var) is True (because the if keyword\r\ndoes not appear, so all values are included). The result is the list\r\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100].\r\n\r\nIf we wanted to join all these values into one big string with a ':' separating \r\nthese values, we cannot use a .join directly on this list, because .join\r\nrequires the values in the list being joined to be strings not ints. But, we\r\ncould specify a slightly different comprehension, using str(i**2) as the\r\nexpression instead of i**2\r\n\r\n  [str(i**2) for i in irange(1,10)]     # note str(i**2)\r\n\r\nwhich results in the list\r\n\r\n['1', '4', '9', '16', '25', '36', '49', '64', '81', '100']\r\n\r\nGiven the list that this comprehension produces, we could write\r\n\r\n  ':'.join([str(i**2) for i in irange(1,10)])\r\n\r\nwhich results in the string '1:4:9:16:25:36:49:64:81:100'\r\n\r\nIf we wanted only the squares of the prime numbers in a list, we could again\r\nuse the \"if\" keyword to filter-out non-primes by writing\r\n\r\n  [i**2 for i in irange(1,10) if predicate.is_prime(i)]     # note: if ..\r\n\r\nwhich results in the list [4, 9, 25, 49].\r\n\r\nFinally, here is an example that creates a list of all the lines in the file\r\n'input.txt', with each line stripped of its '\\n' at the end.\r\n\r\n  [l.rstrip() for l in open('input.txt')]\r\n\r\nIf a file named 'input.txt' contained the three lines\r\n\r\nSee Spot.\r\nSee Spot run.\r\nRun Spot run!\r\n\r\nThe list produced would be: ['See Spot.', 'See Spot run.', 'Run Spot run!']\r\n\r\nComprehensions can get quite complicated. For example, the comprehension below\r\n(1) reads every line in the file and (2) for each line (2a) strips the '\\n'\r\nfrom the line and THEN (2b) uses the .split method to break that line into a\r\nlist of its words (here words in the line are assumed to be separated by\r\nspaces).\r\n\r\n  [l.rstrip().split(' ') for l in open('input.txt')]\r\n\r\nSo the result is that this comprehension produces a list of lists of strings\r\nwhich for the file named 'input.txt\" results in the list\r\n\r\n  [['See', 'Spot.'], ['See', 'Spot', 'run.'], ['Run', 'Spot', 'run.']]\r\n\r\n------------------------------------------------------------------------------\r\n\r\nWe can translate a list comprehension into equivalent code that uses more\r\nfamiliar Python features. The general comprehension form, whose result is\r\nassigned to the name x\r\n\r\nx = [f(var) for var in iterable if p(var)]\r\n\r\nis equivalent to the Python code\r\n\r\nx = []\t       \t  \t # start with an empty list\r\nfor var in iterable:\t # bind var to each values produced by iterable\r\n   if p(var):\t\t #   if var is to be included in the list...\r\n       x.append(f(var))\t #   add f(var) next into the list\r\n\r\nOnce you understand comprehensions (by practicing writing/using them), writing\r\nthem to create new lists is often simpler than the equivalent Python code above.\r\n\r\nWhat comprehensions aren't good for is mutating/changing data in an already\r\nexisting list; for that job you need code more like the loop above. So when\r\ndeciding whether or not to use a comprehension, ask youself if you are creating\r\na new list (use comprehension) or changing an existing one (don't use\r\ncomprehension).\r\n\r\nFinally, note that calling the list conversion function -list(iterable)-\r\nproduces the same list result as the list comprehension [x for x in iterable].\r\nSo, list('abcde') is the same as [x for x in 'abcde']. In this case, calling the\r\nconversion function list(iterable) is preferable.\r\n", "encoding": "ascii"}