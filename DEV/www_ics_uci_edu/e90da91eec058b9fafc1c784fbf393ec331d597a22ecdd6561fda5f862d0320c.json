{"url": "https://www.ics.uci.edu/~pattis/ICS-46/lectures/notes/dijkstra.txt", "content": "\t\tDijkstra's All Sortest Path Algorithm\r\n\r\n\r\nThe most complicated graph algorithm that we will examine in detail in ICS-46\r\nis Dijkstra's All Shortest (least costly) Paths Algorithm. Given a starting node\r\nand a graph, it computes the shortest paths (in a directed graph with weighted\r\nedges; the edge weights must all be non-negative) to all the nodes that can be\r\nreached in the graph from the starting node. The length of a path (and the\r\nmeasure of \"shortness\") is based on the sum-of-the-weights of all the edges on\r\nthe path.\r\n\r\nActually, I will call it an Extended version of Dijkstra's algorithm, because\r\nwe will store enough information not only to compute the cost of the shortest\r\npaths, but to reconstruct these paths as well: what nodes/edges lie between the\r\nstarting and ending nodes, and what order they must be followed. The standard\r\nDijkstra algorithm computes just the cost of all the shortest paths, but omits\r\ninformation for reconstructing the paths.\r\n\r\nThis algorithm generalizes the reachability algorithm that we wrote in\r\nProgramming Assignment #1, by finding not just all nodes reachable from a start\r\nnode, but the minimum cost path to reach each node; in Programming Assignment\r\n#1, our map stored no edge weights to compute such path costs.\r\n\r\nGPS systems use a variant of this algorithm to search from where you are to\r\nwhere you want to go. But it is more specialized/efficient, because it knows\r\nwhere you want to go at the time the algorithm starts: with Dijkstra's\r\nalgorithm, the destination(s) are supplied at the end, after the algorithm \r\ndoes all its work computing shortest paths.\r\n\r\nThis algorithm uses many data types to get its job done: a Graph, two Maps,\r\na Priority Queue, a Queue, and Stack. I will describe the algorithm in detail\r\nbelow, and then we will hand simulate it on a moderate-sized graph in class.\r\nYou will implement this algorithm as part of Programming Assignment #5.\r\n\r\nMost data in the algorithm is stored as objects from a class named Info, which\r\ncontains (1) an approximation to the cost of the minimum path to reach that\r\nnode (initialzed to +infinity and updated in the algorithm until the actual\r\nminimum cost is found), and (2) the name of the node BEFORE it on the shortest\r\npath to it (initialized to \"?\" and updated in the algorithm).\r\n\r\nObjects in the Info class are ultimately stored in three collections: as the\r\nvalues in two Maps (the key is the node name), and in an Adjustable Priority\r\nQueue (see the writeup of Programming Assignment #5 which discusses the\r\nAdjustable variant of a PriorityQueue in detail: basically, we can use the\r\nupdate method to replace one priority queue value with another; when update is\r\nexecuted, the priority queue adjusts itself according to the new value's\r\npriority: in a heap implementation, it percolates the value up or down to the\r\ncorrect position).\r\n\r\nThe basic algorithm is\r\n\r\nGet the inputs:\r\n1) Input the Graph. In your code, prompt the user for a file name and load and\r\n     print its graph, whose edges are will be labeled by non-negative integer\r\n     values.\r\n\r\n2) Input the start node. In your code, prompt the user to enter a start node.\r\nIt will compute all shortest paths FROM that particular START node.\r\n\r\nCompute the shortest paths:\r\n3) Call the extended_dijkstra function with this information, returning a map\r\n     of the minimum costs to reach each node and the information needed to\r\n     construct the minimum cost path to any node.\r\n\r\n   In the extended_dijkstra function:\r\n\r\n   3a) Declare the answer_map to be empty and the info_map to contain each node\r\n         in the graph as a key in the map, with its associated value a newly\r\n         constructed/initialized object of Info for that node. \r\n \r\n       Update the start node in the info_map by setting its total_cost to 0\r\n          (since we start at that node, the cost to reach it is 0).\r\n\r\n   Note the info_map contains nodes whose minimum distance from the start node\r\n   ARE NOT YET KNOWN; the answer_map contains nodes whose minimum distance ARE\r\n   KNOWN.\r\n\r\n   3b) Declare the info_pq, and load it with the current contents of the\r\n          info_map: here the smallest cost has the highest priority.\r\n\r\n   3c) Loop so long as the info_map is not empty...\r\n\r\n       3c1) Remove the Info from info_pq with the smallest associated cost.\r\n              Initally it will remove the start node (cost 0; others costs\r\n              are all infinity).\r\n            If its cost is infinity, then no more nodes in info_map are\r\n              reachable, so terminate.\r\n    \r\n       3c2) Call \"min_node\" the node from this Info and \"min_cost\" its cost. We\r\n              are now guaranteed to know the least costly path from the start\r\n              node to min_node.\r\n\r\n       3c3) Remove this key->value from the info_map and put it into the\r\n              answer_map.\r\n\r\n       3c4) For every node d that is a destination from the min_node and not\r\n              already in the answer_map, get d's Info using info_map and see if\r\n              the cost is infinite or greater than the cost of the path from\r\n              the start node to min_node, plus the cost of the edge from\r\n              min_node to d.\r\n            If it is infinte, or the computed sum is smaller than its stored\r\n              value,\r\n              (1) In info_map, update the cost in Info to this smaller number,\r\n                    and update the predecessor of d to be min_node,\r\n              (2) update Info to the adjustable info_pq to this new information\r\n\r\n        3c5) Continue around the loop \r\n\r\n  3d) When the loop finishes, the Info values in answer_map are filled with\r\n        the mminimum cost to reach each node and the node preceding it on the\r\n        minimum path. Return this information.\r\n\r\nFind the minimum cost paths to any nodes in the graph:\r\n4) Repeatedly prompt the user for a stop node and show the minimum cost and\r\n     minimum cost path to reach that node, by calling the recover_path, which\r\n     returns a Queue of the nodes on the shortest path between the start node\r\n     and stop node.\r\n\r\n   By repeatedly following the predecessors in the map (a Stack is useful here),\r\n     we can reconstruct a queue containing the entire minimimum cost path, from\r\n     the  start node to any reachable node.\r\n\r\nAlthough I won't show the hand simulation here, I will do one in class and you\r\nshould be able to hand simulate this algorithm, from memory. The steps listed\r\nabove are very detailed when applied to actual C++ data types, but when I\r\npeforming the algorithm on the whiteboard it will be more intuitive and\r\nreasonably fast.\r\n\r\nAgain, I called this algorithm an Extended version of Dijkstra's algorithm,\r\nbecause we will store enough information not only to compute the cost of the\r\nshortest paths, but to reconstruct them as well: what nodes/edges lie between\r\nthe starting and ending nodes. The standard Dijstra algorithm computes just the\r\ncost of all the shortest paths, without storing information to reconstruct the\r\npaths.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSimplistic Analysis: Dense and Sparse Graphs\r\n\r\nAssume that we have a dense graph: each of its N nodes has O(N) edges. The\r\nloop specified in step 3c loops once for each node, so it iterates O(N)\r\ntimes. Each time it loops it executes: part 3c1 takes O(Log N), part 3c3 takes\r\nO(1), and part 3c4 takes O(N)xO(Log N) -because in a dense graph each node can\r\nhave O(N) outgoing edges to process and enqueue; so the entire algorithm is\r\nO(N) x ( O(Log N) + O(1) + O(N)xO(Log N) ) or O(N^2 Log N).\r\n\r\nAssume that we have a sparse graph: each of its N nodes has O(1) edges. The\r\nloop specified in step 3c loops once for each node, so it iterates O(N)\r\ntimes. Each time it loops it executes: part 3c1 takes O(Log N), part 3c3 takes\r\nO(1), and part 3c4 takes O(1)xO(Log N) -because in a sparse graph each node has\r\nsome constant number of outgoing edges to process and enqueue; so the entire\r\nalgorithm is O(N) x ( O(Log N) + O(1) + O(1)xO(Log N) ) or O(N Log N).\r\n\r\nSo we can unify both cases by writing the bound as O( (M+N)Log N )\r\n(recall M is the number of edges in the graph).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProof of Correctness of Dijkstra's Algorithm: By Induction and Contradiction\r\n\r\nProve: The final answer_map contains all the correct answers (shortest paths).\r\n\r\nProof by induction on the size of the answer_map.\r\n\r\n1) size 1: The answer_map contains just the starting node (call it s), with cost\r\n0. That is the correct answer.\r\n\r\n2) Assume that the answer_map, when its size is between 1 and k inclusive, has\r\nall the correct answers. Prove that the next value put in the answer map,\r\nincreasing its size by 1, is correct.\r\n\r\nLet v be the next node added to answer_map. Call the node it came from u (where\r\nu is some node in the answer_map, and there is an edge from u->v). We prove that\r\nthe path from s->u extended by the edge from u->v is the shortest path from s to\r\nv.\r\n\r\nProof by Contradiction:\r\n\r\nAssume that there is a shorter path from s->v through a node y that is not yet\r\nin the answer_map; let x be the last node on this path that is in the\r\nanswer_map. Then there is a path from s->x and from x->y and from y->v. We have\r\nthe following picture (with s, x, and u in the answer_map and y and v not in the\r\nanswer_map)\r\n\r\nin answer_map\r\n +---------+\r\n |         |\r\n |    x ---+---y\r\n |    /    |   |\r\n |  ...    |   |\r\n |  /      |   |\r\n | s       |   |\r\n |  \\      |   |\r\n |  ...    |   |\r\n |    \\    |   |\r\n |    u ---+-- v\r\n |         |\r\n +---------+\r\n\r\nNow, because v was chosen to be the next node in answer_map, the distance from\r\ns->v must be less than the distance from s->y (otherwise y would have been\r\nchosen). Because the edges leading from y to v (there must be at least one) must\r\nhave a non-negative value, it means that any path s->y->v  must be as long or\r\nlonger than the path from s->u->v\r\n  length(s->u->v) <= length(s->x->y) <= length(s->x->y) + len(y->v)\r\n\r\nSo, there can be no such node y tht leads to a SHORTER path from s to v. So our\r\nassumption is wrong, and the shortest path from s->v is correctly added to\r\nanswer_map.\r\n", "encoding": "ascii"}