{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/Minutes990323.txt", "content": "Minutes 3/23/99\n\nAttending: Jim Davis, Jim Whitehead, Geoff Clemm, Chuck Fay, Judy Slein\n\nACTION ITEMS\n\nGeoff: Write up arguments pro and con for making the default semantics of COPY be to \naffect the target.  Send to the WebDAV mailing list by the end of this week.\n\nGeoff: Write up his position on the semantics of LOCK and send it to the mailing list by \nthe end of this week.\n\nJim Davis: Write up a discussion of references to collections and distribute to the \nWebDAV mailing list.\n\nSEMANTICS OF COPY\n\nGeoff:  If we make the default semantics be to copy the reference, this causes problems \nfor relative URIs in the DAV:reftarget property of references.  If COPY results in broken \nreferences at the destination, that\u2019s not acceptable.  Let the default be to copy the target to \navoid this problem.\n \nJim D agrees with Geoff.\n\nJudy: Couldn\u2019t you have the server fix up the value of reftarget?\n\nGeoff: No, the server can\u2019t tell whether client wanted reference fixed up or not.  Adding a \nheader to control this wouldn\u2019t help down-level clients.\n\nIf there is a relative URL within a hierarchy, if you copy the hierarchy, the relative URL\nwill still work.  You don\u2019t want to do any fix-up in this case.\n\nAction Item for Geoff: Write the arguments for and against making the default semantics \nbe to copy the target.  Send this message to the WebDAV mailing list by the end of this \nweek.  We\u2019ll allow a week for mailing list discussion, then make a decision. The \narguments for copying the reference: Size issue, when copying collections.  Simpler / \nleast work for server.  New resource is same type as original.  The arguments for copying \nthe target: Meaning of COPY to down-level client (independence).  Relative URIs in \nreftarget.\n \nJudy: Whatever we choose, let it be the same for direct and redirect. (I count passing \nthrough to the target and responding with 302 as the same - they are different \nmechanisms for copying the target.)  General agreement.\n \nGeoff\u2019s proposal is return 302 on redirect, copy target for direct.  Jim W: depth infinity \ncopy might have lots of 302s, and that seems unacceptable to him.\n\nGeoff could live with either, Jim D also, Judy also.\n\nChuck: If we decide to copy the target, say explicitly in the spec that the result will be a \nresource of the same type as the target, not a reference.\n\nLOCK SEMANTICS\n\nGeoff\u2019s conversation with Yaron: Yaron wants to lock both reference and target, Geoff \ncan\u2019t live with that.\n\nMicrosoft clients count on the behavior Yaron is advocating.\n\nVersioning will introduce references everywhere, and locking the references will result in \nlocking whole trees.  Geoff considers this not acceptable.\n\nJudy: There were some subtle and interesting suggestions at IETF that looked as if they \nwould allow you to lock both the target and (in a sense) the reference, without having the \nconsequence that they would lock whole trees.\n  \nGeoff: These proposals introduce multiple kinds of locks.  It would be difficult for the \nserver to track all these locks.\n\nJudy: What we care about is really just preventing anyone from DELETE or MOVE any \nreference involved in accessing the target.  So apply something like an existence lock to \nany reference on the path to the target, and a write lock to the target.  Why would this be \nso hard? There wouldn\u2019t be many references on any one path to the target.  All the \nreferences are included in the same lock token, and they all get unlocked in the same \noperation.\n  \nAlternatively, you could accomplish the desired without actually creating additional \nlocks, but just requiring the server to prevent anyone from deleting or moving a reference \nwhen its target is locked.\n\nGeoff: Whether to have these sorts of constraints on server behavior is related to the \nconflict between two world views in versioning - whether things are by default mutable \nor by default immutable.\n\nAction Item for Geoff: Write up his position and send it to the mailing list by the end of \nthis week.  We\u2019ll allow a week\u2019s discussion on the list, then make a decision.\n\nDIRECT REFERENCES TO COLLECTIONS\n\nIf you have reference A to collection P/, and P/ has member q, what is the meaning of \nA/q?  Jim W: A is a pointer, you do c-style pointer arithmetic.  There\u2019s only one \nreference, the one identified by A.\n \nJim W: Suppose you have URL /a/q, where /a is a reference but /a/q is not.  What \nhappens if you submit a request with No-Passthrough to /a/q?\n \nGeoff and Judy: No-Passthrough is only relevant to resource identified by the entire \nURL.  If it\u2019s a reference, ok.  Otherwise, the header gets ignored. Jim W could live with \nthis.\n\nWhat if you do a PROPFIND with Depth=1, of A which points to P/?  What are the \nvalues of the hrefs in the response? A/q? P/q? Jim W: Use whatever path the client used.  \nGeoff thinks it\u2019s server-dependent.  Can the values of the hrefs be relative URIs?  What \ndoes 2518 require?  How far does A act like a collection?  Geoff is ok with A/q in hrefs.  \nIs it more work for the server, generating the names?  Probably not.  In CM, you do these \nsorts of naming mappings all the time.\n\nIf you navigate from reference /A through collection /P/ to q, does q know what \ncollection it belongs to?  What collection will the response show q belonging to?\n  \nAction Item for Jim D: Write a discussion of references to collections.  Send to the \nWebDAV mailing list.\n\nChuck: One thing that may be confusing people is that they may be thinking about a \nparticular implementation.  Some implementations might force you to create the \nreferences to collection members whenever you create a reference to a collection.  You \nmight use a flat namespace with all URIs that can be used to access any resource in a \ntable.  Then you are simulating a hierarchical namespace using a flat namespace.\n \nGeoff: Some people seem to think that as soon as you are in reference space, you must \nstay in reference space.  But that\u2019s not true.\n\nWhen we create a reference to a collection, we are implicitly creating a bunch of new \nURLs that aren\u2019t references.  But when we create a reference, we create a new resource \nthat points to another resource. Even though every URL maps to resource, a URL is not a \nreference.  We need to explain the difference between a URL\u2019s relation to a resource and \na reference\u2019s relation to a resource.\n\nREDIRECT REFERENCES TO COLLECTIONS\n\nThe spec currently says (Section 4.16) that if a request-URI contains embedded parts that \nidentify redirect references to collections, you get a 302 response for each of these \nembedded parts in turn. It\u2019s a straightforward calculation to create the value of Location \nfor each of these responses.\n\nJim W: No, you should just fail with 404.  If the redirect points off-server, server doesn\u2019t \nknow whether the target is a collection. There\u2019s no validation of what\u2019s on the other end \nof a reference when it is created.  You\u2019re not doing the client a service by responding \nwith anything other than a 404 when you don\u2019t know whether the URL points to anything \nuseful.\n\nNobody else likes this.  It would mean you can\u2019t get there from here, and would make \nredirect references to collections useless.\n  \nJim D: If you get a 404, you start doing PROPFINDs on pieces of the URL till you find \none that yields a 302?\n\nChuck: Think about what HTTP 1.1 requires for 302s.  Clients are supposed to continue \nusing the same URL, and it should continue to work.  If a downlevel client gets path a/q \nsomehow where a/ is a redirect reference, it should be able to use that URL and continue \nusing it.\n  \nJim D: Why restrict common and meaningful case in order to prevent confusion in \npathological cases?\n\nSuppose A is redirect to ftp://...\n  \nGeoff: Let\u2019s make a best faith effort to help client get to target.  Assume the client knows \nwhat he\u2019s doing.  If eventually the attempt fails, you did your best.\n\nIf /z/ is collection, you can get 404s from things under /z/.  Here, respond with a 302 first, \nthen the other server eventually returns 404.  Jim W wants to think about this.  How does \nthis put constraints on the URL namespace?\n\nREF-TYPE AND REF-TARGET\n\nDecision: Don\u2019t include these headers (or the reftype and reftarget properties) in \nsuccessful responses except for GET and HEAD responses.  Include them in just those \nerror responses that are currently called out in the spec (Ref-Type and Ref-Target with \n404 for dangling references, Ref-Type with 302 responses).  Jim Whitehead will think \nabout additional error responses that may require them when he reviews the spec.\n", "encoding": "Windows-1252"}