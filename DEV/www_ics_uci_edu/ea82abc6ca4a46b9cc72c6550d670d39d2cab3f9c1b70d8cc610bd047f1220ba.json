{"url": "https://www.ics.uci.edu/~dan/class/165/notes/make.html", "content": "<HTML><HEAD>\n<TITLE> Make: a Unix programming aid\n</TITLE>\n</HEAD><BODY>\n\n<H2> Make:&nbsp; a Unix programming aid </H2>\n\nYou should do separate compilation on files,\ncompiling code files (files ending with <tt>.c</tt>)\ninto object files (ending with <tt>.o</tt>), and then\ncreating a final executable version from these.&nbsp;\nThis saves much CPU\ntime since you only really need to recompile the files you have edited\nsince the last compile.&nbsp;\nIt also saves you precious hacking time since\nyou don't have to sit there waiting for your entire program to recompile\nevery time you make a few small corrections.&nbsp;\nThe Unix command <I>make</I> executes compiliation of large programs\naccording to a set of rules you give it.\n<P>\nThe method (not the best -- just a general, simple way which handles\nmost cases reasonably well):\n<P>\nYour program for a given lab should be in a single directory.&nbsp;\nWithin the directory you should have\nall of your code files (<tt>.c</tt>),\nusually one include file (<tt>.h</tt>),\nand a file called <tt>Makefile</tt> or <tt>makefile</tt>.&nbsp;\nLater you will also have some object files (<tt>.o</tt>),\na single executable file, and perhaps some program input and output\nfiles for testing purposes.\n<P>\nThe code files contain all executable code and data declarations.&nbsp;\nAn easy rule is to put each function in a file by itself,\nwith the name of the file corresponding to the name of the function\ncontained therein.&nbsp;\nThere is nothing wrong with putting several (small) related functions\nin each file as long as you can easily remember where you put them.\n<P>\nThe <tt>.h</tt> file contains the compiler directives to insert all\nsystem include files,\nlike <tt>&lt;stdio.h&gt;</tt> and <tt>&lt;math.h&gt;</tt>,\nand all data type and macro definitions.&nbsp;\nThis file should <I>not</I>\ncontain anything that creates a variable, allocates space, or generates\nexecutable code.&nbsp;\nIt <I>should</I> contain all compiler directives which\ndefine data structures, macros, etc.&nbsp;\nThis file should be included at the head of all <tt>.c</tt> files.&nbsp;\nThus all code files will have exactly the same knowledge about\nthe environment in which they coexist.\n<P>\nThe last file, <tt>Makefile</tt>, tells the system how all of your files\nare inter-related, and how to combine them into a program.&nbsp;\n<tt>Makefile</tt> consists of a list of files which need to be generated\nin the process of creating an executable program.&nbsp;\nThis list will include the <tt>.o</tt> files and the final executable\nfile.&nbsp;\nFor each file, there is a list of files that the file depends on,\nand a list of commands (usually just one <tt>gcc</tt> command) that will\ngenerate the file.&nbsp;\nThe syntax is:&nbsp; on a given line you have the name of the file,\na colon, and a list of the files that it depends on,\nseparated by spaces.&nbsp;\nOn the next line, the first character <I>must</I> be a tab\n(not eight spaces -- a <I>real</I> tab character).\nFollowing the tab is a command that should result in the creation\nof the desired file.&nbsp;\nBlank lines between entries are allowed.&nbsp;\nThe following is an example <tt>Makefile</tt>:\n<P>\n<pre>\n#----------- example of a makefile ----------\n\nCC=gcc\n\nmysort: main.o timer.o insert.o quick.o merge.o heap.o\n        $(CC) -o mysort main.o timer.o insert.o quick.o merge.o heap.o -lm\n\nmain.o: main.c my_includes.h\n        $(CC) -c main.c\n\ninsert.o: insert.c my_includes.h\n        $(CC) -c insert.c\n\nquick.o: quick.c my_includes.h\n        $(CC) -c quick.c\n\nmerge.o: merge.c my_includes.h\n        $(CC) -c merge.c\n\nheap.o: heap.c my_includes.h\n        $(CC) -c heap.c\n\n#----------- end of example makefile --------\n</pre>\n<P>\nNotice that all files depend on a simple tree structure of\nprerequisites.&nbsp;\nThe Unix command <tt>make</tt> will read <tt>Makefile</tt> and\nexamine the timestamps on the files involved.&nbsp;\nIt will then invoke only\nthe commands necessary to update branches of the tree that have been\nmodified since the last compile.\n<P>\nAlso notice that <I>all</I> object files rely on the include file.&nbsp;\nIf you change a definition in the include file, you may redefine a data\nstructure or macro whose definition is known to all of the code files,\nso they generally must all be recompiled.&nbsp;\nBut even though the include\nfile is listed as a prerequisite, it is not listed on the compile\ncommand line since it is read in when the <tt>#include</tt> directive is\nencountered on the first line of the <tt>.c</tt> file.&nbsp;\nYou should not need to\nchange the basic definitions in the <tt>.h</tt> file very often, since\nyou should not start coding until you have figured out what\nglobal data structure definitions and other declarations you will need.\n<P>\nNote that include files that are located in the system include directory\nare surrounded by angles (as in <tt>&lt;stdio.h&gt;</tt>) while include\nfiles that are located in directories relative to the current\ndirectory are surrounded by double quotes\n(as in <tt>\"my_includes.h\"</tt>).\n<P>\nIt has been observed that g++ will produce better diagnostics\nthan gcc if there are errors in your programs.&nbsp;\nOther than that, if you write your\nprograms in standard ANSI C as described in Kernighan,\nthere should be no difference.\n<P>\nHere is another example makefile:\n<P>\n<pre>\n# This sets a make variable OBJ to the list of all the files I want to\n# compile together.  Make is smart enough to know that each file that\n# ends in .o comes from a file that ends in .c.\nOBJ = sorts.o insertion.o quick.o heap.o merge.o\n\n# This tells make to use the g++ compiler instead of the default (cc)\n# when it is implicitly producing .o files from .c files.\nCC = g++\n\n# This tells make what flags to use when compiling C programs.  The flag\n# -Wall tells g++ to print all warning messages.  The flag -g tells\n# g++ to generate the extra information required by a symbolic debugger\n# such as gdb.\nCFLAGS = -Wall -g \n\n# This tells make that the main program it is to build\n# is \"sorts\" and that sorts depends on the files listed in the make variable\n# OBJ.  It also gives a command on the second line to compiler the\n# final executable file \"sorts\".  Note that the second line begins\n# with a TAB.  Make is very fussy that command lines begin with TABs.\nsorts : $(OBJ)\n\tg++ $(CFLAGS) -o sorts $(OBJ) /home/dan/165/timer.o\n</pre>\n<P>\n\n<HR>\n<ADDRESS>\n<A HREF=\"http://www.ics.uci.edu/~dan\">\nDan Hirschberg </A> <BR>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3435<BR>\n</ADDRESS>\n<tt>dan (at) ics.uci.edu</tt><br>\nLast modified: Apr 6, 1999\n</BODY></HTML>\n", "encoding": "ascii"}