{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/statements/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Statements</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Statements</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23\r\n<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  Statements are like complete imperative sentences in Java: each commands\r\n    Java to perform some action.\r\n  Just as we said that Java evaluates expressions, we say that Java executes\r\n    statements.\r\n  We already have studied the Java declaration statement, which declares\r\n    variables (and optionally initializes them).\r\n  We will classify many statements as control structures: such statements\r\n    control (conditionally/by repetition) the execution of other statements.\r\n  <p>\r\n  In this lecture we will first learn how to write the simplest kind of\r\n    statement in Java, the expression statement, and the simplest control\r\n    structure in Java, the block statement,\r\n  We will also begin discussing two analysis tools: hand simulation via trace\r\n    tables, and statement boxing (which is the statement equivalent of oval\r\n      diagrams for expressions). \r\n  <p>\r\n  Then we will learn about Java's most important control structures,\r\n    starting with <b>if</b> statements for decisions and simple\r\n    <b>for</b>/<b>break</b> statements for looping.\r\n  We will extend our analysis tools, trace tables and boxing, to cover these\r\n    statements.\r\n  Eventually we will generalize the <b>for</b> loop and cover two variants\r\n    of looping: <b>while</b> and <b>do</b> statements.\r\n  <p>\r\n  Finally, we will begin learning about Java's <b>try-catch</b> statement:\r\n    a control structure that programmers use to process exceptions.\r\n  Sometimes when an operator or method fails by throwing an exception, it\r\n    does not denote a failure of the program, but is just a signal to the\r\n    program that it must take some special action.\r\n  We will continue exploring the use of the <b>try-catch</b> statement in\r\n    our next lecture, in the context of file I/O.\r\n  <p>\r\n  Thus, we can summarize the language features that we learn in this lecture by<p>\r\n  &nbsp &nbsp <i>statement</i> <=\r\n       <i>local-declaration-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>expression-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>block-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>if-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>for-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>break-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>while-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>do-statement</i> |\r\n<br> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp<i>try-catch--statement</i>\r\n<p>\r\n  We will explore the semantics of the following control structures in detail.\r\n  <ul>\r\n    <li>block: execute a sequence of statements in order\r\n    <li>if: decide which statement to execute\r\n    <li>for/while/do loop: repeatedly execute a statement\r\n    <li>break: terminate execution of a loop\r\n    <li>try-catch: execute a sequence of statements; if one throws an\r\n         exception, execute an alternative sequence of statements\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Declaring Variables -->\r\n\r\n<a name=\"Declarations\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Declaring Variables<br>(review and extension)</b></td>\r\n<td width =\"80%\">\r\n  We have already discussed most aspects of the\r\n  <a href=\"../voe/lecture.html#Declarations\">\r\n    <i>declaration-statement</i></a>\r\n  in depth.\r\n  Recall that the simplest declarations start with the type of the variable,\r\n    followed by the name of the variable, ended by a semicolon.\r\n  In more complex variable declarations, we can specify multiple variable\r\n    names (each declared to be the same type, the one that starts the\r\n    declaration), and each variable can be initialized to a value.\r\n  <p>\r\n  We originally specified the EBNF for each declarator as\r\n  <p>\r\n<i>&nbsp &nbsp variable-declarator</i> <= <i>identifier</i> [=<i>expression</i>]  <p>\r\n    and said that <i>expression</i> could be only a literal (the only kind of\r\n    expression we knew at that time).\r\n  Now we know about much more complicated expressions, including literals,\r\n    variables, operators, and methods; we can use all these to declare the\r\n    initial values for variables.\r\n  Pragmatically, most intializations use either literals or calls to the\r\n    <b>Prompt</b> methods, but other form arise less frequently.\r\n  Here are some examples.\r\n<pre><b>  int a = 0;\r\n  int b = Prompt.forInt(\"Enter b\");\r\n  int c = b;\r\n  int d = Math.max(c,1) + 1;</b></pre>\r\n  <p>\r\n  Here the declation of <b>a</b> is intialized using the literal <b>0</b>;\r\n    the declation of <b>b</b> is initialized to the result returned by calling\r\n      the <b>Prompt.forInt</b> method;\r\n    the declation of <b>c</b> is initialized using <b>b</b>, the value of a\r\n      previous declared and intialized variable;\r\n    finally, the declation of <b>d</b> is initialized to the result returned\r\n      by an expression involving a method call, operator, literal, and\r\n      the value of a previously declared variable (<b>c</b>).\r\n  <p>\r\n  In addition, Java allows the keyword <b>final</b> to appear optionally in\r\n   <p>\r\n&nbsp &nbsp <i>local-variable-declaration-statement</i> <= [<b>final</b>] <i>type</i> <i>variable-declarators</i> ;<p> \r\n  Semantically, if such a declaration includes <b>final</b>, then all the\r\n    variables that it declares must include an initializer and the value they\r\n    store must never be changed.\r\n  That is, we cannot use any state-change operators on <b>final</b> variables.\r\n  If we declared\r\n<b><pre>  final double PI = 3.14159265358979323846;</pre></b>\r\n  Then Java would detect and report an error if we later wrote <b>PI = 3.0</b>\r\n  Thus, we can use <b>final</b> to declare named constants, whose value is\r\n    guaranteed by Java not to change.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Expression Statements -->\r\n\r\n<a name=\"ExpressionStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Expression Statements</b></td>\r\n<td width =\"80%\">\r\n  We can make an <i>expression</i> into <i>expression statement</i> by\r\n    appending a semicolon at its end.\r\n  Such a statement tells Java to evaluate the expression.\r\n  The EBNF rule for expression statements is simply\r\n  <p>\r\n  <i>expression-statement</i> <= [<i>expression</i>] ;<br> \r\n  <p>\r\n  In fact, by discarding the option, we can write just the semicolon as the\r\n    simplest kind of expression statement: it is a statement that\r\n    \"does nothing\".\r\n  <p>\r\n  But Java imposes one important syntax constraint on expression statements:\r\n    if the <i>expression</i> option is included\r\n  <ul>\r\n    <li>The <i>expression</i> must apply a state-change operator or a method\r\n          call last in the expression.\r\n  </ul>\r\n  Thus, the following statements are all legal examples of expression\r\n    statements: each satisfies this syntax constraint..\r\n  <pre><b>    average = (score1 + score2 + score3) / 3;\r\n    gameCount++;\r\n    counter1 = counter2 = counter3 = 0;\r\n    System.out.println(\"You have played \"+gameCount+\" games\");</b></pre>\r\n  Recall that most state-change operators have very low precedence, so they\r\n    will naturally be evaluated last in an expression statement.\r\n  Methods whose prototype lists <b>void</b> as the type of the result don't\r\n    return a result anyway.\r\n  Such methods (e.g., <b>System.out.println</b>) are often called last when\r\n    evaluating expression statements.\r\n  <p>\r\n  Note that <b>x+1;</b> is NOT a legal expression statement: the last operator\r\n    that it applies is <b>+</b>, which computes a value but does not process\r\n    this value further: e.g., doesn't store it anywhere; doesn't print it.\r\n  Writing such an expression serves no purpose, and the Java compiler detects\r\n    and reports an error in this case.\r\n  <p>\r\n  Finally, notice that this syntax constraint still allows\r\n    <b>Prompt.forInt(\"Enter values\");</b> as a legal expression statement,\r\n    even though this method returns an <b>int</b> result which is not processed\r\n    further.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Blocks -->\r\n\r\n<a name=\"Blocks\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Block Statements<br>(and scope)</b></td>\r\n<td width =\"80%\">\r\n  Some airlines restrict you to one carry-on bag.\r\n  If you show up with three small bags, they won't let you on the plane; but\r\n    if you buy a fourth, big bag, and put your original three into the\r\n    fourth, everything will be fine.\r\n  <p>\r\n  Java's syntax sometimes forces this same kind of behavior.\r\n  There are places (mostly inside the control structures we will study later\r\n    in this reading) where only one statement is allowed; if you want multiple\r\n    statements there, you must put them inside one big statement.\r\n  That single, big statement is called a <i>block-statement</i>,\r\n    of sometimes just a <b>block</b>.\r\n  The EBNF rule for blocks is \r\n  <p>\r\n  <i>block-statement</i> <= {{<i>statement</i>}}<br> \r\n  <p>\r\n  In this EBNF rule, the outer braces stand for themselves, the inner ones mean\r\n     repetition.\r\n  That is, blocks are some number of statements enclosed in braces.\r\n  So, a block itself is a statement, inside which we can put other statements.\r\n  Although we write this EBNF rule on one line, <b>block</b> statements in our\r\n    code often span many lines, with each statement inside the block appearing\r\n    on its own line, indented in the braces.\r\n  <p>\r\n  Semantically, Java executes a block by sequentially executing the statements \r\n    that it contains (in the exact same order that they appear in the block).\r\n  When giving directions to humans or computers, often the order in which the\r\n    directions are followed is critical.\r\n  If the directions say, \"To disarm the bomb, cut the blue wire and then cut\r\n    the red wire\" it would not be a good idea for us to change the order in\r\n    which these wires are cut.\r\n  <p>\r\n  \r\n  If a statement inside a block declares a variable, that variable can be used\r\n    in <i>subsequent</i> statements <i>inside</i> that block; after Java\r\n    executes all the statements in a block, the block is finished executing,\r\n    and ALL variables declared inside the block become undeclared.\r\n  So, such variables are called <b>local variables</b> because they exist only \r\n    locally, inside the block, while its statements are executing.\r\n  <p>\r\n  Technically, we call all those places that a variable can be used the\r\n    <b>scope</b> of that variable.\r\n  So the scope of local declarations in blocks include all subsequence\r\n    statements in that block.\r\n  <p>\r\n  Blocks themselves can be nested.\r\n  Any variables declared in an outer block can be used in an inner block.\r\n  For example\r\n<pre><b>{ //Outer block\r\n  int x = 1;\r\n  { //Inner block\r\n    System.out.println(x);     //Refers to x in outer block\r\n    x = 3;                     //Refers to x in outer block\r\n  }\r\n  System.out.println(x);\r\n}</b></pre>\r\n  This example illustrates that the scope of the variable <b>x</b> includes the\r\n    whole outer-block, which includes its inner block too.\r\n  The inner block is just one statement that is included in the outer block\r\n    (which is itself one bigger statement).\r\n  In this example, Java prints <b>1</b> followed by <b>3</b>.\r\n  <p>\r\n  If we had moved the declaration from the outer block to the start of the\r\n    inner block, Java would detect and report an error at compile time.\r\n<pre><b>{ //Outer block\r\n  { //Inner block\r\n    int x = 1;\r\n    System.out.println(x);     //Refers to x in inner block\r\n    x = 3;                     //Refers to x in inner block\r\n  }\r\n  System.out.println(x);       //Error! the x in the inner block\r\n                               // is undeclared for this statement.\r\n}</b></pre>\r\n  With this placement, the variable <b>x</b> would not be accessible outside\r\n    the inner block, so it would be unknown in the final print method.\r\n  The scope of <b>x</b> is just the inner block in which it is declared.\r\n</td>\r\n</tbody>\r\n</table>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- A Block of COde-->\r\n\r\n<a name=\"ABlock\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Putting Everything Together</b></td>\r\n<td width =\"80%\">\r\n  Finally, putting together everything that we have learned about Java, the\r\n    following block contains a variety of statements that perform a simple\r\n    computation: declaring variables, prompting the user for values to store\r\n    in these variables (by calling a method), performing a simple calculation\r\n    with these variables (storing the result in another variable with a state\r\n    change operator) and displaying the result in the console window.<pre><b>{        \r\n  double gravity;           //meter/sec/sec\r\n  double height;            //meters\r\n  double time;              //sec\r\n\t\t  \r\n  //Input\r\n  gravity = Prompt.forDouble(\"Enter gravity (in m/s/s)\");\r\n  height  = Prompt.forDouble(\"Enter height of drop (in m)\");\r\n\t\t  \r\n  //Calculate\r\n  time = Math.sqrt(2.*height/gravity);\r\n\t\t  \r\n  //Output\r\n  System.out.println();\r\n  System.out.println(\"Drop time = \" + time + \" secs\");\r\n}</pre></b>\r\n  Note that by intializing variables when they are declared, we could\r\n   \"simplify\" this code, writing it as follows.\r\n  Both blocks ultimate produce the same results.\r\n<pre><b>{  \r\n  //Input      \r\n  double gravity = Prompt.forDouble(\"Enter gravity (in m/s/s)\");\r\n  double height  = Prompt.forDouble(\"Enter height of drop (in m)\");\r\n\r\n  //Calculate\t  \r\n  double time = Math.sqrt(2.*height/gravity);\r\n\t\t  \r\n  //Output\r\n  System.out.println();\r\n  System.out.println(\"Drop time = \" + time + \" secs\");\r\n}</pre></b>\r\n  In fact, there is no need in this program for variables at all!\r\n  We can squeeze this entire program down to just one statement, using the\r\n    <b>\\n</b> escape sequence inside one huge (4 line) output statement.\r\n<pre><b>{  \r\n  System.out.println(\"\\nDrop time = \" + \r\n      Math.sqrt(2.*Prompt.forDouble(\"Enter height of drop (in m)\")\r\n                /Prompt.forDouble(\"Enter gravity (in m/s/s)\")) +\r\n      \" secs\");\r\n}</pre></b>\r\n  Although this program is the smallest yet, it is a bit complicated to follow\r\n    the calculation, which includes two prompts to the user as part of the\r\n    formula being computed.\r\n  Thus, while smaller is generally better, it isn't here; sometimes storing\r\n    partial calculations in nicely named variables helps us to write clearer,\r\n    easier to understand programs (a main goal of ICS-21).\r\n  Of course, if the program needs to use the values entered by the user more\r\n    than once, we should store them in variables to avoid reprompting the user\r\n    for the same information multiple times.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Hand Simulation -->\r\n\r\n<a name=\"HandSimulation\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Hand Simulating State Changes</b></td>\r\n<td width =\"80%\">\r\n  As programmers, we must be able to analyze our programs to verify that they\r\n    are correct, or detect where bugs occur (the hard part) and fix them (an\r\n    easier part).\r\n  The most important way to analyze code is to be able to <i>hand simulate</i>\r\n    it.\r\n  The \"input\" to a hand simulation is\r\n  <ul>\r\n    <li>Variables and their current values (called the initial state)\r\n    <li>A block of code (a sequence of statements)\r\n    <li>If needed, values that the user enters to prompts on the console\r\n  </ul>\r\n  The \"output\" to a hand simulation is\r\n  <ul>\r\n    <li>The same variables and their resulting values, and the contents of the\r\n          console (called the final state)\r\n  </ul>\r\n  During a hand simulation we construct a <i>trace table</i> of state-changes\r\n    for each statement executed in the block of code; these include changes to\r\n    the states of variables and changes to the state of the console (what\r\n    input/output the program does).\r\n  <p>\r\n  Here is a simple example (no input/output) of such a trace table.\r\n  Assume <b>int x=5; int y=8;</b> and the block <b>{x=y; y=x;}</b>\r\n  If beginning students are asked to predict what the code does, the most\r\n    common response is that it swaps the values in <b>x</b> and <b>y</b>.\r\n  Let's see what really happens using a trace table (note that a table cell\r\n    shows the value stored in a variable <i>after</i> the statement on its\r\n    line is finished).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial States</td><td>5</td><td>8</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>x=y;</td><td>8</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>y=x;</td><td>&nbsp</td><td>8</td><td>&nbsp</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  So, we see that the values in the variables are not swapped, but\r\n    that <b>y</b>'s initial value ends up stored in both <b>x</b> and <b>y</b>.\r\n  In some sense, the simplest thing to do with two variables is to exchange\r\n    their values; yet the intuitive way to write code for this task is\r\n    incorrect.\r\n  Don't gloss over this observation, because it is very important.\r\n  The kind of reasoning a programmer does about state changes in code is very\r\n    different from the kind of reasoning a mathematician does about equations.\r\n  <p>\r\n  One correct way to swap the values stored in two variables is:\r\n    <b>{int temp=x; x=y; y=temp;}</b>, and the hand simulation illustrating\r\n    its correctness (using the same initial state).\r\n  <p>  \r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>temp</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial States</td><td>5</td><td>8</td><td>Undeclared</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int temp=x;</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>x=y;</td><td>8</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>y=temp;</td><td>&nbsp</td><td>5</td><td>Undeclared</td><td>&nbsp</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note how <b>temp</b> is shown as undeclared before the block is executed and\r\n    also becomes undeclared  after Java finishes executing the block.\r\n  But <b>temp</b> plays a crucial part in the computation, while Java is\r\n    executing the statements in the block that it is declared in.\r\n  <p>\r\n  As a final example, let's examine the trace table for a block that does\r\n    I/O too.\r\n  Here there are no variables in the initial state: the block to execute is:\r\n    <b><pre>    {\r\n      double x,y;\r\n      x = Prompt.forDouble(\"Enter x\");\r\n      y = Math.pow(x,3.);\r\n      System.out.println(x + \" cubed = \" + y);\r\n    }</pre></b>\r\n  Finally, when prompted, the user will enter a 5.1 on the console.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial States</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>double x,y;</td><td>?</td><td>?</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>x = Prompt.forDouble(\"Enter x\");</td><td>5.1</td><td>&nbsp</td><td>Enter x: 5.1</td>\r\n  <tr valign=\"top\"><td>y = Math.pow(x,3.);</td><td>&nbsp</td><td>132.651</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>System.out.println(x + \" cubed = \" + y);</td><td>Undeclared</td><td>Undeclared</td><td>5.1 cubed = 132.651</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here the <b>Console</b> column shows what is on each line (on the first\r\n    line, the prompt and the value that the user enters; on the second line\r\n    the answer).\r\n  This is certainly a lot of work for such a simple example; but if you can\r\n    easily write such trace tables, you can use them to debug code that has\r\n    much subtler errors.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Boxing Simple Statements -->\r\n\r\n<a name=\"Boxing1\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Boxing Statements</b></td>\r\n<td width =\"80%\">\r\n  Just as we used oval diagrams to understand the structure of expressions\r\n   (and their subexpressions), we will use box diagrams to understand\r\n    statements (and in the case of control structures, their substatements).\r\n  <p>\r\n  Right now we know three kinds of statements: declaration statements,\r\n    expression statements, and block statements.\r\n  Declaration statements and expression statements contain never contain\r\n    substatements; block statements contain substatements: the statements\r\n    that the block executed sequentially.\r\n  The example below includes multiple occurences of each of these kinds of\r\n    statements.\r\n  Each statement appears inside a box.\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/boxed1.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>&nbsp</b></td>\r\n<td width =\"80%\">\r\n  Practice the skill of boxing statements.\r\n  Learn to \"see\" statements inside of statements, the way a programmer does.\r\n  Notice how consistent indenting in the code makes this task easier.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- If Statements -->\r\n\r\n<a name=\"IfStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>if Statements</b></td>\r\n<td width =\"80%\">\r\n  In Java, <b>if</b> statements allow us to choose whether or not to execute\r\n  another statement, or which one of many statements to execute\r\n  (like both the option and alternative forms in EBNF).\r\n<p>\r\n  There are three forms of <b>if</b> statements in Java.\r\n  <ul>\r\n    <li><b>if</b>\r\n    <li><b>if/else</b>\r\n    <li><b>cascaded if</b> or <b>cascaded if/else</b>\r\n  </ul>\r\n  The general form of all <b>if</b> statements is given by one EBNF rule\r\n  <p>\r\n  <i>if-statement</i> <= <b>if (</b><i>expression</i></b>)</b> <i>statement</i> [<b>else</b> <i>statement</i>]\r\n  <p>\r\n  As a syntax constraint, <i>expression</i> must result in a <b>boolean</b>\r\n    value (if it doesn't, the Java compiler detects and reports this error).\r\n  Note that both <b>if</b> and <b>else</b> are keywords in Java, and the test\r\n    expression, no matter how simple or complicated, must always appear inside\r\n    parentheses.\r\n  Finally, although we write this EBNF rule on one line, we write <b>if</b>\r\n    statements in code that span at least two (and often many more) lines, and\r\n    contain indented statements.\r\n  <p>\r\n  An <b>if</b> statement (discarding the option) decides whether or not to\r\n    execute its statement.\r\n  We write it as<pre><b>   if (test)\r\n     statement</b></pre>\r\n  Recall that <b>statement</b> can also be a block.\r\n  Two <b>if</b> statement examples are  <pre><b>   if (x < 0)\r\n     x = -x;\r\n\r\n\r\n   if (myNumber == rouletteNumber) {\r\n     myWins++;\r\n     myPurse += stakes;\r\n   }</b></pre>\r\n   Notice where the opening and closing brace appear for this block: this is\r\n     the standard style that we will always use for blocks inside <b>if</b>\r\n      statements.\r\n   <p>\r\n   Semantically, Java executes an <b>if</b> statement as follows\r\n   <ul>\r\n     <li>Evaluate the <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute the (single) statement after the <b>test</b>.\r\n     <li>If it is <b>false</b>, skip the (single) statement after the <b>test</b>.\r\n   </ul>\r\n  So, if the test evaluates to <b>true</b> in the second example, Java executes\r\n    the block statement; it executes the block by sequentially executing the\r\n    two expression statements that it contains.\r\n  If the test evaluates to <b>false</b> in the second example, Java skips the\r\n    block statement (executing neither of the statements that it contains).\r\n  <p>\r\n  An <b>if/else</b> statement (including the option) decides which one of its\r\n    two statements to execute.\r\n  We write it as<pre><b>   if (test)\r\n     statement<sub>1</sub>\r\n   else\r\n     statement<sub>2</sub></b></pre>\r\n  Recall that <b>statement<sub>1</sub></b> and/or <b>statement<sub>2</sub></b>\r\n    can also be a block\r\n  Two example <b>if/else</b> statements are  <pre><b>\r\n   if (x%2 == 0)     //is x is even?\r\n     x = x/2;\r\n   else\r\n     x = 3*x+1;\r\n\r\n   if (x > y) {\r\n      min = y;\r\n      max = x;\r\n   }else{\r\n      min = x;\r\n      max = y;\r\n   }</pre></b>\r\n   Semantically, Java executes an <b>if/else</b> statement as follows\r\n   <ul>\r\n     <li>Evaluate the <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute <b>statement<sub>1</sub></b>, which\r\n           appears directly after the <b>test</b>, then skip\r\n           <b>statement<sub>2</sub></b>.\r\n     <li>If it is <b>false</b>, skip <b>statement<sub>1</sub></b>, then execute\r\n           <b>statement<sub>2</sub></b>, which appears directly after the\r\n           keyword <b>else</b>.\r\n   </ul>\r\n   So in <b>if/else</b> statements, Java always executes one of the two\r\n     substatements that it controls.\r\n   This is a bit different from the plain <b>if</b> statement, which decides\r\n     whether or not to execute the one statement that it controls.\r\n  <p>\r\n  A <b>cascaded if</b> (or <b>cascaded if/else</b>) decides which one (if any)\r\n    of many statements to execute.\r\n  The general form of the <b>cascade if</b> in Java is<pre><b>   if (test<sub>1</sub>)\r\n     statement<sub>1</sub>\r\n   else if (test<sub>2</sub>)\r\n     statement<sub>2</sub>\r\n   else if (test<sub>3</sub>)\r\n     statement<sub>3</sub>\r\n   else ...\r\n     ...\r\n   else if (test<sub>N</sub>)\r\n     statement<sub>N</sub>\r\n\r\n   <i>or </i>\r\n\r\n   if (test<sub>1</sub>)\r\n     statement<sub>1</sub>\r\n   else if (test<sub>2</sub>)\r\n     statement<sub>2</sub>\r\n   else if (test<sub>3</sub>)\r\n     statement<sub>3</sub>\r\n   else ...\r\n     ...\r\n   else if (test<sub>N</sub>)\r\n     statement<sub>N</sub>\r\n   else\r\n     statement<sub>N+1</sub>\r\n  </b></pre>\r\n  A <b>cascaded if</b> is built from many <b>if/else</b> statements, where\r\n    each of statements in the <b>else</b> part is another <b>if/else</b>\r\n    statement (except possibly the lst one).\r\n  An example <b>cascaded if</b> statement, assuming the declaration\r\n    <b>char grade;</b> is  <pre><b>   if (testScore >= 90)\r\n     grade = 'A';\r\n   else if (testScore >= 80)\r\n     grade = 'B';\r\n   else if (testScore >= 70)\r\n     grade = 'C';\r\n   else if (testScore >= 60)\r\n     grade = 'D';\r\n   else\r\n     grade = 'F';</pre></b>\r\n   Semantically, Java executes a <b>cascaded if</b> statement as follows\r\n   <ul>\r\n     <li>Evaluate the first <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute the statement after the <b>test</b>\r\n           and terminate the <b>cascaded if</b> (don't check any more tests\r\n           or execute any more statements).\r\n     <li>If it is <b>false</b>, evaluate the second <b>test</b> expression.\r\n     <li>If it is <b>true</b>, execute the statement after the <b>test</b> and\r\n           terminate the <b>cascaded if</b> (don't check any more tests\r\n           or execute any more statements).\r\n     <li>Continue following rules of this form until a <b>true</b> test is\r\n           found, or the last test is evaluated.\r\n     <li>If the last test is <b>true</b>, execute the statement after the                  <b>test</b> and terminate the <b>cascaded if</b> (there are no more\r\n           tests to check).\r\n     <li>If the last test is <b>false</b>, and it is an <b>if</b> statement,\r\n           terminate the <b>cascaded if</b>; if it is an <b>if/else</b>\r\n           statement, execute the statement after the <b>else</b> keyword.\r\n   </ul>\r\n   So in the <b>cascaded if</b>, exactly <b>one</b> statement -the one after\r\n     after the first <b>true</b> test is executed; if no tests are\r\n     <b>true</b>, either no statements are executed (when the last statement \r\n     is an <b>if</b>) or the statement after the last <b>else</b> is executed.\r\n   Graphically, we can summarize the control flow in the three kinds of\r\n      <b>if</b>s as\r\n   <p>\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/ifcontrol.gif\"></image><p>\r\n\r\n\r\n<!-- Hand Simulations -->\r\n\r\n<a name=\"HandSimulations\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Hand Simulating if statements</b></td>\r\n<td width =\"80%\">\r\n  We can extend our use of trace tables to hand simulations of <b>if</b>\r\n     statements.\r\n  We include a special <b>Explanation</b> column to indicate the result of\r\n    evaluating <b>test</b> and which statement Java executes next.\r\n  Let's write two trace tables for hand simulating the first <b>if</b>\r\n    statement shown above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>-5</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x < 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>x = -x;</td><td>5</td><td>&nbsp</td><td><b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>5</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x < 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: skip next statement; <b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Next, let's write two trace tables for hand simulating the second\r\n    <b>if/else</b> statement shown above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>min</th><th>max</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>5</td><td>3</td><td>?</td><td>?</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x > y)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>min = y;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>max = x;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>2nd statement in block; block and <b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>x</th><th>y</th><th>min</th><th>max</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>3</td><td>5</td><td>?</td><td>?</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (x > y)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute statement after <b>else</b></td>\r\n  <tr valign=\"top\"><td>min = x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>max = y;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>2nd statement in block; block and <b>if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  What is the trace table for this example if the values stored in <b>x</b> and\r\n    <b>y</b> are equal?\r\n  Does it produce the correct result?\r\n  Can you change the test to &gt= and still always get the same result?\r\n  Can there be two different ways of getting the same result?\r\n  <p>\r\n  Finally, let's write a trace table for hand simulating the\r\n     <b>cascaded if</b> statement shown above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>testScore</th><th>grade</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>73</td><td>?</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (testScore >= 90)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute <b>if</b> in <b>else</b></td>\r\n  <tr valign=\"top\"><td>if (testScore >= 80)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute <b>if</b> in <b>else</b></td>\r\n  <tr valign=\"top\"><td>if (testScore >= 70)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>grade = 'C';</td><td>&nbsp</td><td>'C'</td><td>&nbsp</td><td><b>cascaded if</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- A Clock Example-->\r\n\r\n<a name=\"AClockExample\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Clock Example</b></td>\r\n<td width =\"80%\">\r\n  Let's take a quick look at an interesting task that combines all the\r\n    statements that we have studied.\r\n  Assume that we have declared the following variables for a \"military\" style\r\n    clock: e.g., 00:00 represents midnight, 9:03 represents 9:03am, 14:23\r\n    represents 2:23 pm, and  23:59 represents 11:59pm.\r\n<b><pre>    int minute; //in the range [0,59] inclusive\r\n    int hour;   //in the range [0..23] inclusive</pre></b>\r\n  Also assume that the method <b>emitBeeps</b> takes a single <b>int</b>\r\n    operand and emits that many beeps.\r\n  Finally, assume that the following code is called once a minute by the\r\n    operating system; when we study Java <b>threads</b> we will learn how to\r\n    arrange for such an action to occur repeatedly;.<b><pre>\r\n    if (minute != 59)\r\n      minute++;\r\n    else {\r\n      emitBeeps(hour+1);\r\n      minute = 0;\r\n      if (hour != 23)\r\n        hour++;\r\n      else\r\n        hour = 0;\r\n    }</b></pre>\r\n  Each time the code is called, it advances <b>minute</b> (and <b>hour</b>, if\r\n   necssary) ensuring they store only legal values; on the hour, the code beeps\r\n    that many times (once at 1 am, twice at 2am, ... 12 times at noon, 13 times\r\n    at 1pm, ..., and 24 times at midnight).\r\n  Let's write two trace tables for hand simulating this code in two different\r\n    initial situations: first at 10:15 (10:15am).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>hour</th><th>minute</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>10</td><td>15</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (minute != 59)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>minute++;</td><td>&nbsp</td><td>16</td><td>&nbsp</td><td><b>if/else</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here, the minute is incremented by 1, and nothing else happens.\r\n  <p>\r\n  Now lets write a trace table for the initial situation 22:59 (10:59pm).\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>hour</th><th>minute</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>22</td><td>59</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (minute != 59)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b>: execute statement after <b>else</b></td>\r\n  <tr valign=\"top\"><td>emitBeeps(hour+1);</td><td>&nbsp</td><td>&nbsp</td><td>Beep 23 times</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>minute = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>2nd statement in block</td>\r\n  <tr valign=\"top\"><td>if (hour != 23)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b>: execute next statement</td>\r\n  <tr valign=\"top\"><td>hour++;</td><td>23</td><td>&nbsp</td><td>&nbsp</td><td>inner <b>if/else</b> finished, and outer <b>if/else</b> finished</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Here, much more happens: the clock beeps 23 times (for 11:00pm) and the\r\n    minute is reset to 0 while the hour advances to 23.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- A Caution -->\r\n\r\n<a name=\"ACaution\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Caution: = vs ==<br>in ifs</b></td>\r\n<td width =\"80%\">\r\n  Imagine that you want to write code that doubles the value stored in an\r\n    <b>int</b> variable <b>x</b>, but only if it stores <b>10</b>. \r\n  The following <b>if</b> statement proposes to solve the problem\r\n<pre><b>   if (x = 10)\r\n     x = 2*x;</b></pre>\r\n  Carefully examine the test, it is written as <b>x = 10</b> not\r\n     <b>x == 10</b>.\r\n  Did you see that the first time you read it?\r\n  Most students don't.\r\n  <p>\r\n  It is a common mistake for programmers to write <b>=</b> accidentally\r\n     instead of <b>==</b>  in <b>if</b> tests.\r\n  But the good news is that the Java compiler will detect and report a\r\n   syntax constraint error, because the result type of the test is not\r\n   <b>boolean</b>.\r\n  <p>\r\n  There are situations, though, where the Java compiler will not detect such a\r\n    mistake will not be detected: when the expression itself is of type\r\n    <b>boolean</b>.\r\n  The code on the left uses <b>=</b> and the one on the right uses <b>==</b>.\r\n<pre><b>  boolean doIt = ...;                    boolean doIt = ...;\r\n  if (doIt == true)                        if (doIt = true)\r\n    System.out.println(\"Yes\");               System.out.println(\"Yes\");</b></pre>\r\n  Assume in both cases the the <b>...</b> code evalutes to <b>false</b>.\r\n  The left test evaluates to <b>false</b>, so it does not print the message.\r\n  But the right test stores <b>true</b> into <b>doIt</b> (wiping out the\r\n    value computed before the <b>if</b>) AND evaluates to <b>true</b> (by\r\n    the semantics of the <b>=</b> operator), so it does print the message.\r\n  The Java compiler does not report any error, because the type of the\r\n    expression in both cases is <b>boolean</b>.\r\n  <p>\r\n  This brings us to a style point: writing <b>== true</b> or <b>== false</b>\r\n    in an <b>if</b>'s test is unnecessary, and is prone to error.\r\n  For any <b>boolean</b> expression <b><i>e</i></b>, we can write just\r\n    <b><i>e</i></b> (instead of <b><i>e</i> == true</b>) and\r\n    we can write <b>!<i>e</i></b> (instead of <b><i>e</i> == false</b>).\r\n  Avoiding the <b>true</b> and <b>false</b> literals here is the sign of a\r\n     mature programmer. \r\n  <p>\r\n  Finally, as we have already seen, if you accidentally write the expression\r\n    statement <b>x == 0;</b> the Java compiler will detect and report a\r\n    syntax constraint error, because the last operator applied in this\r\n    expression statement is not a state-change operator.\r\n  Older languages (C and C++) allow these expression statements, and cause\r\n    programmers no  end of debugging problems, so Java disallowed them,\r\n    instead forcing them to be reported during compilation.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Dangling Else -->\r\n\r\n<a name=\"DanglingElse\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Dangling else</b></td>\r\n<td width =\"80%\">\r\n  Examine the following two <b>if</b> statements<pre><b>   if (test<sub>1</sub>)             if (test<sub>1</sub>)\r\n     if (test<sub>2</sub>)             if (test<sub>2</sub>)\r\n       statement<sub>1</sub>             statement<sub>1</sub>\r\n     else                else\r\n       statement<sub>2</sub>           statement<sub>2</sub></b></pre>\r\n  The left code looks like it has an <b>if/else</b> inside an <b>if</b>.\r\n  The right code looks like it has an <b>if</b> inside and <b>if/else</b>.\r\n  But what we see is based on whitespace/indentation.\r\n  What Java sees for both is EXACTLY THE SAME TOKENS:\r\n    <b>if (test<sub>1</sub>) if (test<sub>2</sub>) statement<sub>1</sub> else statement<sub>2</sub></b> because\r\n    whitespace is removed once Java tokenizes a program.\r\n  <p>\r\n  So, Java interprets both code fragments in exactly the same way!\r\n  Which interpretation does Java use for these tokens?\r\n  We need an extra syntax rule that helps us gree on which interpretion is\r\n     the correct one: an <b>else</b> belongs to the most recently seen\r\n     <b>if</b> that it can belong to.\r\n  So, Java uses the left interpretation.\r\n  <p>\r\n  To force the other interpretation, matching the <b>else</b> with the first\r\n     <b>if</b>, we must use a block, and write\r\n<pre><b>   if (test<sub>1</sub>) {\r\n     if (test<sub>2</sub>)\r\n       statement<sub>1</sub>\r\n   }else                 \r\n     statement<sub>2</sub></b></pre>\r\n   Now the <b>else</b> (which is outside the block) cannot possibly belong to\r\n     the <b>if</b> that is inside the block, because all parts of that\r\n     <b>if</b> statement must reside entirely in the block.\r\n   So the final <b>else</b> now belongs with the first <b>if</b>.\r\n  <p>\r\n  This is called th dangling else problem, and it is hard for programmers\r\n    to see.\r\n  We must carefully indent our <b>if</b> statements accurately, to reflect\r\n    which <b>else</b>s belong with which <b>if</b>, otherwise our program will\r\n    contain a subtle error that is very hard for us to locate.\r\n  In fact, some programmers advocate ALWAYS using block in\r\n    <b>if</b>/<b>else</b> statements to avoid dangling elses.\r\n  The disadvantage of this approach is that in simple cases, the extra\r\n    blocks create code that is harder to read.\r\n  We will discuss style principles in more detail later in the quarter.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- If Pragmatics -->\r\n\r\n<a name=\"IfPragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>if Pragmatics</b></td>\r\n<td width =\"80%\">\r\n  When writing decisions, determine the correct form: <b>if</b>,\r\n     <b>if/else</b>, or <b>cascaded if</b>.\r\n  If you are unsure about which one is correct, try the simpler forms first.\r\n  <p>\r\n  Indent the parts of the <b>if</b> and the statements that it contains to\r\n    illustrate the logical structure of the <b>if</b>; when blocks are used,\r\n    place the braces in the positions shown in the examples above.\r\n  Ensure that the indentation (making the code easier for humans to read)\r\n    accurately reflects how Java reads the tokens (e.g., beware of a dangling\r\n    else).\r\n  <p>\r\n  The key to understanding an <b>if</b> statement is understanding its test(s).\r\n  Ensure that for some values of its variables, every test can evaluate to\r\n    both <b>true</b> and <b>false</b> (otherwise the test is probably wrong).\r\n  For example, what is wrong with the following code?\r\n  <p>\r\n  Study it carefully and hand simulate it for a few different values of\r\n    <b>x</b>.\r\n<pre><b>  if (x > 2 || x < 5)\r\n    x++;</b></pre>\r\n  Is this test really the right one?\r\n    probably not: no <b>int</b> value stored in <b>x</b> makes the test\r\n    <b>false</b>; try to find one.\r\n  If it were correctly, we could simplify this code by removing the whole\r\n    <b>if</b> statement, simplifying it to just <b>x++</b>, which always\r\n    performs this action.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- For Statements -->\r\n\r\n<a name=\"ForStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>for Statements</b></td>\r\n<td width =\"80%\">\r\n  In Java, <b>for</b> statements allow us to repeatedly execute\r\n  another statement.\r\n<p>\r\n  To begin, we present a simple, useful, legal, but incomplete, form for the\r\n    <b>for</b> statement.\r\n  The EBNF rule for this simplified <b>for</b> statement is\r\n  <p>\r\n  <i>for-statement</i> <= <b>for(;;)</b> <i>statement</i>\r\n  <p>\r\n  We call <i>statement</i> the <i>body</i> of the <b>for</b> loop.\r\n  Although we write this EBNF rule on one line, we write <b>for</b> statements\r\n    in code that span at least two (and often many more) lines.\r\n  Finally, note that <b>for</b> is a keyword in Java.\r\n  <p>\r\n  The most typical form of the <b>for</b> statement is\r\n<pre><b>   for (;;) {\r\n     statements (i.e. a sequence of statements inside a block)\r\n   }</b></pre>\r\n  Here the body of the <b>for</b> is a block.\r\n  <p>\r\n  Semantically, Java executes the <b>for</b> statement by executing its body\r\n    over and over again.\r\n  Thus, when done executing the body, Java \"loops back\" and re-executes it.\r\n  That is why we often refer to such a statement as a \"for loop\".\r\n  Such a loop runs forever; or, more accurately, until Java executes a\r\n    <b>break</b> statement inside the loop (discussed in the next section)\r\n    forces Java to terminate the loop.\r\n  Two example <b>for</b> loops (each infinite) are  <pre><b>   for (;;)\r\n     System.out.println(\"You're Great!\");\r\n\r\n\r\n   int count = 0;\r\n   for (;;) {\r\n     System.out.println(count);\r\n     count++;\r\n   }</b></pre>\r\n  The first example fills the screen with <b>Your're Great!</b>.\r\n  The second example starts by displaying the value <b>0</b>, then <b>1</b>, then <b>2</b>,\r\n    then <b>3</b>, etc. with the next value displayed becoming larger by one for each\r\n    iteration.\r\n  <p> \r\n  Let's hand simulate this second example and write a trace table for it.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>count</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int count = 0;</td><td>0</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>\r\n  <tr valign=\"top\"><td>System.out.println(count);</td><td>&nbsp</td><td>0</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>1</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.println(count);</td><td>&nbsp</td><td>0<br>1</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>2</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.println(count);</td><td>&nbsp</td><td>0<br>1<br>2</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>3</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>...</td><td>...</td><td>...</td><td>...</td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Of course, this process continues endlessly, so we cannot show a complete\r\n    trace table for this code or any other infinite loop.\r\n  You can always terminate a program in Eclipse by using by pressing the red \r\n    square in the console window, if you suspect your program is in an\r\n    infinite loop and you want to stop it.\r\n<p>\r\n  In the next section, we will explain how the <b>break</b> statement\r\n    allows the program itself to terminate the loop.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Break Statements -->\r\n\r\n<a name=\"BreakStatements\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>break Statements</b></td>\r\n<td width =\"80%\">\r\n  The EBNF rule for the <b>break</b> statement is very simple\r\n  <p>\r\n  <i>break-statement</i> <= <b>break</b>;\r\n  <p>\r\n  Java imposes a syntax constraint that a <b>break</b> statement must appear\r\n    inside the body of some loop.\r\n  Finally, note that <b>break</b> is another keyword in Java.\r\n  <p>\r\n  In real programs, <b>break</b> statements appear inside <b>if</b> statements\r\n    (which themselves are inside the bodies of loops), so a typical example is\r\n<b><pre>   if (count == 0)\r\n     break;</b></pre>\r\n  Semantically, whenever a <b>break</b> statement is executed, Java terminates\r\n    the inner-most loop that it apears in; it <i>breaks</i> out of that loop.\r\n  Terminating a loop means Java next executes the statement AFTER the body of\r\n    the loop (it does not mean that the program terminates).\r\n  By putting a <b>break</b> statement inside an <b>if</b> statement, the\r\n    <b>if</b> can control (based on its <b>test</b>) whether or not the\r\n    <b>break</b> statement is executed: the <b>test</b> determines whether or\r\n    not the loop terminates on this iteration.\r\n  <p>\r\n  A tyical combination of <b>for</b> and <b>break</b> statements is\r\n<pre><b>   int countdown = 3;\r\n   for(;;) {\r\n     System.out.print(countdown + \"...\");\r\n     if (countdown == 0)\r\n       break;\r\n     countdown--;\r\n   }\r\n   System.out.println(\"Blastoff\");</b></pre>\r\n  Let's hand simulate this example and write a trace table for it.\r\n  We call such a <b>for</b>/<b>break</b> combination a <i>count down</i> loop.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <p>\r\n\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>countdown</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int countdown = 3;</td><td>3</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body first time</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>countdown--;</td><td>2</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...2...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>countdown--;</td><td>1</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...2...1...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>countdown--;</td><td>0</td><td>&nbsp</td><td>last statement in block</td>\r\n  <tr valign=\"top\"><td>for(;;) {</td><td>&nbsp</td><td>&nbsp</td><td><b></b> execute body again</td>\r\n  <tr valign=\"top\"><td>System.out.print(countdown + \"...\");</td><td>&nbsp</td><td>3...2...1...0...</td><td>1st statement in block</td>\r\n  <tr valign=\"top\"><td>if (countdown == 0)</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement;</td>\r\n  <tr valign=\"top\"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>\r\n  <tr valign=\"top\"><td>System.out.println(\"Blastoff\");</td><td>&nbsp</td><td>3...2...1...0...Blastoff</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n   We can graphically summarize the control flow in cooperating <b>for</b> and <b>break</b> statements\r\n     as\r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/forbreak.gif\"></image><p>\r\n\r\n\r\n\r\n<!-- More Examples -->\r\n\r\n<a name=\"MoreExamples\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>More for/break Examples</b></td>\r\n<td width =\"80%\">\r\n  Let's look at two more interesting kinds of loops that combine <b>for</b>\r\n     and <b>break</b>.\r\n  The first is called a <i>count up</i> loop: the variable <b>x</b> counts\r\n    up to the value stored in the variable <b>max</b>.\r\n  Notice that <b>max</b> is declared and initialized by the value entered by\r\n    the user.\r\n <b><pre>    int max = Prompt.forInt(\"Enter Number to Sum To\");\r\n    int x   = 0;       //Stores value to add to sum\r\n    int sum = 0;       //Stores sum that x is added to\r\n\r\n    for (;;) {\r\n      if (x == max)\r\n        break;\r\n      x++;\r\n      sum += x;\r\n    }\r\n    System.out.println(\"1+2+...+\" + max + \" = \" + sum);</pre></b>\r\n   Assuming the user enters <b>5</b> when prompted, let's hand simulate these\r\n     statements and write a trace table for it.\r\n</td>\r\n</tbody>\r\n</table>\r\n  <p>\r\n\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>max</th><th>x</th><th>sum</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int max = Prompt(...);</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...: 5&nbsp</td><td>&nbsp</td>\r\n\r\n  <tr valign=\"top\"><td>int x = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int sum = 0;</td><td>&nbsp</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td>\r\n \r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>4</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>10</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>x++;</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>15</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>if (x == max)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement</td>\r\n  <tr valign=\"top\"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>\r\n\r\n  <tr valign=\"top\"><td>System.out.println(...);</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...:5<br>1+2+...+5 = 15</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nThe second example is called a <i>sentinel terminated</i> loop.\r\nHere the user enters a special value (called a sentinel) to inform the program\r\n  that there are no more values to input.\r\nThe sentinel is not processed by the normal code in the loop body<b><pre>    int count = 0;\r\n    int sum   = 0;\r\n    for (;;) {\r\n      int score = Prompt.forInt(\"Enter a Score (-1 to Terminate)\");\r\n      if (score == -1)\r\n        break;\r\n      count++;\r\n      sum += score;\r\n    }\r\n    System.out.println(\"Average = \" + (double)sum/(double)count);</b></pre>\r\n   Assuming the user enters the value <b>3</b>, <b>6</b>, <b>4</b>, and the\r\n     sentinel <b>-1</b> respectively when prompted, let's hand simulate these\r\n     statements and write a trace table for it.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>count</th><th>sum</th><th>score</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int count = 0;</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int sum = 0;</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body first time</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>Enter ...: 3</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= score;</td><td>&nbsp</td><td>3</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>Enter ...: 3<br>Enter ...: 6</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= score;</td><td>&nbsp</td><td>9</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>4</td><td>Enter ...: 3<br>Enter ...: 6<br>Enter ...: 4</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>false</b> skip next (<b>break;</b>) statement; <b>if</b> finished</td>\r\n  <tr valign=\"top\"><td>count++;</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>sum+= score;</td><td>&nbsp</td><td>13</td><td>Undeclared</td><td>&nbsp</td><td>last statement in block</td>\r\n\r\n  <tr valign=\"top\"><td>for (;;) {</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>execute body again</td>\r\n  <tr valign=\"top\"><td>int score = Prompt.forInt(...);</td><td>&nbsp</td><td>&nbsp</td><td>-1</td><td>Enter ...: 3<br>Enter ...: 6<br>Enter ...: 4<br>Enter ...: -1</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>if (score == -1)</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td><b>true</b> execute next (<b>break;</b>) statement</td>\r\n  <tr valign=\"top\"><td>break;</td><td>&nbsp</td><td>&nbsp</td><td>Undeclared</td><td>&nbsp</td><td>terminate <b>for</b> loop</td>\r\n\r\n  <tr valign=\"top\"><td>System.out.println(...)</td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Average = 4.3333333</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n<p>\r\n  Notice that each time that the <b>for</b> loop executes its body, it\r\n    declares, intializes, then undeclares its local variable <b>score</b>.\r\n  This variable could be declared and left uninitialized before the loop, as\r\n    <b>int score;</b> and then appear in the loop as just\r\n    <b>score = Prompt.forInt(\"Enter a Score (-1 to Terminate)\");</b>.\r\n  But because the values stored in this variable are never (and should never\r\n    be)used outside the loop, we have chosen to not even declare this variable\r\n    outside the loop.\r\n  The fact that this variable is declared/undeclared many times does not\r\n    affect the correctness (nor the speed) of this code.\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Compact Trace Tables -->\r\n\r\n<a name=\"Compact\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Compact Trace Tables</b></td>\r\n<td width =\"80%\">\r\n  When we hand simulate programs with complicated control structures, most of \r\n    the trace table is occupied by information relating to control structures\r\n    deciding which statements to execute next, as opposed to statements that\r\n    actually change the state of variables or the console window.\r\n  Such trace tables are cumbersome to create and hard to read.\r\n  <p>\r\n  Compact trace tables remove all the information related to control\r\n     structures, and instead focus on state changes to variables and the\r\n     console window.\r\n  To construct a compact trace table, we list all variables and <b>Console</b>\r\n    in separate columns (and omit <b>Explanation</b>).\r\n  Only when the code changes the state of a variable OR the console window do\r\n    we update information in the appropriate column; and we always do so\r\n    right beneath the last entry for this column.\r\n  <p>\r\n  Note that what we lose in a compact trace table (we gain conciseness) is an \r\n    indication of the order in which different variables have their state\r\n    changed: because each column is shown as compactly as possible (no blank\r\n    entries); there is no correlation among columns whose states changed.\r\n  Here are compact trace tables for the three standard trace tables shown\r\n    above.\r\n  First, the <i>count down</i> loop.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">countdown</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Undeclared</td><td>(blank)</td>\r\n  <tr valign=\"top\"><td>3</td><td>3...</td>\r\n  <tr valign=\"top\"><td>2</td><td>3...2...</td>\r\n  <tr valign=\"top\"><td>1</td><td>3...2...1...</td>\r\n  <tr valign=\"top\"><td>0</td><td>3...2...1...0...</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>3...2...1...0...Blastoff</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Next, the <i>count up</i> loop.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">max</th><th>x</th><th>sum</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>(blank)</td>\r\n  <tr valign=\"top\"><td>5</td><td>0</td><td>0</td><td>Enter Number to Sum To: 5</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>1</td><td>1</td><td>1+2+...+5 = 15</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>2</td><td>3</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>3</td><td>6</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>4</td><td>10</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>5</td><td>15</td><td>&nbsp</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n Finally, the <i>sentinel terminated</i> loop.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">count</th><th>sum</th><th>score</th><th>Console</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>(blank)</td>\r\n  <tr valign=\"top\"><td>0</td><td>0</td><td>3</td><td>Enter a Score (-1 to Terminate): 3</td>\r\n  <tr valign=\"top\"><td>1</td><td>3</td><td>6</td><td>Enter a Score (-1 to Terminate): 6</td>\r\n  <tr valign=\"top\"><td>2</td><td>9</td><td>4</td><td>Enter a Score (-1 to Terminate): 4</td>\r\n  <tr valign=\"top\"><td>3</td><td>13</td><td>-1</td><td>Enter a Score (-1 to Terminate): -1</td>\r\n  <tr valign=\"top\"><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Average = 4.333333</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Remember, in a compact trace table, all the blank entries are at the bottom\r\n    of a column.\r\n  A column entry is filled in only when all the column entries on top of it\r\n    have been filled in.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- General for statement -->\r\n\r\n<a name=\"GeneralFor\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>General for/break; while/do</b></td>\r\n<td width =\"80%\">\r\n  We can write ANY looping code using the <b>for</b> and <b>break</b> that we\r\n    know; but, there is a more general form of the <b>for</b> statement that\r\n    allows use to write many loops more compactly and clearly.\r\n  When we study arrays, iterators, and self referential objects, these forms\r\n    will become more and more useful.\r\n  <p>\r\n  The general <b>for</b> statement packages all the information needed for a\r\n    count-down or count-up loop into one locality, making it easier to read,\r\n    write, and understand.\r\n  The EBNF rule for the general <b>for</b> statement is\r\n  <p>\r\n  <i>expression-list</i> <= <i>expression</i>{<b>,</b><i>expression</i>}<br>\r\n  <i>for-init</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>type variable-declarators</i> | <i>expression-list</i><br>\r\n  <i>for-update</i> &nbsp &nbsp &nbsp <= <i>expression-list</i><br>\r\n  <i>for-statement</i> &nbsp<= [<i>identifier</i>:] <b>for(</b>[<i>for-init</i>]<b>;</b>[<i>expression</i>]<b>;</b>[<i>for-update</i>]<b>)</b> <i>statement</i>\r\n  <p>\r\n  Note that if we discard all the options, we are back at the <b>for(;;)</b>\r\n    statement that we have studied.\r\n  As a syntax constraint, if the <i>expression</i> option (in the middle of the\r\n    semi-colons) is included, its resulting type must <b>boolean</b>: this\r\n    part is called the continuation test.\r\n  Also, each <i>expression</i> in an <i>expression-list</i> must adhere to the\r\n    same constraints as an <i>expression-statement</i>: it must apply a\r\n    state-change operator or a method call last in the expression.\r\n  <p>\r\n  For example, we can use such a <b>for</b> statements to simplify the code\r\n    that sums all the integers up to <b>max</b>.\r\n  <b><pre>  int max = Prompt.forInt(\"Enter Number to Sum To)\";\r\n  int sum = 0;       //Holds Sum of 1..x\r\n\r\n  for (int x=1; x<=max; x++)\r\n    sum += x;\r\n  System.out.println(\"1+2+...+\" + max + \" = \" + sum);</pre></b>\r\n  The <b>for</b> loop is so powerful that it reduces the body of the loop to a\r\n     single expression statement.\r\n  <p>\r\n  Semantically the <b>for</b> loop executes as follows.\r\n  <ol>\r\n    <li>Execute the code specified in <i>for-init</i>\r\n        (in the example, the declaration <b>int x=1</b>: if <i>for-init</i> is\r\n         a declaration, the scope of the variable(s) declared is the\r\n         <b>for</b> statement; any disappear when the loop terminates.\r\n    <li>Evaluate the test as specified in the <b>boolean</b> <i>expression</i>\r\n          (in this example <b>x <= max</b>): if <b>true</b> execute the body\r\n          of the <b>for</b> loop; if <b>false</b> terminate the <b>for</b>\r\n          loop.\r\n        If the <b>expression</b> is omitted, execute the body of the <b>for</b>\r\n          loop.\r\n    <li>After executing the entire body of the <b>for</b>, evaluate\r\n          <i>for-update</i> (in the example <b>x++</b>: note that the last\r\n          operator applied here is a stat-change operator).\r\n    <li>Continue back at step 2 (in the example, checking the continuation\r\n         test for the new value stored in <b>x</b>).\r\n  </ol>\r\n  <p>\r\n  Pictorially, the semantics look like<p>\r\n  <img src=\"images/forcontrol.gif\"></image><p>\r\n  What makes the <b>for</b> loop so powerful is the way it groups together,\r\n    in one locality, all the information that controls the loop.\r\n  Here is a standard (not compact) trace table illustrating these semantics\r\n    in the code above.\r\n  <p>\r\n  <table cellspacing=\"0\" cellpadding=\"5\" border=\"1\" rules=\"all\">\r\n  <thead><tr><th align=\"left\">Statement</th><th>max</th><th>x</th><th>sum</th><th>Console</th><th>Explanation</th>\r\n  </thead>\r\n  <tbody>\r\n  <tr valign=\"top\"><td>Initial State</td><td>Undeclared</td><td>Undeclared</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int max = ...;</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...: 5&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>int sum = 0;</td><td>&nbsp</td><td>&nbsp</td><td>0</td><td>&nbsp</td><td>&nbsp</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>&nbsp</td><td>Initialize; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>1</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>2</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>3</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>6</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>4</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>10</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>5</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>true</b> execute body</td>\r\n  <tr valign=\"top\"><td>sum+= x;</td><td>&nbsp</td><td>&nbsp</td><td>15</td><td>&nbsp</td><td>last statement in body</td>\r\n  <tr valign=\"top\"><td>for (int x=1; x<=max; x++)</td><td>&nbsp</td><td>Undeclared</td><td>&nbsp</td><td>&nbsp</td><td>increment; test is <b>false</b> terminate loop</td>\r\n  <tr valign=\"top\"><td>System.out.println(...);</td><td>&nbsp</td><td>&nbsp</td><td>&nbsp</td><td>Enter ...:5<br>1+2+...+5 = 15</td><td>1st statement AFTER loop body</td>\r\n  </td>\r\n  </tbody>\r\n  </table>\r\n  <p>\r\n  Note that the variable <b>x</b> becomes undeclared after the <b>for</b>\r\n    statement terminates.\r\n  Thus, we cannot refer to it after the <b>for</b> loop's body (where we print\r\n     the statistics); if we did write its name there, the Java compiler would\r\n     detect and report an error.\r\n  If we did want to refer to this value AFTER the <b>for</b> statement\r\n    finishes, we could write\r\n  <b><pre>  int max = Prompt.forInt(\"Enter Number to Sum To)\";\r\n  int sum = 0;       //Holds Sum of 1..x\r\n\r\n  int x = 1;\r\n  for (; x<=max; x++)\r\n    sum += x;\r\n  System.out.println(\"1+2+...+\" + max + \" = \" + sum + \" and x = \" + x);</pre></b>\r\n  Here, <b>x</b> is declared before the <b>for</b> statement, not in it, so it\r\n    remains declared after the <b>for</b> statement finishes.\r\n  Note that in this <b>for</b> statement, nothing appears before the first\r\n    semi-colon. \r\n  <p>\r\n  Finally, a <b>for</b> statement can be named by an <i>identifier</i>\r\n    (see the first option in the EBNF).\r\n  Likewise, there is a more general <b>break</b> statement whose EBNF is\r\n    <p>\r\n    <i>break-statement</i> <= <b>break</b> [<i>identifier</i>] ;\r\n    <p>\r\n  In a simple <b>break</b> statement, Java terminates the inner-most\r\n    loop that the <b>break</b> apears in.\r\n  If a general <b>break</b> statement includes this option, it has a\r\n     syntax constraint that it must appear inside a loop named by that same\r\n     <i>indentifier</i>, and it terminanes that loop.\r\n  This feature is only useful for loops inside loops, and even then it is\r\n    very very rarely needed.\r\n</td>\r\n</tbody>\r\n</table>\r\n<p>\r\n\r\n\r\n<a name=\"WhileDo\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>for,while,do Semantics</b></td>\r\n<td width =\"80%\">\r\n  We will now show the EBNF rule for <b>while</b> and <b>do</b> statements and \r\n    explain their semantics, and the general <b>for</b> statement, by using\r\n    the simple <b>for</b> and <b>break</b> statements.\r\n  The EBNF for <b>while</b> and <b>do</b> statements is\r\n  <p>\r\n  <i>while-statement</i> <= <b>while</b>(<i>expression</i>) <i>statement</i><br>\r\n  <i>do-statement</i> &nbsp &nbsp <= <b>do</b> <i>statement</i> <b>while</b> (<i>expression</i>);\r\n  <p>\r\n  Semantically, we can mechanically translate any general <b>for</b> loop,\r\n    <b>while</b> loop, or <b>do</b> loop into an equivalent simple\r\n    <b>for(;;)</b> loop.\r\n  The Java compiler performs just this kind of transformation when it\r\n    generates the machine instructions corresponding to these kinds of loops.\r\n  <b><pre>\r\n  for (init; continue; update)       {\r\n    statement                          init;\r\n                                       for (;;) {\r\n                                         if ( !(continue) )\r\n                                           break;\r\n                                         statement\r\n                                         update\r\n                                       }\r\n                                      }\r\n\r\n\r\n   while (continue)                   for(;;) {\r\n     statement                          if ( !(continue) )\r\n                                          break;\r\n                                        statement\r\n                                      }\r\n                        or even\r\n\r\n                                     for(;continue;)\r\n                                       statement\r\n\r\n   do                                 for(;;) {\r\n     statement                          statement\r\n   while (continue)                     if ( !(continue) )\r\n                                          break;\r\n                                      }</pre></b>\r\n  For the general <b>for</b> statement example above, this means\r\n  <b><pre>  for (int x=1; x<=max; x++)      {\r\n    sum += x;                       int x=1;\r\n                                    for (;;) {\r\n                                      if (!(x<=max))\r\n                                        break\r\n                                      sum += x;\r\n                                      x++;\r\n                                    }\r\n                                  }</pre></b>\r\n  Note that the value of <b>x</b> is declared inside a special block (the\r\n    outermost one); as described above, this variable disappears when the\r\n    <b>for</b> statement (the outermost block shown above in the translation)\r\n    terminates. \r\n  <p>\r\n  The <b>while</b> and <b>do</b> statements and just variants where the\r\n     continuation condition is always tested first or last in the loop's\r\n     body.\r\n  In the case of the <b>do</b> loop, the body is always executed once.\r\n  Pragmatically, you will see many more <b>while</b> loops than <b>do</b>\r\n    loops.\r\n <p>\r\n Finally, most students have two problems understanding general <b>for</b>\r\n    loops.\r\n <ul>\r\n   <li>They don't realize when the <b>update</b> is done: it is done AFTER the\r\n         loop body, right BEFORE <b>continue</b> is retested.\r\n       Also note that <b>x++</b> and <b>x=x+1</b> are valid expression\r\n         statements that can be used in <b>update</b> (but <b>x+1</b> is not,\r\n         because it contains no state-change operator)\r\n   <li>They try to use the variable declared in <b>init</b> outside the loop,\r\n         after it has terminated: this variable can be used only inside the\r\n         loop.\r\n </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- For/Break Pragmatics -->\r\n\r\n<a name=\"ForBreakPragmatics\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>for/break Pragmatics</b></td>\r\n<td width =\"80%\">\r\n  The following rules can help you synthesize and analyze (to fix bugs) loops.\r\n  When designing iterative code, think in terms of the simple <b>for</b> and\r\n    <b>break</b> statements and determine:\r\n  <ul>\r\n    <li>What statements belong before the loop (initialization code)\r\n    <li>What statements belong inside the body of the loop\r\n    <li>What condition terminates the loop\r\n    <li>Where that condition should be tested inside the loop\r\n  </ul>\r\n  Each iteration should allow some progress towards the termination condition\r\n     of the loop (making the <b>if test true</b>).\r\n  Sometimes it is easier to write the body of the loop first, and then\r\n    determine what initialization is necessary before the loop.\r\n  <p>\r\n  Sylistically, write loops as shown, with block braces as shown and the body\r\n    of the loop slightly indented (typically 2 spaces).\r\n  <p>\r\n  When hand simulating loops, pay special attention to the first few and last\r\n    few iterations (certain kinds of errors occur only at the beginning or\r\n    ending of a loop).\r\n  Ensure that all the variables are properly initialized before they are\r\n    examined in expressions (the Java compiler will help you here).\r\n  Errors due to incorrect initialization are easy to spot if we carefully hand\r\n    simulate the first iteration of a loop (and these are among the most\r\n    frequent category of errors).\r\n  <p>\r\n  The <b>break</b> statement is the most important statement inside a loop.\r\n  Clearly mark <b>break</b> statements using white space and/or special\r\n    comments (e.g., a comment sandwich).\r\n  Ensure that for all possible initial states of its variables, a loop\r\n    eventually terminates (the <b>test</b> in the <b>if</b> statement\r\n    containing the <b>break</b> will always eventually evaluate to\r\n    <b>true</b>).\r\n  <p>\r\n  Most loops, even in industrial code, need one <b>if</b>/<b>break</b>\r\n    combination.\r\n  A loop to solve a very complicated problem may require multiple \r\n    <b>if</b>/<b>break</b> combinations, but they can often be localized\r\n    (grouped together).\r\n  Only a loop that solves the most complicated kind of problems may require\r\n    multiple <b>if</b>/<b>break</b> combinations distributed throughout the\r\n    loop's body.\r\n  <p>\r\n  It is the mark of a good programmer to write simple loops with simple\r\n      terminations.\r\n  The most frequent occuring location for the <b>if</b>/<b>break</b> is the\r\n    first statement in the body of the <b>for</b> loop (try it there first,\r\n    move it elsewhere if necessary).\r\n  Such a <b>for/break</b> combination can also be written as a <b>while</b>\r\n    loop.\r\n  <p>\r\n  Finally, use the general form of the <b>for</b> statement to its maximum \r\n    advantage, to clarify your loops.\r\n  You may use <b>while</b> and <b>do</b> loops, but the extra thought that\r\n    goes into considering them, and the fact that it is often harder to think\r\n    of a \"continuation\" condition rather than a \"termination\" condition, means\r\n    that I use them infrequently, preferring the <b>for/break</b> combination.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Boxing Statements -->\r\n\r\n<a name=\"Boxing2\">\r\n<hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Boxing if, for, and break Statements</b></td>\r\n<td width =\"80%\">\r\n  Continuing our analysis of boxing statements, we illustrate below how to box\r\n    <b>if</b>, <b>for</b> and <b>break</b> statements (as well as expression\r\n    and block statements).\r\n  Notice that EVERYTHING that can be syntactically considered to be a\r\n    statement is in its own box.\r\n  This includes declarations statements (there are none here), expression\r\n    statements, blocks, entire <b>if</b> statements, <b>break</b> statements,\r\n    and entire <b>for</b> statements. \r\n</td>\r\n</tbody>\r\n</table>\r\n<img src=\"images/boxed2.gif\"></image><p>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  General <b>for</b> loops are boxed in a similar manner; none of the\r\n    information within their parentheses are considered statements.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Try-Catch -->\r\n\r\n<a name=\"TryCatch\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>try-catch</b></td>\r\n<td width =\"80%\">\r\n  The EBNF of the <b>try-catch</b> statement is the most complex of any\r\n    control structure that we have seen so far: that is a tipoff that\r\n    programming in Java with exception handling is interesting.\r\n  In fact, many Java courses don't cover exceptions and exception handling\r\n    until much later in the quarter.\r\n  But, I think that the core concepts can be demonstrated early, can be used\r\n    to good advantage in stereotypical ways that are easy to understand, and\r\n    can be returned to repeatedly in more complicated contexts (a spiral\r\n     approach to learning).\r\n  The general form of a <b>try-catch</b> statement is\r\n  <p>\r\n  <i>parameter</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <= <i>type</i> <i>identifier</i><br>\r\n  <i>catch-clause</i> &nbsp  &nbsp &nbsp &nbsp &nbsp &nbsp<= <b>catch</b> (<i>parameter</i>) <i>block-statement</i><br>\r\n  <i>try-catch-statement</i> <= <b>try</b> <i>block-statement</i> {<i>catch-clause</i>}[<b>finally</b> <i>block-statement</i>]\r\n  <p> \r\n  Although we write the <i>try-catch-statement</i> EBNF rule on one line,\r\n    <b>try-catch</b> statements written in our code often span many \r\n    lines (they contain mandatory blocks, which can contain many statements\r\n    on different lines).\r\n  The names of exceptions are actually special reference types.\r\n  Although this is getting a bit ahead of ourselves, we will use the following\r\n    reference types/exception names: <b>ArithmeticException</b>,\r\n    <b>NumberFormatException</b>, <b>IllegalArgumentException</b>,\r\n    <b>IllegalStateException</b>, <b>IOException</b>, and <b>Exception</b>\r\n    (a generic name that includes all the others). \r\n  <p>\r\n  As a syntax constraint, the right hand side of each\r\n    <i>try-catch-statement</i> must have at least one <i>catch-clause</i> or\r\n    one <b>finally</b>; there can be many of the former, and a combination\r\n    of both, but we cannot take 0 repetitions of <i>catch-clause</i> and at\r\n    the same time discard the <b>finally</b> block.\r\n  We could actually encode this restriction in EBNF, but it would make a\r\n    complicated description look even more complex.\r\n  <p>\r\n  The semantics of this statement, as you might expect, are complicated as\r\n    well.\r\n  Java starts a <b>try-catch</b> by sequentially executing the statements\r\n    in the <i>block-statement</i> immediately following the keyword <b>try</b>\r\n   (known as the <b>try</b> block), just as it would execute any block.\r\n  One of two things happen.\r\n  <ul>\r\n    <li>If no statement in the <b>try</b> block throws an exception, after the \r\n         last statement in the block is executed, Java executes the\r\n         <b>finally</b> block (if this option was included).\r\n       Java is now done with the <b>try-catch</b> statement and executes the\r\n          next statement following it.\r\n    <p>\r\n    <li>If some statement in the <b>try</b> block throws an exception, the rest\r\n          of the statements in that block are skipped.\r\n        Java tries to find a <i>catch-clause</i> whose <i>parameter</i>\r\n          matches the name of the exception that was thrown; the generic name\r\n          <b>Exception</b> matches all exception names.\r\n        <ul>\r\n          <li>If the name is found, Java executes its associate block, and\r\n               then Java executes the <b>finally</b> block (if this option was\r\n               included).\r\n              Java is now done with the <b>try-catch</b> statement and executes\r\n                the next statement following it.\r\n          <li>If the name is NOT found, Java executes the <b>finally</b> block\r\n                (if this option was included).\r\n              Java then skips code while it looks for another, more outer\r\n                 <b>try-catch</b> statement: one whose\r\n                 <i>catch-clause</i> does name the exception.\r\n              <ul>\r\n                <li>If one is found, follow the rule above.\r\n                    Note that it DOES NOT return to the original, inner\r\n                    <b>try-catch</b> statement.\r\n                 <li>If one is NOT found, Java terminates the programs, citing\r\n                       an uncaught exception.\r\n                     Typically, this results in a trace: it prints on the\r\n                       console the name of the uncaught exception and what\r\n                       methods were active when the exception was thrown.\r\n              </ul>\r\n        </ul>\r\n  </ul>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- An Example -->\r\n\r\n<a name=\"AnExample\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>A Simple Example</b></td>\r\n<td width =\"80%\">\r\n  In this section we will present a simplified example: it is not useful in\r\n    real programs, but is useful only to illustrate the semantics of \r\n    <b>try-catch</b> statements.\r\n  Recall that the <b>/</b> operator throws an exception named\r\n    <b>ArithmeticException</b> if its second operand is zero.\r\n  Let us examine the effect of placing the following <b>try-catch</b>\r\n    statement in a program.\r\n<pre><b>  int percentage;\r\n  ...some code\r\n  try {\r\n    int attended = Prompt.forInt(\"Enter attendance\");\r\n    int capacity = Prompt.forInt(\"Enter capacity\");\r\n    percentage = 100*attended/capacity;\r\n    System.out.Println(\"percentage computed ok\");\r\n  }\r\n  catch (ArithmeticException a) {\r\n    System.out.println(\"capacity was 0; I'll assume percentage was 100%\");\r\n    percentage = 100;\r\n  }\r\n  ... more code</b></pre>\r\n  Here, if the division succeeds, <b>percentage</b> is set correctly, the\r\n    \"ok\" message is printed, the <b>try</b> block finishes normally, and\r\n    execution continues afterward, where it says <b>...more code</b> \r\n    (because there is no <b>finally</b> block).\r\n  <p>\r\n  On the other hand, if the division fails (throwing\r\n     <b>ArithmeticException</b>), <b>percentage</b> is not set (the <b>=</b>\r\n    operator is never evaluted; it requires the result from the division which\r\n    we have just seen has thrown an exception) the \"ok\" message is skipped as\r\n    Java locates the appropriate <i>catch-clause</i>; both statements in the\r\n    <i>catch-clause</i> block are executed, then the <b>try</b> block finishes,\r\n    and execution again continues afterward, where it says <b>...more code</b>\r\n    (because there is no <b>finally</b> block).\r\n  <p>\r\n  If we replaced <b>ArithmeticException</b> by <b>Exception</b> then the code\r\n    would execute identically, because <b>Exception</b> matches all raised\r\n    exceptions.\r\n  If we replaced <b>ArithmeticException</b> by any other name, say\r\n    <b>IOException</b> then Java would not find a matching exception;\r\n    assuming that there is no outer <b>try-catch</b> statement to catch this\r\n    exception, Java would terminate the program and print a trace on the\r\n    console.\r\n  <p>\r\n  One reason why this example is not realistic is that we can easily check\r\n    whether the division will fail with an <b>if</b> statement and avoid the\r\n    need for a <b>try-catch</b> statement all together.\r\n<pre><b>  int percentage;\r\n  ...some code\r\n  int attended = Prompt.forInt(\"Enter attendance\");\r\n  int capacity = Prompt.forInt(\"Enter capacity\");\r\n  if (capacity != 0) {\r\n    percentage = 100*attended/capacity;\r\n    System.out.Println(\"percentage computed ok\");\r\n  }else {\r\n    System.out.println(\"capacity was 0; I'll assume percentage was 100%\");\r\n    percentage = 100;\r\n  }\r\n  ... more code</b></pre>\r\n  In the following two examples, which are much more realistic, we will need a\r\n    <b>try-catch</b> statement to solve the problem: we cannot use an\r\n    <b>if</b> statement to check whether an exception is about to be thrown.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- A Prompting Example-->\r\n\r\n<a name=\"Prompting\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Prompting with try-catch</b></td>\r\n<td width =\"80%\">\r\n  In this section we will present a more realistic example.\r\n  In fact, similar code appears inside the <b>Prompt.forInt</b> method.\r\n  Understanding how this code works requires a mastery of the semantics of many\r\n    Java statements.\r\n  First, we must know that the <b>Integer.parseInt</b> method (from the Java\r\n    library) has the following prototype\r\n  <pre><b>int Integer.parseInt(String) throws NumberFormatException</b></pre>\r\n  This methods takes a <b>String</b> as an argument.\r\n  If that argument represents the value of a legal integer, it returns that\r\n    value as an <b>int</b>; if it does not represent a legal integer, it\r\n    cannot return any reasonable value, so it throws\r\n    <b>NumberFormatException</b>.\r\n  <p>\r\n  Thus  <b>Integer.parseInt(\"-10\")</b> returns the <b>int -10</b> and\r\n  <b>Integer.parseInt(\"-1x0\")</b> throws <b>NumberFormatException</b>.\r\n  There is no method that Java provides to check whether\r\n    <b>Integer.parseInt</b> will throw an exception: we have to call that\r\n    method to see what it does.\r\n  <p>\r\n  Now, let us see how the following code, a combination of a <b>for</b> loop,\r\n    <b>break</b> statement (not in an <b>if</b>!) and <b>try-catch</b>,\r\n    prompts the usre until he/she enters a valid integer, whose value is\r\n    stored into <b>answer</b>\r\n  <pre><b>  int answer;\r\n  for(;;)\r\n    try {\r\n      answer = Integer.parseInt(Prompt.forString(\"Enter integer\"));\r\n      break;\r\n    }\r\n    catch (NumberFormatException e) {\r\n      System.out.println(\"Error: please enter a valid integer\");\r\n    }\r\n  ...process answer</b></pre>\r\n  Here, the <b>for</b> loop repeatedly executes the <b>try-catch</b> statement.\r\n  First, let us see what happens if the user enters a valid integer.\r\n  During the first iteration of the loop, Java executes the first statement;\r\n    the user enters a valid integer (read as a <b>String</b> that is passed to\r\n    the <b>Integer.parseInt</b> method); so, this method does not throw an\r\n    exception, but instead returns a result that is stored in <b>answer</b>.\r\n  Thus, the second statement in the block is reached; this <b>break</b>\r\n    statement terminates the entire <b>for</b> loop, and execution continue \r\n   after the <b>for</b> loop, where it says <b>...process answer</b>.\r\n  <p> \r\n  Now, let us see what happens if the user enters an INVALID integer.\r\n  During the first iteration of the loop, Java executes the first statement;\r\n    the user enters an invalid integer (read as a <b>String</b> that is passed\r\n    to the <b>Integer.parseInt</b> method); so, this method throws a\r\n    <b>NumberFormatException</b>.\r\n  Java skips the <b>break</b> statement and instead finds the <b>catch</b>\r\n    matching the exception; its following block prints an error message.\r\n  Now the <b>try-catch</b> statement is finished; but this statement is the\r\n    body of a <b>for</b> loop, so it is executed again!\r\n  <p>\r\n  Therefore, this loop will continue executing so long as the user enters an\r\n    invalid integer; the first time that the user enters a valid integer (see\r\n    the description above) its value will be stored into <b>answer</b> and\r\n    the <b>break</b> statement following it will be executed to terminate the\r\n    loop.\r\n  <p>\r\n  So generally, we have designed code that (potentially) repeatedly performs\r\n    some operation until an exception is NOT thrown.\r\n  In the next section, we will design code that repeatedly performs some\r\n    operation until an exception IS thrown: e.g., we are anticipating that\r\n    an exception will eventually terminate the loop, which continues executing\r\n    until it is does.\r\n  Together, these two forms occur frequently in exception handing code.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- A File/Reading Example-->\r\n\r\n<a name=\"FileReading\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Reading Files with try-catch</b></td>\r\n<td width =\"80%\">\r\n  In this section we will present another realistic example.\r\n  In fact, code similar to this will be present in most programs that read\r\n     files.\r\n  First, we must learn that the <b>readInt</b> method (from a Java library\r\n    class that I have written) has the following prototype\r\n  <pre><b>int readInt() throws NumberFormatException, EndOfFileException</b></pre>\r\n  This method skips any white space in a file and returns the next integer\r\n    value that it contains (if it succeeds).\r\n  There are two ways for it to fail, each denoted by a different exception\r\n    name.\r\n  <ol>\r\n    <li>There is a value in the file, but it is not an integer; in this case\r\n          the method throws <b>NumberFormatException</b>.\r\n    <li>There are no more values (of any type) in the file; in this case the\r\n          method throws <b>EndOfFileException</b>.\r\n  </ol>\r\n  The following code assumes the variable <b>inputFile</b> refer to an object\r\n    representing a file (we'll learn more about this in a later lecture).\r\n  It reads every value in a file, accumulating the sum, and ultimately\r\n    printing it.\r\n  <pre><b>  int sum = 0;\r\n  for (;;)\r\n    try {\r\n      int aValue = inputFile.readInt();\r\n      sum += aValue;\r\n    }\r\n    catch (EndOfFileException eofe) {\r\n     break;\r\n    }\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n  Let us see what happens if the file contains two integers.\r\n  <ol>\r\n  <li>Java starts to execute the <b>for</b> loop, which contains just one\r\n     statement: a  <b>try</b> block,\r\n  During this first iteration of the loop, Java executes the first statement in\r\n    the <b>try</b>. block; calling the <b>readInt</b> method reads a valid\r\n    integer from the file and stores into <b>aValue</b>.\r\n  In the next statement the <b>sum</b> is incremented by this value.\r\n  The <b>try</b> block is finished, and the <b>for</b> loop executes it a\r\n    second time.\r\n  <li>During the second iteration of the loop, Java executes the first\r\n    statement in the <b>try</b>. block; calling the <b>readInt</b> method reads\r\n    another valid integer from the file stores into <b>aValue</b>.\r\n  In the next statement the <b>sum</b> is incremented by this new value.\r\n  The <b>try</b> block is finished, and the <b>for</b> loop executes it a\r\n    third time.\r\n  <li>During the third iteration of the loop, Java executes the first\r\n    statement in the <b>try</b>. block; calling the <b>readInt</b> methods\r\n    causes it to throw <b>EndOfFileException</b>, because there are no more\r\n    values in the file to read.\r\n  This error is caught by the <b>catch (EndOfFileException eofe)</b> clause,\r\n     whose block contains a <b>break</b> statement that terminates the\r\n     <b>for</b> loop.\r\n  Java continues by executing the statement after the <b>for</b> loop,\r\n     printing the accumulated sum.\r\n  </ol>\r\n  <p>\r\n  This code repeatedly performs some operation until an exception is\r\n     thrown.\r\n  Note that if a non-integer value appears in the file, then calling the\r\n    <b>readInt</b> method causes it to throw <b>NumberFormatException</b>.\r\n  This exception is not caught by the <b>try-catch</b> shown above, so \r\n    Java terminates the program and prints a trace on the console.\r\n  <p>\r\n  Finally, because the only place that <b>aValue</b> is used is to add to\r\n     <b>sum</b>, we can simplify this code a bit and write.\r\n  <pre><b>  int sum = 0;\r\n  for (;;)\r\n    try {\r\n      sum += inputFile.readInt();\r\n    }\r\n    catch (EndOfFileException eofe) {\r\n      break;\r\n    }\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA, or any other student.\r\n  <ol>\r\n    <li>Explain which of the following state-change expressions are legal and illegal.\r\n        Assume we have declared <b>int a,b,c;</b>.\r\n        <b><pre>   a + b = c;\r\n   a = 2++;\r\n   (a = b) = c;\r\n   a = Prompt.forInt(\"Enter a\") + b;\r\n   a = System.out.println(\"Success!\");</pre></b>\r\n    \r\n    <p>\r\n    <li>In each of the following expression statements, carefully apply your knowledge of syntax\r\n          (tokens, operator precedence, and associativity) and semantics to explain (a) What values\r\n          are stored in all variables whose states are changed. (b) What is the result computed by\r\n          the expression. (c) What oval diagram illustrates parts a and b.\r\n        Assume that each statement is executed just after the declaration <b>int a=3, b=5, c=8;</b>\r\n<b><pre>   a = b++ + c;\r\n   a = b + ++c;\r\n   c = b+++c++;\r\n   a+=b+=c+=1;\r\n   a = b = c + 1;\r\n   a = (b = c) + 1;\r\n   System.out.println(\"\" + ++b + b);\r\n   System.out.println(\"\" + b++ + b);</pre></b>\r\n\r\n    <p>\r\n    <li>Explain what is displayed on the console for the top and bottom block.\r\n        Assume we have declared <b>int i; char c;</b> and that the ASCII equivalent of <b>'A'</b>\r\n          is <b>65</b>.\r\n    <pre><b>   {i = 'A';  System.out.println(i);}\r\n   {c =  65;  System.out.println(c);}</b></pre>\r\n    <p>\r\n\r\n    <li>Show what is displayed in the console window after Java executes the following expression\r\n          statements.\r\n        Be very careful to show which word occurs on which lines.\r\n        Remember that the escape character <b>\\n</b> starts a new line.\r\n    <pre><b>   System.out.print(\"When \" + \"in \");\r\n   System.out.println( \"the \"\r\n        + \"course \"\r\n        + \"of \");\r\n   System.out.print(\"human\\nevents \");\r\n   System.out.print(\"it \");\r\n   System.out.print(\"becomes \");\r\n   System.out.println(\"necessary \");\r\n   System.out.print(\"for one nation to sever...\");</b></pre>\r\n    \r\n    <p>\r\n    <li>Examine the following 6 blocks (all are are permutations of the same three\r\n          statements).\r\n        Classify each block as syntactically legal or illegal (hint: certain statement\r\n          orderings are illegal because they violate a constraint on where a variable\r\n          declared inside a block can be used).\r\n        For those blocks that are legal, determine whether or not they swap of the values\r\n          stored in <b>x</b> and <b>y</b>.<pre><b>        {int temp=x; x=y;        y=temp;}\r\n        {int temp=x; y=temp;     x=y;}\r\n        {x=y;        int temp=x; y=temp;}\r\n        {x=y;        y=temp;     int temp=x;}\r\n        {y=temp;     x=y;        int temp=x;}\r\n        {y=temp;     int temp=x; x=y;}</b></pre>\r\n\r\n    <p>\r\n    <li>Examine each of the following statements; determine whether it is true or\r\n          false (and be prepared to support your answer or show a counter example).\r\n        <ul>\r\n          <li>A block can be empty (contain no statements).\r\n          <li>A block can be unitary (contain 1 statement).\r\n          <li>The statements <b>x=y;</b> and <b>y=x;</b> have identical meanings.\r\n          <li>If we declare <b>int x=5,y=8;</b> and Java executes the expression statement\r\n                <b>x=y;</b> immediately followed by <b>y=3;</b> then\r\n                both <b>x</b> and <b>y</b> now store <b>3</b>.\r\n          <li>A single statement can change the state of more than one variable.\r\n        </ul>\r\n\r\n    <p>\r\n    <li>The following block is rejected at compile time by the Java compiler.\r\n        Write the error message that Java reports.\r\n        Explain why it makes sense to recognize this problem and report the error.\r\n<pre><b>  {\r\n    int a;\r\n    System.out.println(\"a = \" + a);\r\n  }</b></pre>\r\n\r\n    <p>\r\n    <li>Which of the following is easier to understand: the single statement or double statement?\r\n        Verify that both perform the same computation.\r\n<pre><b>  myPurse += stakes + 0*(myWins++);          myWins++;\r\n                                             myPurse += stakes;</b></pre>\r\n    <p>\r\n    <li>Assume that we declare a\r\n          <b>char grade;</b> and guarantee that it stores a letter corresponding\r\n          to a UCI grade: <b>'A'</b>, <b>'B'</b>, <b>'C'</b>, <b>'D'</b>, or <b>'F'</b>.\r\n        Write an <b>if</b> statement that computes the number of quality points for that grade\r\n          and stores it in <b>int qp;</b>\r\n        an A is worth 4, a B is worth 3, a C is worth 2, a D is worth 1, and an R is worth 0.\r\n    <p>\r\n\r\n\r\n\r\n   <li>Assume that we declare\r\n         <b>int hours;</b>\r\n       Write an <b>if</b> statement that computes the pay (in cents) due a worker according the following\r\n         formulas: <b>625*Hours</b> if the hours worked is less than or equal to 40;\r\n         <b>625*Hours + 725*(Hours-40)</b> if the hours worked is greather than 40.\r\n       Store the result in <b>int centsPay;</b>\r\n       Try a few examples under, at, and over 40 hours to verify your statement is correct.\r\n   <p>\r\n\r\n    <li>Assume that we declare \r\n           <b>int x, y; boolean isIt;</b>\r\n         Write a trace table for the hand simulation of the following Java statements: one where\r\n           <b>x</b> stores <b>3</b> and <b>y</b> stores <b>5</b>; and another where \r\n           <b>x</b> stores <b>5</b> and <b>y</b> stores <b>3</b>.\r\n         State whether the results are the same or different in each case.<b><pre>   if (x < y )            if (x < y)\r\n     isIt = true;          isIt = true;\r\n   else                  isIt = false;\r\n     isIt = false;</pre></b>\r\n      Which statement side is equivalent to the expression statement <b>isIt = (x < y);</b>\r\n    <p>\r\n\r\n    <li>Assume that we declare \r\n          <b>int studentAnswer, correctAnswer, wrongCount;</b>\r\n         Explain what is wrong with the following statement (there is a syntax error).<b><pre>   if (studentAnswer == correctAnswer)\r\n   else\r\n     wrongCount++;</pre></b>\r\n      Explain how to fix this problem in a simple way.\r\n    <p>\r\n\r\n    <li>Modify the <b>cascaded if</b> for computing grades, so that <b>grade</b> stores <b>'?'</b> if\r\n           <b>testScore</b> is outside the range <b>0</b> to <b>100</b> inclusive. \r\n     <p>\r\n\r\n     <li>Write a trace table for the clock code, if the clock starts at 11:59pm (one minute before midnight).  \r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>double s, signum;</b>\r\n         Write a cascaded <b>if</b> statement(s) that stores into <b>signum</b> the value <b>-1.</b> if <b>X</b> is less\r\n            than <b>0.</b>; <b>0.</b> if <b>X</b> is equal to <b>0.</b>; <b>1.</b> if <b>X</b> is greater than\r\n            <b>0.</b> \r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>double min, x, max;</b>\r\n         Write a cascaded <b>if</b> statement(s) that stores into <b>x</b> the value <b>min</b> if <b>x</b> is less\r\n            than <b>min</b>; <b>max</b> if <b>x</b> is greater than <b>max</b>; nothing new otherwise.\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>int x,y,z,min;</b>\r\n         Write an <b>if</b> statement(s) that stores into <b>min</b> the minimum of the values stored in\r\n            <b>x</b>, <b>y</b>, and <b>z</b>.\r\n         Try to do this with the minimum amount of code.\r\n     <p>\r\n\r\n     <li>Re-examine the <b>cascade if</b> that computes a course grade.\r\n         Which of the following statements are equivalent to it (do the same thing for all values\r\n           stored in <b>testScore</b>)?<b><pre>    if (testScore >= 60)             if (testScore < 60)\r\n      grade = 'D';                     grade = 'F';\r\n    else if (testScore >= 70)        if (testScore < 70)\r\n      grade = 'C';                     grade = 'D';\r\n    else if (testScore >= 80)        if (testScore < 80)\r\n      grade = 'B';                     grade = 'C';\r\n    else if (testScore >= 90)        if (testScore < 90)\r\n      grade = 'A';                     grade = 'B';\r\n    else                             else\r\n      grade = 'F';                     grade = 'A';</pre></b>\r\n        What simple changes would correct any incorrect code?\r\n     <p>\r\n\r\n     <li>Suppose that we modify the clock code to call <b>emitBeeps</b> at the bottom of its block,\r\n           and also change its argument to just <b>hour</b>.\r\n         Will this code always work as before?\r\n         If not, for what <b>hour</b> and <b>minute</b> combination(s) will it fail?<b><pre>\r\n     if (minute != 59)\r\n       minute++;\r\n     else {\r\n       minute = 0;\r\n       if (hour != 23)\r\n         hour++;\r\n       else\r\n         hour = 0;\r\n       emitBeeps(hour);\r\n     }</pre></b>\r\n        Note that to be correct, the code must be correct for every <b>hour</b> and <b>minute</b>.\r\n        There are 24x60 = 1,440 different possiblities; which ones are crucial to check?\r\n     <p>\r\n\r\n     <li>Suppose that we modify the clock code as follows.\r\n         Will this code always work as before?\r\n         If not, for what <b>hour</b> and <b>minute</b> will it fail?<b><pre>\r\n     minute++;\r\n     if (minute == 60} {\r\n       minute = 0;\r\n       hour++;\r\n       emitBeeps(hour);\r\n       if (hour == 24)\r\n         hour = 0;\r\n     }</pre></b><br>\r\n        Note that to be correct, the code must be correct for every <b>hour</b> and <b>minute</b>.\r\n        There are 24x60 = 1,440 different possiblities; which ones are crucial to check?\r\n     <p>\r\n\r\n     <li>Assume that we declare\r\n           <b>int hour;</b>\r\n         storing the values <b>0</b> through <b>23</b> as described above.\r\n         Write an <b>if</b> statement(s) to display on the console the hour in a standard format:\r\n           e.g., when <b>hour</b>\r\n           stores <b>3</b> display <b>3am</b>; when <b>hour</b> stores 15 display <b>3pm</b>.\r\n         When <b>hour</b> stores <b>0</b> display <b>12midnight</b> and when <b>hour</b> stores\r\n           <b>12</b> display <b>12noon</b>.\r\n         Try to do this with the simplest possible code.\r\n     <p>\r\n\r\n     <li>Write a standard trace table for the following code, when the user enter the value\r\n           <b>3</b>; write a compact trace table for this value, and when the user enters <b>7</b>.     <b><pre>  int cycleCount = 0;\r\n  int test = Prompt.forInt(\"Enter value to test\");\r\n  for (;;) {\r\n    cycleCount++;\r\n\r\n    //////////////\r\n    if (test == 1)\r\n      break;\r\n    //////////////\r\n\r\n    if (test%2 == 0)\r\n      test = test/2;\r\n    else\r\n      test = 3*test + 1;\r\n  }\r\n  System.out.println(\"Finished in \" + cycleCount + \" cycles\");</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>The following two code fragments are identical to the original count down code,\r\n           but the <b>if</b> appears in different locations inside the loop.\r\n         Write a standard trace table for each showing its behavior and results.\r\n         Can you change the <b>test</b> in the <b>if</b> to produce the original results?<b><pre>\r\n   int countdown = 3;\r\n   for (;;) {\r\n     if (countdown == 0)\r\n       break;\r\n     System.out.println(countdown + \"...\");\r\n     countdown--;\r\n   }\r\n   System.out.println(\"Blastoff\");\r\n\r\n\r\n   int countdown = 3;\r\n   for (;;) {\r\n     System.out.println(countdown + \"...\");\r\n     countdown--;\r\n     if (countdown == 0)\r\n       break;\r\n   }\r\n   System.out.println(\"Blastoff\");</pre></b>\r\n  <p>\r\n\r\n  <li>The following code fragment is identical to the original sentinel code,\r\n         but the <b>if</b> appears in a different location inside the loop.\r\n      Write a standard trace table for each showing its behavior and results.<b><pre>    int count = 0;\r\n    int sum   = 0;\r\n    int score;\r\n    for (;;) {\r\n      score = Prompt.forInt(\"Enter a Score (-1 to Terminate)\");\r\n      count++;\r\n      sum += score;\r\n      if (score == -1)\r\n        break;\r\n    }\r\n    System.out.println(\"Average = \" + (double)Sum/(double)Score);</pre></b>\r\n  <p>\r\n\r\n  <li>Rewrite the countdown loop more compactly, so that it uses a general\r\n    <b>for</b> statement (without <b>if</b>/<b>break</b> in its body).\r\n  <p>\r\n\r\n  <li>Rewrite the sentinel loop twice, so that it uses a <b>while</b>\r\n        loop and a <b>do</b> loop.\r\n      It can be done, but what problem arises?\r\n  <p>\r\n\r\n\r\n  <li>The following code can be used to ensure that the user enters a positive value.\r\n      Write a standard trace table for the following code, assuming the user enters the values\r\n        <b>-5</b>, <b>-1</b>, and <b>8</b> respectively.<b><pre>\r\n  int positive;\r\n  for (;;) {\r\n    positive = Prompt.forInt(\"Enter Positive Value\");\r\n\r\n    //////////////\r\n    if (positive >= 1)\r\n      break;\r\n    //////////////\r\n\r\n    System.out.println(\"Sorry, \" + positive + \" isn't postive!\");\r\n  }\r\n  System.out.println(\"positive = \" + positive);</pre></b>\r\n  What changes would be necessary to ensure the user entered a positive and even value?\r\n  <p>\r\n\r\n\r\n  <li>Write a compact trace table for the following code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>7</b>, <b>-3</b>, <b>-7</b>, <b>8</b>, <b>-8</b>, <b>11</b>,\r\n        <b>15</b>, <b>-5</b>, <b>9</b>, and <b>-100</b> respectively.<b><pre>  int zcc = 0;\r\n  int p = Prompt.forInt(\"Enter Value\");\r\n  for (;;) {\r\n    int c;\r\n    c = Prompt.forInt(\"Enter Value\");\r\n\r\n    //////////////\r\n    if (c == -100)\r\n      break;\r\n    //////////////\r\n\r\n    if (p < 0 != c < 0)\r\n      zcc++;\r\n\r\n    p = c;\r\n  }\r\n  System.out.println(\"Final zcc = \" + zcc);</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>Write a compact trace table for the following code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>7</b>, <b>3</b>, <b>7</b>, <b>7</b>, <b>8</b>, <b>11</b>,\r\n        <b>15</b>, <b>5</b>, <b>9</b>, and <b>-1</b> respectively.<b><pre>  int ll = 0;\r\n  int cl = 0;\r\n  int p = Prompt.forInt(\"Enter Value\");\r\n  for (;;) {\r\n    if (cl > ll)\r\n      ll = cl;\r\n   \r\n    int c = Prompt.forInt\"Enter Value\")\r\n\r\n    //////////////\r\n    if (c == -1)\r\n      break;\r\n    //////////////\r\n\r\n    if (p < c)\r\n      cl++;\r\n    else\r\n      cl = 0\r\n\r\n    p = c;\r\n  }\r\n  System.out.println(\"Final ll = \" + ll);</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>Write code (see the previous two problems for inspiration) that determines whether all the\r\n        values it prompts for (use <b>-1</b> as a sentinel) are in strictly increasing order:\r\n        each value is greater than the one that precedes it.\r\n      It should store its final answer in a <b>boolean</b> variable named <b>isIncreasing</b>.\r\n      Write two compact trace tables for your code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>3</b>, <b>5</b>, <b>2</b>, <b>4</b>, and <b>-1</b> the\r\n        first time; and <b>4</b>, <b>5</b>, <b>7</b>, <b>7</b>, <b>-1</b> the second time.\r\n  <p>\r\n\r\n\r\n  <li>Write code that counts the number of strictly increasing pairs\r\n        of values the user enters (use <b>-1</b> as a sentinel).\r\n      It should store its final answer in an <b>int</b> variable named <b>increasingPairCount</b>.\r\n      Write two compact trace tables for your code, assuming the user enters the values\r\n        <b>4</b>, <b>5</b>, <b>3</b>, <b>3</b>, <b>7</b>, <b>6</b>, <b>8</b>, <b>9</b>, <b>2</b>,\r\n        <b>5</b>, <b>4</b>, and <b>-1</b>.\r\n      For this input, it finds 5 pairs: <b>4</b>:<b>5</b>, <b>3</b>:<b>7</b>, <b>6</b>:<b>8</b>,\r\n        <b>8</b>:<b>9</b>, and <b>2</b>:<b>5</b>.\r\n  <p>\r\n\r\n  <li>Explain why the following <b>for</b> loop contains an error spotted by the Java compiler\r\n      <b><pre>  for (int i=1; i<=10; i+1)\r\n    System.out.println(i);</pre></b>\r\n  <p>\r\n\r\n\r\n  <li>Explain what the following <b>for</b> loop displays. Hint: it doesn't display all the\r\n        even numbers from <b>1</b> to <b>10</b>.\r\n      How could we write a <b>for</b> loop to accomplish this task?\r\n      <b><pre>  for (int i=1; i<=10 && i%2==0; i++)\r\n    System.out.println(i);</pre></b>\r\n  <p>\r\n\r\n  <li>Translate the following <b>for</b> loop into a <b>for(;;)</b> loop with a\r\n        <b>break</b> in its body.\r\n      <b><pre>  for (int i=5; i>=0; i--)\r\n    System.out.println(i);</pre></b>\r\n  <p>\r\n\r\n  <li>Assume that we have declared <b>int Width, Height;</b> and stored values into these\r\n        variables.\r\n      Write a pair of nested <b>for</b> loops that print a rectangle of <b>'*'</b> that is\r\n        <b>height</b> by <b>width</b>: e.g., if <b>height</b> was <b>5</b> and <b>width</b>\r\n        was <b>20</b> it would display\r\n      <b><pre>  ******************** \r\n  ******************** \r\n  ******************** \r\n  ******************** \r\n  ********************</pre></b>\r\n\r\n  <li>What is syntactically wrong with the following <b>for</b> loop (be careful)?\r\n      How can we rewrite it to satisfy the syntax but still do the same intended thing?\r\n      <b><pre>    for (int i = 0, double d = 0.0; velocity>0 ; i++,d+=.01)</b></pre> \r\n<p>\r\n\r\n    <li>Suppose that in the prompting code, we always want to set <b>answer</b> to <b>0</b>\r\n          and terminate the loop if the user fails to enter a valid integer.\r\n        Change the code to implement this requirement.\r\n        Hint: this change requires just changing the block in the <i>catch-clause</i>.\r\n    <p>\r\n\r\n    <li>Explain whether or not the code below correctly reads all the\r\n          integer values in a file and prints their sum.\r\n        Note that this code contains a <b>for</b> loop in a <b>try-catch</b>\r\n          statements with no <b>break</b> statement; the original code to\r\n          solve this problem contained a <b>try-catch</b> (with a <b>break</b>\r\n          statement) in a <b>for</b> loop.\r\n  <pre><b>  int sum = 0;\r\n  try {\r\n    for (;;) {\r\n      int aValue = inputFile.readInt();\r\n      sum += aValue;\r\n    }\r\n  }\r\n  catch (EndOfFileException eofe) {}\r\n  System.out.println(\"Sum = \" + sum);</b></pre>\r\n  <p>\r\n\r\n    <li>Suppose that in the file-reading code (from the lecture), we want to\r\n      ignore any non-integer values encountered (but keep reading more\r\n      values until there are no more in the file to read).\r\n      How can we change the code to implement this requirement?\r\n      Why might it be better not just to ignore it, but print an error\r\n        message (and how can this be accomplished)?\r\n      Finally, why can't we modify the code above to solve this problem too?\r\n      Hint: look at how <i>catch-clause</i> appears in the EBNF\r\n          <b>try-catch</b> statements. \r\n      Failing to read an <b>int</b> because some non<b>-int</b> value\r\n          appears in the file will cause Java to throw the \r\n          <b>NumberFormatException</b>.\r\n\r\n  </ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}