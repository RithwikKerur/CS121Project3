{"url": "https://www.ics.uci.edu/~pattis/ICS-33/lectures/iterators.txt", "content": "\t\t\t\tIterators\r\n\r\n\r\nIterators are one of the most useful (and used) features in Python. Besides\r\nbeing used explicitly with for loops (for loop statements and comprehensions),\r\nconstructors often include a parameter that is iterable, whose values are used\r\nto initialize the state of the list/tuple/set/dict objects they are building:\r\ne.g., we write set(alist) to create a set with all the values from alist\r\n(obviously removing duplicates in the process). Also, calls to functions\r\nlike sorted and reversed have iterable arguments and produce list results that\r\nwe can iterate over: e.g., for i in sorted(aset): ... takes an iterable as an\r\nargument and returns a list that Python iterates over.\r\n\r\nIn the next three lectures we will explore iterators in more detail. The first\r\nfocuses on the underlying mechanics of iterators; the second focuses on examples\r\nof iterators written in/for classes; the third introduces a new kind of\r\nfunction-like object (called a generator function, which is more generally\r\nknown in computer science as a coroutine) that returns a value, but when called\r\nagain remembers where it \"left off executing\" to return another value: this\r\nfeature makes writing all sorts of iterators as generators (not as classes)\r\nmuch easier.\r\n\r\nThroughout these lectures we will also discuss iterator efficiency issues (both\r\ntime and space): because iterators are used so often, their running times can\r\ndominate a program's running time; they can often use little space because (like\r\ntuple comprehensions) they produce their values one at a time, rather than\r\nstoring them all in a large data structure that is iterated over (although with\r\nconstructors and comprehensions, we can easily create such a data structure from\r\na iterator, if we need to examine it all at once).\r\n\r\nIn this lecture we will learn about the __iter__ and __next__ methods (which a\r\nclass must implement to be iterated over), how a for loop doing iteration is\r\ntranslated into an equivalent while loop (which needs a try/except block to\r\ncatch the StopIteration exception that is raised by \"exhausted\" iterators), and\r\nhow sharing and mutation affects iterators: sometimes they can cause problems,\r\nand we will learn how to mitigate such problems, although often at the cost of\r\nusing more space to store the iterator (by copying the object to iterate over).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nFor a class to be iterable (i.e., used in any kind of for loop) it must\r\nimplement the iterator protocol, which means both the __iter__ and __next__\r\nmethods. A protocol is just a group of methods that work together to accomplish\r\nsome task. We have already seen the __enter__ and __exit__ methods that work\r\ntogether to implement the context manager protocol. Included in the iterator\r\nprotocol is the StopIteration class, which is an exception raised by __next__ \r\nto signal there are no more values to iterate over (terminating the for loop).\r\nThe builtins module defines the StopIteration class.\r\n\r\nBefore writing any classes that act as iterators, we will explore the semantics\r\nof Python's for loop, by showing how to translate it into an equivalent -but\r\nmore primitive- while loop and the try/except statement. Python translate for\r\nloops into while loops using __iter__ and __next__; the while loop is more\r\nprimitive than the for loop, so we can see more details of how for loops work\r\nby analyzing their equivalent while loops. In this process we will better\r\nunderstand for loops, and also see how to write loops that process iterators in\r\na more intricate way than the straightforward (but simple and very useful) way\r\nthat for loops proccess them.\r\n\r\n------------\r\nfor loop with else Interlude\r\n\r\nBefore discussing this translation, we should first understand how the else\r\nkeyword is used in for/while loops. Since I'm not sure how familiar you are\r\nwith these statements, I'll start at the beginning (but move quickly).\r\n\r\n1) The break statement in Python (just the keyword break as a statement) can be\r\nput in any for/while loop; semantically, when executed it terminates the loop.\r\nI sometimes write loops like\r\n\r\n  while True:\r\n     statements\r\n     if test:\r\n          break\r\n     statements\r\n\r\nIn fact, when the if test: break statement appears FIRST in the the loop, as\r\nshown below,\r\n\r\n  while True:\r\n     if test:\r\n         break\r\n     statements\r\n\r\nwe can write an equivalent while loop that incorporates the test directly\r\n\r\n  while not (test):\t# not is high precedence, so I put test in ()\r\n      statements        # not True and False = (not True) and False = False\r\n                        # not (True and False) = True\r\n\r\n-----Interlude\r\nIn Python \"not\" has a higher pecedence than \"and\", which has a higher precedence\r\nthan \"or\" (think of \"not\" like unary \"-\", \"and\" like \"*\", and \"or\" like \"+\").\r\nThus, in Python the expression\r\n\r\nnot False or True      is equivalent to \r\n(not False) or True    which evaluates to True or True = True; whereas\r\n\r\nnot (False or True)    evaluates to not (True) = False\r\n\r\nAll the logical operators have lower precedence than relational operators, which\r\nhave a lower precedence than arithmetic operators. These orderings make it easy\r\nto write expressions that build relational operators on arithmetic operators and\r\nlogical operators that build on relational operators with few parentheses:\r\nx**2 < 100*math.cos(x) and 3*x+1 >= sqrt(18)\r\n-----End Interlude\r\n\r\nSome programmers/educators banish using breaks in loops, but I think that edict\r\nis too extreme. I could give a long lecture on how programmers (and educators\r\nwho teach programming) feel about break statements. Instead I'll just say the\r\nfollowing. \r\n\r\n  a) When I teach indefinite looping (in ICS-31), I teach the while True/break\r\n     form first. It decouples deciding to loop from how the loop terminates.\r\n     When students need to write a loop, they write an infinite loop first, and\r\n     later decide where to test the \"termination\" condition, and what this\r\n     condition should be; this test can be stated in the \"positive\" form:\r\n     terminate when the test is True (unlike while: keep executing while the\r\n     test is True).\r\n\r\n  b) If that test is the first statement in the loop (as shown above; sometimes\r\n     we need to re-arrange code to get equivalent code with that test first)\r\n     then I will SOMETIMES convert it into a while loop whose test is a\r\n     \"continuation\" condition; the test must be stated in the \"negative\" form:\r\n     terminate when the test is False (equivalent to continue when the test is\r\n     True).\r\n\r\n  c) I think it is much easier to think about termination (stop when some\r\n     specific state occurs) than about continuation (continue in lots of other\r\n     states). Think  about terminating when a value reaches 0 versus continuing\r\n     when the value is any positive number.\r\n\r\n  d) Students sometimes go crazy and write too many different conditional \r\n     breaks inside loops: there is no limit. Programmers need to work hard to\r\n     reduce the number of breaks to simplify their code, but sometimes the\r\n     \"simplest to understand\" code has a few breaks. In fact, we can also\r\n     have conditional breaks in for loops, because they can terminate that kind\r\n     of loop too (since for loops, as we'll see below, are translated into\r\n     while loops): one simple use might be searching over a range of values\r\n     with a for loop, but terminating when a special value is reached.\r\n\r\n  e) Often difficulties with breaks get resolved if we take the loop code we\r\n     are writing and put it in a function, replacing muiltiple breaks by\r\n     multiple returns. Of course some programmers/educators don't like to write\r\n     functions with multiple returns either.\r\n\r\nHere is a cannonical example of a while loop that is more easily understood\r\nwhen written as a while True loop with a conditional break. This is a \"sentinel\"\r\nloop, which sums the values read until a sentinel (-1) is read. It is a \"middle\r\nexit\" loop, because termination is computed in the middle of the body of the\r\nloop.\r\n\r\nsum = 0\r\nwhile True:\r\n    value = prompt.for_int('Enter test score (-1 to terminate)')\r\n    if value == -1:\r\n        break\r\n    sum += value\r\nprint(Sum =',sum)  # we know here the loop exited, so value == -1 is True\r\n\r\nTo use a while test loop (and no conditional break), we would need to write it\r\nwith the following test\r\n\r\nsum = 0\r\nvalue = prompt.for_int('Enter test score (-1 to terminate)')\r\nwhile value != -1:\r\n    sum += value\r\n    value = prompt.for_int('Enter test score (-1 to terminate)')\r\nprint(Sum =',sum)  # we know here the loop exited, so value != -1 is False\r\n\r\nWhat I object to in the code above is the duplicate prompt; in other code there\r\nmight be more even statements duplicated.\r\n\r\n2) The actual syntax of a for/while loops are\r\n\r\nfor index(es) in iterable:\t    \t while boolean-expression:\r\n    block-body \t \t\t\t     block-body\r\n[else:\t\t\t\t\t [else:\r\n    block-else]\t\t\t\t     block-else]\r\n\r\nwhere [else: block-else] is optional (using [] from EBNF).\r\n\r\nSemantically, when each loop terminates (it may terminate \"normally\" or by\r\nexecuting a break inside the block-body), if the else keyword is present and\r\nthe loop terminated normally, then Python executes block-else. So else means:\r\nexecute block-else if the loop didn't execute a break to terminate. In the\r\ncase of the for loop, it means the iterator stopped; in the case of the while\r\nloop it means the boolean-expression finally evaluated to False.\r\n\r\nAs a simple example that illustrates the use of else, we could write the\r\nfollowing code (notice the else is indented at the level of the for, not the if)\r\n\r\nfor i in range(100):\r\n    if special_property(i):\r\n        print(i,'is the first with the special property')\r\n        break\r\nelse:\r\n     print('No value had the special property')\r\n\r\nI don't find myself writing else in loops much, but that might be because I\r\nam new to a language that allows such a feature. As I continue to use Python,\r\nI'll come to a more concrete conclusion about the usefulness of this language\r\nfeature.\r\n------------\r\n\r\nOK, now back to the main event: iterators. Python translates for loops like\r\n\r\n  for index(es) in iterable:  # indexes for unpacked assignment: e.g, key,value\r\n      block-body\r\n  [else:\r\n      block-else]\r\n\r\ninto the following code.\r\n\r\n  _hidden = iter(iterable)\t\t# ultimately calls iterable.__iter__()\r\n  try:\r\n      while True:\r\n          index(es) = next(_hidden)\t# ultimatelyl calls _hidden.__next__()\r\n          block-body\r\n  except StopIteration:\r\n      pass\t\t\t\t# A place-holder, when [] is discarded;\r\n      [block-else]\t\t\t#    the except block cannot be empty\r\n  finally:\r\n    del _hidden\t\t\t\t# Remove _hidden from name_space\r\n\r\nNote that like Python's len function, its iter and next functions translate\r\ninto method calls of __iter__ and __next__ on their argument: e.g.,\r\n\r\ndef iter(i):\r\n    return i.__iter__()\r\n\r\ndef next(i):\r\n    return i.__next__()\r\n\r\nThe key to understanding how iter and next are used in iteration is:\r\n\r\n  The iter function MUST return an object on which next can be called; and\r\n    __next__ is frequently called multiple times (in the while loop).\r\n\r\n  Each call to the next function returns a value and advances the state\r\n    of the iteration, until there are no more values to return; then calling\r\n    next another time raises StopIteration (i.e., when there is no next value\r\n    to iterate over).\r\n\r\nStudy the for/while equivalence carefully. Note that _hidden is a special name\r\nused by Python to translate the for loop (it is not really the name \"_hidden\";\r\nI'm just trying to indicate there is a name, but it hidden from use: it cannot\r\nnamed/accessed by the programmer): it is defined by calling iter(iterable) and\r\ndeleted when the loop terminates. We cannot use this name in our code even if\r\nwe knew it; it can be used only by Python in the translation of the for loop.\r\n\r\nThen Python executes a while True loop INSIDE a try/except statement. Each\r\niteration of the loop binds the next value(s) to be iterated over to index(es)\r\nand then executes block-body. This rebinding/block-body execution continues\r\nuntil either \r\n\r\n  (1) next raises the StopIteration exception, which is handled by causing the\r\n      loop to terminate (the except: is OUTSIDE the loop, so handling the\r\n      exception causes Python to exit the loop, terminating it) and executing\r\n      pass and block-else (if there is one: every except: clause must have at\r\n      least one statement, which pass always satisfies), and finally removing\r\n      the _hidden variable from the namespace (in the finally: clause).\r\n\r\n  (2) block-body itself executes a break statement, which causes the loop to\r\n      terminate. Because there was no exception in the body of the try, the\r\n      try/except terminates without having to handle an exception, and\r\n      therefore does not the execute pass/block-else (if present), and finally\r\n      removes the the _hidden variable from the namespace (in the finally:\r\n      clause).\r\n\r\nIn practice, most for loops do not contain break statements, so (1) happens\r\nmuch more frequently in our code than (2).\r\n\r\nAs a concrete example, the simple for loop\r\n\r\nfor i in range(1,6):       # for the values 1-5\r\n    print(i)\r\n    #break  # uncomment this line to see what break does\r\nelse:\r\n    print('executing else')\r\n\r\nis translated into\r\n\r\n_hidden = iter(range(1,6))\r\ntry:\r\n    while True:\r\n        i = next(_hidden)\r\n        print(i)\r\n        #break  # uncomment thie line to see what break does\r\nexcept StopIteration:\r\n    pass\r\n    print('executing else')\r\nfinally:\r\n    del _hidden\r\n\r\nTry executing both scripts in Eclipse, including uncommenting each break\r\nstatement to observe the effect of executing this statement: it unconditionally\r\nterminates the loop on the first iteration and doesn't print 'executing else'\r\n\r\nNow that we understand the use of the iter/next functions, we can write more\r\ninteresting loops (while loops) that process iterables. For example, suppose\r\nthat we wanted to write a function that returned the sum of the absolute values\r\nof the differences between each adjacent pair of values in an iterable: e.g.,\r\nfor the 5-list [5, 2, 8, 3, 5] it would return the value 16 = 3+6+5+2, where\r\n3 = abs(5-2), 6 = abs(2-8), 5 = abs(8-3), and 2 = abs(3-5).\r\n\r\nThe following simple code works for arguments that can be sliced (like lists)\r\n\r\ndef sum_dif(alist):\r\n    return sum( [abs(a-b) for a,b in zip(alist,alist[1:])] )\r\n\r\nBut, it is not easy to write this function efficiently:\r\n\r\n1) It is inefficient to slice a very large list: Python creates a new/sliced\r\nlist whose length is just one shorter than alist, almost doubling the storage\r\nrequirements.\r\n\r\n2) An arbitrary iterable (i.e., a tuple-comprehension) doesn't even support\r\nslicing (not even indexing). Given the predicate is_prime, the call\r\nsum_diff( i for i in range(1000) if is_prime(i )) would raise the exception\r\nTypeError: 'generator' object is not subscriptable\r\n\r\nWe could use the code below to turn the iterable into a real tuple (or list),\r\nand then slicing that data structure. But that would be space inefficient.\r\n\r\ndef sum_dif(iterable):\r\n    all_values = tuple(iterable)  # same if we used list(iterable)\r\n    return sum( [abs(a-b) for a,b in zip(all_values,all_values[1:])] )\r\n\r\nHere calling sum_dif(range(1_000_000_000)) raise MemoryError (would run out of\r\nstorage) because the tuple comprehension contains more values than can be\r\nsored in the computer.\r\n\r\nWe can write sum_dif without ever turning the iterable into a tuple or list as\r\nfollows, using a variant of the standard for loop code (translated to a while\r\nloop) that we explored above.\r\n\r\ndef sum_dif(iterable):\r\n    answer = 0\r\n    i  = iter(iterable)\r\n    v2 = next(i)\t\t       # get first value (loop moves v2 to v1)\r\n    try:\r\n        while True:                    # next gets one new value in each loop\r\n            v1, v2 = v2, next(i)       # first time, v1 is 1st value, v2 is 2nd\r\n            answer += abs(v1-v2)\r\n    except StopIteration:\r\n        pass\r\n    return answer\r\n\r\nNow, all the calls above (which failed) will work (although iterating over a\r\nbillion values takes a lot of computer time: about 10 minutes on my computer).\r\nThis function has just five names (iterable, answer, i, v1, v2), none of which\r\nis bound to a big data structure: iterable and i are bound to generator\r\nfunctions; and i, v1, and v2 are bound to integers.\r\n\r\nNote that pass is required in this except: clause because we need no block-else;\r\nalso, we did not \"del i\" (i takes the place of _hidden) because as a local\r\nvariable in sum_dif; as a local variable, i will disappear when the function\r\nreturns.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nClasses implementing the iterator protocol: how range really works in Python\r\n\r\nIn this section we will first write a very simple Countdown class and then a\r\nmore complex prange class (pseudo-range) that acts like the real range class\r\nfrom Python's builtins module. Then we will generalize prange by overloading\r\nsome simple operators for it (as the real range class does). I'm not sure how\r\nrange is really implemented, but this implementation seems straight-forward and\r\nefficient.\r\n\r\nI would like the following iterator behavior for Countdown objects. The loop\r\n\r\nfor i in Countdown(10):\r\n    print(str(i)+', ',end='')\r\nprint ('blastoff')\r\n\r\nShould print: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, blastoff\r\n\r\nHere is one class implementing these semantics.\r\n\r\nclass Countdown:\r\n    def __init__(self,start):\r\n        self.start = start\t# self.start never changes; see self.n in __iter__\r\n    \r\n    # __iter__ must return an object on which __next__ can be called; it returns\r\n    # self, which is an object of the Countdown class, which defines __next__.\r\n    # Later we will see a problem with returning self (when the same Countdown\r\n    # object is iterated over in a nested structure), and how to solve that\r\n    # problem. \r\n\r\n    def __iter__(self):\r\n        self.n = self.start\t# n attribute is added to the namespace here \r\n        return self             # (not in __init__) and processed in __next__\r\n    \r\n    def __next__(self):\r\n        if self.n < 0:\r\n            raise StopIteration # can del self.n here, after exhausting iterator\r\n        else:\r\n            answer = self.n\t# or, without the temporary, but more confusing\r\n            self.n -= 1\t\t#  self.n -= 1\r\n            return answer       #  return self.n+1\r\n\r\nIn this class, when __iter__ is called it (re)sets self.n (the value __next__ \r\nwill return first) to self.start (which is set in __init__ and never changes for\r\na constructed object). The __iter__ method has a requirement that it must\r\nreturn an object that defines a __next__ method. Here it returns self, which as\r\nan object constructed from Countdown, defines __next__ (right below __iter__).\r\n\r\nWhen __next__ is called it checks whether self.n has been decremented past 0,\r\nand if is has, raises StopIteration; otherwise it returns the current value\r\nof self.n, but before doing so, it decrements self.n by 1 (by saving it in a\r\nlocal variable, decrementing it, and then returning the saved local value).\r\n\r\nAs a variant in __next__, we could put del self.n directly before the raise\r\nstatement, to remove this attribute from the namespace once the iterator is\r\nexhausted; if we did this, calling __next__ again would raise a NameError when\r\naccessing self.n; the code above, without del, would just raise StopIteration\r\nagain, which is probably a better behavior to implement.\r\n\r\nNote that if we substituted Countdown(-1) in the loop above, its body would be\r\nexecuted 0 times and nothing would be printed before \"blastoff\".\r\n\r\nAlso, the following code counts-down twice; in each for loop __iter__ is called\r\n(recall how it is translated into a while loop), which initializes self.n to 10\r\nbefore calling __next__ multiple times.\r\n\r\ncd = Countdown(10)\r\nfor i in  cd:\r\n    print(str(i)+', ',end='')\r\nprint ('blastoff')\r\n\r\nfor i in  cd:\r\n    print(str(i)+', ',end='')\r\nprint ('blastoff')\r\n\r\nIt print:\r\n\r\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, blastoff\r\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, blastoff\r\n\r\nAgain, at the start of each for loop (see the equivalent while loop), iter is\r\ncalled, which (re)initialize the attribute n to 10.\r\n\r\n------------------------------\r\nQuick interlude: I originally said Python defines iter like len:\r\n\r\ndef iter(i):\r\n    return i.__iter__()\r\n\r\nBut the truth is closer to the following (not completely true yet, but correct\r\nuntil we discuss inheritance). \r\n\r\ndef iter(i):\r\n    x = i.__iter__()\r\n    if '__next__' not in x.__dict__ and '__next__' not in type(x).__dict__:\r\n        raise TypeError('iter() returned non-iterator of type '+type_as_str(x))\r\n    return x\r\n\r\nIf neither the object returned by i.__iter__() nor the class (type) it was\r\nconstructed from defines a __next__  method, then Python raises an exception\r\nimmediately: not waiting for a call of __next__ on the iterator to fail by\r\nraising a NameError exception.\r\n\r\n------------------------------\r\n\r\nprange: initialization (and the meaning of its arguments)\r\n\r\nNow let's aim much higher and write a prange class that operates like the range\r\nclass. Recall there are 3 possible parameters for range: start, stop, and step.\r\nStart has a default value of 0 and step has a default value of 1, but stop\r\n-written between start and step- has no default value. Unfortunately, we CANNOT\r\nwrite the following parameter structure for the __init__ in prange.\r\n\r\n    def  __init__(self,start=0,stop,step=1):\r\n        ....\r\n\r\nbecause prange(5) would be an illegal call: it would bind start to 5 but have\r\nno value to bind for stop; moreover, in this case start should be 0 and stop\r\nshould be bound to 5. More generallly prange(5) should bind the first/only\r\nargument to stop; prange(1,5) should bind the first argument to start and the\r\nsecond to stop; and prange(1,5,2) should bind the first argument to start and\r\nthe second to stop, and the third to step. How can we write such parameters for\r\nsuch an __init__ method?\r\n\r\nHere is the start of the prange class, using *args in __init__ to solve this\r\nparameter problem. The __init__ methods raises exceptions like range: there must\r\nbe 1-3 int arguments and the value of step cannot be 0; the __repr__ method\r\nreturns a string just like range: it always shows start and stop values, but\r\nshows the step value only if it is not 1. It works by looking at *args and\r\ndecoding the meaning of the arguments based on the the number of arguments\r\nactually passed to prange.\r\n\r\nTo run this code, I need to import the type_as_str function from goody.\r\n\r\nclass prange:\r\n    def __init__(self,*args):\r\n        for a in args:\r\n            if not type(a) is int:\r\n                raise TypeError('\\''+type_as_str(a)+'\\' object cannot be interpreted as an integer')\r\n\r\n        self.start, self.step = 0, 1   # defaults for non-required parameters\r\n        if len(args) == 1:\r\n            self.stop = args[0]                       # store single argument\r\n        elif len(args) == 2:\r\n            self.start, self.stop = args              # unpack 2 arguments\r\n        elif len(args) == 3:\r\n            self.start, self.stop, self.step = args   # unpack 3 arguments\r\n            if self.step == 0:\r\n                raise ValueError('3rd argument must not be 0')\r\n        else:\r\n            raise TypeError('range expected at most 3 arguments, got '+str(len(args))) \r\n\r\n    def __repr__(self):\r\n        return 'prange('+str(self.start)+','+str(self.stop)+('' if self.step==1 else ','+str(self.step))+')'\r\n\r\n\r\n------------------------------\r\n\r\nprange: implementing the iteration protocol\r\n\r\nNow let's add the main functionality: the iterator protocol methods. They are\r\nsimilar to but generalize what we wrote in the Countdown class.\r\n\r\n    def __iter__(self):\r\n        self.n = self.start # first value to return from __next__\r\n        return self         # must return object on which __next__ is callable\r\n    \r\n    def __next__(self):\r\n        if self.step > 0 and self.n >= self.stop or\\\r\n           self.step < 0 and self.n <= self.stop:\r\n            raise StopIteration\r\n        answer = self.n\r\n        self.n += self.step\r\n        return answer\r\n\r\nIn this class, when __iter__ is called it (re)sets self.n (the value __next__\r\nwill return) to self.start (which never changes). The __iter__ method has a\r\nrequirement that it must return an object that defines a __next__ method. Here\r\nit returns self, which is an object constructed from prange, which defines\r\n__next__ (right below __iter__).\r\n\r\nWhen __next__ is called it checks whether self.n has reached or exceeded\r\nself.stop (different tests, depending on whether self.step is positive or\r\nnegative: self.step cannot be 0) and raises StopIteration; otherwise it returns\r\nthe current value of self.n but before returning it increments self.n by\r\nself.step (by saving it, incrementing it, returning the saved value). We could\r\navoid the temporary name answer by writing the following code, but it seems\r\nclumsy to me.\r\n\r\n        if self.step > 0 and self.n >= self.stop or\\\r\n           self.step < 0 and self.n <= self.stop:\r\n               raise StopIteration\r\n        self.n += self.step\r\n        return self.n - self.step\r\n\r\nWe discussed similar, but simpler, code in Countdown (there the equivalent of\r\nself.step was always -1).\r\n\r\nTry running various loops or comprehensions using prange objects to ensure that\r\nthis code perform like Python's built-in ranges.\r\n\r\n------------------------------\r\n\r\nprange: overloading operators\r\n\r\nNow we move prange closer to Python's real range class by writing methods that\r\nimplement __len__, __getitem__, __contains__, and __reversed__. All of these\r\nmethods use some fancy mathematics to compute their results, so I won't discuss\r\nhere how these method work in detail (but I encourage you to examine them and\r\ncalculate examples). Note that __reversed__ just returns a new prange object,\r\nbut with different start/stop values and a step that is the opposite sign.\r\n\r\nTo run this code, I need to import math (to use the math's ceiling function:\r\nreturns an integer >= its float/int argument; ceiling(3.9) is 4).\r\n\r\n    def __len__(self):\r\n        if self.step > 0 and self.start >= self.stop or \\\r\n           self.step < 0 and self.start <= self.stop:\r\n            return 0\r\n        else:\r\n            return math.ceil((self.stop-self.start)/self.step)\r\n              \r\n    def __getitem__(self,n):\r\n        if n < 0 or n >= len(self) :  # yes, could be n >= self.__len__()\r\n            raise IndexError(str(self)+'['+str(n)+'] index out of range')\r\n        return self.start+n*self.step\r\n    \r\n    def __contains__(self,n):\r\n        if self.step > 0:\r\n            return self.start<=n<self.stop and (n-self.start)%self.step == 0\r\n        else:\r\n            return self.stop<n<=self.start and abs(n-self.start)%abs(self.step) == 0\r\n        \r\n    def __reversed__(self):\r\n        if self.step > 0:\r\n            return prange(self.start+(len(self)-1)*self.step,self.start-1,-self.step)\r\n        else:\r\n            return prange(self.start+(len(self)-1)*self.step,self.start+1,-self.step)\r\n\r\n\r\n------------------------------\r\n\r\nprange: an alternative implementation (poor use of space and potentially time)\r\n\r\nFor my final topic in this section, I am going to rewrite an alterntaive\r\nimplementation of this class: one that uses __init__ to generate and store the\r\ncomplete list of values that are in a range. I will then discuss the complexity\r\nof the code and some time/space tradeoffs.\r\n\r\nIn this code, the __init__ method computes and remembers start, stop, and step\r\n(but only for use in __repr__). The code at the end of __init__ is a while loop\r\nthat explicitly iterates through all the values in the range, storing each value\r\nin a list. (try to reverse the test and replace True by the continuation\r\ncondition for this loop).\r\n\r\nOnce we have a list with all these values, all the other methods are much\r\nsimpler to implement (they typically just delegate to the list methods to get\r\ntheir jobs done) and require no complicated mathematics to write correctly. The\r\n__iter__ method just delegates to construct an iterator for the list (defined\r\nin the list class); The __next__ method is not defined in this class, because\r\nthe object returned by __iter__ is a list iterator, which has its own __next__ \r\nmethod defined in the list class. len, [], in, and reversed all work by\r\ndelegating to the list.\r\n\r\nfrom goody import type_as_str\r\nimport math\r\nclass prange:\r\n    def __init__(self,*args):\r\n        for a in args:\r\n            if not type(a) is int:\r\n                raise TypeError('\\''+type_as_str(a)+'\\' object cannot be interpreted as an integer')\r\n\r\n        self.start, self.step = 0,1   # defaults\r\n        if len(args) == 1:\r\n            self.stop = args[0]                       # store single argument\r\n        elif len(args) == 2:\r\n            self.start, self.stop = args              # unpack 2 arguments\r\n        elif len(args) == 3:\r\n            self.start, self.stop, self.step = args   # unpack 3 arguments\r\n        elif len(args) == 3:\r\n            self.start, self.stop, self.step = args[0], args[1], args[2]\r\n            if self.step == 0:\r\n                raise ValueError('3rd argument must not be 0')\r\n        else:\r\n            raise TypeError('range expected at most 3 arguments, got '+str(len(args))) \r\n\r\n        # store exactly the range of values into a list\r\n        self.listof = []\r\n        self.n = self.start\r\n        while True:\r\n            if self.step > 0 and self.n >= self.stop or \\\r\n               self.step < 0 and self.n <= self.stop:\r\n                break\r\n            self.listof.append(self.n)\r\n            self.n += self.step\r\n\r\n    def __repr__(self):\r\n        return 'prange('+str(self.start)+','+str(self.stop)+','+('' if self.step==1 else str(self.step))+')'\r\n    \r\n    def __iter__(self):\r\n        return iter(self.listof)\r\n    \r\n    # no need to define __next__: __iter__ returns iter(list) and list defines __next__\r\n\r\n    def __len__(self):\r\n        return len(self.listof)\r\n              \r\n    def __getitem__(self,n):\r\n        return self.listof[n] \r\n       \r\n    def __contains__(self,n):\r\n        return n in self.listof\r\n            \r\n    def __reversed__(self):\r\n        return reversed(self.listof)\r\n\r\nSo what are the tradeoffs between these two implementations? The list\r\nimplementation of the prange class is much simpler (except for the loop in\r\n__init__ to turn a the range into a real list is 8 extra lines: 23 vs 15); it\r\nrequires no complex mathematics (but while such mathematics is hard for us, it\r\nis trivial for the computer). This class can require a huge amount of memory\r\nfor storing a large range (e.g., for prange(1,1_000_000_0000_000)), this\r\nimplementation must store a trillion element list, while the original pranges\r\nalways stores only 4 int attributes (self variables that we can use to generate\r\nall the values in the range -those in the list). Also, __init__ takes a lot\r\nof time to construct such a list (and we might not even iterate over all the\r\nvalues in this prange). Finally, the __contains__ method here takes an amount\r\nof time proportional to the range size (we will study why soon), to search for\r\nthe value in the list; whereas the original implementation computes this value\r\njust by some quick arithmetic, independent of the size of the range.\r\n\r\nAs the quarter goes on, we will study efficiency more formally, but I thought\r\nthis was a good first time to bring up the issue, dealing with alternative\r\nimplementations for the prange class (and its iterator). Again, the main point\r\nhere is that the original prange COMPUTED the values in the range one at a time,\r\nas needed, from 4 atributes; while the list version EXPLICITLY stores all the\r\nvalues in a potentially huge list.\r\n\r\nGenerally, new Python students often create extra data structures that are not\r\nneeded. For example, they read an entire open file into a list and then iterate\r\nover that list, when they could just iterate over the open file: if the file is\r\nhuge, it might not fit in memory as a list; but iterating over an open file\r\njust needs enough space to store one line at a time from the file.\r\n\r\nAlthough I've promoted \"write simple code\" in this course, we should start\r\nthinking about some of the time/space issues of using Python. Often using\r\nPython \"efficiently\" doesn't make the code more complicated.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nSharing list iterators and Mutating list objects that are being iterated over\r\n\r\nExamine the following code\r\n\r\nl = [0,1,2,3,4,5,6,7,8,9]\r\nx = iter(l)\r\ny = iter(l)\r\n\r\nprint(next(x))\r\nprint(next(y))\r\n\r\nprint(next(x))\r\nprint(next(y))\r\n\r\nprint(next(x))\r\nprint(next(y))\r\n\r\nIt defines one list l, and constructs two iterator objects for the list: the\r\nfirst bound to x, the second bound to y. Each call of next(x) refers to one\r\niterator object and each call of next(y) refers to another. Each call advances\r\nthe state of one iterator object. So identical values come out of each\r\niterator: the code prints 0, 0, 1, 1, 2, 2 (two 0s, 1s, and 2s)\r\n\r\nNow change the code to \r\nl = [0,1,2,3,4,5,6,7,8,9]\r\nx = iter(l)\r\ny = x\r\n\r\nNow x and y are bound to the same iterator object. Each call of next is on the\r\nsame OBJECT (whether next(x) or next(y)), which advances the state of that one\r\niterator object. So the print statements above print 0, 1, 2, 3, 4, and 5.\r\n\r\nFinally, what do you think the following code will produce? The big question is,\r\ndoes Python iterate over the values in l when the iterator is CREATED, or does\r\nit iterate over the values of l at the time the iterator is USED? l might have\r\nbeen mutated since the iterator was created.\r\n\r\nl = [0,1,2,3,4,5,6,7,8,9]\r\nx = iter(l)\r\nl.append(10)\r\n\r\ntry:\r\n    while True:\r\n       print(next(x),end=' ')\r\nexcept StopIteration:\r\n    pass\r\n\r\nThe answer is that it iterates over the values of l at the time the iterator\r\nis USED. In this case it prints the integers 0 - 10 (including the 10 added to\r\nthe list after the iterator was created).\r\n\r\nWhat if we change the loop to\r\n\r\ntry:\r\n    while True:\r\n        v = next(x)\r\n        print(v,end=' ')\r\n        if v == 4:\r\n            l[4:7] = ('a','b','c')\r\nexcept StopIteration:\r\n    pass\r\n\r\nIt prints: 0 1 2 3 4 b c 7 8 9, 10. Although 'a' is added to position 4, the\r\nvalue in that position of the list has already been iterated over (returned),\r\nso when __next__ is called again it prints the value in the next position,\r\n'b'. So any mutation we make to a list while it is being iterated over can\r\naffect the results of the iteration.\r\n\r\nNow look at the following code; it causes an infinite loop (printing higher and\r\nhigher values) because for every iteration of the loop, a new value is added to\r\nthe list, increasing the number of values to iterate over.\r\n\r\ni = 0\r\nl = [i]\r\nfor x in l:\r\n    print(x)\r\n    i += 1\r\n    l.append(i)\r\n\r\nSo, the iterator object for a list is keeping track of what index it is on, but\r\nthe list it indexes (from which to get these values) is also growing (its len is\r\nincreasing). We can avoid all these problems by iterating over a COPY of the\r\nlist. There are many ways to create copies of objects (see the copy module, for\r\nexample) but the easiest way to make a copy of a list l is by using the idiom\r\nlist(l) or even l[:]. If we replace\r\n\r\n  for x in l:\r\n\r\n by\r\n\r\n   for x in l[:]:  # or for x in list(l):\r\n\r\nin the example above, only the original list's value (just one 0) is printed. Of\r\ncourse doing so make a copy of the list (using more space).\r\n\r\nIt would be easy to write a variant of a list class whose __iter__ method always\r\nmakes a copy of the list to iterate over, so any changes subsequently made to\r\nthe list will not change the result of the iteration. Of course, a drawback of\r\nthat approach is that it requires extra space to \"remember what the list\r\ncontained when the iterator started\". When we study lots of iterators in the\r\nnext lecture, we will see examples of these kinds of classes. Of course, besides\r\nthe extra space it takes extra time to make a copy, but sometimes it is\r\nworth it (to avoid the problems shown above).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe entire original prange (59 lines)\r\n\r\nfrom goody import type_as_str\r\nimport math\r\nclass prange:\r\n    \r\n    def __init__(self,*args):\r\n        for a in args:\r\n            if not type(a) is int:\r\n                raise TypeError('\\''+type_as_str(a)+'\\' object cannot be interpreted as an integer')\r\n\r\n        self.start, self.step = 0,1   # defaults\r\n        if len(args) == 1:\r\n            self.stop = args[0]                       # store single argument\r\n        elif len(args) == 2:\r\n            self.start, self.stop = args              # unpack 2 arguments\r\n        elif len(args) == 3:\r\n            self.start, self.stop, self.step = args   # unpack 3 arguments\r\n        elif len(args) == 3:\r\n            self.start, self.stop, self.step = args[0], args[1], args[2]\r\n            if self.step == 0:\r\n                raise ValueError('3rd argument must not be 0')\r\n        else:\r\n            raise TypeError('range expected at most 3 arguments, got '+str(len(args))) \r\n\r\n    def __repr__(self):\r\n        return 'prange('+str(self.start)+','+str(self.stop)+','+('' if self.step==1 else str(self.step))+')'\r\n    \r\n    def __iter__(self):\r\n        self.n = self.start\r\n        return self # must return an object on which __next__ can be called\r\n    \r\n    def __next__(self):\r\n        if self.step > 0 and self.n >= self.stop or \\\r\n           self.step < 0 and self.n <= self.stop:\r\n            raise StopIteration\r\n        save = self.n\r\n        self.n += self.step\r\n        return save\r\n\r\n    def __len__(self):\r\n        if self.step > 0 and self.start >= self.stop or \\\r\n           self.step < 0 and self.start <= self.stop:\r\n            return 0\r\n        else:\r\n            return math.ceil((self.stop-self.start)/self.step)\r\n              \r\n    def __getitem__(self,n):\r\n        if n < 0 or n >= len(self) :  # yes, could be n >= self.__len__()\r\n            raise IndexError('range('+str(self)+') index('+str(n)+') out of range')\r\n        return self.start+n*self.step\r\n    \r\n    def __contains__(self,n):\r\n        if self.step > 0:\r\n            return self.start<=n<self.stop and (n-self.start)%self.step == 0\r\n        else:\r\n            return self.stop<n<=self.start and abs(n-self.start)%abs(self.step) == 0\r\n        \r\n    def __reversed__(self):\r\n        if self.step > 0:\r\n            return prange(self.start+(len(self)-1)*self.step,self.start-1,-self.step)\r\n        else:\r\n            return prange(self.start+(len(self)-1)*self.step,self.start+1,-self.step)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n------------------------------------------------------------------------------\r\n\r\nProblems:\r\n\r\n1)Is the following translation of a for loop also equivalent to the translation\r\nof the for loop shown above? Argue they are equivalent of show an example where\r\ntheir execution differs.\r\n\r\n_hidden = iter(iterable)\r\nwhile True:\r\n    try:\r\n        indexes = next(_hidden)\r\n        block-body\r\n    except StopIteration:\r\n        [block-else]\r\n        break\r\n    finally:\r\n        del _hidden\r\n\r\n2) Write the class Random_N which is constructed with an integer argument and \r\nproduces that many random values.\r\n\r\n3) Define a function named first, which takes any iterable and a predicate\r\nfunction (takes one argument, returns a bool) as arguments, and uses a for loop\r\nto returns the first value in the iterable for which the predicate is True; or,\r\nit raises the ValueError exception if the predicate is True for none of the\r\niterator's values.\r\n\r\n4) Translate the following iteration to use a while loop and explicit calls to\r\n__iter__ and __next__.\r\n\r\nfor c in 'abcdefg':\r\n    print(c)\r\n\r\n5) Define a function named group_n, which takes any iterable and an int as\r\narguments, and returns a list of a list of the first n values, a list of the\r\nsecond n values, etc. in the iterable; if the iterable raises StopIteration\r\nbefore the last group of n values can be collected, ignore those. For example,\r\ngroup_n('abcdefghijklmn',3) returns the list of lists:\r\n[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l']]\r\n\r\n6) The fibonacci sequence is defined as 1, 1, 2, 3, 5, 8, 13, 21, ... where the\r\n1st and 2nd fibonacci numbers are 1 and 1, and all subsequent numbers are the\r\nsum of the prior two. Define a class named fib_range that is initialized by two\r\nvalues (the index of the first and last fibonacci number inclusive), and whose\r\niterator generates all the fibonacci numbers in the range. For example, the\r\ncomprehension [i for i in fib_range(4,6)] creates the list [3, 5, 8]\r\n\r\n7) Define a method named len_remaining which returns an int indicating how many\r\nmore values a prange iterator object will iterate over. Initially len and\r\nlen_remaining would return the same result, but for every time __next__ is\r\ncalled,  len_remaining returns a value one less.\r\n\r\n8) Re-examine the __reversed__ method in prange. Explain why it is incorrect to\r\nsimplify this method to the following: for what kinds of values does it work\r\nand for what kind does it fail?\r\n\r\n    def __reversed__(self):\r\n        if self.step > 0:\r\n            return prange(self.stop-1 ,self.start-1, -self.step)\r\n        else:\r\n            return prange(self.stop+1 ,self.start+1, -self.step)\r\n\r\n9) Examine the difference between the following code and what is produced.\r\n\r\n   \t       \t\t  \t  c = Countdown(2)\t  \t  \r\nfor a in Countdown(2):\t\t  for a in c:\r\n    for b in Countdown(2):\t      for b in c:\r\n        print(a,b)\t\t          print(a,b)\r\n\r\nprints:\t\t\t\t  prints:\r\n2 2\t\t\t\t  2 2\r\n2 1\t\t\t\t  2 1\r\n2 0\t\t\t\t  2 0\r\n1 2\r\n1 1\r\n0 0\t\r\n0 2\r\n0 1\r\n0 0\r\n\r\nExplain why these results print as they do and find a simple way to modify the\r\nCountdown class to make these two scripts perform identically. Hint: it relates\r\nto a problem with sharing objects.\r\n", "encoding": "ascii"}