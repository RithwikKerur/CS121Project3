{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/while/while.txt", "content": "\t\t\t\twhile Statements\r\n\r\n\r\nIn this lecture we will examine indefinite iteration with Python's while loop.\r\nIn the process we will learn about the break statement, which can be used in\r\nboth of Python's loops. And once we learn about break, we will see that the\r\nkeyword else is usable with both of Python's loops, and we will learn its\r\nmeaning (related to whether the loop finishes \"normally\" or via a break). Once\r\nwe cover Python's try/except statement, we can write a try/except/while that is\r\nequivalent to (and further illustrates) Python's for loop\r\n\r\nWhile loops are called indefinite loops: at the time they start they do not\r\nknow how many iterations they will perform (and if written incorrectly, they\r\nmight never terminate: what we call an \"infinite\" loop). While loops use a\r\nboolean condition (really an expression, just like those used in if statements)\r\nto determine when to continue or terminate the loop.\r\n\r\nThe EBNF for a while_statement is quite simple. Note that like all the control\r\nstructures we've seen, its first line ends with a : indicating that a block\r\n(indented) follows. The word while is a keyword in Python.\r\n\r\n  while_statement <= while expression:\r\n                         block\r\n\r\nAs a syntax constraint, expression must result in a boolean value. We call this\r\nexpression the \"continuation condition\" of the loop. Semantically (in a\r\nnutshell) the while loop will repeatedly execute block (0 or more times) while\r\nthis expression evaluates to True and terminate the loop the first time this\r\nexpression evaluates to False.\r\n\r\nSemantically, Python executes a while_loop as follows\r\n\r\n  (1) Evaluate the expression (True or False)\r\n  (2) If it is False, terminate the loop\r\n  (3) If it is True, execute block and redo (loop back) to step (1)\r\n\r\nThe loop's body is executed 0 times if the expression is initially False\r\n\r\nHere is a simple while_loop that is infinite, because the expression (the\r\nliteral value True, which is by itself an expression) will never evalutate to\r\nFalse.\r\n\r\nwhile True:\r\n    print('You are going to master progrmming in ICS-31!')\r\n\r\nNote the block in a while statement is typically called the body of the while\r\nloop. Instead to writing more interesting boolean expresssions in the\r\nwhile_loop, we will first look at some examples where the expression is always\r\nthe literal True. To make such loops useful (and not infinite), we will need to\r\nintroduce the break statement, which will always be used inside an if statement.\r\nI believe beginning programmers should first use only True boolean expressions\r\nin while loops, and use if/break combinations to control their termination.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe break statement and while True loops\r\n\r\nThe EBNF rule for the break statement is very simple. note that break is another\r\nkeyword in Python\r\n\r\n  break_statement <= break\r\n\r\nPython imposes a syntax constraint that a break statement must appear inside\r\nthe body of some loop (either for or while). If Python executes a break\r\nstatement that is not in the context of some loop, it raises an exception,\r\nbecause break is only meaningful in loops: SyntaxError: 'break' outside loop\r\n\r\nIn real scripts, break statements appear inside if statements (which themselves\r\nare inside the bodies of loops), so a typical example is\r\n\r\nif count_down == 0:\r\n    break\r\n\r\nSemantically, whenever a break statement is executed, Python terminates the\r\ninner-most loop that it apears in (we will see examples of nested loops, one\r\ninside another, when our programming tasks get more complicated); it \"breaks\"\r\nout of that loop. Terminating a loop means Python next executes the statement\r\nAFTER the loop's block (it does not mean that the program itself terminates).\r\nBy putting a break statement inside an if statement, the if can control (based\r\non its boolean test expression) whether or not the break statement is executed:\r\nthe test determines whether or not the loop terminates on this iteration. Here\r\nis a typical combination of while/break statements\r\n\r\ncount_down = 3\r\nwhile True:\r\n    print(count_down + '.',end='')\r\n    if count_down == 0:\r\n        break\r\n    count_down -= 1\r\nprint('Go');\r\n\r\nLet's hand simulate this example and write a trace table for it.\r\n\r\nTypically the body will contain code that changes values that appear in\r\nexpression, and executing the body enough times will eventually make the\r\nexpression True. Here is an example of a countdown while loop\r\n                    count\r\nStatement         | _down | Console    | Explanation\r\n------------------+-------+------------+---------------------------\r\ncount_down = 3    |   3   |            | assignment statement\r\nwhile True:       |       |            | Start loop: True: execute body\r\nprint(count_down..|       |3.          | print (stay on same line)\r\nif count_down...  |       |            | False: skip next block (break)\r\ncount_down -= 1   |   2   |            | decrement count_down\r\n...while True:    |       |            | Continue loop: True: execute body\r\nprint(count_down..|       |3.2.        | print (stay on same line)\r\nif count_down...  |       |            | False: skip next block (break)\r\ncount_down -= 1   |   1   |            | decrement count_down\r\n...while True:    |       |            | Continue loop: True: execute body\r\nprint(count_down..|       |3.2.1.      | print (stay on same line)\r\nif count_down...  |       |            | False: skip next block (break)\r\ncount_down -= 1   |   0   |            | decrement count_down\r\n...while True:    |       |            | Continue loop: True: execute body\r\nprint(count_down..|       |3.2.1.0.    | print (stay on same line)\r\nif count_down...  |       |            | True: execute next block (break)\r\nbreak             |       |            | Terminate loop\r\nprint('Go')       |       |3.2.1.0.Go  | Executes statement in block, after loop\r\n\r\nTruth be told, this is really a definite loop, and it would be easier to write\r\nas follows. But it does illustrate the meaning and use of while True: and break\r\nstatements.\r\n\r\nfor count_down in irange(3,0,-1):\t# note, irange from my goody module\r\n    print(count_down + '.',end='')\r\nprint('Go');\r\n\r\nNow we will write a loop that prompts the user for an arbitrary  number of\r\nscores, and computes their average. This is not a definite loop because the\r\nuser indicates when the data is finished being entered by typing the special\r\nvalue -1, and the loop has no knowledge of when this will occur; this is called\r\na sentinel value, and the loop is called a sentinel loop.\r\n\r\ncount = 0\r\nsum   = 0\r\nwhile True:\r\n    score = prompt.for_int('Enter a Score (-1 to Terminate)')\r\n    if score == -1:\r\n        break\r\n    count += 1\r\n    sum += score\r\nif count != 0:\t\t\t\t# Avoid /0 if sentinel entered first\r\n    print('Average =', sum/count)\r\nelse:\r\n    print('No scores to average')\r\n\r\nLet's hand simulate this example and write a trace table for it, assuming the\r\nuser will enter 3, 6, 4, and then -1.\r\n                \r\nStatement      |count|sum|score| Console | Explanation\r\n---------------+-----+---+-----+-----------+-----------------------------------\r\ncount = 0      |  0  |   |     |           | assignment statement\r\nsum = 0        |     | 0 |     |           | assignment statement\r\nwhile True:    |     |   |     |           | Start loop: True: execute body\r\nscore = ...    |     |   |  3  | Enter...3 | assign/prompt for a score\r\nif score == -1:|     |   |     |           | False: skip next block (break)\r\ncount += 1     |  1  |   |     |           | assignment statement\r\nsum += score   |     | 3 |     |           | assignment statement\r\n...while True: |     |   |     |           | Continue loop: True: execute body\r\nscore = ...    |     |   |  6  | Enter...6 | assign/prompt for a score\r\nif score == -1:|     |   |     |           | False: skip next block (break)\r\ncount += 1     |  2  |   |     |           | assignment statement\r\nsum += score   |     | 9 |     |           | assignment statement\r\n...while True: |     |   |     |           | Continue loop: True: execute body\r\nscore = ...    |     |   |  4  | Enter...6 | assign/prompt for a score\r\nif score == -1:|     |   |     |           | False: skip next block (break)\r\ncount += 1     |  3  |   |     |           | assignment statement\r\nsum += score   |     | 13|     |           | assignment statement\r\n...while True: |     |   |     |           | Continue loop: True: execute body\r\nscore = ...    |     |   | -1  | Enter...-1| assign/prompt for a score\r\nif score == -1:|     |   |     |           | True: execute next block (break)\r\nbreak          |     |   |     |           | Terminate loop\r\nif (count ...  |     |   |     |           | True: execute next block (print)\r\nprint('Ave...  |     |   |     |Average... | Executes statement after loop\r\n\r\nFinally, let's look at a simplified version of the loop in the Collatz program.\r\nThis version just prompts for a value and prints how many iterations it took to\r\nreduce that value to 1 by the Collatz rules. We cannot compute this value any\r\nother way than by looping and changing \"test\".\r\n\r\nimport prompt,predicate\r\ntest  = prompt.for_int('Enter number to test',is_legal=predicate.is_positive)\r\ncount = 0\r\nwhile True:\r\n    if test == 1:\r\n        break\r\n    else:\r\n        count += 1\r\n        if test%2 == 0:\r\n            test = test//2\r\n        else:\r\n            test = 3*test + 1\r\nprint('Reduction took',count,'iterations')\r\n\r\nHere are a few observations about this code. First, as we discussed, no one\r\nknows whether this loop even terminates for all inputs: this loop might be\r\ninfinite for a certain value of test because\r\n\r\n  (1) test might get bigger and bigger during the calculation without limit;\r\n      after all, it goes up by a factor of 3 and down by a factor of only 2.\r\n      Sure it goes up and down, but maybe on average it goes up more than it\r\n      goes down.\r\n\r\n  (2) test might get stuck in a cycle, reaching some value X, then going up and\r\n      down a bit and returning to the same value X, which would then repeat in\r\n      exactly the same manner over and over forever forever\r\n\r\nSo, it makes sense that testing Collatz wouldn't use a for loop, because that\r\nloop always terminates. Of course, no one has found a value for test that\r\ndoesn't eventually reach 1 by these rules. But there might be a number out there\r\nthat no one has tried that creates an infinite loop (find it and you'll become\r\nfamous for disproving the Collatz conjecture): no one has proved that the\r\nprocess terminates for all positive numbers.\r\n\r\nSecond, we can simplify the code above as follows, while retaining equivalence\r\nof execution. Let's just focus on the while loop and its body\r\n\r\nwhile True:\r\n    if test == 1:\r\n        break\r\n    count += 1\r\n    if test%2 == 0:\r\n        test = test//2\r\n    else:\r\n        test = 3*test + 1\r\n\r\nIt is not a tremendous simplification, but we turned the first if/else statement\r\ninto just a if, and avoided nesting the following count+=/if statements in\r\nanother block in an else deeper inside the while loop. This code is equivalent\r\nbecause both ifs will execute break if test == 1; and both loops will execute\r\nthe count+=/if if test is not == 1: the first in an else: block, the second\r\nby just continuing in the same block the first if is in. Draw a boxing diagram\r\nto see the difference.\r\n\r\nWe will discuss equivalence and simplification in a later lecture, and see a\r\ngeneral rule that applies to this particular simplification.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nwhile loops with real tests (not just True)\r\n\r\nFinally, we will show how to change a while True into a while loop with a real\r\ntest and remove an if/break. To do this the if/break must be the first statement\r\ninside the body of the while loop: sometimes, if it is not, we can transform the\r\nloop body by other rules of equivalence to promote it to the first position, but\r\nsometimes we cannot.\r\n\r\nGenerally, we can tranform code of the form\r\n\r\nwhile True:\r\n    if some-test:\r\n        break\r\n    statements\r\n\r\ninto\r\n\r\nwhile not(some-test):\r\n    statements\r\n\r\nIn the top case, each execution of the while loop first evaluates some-test and\r\nbreaks out of the loop if it is True. In the bottom case, before each execution\r\nof the loop the while evalutes not(some-test) and again, if some-test is True\r\nthen not(some-test) is False, and if the boolean expression controlling the\r\nwhile loop is False, the loop terminates (as with the if/test). Recall the\r\nboolean expression in the while syntax is called the \"continuation\" condition\r\n(True continues, False terminates) while the boolean expression in the if/break\r\nis a termination condtion (True terminates, False continues) so it makes sense\r\nthat we must negate the test with not when changing it from a termination\r\ncondition to a continuation condition (or vice versa).\r\n\r\nIn the Collatz loop, some-test is test == 1 so we could write not(test == 1) to\r\ncontrol the while, but we should simplify that to test != 1 and write\r\n\r\nwhile test != 1:\r\n    count += 1\r\n    if test%2 == 0:\r\n        test = test//2\r\n    else:\r\n        test = 3*test + 1\r\n\r\nNote that in the general pattern I put parentheses around some-test, because it\r\nmight include operators that are lower precedence than not: for example if the\r\ntest were a == 1 or b == 2, then writing not(a == 1 or b == 2) would be correct,\r\nand different from writing not a == 1 or b == 2, which according to Python's\r\noperator precedence rules would be interpreted as not(a == 1) or b == 2, first\r\nperforming the not on (a == 1) and then or'ing it with (b == 2). Actually the\r\nsimplest negation is a != 1 and b != 2.\r\n\r\nWe cannot perform this transformation on all while True with if/break loops,\r\nbecause some do not have the if/break as the first statement in the loop\r\nbody (e.g.,the first two loops discussed in this lecture).\r\n\r\nSome experienced programmers (and educators) like to avoid using while True with\r\nif/break, but I am fine with this usage. In fact, I think it is easier for\r\nbeginners (and sometimes even experienced programmers) to first just write the\r\nloop (not having to think: we always write it as while True) and then worry\r\nabout what the body of the loop should compute, and how/where to test for \r\ntermination. If it so happens the if/break is first in the loop (it actually\r\nis for a surprising number of loops) then we can perform the transformation.\r\n\r\nWhere this advice goes wrong in the hands of beginners is that they often write\r\nmultiple if/breaks inside their while True loops that make these loops\r\ncomplicated and very hard to understand. The most imporant part of a loop is\r\nhow it terminates. It is an extraordinary while True loop that requires more\r\nthan one if/break, so you should be skeptical that your code is simple if it has\r\nmultiple if/break statements.\r\n\r\nFinally, it is possible to have a while with a test and if/break statements in\r\nits body (or for that matter, a for loop with an if/break in its body; an\r\nexample is shown in the next section). Syntactically and semantically Python\r\nknows what to do, but according to the paragraph above, having tests in two or\r\nmore spots is excessive and you should try to simplify your thinking and your\r\ncode. I have written some loops in my life that have multiple tests for\r\ntermination, but not many.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe else: block-else option in for/while loops\r\n\r\nNow we will extend the syntax of for/while loops (with optional else parts).\r\nUnderstanding their meaning depends on knowing about break statements, which is\r\nwhy I had to simplify the truth (also known as lying) earlier. The actual EBNF\r\nof for_statement and while_statement are as follows (of course you can bet that\r\nI'm still lyingXXXXX simplifying the truth a bit).\r\n\r\nfor_statement   <=   for index in iterable:\r\n                         block-body\r\n                     [else:\r\n                         block-else]\r\n\r\nwhile_statement <=   while expression:\r\n                         block-body\r\n                     [else:\r\n                         block-else]\r\n\r\nBoth allow the else: block-else option (so if we ignore this option, the EBNF\r\nI wrote before is correct; typically when I update EBNF it is just to \"add\"\r\nstuff; never subtract). Here are the semantics of this option.\r\n\r\n   If the else; block-else option appears, and the loop terminated normally,\r\n   (not with a break statement) then execute block-else.\r\n\r\nHere is an example that makes good use of the else: block-else option. This\r\ncode prints the first/lowest value (looking at 0 to 100 inclusive) for which\r\nthe function special_property returns True (and then breaks out of the loop);\r\notherwise it prints that no value in this range had this property: so it prints\r\nexactly one of these two messages. Note you cannot run this code, because there\r\nis no special_property function: I'm using it for illustration only.\r\n\r\nfor i in irange(100):\r\n    if special_property(i):\r\n        print(i,'is the first value with the special property')\r\n        break\r\nelse:\r\n    print('No value in the range had the special property')\r\n\r\nWithout the else: block-else option, the simplest code that I can write that has\r\nequivalent meaning is as follows.\r\n\r\nfound_one = False\r\nfor i in irange(100):\r\n    if special_property(i):\r\n        print(i,'is the first with the special property')\r\n        found_one = True\r\n        break\r\nif not found_one:\r\n    print('No value in the range had the special property')\r\n\r\nThis solution requires an extra name (found_one), an assignment to reset the\r\nname, and an if statement. Although I came up with the example above, I have\r\nnot used the else: block-else option much in Python (but I've only used Python\r\nfor a few months). Most programming languages that I have used don't have this\r\nspecial feature, so I'm still exploring its usefulness. \r\n\r\nCan you predice what would happen if I removed the break statement in the bigger\r\ncode above?\r\n\r\nI think the bottom line here is although Python allows else: in loops, it is\r\nhardely every used there. The vast majority of uses of else: is in if\r\nstatements.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nCompressed trace tables\r\n\r\nWhen we hand simulate programs with complicated control structures, most of the\r\ntrace table is occupied by information relating to control structures deciding\r\nwhich statements to execute next, as opposed to statements that actually rebind\r\na name or change the contents of the console window. Such trace tables are\r\ncumbersome to create and tedious to read (but fully explain how the code is\r\nexecuted). Compact trace tables remove all the information related to control\r\nstructures, and instead focus on rebinding names and the changes to the console\r\nwindow.\r\n\r\nTo construct a compact trace table, we list all the names and Console in\r\nseparate columns (and omit the Statement and Explanation column). Only when the\r\ncode rebinds a name OR the console window changes do we update information in\r\nthe appropriate column; and we always do so right beneath the last entry for\r\nthis column. THERE ARE NEVER BLANK CELLS BETWEEN ONE CHANGE AND THE NEXT CHANGE.\r\n\r\nNote that what we lose in a compact trace table (we gain conciseness) is an\r\nindication of the order in which different names are rebound to new values:\r\nbecause each column is shown as compactly as possible (no blank entries); we\r\nlose the correlation among columns. Here are compact trace tables for the two\r\nstandard trace tables shown above. First, the count down loop.\r\n\r\ncount_down | Console\r\n-----------+-------------\r\n    3      | 3.\r\n    2      | 3.2.\r\n    1      | 3.2.1.\r\n    0      | 3.2.2.0.\r\n           | 3.2.2.0.Go\r\n\r\nHere is the sentinel terminated loop.\r\n\r\ncount | sum | score | Console\r\n------+-----+-------+-------------------------------------------\r\n  0   |  0  |   3   | Enter a Score (-1 to Terminate): 3\r\n  1   |  3  |   6   | Enter a Score (-1 to Terminate): 6\r\n  2   |  9  |   4   | Enter a Score (-1 to Terminate): 4\r\n  3   | 13  |   -1  | Enter a Score (-1 to Terminate): -1\r\n      |     |       | Average = 4.333333\r\n \t \t \t\r\nSo we see the count goes from 0 to 3, the sum goes from 0 to 13, and the\r\nscores are entered as 3, 6, 4, and -1 but there is no correlation among columns\r\nas to when each change happens.\r\n\r\nRemember, in a compact trace table, a column entry is filled in only when all\r\nthe column entries on top of it have been filled in; there are never an blank\r\nentries (except possibly at the bottom).\r\n\r\n------------------------------------------------------------------------------\r\n\r\nShort-circuit Logical Operators\r\n\r\nThe operators and/or are called short-ciruit operators, because unlike other\r\noperators (which evaluate both of their operands before being applied), short-\r\ncircuit operators evaluate their left operand first, and sometimes don't need\r\nto evaluate their right operand (and therefore don't, in those cases). For\r\nexample True or anything is True; False and anything is False. So if the or\r\noperator's left operand is True, it doesn't need to evalate its right operand:\r\nthe result is True; and if the and operator's left operand is False, it doesn't\r\nneed to evalate its right operand: the result is False. This rule saves time,\r\nbut it is more important for another reason (discussed below). If the left\r\noperands of or/and is False/True it must evaluate the right operand in order to\r\ncompute its result.\r\n\r\nSo, for example, if we wrote the following if/test (assume d is a dict)\r\n  s = prompt.for_string('Enter string')\r\n\r\n  if len(s) > 10 and s[10] == '*':\r\n      ....\r\n\r\nPython would first evaluate the expression: len(s) > 10. When False it would\r\ndetermine the value of the and operator is already known: it is False. It\r\nwould not have to evaluate s[10] == '*' and that is a good thing, because that\r\nwould throw an IndexError exception, because if the length of a string is <= 10\r\nthen 10 is not an legal index (legal indexes are 0 to len(s)-1).\r\n\r\nSo, while short-circuit operators can save a little time, that is not their\r\nmost important purpose; avoiding raising exceptions is the primary reason that\r\nand/or operators are short-circuit.\r\n\r\nEven without short-circuit operators, we could write the equivalent code as\r\nfollows. Only if the test in the first if is True, does Python execute the\r\nsecond if inside it.\r\n\r\n  if len(s) > 10:\r\n      if s[10] == '*':\r\n          ....\r\n\r\nBut that requires nested if statements and is much more cumbersome. It is\r\nbetter to spend some time learning about short-circuit operators now, and then\r\nunderstand how to use them and save time later by using them appropriately.\r\n", "encoding": "ascii"}