{"url": "https://www.ics.uci.edu/~ejw/authoring/webdav-req-00.txt", "content": "WEBDAV Working Group\t\t\t\tJ.A. Slein\nINTERNET-DRAFT      \t\t\t\tXerox Corporation\n<draft-slein-www-dist-author-00.txt>\t\tF. Vitali\n\t\t\t\t\t\tUniversity of Bologna              \n\t\t\t\t\t\tE.J. Whitehead, Jr.\n\t\t\t\t\t\tU.C. Irvine\n\t\t\t\t\t\tD.G. Durand\n\t\t\t\t\t\tBoston University\n\t\t\t\t\t\tFebruary 28, 1997\n\nExpires August 28, 1997\n\n     Requirements for Distributed Authoring and Versioning \n                    on the World Wide Web\n\n\nStatus of this Memo\n\nThis document is an Internet draft. Internet drafts are working\ndocuments of the Internet Engineering Task Force (IETF), its areas and\nits working groups. Note that other groups may also distribute working\ninformation as Internet drafts.\n\nInternet Drafts are draft documents valid for a maximum of six months\nand can be updated, replaced or obsoleted by other documents at any\ntime. It is inappropriate to use Internet drafts as reference material\nor to cite them as other than as \"work in progress\".\n\nTo learn the current status of any Internet draft please check the\n\"lid-abstracts.txt\" listing contained in the Internet drafts shadow\ndirectories on ftp.is.co.za (Africa), nic.nordu.net (Europe),\nmunnari.oz.au (Pacific Rim), ds.internic.net (US East coast) or\nftp.isi.edu (US West coast). Further information about the IETF can be\nfound at URL: http://www.ietf.org/\n\nDistribution of this document is unlimited. Please send comments to the\nWWW Distributed Authoring and Versioning (WebDAV) mailing list,\n<w3c-dist-auth@w3.org>, which may be joined by sending a message with\nsubject \"subscribe\" to <w3c-dist-auth-request@w3.org>. Discussions are\narchived at URL:\nhttp://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth/.\n\nAbstract\n\nCurrent World Wide Web (WWW or Web) standards provide simple support \nfor applications which allow remote editing of typed data. In practice, \nthe existing capabilities of the WWW have proven inadequate to support \nefficient, scalable remote editing free of overwriting conflicts.  \nThis document presents a list of features in the form of requirements \nwhich, if implemented, would improve the efficiency of common remote \nediting operations, provide a locking mechanism to prevent overwrite \nconflicts, improve relationship management support between non-HTML \ndata types, provide a simple attribute-value metadata facility, provide\nfor the creation and reading of container data types, and integrate \nversioning into the WWW.\n\n1. Introduction\n\nSlein, Vitali, Whitehead, Durand                                Page 1\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nThis document describes functionality which, if standardized in the\ncontext of the WWW, would allow tools for remote loading, editing and\nsaving (publishing) of various media types on the WWW to interoperate\nwith any compliant Web server. As much as possible, this functionality \nis described without suggesting a proposed implementation, since there \nare many ways to perform the functionality within the WWW framework. It\ncould be implemented in extensions to HTTP, in a new protocol to be \nlayered on top of HTTP, in additional MIME types, or some combination\nof these and other approaches. It is also possible that a single \nmechanism could simultaneously satisfy several requirements.\n\nThis document is intended to reflect the consensus of the WWW \nDistributed Authoring and Versioning working group (WebDAV) as to the \nfunctionality that needs to be standardized to support distributed \nauthoring and versioning on the Web. However, this version still has \nsome elements that are being debated in the working group. The following\nelements are still under discussion:\n\n\to Whether attribute search should be in scope\n\to Whether support for partial-resource locking is needed\n\to Whether other lock types besides write locks are needed\n\to Semantics of locking\n\to Semantics of copy / move for resources with attributes or\n\t  relationships, as well as for collections and version graphs\n\to Implications of attributes, relationships, collections, and\n\t  versioning for the HTTP DELETE method\n\to Semantics of removing resources from collections\n\to How to balance the goal of simplicity for clients against\n\t  the wish to allow versioning servers to implement a variety\n\t  of versioning policies\n\to Whether reservations are apart from versioning, or whether\n\t  they make sense only in versioning systems\n\to Whether diff / merge are needed\n\to Which requirements are mandatory, and which are optional for \n\t  a server to implement in order to be WebDAV-compliant\n\n2. Rationale\n\nCurrent Web standards contain functionality which enables the editing of \nWeb content at a remote location, without direct access to the storage \nmedia via an operating system. This capability is exploited by several \nexisting HTML distributed authoring tools, and by a growing number of \nmainstream applications (e.g., word processors) which allow users to \nwrite (publish) their work to an HTTP server. To date, experience from \nthe HTML authoring tools has shown they are unable to meet their users' \nneeds using the facilities of Web standards. The consequence of \nthis is either postponed introduction of distributed authoring \ncapability, or the addition of nonstandard extensions to the HTTP \nprotocol [4] or other Web standards.  These extensions, developed in \nisolation, are not interoperable.\n\nOther authoring applications have wanted to access document repositories \nor version control systems through Web gateways, and have been similarly\nfrustrated.  Where this access is available at all, it is through\nnonstandard extensions to HTTP or other standards that force clients to \n\nSlein, Vitali, Whitehead, Durand                                Page 2\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n\nThis document describes requirements for a set of standard extensions\nto the Web that would allow distributed Web authoring tools to provide\nthe functionality their users need by means of the same standard\nsyntax across all compliant servers. The broad categories of \nfunctionality that need to be standardized are:\n\n\tAttributes\n\tRelationships\n\tLocking\n\tReservations\n\tRetrieval of Unprocessed Source\n\tPartial Write\n\tName Space Manipulation\n\tCollections\n\tVersioning\n\n3. Terminology\n\nWhere there is overlap, usage is intended to be consistent with that in \nthe HTTP 1.1 specification [4].\n\nAttribute\n\tNamed descriptive information about a resource.\n\nClient\n\tA program which issues HTTP requests and accepts responses.\n\nCollection\n\tA collection is a resource that contains other resources,\n\teither directly or by reference.\n\nDistributed Authoring Tool\n\tA program which can retrieve a source entity via HTTP, allow \n\tediting of this entity, and then save/publish this entity\n\tto a server using HTTP.\n\nEntity\n\tThe information transferred in a request or response.\n\nHierarchical Collection\n\tA hierarchical organization of resources.  A hierarchical\n\tcollection is a resource that contains other resources, \n\tincluding collections, either directly or by reference.\n\nLock\n\tA mechanism for preventing anyone other than the owner of the\n\tlock from accessing a resource.\n\nMember of Version Graph\n\tA resource that is a node in a version graph, and so is derived\n\tfrom the resources that precede it in the graph, and is the \n\tbasis of those that succeed it.\n\nRelationship\n\nSlein, Vitali, Whitehead, Durand                                Page 3\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n\nReservation\n\tA declaration to the server that one intends to edit a resource.\n\nResource\n\tA network data object or service that can be identified by\n\ta URI.\n\nServer\n\tA program which receives and responds to HTTP requests.\n\nServer Attribute\n\tAn attribute whose value is generated by the server.\n\nUser Agent\n\tThe client that initiates a request.\n\nUser Attribute\n\tAn attribute whose value is provided by a user or a user agent.\n\nVersion Graph\n\tA directed acyclic graph with resources as its nodes, where\n\teach node is derived from its predecessor(s).\n\nWrite Lock\n\tA lock that prevents anyone except its owner from modifying\n\tthe resource it applies to.\n\n\n4. General Principles\n\nThis section describes a set of general principles that the WebDAV\nextensions should follow.  These principles cut across categories of\nfunctionality.\n\n4.1. User Agent Interoperability\n\nAll WebDAV clients should be able to work with any WebDAV-compliant HTTP\nserver. It is acceptable for some client/server combinations to provide\nspecial features that are not universally available, but the protocol\nshould be sufficient that a basic level of functionality will be\nuniversal.\n\n4.2. Client Simplicity\n\nThe WebDAV extensions should be designed to allow client implementations\nto be simple.\n\n4.3. Legacy Client Support\n\nIt should be possible to implement a WebDAV-compliant server in such a\nway that it can interoperate with non-WebDAV clients.  Such a server\nwould be able to understand any valid HTTP 1.1 request from an ordinary\nWeb client without WebDAV extensions, and to provide a valid HTTP 1.1 \nresponse that does not require the client to understand the extensions.\n\nSlein, Vitali, Whitehead, Durand                                Page 4\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n4.4. Data Format Compatibility\n\nWebDAV-compliant servers should be able to work with existing resources \nand URIs [2]. Special additional information should not become a \nmandatory part of document formats.\n\n4.5. Replicated, Distributed Systems\n\nDistribution and replication are at the heart of the Internet.  All\nWebDAV extensions should be designed to allow for distribution and\nreplication.  Version trees should be able to be split across multiple\nservers.  Collections may have members on different servers.  Resources\nmay have attributes on different servers.  Any resources may be cached\nor replicated for mobile computing or other reasons.  Consequently, the\nWebDAV extensions must be able to operate in a distributed, replicated\nenvironment.\n\n4.6 Parsimony in Client-Server Interactions \n\nThe WebDAV extensions should keep to a minimum the number of \ninteractions between the client and the server needed to perform common\nfunctions. For example, publishing a document to the Web will often mean\npublishing content together with related metadata.  A client may often \nneed to find out what version graph a particular resource belongs to, \nor to find out which resource in a version graph is the published one.\nThe extensions should make it possible to do these things efficiently.\n\n4.7. Alternate Transport Mechanisms\n\nIt may be desirable to transport WebDAV requests and responses by other\nmechanisms, particularly EMail, in addition to HTTP.  The design of the\nWebDAV extensions should take alternative transports into account.\n\n5. Requirements\n\nIn the requirement descriptions below, the requirement will be stated,\nfollowed by its rationale.\n\n5.1. Attributes\n\n5.1.1. Functional Requirements\n\nIt must be possible to create, modify, query, read and delete arbitrary\nattributes on resources of any media type.\n\nAttributes are resources that may have attributes of their own, may be\nsubject to content negotiation, etc.\n\nAttributes have implications for the semantics of move, copy, and\ndelete operations.  See \"5.7. Name Space Manipulation\" below.\n\n5.1.2. Rationale \n\nAttributes describe resources of any media type.  They may \ninclude bibliographic information such as author, title, publisher, \n\nSlein, Vitali, Whitehead, Durand                                Page 5\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nattributes have many uses, such as supporting searches on attribute \nvalues, enforcing copyrights, and the creation of catalog entries as \nplaceholders for objects which are not available in electronic form, or \nwhich will be available later.\n\n5.2. Relationships\n\n5.2.1. Functional Requirements\n\nIt must be possible to create, modify, query, read and delete typed \nrelationships between resources of any media type.\n\nRelationships have implications for the semantics of move, copy, and\ndelete operations.  See \"5.7. Name Space Manipulation\" below.\n\n5.2.2. Rationale \n\nOne type of relationship between resources is the hypertext \nlink, which is browsable using a hypertext style point-and-click user \ninterface. Relationships, whether they are browsable hypertext links, \nor simply a means of capturing a connection between resources, have \nmany purposes.  Relationships can support pushbutton printing of a \nmulti-resource document in a prescribed order, jumping to the access \ncontrol page for a resource, and quick browsing of related information,\nsuch as a table of contents, an index, a glossary, help pages, etc. \nWhile relationship support is provided by the HTML \"LINK\" element, this\nis limited only to HTML resources [1]. Similar support is needed for \nbitmap image types, and other non-HTML media types.  \n\n5.3. Locking\n\n5.3.1. General Principles\n\n5.3.1.1. Independence of locks. It must be possible to lock a resource\nwithout re-reading the resource, and without committing to editing the \nresource.\n\n5.3.1.2. Multi-Resource Locking. It must be possible to take out a \nlock on multiple resources in the same action, and this locking \noperation must be atomic across these resources.\n\n5.3.1.3. Partial-Resource Locking. It must be possible to take out a \nlock on a subsection of a resource.\n\n5.3.1.4. Optional Server Support for Locking.  Some systems use other\nmechanisms besides locking to ensure consistency in environments where\nseveral users may wish to edit a resource at once.  These other \nstrategies must be permitted.\n\n5.3.2. Functional Requirements\n\n5.3.2.1. Write Locks. It must be possible to restrict modification of \na resource to a specific person.\n\n5.3.2.2. Lock Query. It must be possible to find out whether a given \n\nSlein, Vitali, Whitehead, Durand                                Page 6\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\ncurrently has modification permission.\n\n5.3.2.3. Unlock. It must be possible to remove a lock.  Only the owner \nof a lock or a principal with appropriate access rights may remove the \nlock.\n\n5.3.3. Rationale\n\nAt present, the Web provides limited support for preventing two or more \npeople from overwriting each other's modifications when they save to a \ngiven URI. Furthermore, there is no way to discover whether someone else\nis currently making modifications to a resource. This is known as the \n\"lost update problem,\" or the \"overwrite problem.\" Since there can be \nsignificant cost associated with discovering and repairing lost \nmodifications, preventing this problem is crucial for supporting \ndistributed authoring. A write lock ensures that only one person may \nmodify a resource, preventing overwrites. Furthermore, locking support \nis a key component of many versioning schemes, a desirable capability \nfor distributed authoring.\n\nAn author may wish to lock an entire web of resources even though he \nis editing just a single resource, to keep the other resources from \nchanging. In this way, an author can ensure that if a local hypertext \nweb is consistent in his distributed authoring tool, it will then be \nconsistent when he writes it to the server. Because of this, it should \nbe possible to take out a lock without also causing transmission of the \ncontents of a resource.\n\nIt is often necessary to guarantee that a lock or unlock operation \noccurs at the same time across multiple resources, a feature which is \nsupported by the multiple-resource locking requirement. This is useful \nfor preventing a collision between two people trying to establish locks \non the same set of resources, since with multi-resource locking, one of \nthe two people will get a lock. If this same multiple-resource locking \nscenario was repeated by using atomic lock operations iterated across \nthe resources, the result would be a splitting of the locks between the \ntwo people, based on resource ordering and race conditions.\n\nPartial resource locking provides support for collaborative editing \napplications, where multiple users may be editing the same resource\nsimultaneously. Partial resource locking also allows multiple people to \nsimultaneously work on a database type resource.\n\n5.4. Reservations\n\n5.4.1. Functional Requirements \n\n5.4.1.1. Reserve. It must be possible to notify the server that \na resource is about to be edited by a given person.\n\n5.4.1.2. Reservation Query. It must be possible to find out whether \na given resource has any active reservations, and if so, who currently \nholds reservations.\n\n5.4.1.3. Release Reservation.  It must be possible to release the \n\nSlein, Vitali, Whitehead, Durand                                Page 7\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nappropriate access rights may release the reservation.\n\n5.4.2. Rationale\n\nExperience from configuration management systems has shown that people \nneed to know when they are about to enter a parallel editing situation. \nOnce notified, they either decide not to edit in parallel with the \nother authors, or they use out-of-band communication (face-to-face, \ntelephone, etc.) to coordinate their editing to minimize the difficulty \nof merging their results. Reservations are separate from locking, since \na write lock does not necessarily imply a resource will be edited, and \na reservation does not carry with it any access restrictions. This \ncapability supports versioning, since a check-out typically involves \ntaking out a write lock, making a reservation, and getting the resource\nto be edited.\n\n5.5. Retrieval of Unprocessed Source for Editing\n\n5.5.1. Functional Requirement\n\nThe source of any given resource must be retrievable.\n\n5.5.2. Rationale\n\nThere are many cases where the source stored on a server does \nnot correspond to the actual entity transmitted in response to an HTTP \nGET. Current known cases are server side include directives, and \nStandard Generalized Markup Language (SGML) source which is\nconverted on the fly to HyperText Markup Language (HTML) [1] output \nentities. There are many possible cases, such as automatic conversion \nof bitmap images into several variant bitmap media types (e.g. GIF, \nJPEG), and automatic conversion of an application's native media type \ninto HTML. As an example of this last case, a word processor could \nstore its native media type on a server which automatically converts \nit to HTML. A GET of this resource would retrieve the HTML. Retrieving \nthe source would retrieve the word processor native format.\n\nThis requirement should be met by a general mechanism which can handle \nboth the \"single-step\" source processing described above, where the \nsource is converted into the transmission entity via a single \nconversion step, as well as \"multi-step\" source processing, where there \nare one or more intermediate processing steps and outputs. An example \nof multi-step source processing is the relationship between an \nexecutable binary image, its object files, and its source language \nfiles. It should be noted that the relationship between source and \ntransmission entity could be expressed using the relationship \nfunctionality described above in \"5.2. Relationships.\"\n\n5.6. Partial Write.\n\n5.6.1. Functional Requirement \n\nAfter editing a resource, it must be possible to write only the changes\nto the resource, rather than retransmitting the entire resource.\n\n\nSlein, Vitali, Whitehead, Durand                                Page 8\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n\nDuring distributed editing which occurs over wide geographic separations\nand/or over low bandwidth connections, it is extremely inefficient\nand frustrating to rewrite a large resource after minor changes, such \nas a one-character spelling correction. Support is needed for \ntransmitting \"insert\" (e.g., add this sentence in the middle of a \ndocument) and \"delete\" (e.g. remove this paragraph from the middle of \na document) style updates. Support for partial resource updates will \nmake small edits more efficient, and allow distributed authoring tools \nto scale up for editing large documents.\n\n5.7. Name Space Manipulation\n\n5.7.1. Copy\n\n5.7.1.1. Functional Requirements \n\nIt must be possible to duplicate a resource without a client loading, \nthen resaving the resource. After the copy operation, the content of \nthe destination resource must be octet for octet identical to the \ncontent of the source resource. A modification to either resource must \nnot cause a modification to the other. The copy operation should leave \nan audit trail.\n\nIt must be possible for a client to specify whether a resource's user\nattributes and relationships are to be copied with it, although the \nserver may decline to copy them. It may decline to copy user attributes\nif the destination namespace supports different attributes from the \nsource namespace, for example. The server may follow whatever policy it\nlikes for copying server attributes.\n\nCopying a collection causes all of the resources that belong to it\ndirectly to be copied as well. For resources that belong to it by \nreference, the reference is copied.  It must be possible for a client\nto specify whether subcollections should be copied with the collection.\n\nIf a version graph is copied, all relationships between nodes in the \ngraph must be changed in the new copy to reflect its new location.\n\n5.7.1.2. Rationale\n\nThere are many reasons why a resource might need to be duplicated, such \nas changing ownership, preparing for major modifications, or making \na backup. Due to network costs associated with loading and saving a \nresource, it is far preferable to have a server perform a resource copy\nthan a client. If a copied resource records which resource it is a copy\nof, then it would be possible for a cache to avoid loading the copied \nresource if it already locally stores the original.\n\n5.7.2. Move/Rename\n\n5.7.2.1. Functional Requirements \n\nIt must be possible to change the location of a resource without \na client loading, then resaving the resource under a different name. \n\nSlein, Vitali, Whitehead, Durand                                Page 9\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nlocation must be octet for octet identical to the content of the prior \nresource. It must no longer be possible to access the resource at its \noriginal location. The move operation should leave an audit trail.\n\nIt must be possible for a client to specify whether a resource's user\nattributes and relationships are to be moved with it, although the \nserver may decline to move them. It may decline to move user attributes\nif the destination namespace supports different attributes from the \nsource namespace, for example. The server may follow whatever policy it\nlikes for server attributes.\n\nMoving a collection causes all of the resources that belong to it\ndirectly to be moved as well. For resources that belong to it by \nreference, the reference is moved.  It must be possible for a client\nto specify whether subcollections should be moved with the collection.\nIf not, subcollections that belong to the collection directly should be\ndeleted from the source location.\n\nIf a version graph is moved, all relationships between nodes in the \ngraph must be changed in the destination resource to reflect its new \nlocation.\n\n5.7.2.2. Rationale\n\nIt is often necessary to change the name of a resource, for example due \nto adoption of a new naming convention, or if a typing error was made \nentering the name originally. Due to network costs, it is undesirable \nto perform this operation by loading, then resaving the resource,\nfollowed by a delete of the old resource. Similarly, a single rename \noperation is more efficient than a copy followed by a delete operation.\nNote that moving a resource is considered the same function as renaming\na resource. The audit trail makes it possible for the server to redirect\nclient requests for the resource at its old location, perhaps with a \n\"301 Moved Permanently\" status code.\n\n5.7.3. Delete\n\nHTTP already provides a DELETE method, but the semantics of DELETE must\nbe reconsidered once attributes, relations, collections, and versions\nare introduced.\n\nWhen a resource is deleted, it must be possible for a client to specify\nwhether a its attributes are to be deleted with it. In an environment \nwhere resources may share the same attributes, the server may decline \nto delete the attributes.\n\nWhen a resource is deleted, the relationships in which it participates\nshould also be deleted.\n\nIf the resource being deleted is a collection, all resources that belong\nto it directly will be deleted as well.  Resources that belong to it by\nreference are unaffected.\n\nIf the resource being deleted is a member of a version graph, the\npredecessor and successor relationships in the graph must be updated,\n\nSlein, Vitali, Whitehead, Durand                                Page 10\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nThe versioning server may, for example, require a comment explaining\nthe reason for the deletion.\n\n5.8. Collections\n\nA collection is a resource that is a container for other resources,\nincluding other collections.  A resource may belong to a collection\neither directly or by reference.  If a resource belongs to a\ncollection directly, namespace operations like copy, move, and\ndelete applied to the collection also apply to the resource.  If a\nresource belongs to a collection by reference, namespace operations\napplied to the collection affect only the reference, not the resource\nitself.\n\n5.8.1. Functional Requirements\n\n5.8.1.1. List Collection. A listing of all resources in a specific \ncollection must be accessible.\n\n5.8.1.2. Make Collection. It must be possible to create a new \ncollection.\n\n5.8.1.3. Add to Collection.  It must be possible to add a resource to a\ncollection directly or by reference.\n\n5.8.1.4. Remove from Collection.  It must be possible to remove a\nresource from a collection.  In the case of a resource that belongs to\nthe collection directly, this results in the resource being deleted.  In\nthe case of a resource that is merely referenced by the collection, only\nthe reference is removed.\n\n5.8.1.5. Collections have implications for the semantics of move, copy,\nand delete operations.  See \"5.7. Name Space Manipulation\" above.\n\n5.8.2. Rationale\n\nIn [2] it states that, \"some URL schemes (such as the ftp, http, and \nfile schemes) contain names that can be considered hierarchical.\" \nEspecially for HTTP servers which directly map all or part of their URL \nname space into a filesystem, it is very useful to get a listing of all \nresources located at a particular hierarchy level. This functionality \nsupports \"Save As...\" dialog boxes, which provide a listing of the \nentities at a current hierarchy level, and allow navigation through \nthe hierarchy. It also supports the creation of graphical visualizations\n(typically as a network) of the hypertext structure among the entities \nat a hierarchy level, or set of levels. It also supports a tree\nvisualization of the entities and their hierarchy levels.\n\nIn addition, document management systems may want to make their \ndocuments accessible through the Web.  They typically allow the \norganization of documents into collections, and so also want their users\nto be able to view the collection hierarchy through the Web.\n\nThere are many instances where there is not a strong correlation between\na URL hierarchy level and the notion of a collection. One example is a \n\nSlein, Vitali, Whitehead, Durand                                Page 11\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nwhich performs some resolution on the name. In this case, the contents \nof the URL hierarchy level can vary depending on the input to the \ncomputation, and the number of resources accessible via the computation \ncan be very large. It does not make sense to implement a directory \nfeature for such a namespace. However, the utility of listing the \ncontents of those URL hierarchy levels which do correspond to \ncollections, such as the large number of HTTP servers which map their \nnamespace to a filesystem, argue for the inclusion of this capability, \ndespite not being meaningful in all cases. If listing the contents of \na URL hierarchy level does not makes sense for a particular URL, then \na \"405 Method Not Allowed\" status code could be issued.\n\nThe ability to create collections to hold related resources supports \nmanagement of a name space by packaging its members into small, related \nclusters. The utility of this capability is demonstrated by the broad \nimplementation of directories in recent operating systems. The ability \nto create a collection also supports the creation of \"Save As...\" \ndialog boxes with \"New Level/Folder/Directory\" capability, common in \nmany applications.\n\n5.9. Versioning\n\n5.9.1. Background and General Principles\n\n5.9.1.1. Stability of versions. Most versioning systems are intended to\nprovide an accurate record of the history of evolution of a document. \nThis accuracy is ensured by the fact that a version eventually becomes \n\"frozen\" and immutable. Once a version is frozen, further changes will \ncreate new versions rather than modifying the original. In order for \ncaching and persistent references to be properly maintained, a client \nmust be able to determine that a version has been frozen. Any successful\nattempt to retrieve a frozen version of a resource will always retrieve\nexactly the same content, or return an error if that version (or the \nresource itself) is no longer available.\n\n5.9.1.2. Operations for Creating New Versions\n\nVersion management systems vary greatly in the operations they require,\nthe order of the operations, and how they are combined into atomic\nfunctions.  In the most complete cases, the logical operations involved\nare:\n\to Reserve existing version\n\to Lock existing version\n\to Retrieve existing version\n\to Request or suggest identifier for new version\n\to Write new version\n\to Release lock\n\to Release reservation\nWith the exception of requesting a new version identifier, all of these\noperations have applications outside of versioning and are either \nalready part of HTTP or are discussed in earlier sections of these\nrequirements. Typically, versioning systems combine reservation, \nlocking, and retrieval -- or some subset of these -- into an atomic \ncheckout function.  They combine writing, releasing the lock, and \nreleasing the reservation -- or some subset of these -- into an atomic \n\nSlein, Vitali, Whitehead, Durand                                Page 12\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\ncheckout or at checkin.\n\nThe WebDAV extensions must find some balance between allowing versioning\nservers to adopt whatever policies they wish with regard to these \noperations and enforcing enough uniformity to keep client \nimplementations simple.\n\n5.9.1.3. The Versioning Model\n\nEach version typically stands in a \"derived from\" relationship to its \npredecessor(s).  It is possible to derive several different versions \nfrom a single version (branching), and to derive a single version from \nseveral versions (merging).  Consequently, the collection of related\nversions forms a directed acyclic graph.  In the following discussion,\nthis graph will be called a \"version graph\".  Each node of this graph\nis a \"version\" or \"member of the version graph\".  The arcs of the graph\ncapture the \"derived from\" relationships.\n\nIt is also possible for a single resource to participate in multiple\nversion graphs.\n\nThe WebDAV extensions must support this versioning model, though\nparticular servers may restrict it in various ways.\n\n5.9.1.4. Versioning Policies. Many writers, including Feiler [3] and \nHaake and Hicks [5], have discussed the notion of versioning styles \n(referred to here as versioning policies, to reflect the nature of \nclient/server interaction) as one way to think about the different \npolicies that versioning systems implement. Versioning policies include\ndecisions on the shape of version histories (linear or branched), the \ngranularity of change tracking, locking requirements made by a server, \netc. The protocol should clearly identify the policies that it dictates\nand the policies that are left up to versioning system implementors or\nadministrators.\n\n5.9.1.5. It is possible to version resources of any media type.\n\n5.9.2. Functional Requirements\n\n5.9.2.1. Referring to a version graph. There must be a way to refer to\na version graph as a whole.  \n\nSome queries and operations apply, not to any one member of a\nversion graph, but to the version graph as a whole.  For example, a \nclient may request that an entire graph be moved, or may ask for a \nversion history. In these cases, a way to refer to the whole version \ngraph is required.\n\n5.9.2.2. Referring to a specific member of a version graph. There must\nbe a way to refer to each member of a version graph. This means that \neach member of the graph is itself a resource. \n\nEach member of a version graph must be a resource if it is to be \npossible for a hypertext link to refer to specific version of a page, \nor for a client to request a specific version of a document for editing.\n\nSlein, Vitali, Whitehead, Durand                                Page 13\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n5.9.2.3. A client must be able to determine whether a resource is a \nversion graph, or whether a resource is itself a member of a version \ngraph.\n\nA resource may be a simple, non-versioned resource, or it may be a \nversion graph, or it may be a member of a version graph.  A client needs\nto be able to tell which sort of resource it is accessing.\n\n5.9.2.4. There must be a way to refer to a server-defined default \nmember of a version graph.\n\nThe server should return a default version of a resource for requests \nthat ask for the default version, as well as for requests where no\nspecific version information is provided. This is one of the simplest \nways to guarantee non-versioning client compatibility. This does not \nrule out the possibility of a server returning an error when no sensible\ndefault exists.\n\nIt may also be desirable to be able to refer to other special members \nof a version graph. For example, there may be a current version for\nediting that is different from the default version.  For a graph with\nseveral branches, it may be useful to be able to request the tip version\nof any branch.\n\n5.9.2.5. It must be possible, given a reference to a member of a version\ngraph, to find out which version graph(s) that resource belongs to.\n\nThis makes it possible to understand the versioning context of the \nresource. It makes it possible to retrieve a version history for the \ngraphs to which it belongs, and to browse the version graph. It also \nsupports some comparison operations: It makes it possible to determine \nwhether two references designate members of the same version graph.\n\n5.9.2.6. Navigation of a version graph.  Given a reference to a member \nof a version graph, it must be possible to discover and access the \nfollowing related members of the version graph.\n   o root member of the graph\n   o predecessor member(s)\n   o successor member(s)\n   o default member of the graph\n\nIt must be possible in some way for a versioning client to access\nversions related to a resource currently being exhamined.\n\n5.9.2.7. Version Topology. There must be a way to retrieve the complete \nversion topology for a version graph, including information about all \nmembers of the version graph. The format for this information must be \nstandardized so that the basic information can be used by all clients. \nOther specialized formats should be accomodated, for servers and \nclients that require information that cannot be included in the \nstandard topology.\n\n5.9.2.8. A client must be able to request that the server generate a \nversion identifier for a new member of a version graph. Such an \nidentifier will not be used by any other client in the meantime. The \n\nSlein, Vitali, Whitehead, Durand                                Page 14\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n\n5.9.2.9. A client must be able to propose a version identifier to be \nused for a new member of a version graph. The server may refuse to use \nthe client's suggested version identifier.\n\n5.9.2.10. A version identifier must be unique across a version graph.\n\n5.9.2.11. A client must be able to supply version-specific metadata to \nbe associated with a new member of a version graph. (See Section 5.1 \n\"Attributes\" above.) At a minimum, it must be possible to associate \ncomments with the new member, explaining what changes were made.\n\n5.9.2.12. A client must be able to query the server for information \nabout a version tree, including which versions are locked, which are \nreserved for editing, and by whom (Session Tracking).\n\n5.9.2.13. It must be possible for a client to get from the server a list\nof the differences between two or more resources of the same media type.\n\n5.9.2.14. A client must be able to request that the server merge two or \nmore resources, and return the result of the merge to the client or\nstore the result as a resource.  Server support for this functionality\nis optional.\n\n5.9.2.15. Versioning has implications for the semantics of move, copy, \nand delete operations.  See \"5.7. Name Space Manipulation\" above.  In\naddition, if the WebDAV extensions allow versioning servers to PUT or\nPOST new members into a version graph, the semantics of those methods\nmust be extended to encompass the new functionality.\n\n5.9.3. Rationale\n\nVersioning in the context of the world-wide web offers a variety of\nbenefits:\n\nIt provides infrastructure for efficient and controlled management of \nlarge evolving web sites. Modern configuration management systems are \nbuilt on some form of repository that can track the revision history of\nindividual resources, and provide the higher-level tools to manage \nthose saved versions. Basic versioning capabilities are required to \nsupport such systems.\n\nIt allows parallel development and update of single resources. Since \nversioning systems register change by creating new objects, they\nenable simultaneous write access by allowing the creation of variant\nversions. Many also provide merge support to ease the reverse operation.\n\nIt provides a framework for coordinating changes to resources. While \nspecifics vary, most systems provide some method of controlling or \ntracking access to enable collaborative resource development.\n\nIt allows browsing through past and alternative versions of a resource.\nFrequently the modification and authorship history of a resource is\ncritical information in itself.\n\n\nSlein, Vitali, Whitehead, Durand                                Page 15\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\nannotation and link-server support. Both annotation and link servers \nfrequently need to store stable references to portions of resources \nthat are not under their direct control. By providing stable states of \nresources, version control systems allow not only stable pointers into \nthose resources, but also well-defined methods to determine the \nrelationships of those states of a resource.\n\nIt allows explicit semantic representation of single resources with \nmultiple states. A versioning system directly represents the fact that \na resource has an explicit history, and a persistent identity across \nthe various states it has had during the course of that history.\n\n5.10. Authentication and Security\n\nThe WebDAV extensions should make use of existing authentication and \nsecurity protocols.  The WebDAV specification must state how the WebDAV\nextensions interoperate with existing authentication and security\nschemes.\n\n6. Acknowledgements\n\nOur understanding of these issues has emerged as the result of much\nthoughtful discussion, email, and assistance by many people, who\ndeserve recognition for their effort.\n\nMartin Cagan, Continuus Software, Marty_Cagan@continuus.com\nSteve Carter, Novell, srcarter@novell.com\nDan Connolly, World Wide Web Consortium, connolly@w3.org\nJim Cunningham, Netscape, jfc@netscape.com\nMark Day, Lotus, Mark_Day@lotus.com\nAssad Faizi, Netscape, asad@netscape.com\nRon Fein, Microsoft, ronfe@microsoft.com\nDavid Fiander, Mortice Kern Systems, davidf@mks.com\nRoy Fielding, U.C. Irvine, fielding@ics.uci.edu\nYaron Goland, Microsoft, yarong@microsoft.com\nPhill Hallam-Baker, MIT, hallam@ai.mit.edu\nDennis Hamilton, Xerox PARC, hamilton@parc.xerox.com\nAndre van der Hoek, University of Colorado, Boulder,\n  andre@bigtime.cs.colorado.edu\nDel Jensen, Novell, dcjensen@novell.com\nGail Kaiser, Columbia University, kaiser@cs.columbia.edu\nRohit Khare, World Wide Web Consortium, khare@w3.org\nDave Long, America Online, dave@sb.aol.com\nHenrik Frystyk Nielsen, World Wide Web Consortium, frystyk@w3.org\nOra Lassila, Nokia Research Center, ora.lassila@research.nokia.com\nLarry Masinter, Xerox PARC, masinter@parc.xerox.com\nMurray Maloney, SoftQuad, murray@sq.com\nJim Miller, World Wide Web Consortium, jmiller@w3.org\nKeith Moore, University of Tennessee, Knoxville, moore@cs.utk.edu\nAndrew Schulert, Microsoft, andyschu@microsoft.com\nChristopher Seiwald, Perforce Software, seiwald@perforce.com\nEinar Stefferud, stef@nma.com\nRichard Taylor, U.C. Irvine, taylor@ics.uci.edu\nRobert Thau, MIT, rst@ai.mit.edu\n\n\nSlein, Vitali, Whitehead, Durand                                Page 16\n\fdraft-slein-www-dist-author-00.txt   WebDAV Requirements   February 1997\n\n\n[1] T. Berners-Lee, D. Connolly, \"HyperText Markup Language\nSpecification - 2.0\", RFC 1866, MIT/LCS, November 1995.\n\n[2] T. Berners-Lee, L. Masinter, M. McCahill. \"Uniform Resource\nLocators (URL)\", RFC 1738, CERN, Xerox PARC, University of Minnesota,\nDecember 1994.\n\n[3] P. Feiler, \"Configuration Management Models in Commercial\nEnvironments\", Software Engineering Institute Technical Report\nCMU/SEI-91-TR-7, \n<http://www.sei.cmu.edu/products/publications/91.reports/91.tr.007.html>\n\n[4] R. Fielding, J. Gettys, J. C. Mogul, H. Frystyk, and\nT. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2068,\nU.C. Irvine, DEC, MIT/LCS, January 1997.\n\n[5] A. Haake, D. Hicks, \"VerSE: Towards Hypertext Versioning Styles\", \nProc. Hypertext'96, The Seventh ACM Conference on Hypertext, 1996,\npages 224-234.\n\n8. Authors' Addresses\n\nJudith Slein\nXerox Corporation\n800 Phillips Road 128-29E\nWebster, NY 14580\n\nEMail: slein@wrc.xerox.com\n\nFabio Vitali\nDepartment of Computer Science\nUniversity of Bologna\nITALY\n\nEMail: fabio@cs.unibo.it\n\nE. James Whitehead, Jr.\nDepartment of Information and Computer Science\nUniversity of California\nIrvine, CA 92697-3425\n\nFax: 714-824-4056\nEMail: ejw@ics.uci.edu\n\nDavid G. Durand\nDepartment of Computer Science\nBoston University\nBoston, MA\n\nEMail: dgd@cs.bu.edu\n\nExpires August 28, 1997\n\nSlein, Vitali, Whitehead, Durand                                Page 17\n\f\n", "encoding": "ascii"}