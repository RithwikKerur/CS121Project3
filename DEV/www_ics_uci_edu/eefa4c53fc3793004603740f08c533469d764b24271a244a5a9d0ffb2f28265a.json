{"url": "https://www.ics.uci.edu/~thornton/ics46/Notes/MultidimensionalData/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 46 Spring 2018, Notes and Examples: Multidimensional Data</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 46 Spring 2018 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 46 Spring 2018<br />\r\n   Notes and Examples: Multidimensional Data</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Single-dimension arrays in C++</p>\r\n\r\n<p>In C++, you've no doubt seen before that there are single-dimension arrays, and that they come in two flavors: statically-allocated and dynamically-allocated.</p>\r\n\r\n<p>As with anything else in C++, the statically-allocated version of an array has to be allocated by the compiler, so it must be possible to determine the size of the array at compile time; that means the size appears as part of the array's declaration, at which time the compiler must provide for its allocation.</p>\r\n\r\n<blockquote><pre>\r\nint a[10];\r\n</pre></blockquote>\r\n\r\n<p>Note that there is also a feature called <i>variable-length arrays</i> in recent versions of C, which is supported as an extension by some C++ compilers, but that is not officially part of the C++ standard.  It allows you to do what appears to be static allocation of an array whose size is not known until run time:</p>\r\n\r\n<blockquote><pre>\r\nvoid foo(unsigned int n)\r\n{\r\n    int a[n];\r\n\r\n    // ...\r\n}\r\n</pre></blockquote>\r\n\r\n<p>While this feature can be implemented a bit differently by different compilers that allow it &mdash; because it is not, after all, a part of the C++ language, but is instead an extension provided by the compiler &mdash; our compiler allocates it dynamically on the run-time stack (i.e., it pushes it to the top of the stack when the time comes, then pops it when it falls out of scope).  This is potentially problematic for a few reasons, not the least of which is that the run-time stack is generally allocated with a fairly limited size, so if <b>n</b> has a large value, that can cause problems up to and including program crashes.</p>\r\n\r\n<p>Meanwhile, we can dynamically allocate arrays using the <b>new</b> operator, with the result being a pointer to the array's first element.  Because it's allocated dynamically, its size can be determined at run time (e.g., by an expression with an integral type), and there are fewer restrictions on how large they can be.</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[size];\r\n</pre></blockquote>\r\n\r\n<p>Note, too, that even a statically-allocated array can be passed as a parameter, in which case you're really passing a pointer to its first element.  So, ultimately, the function below could accept an array regardless of how it was allocated.  And recall that you would need to pass the array's size as an additional parameter, since arrays don't carry size information with them and don't do any automated bounds checking.  (This is one reason to consider using <b>std::vector</b> instead, which you can think of as a single-dimension array that is managed with the RAII technique, and which also provides the option of bounds checking by using the <b>at()</b> member function in place of the <b>[ ]</b> operator.)</p>\r\n\r\n<blockquote><pre>\r\nvoid zeroArray(int* a, unsigned int size)\r\n{\r\n    for (unsigned int i = 0; i &lt; size; ++i)\r\n    {\r\n        a[i] = 0;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>For a longer treatment of this prerequisite topic, you can also check out the <a href=\"http://www.ics.uci.edu/~thornton/ics45c/Notes/SingleDimensionArrays\">Single-Dimension Arrays notes from my most recent ICS 45C offering</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Multidimensional arrays in C++</p>\r\n\r\n<p>Some data is inherently <i>multidimensional</i>, so the ability to store it in a data structure that lets you index in multiple dimensions can make it much easier to work with it.  As always, we choose data structures on the basis of how convenient and how performant it will be for us to use them to solve the problems we're actually trying to solve.  Something we can use to manage multidimensional data simply and efficiently would be a useful tool to add to our toolbox.</p>\r\n\r\n<p>C++ offers the ability to create <i>multidimensional arrays</i>, though, like most things in C++, it's important that you understand some of their underlying implementation details, because they're limited in ways that don't necessarily make sense until you understand the details of how they work.</p>\r\n\r\n<p class=\"subtitle\">Statically-allocated multidimensional arrays</p>\r\n\r\n<p>The most direct way to create a multidimensional array in C++ is to statically allocate it, which we do by including the size of each of its dimensions as part of its declaration.  Because statically-allocated arrays have to be allocated at compile time, the bounds of each dimension must be constants (or, at the very least, <b>constexpr</b>s, i.e., expressions that can be evaluated at compile time).  Once defined, we can access its individual cells by indexing it in all dimensions.  In the example below, we create a two-dimensional array and store a value in all of its cells.</p>\r\n\r\n<blockquote><pre>\r\nint a[4][5];\r\n\r\nfor (int i = 0; i &lt; 4; ++i)\r\n{\r\n    for (int j = 0; j &lt; 5; ++j)\r\n    {\r\n        a[i][j] = i * j;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>From a purely conceptual perspective, you can think of this data representing whatever you'd like.  Speaking strictly conceptually, the \"meaning\" of the dimensions is determined by the problem you're trying to solve; as long as you index it correctly (i.e., you use the index appropriate for each dimension), you'll get the values you want.  So, for example, you could think of the data in your mind as a matrix with four rows and five columns, in which case you'd have to index it by specifying a row first and then a column:</p>\r\n\r\n<table class=\"normal\">\r\n  <tr>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>1</td>\r\n    <td>2</td>\r\n    <td>3</td>\r\n    <td>4</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>2</td>\r\n    <td>4</td>\r\n    <td>6</td>\r\n    <td>8</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>3</td>\r\n    <td>6</td>\r\n    <td>9</td>\r\n    <td>12</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>Or, alternatively, you could think of it as a matrix with four columns and five rows, in which case you'd have to index it by specifying a column first and then a row:</p>\r\n\r\n<table class=\"normal\">\r\n  <tr>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>1</td>\r\n    <td>2</td>\r\n    <td>3</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>2</td>\r\n    <td>4</td>\r\n    <td>6</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>3</td>\r\n    <td>6</td>\r\n    <td>9</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>4</td>\r\n    <td>8</td>\r\n    <td>12</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>Speaking strictly conceptually, neither of these is inherently \"correct\"; it's purely a matter of how you've chosen to organize your data, and how you've chosen to think about it, with the only constraint being that you're consistent in your uses of the two dimensions, such that the first dimension in your indexing operation matches the first dimension when you allocated, and the second matches the second.</p>\r\n\r\n<p class=\"subtitle\">How multidimensional arrays are stored in memory</p>\r\n\r\n<p>However, we also have to be cognizant of how multidimensional arrays are actually stored in memory, because that implementation technique imposes some constraints on how we use them, how we pass them as parameters, and so on.  C++ stores multidimensional arrays in what is sometimes called <i>row-major order</i>, though this term only makes sense if you have the same mental bias about what constitutes a \"row\" and what constitutes a \"column\" as the person who coined that term.  So, an alternative way to think about it is to think of it as <i>first-dimension-major order</i>, which is to say that all elements with the same index in the first dimension will be contiguous, and that the groups of elements with consecutive values in that dimension are also contiguous to one another.  Our example two-dimensional array above would be laid out in memory like this, in one long, contiguous block of memory:</p>\r\n\r\n<table class=\"normal\">\r\n  <tr class=\"divider\">\r\n    <td>a[0][0]</td>\r\n    <td>a[0][1]</td>\r\n    <td>a[0][2]</td>\r\n    <td>a[0][3]</td>\r\n    <td>a[0][4]</td>\r\n    <td>a[1][0]</td>\r\n    <td>a[1][1]</td>\r\n    <td>a[1][2]</td>\r\n    <td>a[1][3]</td>\r\n    <td>a[1][4]</td>\r\n    <td>a[2][0]</td>\r\n    <td>a[2][1]</td>\r\n    <td>a[2][2]</td>\r\n    <td>a[2][3]</td>\r\n    <td>a[2][4]</td>\r\n    <td>a[3][0]</td>\r\n    <td>a[3][1]</td>\r\n    <td>a[3][2]</td>\r\n    <td>a[3][3]</td>\r\n    <td>a[3][4]</td>\r\n  </tr>\r\n  <tr>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>0</td>\r\n    <td>1</td>\r\n    <td>2</td>\r\n    <td>3</td>\r\n    <td>4</td>\r\n    <td>0</td>\r\n    <td>2</td>\r\n    <td>4</td>\r\n    <td>6</td>\r\n    <td>8</td>\r\n    <td>0</td>\r\n    <td>3</td>\r\n    <td>6</td>\r\n    <td>9</td>\r\n    <td>12</td>\r\n  </tr>\r\n  <tr class=\"divider\">\r\n    <td colspan=\"5\">a[0]</td>\r\n    <td colspan=\"5\">a[1]</td>\r\n    <td colspan=\"5\">a[2]</td>\r\n    <td colspan=\"5\">a[3]</td>\r\n  </tr>\r\n</table>\r\n\r\n<p>You might wonder why C++ \"flattens\" a multidimension array in memory, but it's important to realize that <i>all</i> of memory can be thought of as essentially one giant array, with a pointer or a reference representing an index into that giant array.  Ultimately, <i>everything</i> is flattened in one way or another, with pointers and references used to help us find things that aren't immediately contiguous to one another.  Some technique for flattening needs to be used; C++ uses the technique above.</p>\r\n\r\n<p>You might also wonder why it's important for us to know this underlying implementation detail.  If it's being done by the compiler automatically, why should we have to care about it?  Is it just intellectual curiosity that makes us wonder about it, or does it have a bearing on how we use it?  To understand the answer to this question, we need to also understand how individual cells in a multidimensional array are found.</p>\r\n\r\n<p class=\"subtitle\">How indexing into a multidimensional array actually works</p>\r\n\r\n<p>You have likely seen previously that C++ indexes into a single-dimension array by performing an address calculation.  If you've declared the following array:</p>\r\n\r\n<blockquote><pre>\r\nint x[10];\r\n</pre></blockquote>\r\n\r\n<p>then you can think of the value of <b>x</b> as really being a pointer to the first element in the array.  (This is why, if you were to pass <b>x</b> as an argument to some function, <b>int*</b> would be a compatible type for the corresponding parameter.)</p>\r\n\r\n<p>If you index into that array with the expression <b>x[i]</b>, the compiler needs to generate code that finds the appropriate element.  Since all of the elements are contiguous, and since they're all the same type (and, therefore, the same size), the calculation, conceptually, is <b>address of x + (sizeof(int) * i)</b>, a calculation that you can also write in C++ by using <i>pointer arithemtic</i>: <b>x + i</b>.\r\n\r\n<p>Indexing into a multidimensional array is actually fairly similar, except it's a multi-step process (one for each dimension).  For example, in our two-dimensional array <b>a</b> declared earlier in these notes, the expression <b>a[i][j]</b> would result in the following calculation being necessary.  (Sticking with C++ implementation terminology, we'll use \"rows\" to describe the first dimension and \"columns\" to describe the second.)</p>\r\n\r\n<ul>\r\n  <li>We know already where <b>a[0][0]</b> is, because <b>a</b> can be thought of as a pointer to the first element of the two-dimensional array.</li>\r\n  <li>We first need to know where <b>a[i][0]</b> is, which will get us to the correct row.  This can be done with the following conceptual calculation: <b>address of a + (sizeof(int) * i * 5)</b>, where <b>5</b> appears because it's the number of columns in each row.</li>\r\n  <li>Then, we need to know where <b>a[i][j]</b> is.  If we've already got the address of a[i][0], we can do this: <b>address of a[i][0] + (sizeof(int) * j)</b>.</li>\r\n</ul>\r\n\r\n<p>Putting all of this together, expressed using C++ pointer arithemtic syntax, we have: <b>a + (i * 5) + j</b>.  Note that the constant <b>5</b> (the number of columns) appears in this formula, but the constant <b>4</b> (the number of rows) does not.  Extending this idea to a third dimension, a fourth dimension, and so on, we would see a fundamental truth: The size of every dimension <i>except the first</i> would have to be known in order to do this calculation.</p>\r\n\r\n<p class=\"subtitle\">Passing a multidimensional array to a function</p>\r\n\r\n<p>We've seen before that arrays can be represented easily as pointers to their first element, so you might expect to be able to pass a multidimensional array the same way.  And you've seen, also, that arrays do not store size information, so we would expect also to have to pass the size of its dimensions as additional parameters.  That would lead you to believe that you could write this:</p>\r\n\r\n<blockquote><pre>\r\nvoid fillTwoDArray(int* a, int rows, int columns)\r\n{\r\n    for (int i = 0; i &lt; rows; ++i)\r\n    {\r\n        for (int j = 0; j &lt; columns; ++j)\r\n        {\r\n            a[i][j] = i * j;\r\n        }\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>However, if you think about the realities of how a two-dimensional array is implemented, you'll see that this can't possibly work.  The compiler will need to compile the expression <b>a[i][j]</b> into machine code that finds the appropriate cell in the two-dimensional array.  But, as we've seen, the formula for doing that has an important input that can't be left out: <i>the size of the second dimension!</i>  And even though that's technically been passed as a parameter to our function, C++ isn't aware of the correlation.</p>\r\n\r\n<p>For the same reason, the following reasonable-looking line of code won't compile, either:</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[4][5];\r\n</pre></blockquote>\r\n\r\n<p>because two-dimensional arrays can't be represented simply by a pointer to their first element.</p>\r\n\r\n<p class=\"subtitle\">Passing a multidimensional array as a parameter to a function</p>\r\n\r\n<p>In order to make our <b>fillTwoDArray</b> function work, the size of the second dimension has to be expressed as part of its type, making the following version legal.</p>\r\n\r\n<blockquote><pre>\r\nvoid fillTwoDArray(int a[][5], int rows)\r\n{\r\n    for (int i = 0; i &lt; rows; ++i)\r\n    {\r\n        for (int j = 0; j &lt; 5; ++j)\r\n        {\r\n            a[i][j] = i * j;\r\n        }\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>It should be noted, though, that this function is more limited; it only works for a two-dimensional array whose second dimension is size 5.  We could overcome that limitation by using a function template instead.</p>\r\n\r\n<blockquote><pre>\r\ntemplate &lt;int Columns&gt;\r\nvoid fillTwoDArray(int a[][Columns], int rows)\r\n{\r\n    for (int i = 0; i &lt; rows; ++i)\r\n    {\r\n        for (int j = 0; j &lt; Columns; ++j)\r\n        {\r\n            a[i][j] = i * j;\r\n        }\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>Note that the reason the function template can work is because template parameters are always determined at compile time, so <b>Columns</b> will be a constant expression, which will appear in a call to the function:</p>\r\n\r\n<blockquote><pre>\r\nfillTwoDArray&lt;5&gt;(a, 4);\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Dynamically-allocated multidimensional data</p>\r\n\r\n<p>Unfortunately, as we've seen, multidimensional arrays in C++ are limited to scenarios where we can determine the size of all of their dimensions except the first at compile time.  Even if we dynamically allocate them, the only dimension whose value can be determined dynamically is the first one.  So what do we do if we want dynamically-allocated multidimensional data, whose size we can't determine, in any dimension, until the program runs?  There are a few possible answers to this.</p>\r\n\r\n<p class=\"subtitle\">Dynamically-allocated multidimensional arrays</p>\r\n\r\n<p>While you can't dynamically allocate a multidimensional array directly, there is an alternative that works: Dynamically allocating a single-dimension array of dynamically-allocated single-dimension arrays.</p>\r\n\r\n<blockquote><pre>\r\nint** a = new int*[rows];\r\n\r\nfor (int i = 0; i &lt; rows; ++i)\r\n{\r\n    a[i] = new int[columns];\r\n}\r\n</pre></blockquote>\r\n\r\n<p>This would be implemented with <b>a</b> being a pointer to the first element of a single-dimension array, in which each element is a pointer to the first element of some other single-dimension array.  Indexing into this requires doing an address calculation, then following a pointer to one of the \"subarrays,\" then doing another address calculation into the subarray.  Syntactically, though, it would be identical:</p>\r\n\r\n<blockquote><pre>\r\nfor (int i = 0; i &lt; rows; ++i)\r\n{\r\n    for (int j = 0; j &lt; columns; ++j)\r\n    {\r\n        a[i][j] = i * j;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">A single-dimension array treated as multidimensional</p>\r\n\r\n<p>Another option would be to allocate a single-dimension array dynamically, then do the address calculation yourself to make it act as though it was multidimensional.  This would leave you the ability to use a dynamic number of rows and columns in the calculation, with the tradeoff being that you'd have to implement the calculation &mdash; though it would be something you could put into a short, inlineable function, so it would quite likely perform well.  (And it wouldn't be a bad idea to write a function to do the indexing, for the simple reason that rewriting the same formula repeatedly would leave you the opportunity to make a mistake in one or more of its uses.)</p>\r\n\r\n<blockquote><pre>\r\nint* a = new int[rows * columns];\r\n\r\nfor (int i = 0; i &lt; rows; ++i)\r\n{\r\n    for (int j = 0; j &lt; columns; ++j)\r\n    {\r\n        a[i * columns + j] = i * j;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n<p>This is, more or less, a manually-implemented version of what C++ does already with multidimension arrays.  The only trick is that writing the code ourselves allows us to write our own calculation that is capable of working purely with dynamic values that aren't known until run time.</p>\r\n\r\n<p class=\"subtitle\">A vector of vectors</p>\r\n\r\n<p>A third option would be to use a <b>std::vector</b>, in which each element is a <b>std::vector</b> of values.  From a performance perspective, this would be quite similar to the \"pointer to an array of pointers to arrays\" solution above, but with some of the underlying details automated for you.</p>\r\n\r\n<blockquote><pre>\r\n// This version of the std::vector constructor allows you to give it a size\r\n// and fill in all of these cells with the same value automatically, which is\r\n// a handy way to make it start out with the right size.\r\nstd::vector&lt;std::vector&lt;int&gt;&gt; a(rows, std::vector&lt;int&gt;(columns));\r\n\r\nfor (int i = 0; i &lt; rows; ++i)\r\n{\r\n    for (int j = 0; j &lt; columns; ++j)\r\n    {\r\n        a[i][j] = i * j;\r\n    }\r\n}\r\n</pre></blockquote>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}