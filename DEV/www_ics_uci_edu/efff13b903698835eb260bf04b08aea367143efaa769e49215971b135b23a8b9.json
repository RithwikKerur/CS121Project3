{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/FastPair.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Fast pair algorithm: hybrid of conga line and nearest neighbors\n\n#include \"FastPair.h\"\n#include \"Error.h\"\n\n// Subroutine to find nearest neighbor of a given point\nvoid FastPair::FindNeighbor(point p)\n{\n\t// if no neighbors avail, set flag for UpdatePoint to find\n\tif (npoints == 1) {\n\t\tneighbors[p] = p;\n\t\tnbr_dist[p] = MAX_DISTANCE;\n\t\treturn;\n\t}\n\n\t// find first point unequal to p itself\n\tint first_nbr = 0;\n\tif (p == points[first_nbr]) first_nbr = 1;\n\tneighbors[p] = points[first_nbr];\n\tnbr_dist[p] = dist(p, neighbors[p]);\n\n\t// now test whether each other point is closer\n\tfor (long i = first_nbr + 1; i < npoints; i++)\n\t{\n\t\tpoint q = points[i];\n\t\tif (q != p) {\n\t\t\tdouble d = dist(p,q);\n\t\t\tif (d < nbr_dist[p]) {\n\t\t\t\tnbr_dist[p] = d;\n\t\t\t\tneighbors[p] = q;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Set up\nFastPair::FastPair(long np, long mp, Distance & d)\n\t: ClosestPairs(np,mp,d), points(new point[mp]), neighbors(new point[mp]),\n\t  where_are_the_points(new point[mp]), nbr_dist(new double[mp]), dist(d)\n{\n\tif (points == 0 || where_are_the_points == 0 || neighbors == 0 ||\n\t\tnbr_dist == 0) error(\"NeighborCP: unable to create neighbor arrays\");\n\t\t\n\tgInsertions += np;\n\tnpoints = np;\n\t\n\t// set up points array for conga line\n\tunsigned long i;\n\tfor (i = 0; i < np; i++) points[i] = i;\n\n\t// Find all neighbors. We use a conga line rather than calling FindNeighbor.\n\tpoint * p = points;\n\twhile (np > 1) {\n\t\n\t\t// find neighbor to p[0]\n\t\tpoint nbr = 1;\n\t\tdouble nbd = dist(p[0], p[1]);\n\t\tfor (i = 2; i < np; i++) {\n\t\t\tdouble d = dist(p[0],p[i]);\n\t\t\tif (d < nbd) {\n\t\t\t\tnbr = i;\n\t\t\t\tnbd = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add that edge, move nbr to p[1], increment p\n\t\tneighbors[p[0]] = p[nbr];\n\t\tnbr_dist[p[0]] = nbd;\n\t\tp[nbr] = p[1];\n\t\tp[1] = neighbors[p[0]];\n\t\tp++;\n\t\tnp--;\n\t}\n\t\n\t// No more neighbors, terminate conga line\n\tneighbors[p[0]] = p[0];\n\tnbr_dist[p[0]] = MAX_DISTANCE;\n\t\n\t// set where_are...\n\tfor (i = 0; i < npoints; i++)\n\t\twhere_are_the_points[points[i]] = i;\n}\n\n// Clean up\nFastPair::~FastPair()\n{\n\tdelete points;\n\tdelete where_are_the_points;\n\tdelete neighbors;\n\tdelete nbr_dist;\n}\n\n// Add a point and find its nearest neighbor\nvoid FastPair::operator += (point p)\n{\n\tgInsertions++;\n\tFindNeighbor(p);\n\tpoints[where_are_the_points[p] = npoints++] = p;\n}\n\n// Remove a point and update neighbors of points for which it had been nearest\nvoid FastPair::operator -= (point p)\n{\n\tgDeletions++;\n\tnpoints--;\n\tunsigned long q = where_are_the_points[p];\n\twhere_are_the_points[points[q] = points[npoints]] = q;\n\n\tfor (long i = 0; i < npoints; i++)\n\t\tif (neighbors[points[i]] == p)\n\t\t\tFindNeighbor(points[i]);\n}\n\n// Find closest pair by scanning list of nearest neighbors\ndouble FastPair::operator () (point & a, point & b)\n{\n\tif (npoints < 2) error(\"FastPair: not enough points to form pair\");\n\tgPairs++;\n\tdouble d = nbr_dist[points[0]];\n\tpoint r = 0;\n\tfor (long i = 1; i < npoints; i++) {\n\t\tif (nbr_dist[points[i]] < d) {\n\t\t\td = nbr_dist[points[i]];\n\t\t\tr = i;\n\t\t}\n\t}\n\ta = points[r];\n\tb = neighbors[a];\n\treturn d;\n}\n\n// All distances to point have changed, check if our structures are ok\n// Note that although we completely recompute the neighbors of p,\n// we don't explicitly call FindNeighbor, since that would double\n// the number of distance computations made by this routine.\n// Also, like deletion, we don't change any other point's neighbor to p.\nvoid FastPair::UpdatePoint(point p)\n{\n\tneighbors[p] = p;\t// flag for not yet found any\n\tnbr_dist[p] = MAX_DISTANCE;\n\tfor (long i = 0; i < npoints; i++) {\n\t\tpoint q = points[i];\n\t\tif (q != p) {\n\t\t\tdouble d = dist(p,q);\n\t\t\tif (d < nbr_dist[p]) {\n\t\t\t\tnbr_dist[p] = d;\n\t\t\t\tneighbors[p] = q;\n\t\t\t}\n\t\t\tif (neighbors[q] == p) {\n\t\t\t\tif (d > nbr_dist[q]) FindNeighbor(q);\n\t\t\t\telse nbr_dist[q] = d;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Single distance has changed, check if our structures are ok\nvoid FastPair::UpdateDistance(point p, point q)\n{\n\tdouble d = dist(p,q);\n\n\tif (d < nbr_dist[p]) {\n\t\tnbr_dist[p] = q;\n\t\tneighbors[p] = q;\n\t} else if (neighbors[p] == q && d > nbr_dist[p]) FindNeighbor(p);\n\n\tif (d < nbr_dist[q]) {\n\t\tnbr_dist[q] = p;\n\t\tneighbors[q] = p;\n\t} else if (neighbors[q] == p && d > nbr_dist[q]) FindNeighbor(q);\n}\n", "encoding": "ascii"}