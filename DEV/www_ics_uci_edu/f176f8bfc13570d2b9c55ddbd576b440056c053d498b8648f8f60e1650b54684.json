{"url": "https://www.ics.uci.edu/~eppstein/263/s14-hw1.html", "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\n<html>\n<head>\n<title>CompSci 263, Spring 2014, Homework 1</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}\n});\n</script>\n<script type=\"text/javascript\"\n  src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n</head>\n<body>\n<h1>CS 263, Spring 2014, Homework 1</h1>\n<h2>Due at the start of class, Thursday, April 10</h2>\n\n<ol>\n<li>\n[Mitzenmacher and Upfal]\n\n<p>Suppose that you are trying to write a program that takes as input a number <i>x</i> and that outputs the value of the function <i>mystery</i>(<i>x</i>). Here's what you know about this function:</p>\n<ul>\n<li><p>Its inputs and outputs are both integers in the range from 0 to 99.</p></li>\n<li><p>For any two numbers <i>x</i> and <i>y</i> in this range, <i>mystery</i>(<i>x</i>&nbsp;+&nbsp;<i>y</i>&nbsp;mod&nbsp;100) = \n<i>mystery</i>(<i>x</i>)&nbsp;+&nbsp;mystery</i>(<i>y</i>)&nbsp;mod&nbsp;100.</p>\n<li><p>Your program has access to an array <i>M</i>[<i>x</i>] of length 100 which originally stored the values of the <i>mystery</i> function: that is, at some point in the past, the array values satisfied the equation <i>M</i>[<i>x</i>]&nbsp;=&nbsp;<i>mystery</i>(<i>x</i>).</p></li>\n<li><p>Unfortunately cosmic rays have corrupted up to 20 of the array values, replacing them with incorrect numbers.</p></li>\n</ul>\n<p>Describe how to use this information in a randomized algorithm for computing <i>mystery</i>(<i>x</i>), regardless of whether <i>M</i>[<i>x</i>] is or is not one of the corrupted cells. Your algorithm should guarantee that the probability getting a correct answer is at least 1/2. It should use as few table lookups and as little computation as possible.</p>\n</li>\n\n<li>\n<ol type=\"a\"><li><p>Suppose we have a randomized algorithm R for answering some yes-or-no question. Algorithm R has probability 1/3 of making a wrong answer: that is, if the correct answer is yes, it answers yes with probability 2/3 and no with probability 1/3, and if the correct answer is no, it answers yes with probability 1/3 and no with probability 2/3. If we make three independent runs of algorithm R, and return the majority of the answers it gives, what is the probability that the answer we return is correct?</p></li>\n<li><p>How would the answer to part (a) change if algorithm R instead has probability 1/2 of making a wrong answer?</p></li></ol></li>\n\n<li><p>Freivald's algorithm checks whether a matrix product is correct by testing it against random vectors of 0's and 1's, but the Schwarz et al method for testing whether a polynomial is zero uses random choices from a larger set of values. Define a <i>bad polynomial</i> to be a polynomial that is not zero, but that appears to be zero whenever all of its arguments are zeros or ones (showing that the larger number of choices used by Schwarz et al is necessary for it to work correctly). For instance, the single-variable polynomial <i>x</i><sup>3</sup>&nbsp;&minus;&nbsp;<i>x</i> is bad, because its value is zero no matter whether <i>x</i> is zero or one. Find a three-variable bad polynomial with as small a degree as possible.</p>\n\n<li><p>Suppose that we wish to test whether a given polynomial is zero or not by evaluating it at a small number of points, but we wish to do so deterministically (meaning that we don't use any randomization and the result should always be correct). For two-variable polynomials of degree two, how many points do we need to test? Find a set of that many points that suffice for this problem.</p>\n</ol>\n", "encoding": "ascii"}