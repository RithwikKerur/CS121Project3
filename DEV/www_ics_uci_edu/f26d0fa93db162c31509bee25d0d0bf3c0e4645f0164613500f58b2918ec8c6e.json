{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/review/review.txt", "content": "The final exam is worth 200 points (the midterm/in-lab exams were 150 points).\r\nI have not written this exam yet, but I expect it to be like the midterm in\r\nform: about 10 questions (some might have multiple parts), each covering about\r\n1 week of material for the 10 week quarter. So, it is cumulative. Over this 120\r\nminute test, that is about 12 minutes per question (to read and answer it).\r\n\r\nWe have covered way too much material for you to re-read everything. I suggest\r\nprimarily reviewing the quizzes and midterm, and then the programming\r\nassignments: not reading them in depth, but being familiar with them and their\r\nmajor themes. Of course you will be analyzing and writing code on the final\r\nexam, but I expect there also to be a small number of questions to be answered\r\nin English or with pictures/diagrams.\r\n\r\nI will write in more detail over the weekend, after I have written the exam.\r\nI will provide the same kind of preview I provided for the midterm.\r\n\r\nHere is my view of the material that we covered.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nPreliminaries/Basics\r\n  EBNF\r\n  Tokenization\r\n  Defining and IMporting Names/Modules (binding them to objects they refer to)\r\n\r\nExpressions\r\n  Reading Function Headers and Calling Functions from modules\r\n    the print ubiquitous function\r\n       arbitrary number of arugments (str called on each)\r\n       named parameters sep/end and their meanings\r\n    parameter/argument binding\r\n    functions from prompt/predicate modules\r\n  Operators (individual meanings)\t  \r\n  Expressions built from literals, names, operators, and functions\r\n    operator precedence, associativity, and parentheses \r\n    (eventually including conditional expressions, lambdas, and comprehensions)\r\n\r\nStatements\r\n  if, if/else, if{/elsif}/else\r\n  for (with many objects to iterate over)\r\n  while (boolean-test, or if/break)\r\n  try/except\r\n  return, assert, raise (typically used in functions)\r\n\r\nAbstraction\r\n  modules   (using-importing/writing-scripts and libraries)\r\n  functions (using/writing)\r\n\r\nData Types\r\n  \"simple\" types\r\n      int, float, str, bool\r\n  data structures\r\n    lists (sorting lists, using lambdas)\r\n    tuple (like list but no mutation)/named tuple (not used much)\r\n    set\r\n    dictonary/defaultdict\r\n    combinations: e.g., lists/sets as dict values; dict keys are mostly str\r\n  building data structures with comprehensions\r\n  iterating over data structures with for loops\r\n    iterating using sorted\r\n    3 ways to iterative over dicts: keys, values, and items (producing 2-tuples)\r\n\r\nClasses\r\n  using prewritten classes: construction and calling methods\r\n    standard classes (e.g., list) special classes (e.g. Dict)\r\n  writing simple classes\r\n    the __init__ method for construction\r\n    methods: accessor/query (e.g., pip_sum) and mutatator/command (e.g., roll)\r\n\r\nSpecial Topics\r\n  program synthesis by iterative enhancement\r\n  debugging (using simple print statements and the debugger)\r\n  passing (uncalled) functions as arguments\r\n    prompt functions using predicate functions to filter bad data\r\n\r\n", "encoding": "ascii"}