{"url": "https://www.ics.uci.edu/~kibler/H23Homeworks.htm", "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\r\n<HTML>\r\n\r\n<HEAD>\r\n\t<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;CHARSET=iso-8859-1\">\r\n\t<META NAME=\"GENERATOR\" Content=\"Visual Page 2.0 for Windows\">\r\n\t<TITLE>H23 Homeworks</TITLE>\r\n</HEAD>\r\n\r\n<BODY BGCOLOR=\"#99FFFF\">\r\n\r\n<P><B>H23 Homeworks:</B> Typicallyl these homeworks have a theory portion and a design or coding portion.</P>\r\n\r\n<P><I><B>Warning:</B> Only the homework for the next assigment is guaranteed to be correct and complete. Look at\r\nthe assignment early and ask questions if you do not understand what you are supposed to do.</I></P>\r\n\r\n<P><B>NOTE: Due Time: </B>Coding assignments are due (i.e. need to be deposited) by 10pm on tuesday of the week\r\nthat the homework is due. Work that should be handed in is due at the beginning of class on Wednesday of the week\r\nthat homework is due. Late homeworks will be marked down by 20% for each day that it is late.</P>\r\n\r\n<P><B>Regrades: </B>For a regrade you must resubmit your homework within 1 week of receiving your score. Also you\r\nmust explain what part of your homework needs to be regraded. The entire assigment will be regraded so it is possible\r\nto lower your score on a regrade.</P>\r\n\r\n<P><I><BR>\r\n</I><B>Special Homework 0: Due wednesday by 5pm.</B></P>\r\n\r\n<P>Email your answers to me (kibler@ics.uci.edu) and cc the ta Li Zhang (lzhang1@uci.edu). Restrict your answer\r\nto a maximum of a paragraph.</P>\r\n\r\n<P>1. Tell me about any program that you have written purely for fun, i.e. not for any class assignment. If none,\r\nsay so.</P>\r\n\r\n<P>2. Tell me about a program that you would like to write.</P>\r\n\r\n<P><BR>\r\n<I><BR>\r\n</I><B>Homework 1:</B> Goal: <B>Review + practice object-oriented design + simple Gui interface</B></P>\r\n\r\n<P><B>Read </B>chapter 1. chapter 1 has some useful program examples as well as a review of some basic mathematical\r\ntechniques.</P>\r\n\r\n<P>1. . This is a finite induction problem.</P>\r\n\r\n<P>Prove: sum(i = 1 to i = N ) { 2*i -1} = N^2.</P>\r\n\r\n<P>2. This part requires no coding, only design. Suppose that you are coding a very limited banking systems. Customers\r\ncan only: open a savings account, close a savings account, add money to an account, and withdrawn money from an\r\naccount. You may assume that this is a new bank which begins with no customers. In the style of the lectures, define\r\nappropriate objects and methods. You should only turn in the your final design, not the steps you used to create\r\nthe design. Also include the driver program, ie. the program which puts the objects together. This should look\r\nlike a code, but would not execute since the needed objects have not been defined. Some people like to start by\r\nwriting the driver program, guessing what objects they might need.</P>\r\n\r\n<P>3. This part of the assigment involves writing a simple GUI interface. From the user get a file name. The file\r\nyou will use is WM.txt which is in the class folder XX. Your program will display: a) the total number of letters\r\n(characters from a through z), b) for each letter the number of times it occurs, and c) a graphical plot of the\r\nfrequency of each letter. More specifically, you plot (i-th letter, frequency of i-th letter). Upper case letters\r\nshould be &quot;normalized&quot; to lower case letters. This can be conveniently done by transforming every read\r\nString into a String of lower case letter via a String method.</P>\r\n\r\n<P><BR>\r\n<BR>\r\n<B>Homework 2</B>: Goal: <B>Reinforce familiarity with O notation + Proofs</B></P>\r\n\r\n<P><B>Read </B>chapter 5</P>\r\n\r\n<P>1. Do problem 5.14, only part a. ( 6 code fragments to analyze)</P>\r\n\r\n<P>2. Suppose T(N) = O(f(N)) and S(N) = O(g(N)).</P>\r\n\r\n<P>a) What is T(N)*S(N)?</P>\r\n\r\n<P>b) Prove it.</P>\r\n\r\n<P>c) What is T(N)+S(N)?</P>\r\n\r\n<P>d) Prove it.</P>\r\n\r\n<P>3. Definition: A set S is convex if whenever points p and q belong to the set, then for any x between 0 and\r\n1, the point x*p + (1-x)*q belongs to S.</P>\r\n\r\n<P>Prove that if S1 and S2 are convex, then S1 intersect S2 is convex. The proof is straightforward, as long as\r\nyou don't lose your head. Do not attempt a geometric proof, although that might provide insight/confidence in the\r\nresult. Algebraic proofs are usually easier, once you know what might be true.</P>\r\n\r\n<P><B>Homework 3:</B> Goal: Use <B>Gui Interface and standard Collection Classes</B></P>\r\n\r\n<P>This assignment is somewhat similar to assignment 1, but adds the uses of Collection classes. In this assignment\r\nyou will build a Gui interface that performs a simple statistical analysis of a text document. Use the swing classes\r\nas the awt library is deprecated. Using BorderLayout, in the north panel ask the user for a file to be processed.\r\nIn the west panel display, in sorted order, the frequency of all the words in the document. In the center panel\r\ndisplay a graph of the 100 most frequent words, in sorted order. The y-axis measures frequency of occurrence as\r\na percentage of the i-th most frequent word. So you plot the points (i-th word, frequences of i-th word). On the\r\nnorth panel display the total number of words and the total number of different words.</P>\r\n\r\n<P>You will read the file WM.txt again. One important question is: What constitutes a word? For the purposes of\r\nthis assignment a word is a sequence of characters surrounded by white-space where the first and last characters\r\nare letters. Also you need to remove final (not internal) punctuation. Hence Jackson7 is not a word and won't be\r\ncounted. Use StringTokenizer to identify candidate words. Use a Hashtable or HashMap, provided in the Collections\r\npackage, to keep track of the number of occurences of every word. Then use TreeSet, also provided in the Collections\r\npackage, to sort the words. You will sort the words by frequency so you need to define a Comparator.</P>\r\n\r\n<P>Start this assignment early. Do not write this is one fell swoop. Instead, start by writing a few of the simplest\r\nthrow-away programs that you can imagine that develop your understanding and confidence in individual features\r\nof the Java language.</P>\r\n\r\n<P><BR>\r\nTo help you with this assignment, I'm giving you a class I wrote called FileTokenizer that you might find useful.\r\nConceptually it is much like StringTokenizer on a file. It basically provides an iterator, but I did not make it\r\nimplement Iterator. Why not? If you find errors or improvements in this code, please let me know.</P>\r\n\r\n<P><BR>\r\nimport java.util.*;<BR>\r\n<BR>\r\nclass FileTokenizer <BR>\r\n{<BR>\r\nBufferedReader br;<BR>\r\nString line;<BR>\r\nStringTokenizer stok;<BR>\r\n<BR>\r\nFileTokenizer(String s)<BR>\r\n<BR>\r\n{<BR>\r\ntry<BR>\r\n{<BR>\r\nbr = new BufferedReader(new FileReader(s));<BR>\r\nline = br.readLine();<BR>\r\nstok = new StringTokenizer(line);<BR>\r\n}<BR>\r\ncatch(IOException ioe) {}; <BR>\r\n<BR>\r\n}<BR>\r\n<BR>\r\nString nextWord()<BR>\r\n{<BR>\r\nreturn stok.nextToken(); <BR>\r\n}<BR>\r\nboolean hasWord()<BR>\r\n{<BR>\r\ntry{<BR>\r\nif (stok.hasMoreElements()) return true;<BR>\r\nline = br.readLine();<BR>\r\n<BR>\r\nif (line == null) return false;<BR>\r\n<BR>\r\nstok = new StringTokenizer(line); // misses blank lines<BR>\r\nwhile ( !stok.hasMoreElements())<BR>\r\n{<BR>\r\nline = br.readLine();<BR>\r\nif (line == null) return false;<BR>\r\nstok = new StringTokenizer(line);<BR>\r\n}<BR>\r\nreturn true;<BR>\r\n<BR>\r\n}<BR>\r\ncatch(IOException ioe){};<BR>\r\nreturn false;<BR>\r\n}<BR>\r\n<BR>\r\n}</P>\r\n\r\n<P><BR>\r\n<B><BR>\r\nHomework 4</B>: Goal: <B>Review and compare use of lists, stacks and arrays.</B></P>\r\n\r\n<P><B>Due Date extended to May 8, 10pm</B></P>\r\n\r\n<P><B>Read</B> chapter 3+ 4.3 Chapter 3 is on lists, stacks, and queues. 4.3 covers binary trees. Also read handout\r\non Collections.</P>\r\n\r\n<P>In this assignment you will implement a Cache (the inteface will be defined) in 5 different ways: namely as\r\nan array, a linked list, an ordered tree, as a linked list from the collections package (in java.util), and as\r\na tree from the collections package. For each implementation give an O-notation analysis. Additional compare the\r\nimplementation by generating 1,000,000 random numbers and putting them into a cache of size 1000. If these numbers\r\nare too small (depends on your computer) you may increase them. Or run the experiment multiple times. Which implementation\r\nof cache is performs best? What can you say about memory use, i.e. how much memory does each technique require\r\n(give more than an O(n) analysis).</P>\r\n\r\n<P>A Cache is a bounded, ordered container for objects. Since it only stores objects, you will actually store Double\r\nobjects. A concrete cache has a single constructor, cache(int bound) where bound is the number of elements to be\r\nstored. Only objects that are comparable are allowed to be entered into a cache. Duplicated objects (in this case\r\ndoubles) are not stored.</P>\r\n\r\n<P>The interface Cache has only one required method.</P>\r\n\r\n<P>void add(Object o) .. may store the comparable object o. Object o is added if either the cache is not full or\r\nthe object o is greater than some object currently stored.</P>\r\n\r\n<P>The constructor is Cache(int bound) where bound is the maximum number of elements to be stored.</P>\r\n\r\n<P>It is suggested that you also define</P>\r\n\r\n<P>Iterator iterator() .. this will allow you to view see what is stored. For this, define remove() to do nothing.\r\nThis is not trivial to define an Iterator() for Trees.</P>\r\n\r\n<P>import java.util.*;<BR>\r\ninterface Cache<BR>\r\n{<BR>\r\nvoid add(Comparable o); // note that wrappers such as Double, Integer and the String class all implement Comparable.<BR>\r\n}</P>\r\n\r\n<P><BR>\r\nYou may defined additional methods, such as isFull() or remove(Object o) or whatever if you find them useful.</P>\r\n\r\n<P>You may use your Cache class in later assignments.</P>\r\n\r\n<P>Note: one homework has been cancelled.</P>\r\n\r\n<P><BR>\r\n<B>Homework 5: </B>Goals: <B>Processing files, using hashtables and a cache. Different data structures for different\r\ngoals.</B></P>\r\n\r\n<P><B>Read </B>chapter 5 or chapter on hashing</P>\r\n\r\n<P>The program finds interesting kmers. A kmer is contiguous string of exactly k letters. Your program will read\r\nin two files and the size of k. Each file consists of characters from the alphabet {a,c,g,t}. The first file we\r\nwill call the family.The second file we will call the background. To create a filereader from the Masterhit directory,\r\nyou should use new File(&quot;\\\\\\\\Masterhit\\\\Instructional\\\\ics-h23\\\\files\\\\nit.txt&quot;); You may think of the\r\nbackground as dna strings from the normal population and the family file as dna from people with some genetic disease.Your\r\nprogram goal is to find unusual (really statistically significant) kmers that occur suprisingly often in the family\r\nwith respect to the background. For the purposes of this homework we define the unusualness of a kmer in the family\r\nas:</P>\r\n\r\n<P>(number of times kmer occurs in family) - ( number of times kmer occurs in background)* (size of family)/(size\r\nof background).</P>\r\n\r\n<P>This is the difference between he actual number of occurrences and the expected number of occurrences.</P>\r\n\r\n<P>There are more appropriate statistical founded definitions, but involve more work and arrive at nearly the same\r\nresults.</P>\r\n\r\n<P>This value defines how to kmers should be compared.</P>\r\n\r\n<P>To count the number of times every kmer in a family occurs use a hashtable which is part of the collections\r\npackage (in java.util.*). For computing the background counts, you should only count the kmers that occur in the\r\nfamily. Again a hashtable is suitable. If you define it properly, you can use the same hashtable as before. For\r\nexample an entry in the hashtable could consist of a pair of integers (family count, background count) and a real-values\r\nscore of the unusualness.</P>\r\n\r\n<P>There are three major steps (b,c,d) to do this task, plus a few minor ones (a,e).</P>\r\n\r\n<P>a) You need to read into memory two files and store them as strings. (This isn't entirely necessary, but otherwise\r\nyou will have to worry about substrings wrapping around the end of one line and the beginning of the next line).\r\nBoth files are in Masterhit\\Instructional\\icsh23\\files. The family file is in &quot;nit.txt&quot;. This file is\r\nin standard &quot;Fasta&quot; format, the form that molecular biologists use to store information about genes or\r\ntheir surrounding regions.To process this file you need &quot;skip&quot; the comment lines. The net effect is that\r\nyou read this file and form a single long string, which should have 3500 characters. The second file is the complete\r\nchromosome I of yeast (which has 16 chromosomes) and is called &quot;chri_230203.txt&quot;. You can guess how many\r\ncharacters it has. Again you need to read the file into a single very long string. You can define the same reader\r\nclass to process either file. (I will provide that little bit of code).</P>\r\n\r\n<P><BR>\r\nb) computing the number of times each kmer occurs in the family ( use a Hashtable or a HashMap). You need to define\r\na class I call entry. Its what goes into the hashtable. The key to the entry is the kmer, a string. Since string\r\nhave good predefined hashcode you don't need to define anything special. The class entry require at least two fields:\r\nint family count and int background count. To process the family file you consider each kmer in turn, and either\r\nenter it into the hashtable or update the family count if it is already their. After you process the family file,\r\nthe family count will hold the number of occurrences in the family and the background count will be zero. The complexity\r\nof all this should be <B>linear</B>. The general rule is that you also avoid processing a file. Twice through a\r\nfile is once too many.</P>\r\n\r\n<P>The entry into the hashtable might have the fields: (string kmer, int familyCount, int backgroundCount, double\r\nscore).</P>\r\n\r\n<P>c) computing the number of times kmers <B>in the family</B> occur in the background (use <B>the same</B> hashtable).\r\nProcessing this file is a a little different. For each kmer in the file, check to see if it occurs in the hashtable.\r\nIf it isn't there you don't care. Otherwise you update the background count.</P>\r\n\r\n<P>d) computing unusualness and sorting the kmers by this value. Luckily hashtables have enumerators and Hashmaps\r\nhave iterators associated with them. Now you go thru the hashtable and enter the best scoring kmers into your cache\r\n(sorted, bounded) from a previous assignment.</P>\r\n\r\n<P>e) finally you print out the top 20 kmers from your cache with kmersize of 6 (minor step) Instead of using your\r\ncache class, you may use TreeSet from the collections package. Actually you should print out the entry associated\r\nwith each of these kmers. So the output would look something like:</P>\r\n\r\n<P>Kmer # of times in family # of times in background Score</P>\r\n\r\n<P>aaaaaa 13 121 .... (not the real answer)</P>\r\n\r\n<P>etc.</P>\r\n\r\n<P>++++++++++++++++++ Code to follow ++++++++++++</P>\r\n\r\n<P><BR>\r\nHere is the code that will concatenate all the upstream regions into a single string. If you write this with s\r\n+= br.readLine() you will have a huge (unacceptable) cost overhead. Instead (and in fact better) you could just\r\nread in and process each upstream region. This code has worked for me, but no guarantees that is errorfree. Complaints/improvements\r\nwelcomed.</P>\r\n\r\n<P><BR>\r\nimport java.io.*;<BR>\r\n<BR>\r\nclass FastaReader<BR>\r\n{<BR>\r\nString data;<BR>\r\n<BR>\r\nFastaReader(String fileName)<BR>\r\n{<BR>\r\ntry<BR>\r\n{<BR>\r\nFile file = new File(fileName);<BR>\r\nBufferedReader bf = new BufferedReader( new FileReader (file)); <BR>\r\nStringBuffer sbuf = new StringBuffer((int)file.length());<BR>\r\n<BR>\r\nString line = bf.readLine();<BR>\r\nwhile (line != null)<BR>\r\n{ <BR>\r\nif (line.charAt(0) != '&gt;')<BR>\r\nsbuf.append(line);<BR>\r\nline = bf.readLine(); <BR>\r\n} <BR>\r\n<BR>\r\ndata = new String(sbuf);<BR>\r\nbf.close();<BR>\r\n}<BR>\r\n<BR>\r\ncatch(IOException e)<BR>\r\n{ <BR>\r\nSystem.out.println(&quot;bad file or something&quot;); <BR>\r\n}<BR>\r\n<BR>\r\n}<BR>\r\n<BR>\r\n<BR>\r\n}</P>\r\n\r\n<P><BR>\r\n.</P>\r\n\r\n<P><BR>\r\n<BR>\r\n<B>Homework 6</B>: Goal: <B>Dynamic programming: the Needleman-Wunsch Algorithm.</B></P>\r\n\r\n<P><B>Read</B> chapter 10.3 Not covered in depth in either text.</P>\r\n\r\n<P>The Needleman-Wunsch algorithm has many applications. The most famous application is helping to discover the\r\nfunction of proteins by finding similar proteins with known function. It could also be applied to spelling correction.\r\nIt is the basis of time-warping algorithms in speech recognition. Your task also includes extending the algorithm\r\nso that it also produces an alignment. You can do this either with a graphical interface or a command line interface\r\nor using terminal io. The input to the program consists of two strings. The output is a) the Needleman-Wunsch similarity\r\nscore and the alignment. The alignment can be illustrated via dashes, as in the following example: If using graphics,\r\nuse a fixed size font.</P>\r\n\r\n<P>Here's an example:</P>\r\n\r\n<P>input string1: heagawghee</P>\r\n\r\n<P>input string2: pawheae</P>\r\n\r\n<P>output: score = -1</P>\r\n\r\n<P>heagawghe-e</P>\r\n\r\n<P>--p-aw-heae</P>\r\n\r\n<P>A dash indicates that the character was skipped. The final score is unique, but their may be several alignments\r\nthat achieve that score.</P>\r\n\r\n<P>The Needleman-Wunsch algorithm will be discussed in class. To compute the alignment I suggest using a separate\r\ntwo dimensional array to record the &quot;backpointers&quot;, although this is not necessary. One can also implement\r\nthe algorithm to use linear space, but that takes more effort and care.</P>\r\n\r\n<P><BR>\r\n<B>Last Assignment due June 5:  Two week assignment. A Competition! </B></P>\r\n\r\n<P><B>Top 5 performers, scored by length of the path produced, will get double grades, i.e grade will also replace\r\nanother homework score, assuming it is a better grade. </B></P>\r\n\r\n<P><BR>\r\n<B>Homework 7:</B> Goal: <B>Use local improvements algorithm on the traveling salesman problem. And Graphics.</B></P>\r\n\r\n<P><B>Read </B>Chapter 10.1 and 10.2 The topic is greedy algorithms</P>\r\n\r\n<P>This assigment requires a graphical display. The inputs to the program are two integers. The first integer is\r\na seed for the random number generator and the second integer is the number of cities. The code to generate the\r\n2-d Points is provided below. Each point will have values that range from 0 to 100. Your program should display\r\nthe initial path together with its length. There are a number of local improvements methods that you might try.\r\nAt the minimum you should implement the &quot;uncrossing&quot; heuristic. You may add other operators or approaches\r\nas you choose. Your code will be evaluated on a random set of  40 cities. </P>\r\n\r\n<P>The best &quot;operator&quot; I've found for improving a tour is to &quot;remove crosses&quot;. Other operators,\r\nthat are also useful , are swapping a pair of cities or moving a single city to a new point in the tour. You need\r\nonly implement the &quot;remove crosses&quot; heuristic. A formula for detecting crosses is fairly simple. Let\r\nd[i][j] represent the distance from city i to city j. For convenience let i' and j' be the next city in the tour\r\n(you need to worry about wrap around). Then a &quot;cross&quot; exists between i and i' and j and j' if:</P>\r\n\r\n<P>d[i][j]+d[i'][j'] &lt; d[i][i'] + d[j][j'].</P>\r\n\r\n<P>If you implement this with doubly linked lists, you can uncross the path with a few pointer moves. If you use\r\nan array to store the cities, then you will need to swap a number of cities. You may use the collection class.</P>\r\n\r\n<P>The performance measure is the length of the tour that your program finds. Your program is constrained to not\r\ntake too long, say not more than 2 cpu minutes for either problem.</P>\r\n\r\n<P>Note the grade on the assignment is determined in the standard way, i.e. the code is correct and clean. However\r\nfor the competition, its no holds bar. The only thing that counts is the length of the tour you find. However you\r\nwould not want to double a poor grade. :)</P>\r\n\r\n<P>Code for Generating an array of Points. Note this is like the Math functions, i.e. it is really just a long\r\nname for a function.  may have This code guarantees that each city have unique coordinates.</P>\r\n\r\n<P>=================== Code ===================</P>\r\n\r\n<P>import java.util.*; // for the class Random<BR>\r\nimport java.awt.*; // for the class Point<BR>\r\n<BR>\r\nclass PointGenerator<BR>\r\n{ <BR>\r\nPoint[] pts;<BR>\r\nPointGenerator(int seed, int size)<BR>\r\n{ <BR>\r\npts = new Point[size];<BR>\r\nint [] xcoord = shuffle(new Random(seed));<BR>\r\nint [] ycoord = shuffle(new Random(seed+1));<BR>\r\nfor (int i = 0; i&lt;size; i++)<BR>\r\npts[i] = new Point(xcoord[i],ycoord[i]);<BR>\r\n}<BR>\r\n<BR>\r\nint[] shuffle(Random r)<BR>\r\n// returns 100 random integers with no repeats from 0..99<BR>\r\n{<BR>\r\nint[] ans = new int[100];<BR>\r\nfor (int i = 0; i&lt;100; i++)<BR>\r\nans[i] = i;<BR>\r\nfor (int i = 99, bound = 100; i&gt;0; i--, bound--)<BR>\r\nswap(ans, i, modulo(r.nextInt(),bound));<BR>\r\nreturn ans;<BR>\r\n}<BR>\r\n<BR>\r\nint modulo(int i, int m) // because % doesn't compute modulo correctly<BR>\r\n{<BR>\r\nint temp = i%m;<BR>\r\nif (temp&lt;0) return temp+m;<BR>\r\nreturn temp;<BR>\r\n}<BR>\r\n<BR>\r\nvoid swap(int[] a, int i, int j)<BR>\r\n{<BR>\r\nint temp = a[i];<BR>\r\na[i]= a[j];<BR>\r\na[j] = temp;<BR>\r\n}<BR>\r\n<BR>\r\nPoint[] getPoints()<BR>\r\n{<BR>\r\nreturn pts;<BR>\r\n}<BR>\r\n}</P>\r\n\r\n<P>================end of code ======================= \r\n<HR ALIGN=\"CENTER\">\r\n<B>Final Exam: June 11</B></P>\r\n\r\n<P><B>Quiz 2 gives a reasonable idea of the form of the final, except it will be longer and cover the entire course\r\nmaterial.</B></P>\r\n\r\n<P><B><BR>\r\n<BR>\r\n<BR>\r\n<BR>\r\n<BR>\r\n</B>\r\n<HR ALIGN=\"CENTER\">\r\n<B><BR>\r\n</B><BR>\r\n<B>Homework Z:</B></P>\r\n\r\n<P><B>Read </B>Chapter 10.1 and 10.2 The topic is greedy algorithms</P>\r\n\r\n<P>This assigment requires a graphical display. The input to the program is the number of cities. Each city will\r\nbe placed randomly at (i,j) where i and j are between 0-100. Display the random path together with its length.\r\nImplement two ways of solving the problem: an exhaustive method and a local improvement method. The user should\r\nbe able to specify which method. Each time a method improves the path, show the new path and the new length. Compare\r\nthe effectiveness of each method on problems of size 10. To do this run each method on 10 problems. Of course the\r\nexhaustive method will find the best solution, but how good is the heuristic approach. Also record the amount of\r\ntime each method makes. Also try both methods on larger problems. When does the exhaustive approach fail - i.e.when\r\nis it unable to solve the problem in a reasonable amount of time (reasonable = 1 minute)? Run the heuristic 10\r\ntimes on the same problem of size 50, but randomize the initial ordering of the cities before each run.</P>\r\n\r\n<P>The best &quot;operator&quot; I've found for improving a tour is to &quot;remove crosses&quot;. Other operators,\r\nthat are also useful , are swapping a pair of cities and moving a single city to a new point in the tour. You need\r\nonly implement the &quot;remove crosses&quot; heuristic. A formula for detecting is fairly simple. Let d[i][j]\r\nrepresent the distance from city i to city j. For convenience let i' and j' be the next city in the tour (you need\r\nto worrry about wrapping around). Then a &quot;cross&quot; exists between i and i' and j and j' if:</P>\r\n\r\n<P>d[i][j]+d[i'][j'] &lt; d[i][i'] + d[j][j'].</P>\r\n\r\n<P>If you implement this with doubly linked lists, you can uncross the path with a few pointer moves. If you use\r\nan array to store the cities, then you will need to swap a number of cities.</P>\r\n\r\n<P><BR>\r\n<BR>\r\n<BR>\r\n<B>Homework X: </B>N-Queens Problem</P>\r\n\r\n<P>This assignment requires a graphics. Optionally you may let the user choose a board size, but you can set it\r\nat some reasonable number between 20 and 100. Display the board with a random placement of N-queens. Implement\r\na greedy local improvement algorithm. For each cycle of the algorithm display the number of queen moves. Provide\r\nappropriate summary information once a solution is reached.</P>\r\n\r\n<P><BR>\r\n<BR>\r\n<B>Homework X: </B>Goals: Graphics, binary search</P>\r\n\r\n<P><B>Read </B>Appropriate chapter</P>\r\n\r\n<P>In this assignment you will implement a gui interface that displays a polynomial and some information about\r\nthe polynomial. The input to the program is a line like: 2*x^3+5*x+3 and a pair of real numbers, say 3.1 and 6.1.\r\nThe constructor for your polynomial class is <B>Polynomial(String s).</B></P>\r\n\r\n<P>You should define a method<B> double evaluate(double d)</B> which evaluates the polynomial on the given real\r\nnumber. There is a clever way to evaluate a polynomial.</P>\r\n\r\n<P>Your program will graph the function over the range provided. Finally your program will display a solution to\r\nthe problem of polynomial(x) = 0. To do this part of the problem you need to assume a solution exists. To solve\r\nit, use binary search. In order to apply binary search you will need to have two values x1 and x2 in the domain\r\nsuch that poly(x1) &gt; 0 and poly(x2) &lt;0, or vice versa. To find such values I suggest a simple linear search\r\nover the domain, i.e. test poly(x[i]) and poly(x[i+1] where the x[i]'s break the domain into 100 equal sized parts.\r\nOnce these values are found, use binary search to yield an approximate solution to poly(x) = 0.</P>\r\n\r\n<P>This following is a <B>possible </B>and simple layout for the GUI interface. The interface contains three text\r\nfields for the inputting the polynomial ( a string) and the left and right bound. It a button that causes the graphing\r\nof the polynomial on someJPanel.. When the polynomial is drawn, a solution to p(x) = 0 (if it has a solution) should\r\nbe indicated graphically and numerically, i.e. in a JTextField.</P>\r\n\r\n<P>As always you should provide time and space analysis as appropraite.\r\n\r\n</BODY>\r\n\r\n</HTML>", "encoding": "ascii"}