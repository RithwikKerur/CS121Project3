{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/BruteForce.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Brute force closest pair algorithm implementation\n\n#include \"BruteForce.h\"\n#include \"Error.h\"\n\nBruteForceCP::~BruteForceCP()\n{\n\tdelete points;\n\tdelete where_are_the_points;\n}\n\nBruteForceCP::BruteForceCP(long np, long max_points, Distance & d)\n\t: ClosestPairs(np, max_points, d), dist(d)\n{\n\tpoints = new point[max_points];\n\twhere_are_the_points = new point[max_points];\n\tif (points == 0 || where_are_the_points == 0)\n\t\terror(\"BruteForceCP: unable to initialize arrays, out of memory\");\n\n\tnpoints = np;\n\tgInsertions += np;\n\tfor (long i = 0; i < np; i++) points[i] = where_are_the_points[i] = i;\n}\n\n// add point to end of points[] and store index in where_are...\n//\nvoid BruteForceCP::operator += (point p)\n{\n\tgInsertions++;\n\tpoints[where_are_the_points[p] = npoints++] = p;\n}\n\n// move end of points[] to deleted location and update where_are...\n//\nvoid BruteForceCP::operator -= (point p)\n{\n\tgDeletions++;\n\tnpoints--;\n\tunsigned long q = where_are_the_points[p];\n\twhere_are_the_points[points[q] = points[npoints]] = q;\n}\n\n// nested loop to find all pairs and return closest one\n//\ndouble BruteForceCP::operator() (point & a, point & b)\n{\n\tgPairs++;\n\tif (npoints < 2) error(\"BruteForceCP: fewer than two points in set\");\n\tdouble min_dist = dist(points[0],points[1]);\n\ta = points[0];\n\tb = points[1];\n\tfor (unsigned long i = 2; i < npoints; i++)\n\t\tfor (unsigned long j = 0; j < i; j++) {\n\t\t\tdouble d = dist(points[i], points[j]);\n\t\t\tif (d < min_dist) {\n\t\t\t\tmin_dist = d;\n\t\t\t\ta = points[i];\n\t\t\t\tb = points[j];\n\t\t\t}\n\t\t}\n\treturn min_dist;\n}\n", "encoding": "ascii"}