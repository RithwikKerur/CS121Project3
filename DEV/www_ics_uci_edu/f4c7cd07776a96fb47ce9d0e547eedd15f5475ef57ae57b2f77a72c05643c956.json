{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/usingclasses/usingclasses.txt", "content": "\t\t\t\tUsing Classes\r\n\r\n\r\nThroughout out study and use of Python we have discussed and used objects. In\r\nthis lecture we will learn more about reading and using classes (which are\r\ntemplates from which objects are created), and start to learn about writing\r\nclasses; but barely, because writing classes is the main topic for the following\r\ntwo lectures. As we understand classes better, we will understand all aspects\r\nof Python better -those parts we have already learned and those parts we have\r\nyet to learn.\r\n\r\nWhen we started learning about Python, we started with simple objects storing\r\nint, float, str, and bool values. What do the names int, float, str, and bool\r\nrefer to? They are names that refer to objects that represent the classes from\r\nwhich object values are constructed. When we write objects from these simple\r\nclasses, we use special literals to describe their values. Note that all of\r\nthese objects are immutable: we cannot change their state (but we can rebind\r\nnames to different values: e.g., x += 1 which means x = x+1).\r\n\r\nLater we discussed, list, tuple, dictionary, set, and frozenset objects: these\r\nnames are also bound to objects representing classes (some mutable, some\r\nimmutable). When we write objects from these classes, we typically use special\r\nliterals to describe their values (like lists in [] brackets), but we can also\r\nuse the name of the class: e.g., x = list()  or  x = list(aset). We call this\r\nform using a constructor to construct the object bound to the name x. In all\r\nthe classes that we write ourselves, we will use this constructor form: the\r\nname bound to the class object to create an object of the class.\r\n\r\nClasses serve as templates for constructing objects. Every object that we\r\nconstruct is initialized by a special method named __init__ in some class. Much\r\nmore on this special method in the following two lectures.\r\n\r\nLet's review the difference between functions and methods. We can pass objects\r\nas arguments to functions: we have written many functions whose arguments are\r\nobjects). But, we can also call methods on objects using a different syntax.\r\nFor example if x is a list, we can call its append method as x.append(5) to\r\nappend the value 5 to the list. We first saw methods used when processing\r\nstrings: if s is a str, we can write method calls on s as s.upper() or\r\ns.find('#') or s.rstrip().\r\n\r\nThe fundamental equation of object-oriented programming tells us that Python\r\ntranslates the method call o.m(p) to the function call type(o).m(o,p). So,\r\nPython translates the method call s.find('#') into str.find(s,'#'): it usess\r\nthe str class object and calls its find function, passing it the arguments s\r\nand '#'; likewise, Python translates x.append(5) into list.append(x,5): it\r\nfinds the list class object and calls its find function, passing it the\r\narguments x and 5.\r\n\r\nSo, we use this special syntax to call methods (defined in classes) on objects\r\n(constructed from classes) and also pass along any other needed arguments. This\r\nsyntax is the defining feature of using classes in object-oriented programming.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe Dice class\r\n\r\nWith this as prologue, let's see the entire class definition for Dice (all\r\nclasses we define will use upper-case letters; multiple words are separated by\r\nunderscores). The Dice class models rolling any number of dice, each having\r\nany number of sides. We will not tackle understanding the code inside this class\r\nin this lecture, but instead just look at its the method headers. In the next\r\ntwo lectures we will study its method bodies, which contain familiar Python\r\nstatements.\r\n\r\nOf course, dice are rolled randomly, for which we import the random module and\r\nuse its randint and seed functions.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nimport random\r\n\r\n\r\nclass Dice:\r\n    def __init__(self,max_pips):\r\n        assert len(max_pips) >= 1, 'Dice.__init__: max_pips is empty'\r\n        for i in range(0,len(max_pips)):\r\n            p = max_pips[i]\r\n            assert p >= 1, 'Dice.__init__: max_pips['+str(i)+']='+str(p)+': must be an int >= 1'\r\n        self._max_pips   = max_pips[:]       #Copy to avoid aliasing\r\n        self._pips      = [0]*len(max_pips)\r\n        self._roll_count = 0\r\n\r\n\r\n    def roll(self):\r\n        self._roll_count += 1\r\n        self._pips = [ random.randint(1,max_pips) for max_pips in self._max_pips ]\r\n        return self\r\n\r\n\r\n    def number_of_dice(self):\r\n        return len(self._pips)\r\n\r\n\r\n    def all_pip_maximums(self):\r\n        return self._max_pips[:]\r\n\r\n\r\n    def rolls(self):\r\n        return self._roll_count\r\n\r\n\r\n    def pips_on(self,i):\r\n        assert self._roll_count > 0, 'Dice.pips_on: dice not rolled' \r\n        assert 0<= i < len(self._pips), \\\r\n          'Dice.pips: die index i('+str(i)+') must be >= 0 and <'+str(len(self._pips))\r\n        return self._pips[i]\r\n\r\n\r\n    def all_pips(self):\r\n        return self._pips[:]\r\n\r\n\r\n    def pip_sum(self):\r\n        assert self._roll_count > 0, 'Dice.pip_sum: dice not rolled' \r\n        return sum(self._pips)\r\n\r\n        \r\n    def pips_same(self):\r\n        return all( [self._pips[0] == p for p in self._pips] )\r\n\r\n    \r\n    def __str__(self):\r\n        return 'Dice('+str(self._pips)+')'\r\n\r\n    \r\n    def __repr__(self):\r\n        return 'Dice('+str(self._max_pips)+')'\r\n\r\n    \r\n    def standard_rolls_for_debugging(self):\r\n        random.seed(12161949)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nAgain, in this lecture we will examine only the headers of the methods, which\r\nare highlighted here by removing their method bodies.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nclass Dice:\r\n    def __init__(self,max_pips):\r\n    def roll(self):\r\n    def number_of_dice(self):\r\n    def all_pip_maximums(self):\r\n    def rolls(self):\r\n    def pips_on(self,i):\r\n    def all_pips(self):\r\n    def pip_sum(self):\r\n    def pips_same(self):\r\n    def __str__(self):\r\n    def standard_rolls_for_debugging(self):\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe Dice class is the only definition in the dice.py module, which already is\r\nin the courselib folder. We can use Dice in any of our modules by just\r\nimporting dice.py (as was done in the craps.py module used in the debugger\r\nhandout). We can also impor this class in the interpreter to test its methods\r\nindividually.\r\n\r\nThe actual Dice class that I wrote includes comments that describe the class\r\nand each of its methods. We can see these headers and read their comments in\r\nthe html documents produced by a program called pydoc. To view this document,\r\ngo to the course home page, then click on the \"Course Library Reference\" link\r\nin the index; then click on the Dice link. Do this now, while you are reading\r\nthis lecture (I will, when I discuss it in class).\r\n\r\nThe methods in this document appear in alphabetical order (although the special\r\n__init__ method always appears first). Reading from the top down, in blue is\r\nthe module in which this class is defined: dice.py. In purple are the modules\r\nthat this one imports and uses: just random. In red is the class hierarchy for\r\nthe Dice class (all classes inherit from builtins.object): which is just Dice;\r\nnested in red is the header of the class definition and a brief description of\r\nthe class. Below that are the method headers (minus the keyword def) and\r\ndocumentation for each method that is not private (more on private in the next\r\ntwo lectures).\r\n\r\nThe main idea behind objects constructed from the Dice class is that they model\r\nsome number of dice, where each can have a different number of sides. We can\r\nexecute a roll command on these dice (mutating the pips showing on each side) or\r\nquery the rolled dice in various ways. Dice defines one command/mutator and\r\nmany query/accessor methods.\r\n\r\nEach method has a parameter named self, which is the Dice object being operated\r\non. For example, if we defined\r\n\r\n  d = Dice([6,6])\r\n\r\nd would refer to a Dice object representing two dice, each with six sides. The\r\nlist's length is the number of dice and the values in the list specify how many\r\nsides each die has (the dice are indexed like lists: 0 and 1 in this case. We\r\ncan also call methods like d.roll() and d.pip_sum()... Here are examples of\r\ncalling all the Dice methods, summarizing in English what each method does.\r\n\r\nA  Dice object stores this list of sides, a list of the number of pips showing\r\non the dice (once it has been rolled) and a count of the number of times the\r\ntime have been rolled (something that real dice cannot do). These method examine\r\nor update this date.\r\n\r\n  d.roll()     \t       increasing the roll count and generate new random pips\r\n                       (returns d, so can cascade calls: d.roll().pip_sum())\r\n  d.number_of_dice()   return the number of dice\r\n  d.all_pip_maximums() return a list showing the maximum allowed pips\r\n  d.rolls()\t       return the number of times the dice have been rolled\r\n  d.pips_on(i)\t       return the number of pips on the ith (starting at 0) die\r\n  d.all_pips()\t       return a list of all the pips on all the dice\r\n  d.pip_sum()\t       return the sum of all the pips onall the dice\r\n  d.pips_same()\t       return whether or not all dice show the same pips\r\n  d.__str__()\t       return a string representation of the Dice object\r\n                       (same as calling the str functions: str(d))\r\n  d.standard_rolls_for_debugging() ensures the same pips are rolled each time\r\n\r\nLet's see how to perform various dice operations on a parameter to a function.\r\nThe experiment function below rolls the dice (notice the lower-case d in the\r\nparameter name) the specified number of times, and records how often each pip\r\nsum is thrown. It creates an array that can be indexed between 0 and the\r\nmaximum pip sum, then loops the required number of times, incrementing the\r\nindex of the pip sum thrown, and finally returning the array.\r\n\r\ndef experiment(dice : Dice,times : int) -> NoneType :\r\n    histogram = (sum(dice.all_pip_maximums())+1)*[0]\r\n    for i in range(times):\r\n        histogram[dice.roll().pip_sum()] += 1\r\n    return histogram\r\n\r\nFor the script below (using the print_histogram function)\r\n\r\nd = Dice([6,6,6])   \r\nprint_histogram('1 million dice rolls', experiment(d,1000000)) \r\n\r\nThe result it prints is as follows. Note that with 3 6-sided dice, the lowest\r\npossible pip sum is 3 and the highest 18. We would expect 3 and 18 to be thrown\r\nwith probability 1/6**3 or 1/216 or about .46 percent (which is what the bins\r\n3 and 18 show, to one significant digit).\r\n\r\n1 million dice rolls\r\n   3[  0.5%]|*\r\n   4[  1.4%]|*****\r\n   5[  2.8%]|***********\r\n   6[  4.6%]|******************\r\n   7[  6.9%]|***************************\r\n   8[  9.6%]|**************************************\r\n   9[ 11.6%]|**********************************************\r\n  10[ 12.5%]|*************************************************\r\n  11[ 12.5%]|**************************************************\r\n  12[ 11.6%]|**********************************************\r\n  13[  9.8%]|***************************************\r\n  14[  6.9%]|***************************\r\n  15[  4.6%]|******************\r\n  16[  2.8%]|***********\r\n  17[  1.4%]|*****\r\n  18[  0.5%]|*\r\n\r\nSee the craps.py script for another use of the Dice class.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nThe Stopwatch Class:\r\n\r\nThe Stopwatch class is the only definition in the topwatch.py module, which is\r\nalso already in the courselib folder. We can use Stopwatch in any of our\r\nmodules by just importing stopwatch.py. This class models a stopwatch that is\r\neither stopped or running (forward -adding time- or backwards -subtracting\r\ntime). We can read the time (in seconds) on the stopwatch (while it is stopped\r\nor running), and reset the stopwatch.\r\n\r\nYou can examine the documentation for this class at the same location as the\r\nDice class, and read it the same way. Here are all the methods that we should\r\ncall (there are a few more, but those are private helper methods, which we will\r\ndiscuss in the next two lectures). This class is the opposite of Dice in that\r\nit defines many more commands/mutators (the first four) than queries/accessors\r\n(the second to last one; the last one is called only for debugging purposes).\r\n\r\nclass Stopwatch:\r\n    def reset(self):            reset the stopwatch: stopped, 0 accumulated time\r\n    def start(self):            run the stopwatch forward\r\n    def start_backwards(self):  run the stopwatch backward\r\n    def stop(self):             stop the stopwatch\r\n    def read(self):             return the time elapsed (a float in seconds)\r\n    def status(self):\t\treturn a tuple with the state of the stopwatch\r\n\r\nWe can easily use this class to determine how long it takes to execute some\r\ncode, including how long it takes the user to respond to some prompt.\r\n\r\ntimer = Stopwatch()  # with no arguments, the stopwatch is stopped at 0 seconds\r\ntimer.start()\r\ncode-to-time\r\ntimer.stop()\r\nprint(timer.read(),'seconds elapsed time')\r\n\r\nIn fact, we can shorten this code to the following, although the code above can\r\nbe more easily changed to do slightly different tasks. When we construct the\r\nstopwatch we can construct it to be running, and we can read a running\r\nstopwatch (we don't have to stop it to read it).\r\n\r\ntimer = Stopwatch(running_now=True)        # running from 0 seconds\r\ncode-to-time\r\nprint(timer.read(),'seconds elapsed time') # can read a running stopwatch\r\n\r\nThe code below times how long it takes to do a loop calling function f, and then\r\nsubtracts the amount of time it takes to run the same loop without calling f.\r\n\r\ntimer1 = Stopwatch()  # with no arguments, the stopwatch is stopped at 0 seconds\r\ntimer1.start()\r\nfor i in range(1000000):\r\n  f(i)\r\ntimer1.stop()\r\n\r\ntimer2 = Stopwatch()\r\ntimer2.start()\r\nfor i in range(1000000):\r\n  pass\r\ntimer2.stop()\r\nprint(timer2.read()-timer1.read(),'seconds elapsed net time')\r\n\r\nWe can use a single stopwatch to do both jobs, running it backwards after the\r\nfirst loop.\r\n\r\ntimer = Stopwatch()  # with no arguments, the stopwatch is stopped at 0 seconds\r\ntimer.start()\r\nfor i in range(1000000):\r\n  f(i)\r\ntimer.start_backwards()\r\nfor i in range(1000000):\r\n  pass\r\ntimer.stop()\r\nprint(timer.read(),'seconds elapsed net time')\r\n\r\n------------------------------------------------------------------------------\r\n\r\nOther classes in the courselib\r\n\r\nExamine the documentation for all the modules in courselib: goody, predicate,\r\nand prompt are modules that define functions. All the other modules define a\r\nsingle class: dice and stopwatch model data in the physical world; modular\r\nmodels a special kind of number; equivalence, graph,, queue, and stack model\r\ndata types (e.g., they each store data, like lists/tuple/dict/set/frozenset do).\r\n\r\nAll programming languages come with large libraries. For a programmer to become\r\nproficient in a language he/she must learn the language itself but also have a\r\ngood familiarity with the language's library (and be able to create library\r\nmodules of his/her own).\r\n\r\nPython Module\tDescription\r\ndice   \t\tA class modeling an ensemble of dice\r\nequivalence\tA class implementing the equivalence class data type\r\ngoody\t\tA module defining miscellaneous useful functions (goodies)\r\ngraph\t\tA class implementing the graph data type (using nodes and edges)\r\nmodular\t\tA class implementing the modular number data type\r\npredicate\tA module defining predicate functions: i.e., def p(x:int)->bool\r\nprompt\t\tA module defining functions that prompt the user for values\r\nqueue\t\tA class implementing the queue data type\r\nstack\t\tA class implementing the stack data type\r\nstopwatch\tA class modeling a stopwatch (useful for timing code)\r\n\r\n------------------------------------------------------------------------------\r\n\r\nPreview of the netxt 2 lectures on classes\r\n\r\n(2) Implementing classes: __init__, self, and methods\r\n\r\n(3) Advance classes: privacy conventions; translating operators to method calls\r\n", "encoding": "ascii"}