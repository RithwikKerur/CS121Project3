{"url": "https://www.ics.uci.edu/~pattis/ICS-21/lectures/inheritancei/lecture.html", "content": "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\r\n<html>\r\n\r\n<head>\r\n  <title>Inheritance in Class Hierarchies</title>\r\n</head>\r\n\r\n<body BGCOLOR=\"white\">\r\n\r\n<center>\r\n<h1>Inheritance in Class Hierarchies</h1>\r\n<p>\r\n<h2>Introduction to Computer Science I-III<br>\r\nICS-21/-22/-23<br>\r\n</h2>\r\n<p>\r\n</center>\r\n\r\n\r\n<!-- Introduction -->\r\n\r\n<a name=\"Introduction\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Introduction</b></td>\r\n<td width =\"80%\">\r\n  In this lecture we will begin discussing direct relationships among classes\r\n    (including generalizing the relationship the <b>Object</b> class has to\r\n    all other classes).\r\n  We will discus subclasses (also known as extension classes), superclasses\r\n   (aka base classes),  and the concept of  inheritance among classes.\r\n  Pragmatically, we will focus on inheriting the state and methods defined in\r\n    classes, and overriding methods.\r\n  <p>\r\n  A brief review.\r\n  Originally, we learned that every class was independent of every other class.\r\n  The type of a variable, and the reference to the object we stored in it,\r\n    were always the names of the same class\r\n   (e.g., <b>Timer t = new Timer();</b>). \r\n  <p>\r\n  Then we learned that the class <b>Object</b> acted as the type of a generic\r\n     class.\r\n  If a variable were declared to be of the type <b>Object</b>, then we could\r\n    store into it a reference to an object constructed from any class (but\r\n    still not a primitive value; e.g., not <b>int</b>, but we could wrap that\r\n    value in the <b>Integer</b> wrapper class).\r\n  Now, for the first time, the type of the left side of a declaration did not\r\n    have to be the same as the class constructed: we could write\r\n    <b>Object x = new String(\"abc\");</b> or <b>Object x = new Integer(123);</b>\r\n    or <b>Object x = new Timer();</b>. \r\n  On that variable, we could call only those methods declared in the\r\n    <b>Object</b> class.\r\n  If we wanted to call methods from the class of the object to which it really\r\n    refered, or store a reference to an <b>Object</b> into some other type\r\n    of variable, we needed to cast the reference (and/or check it with the\r\n    <b>instanceof</b> operator):  <b>((Integer)s.pop()).intValue()</b> or\r\n    <b>Integer i = (Integer)s.pop();</b> \r\n  <p>\r\n  Recently we learned that sometimes classes were indirectly related: because\r\n    they implemented the same interface.\r\n  In these cases, if we used the interface name as a type for a variable, then\r\n    we could store into it a reference to an object constructed from any class\r\n    that implements that interface (e.g.,\r\n    <b>DecisionInt inRange = new IsBetween(0,5);</b>); likewise, on that\r\n    variable, we could call only those methods declared in the interface,\r\n    which its class is guaranteed to specify..\r\n  <p>\r\n  In this lecture we will learn about another, and more complicated and \r\n    useful, way for classes to be related: via subclassing/extension (i.e.,\r\n    inheritance).\r\n  Again we will study a generalization about how the type of a variable\r\n    restricts what references to objects we can store in it and what methods we\r\n    can call on the variable; and how the class of the object it refers\r\n    to determines the actual behavior of these methods when they are called.\r\n  <p>\r\n  The <b>Object</b> class, and all the properties that we know about it, is\r\n    just a special case of learning about subclassing/extension (inheritance).\r\n  The concepts of reference casting and the <b>instanceof</b> operator are\r\n    likewise rediscussed in the more general framework of class inheritance.\r\n  Although the programming implications of inheritance are many and varied, we\r\n    will focus on some of the technical details first.\r\n  <p>\r\n  Whenever we discuss new facets of classes, we must discuss how they are\r\n    related to  constructors, fields, and methods.\r\n  Specifically, we will learn how to picture objects constructed from\r\n    subclasses, which extend the fields  provided by their superclasses;\r\n    we will learn some new constructor syntax for this purpose as well.\r\n  We will discuss how methods in a superclass are inherited and overridden in\r\n    subclasses, determining the behavior of any object constructed from the\r\n    subclass.\r\n  <p>\r\n  To make this information concrete, we will use a few very simple classes\r\n    collected into a small hierarchy: <b>IntCounter</b>, <b>ModularCounter</b>,\r\n    and <b>BoundedCounter</b>.\r\n  Each of these classes implements the <b>Counter</b> interface.\r\n  Both <b>ModularCounter</b> and <b>BoundedCounter</b> extend\r\n    <b>IntCounter</b> by adding fields and inheriting, overriding, and\r\n    defining new methods.\r\n  We will close this lecture by discussing the <b>SkipCounter</b> class,\r\n    which acts as a decorator for the <b>Counter</b> interface and contrast\r\n    its use with making yet more subclasses.\r\n  <p>\r\n  You can download the\r\n    <a href=\"../../programs/counters.zip\">\r\n    Counters via Inheritance Demonstration</a> application, whose code is\r\n    described in, and used to illustrate, all the material in this lecture.\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Subclassing/Extension -->\r\n\r\n<a name=\"Extends\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>extends and Subclassing </b></td>\r\n<td width =\"80%\">\r\n  Often a new class is a slight variation (extension) of an old class; it adds\r\n    some state (fields) and adds/modifies some behavior (methods).\r\n  What makes a programming language object-oriented is that is provides a\r\n    mechansim to define a new class based on an old class, requiring us to\r\n    define just the new fields and changed/new methods.\r\n  In Java, we use the <b>extends</b> keyword to create a <b>subclass</b> based\r\n    on (extending) a <b>superclass</b>.\r\n  <p>\r\n  For example, the first line that defines the <b>ModularCounter</b> class is\r\n  <pre><b>  public class ModularCounter extends IntCounter {\r\n  ...field(s), constructor(s) and method(s)\r\n  }</b></pre>\r\n  In Java, and most OOP languages, we can define a class to extend just\r\n    <b>one</b> other class.\r\n  Often we show this relationship as follows (always with the superclass on\r\n    top of the subclass)\r\n</tbody>\r\n</table>\r\n   <img src=\"images/supersub.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  We can build a complicated application program from a library of many\r\n    classes, some of which are  related by superclass-subclass relationships,\r\n    forming an inheritance hierarchy.\r\n  We draw such hierarchies as follows, with each subclass beneath its\r\n    superclass (with an arrow pointing to it).\r\n  While a superclass may have many direct subclasses, a subclass has exactly\r\n     one direct superclass.\r\n</tbody>\r\n</table>\r\n   <img src=\"images/counterhierarchy.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  So, in this example, the <b>ModularCounter</b> and <b>BoundedCounter</b>\r\n     classes extend the <b>IntCounter</b> class.\r\n  Each subclass is in some sense more powerful than the superclass that it\r\n    extends: it adds more fields and methods.\r\n  Unfortunately the terms <b>subclass</b> and <b>superclass</b> seem to have\r\n    exactly the opposite informal meanings.\r\n  The word <i>super</i> implies something more powerful, but in fact it is\r\n    the <i>subclass</i> that is more powerful.\r\n  We have to be careful how we use these terms.\r\n  <p>\r\n  Many classes are declared without extending any other class.\r\n  By default, the absence of <b>extends</b> implies that these classes all\r\n    extend the class  <b>Object</b>.\r\n  This class is the most super of superclasses (it extends no other class).\r\n  It is at the root of the inheritance hierarchy that is created by all\r\n    inheritance relationships.\r\n  For example, the following inheritance hierarchy includes just a very few\r\n    of classes that we have discussed this quarter.\r\n</tbody>\r\n</table>\r\n   <img src=\"images/bighierarchy.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Most classes extend no other class, so by definition they are subclasses of\r\n    the <b>Object</b> class.\r\n  We will soon study how to read the Javadoc of classes in a hierarchy,\r\n    studying the fields and methods that they inherit.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Superclass -->\r\n\r\n<a name=\"IntCounter\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The IntCounter Superclass</b></td>\r\n<td width =\"80%\">\r\nThe <b>IntCounter</b> class appears below.\r\nIt is a very simple class (compared to what we have been reading and writing),\r\n  but it has all the elements needed to discuss general inheritance in class\r\n  hierarchies.\r\nCertainly this class is more pedagogically useful than practical.\r\n<b><pre>  public class IntCounter {\r\n\r\n    public IntCounter ()\r\n    {}\r\n  \r\n    public IntCounter (int initialValue)\r\n    {value = initialValue;}\r\n  \r\n    public void reset ()\r\n    {value = 0;}\r\n\r\n    public void increment ()\r\n    {value++;}\r\n  \r\n    public int getValue()\r\n    {return value;}\r\n\r\n    public String toString()\r\n    {return \"\"+value;}\r\n\r\n    private int value = 0;\r\n}</pre></b>\r\nThe class declares the instance variable <b>value</b> and automatically\r\n  initializes it to <b>0</b>.\r\nOne constructor allows us to keep this value; the other stores any initial\r\n   value into <b>value</b>.\r\nNotice that if the first constructor were not written, Java WOULD NOT\r\n  supply it because there is another constructor; Java automatically\r\n  supplies a do-nothing constructor only if a class defines no other\r\n  constructors.\r\nThe mutators/commands reset/increment the state stored in <b>value</b>.\r\nThe accessor/query <b>getValue</b> returns this value, and <b>toString</b>\r\n  returns this value as a <b>String</b>, easily accomplished via catenation\r\n  to the empty string.\r\n<p>\r\nWe can use this class by itself. We can declare\r\n   <b>IntCounter i = new IntCounter();</b>\r\n  and then call <b>i.increment();</b> and then call\r\n  <b>System.out.println(\"i = \" + i);</b> (remember writing <b>i</b> here is\r\n  the same as writing <b>i.toString()</b>) which would print simply\r\n  as <b>i = 1</b>.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Subclass -->\r\n\r\n<a name=\"ModularCounter\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The ModularCounter Subclass</b></td>\r\n<td width =\"80%\">\r\nThe <b>ModularCounter</b> class appears below.\r\nWe will first explain Java's inheritance mechanism by using this class,\r\n  which extend (is a subclass of) <b>IntCounter</b>.\r\nBriefly examine it now, but don't worry about details you don't yet\r\n  understand; we will discuss each of its components in the\r\n  next few sections.\r\n<b><pre>  public class ModularCounter extends IntCounter {\r\n    public ModularCounter (int modulus)\r\n    {this(0,modulus);}\r\n\r\n    public ModularCounter (int value, int modulus)\r\n      throws IllegalArgumentException\r\n    {\r\n      super(value);\r\n      if (modulus < 1)\r\n        throw new IllegalArgumentException(\"ModularCounter: modulus bad\");\r\n      if (value < 0 || value >= modulus)\r\n        throw new IllegalArgumentException(\"ModularCounter: value bad\");\r\n\r\n      this.modulus = modulus;\r\n    }\r\n\r\n    public int getModulus()\r\n    {return modulus;}\r\n\r\n    public void increment()\r\n    {\r\n      if (getValue() == modulus-1)\r\n        reset();\r\n      else\r\n        super.increment();\r\n    }\r\n\r\n    public String toString()\r\n    {return super.toString()+\"(\"+modulus+\")\";}\r\n\r\n    private final int modulus;\r\n}</pre></b>\r\nWe explain the relationship bewteen <b>ModularCounter</b> and\r\n  <b>IntCounter</b> by examining how inheritance affects the three components\r\n  of any class: fields, constructors, and methods.\r\nIn the process, we will explain the uses of <b>super</b> that appear above.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Fields -->\r\n\r\n<a name=\"Fields\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Fields in Subclasses</b></td>\r\n<td width =\"80%\">\r\n  An object constructed from a subclass contains all the fields that the\r\n     subclass defines, and all the fields that are contained in its superclass\r\n    (and the superclass of the superclass, etc. all the way to the class\r\n    <b>Object</b>, at the root of the inheritance hierarchy).\r\n  The <b>Object</b> class defines no instance variables, so we will not\r\n    graphically represent it.\r\n  Note how the <b>public</b> and <b>private</b> access modifiers work with\r\n    subclassing: although a subclass may contain fields defined in its\r\n    superclass, if those fields are defined to be <b>private</b> in the\r\n    superclass, then the subclass cannot refer to them: if it wishes to\r\n    access or  change them, it must use the standard accessor and mutator\r\n    methods defined in the superclass.\r\n  All <b>public</b> fields -typically NONE of the instance variables- defined\r\n    in a superclass can be referred to directly in a subclass.\r\n  <p>\r\n  When we draw an object constructed from a subclass, we will show it\r\n    containing all the fields of its superclass inside.\r\n  We will label the boundary of the superclass in which each instance\r\n    variable appears.\r\n  So, for example, the <b>IntCounter</b> class defines only a <b>value</b>\r\n    (of type <b>int</b>) instance variable; the <b>ModularCounter</b> class\r\n    that extends it defines a <b>modulus</b> (of type <b>int</b>) instance\r\n    variable.\r\n  Because <b>ModularCounter</b> extends <b>IntCounter</b> and inherits all its\r\n    fields, we will draw a <b>ModularCounter</b> object as follows.\r\n</tbody>\r\n</table>\r\n   <img src=\"images/object.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  Again, we choose NOT to represent the <b>Object</b> class in these pictures,\r\n    even though it is always the top class in an inheritance hierarchy,\r\n    because that class defines no state.\r\n  As we continue to study the mechanics of inheritance, pictures like this one\r\n    will make all the material easier to understand.\r\n <p>\r\n  Finally, we will now introduce another access modifier named\r\n   <b>protected</b> (a keyword) that allows access at a level inbetween\r\n   <b>public</b> and <b>private</b> (but different than package-friendly).\r\n  Any class member declared <b>protected</b> can be referred to by methods in\r\n    the class itself, can be referred to by methods in any subclass (or\r\n    subclass of a subclass, etc.), and can be referred to by any methods in a\r\n    class that is defined in the same package (like package-friendly).\r\n  This last rule for the <b>protected</b> access modifier is a bit strange,\r\n    and students are advised to not use <b>protected</b>, but they should\r\n    know what it means if they run across code that uses it.\r\n  In summary access modifiers get more restrictive in the following sequence\r\n    <b>public</b>, <b>protected</b>, package-friendly, and <b>private</b>.\r\n  We can say that <b>protected</b> members are package-friendly, plus being\r\n    able to be accessed in subclasses (whether or not they are in the same\r\n    package).\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Constructors -->\r\n\r\n<a name=\"Constructors\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Constructors in Subclasses</b></td>\r\n<td width =\"80%\">\r\n  As we have seen, an object constructed from a subclass contains all the\r\n    fields present in its superclass as well.\r\n  So, when we diagram/construct an object from a subclass, we must first\r\n    diagram/construct its superclass fields, encapsulated inside an oval for\r\n    the superclass; then, we take all the new fields that the subclass defines\r\n    and place them outside the oval, and encapsulate all fields inside the\r\n    subclass oval.\r\n  <p>\r\n  The first line of code in a subclass constructor must be a call to\r\n    <b>super</b>, a keyword which when it appears in a constructor means to\r\n    call the constructor of the superclass (whatever class this subclass\r\n    extends).\r\n  Most student would prefer to use the name of the superclass here, but this\r\n    is not the Java way.\r\n  The only exception is if the first line uses <b>this</b>, in which case\r\n    it cannot have a call to <b>super</b>.\r\n  Of course, the arguments to <b>super</b> must match the parameters of one of\r\n    the constructors of the superclass (which may be overloaded).\r\n  For example, there are two constructors defined for the superclass\r\n     <b>ModularCounter</b>; they are\r\n  <pre><b>  public ModularCounter (int modulus)\r\n  {this(0,modulus);}\r\n\r\n  public ModularCounter (int value, int modulus)\r\n    throws IllegalArgumentException\r\n  {\r\n    super(value);\r\n    if (modulus < 1)\r\n      throw new IllegalArgumentException(\"ModularCounter: modulus bad\");\r\n    if (value < 0 || value >= modulus)\r\n      throw new IllegalArgumentException(\"ModularCounter: value bad\");\r\n\r\n    this.modulus = modulus;\r\n  }</b></pre>\r\n  As you can see the first constructor just refers to the second, more general\r\n    one using the <b>this</b> mechanism, which we have studied before.\r\n  The first line of code in the second constructor is, and must be, a\r\n    call to the constructor of its superclass (always denoted by the keyword\r\n    <b>super</b>).\r\n  The purpose of calling <b>super</b> is to appropriately initialize\r\n    <b>private</b> instance variables in the superclass.\r\n  In fact, if <b>super</b> is not explicitly called, it is implicitly called\r\n    as <b>super();</b> so if you leave out a call to <b>super</b> (accidentally\r\n    or on purpose) in your constructor, Java will still compile and run  your\r\n    code IF THE SUPERCLASS HAS A PARAMETERLESS CONSTRUCTOR.\r\n  <p>\r\n  The second constructor for the <b>ModularCounter</b> class calls the\r\n    right <b>super</b> constructor: reinitializing <b>value</b> in\r\n    <b>IntCounter</b> to the value of the parameter <b>value</b> in the\r\n    <b>ModularCounter</b> constructor.\r\n  Notice that by the required placement of <b>super</b> -first in the method-\r\n    this must be done before the sanity check on <b>value</b> can \r\n    be performed.\r\n  <p>\r\n  Then, it will check these values: it seems odd to do this after calling\r\n    <b>super</b>, but this is the required order by Java.\r\n  Finally, assuming that the parameters are OK, it stores the second parameter\r\n    into the <b>modulus</b> instance variable defined in the\r\n    <b>ModularCounter</b> subclass.\r\n  So writing <b>new ModularCounter(3)</b> or <b>new ModularCounter(0,3)</b>\r\n    leads to the construction of the object shown in the picture above.\r\n  <p>\r\n  Here are the rules for construction summarized.\r\n  <ol>\r\n    <li>Allocate space for all the fields specified in the subclass and all its\r\n          superclasses, and initialize these fields according to their\r\n          declarations.\r\n    <li>Call the superclass constructor, which reinitializes some of the fields\r\n          in the superclass; note that this supercalss constructor will\r\n          first call the constructor for its own superclass, unless it is the\r\n          <b>Object</b> class, which has no superclass.\r\n    <li>Execute the rest of the constructor code, which may reinitialize the\r\n          fields declared in this class.\r\n  </ol>\r\n  So, instance variables are declared/initialized/reinitialized from the\r\n    top of the hierarchy downwards.\r\n  Think of Java starting at the super-most class (<b>Object</b>), doing\r\n    initialization (and maybe reinitialization) downward to the subclass\r\n    actually being constructed.\r\n  <p>\r\n  So, technically, each of the constructors for the classes that we have\r\n    written prior to this lecture (which extend only <b>Object</b>) should\r\n    start out with <b>super();</b> to construct the <b>Object</b> class\r\n    that they extend (recall that objects of the <b>Object</b> class store no\r\n    state so their constructor takes no parameters).\r\n  If we omit a call to <b>super</b> in the constructor of a class, java\r\n    automatically includes a call to <b>super();</b> for us, right at the top;\r\n    if the class we are writing extends a class that does not have a\r\n    parameterless constructor, the Java compiler will complain.\r\n  <p>\r\n  The general parameterless constructor that Java writes for class\r\n     <b><i>C</i></b> is thus\r\n<b><pre>  public class <i>C()</i>\r\n  {super();}</pre></b>\r\n  <p>\r\n  Finally, subclass constructors typically specify more parameters than their\r\n    superclass constructors, because the subclass constructor reinitialize \r\n    instance variables in the superclass (via <b>super</b>) AS WELL AS all of\r\n    its own instance variables -the ones that it defines that the superclass\r\n    doesn't know about.\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Methods -->\r\n\r\n<a name=\"Methods\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>methods and Subclassing </b></td>\r\n<td width =\"80%\">\r\n  By far the most interesting, and most subtle, facet of subclasses is how\r\n    they can inherit and use methods from their superclasses.\r\n  Although we have seen that they also inherit fields, most access modifiers\r\n    for fields are <b>private</b>, so the subclass cannot directly access the\r\n    fields defined in its superclass; it must use the accessors/mutators \r\n    supplied by the supercalss  to examine/change these instance variables.\r\n  But, because most accessor modifiers for methods are <b>public</b>, methods\r\n    inherited from the superclass can be referred to in the subclass.\r\n  <p>\r\n  In this section we will discuss inherited methods, new methods, and finally\r\n    overridden methods (which are the most interesting and powerful).\r\n  First, a subclass <i>inherits</i> all methods that are available in its\r\n    superclass.\r\n  We can call such methods on any variable whose type is specified by the\r\n    subclass.\r\n  The <b>IntCounter</b> superclass declares the <b>reset</b>, <b>getValue</b>,\r\n    and <b>toString</b> methods.\r\n  The <b>ModularCounter</b> subclass inherits all these methods.\r\n  So, if we declare <b>ModularCounter mc = new ModularCounter(0,3);</b> \r\n    then we can call <b>mc.reset();</b> and <b>mc.getValue()</b> and\r\n    <b>mc.toString()</b> - which, remember, is called implicitly in\r\n    <b>System.out.println(\"mc = \" + mc);</b>\r\n  <p>\r\n  In all these cases Java executes the methods defined in  the\r\n    <b>IntCounter</b> superclass.\r\n  Such a method, being in the superclass and not the subclass, can refer only\r\n    to instance variables declared in the <b>IntCounter</b> superclass; it is\r\n    not really aware that it is being called via a <b>ModularCounter</b>\r\n    object.\r\n  <p>\r\n  Second, subclasses can also define new methods: ones that are not defined in\r\n    the superclass (either with a different name, OR WITH THE SAME NAME AND A\r\n    DIFFERENT SIGNATURE (parameter structure) - both such methods are\r\n    considered new methods).\r\n  The <b>ModularCounter</b> subclass defines the <b>public getModulus</b>\r\n    method simply as\r\n<b><pre>  public int getModulus()\r\n  {return modulus;}</pre></b>\r\n  There is no method with this name defined in the <b>IntCounter</b>\r\n    superclass; it wouldn't make sense to define such a method there because\r\n    <b>IntCounter</b>s don't store a modulus value!\r\n  They represent only simpler objects.\r\n  So if we declare  <b>ModularCounter mc = new ModularCounte(0,3);</b> then we\r\n    can call <b>mc.getModulus()</b> and Java executes the <b>getModulus</b>\r\n    method defined in the <b>ModularCounter</b> subclass.\r\n <p>\r\n  Finally, and most interestingly, a subclass can also <b>override</b> \r\n    a method (note the word is override NOT overwrite- the words are hard to\r\n    differentiate when you hear them).\r\n  In this case, the subclass defines its own method (with the same name and\r\n   signature as a  method that it inherits).\r\n  When we call that method (by its name, with the correct number/type of\r\n    arguments), Java executes the METHOD DEFINED IN THE SUBCLASS, not the one\r\n    it inherited from the superclass.\r\n  Thus, the subclass \"particularizes\" that method: it can access all the\r\n    instance variables declared in the subclass.\r\n  Because the <b>IntCounter</b> superclass declares a <b>public increment</b>\r\n    method (with no parameters), and because the <b>ModularCounter</b> class \r\n    inherits and overrides this method by defining\r\n<b><pre>  public void increment()\r\n  {\r\n    if (getValue() == modulus-1)\r\n      reset();\r\n    else\r\n      super.increment();\r\n  }</pre></b>\r\n  if we declare <b>ModularCounter mc = new ModularCounter(0,3);</b> \r\n    then we can call <b>mc.increment();</b> and Java executes the\r\n    <b>increment</b> method defined in the <b>ModularCounter</b> subclass\r\n    (the one shown above), which overrides the method in the superclass.\r\n  <p>\r\n  We will now examine HOW Java executes this method.\r\n  The <b>if</b> statement calls the inherited <b>getValue</b> method and\r\n    checks it for equality against one less than the <b>modulus</b> instance\r\n    variable (defined <b>private</b> inside the <b>ModularCounter</b> class,\r\n    and thus directly accessible in this method, which is also defined there).\r\n  If the test is <b>true</b>, the inherited <b>reset</b> method is called; if\r\n    <b>false</b>, the inherited <b>increment</b> method is called.\r\n  <p>\r\n  In the <b>else</b> part, if we wrote only the call <b>increment();</b> in\r\n    this method, Java would try to recursively call the same <b>increment</b>\r\n    method that it is executing: the one defined in the <b>ModularCounter</b>\r\n    subclass; but, instead we wrote <b>super.increment();</b> which tells Java\r\n    to call the overridden method that was inherited.\r\n  <p>\r\n  Our model for objects -the one showing a superclass inside a subclass- can\r\n     help us to understand the process that Java uses to decide which method to\r\n     call.\r\n  Think of the following general process happening whenever a method is called\r\n    on an object that comes from a subclass.\r\n  Java starts at the outermost subclass.\r\n  If Java finds the method defined there (right name, right signature), it\r\n    calls the method defined in that subclass.\r\n  If Java cannot find the method, it goes inward, to its direct superclass,\r\n    and repeats this process.\r\n  So, whenever Java cannot find a method in a subclass, it moves inward to its\r\n    superclass repeating the process until it finds the right method to call.\r\n  <p>\r\n  For new methods in the subclass, this is trivial, because such methods are\r\n    always found at the outer level.\r\n  Java finds the definitions of inherited methods when it moves inward, to the\r\n    superclass that first defines them.\r\n  For overridden methods, Java finds their definition in the (outer) subclass.\r\n  Although the actual process that Java uses to find a method is much more\r\n    efficient (a fast table lookup), this model is a good one to understand,\r\n    because it is simpler to explain and the result is the same.\r\n  <p>\r\n  Finally, when a subclass method overrides a superclass method, and that\r\n    method name is called (it will be immediately found in the subclass), the\r\n    subclass method can call the superclass method that it overrode by\r\n    prefixing the method's name using the keyword <b>super</b>.\r\n  Often the superclass method helps the subclass method get the job done:\r\n    the <b>increment</b> method in <b>ModularCounter</b> sometimes needs\r\n    just to increment the <b>private</b> instance variable <b>value</b> defined\r\n    in the <b>IntCounter</b> class, and the only way it can do so is by\r\n    calling the <b>increment</b> method defined in this superclass, hence the\r\n    call <b>super.increment();</b>\r\n  Concretely, if we declare\r\n    <b>ModularCounter mc = new ModularCounter(0,2);</b> in the first call to\r\n    <b>mc.increment();</b> Java finds and executes <b>increment</b> in the\r\n    subclass, which explicitly executes the inherited method; in the second\r\n    call (with <b>value</b> now set to <b>1</b>) Java finds and executes \r\n    <b>increment</b> in the subclass, which executes the inherited\r\n    <b>reset</b> method\r\n  <p>\r\n  Note that <b>IntCounter</b> class defined <b>toString</b>, which the \r\n    <b>ModularCounter</b> class overrides by defnining\r\n  <pre><b>  public String toString()\r\n  {return super.toString()+\"(\"+modulus+\")\";}</b></pre>\r\n  It works by first calling the <b>toString</b> method defined in the\r\n    <b>IntCounter</b> class, getting a <b>String</b> representation of the\r\n    <b>value</b> instance variable, and then catenating it with the\r\n    <b>modulus</b> instance variable available in this subclass.\r\n  <p>\r\n  Thus, just as we can use <b>this</b> as an explicit reference to the current\r\n    object, and we can use <b>super</b> as a reference to the current object\r\n    as well (but pretending that it is constructed from its superclass, when\r\n    accessing any member; forcing Java to find the method one level deeper in \r\n    the object pictures).\r\n</tbody>\r\n</table>\r\n\r\n<!-- Another Subclass -->\r\n\r\n<a name=\"BoundedCounter\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The BoundedCounter Subclass</b></td>\r\n<td width =\"80%\">\r\nThe <b>BoundedCounter</b> class appears below.\r\nIt is another specialization of the <b>IntCounter</b> and quite similar\r\n  in form to <b>ModularCounter</b>.\r\nBut, it works by counting up to a certain bound and stopping there: further\r\n   increment operations have no effect.\r\n<b><pre>  public class BoundedCounter extends IntCounter {\r\n\r\n    public BoundedCounter (int bound)\r\n    {this(0,bound);}\r\n\r\n    public BoundedCounter (int value, int bound)\r\n      throws IllegalArgumentException\r\n    {\r\n      super(value);\r\n      if (bound < 0)\r\n        throw new IllegalArgumentException(\"BoundedCounter: bound bad\");\r\n      if (value > bound)\r\n        throw new IllegalArgumentException(\"ModularCounter: value bad\");\r\n\r\n      this.bound = bound;\r\n    }\r\n\r\n    public int getBound()\r\n    {return bound;}\r\n\r\n    public void increment()\r\n    {\r\n      if (getValue() < bound)\r\n        super.increment();\r\n    }\r\n\r\n    public String toString()\r\n    {return super.toString()+\"[bounded by \"+bound+\"]\";}\r\n\r\n    private final int bound;\r\n}</pre></b>\r\nSo, we can extend <b>IntCounter</b> by specializing it to add more methods\r\n  and modifying the meanings of inherited methods (as well as adding the\r\n  appropriate constructors).\r\nNotice that each subclass has to define only the differences between it\r\n  and its superclass.\r\nOften the subclass will inherit very many methods from the superclass,\r\n  definining just a small amount of new state, a few new methods, and\r\n  overriding just a few inherited methods.\r\nThus, it is economical to define such subclasses.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- JavaDoc -->\r\n\r\n<a name=\"Javadoc\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Javadoc and Inheritance Hierarchies</b></td>\r\n<td width =\"80%\">\r\n  Javadoc includes special features that help us understand how a class fits\r\n    in the inheritance hierarchy.\r\n  Below is the Javadoc for the <b>ModularCounter</b> class.\r\n  I have run Javadoc on exactly the code shown above, which constains\r\n    no special Javadoc comments, so we can concentrate on the structural\r\n    details of inheritance.\r\n</tbody>\r\n</table>\r\n   <img src=\"images/mcjavadoc.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  This tells us that the <b>ModularCounter</b> class is declared in the\r\n   <b>edu.uci.ics.pattis.introlib</b> package.\r\n  It is a subclass whose direct superclass is <b>IntCounter</b> (also declared\r\n    in this same package); likewise, this class is a subclass whose direct\r\n    superclass is <b>Object</b> (declared in the <b>java.lang</b> package).\r\n  As we have seen <b>Object</b> has no direct superclass, because it is at the\r\n    very top of the Java class hierarchy.\r\n  <p>\r\n  It shows the Constructor Summary next, which contains the two contructors\r\n    that we have studied.\r\n  The Method Summary shows all the other methods defined in this class:\r\n    <b>getModulus</b> is a newly defined method; <b>increment</b> and\r\n    <b>toString</b> override inherited methods.\r\n  Following the Method Summary, Javadoc shows the methods inherited in each of\r\n    the superclasses of <b>ModularCounter</b>.\r\n  It shows <b>getValue</b> and <b>reset</b> from <b>IntCounter</b>, and the\r\n    standard methods from <b>Object</b> that it inherits.\r\n  Notice that the <b>toString</b> method defined in the <b>Object</b> class\r\n    is not listed, because there is no way for a method in the the\r\n    <b>ModularCounter</b> class to refer to this method:\r\n    <b>super.toString()</b> refers to the <b>toString</b> method inheritred\r\n    from the <b>IntCounter</b> class, and we CANNOT WRITE anything like\r\n    <b>super.super.toString()</b>!\r\n  <p>\r\n  As another example, we will soon study the details of the <b>JButton</b>\r\n    class, which allows us to place buttons in an application and take an\r\n    appropriate action when they are pressed (actually, as we will soon see,\r\n    there is much more to a <b>JButton</b> than this description implies).\r\n  If we examine the JavaDoc from Sun's API for this class, it starts with\r\n</tbody>\r\n</table>\r\n   <img src=\"images/jbuttonhierarchy.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\n  This tells us that the <b>JButton</b> class is declared in the\r\n   <b>javax.swing</b> package.\r\n  It is a subclass whose direct superclass is <b>AbstractButton</b>\r\n    (also declared in the <b>javax.swing</b> package); likewise, this class is\r\n    a subclass whose direct superclass is <b>JComponent</b> (also declared in\r\n    the <b>javax.swing</b> package); likewise, this class is a subclass whose\r\n    direct superclass is <b>Container</b> (declared in a different package,\r\n    <b>java.awt</b>); likewise, this class is a subclass whose direct\r\n    superclass is <b>Component</b> (also declared in the <b>java.awt</b>\r\n    package); finally, this class is a subclass whose direct superclass is\r\n    <b>Object</b> (declared in the <b>java.lang</b> package).\r\n  As we have seen <b>Object</b> has no direct superclass, because it is at the\r\n    very top of the Java class hierarchy.\r\n  <p>\r\n  In addition, after displaying all the methods defined by this class,\r\n    Javadoc shows the methods inherited in each of the subclasses.\r\n  For <b>JButton</b> this appears as \r\n</tbody>\r\n</table>\r\n   <img src=\"images/jbuttoninherited1.gif\"></image><br>\r\n   <img src=\"images/jbuttoninherited2.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nSo, it appears that objects in the <b>JButton</b> class have very many\r\n  methods that we can use to query and control them.\r\nAt this point in our studies, I am not concerned with the functioning of\r\n  <b>JButtons</b>, but with the functioning of Javadoc when documenting\r\n  subclasses.\r\n<p>\r\nDo Java programs know all these methods?\r\nCertainly the more you know the easier it is to program in Java.\r\nBut the method usage probably follows some kind of <b>power law</b>:\r\n  when plotting the frequency of use of each method, one finds that\r\n  a small number of methods are used a huge amount of time, and a\r\n  huge number of methods are rarely used at all.\r\nTthe exact curve is a straight line when plotted on a log graph, with\r\n  the power being the slope: recall <b>log(a<sup>b</sup>)</b> equals\r\n  <b>b log (a)</b>.\r\n<p>\r\nMany applications can be written by calling just the <b>setText</b>\r\n  and <b>addActionListener</b> methods: specifying what the button's\r\n  label is and what to do when the button is pushed.\r\nOthers also use <b>setIcon</b>, <b>getText</b>, <b>setEnabled</b>.\r\nI have probably used another half-dozen methods in all the GUIs I've\r\n  written (admitedly, I'm not a professional programmer).\r\n</tbody>\r\n</table>\r\n\r\n\r\n<!-- Polymorphism -->\r\n\r\n<a name=\"Polymorphism\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Polymorphism, Casting, instanceof </b></td>\r\n<td width =\"80%\">\r\nRecall that there are two critical rules to understand about Java method\r\n  calls.\r\nWe restate them here, and illustrate how they are applied in the context of\r\n  inheritance hierarchies.\r\nThese rules, and the type compatibility rules discussed below, are at the\r\n   core of Object-Oriented Programming.\r\n<p>\r\nThe first rule is applied at compile time, the second at runtime:\r\n  (1) what methods the Java compiler ALLOWS to be called on a variable and\r\n  (2) how Java determines WHICH METHOD (in the context of inheritance and\r\n      overriding) to call.\r\n<ol>\r\n  <li>The type of a variable (when it is declared) determines what methods we\r\n        can call on it (regardless of what object it refers to).\r\n      When the compiler examines code with a method call, it checks only that\r\n        the  declared type of the variable supports the method call.\r\n  <p>\r\n  <li>The object that a variable refers to determines what method is actually\r\n        called (regardless of the type of a variable: of course, the type\r\n        must allow the call).\r\n      When the Java runtime systems calls a method, it follows the reference\r\n        from the variable to the object; it is the class of that object that\r\n        determine which method with that name to call.\r\n  </ol>\r\nSo, if we declare <b>ModularCounter mc = ...;</b> then we can call any\r\n   methods on <b>mc</b> that are defined or inherited by the\r\n   <b>ModularCounter</b> class.\r\nIt is not affected by the actual class of the object that <b>mc</b>\r\n  refers to.\r\nThis is just as at was with interfaces: if we declare a variable with the\r\n  name of an interface, we can use it to call only those methods defined\r\n  in the interface.\r\n<p>\r\nAs we shall soon see, we can declare\r\n  <b>IntCounter ic = new ModularCounter(0,3);</b>\r\n  (storing into a superclass variable a reference to a subclass object).\r\nWhen we call the method <b>increment</b> (the <b>ModularCounter</b>\r\n  class overrides the <b>increment</b> method that it inherits from\r\n  <b>IntCounter</b>), Java executes the method defined in the\r\n  <b>ModularCounter</b> class.\r\n<p>\r\nReread the previous paragraphs.\r\nEverything else that we discuss in terms of inheritance is built upon these\r\n  ideas (which we will continue to explore -and become better acquainted with-\r\n  throughout the rest of the quarter).\r\n<p>\r\nThe ability of a variable to refer to objects constructed from different\r\n  classes (but compatible with the variable's type via interfaces and the\r\n  class hierarchy), and for the correct method to be determined at runtime \r\n  is called <b>polymorphism</b>, which means \"many forms\".\r\n<p>\r\nThe rules of assignment, between a variable and a reference, become much more\r\n   interesting when classes are related by an inheritance hierarchy.\r\nWe have already seen that we can assign a reference to an object to a variable\r\n  whose type is an interface, if the object's class implements the interface.\r\nThe basic rules for inheritance are\r\n<ol>\r\n  <li><b>Implicit Upcasting</b>: We can assign a reference to a subclass object to a\r\n    variable whose type is a superclass, without any casting.\r\n    An example is <b>IntCounter c1 = new ModularCounter(0,3);</b>\r\n    In fact, it is correct but redundant to write\r\n      <b>IntCounter c1 = (IntCounter)(new ModularCounter(0,3));</b>\r\n    Of course, this is why we can write <b>Object o = new ....</b>: EVERTHING\r\n      can be implicitly upcasted to the <b>Object</b> class.\r\n  <p>\r\n  <li><b>Explicit Downcasting</b>: We can attempt to assign a reference to a\r\n       superclass object to a variable whose type is a subclass, but we must\r\n       use a cast to do so.\r\n     Whenever we downcast, Java BELIEVES AT COMPILE TIME that the downcast will\r\n        work, but Java CHECK AT RUNTIME that the cast works.\r\n     An example is <b>ModularCounter c2 = (ModularCounter)c1;</b> (which given\r\n       the declaration of <b>c1</b> will work at runtime).\r\n     WE COULD NOT WRITE <b>ModularCounter c2 = c1;</b> the Java COMPILER would\r\n       report an error: we need the explicit cast when going downwards.\r\n     This is why we almost always needed downcasting with the <b>pop</b> and\r\n       <b>dequeue</b> methods: e.g. <b>Integer i = (Integer)q.dequeue();</b>\r\n  <p>\r\n  <li>If the class of an object and the type of the variable are not related\r\n        by a subclass/superclass relationship, we cannot assign one to the\r\n        other.\r\n      WE COULD NOT WRITE <b>ModularCounter c3 = new Timer();</b> or\r\n      <b>ModularCounter c3 = (ModularCounter)(new Timer());</b> \r\n      the Java COMPILER would dectect and report an error.\r\n</ol>\r\nWhy do these rules make sense?\r\nWe know that an object constructed from a subclass (think\r\n  <b>ModularCounter</b>) supports all the methods that Java allows to be called\r\n  on a superclass (think <b>IntCounter</b>) because the subclass inherits all\r\n  the methods in the superclass -of course, it may override some or add new\r\n  methods as well.\r\nRecall that it is legal to write <b>Object o = new ...</b> with any class\r\n   constructing the object stored in <b>o</b>; but recall too that Java allows\r\n   us to call only those methods on <b>o</b> that are defined in the\r\n   <b>Object</b> class.\r\nSo upcasting reduces the number of methods that can be called (from those in\r\n  the subclass to just those in the superclass).\r\n<p>\r\nDowncasting increases the number of methods that can be called using a\r\n   variable (we can call all the methods in the subclass specified by the\r\n   cast), so Java requires us to use explicit casting, which is a signal to\r\n   us that Java will check something at runtime.\r\nThe downcasting <b>ModularCounter mc = (ModularCounter)(new IntCounter(5));</b>\r\n   is accepted by the Java compile, but it always fails at runtime because\r\n   the object created is not of the <b>ModularCounter</b> class.\r\nIf we subsequently tried to call <b>mc.getModulus()</b>, it wouldn't work\r\n  because an object constructed from the <b>IntCounter</b> class fails to\r\n  support that method.\r\n  <p>\r\nSo when does downcasting work?\r\nSuppose we use the <b>SimpleStack</b> class (the one with <b>Object</b>\r\n   parameters and return types) in the following way.\r\n<pre><b>  SimpleStack s = new SimpleStack();\r\n  s.push(new ModularCounter(0,3));\r\n  ModularCounter mc = (ModularCounter)s.pop();</b></pre>\r\nHere the downcast works, because the <b>Object</b> returned by <b>pop</b>\r\n  really is a reference to an object constructed from the\r\n  <b>ModularCounter</b> class.\r\nIf we had written <b>s.push(new IntCounter(0));</b> then the previous code\r\n  would still compiler, but the cast after popping would throw the\r\n  <b>ClassCastException</b>.\r\n  <p>\r\nFinally, we will learn better the semantics of <b>instanceof</b>.\r\nRecall that we originally learned that the expression\r\n  <b>x instanceof <i>TypeName</i></b> returns <b>true</b> when <b>x</b>\r\n  stored a non-<b>null</b> reference and <b>x</b> refers to an object\r\n  constructed from class <b><i>TypeName</i></b>.\r\nNow we generalize this last part allowing <b>x</b> to refer to an object\r\n  that is allowed to be casted to class <b><i>TypeName</i></b> (which\r\n  can be the name of a class or interface).\r\nThus, if we declare <b>ModularCounter mc = new ModularCounter(0,3);</b>\r\n  and asked <b>mc instanceof Counter</b> the result is <b>true</b> (if we\r\n  did what the next section shows: declare an interface named <b>Counter</b>,\r\n  and declared  <b>ModularCounter</b> to implement <b>Counter</b>).\r\nIf we asked <b>mc instanceof IntCounter</b> the result is <b>true</b> again,\r\n  not because <b>mc</b> refers to an object of the class <b>IntCounter</b>,\r\n  but because we could perform an upcast to this class.\r\nOf course, if we asked <b>mc instanceof ModularCounter</b> the result is\r\n  <b>true</b>.\r\nIn upcasting, <b>instanceof</b> always returns <b>true</b> because\r\n  <b><i>TypeName</i></b> is a superclass of the actual object that <b>x</b>\r\n  refers to; in downcasting it must truly check to see if the object is\r\n  constructed from the specified class.\r\n<p>\r\n For completeness, if a reference variable stores <b>null</b> it can be casted\r\n   to any class (but don't try to call a method with the result, because it\r\n   refers to no object).\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Counter Interface -->\r\n\r\n<a name=\"Interface\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Counter Interface</b></td>\r\n<td width =\"80%\">\r\nIn fact, all the counter classes implement a common interface.\r\nLet's see how this is done and why it is useful.\r\nThe <b>Counter</b> interface is specified as\r\n<b><pre>  public interface Counter {\r\n    public void reset();\r\n    public void increment();\r\n    public int  getValue();\r\n  }</pre></b>\r\nSo, for some class to implement this <b>Counter</b> interface, it\r\n  needs to implement at least these three methods; in fact, all the\r\n  classes that we have seen implement these and more.\r\nSo, when we declare the <b>IntCounter</b>, <b>ModularCounter</b>, and\r\n  <b>BoundedCounter</b> class, it is really done as follows:\r\n<b><pre>  public class IntCounter implements Counter {...\r\n  public class ModularCounter extends IntCounter implements Counter {...\r\n  public class BoundedCounter extends IntCounter implements Counter {...\r\n</pre></b>\r\nIn fact, Java allows us to leave off the last two <b>implements Counter</b>\r\n  because when we tell Java that <b>ModularCounter extend IntCounter</b>,\r\n  it combines this knowledge with its knowledge that\r\n  <b>IntCounter implements Counter</b> to deduce that \r\n  <b>ModularCounter implements IntCounter</b> because even if\r\n  <b>ModularCounter</b> did not define one method, it would inherit\r\n  all the methods from <b>IntCounter</b> and thus inherit all the methods\r\n  it needs to implement <b>Counter</b>.\r\n<p>\r\nSo, let's look at the following three declarations, all of which are legal\r\n  because the types are compatible with the objects (via interface, or\r\n   upcasting, or just having the same type as the constucted object).\r\n<b><pre>  Counter        c1 = new ModularCounter(0,3);\r\n  IntCounter     c2 = new ModularCounter(0,3);\r\n  ModularCounter c3 = new ModularCounter(0,3);</pre></b>\r\nWe can call <b>reset</b>, <b>getValue</b>, and <b>increment</b> on\r\n  all these variables.\r\nWe can call <b>toString</b> as well, because any class will at least\r\n  inherit the <b>toString</b> method from the <b>Object</b> class.\r\nIn addition, we can call <b>c3.getModulus()</b>, but we CANNOT CALL\r\n  <b>c1.getModulus()</b> and we CANNOT CALL <b>c2.getModulus()</b> because\r\n  the types of these variables do not specify this method.\r\nRemember, it is the type of the variable that determines what methods\r\n  can be called on it.\r\n<p>\r\nLikewise when we call <b>c1.increment()</b> or <b>c2.increment()</b> or\r\n  <b>c3.increment()</b> Java executes the <b>increment</b> method defined\r\n  in the <b>ModularCounter</b> class -the right one for all the objects-\r\n  because the actual method called depends on the class of the object (not\r\n  the type of the variable)\r\n<p>\r\nStudents have a devil of a time understanding the type/object distinction.\r\nThey always seem to want it backwards: that the type of the variable determines\r\n   which method is called, and the class of the object a variable refers to\r\n   determines whether a method can be called.\r\nThe right rules are not complicated, but takes a bit of getting used to.\r\n<p>\r\nSo, which of the three declarations above would I put in a program?\r\nI like to use the most restrictive type possible.\r\nIf all I care about a counter is calling its <b>reset</b>, <b>getValue</b>,\r\n  and <b>increment</b> methods, then I might as well declare it with\r\n  the type <b>Counter</b>.\r\nTechnically then, I don't care whether I'm using an <b>IntCounter</b>,\r\n  <b>ModularCounter</b>, or <b>BoundedCounter</b>.\r\nIn fact, I might change the code from one to the other; by declaring the\r\n  type generically, as <b>Counter</b>, the rest of the code will guarantee\r\n  to compile, even when I change what constructed object I am using.\r\n<p>\r\nOf course, if I needed to call <b>getModulus</b>, only the third declaration\r\n  works (because then I truly must have a <b>ModularCounter</b>).\r\nLet's explore the issue of types a bit further.\r\nSuppose I want to collect a bunch of counters in an array , and then\r\n  increment all of them.\r\nWe don't know from which classes each counter is constructed; some\r\n  might be from one class and some from another.\r\nThe simplest way to do this is by\r\n<b><pre>  Counter[] counters = new Counter[...];\r\n\r\n  //Code to store a new <b>IntCounter</b>, <b>ModularCounter</b>,\r\n  // or <b>BoundedCounter</b> into each member index in counters.\r\n\r\n  for (int i=0; i&lt;counters.length; i++) {\r\n    Counter c = counters[i];\r\n    c.increment();             //or just counters[i].increment();\r\n  }</pre></b>\r\nBy using the interface name <b>Counter</b> for the type of the array, we are\r\n  specifying that every array member refers to some object constructed from\r\n  a class implementing <b>Counter</b>.\r\nIt is the right generalization for all the objects that get stored in this\r\n  array.\r\n<p>\r\nThe <b>for</b> loop generates each index in the array.\r\nWe can write <b>Counter c = counters[i];</b> because <b>c</b>, as well as any\r\n   member in the <b>counters</b> array, is of type <b>Counter</b>.\r\nThen we call <b>increment</b> to change the state of the object.\r\nIn fact, this can be accomplished more simply by writing just\r\n  <b>counters[i].increment()</b>\r\n<p>\r\nWhat students invariable want to do is to store each class of counter in a\r\n  different array, and then write a loop that processes each.\r\nThis takes lots of code.\r\n<p>\r\nI have also seen students use one array but write code like this.\r\n<b><pre>  for (int i=0; i&lt;counters.length; i++) {            //TERRIBLE\r\n    Counter c = counters[i];                         //TERRIBLE\r\n    if (c instanceof IntCounter)                     //TERRIBLE\r\n      ((IntCounter)counters[i]).increment();         //TERRIBLE\r\n    else if (c instanceof ModularCounter)            //TERRIBLE\r\n      ((ModularCounter)counters[i]).increment();     //TERRIBLE\r\n    else if (c instanceof BoundedCounter)            //TERRIBLE\r\n      ((BoundedCounter)counters[i]).increment();     //TERRIBLE\r\n  }</pre></b>\r\nNone of the uses of <b>instanceof</b> and/or casting is needed.\r\n<p>\r\nThe original approach is much simpler (once you understand the concepts\r\n  involved -hang in there) and more elegant.\r\nIt also is robust under changes.\r\nFor example, if I define a new class that also implements <b>Counter</b>, its\r\n  objects can also be put in the array and incremented with the exact code\r\n  shown above.\r\nIn other approaches I'd have to declare a new array or add another\r\n  <b>else if</b> in the code above.\r\nThese kinds of changes cripple software maintenance.\r\n<p>\r\nAs a final example, suppose that we have enqueued a bunch of\r\n  objects into a <b>SimpleQueue</b>.\r\nWe want to dequeue each object, and if it is a reference to a class that\r\n  implements <b>Counter</b>, we want to add its current value into a sum.\r\nHere is the code for this\r\n<b><pre>  SimpleQueue q = new SimpleQueue();\r\n\r\n  //Code to store a new <b>IntCounter</b>, <b>ModularCounter</b>,\r\n  // <b>BoundedCounter</b> or any other reference into q.\r\n\r\n  int sum = 0;\r\n  for (;!q.isEmpty();) {\r\n    Object o = q.dequeue();\r\n    if (o instanceof Counter)\r\n      sum += ((Counter)o).getValue();\r\n  }</pre></b>\r\nNote that if we were guaranteed that every reference in the queue was to\r\n  an object constructed from a class implementing <b>Counter</b>, we could\r\n  write the loop more simply as\r\n<b><pre>  for (; !q.isEmpty(); )\r\n      sum += ((Counter)q.dequeue()).getValue();</pre></b>\r\nHere we can directly cast the dequeued value.\r\nIn the former code, all non-<b>Counter</b> references are skipped; in this\r\n  code any non-<b>Counter</b> reference causes a <b>ClassCastException</b> to\r\n  be thrown.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Decorator -->\r\n\r\n<a name=\"Decorator\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>The SkipCounter Decorator</b></td>\r\n<td width =\"80%\">\r\nRecall the \r\n  <a href=\"../interfaces/lecture.html#Sorting\">ReverseAComparator</a>\r\n  decorator.\r\nIts constructor took an object constructed from any class implementing\r\n  the <b>Comparator</b> interface.\r\nThis class also implements <b>Comparator</b> by decorating the object it\r\n  is passed so that its <b>compare</b> method always returns the opposite\r\n  result.\r\nWe will now look at another decorator, this time for <b>Counter</b>.\r\nIt is defined as\r\n<b><pre>  public class SkipCounter implements Counter  {\r\n \r\n    public SkipCounter (Counter toDecorate, int skip)\r\n      throws IllegaArgumentException\r\n    {\r\n      if (skip < 1)\r\n        throw new IllegalArgumentException\r\n          (\"SkipCounter: skip(\"+skip+\") < 1\");\r\n      baseCounter = toDecorate;\r\n      this.skip = skip;\r\n    }\r\n  \r\n    public void reset ()\r\n    {baseCounter.reset();}\r\n\r\n    public void increment ()\r\n    {\r\n      for (int i=1; i&lt;= skip; i++)\r\n        baseCounter.increment();\r\n    }\r\n\r\n    public int getValue()\r\n    {return baseCounter.getValue();}\r\n\r\n    public String toString()\r\n    {return baseCounter+\"(skip \"+skip+\")\";}\r\n\r\n    private Counter baseCounter;\r\n    private int     skip;\r\n}</pre></b>\r\nNotice that the constructor takes as parameters a reference to an object\r\n  that is constructed from some class that implements <b>Counter</b> and\r\n  a positive <b>int</b>.\r\nThe reference is stored in the instance variable <b>baseCounter</b> and the\r\n  <b>int</b> is stored in the instance variable <b>skip</b>.\r\nBecause this class implements <b>Counter</b> it must define the methods\r\n  <b>reset</b>, <b>increment</b> and <b>getValue</b>.\r\nThe first and last are implemented by just applying the same-named method\r\n  to <b>baseCounter</b>; the middle is implemented by applying the same-named\r\n  method <b>skip</b> times to <b>baseCounter</b>, incrementing the counter\r\n  <b>skip</b> times.\r\nFinally, the <b>toString</b> method is overridden, to catenate the\r\n  <b>toString</b> of the <b>baseCounter</b> along with how much it is\r\n  skipping).\r\n<p>\r\nThus, if we write\r\n  <b>Counter c = new SkipCounter(new ModularCounter(0,3), 2);</b> and\r\n  then call <b>c.increment()</b> then <b>c.getValue()</b> returns <b>2</b>,\r\n  incrementing <b>0</b> to <b>1</b> to <b>2</b>.\r\nIf we call <b>c.increment()</b> again then <b>c.getValue()</b> returns\r\n  <b>1</b>, incrementing <b>2</b> to <b>0</b> (remember its modulus is\r\n  <b>3</b>) to <b>1</b>.\r\nLikewise, calling <b>c.toString()</b> at this time returns the <b>String</b>\r\n  <b>\"1(mod 3)(skip 2)\"</b>.\r\n<p>\r\nThus we can decorate any counter by making each call to <b>increment</b>\r\n   actually increment <b>skip</b> times.\r\n<p>\r\nAn alternative approach would be to extend the class hierarchy as follows.\r\n</tbody>\r\n</table>\r\n   <img src=\"images/skiphierarchy.gif\"></image>\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\">&nbsp</td>\r\n<td width =\"80%\">\r\nBut, with this approach, we need a different subclass for every class in the\r\n  hierarchy; and if we added more classes into it, we'd need to add more\r\n  skip subclasses for each.\r\nSo, because of the nature of skipping, rather than have to write all these\r\n  classes we can write one decoarator class and apply it to any objects\r\n  constructed from any class in this hierarchy.\r\n</tbody>\r\n</table>\r\n\r\n\r\n\r\n<!-- Problem Set -->\r\n\r\n<a name=\"ProblemSet\"><hr align=\"left\" width=\"33%\">\r\n<table cellspacing=\"0\" cellpadding=\"5\" border=\"0\" rules=\"none\" width=\"100%\">\r\n<tbody>\r\n<tr valign=\"top\">\r\n<td width =\"20%\"><b>Problem Set</b></td>\r\n<td width =\"80%\">\r\n  To ensure that you understand all the material in this lecture, please solve\r\n    the the announced problems after you read the lecture.\r\n  <p>\r\n  If you get stumped on any problem, go back and read the relevant part of the\r\n     lecture.\r\n  If you still have questions, please get help from the Instructor, a CA,\r\n    or any other student.\r\n\r\n<ol> \r\n<li>What would happen if we accidentally forgot to call <b>super</b> (commented\r\n      out) in the  the following constructor? Syntax error or runtime error?\r\n      Explain.\r\n<b><pre>  public ModularCounter (int value, int modulus)\r\n    throws IllegalArgumentException\r\n  {\r\n    //Accidentally leave out the call: super(value);\r\n    if (modulus < 1)\r\n      throw new IllegalArgumentException(\"ModularCounter: modulus bad\");\r\n    if (value < 0 || value >= modulus)\r\n      throw new IllegalArgumentException(\"ModularCounter: value bad\");\r\n\r\n    this.modulus = modulus;\r\n  }</b></pre>\r\n\r\n<p>\r\n<li>Explain why the following <b>increment</b> method (written in the\r\n    <b>ModularCounter</b> class) is not as good as the original one shown\r\n    above?\r\n<b><pre>  public void increment()\r\n  {\r\n    super.increment();\r\n    if (getValue() == modulus)\r\n      reset();\r\n  }</pre></b>\r\n<p>\r\n<li>We saw that if we declare\r\n      <b>ModularCounter x = new ModularCounter(0,3);</b>\r\n      and then ask <b>x instanceof IntCounter</b> it would return <b>true</b>.\r\n    Write a more complicated expression that returns <b>true</b> if and only\r\n      if <b>x</b> really refers to an object constructed from the class\r\n      <b>IntCounter</b>, not any of its subclasses.\r\n    What problem arises in this code if we add more subclasses of\r\n      <b>IntCounter</b>?\r\n    For the ambitious student: check out the <b>Object</b> class for an\r\n      alternative, fail-safe, way to write this code too.\r\n<p>\r\n<li>Java will not let us rewrite the simpler constructor in\r\n  <b>ModularCounter</b> as\r\n<b><pre>  public ModularCounter (int modulus)\r\n  {\r\n   super();\r\n   this(0,modulus);\r\n  }</pre></b>\r\nWhat error does the compiler generate?\r\nWhat problem could be created if this body were allowed (see also the\r\n  body of the more complicated constructor that <b>this</b> refers to)?\r\n\r\n<p>\r\n<li>Do you think we are allowed to call a new or inherited method in a\r\n      constructor?\r\n    For example, if we wanted each call to the constructor to print immediately\r\n    the object that it constructed, could we write any of the\r\n    following? For each that is legal, what would it print if we wrote\r\n    <b>...new ModularCounter(0,3);</b>\r\n<b><pre>  public ModularCounter (int value, int modulus)\r\n  {\r\n    System.out.println(this);\r\n    super(value);\r\n    this.modulus = modulus;\r\n  }\r\n\r\n  public ModularCounter (int value, int modulus)\r\n  {\r\n    super(value);\r\n    System.out.println(this);\r\n    this.modulus = modulus;\r\n  }\r\n\r\n  public ModularCounter (int value, int modulus)\r\n  {\r\n    super(value);\r\n    this.modulus = modulus;\r\n    System.out.println(this);\r\n  }</b></pre>\r\n<p>\r\n<li>Explain what the following method does (it is legal in Java).\r\n<b><pre>  public static Counter gimmeACounter()\r\n  {\r\n     if (Math.random() < .5)\r\n       return new IntCounter(0);\r\n     else\r\n       return new ModularCounter(0,3);\r\n  }</pre></b>\r\nGiven this method, which of the following declarations is legal?\r\n<b><pre>  Counter        x = gimmeACounter();\r\n  IntCounter     x = gimmeACounter();\r\n  ModularCounter x = gimmeACounter();</pre></b>\r\nIf we added explict downcasting to the illegal declarations, would\r\n  they always, never, or sometimes cause a RUNTIME error?\r\nIf we changed the return type of <b>gimmeACounter</b> to <b>IntCounter</b>,\r\n  would the method be legal in Java? Explain why and indicate which\r\n  declarations would still be legal (and how would explicit downcasting\r\n  work). Same questions if we changed the return type to <b>ModularCounter</b>.\r\n<p>\r\n<li>Answer each of the following related questions\r\n    <ul>\r\n    <li>Suppose that we wanted to write an <b>equals</b> method that tested\r\n      equality just by testing the value of each counter (a test not involving\r\n      its modulus or bound).\r\n    In what class(es) would we write this code (and what code goes there; if\r\n      more than one class needs to have new code, just write the code for\r\n      one of the classes)?\r\n    <li>Suppose that we wanted to write an <b>equals</b> method that tested\r\n      true state equality: the objects compared must come from the same\r\n      class and their state must be identical\r\n    In what class(es) would we write this code (and what code goes there; if\r\n      more than one class needs to have new code, just write the code for\r\n      one of the classes)?\r\n    <li>Suppose that we wanted to write a class implementing <b>Comparator</b>,\r\n      such that we could use it to sort objects from any class implementing\r\n      <b>Counter</b> as well as object constructed from the <b>Integer</b>\r\n      wrapper class.\r\n    In what class(es) would we write this code (and what code goes there; if\r\n      more than one class needs to have new code, just write the code for\r\n      one of the classes)?\r\n    </ul>\r\n<p>\r\n<li>What would Java do if the body of the <b>getModulus</b> method contained\r\n      a call to <b>super.getModulus()</b>?\r\n<p>\r\n<li>Write a constructor for <b>SkipCounter</b> that has just one <b>int</b>\r\n       parameter, <b>skip</b>.\r\n    It should create a <b>SkipCounter</b> object that automatically decorates\r\n    an <b>IntCounter</b>.\r\n<p>\r\n<li>Explain why it is not a good idea for <b>SkipCounter</b> to\r\n    <b>extend IntCounter</b> or any other class besides <b>Object</b>.\r\n<p>\r\n<li>Write a <b>public static</b> method named <b>allOK</b> that takes two\r\n      parameters: a filled array of <b>DecisionInt</b> and an <b>int</b>.\r\n    This method returns <b>true</b> if every object in the array, when its\r\n      <b>isOK</b> method is called on the <b>int</b> parameter, returns\r\n      <b>true</b>; otherwise it should return <b>false</b>.\r\n<p>\r\n<li>Carefully finish this sentence.\r\n    The first argument passed to the constructor of <b>SkipCounter</b>\r\n    must be ...\r\n    <!-- a reference to an object constructed from some class that implements\r\n         the <b>Counter</b> interface --->\r\n</ol>\r\n</td>\r\n</tbody>\r\n</table>\r\n\r\n\r\n</body>\r\n</html>\r\n\r\n<!--\r\nis it possible for superclass method to access a variable in a subclass\r\nrephrase as easy because one can contort java to do strange things\r\n\r\n-->", "encoding": "ascii"}