{"url": "https://www.ics.uci.edu/~eppstein/projects/pairs/Source/testbed/CongaLine.cp", "content": "// Test of closest pair algorithms\n// David Eppstein, UC Irvine, 19 Apr 1997\n//\n// Conga line closest pair algorithm\n\n#include \"CongaLine.h\"\n#include \"Error.h\"\n\n#define NO_SUBSET ((CongaSubset) 0xffff)\n#define SCRATCH_SUBSET ((CongaSubset) how_many_subsets)\n\n// add an edge to the graph\ninline void CongaLine::AddEdge(point in, point out, double d, CongaSubset s)\n{\n\tif (how_many_edges == 2*max_points)\n\t\terror(\"CongaLine: too many edges\");\n\tedges[how_many_edges].in = in;\n\tedges[how_many_edges].out = out;\n\tedges[how_many_edges].d = d;\n\tedges[how_many_edges].s = s;\n\thow_many_edges++;\n}\n\n// remove an edge from the graph\ninline void CongaLine::RemoveEdge(unsigned long e)\n{\n\tif (e >= how_many_edges) error(\"CongaLine: removing the same edge twice\");\n\tedges[e] = edges[--how_many_edges];\t// copy struct\n}\n\n// move a point to a new subset, leaving all edges in place\n// caller is responsible for calling subset_sizes.Update(p)\ninline void CongaLine::MoveToSubset(point p, CongaSubset s)\n{\n\tif (subsets[p] < how_many_subsets) subset_sizes[subsets[p]]--;\n\tsubsets[p] = s;\n\tif (subsets[p] < how_many_subsets) subset_sizes[subsets[p]]++;\n}\n\n// We are about to move a point out of its set; call subset_sizes.Update(p)\ninline void CongaLine::FixWhat(point p)\n{\n\tCongaSubset s = subsets[p];\n\tif (s >= how_many_subsets) return;\n\tsubset_sizes[s]--;\t\t// temp so update sees correct value\n\tsubset_sizes.Update(s);\n\tsubset_sizes[s]++;\t\t// undo temp change\n}\n\n// reset all data structures by inserting all points into cluster zero\nvoid CongaLine::CleanAllGraphs()\n{\n\tunsigned long i;\n\tunsigned long np = 0;\n\tfor (i = 0; i < max_points; i++) if (subsets[i] != NO_SUBSET) {\n\t\tsubsets[i] = 0;\n\t\tnp++;\n\t}\n\tsubset_sizes[0] = np;\n\tsubset_sizes.Update(0);\n\tfor (i = 0; i < how_many_subsets; i++) {\n\t\tsubset_sizes[i] = 0;\n\t\tsubset_sizes.Update(i);\n\t}\n\thow_many_edges = 0;\t\t\t// forget all the edges we might have had\n\tFindSubsetEdges(0);\t\t\t// create initial graph\n}\n\n// initialize all data structures\nCongaLine::CongaLine(long np, long mp, Distance & d, long hms)\n  : ClosestPairs(np, mp, d), dist(d), edges(new CongaEdge[2*mp]),\n    how_many_edges(0), subsets(new CongaSubset[mp]), max_points(mp),\n    scratch(new point[mp])\n{\t\n\tif (edges == 0 || subsets == 0 || scratch == 0)\n\t\terror(\"CongaLine: unable to create arrays\");\n\n\tgInsertions += np;\n\tif (hms == 0) {\t\t\t\t// we get to compute the number of subsets\n\t\thms = 1;\t\t\t\t// we choose max(2, ceiling(log_2 n)).\n\t\tunsigned long n = np;\n\t\twhile (n > 2) {\n\t\t\tn /= 2;\n\t\t\thms++;\n\t\t}\n\t}\n\tif (hms == 1) error(\"CongaLine: must have at least two subsets\");\n\tif (hms > MaxCongaSubsets) error(\"CongaLine: too many subsets requested\");\n\thow_many_subsets = hms;\t\t// remember how many we computed\n\tsubset_sizes.Allocate(hms); // make data struc for finding pairs to merge\n\tunsigned long i;\n\tfor (i = 0; i < np; i++) subsets[i] = 0;\n\tfor (i = np; i < mp; i++) subsets[i] = NO_SUBSET;\n\tCleanAllGraphs();\t\t\t// reset data structure\n}\n\n// get rid of allocated space\nCongaLine::~CongaLine()\n{\n\tdelete edges;\n\tdelete subsets;\n\tdelete scratch;\n}\n\n// scan edges to find closest pair\ndouble CongaLine::operator () (point & a, point & b)\n{\n\tgPairs++;\n\tif (how_many_edges < 1) error(\"CongaLine: no more edges\");\n\tunsigned long best_edge = 0;\n\tfor (unsigned long i = 1; i < how_many_edges; i++)\n\t\tif (edges[i].d < edges[best_edge].d) best_edge = i;\n\ta = edges[best_edge].in;\n\tb = edges[best_edge].out;\n\treturn edges[best_edge].d;\n}\n\n// find an unused subset\n// returns SCRATCH_SUBSET if there aren't any\n// after making subset, caller should call MergeSubsets()\n// to check if result was SCRATCH_SUBSET and if so to do merge\nCongaLine::CongaSubset CongaLine::FindFreeSubset()\n{\n\tCongaSubset S = subset_sizes.MinValue();\n\tif (subset_sizes[S] == 0) return S;\n\treturn SCRATCH_SUBSET;\n}\n\n// compute new conga line for a given subset\n// uses a scratch array to list the points in that subset followed by other pts\n// assumes that all relevant edges have been deleted (so that there's room\n// in the edge array to add the edges in s).\nvoid CongaLine::FindSubsetEdges(CongaSubset s)\n{\n\t// make list of points in s and remaining active points\n\tunsigned long ns = 0;\n\tunsigned long tp = ns;\n\tlong i;\n\tfor (i = 0; i < max_points; i++)\n\t{\n\t\tif (subsets[i] == s) {\t\t\t\t// in S?\n\t\t\tscratch[tp++] = scratch[ns];\t// make room at end of S\n\t\t\tscratch[ns++] = i;\t\t\t\t// ... to add the new point\n\t\t} else if (subsets[i] != NO_SUBSET)\t// active?\n\t\t\tscratch[tp++] = i;\t\t\t\t// just add to end of list\n\t}\n\t\n\t// is there enough room for the new edges we might have?\n\t// max # new edges = min(2ns, tp)-1\n\tunsigned long max_edges = 2*ns - 1;\n\tif (tp - 1 < max_edges) max_edges = tp - 1;\n\tif (how_many_edges + max_edges > 2*max_points) {\n\t\tCleanAllGraphs();\t\t\t\t\t// run out of room, rebuild\n\t\treturn;\n\t}\n\t\n\t// now do Conga line\n\tpoint current = scratch[0];\n\tpoint * p = scratch+1;\n\tns--; tp--;\t\t\t// account for removal of first element\n\tfor (;;) {\n\t\tunsigned long i;\t// find nbr s.t. either current or nbr is in s\n\t\tdouble d;\n\t\tif (subsets[current] == s) {\t// current is in s\n\t\t\tif (tp <= 0) return;\t\t// any points left?  if not, done\n\t\t\ti = NeighborInList(current, p, tp, d);\t// search all points in p\n\t\t} else { \n\t\t\tif (ns <= 0) return;\n\t\t\ti = NeighborInList(current, p, ns, d);\t// not in s, search only in s\n\t\t}\n\t\tAddEdge(current, p[i], d, s);\n\t\tcurrent = p[i];\n\t\tif (i < ns) {\t\t// neighbor is also in same subset?\n\t\t\tp[i] = p[0];\t// yes, splice out of front of list\n\t\t\tp++; ns--; tp--;\n\t\t} else p[i] = p[--tp];\t// else splice out of back of list\n\t}\n}\n\n// find nearest neighbor in a list, subroutine for building conga lines\nunsigned long CongaLine::NeighborInList(point pt, point * ptlist,\n\t\t\t\t\t\t\t\t\t\tunsigned long listlen, double & d)\n{\n\tunsigned long retval = 0;\n\td = dist(pt, ptlist[0]);\n\tfor (unsigned long i = 1; i < listlen; i++) {\n\t\tdouble dd = dist(pt, ptlist[i]);\n\t\tif (dd < d) {\n\t\t\td = dd;\n\t\t\tretval = i;\n\t\t}\n\t}\n\treturn retval;\n}\n\n// code for merging subset B into subset A and recomputing conga lines\n// does *not* call subset_sizes.Update(B)\n// A should not be SCRATCH_SUBSET, but B can be.\nvoid CongaLine::MergeSubsets(CongaSubset A, CongaSubset B)\n{\n\t// merge subset info on points\n\tunsigned long i;\n\tfor (i = 0; i < max_points; i++)\n\t\tif (subsets[i] == B) MoveToSubset(i, A);\n\tsubset_sizes.Update(A);\n\t\n\t// delete all existing edges involving the subsets\n\ti = 0;\n\twhile (i < how_many_edges) {\n\t\tif (edges[i].s == A || edges[i].s == B) RemoveEdge(i);\n\t\telse i++;\n\t}\n\t\n\t// create new edges\n\tFindSubsetEdges(A);\n}\n\n// have a collection of points in S, need to find edges\n// and, if S=SCRATCH_SUBSET, do some merging\nvoid CongaLine::MadeNewSubset(CongaSubset S, unsigned long S_size)\n{\n\tif (S_size == 0) return;\n\tif (S != SCRATCH_SUBSET) {\t// able to find room for it already?\n\t\tFindSubsetEdges(S);\t\t// then just make edges and...\n\t\tsubset_sizes.Update(S);\t// tell merge-finding data struc about new set\n\t\treturn;\t\n\t}\n\n\t// here with S = SCRATCH_SUBSET\n\t// we need to merge something to get num subsets down within bound\n\t// if we can do a merge involving S, do so and avoid FindSubsetEdges(S)\n\tCongaSubset smallest_subset = subset_sizes.MinValue();\n\tif (subset_sizes[smallest_subset] <= 2*S_size) {\n\t\tMergeSubsets(smallest_subset, S);\n\t\treturn;\n\t}\n\t\n\t// here with no good merge available.\n\t// have to merge some other pair, rename vertices in S, then FindSubsetEdges\n\tpoint A, B;\n\tsubset_sizes.MinRatio(A, B);\n\tMergeSubsets(A,B);\t\t\t\t// do the bulk of the merge code\n\n\t// now B is empty, move points into it from S\n\tfor (point i = 0; i < max_points; i++)\n\t\tif (subsets[i] == S) MoveToSubset(i, B);\n\tFindSubsetEdges(B);\n\tsubset_sizes.Update(B);\t\t\t// tell data struc about new set\n}\n\n// Point has changed. Have to treat as if newly inserted.\n// Sigh, this is slow, but it's incorrect just to move p to a new set\n// (because now some edges x->p might have become longer than x->something else)\nvoid CongaLine::UpdatePoint(point p)\n{\n\t(*this) -= p;\n\t(*this) += p;\n\tgInsertions--;\n\tgDeletions--;\n}\n\n// Distance has changed. Move both points to new subset, get rid of old pq edges.\n// Unlike UpdatePoint this is reasonably fast.\n// Note that it's safe to remove all edges p->x and q->x, not just p->q and q->p\nvoid CongaLine::UpdateDistance(point p, point q)\n{\n\tunsigned long i = 0;\n\twhile (i < how_many_edges) {\n\t\tif (edges[i].in == p || edges[i].in == q) RemoveEdge(i);\n\t\telse i++;\n\t}\n\tCongaSubset S = FindFreeSubset();\n\tFixWhat(p);\n\tMoveToSubset(p, S);\n\tFixWhat(q);\n\tMoveToSubset(q, S);\n\tMadeNewSubset(S, 2);\n}\n\n// insert new point\nvoid CongaLine::operator += (point p)\n{\n\tgInsertions++;\n\tif (subsets[p] != NO_SUBSET)\n\t\terror(\"CongaLine: reinsertion of existing point\");\n\tMoveToSubset(p, FindFreeSubset());\n\tMadeNewSubset(subsets[p], 1);\n}\n\n// delete point\nvoid CongaLine::operator -= (point p)\n{\n\tgDeletions++;\n\tif (subsets[p] == NO_SUBSET)\n\t\terror(\"CongaLine: deletion of point not previously inserted\");\n\tFixWhat(p);\n\tMoveToSubset(p, NO_SUBSET);\n\t\n\t// delete edges involving p and send neighbors to new subset\n\tCongaSubset S = FindFreeSubset();\n\tunsigned long S_size = 0;\n\tunsigned long i = 0;\n\twhile (i < how_many_edges) {\n\t\tif (edges[i].out == p) {\n\t\t\tif (subsets[edges[i].in] != S) {\t// if not already moved...\n\t\t\t\tFixWhat(edges[i].in);\n\t\t\t\tMoveToSubset(edges[i].in, S);\n\t\t\t\tS_size++;\n\t\t\t}\n\t\t\tRemoveEdge(i);\n\t\t} else if (edges[i].in == p) RemoveEdge(i);\n\t\telse i++;\n\t}\n\t\n\t// If anything was moved, make new conga line and clean up\n\tMadeNewSubset(S, S_size);\n}", "encoding": "ascii"}