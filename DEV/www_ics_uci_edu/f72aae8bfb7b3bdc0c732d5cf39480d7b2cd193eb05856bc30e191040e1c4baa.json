{"url": "https://www.ics.uci.edu/~dan/bridge/implement.html", "content": "<HTML><HEAD>\n<TITLE>implementation details</TITLE>\n</HEAD><BODY>\n<H2>some implementation details</H2>\n\nTwo cards, X and Y, of the same suit in one hand are\n<I>rank-equivalent</I>\nif none of the other 3 players have any cards in that\nsuit with rank in between those of X and Y.\nDynamic rank equivalence can be implemented by maintaining an\narray of length 52, one cell for each of the cards in the deck,\nwith each cell containing a value from the set {N,E,W,S,none}\nindicating which (if any) of the players holds that card in his hand.\nFor purposes of determining equivalence, it is important\nthat this array is not updated at the time a player plays a card!\nThe array must be updated only at the conclusion of a trick.\n<P>\n<I>Node isomorphism</I> refers to the situation in which\ntwo nodes correspond to identical hand configurations\nwith equal number of tricks taken by N/S.\nNode isomorphism can be implemented by maintaining a list\nof configurations and their associated values,\nindicating which partnership, N/S or E/W, will prevail\nstarting from that configuration.\nWhen encountering a configuration, C, the list is checked\nto determine whether C is listed.\nIf it is, then the value of configuration C\ncan be obtained from the stored value, thereby avoiding the\nnecessity of expanding the entire tree of possibilities.\nIf it is not, then the pair [C,unknown] is entered onto the list\nand, after C has been evaluated (say, to find that N/S will prevail)\nthen this entry is updated (to become [C,N/S]).\n<P>\nFor difficult problems, the number of encountered configurations\ncan be so large that there will not be enough space to store\nall of them.  In that situation, it is effective to store\nthe configurations that will have the most impact in avoiding\ntree expansion.   Also, for speed considerations, it is important\nthat the list be searchable very rapidly.  These various concerns\ncan be addressed efficiently and effectively by using a variant\nof <I>Robin Hood hashing</I>.  For very difficult problems,\nadditional speed enhancements might be possible by use of a\n<I>Bloom filter</I>.\n<P>\nTo obtain the greatest benefit,\nit is best that the hash table have the largest size possible.\nThe size of the table is not the number of bytes stored\nin the table -- it is the maximum number of entries that can\nbe stored in the table.  It is true that increasing the number of bytes\navailable for the table will increase the number of entries.\nBut equally effective, and even more important for speed considerations,\nis the fact that decreasing the number of bytes required for one\nentry will increase the maximum number of entries that can be held\nby a table having capacity of a fixed number of bytes.\n<P>\nI encode a configuration in 8 bytes.\nWhen it is possible that an output tree will be produced,\neach configuration requires an additional 4 bytes.\nAlso, producing an output tree necessitates the use of\na rather large stack, typically allowed 1-2 Megs.\n<P>\nThe stack contains the body of what will ultimately be the tree file.\nThe tree file format is roughly as follows.\nThere is a primary header,\nwhich describes the initial state of the program\n(number of cards per player, who are the \"goodguys\",etc.)\na secondary header,\nwhich describes the contents of the 4 hands,\nand the body, which contains one word that gives the number of\nwords in the rest of the body and then a series of cells\nthat are stored in depth-first search order.\nA cell describes a trick.  It contains:\n<UL> For Versions 1,2:  \n <LI> in one word: the round number, the leader, the winner, the 4 cards\n <LI> if a duplicate position has been reached then the next 2 words\n      contain:  ZERO,  pointer to identical position cell\n</UL>\n<UL> For Versions 3,4:\n <LI> in one word: the round number, the leader, the 4 card equivalents,\n      and indication as to whether a duplicate position has been reached\n <LI> if a duplicate position has been reached then\n      the next word contains:   pointer to identical position cell\n<P>\n<HR>\n<ADDRESS>\nDan Hirschberg<BR>\nComputer Science Department<BR>\nUniversity of California, Irvine, CA 92697-3425<BR>\n</ADDRESS>\n<tt>dan at ics.uci.edu</tt><br>\nLast modified: July 1, 1996\n</BODY></HTML>\n", "encoding": "ascii"}