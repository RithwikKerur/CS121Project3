{"url": "https://www.ics.uci.edu/~pattis/ICS-31/lectures/functionsasdata/functionsasdata.txt", "content": "\t\t\t\tFunctional Programming\r\n\r\n\r\nFunctional programming is a style of programming. Some use the words programming\r\nparadigm. The more standard styles are procedural and object-oriented, which\r\nare part of the imperative paradigm. Functional programs fundamentally evaluate\r\nexpressions; imperative programs fundamentally execute statements. Functional \r\nprogramming uses the simplicity and power of functions to accomplish\r\nprogramming tasks.\r\n\r\nIn a purely functional solution to a problem, there will be no mutation to data\r\nstructures, and special functions calling functions (not looping) will be the\r\nprimary control structure. Primarily this lecture discusses functional\r\nprogramming using three functions: map, filter, and reduce, which each take a\r\nfunction as an argument.\r\n\r\nFunctional languages easily support and frequently use the passing of functions\r\nas arguments to other functions (these other functions are called \"higher-order\"\r\nfunctions or functionals) and functions returning other functions as their\r\nresults. Python allows both.\r\n\r\nThere are programming languqages that are purely function (Haskell), others that\r\nare mostly functional (ML -whose major implementations are SML and OCaml- the\r\nScheme dialect of Lisp, and Erlang), and still others that at least support a\r\nfunctional style of programming (some better, some worse) when it is useful.\r\nPython is in this latter category, although features like comprehensions in\r\nPython emphasize its functional programming aspects (lambdas fall into this\r\ncategory too).\r\n\r\nGenerally, functional programming is characterized as using immutable objects\r\nand no state changes (not even rebinding of names). Strings, tuples and\r\nfrozensets are all immutable in Python, but lists, sets, and dicts are not.\r\n\r\nIn functional programming, we don't change data structures but produce new ones\r\nthat are variants of the old ones. For example, if we want to \"change\" the first\r\nvalue of a tuple t to 1, we cannot: instead we create a new tuple whose first\r\nvalues is 1 and whose other values are the other values in the tuple, using the\r\nconcatenation operator. The new tuple is specified as (1,)+t[1:]; note that we\r\nneed the comma in (1,) to distinguish it from (1): the former is a tuple\r\ncontaining the value 1, the later is an int.\r\n\r\nFunctional programming creates lots of objects and must do so in a time and\r\nspace efficient way, and for the most part, functional languages achieve parity\r\nin time/space efficiency with non-functional programming languages. Although,\r\nmixed language like Python tend not to do as well when used functionally as true\r\nfunctional languages. Emerging languages like Scala and Clojure are closing the\r\ngap. Also, because of the simplicity of the semantics of functional programming,\r\nit is easier to automatically transform functional programs to run efficiently\r\non parallel, cluster, or multi-core computers (see the end of this lecture).\r\n\r\nFunctional programming languages are still not as widely used as imperative\r\nlanguages, but they continue to find many uses in industry, and in some\r\nindustries (telecommunications) they have achieved dominance (at least with\r\nsome companies within the industries). Programmers who are trained to use\r\nfunctional languages think about problems and solve problems differently. All\r\nCS students should be exposed to functional programming as part of their\r\neducation (and I mean an exposure longer than one day).\r\n\r\nTo learn more about Python's use of functional programming, read section 10\r\n(Functional Programming Modules) in Python's Library documentation, discussing\r\nthe itertools, functools, and the operator modules.\r\n\r\n------------------------------------------------------------------------------\r\n\r\nIn this lecture we will look at just three important higher-order functions used\r\nin functional programming: map (transform), filter, and reduce (accumulate).\r\nEach operates on a function and an interable, which means they operate on lists\r\nand tuples easily. We will write versions of these functions, to help explain\r\nwhat they do, although more general and faster versions are already available\r\nin in Python's builtins module. So mostly to study functional programming we\r\nare concerned with studying how to call these functions.\r\n\r\n(1) map/transform: this function takes a unary function and a list and produces\r\n    a same-sized list of mapped/transformed values based on substituting each\r\n    value with the result of calling the parameter function on it. For example,\r\n    calling\r\n\r\n    map( lambda x : x**2, [i for i in irange(0,5)] )\r\n\r\nproduces a list of the squares of the values of the numbers [0, 1, 2, 3, 4, 5],\r\nwhich is [0,1,4,9,16,25].\r\n\r\nNote that lambdas are frequently (but not exclusively) used in calls to the map\r\nfunction. We can use regularly defined functions as well, but often we need only\r\na short function, so lambdas often work out well.\r\n\r\nHere is a simple implementation of the map function. Again, Python's builtin\r\nmap function is more general and faster; I show this one only to help you\r\nundertand what map does.\r\n\r\ndef map(f,alist):\r\n    answer = []\r\n    for v in alist:\t\t# generate each value in alist\r\n       answer.append(f(v))\t# put f(that value) in a list to return\r\n    return answer\r\n    \r\nThe simpler definition below uses a comprehension. The use of map functions in\r\nprogramming preceded the use of comprehensions, which are more powerful. So\r\ncomprehensions make the map function trivial to write.\r\n\r\ndef map(f,alist):\r\n    return [f(v) for v in alist]\r\n    \r\n(2) filter: this function takes a predicate (a unary function returning a bool,\r\nalthough in Python most values have a bool interpretation) and some list of\r\nvalues and produces a list (the same size or smaller) with only those values\r\nfor which the predicate returns True (or a value that is interpreted as True).\r\nFor example, calling\r\n\r\n   filter( predicate.is_prime, [i for i in irange(2,50)] )\r\n\r\nproduces a list of all the values between 2 and 50 that are prime:\r\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47].\r\n\r\nHere is a simple implementation of the filter function. Again, Python's builtin\r\nfilter function is more general and faster; I show this one only to help you\r\nundertand what filter does.\r\n\r\ndef filter(p,alist):\r\n    answer = []\r\n    for v in alist:\r\n       if p(v):\r\n           answer.append(v)\r\n    return answer\r\n\r\nThe simpler definition below uses a comprehension. The use of filter functions\r\nin programming preceded the use of comprehensions, which are more powerful. So\r\ncomprehensions make the filter function trivial to write.\r\n\r\ndef map(p,alist):\r\n    return [v for v in alist if p(v)]\r\n    \r\n(3) reduce/accumulate: this function is different than the previous two: it\r\ntakes a binary function and some list of values and typically produces a single\r\nvalue: it reduces or accumulates these results into a single value. \r\n\r\nUnlike map and filter (which are defined and automatically imported from the\r\nbuiltins module) we must import reduce from the functools module explicitly.\r\n\r\nFor example, calling\r\n\r\n   reduce( lambda x,y : x+y, [i for i in irange(1,100)] )\r\n\r\nreturns the sum of all the values 1 to 100, in the list. Here is a more\r\ninteresting call, because uses a non-commutative operator (subtract).\r\n\r\n   reduce( lambda x,y : x-y, [1,2,3] )\r\n\r\nwhich returns -4: or 1 - 2 - 3 or (1-2)-3. Technically, this is called LEFT\r\nreduction/accumulation because the operators are applied left to right. If\r\nthey had been applied right to left (right reduction), the result would have\r\nbeen 1-(2-3) = 1 - (-1) = 2. For all commutative operators, the association\r\norder doesn't make a difference. That is, (1+2)+3 is the same as 1+(2+3). So\r\nfor 5 values, the reduce is equivalent to (((1+2)+3)+4)+5.\r\n\r\nNote that the operator module defines a variety of functions like add (which\r\nhas the same meaning as lambda x,y: x+y) so we could also call this function\r\nas reduce( operator.add, [i for i in irange(1,100)] ) if we had imported\r\noperators.\r\n\r\nHere is another interesting example\r\n\r\n  reduce( max, [4,2,-3,8,6] )\r\n\r\nwhich is equivalent to max(max(max(max(4,2),-3),8),6) which evaluates as\r\nfollows, to compute the maximum of the entire list of values.\r\n\r\nmax(max(max(max(4,2),-3),8),6) -> max(max(max(4,-3),8),6) ->\r\nmax(max(4,8),6) -> max(8,6) -> 8\r\n\r\nSo, we can easily add up a list or compute its max using functional programming.\r\n\r\nHere is the simplest implementation of reduce that I can think of. None is\r\nreturned for an empty list; otherwise f is applied to all the operands as shown\r\nabove to compute the reduced/accumulated value.\r\n\r\ndef reduce(f,alist)\r\n    if alist == []:\r\n        return None\r\n\r\n    answer = alist[0]\r\n    for v in alist[1::\r\n        answer = f(answer,v)\r\n    return v\r\n\r\nHand simulate this code (or single step the debugger on it) for the examples\r\nabove. reduce(f,[a,b]) returns f(a,b); reduce(f,[a,b,c]) returns f(f(a,b),c); \r\nreduce(f,[a,b,c,d]) returns f(f(f(a,b),c),d); etc.\r\n\r\nHere is a concrete example of a function style of programming. This expression\r\ncomputes the length of the longest line in a file.\r\n\r\nreduce(max, map(lambda l : len(l.rstrip()), [line for line in open('file')]))\r\n\r\nFirst the comprehension puts all the lines in a list; then map creates a list\r\nof lengths for each rstripped line; finally reduce applies max to the values\r\nin the list to compute the maximum length line.\r\n\r\nTo return the longest line itself, not the length of the longest line, we could\r\ncompute as follows. Here the lambda for reduce (whose arguments will be two\r\nlines from the file) returns the longer of the two lines; when reduced over all\r\nlines in the file, the final result is the largest line in the file. The lambda\r\nto map now strips spaces off the right end, but doesn't map lines to their\r\nlengths.\r\n\r\nreduce(lambda x,y: x if len(x) >= len(y) else y,\r\n       map(lambda l : l.rstrip(), [line for line in open('file')]))\r\n\r\nFunctional programmers spend a lot of time using these tools to build up their\r\nidioms of expressions. We are just peeking at this topic now. It is possible\r\nfor reduce to return all type of results, not just simple ones: there are for\r\nexample, wasy to reduce lists of lists to produce just lists.\r\n\r\nFor example, these two lambdas end up computing a tuple whose index 0 in the\r\nsmallest value in a list and whose index 1 is the largest.\r\n\r\nreduce(lambda tupx,tupy: ( min(tupx[0],tupy[0]), max(tupx[1],tupy[1]) )\r\n       map(lambda x : (x,x), [4,2,-3,8,6] )\r\n\r\nThe result returned by calling reduce is (-3,8). Here's how this function works:\r\nThe inner map produces the list [(4,4), (2,2), (-3,-3), (8,8), (6,6)]. The\r\nreduce reduces (4,4) and (2,2) to (2,4); then reduces (2,4) and (-3,-3) to\r\n(-3,4); then reduces (-3,4) and (8,8) to (-3,8); then reduces (-3,8) and (6,6)\r\ntoo (-3,8) which are the minmum/maximum respectively of the original list.\r\n\r\nTwo final truths.\r\n\r\n1) The map, filter, and reduce function work on anything that is iterable\r\n(which list and tuple are, but so are sets, dicts, and even strings). So I can\r\ncall map(lambda x : x.upper(), 'Hello') to produce the list\r\n['H', 'E', 'L', 'L', 'O'].\r\n\r\n2) The map and filter functions built into Python produce an iterable as a\r\nresult (not a real list). So if we call\r\n\r\n print(map(lambda x : x.upper(), 'Hello'))\r\n\r\nPython prints: <map object at 0x02DFFE30>\r\n\r\nWhich just says that the result is a map object, which is iterable. But if we\r\ncall\r\n\r\n  print(list(map(lambda x : x.upper(), 'Hello')))\r\n\r\nthe list constructor takes this iterable and produces a real list of its values\r\nfrom it, so Python prints: ['H', 'E', 'L', 'L', 'O']\r\n\r\n------------------------------------------------------------------------------\r\n\r\nMapReduce, commutative functions, and parallel processing\r\n\r\nMapReduce is a special language implementing the map/reduce functions running on\r\na parallel, cluster, or multi-core computer. If we can write our code within \r\nthe MapReduce language, we can guarantee that it runs quickly on the\r\nkinds of computers Google uses for its servers. Generally what it does is run \r\nsimilar operations on huge amounts of data, combining results, until we get a\r\nsingle answer. Apache Hadoop is open source version of MapReduce (but to really\r\nsee its power, we need a cluster of computer to run our code on).\r\n\r\nHow does MapReduce work? The story is long, but imagine we have a commutative\r\noperator and want to compute: 1 + 2 + 3 + ... + n\r\n\r\nWe can evaluate this expression as shown above, one operator at a time left to\r\nright, which would require n-1 additions one right after the other (the former\r\nmust finish before the later starts). Even if we had multiples cores, doing the\r\noperations in this order would require n-1 sequential additions, one after the\r\nother, so only one core at a time would be active.\r\n\r\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16\r\n|   |   |   |   |\r\n+-+-+   |   |   |\r\n  |     |   |   |\r\n  3     |   |   |\r\n  |     |   |   |\r\n  +--+--+   |   |\r\n     |      |   |\r\n     6      |   |\r\n     |      |   |\r\n     +---+--+   |\r\n         |   \t|\r\n        10   \t|\r\n         |   \t|\r\n         +---+--+\r\n             |\r\n            15\r\n\r\n         .... note that one more operand is used at each level\r\n\r\nHere each level uses 1 core and there are 15 levels. In general, with N numbers\r\nto add it take N-1 time steps.\r\n\r\nNow, how can MapReduce handle this problem?\r\n\r\nInstead, because of commutivity, we can evaluate this expression in a\r\ndifferent way: add the 1st and 2nd values at the same time as we add the 3rd\r\nand 4th at the same time as the 5th and 6th ... In all, we can add n/2 pairs\r\nsimultaneously (if we had n/2 cores). We can use this same trick for the\r\nremaining n/2 sums, simultaneously adding them together; then for the n/4 sums,\r\n..., to the final sum sums (for which only one processor is necessary). Here is\r\na pictorial representation of this process for 16 values.\r\n\r\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16\r\n|   |   |   |   |   |   |   |   |   |     |   |     |   |     |   | \r\n+-+-+   +-+-+   +-+-+   +-+-+   +-+-+     +-+-+     +-+-+     +-+-+    8 cores\r\n  |       |       |       |       |         |         |         |\r\n  3       7      11      15      19        23        27        31\r\n  |       |       |       |       |         |         |         |\r\n  +---+---+       +---+---+       +----+----+         +----+----+      4 cores \r\n      |               |                |                   |\r\n     10              26               42                  58\r\n      |               |                |                   |\r\n      +-------+-------+                +---------+---------+           2 cores\r\n              |                                  |\r\n             36                                 100\r\n              |                                  |\r\n              +----------------+-----------------+\t\t       1 core\r\n                               |\r\n                              136\r\n\r\nHere each level uses as many cores as possible there are 4 levels. In general,\r\nwith N numbers to add it takes Log2 N times steps. Recall that Log2 1,000 is\r\n10, Log2 1,000,000 is 20, and Log2 1,000,000,000 = 30. To perform 10**9\r\nadditions in 30 time steps,  we'd need a half billion cores: not likely this is\r\ncoming in your lifetime. But if we had tens-or-hundreds of cores, we could keep\r\nthem all busy except for the last few (bottom) levels. So we could get our code\r\nto run tens-or-hundreds of times faster.\r\n\r\n", "encoding": "ascii"}