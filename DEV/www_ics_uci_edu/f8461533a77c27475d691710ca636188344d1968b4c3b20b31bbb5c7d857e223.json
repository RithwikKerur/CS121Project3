{"url": "https://www.ics.uci.edu/~thornton/ics32/Notes/InputsAndSounds/", "content": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE html PUBLIC\r\n \"-//W3C//DTD XHTML 1.1//EN\"\r\n \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n\r\n<head>\r\n<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\" />\r\n<link rel=\"stylesheet\" href=\"../../course.css\" type=\"text/css\" />\r\n\r\n<title>ICS 32 Winter 2019, Notes and Examples: Inputs and Sounds</title>\r\n\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"navbar\">\r\n\r\n<p>\r\nICS 32 Winter 2019 |\r\n<a href=\"../../index.html\">News</a> |\r\n<a href=\"../../CourseReference.html\">Course Reference</a> |\r\n<a href=\"../../Schedule.html\">Schedule</a> |\r\n<a href=\"../../ProjectGuide\">Project Guide</a> |\r\n<a href=\"../../Notes\">Notes and Examples</a> |\r\n<a href=\"http://www.ics.uci.edu/~thornton/\">About Alex</a>\r\n</p>\r\n\r\n<hr />\r\n\r\n</div>\r\n\r\n<div class=\"header\">\r\n\r\n<p>ICS 32 Winter 2019<br />\r\n   Notes and Examples: Inputs and Sounds</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">PyGame inputs and outputs</p>\r\n\r\n<p>In the <a href=\"../PyGameSpots\">Spots example</a>, we wrote a PyGame-based game that had one kind of input and one kind of output.  It used input events from the mouse (notably, clicks of the primary mouse button) and drew graphics in a window for its output.  But those aren't the only kinds of inputs and outputs that PyGame can handle.</p>\r\n\r\n<p>On the input side of the ledger, PyGame can detect not only the mouse button, but also fine-grained mouse movements, joystick/gamepad interactions, and can also provide a fairly detailed status of every key on the keyboard.</p>\r\n\r\n<p>From an output perspective, PyGame is not limited only to drawing graphics, as we've seen.  It can also load and manipulate images from files, then display them.  It can play sounds and music.  It can also alter the mouse cursor so that it appears different from the usual defaults.</p>\r\n\r\n<p>Which of these features you need is a function of the game you're building, of course, but it's handy to have all of these things at your disposal when you need them.  Like most libraries, the cost for using these features is understanding how you ask the library to handle them for you.  This example takes you through a few of these that might be of use to you in <a href=\"../../ProjectGuide/Project5\">Project #5</a>.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">A little background inspiration</p>\r\n\r\n<p>As a young kid, I played a lot of games on one of the first popular home video game consoles, the venerable <a href=\"https://en.wikipedia.org/wiki/Atari_2600\">Atari 2600</a>.  One of my favorite games in those days was simply called <a href=\"https://en.wikipedia.org/wiki/Adventure_(Atari_2600)\">Adventure</a>, in which your player could roam around a small world consisting of locked castles (and a key to open each one), mazes, and a few other tools (a sword, a magnet, and a bridge).  The world was populated also by dragons (whose main goal was to eat you, but which you could kill with the sword) and a bat, which would steal items from you and fly away with them.  The game's goal was simple: Find a glowing chalice and return it to the gold castle, where you began the game.  To get an idea of what the game looked and sounded like, take a look at this example of someone playing through the simplest of its three levels.</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://www.youtube.com/watch?v=I6-zN_eaRd8\">Atari 2600 - Adventure</a></li>\r\n</ul>\r\n\r\n<p>Of course, this game comes from the dawn of the video game revolution, first released in 1980.  Games have come far enough that Adventure seems trite and silly nowadays, but I found myself completely fascinated by it when I played it as a kid; I simply hadn't seen anything quite like it before, so it captivated me.</p>\r\n\r\n<p>And those simple games still have a lot to teach us about fun, about playability, and also about developing quality software.  In this example, we'll use Adventure as our inspiration and use it to explore alternative forms of input and output in PyGame.</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Keyboard inputs</p>\r\n\r\n<p>There are two different ways to read keyboard input in PyGame, mainly because there are two different ways that you might be interested in finding out about it.</p>\r\n\r\n<ul>\r\n  <li>A separate event that fires every time each key on the keyboard is pressed and every time each key on the keyboard is released.  In other words, events separately describe <i>changes to the state of each key</i>.</li>\r\n  <li>A way to find out, in bulk, the current state of every key on the keyboard.</li>\r\n</ul>\r\n\r\n<p>As it turns out, the latter of these is something you could do yourself if all you had was the former, but it would require that you keep track of the current state of each key &mdash; noting whenever it went down and then came back up again.  But because it's so convenient to be able to ask \"Which of the arrow keys is down right now?\", PyGame provides both mechanisms separately.</p>\r\n\r\n<p>How you know which of these mechanisms is right for you depends on what you'll want to know.</p>\r\n\r\n<ul>\r\n  <li>If it's a change in a key's state that would cause you to take action (i.e., if someone presses the <b>Q</b> key, then you'll do something once, even if they hold that key down), then the event-based mechanism is going to be the right one to use.</li>\r\n  <li>If the state of a key causes a sequence of actions (i.e., holding down a key causes something to happen repeatedly, once per frame), then the state-of-every-key mechanism is going to be the right one to use.</li>\r\n</ul>\r\n\r\n<p>The keys themselves are described by constants that are defined in the <b>pygame</b> module.  Each key on the keyboard has such a constant.  Examples include <b>pygame.K_a</b> for the 'A' key, <b>pygame.K_MINUS</b> for the '-' key, <b>pygame.RIGHT</b> for the right arrow key, and <b>pygame.RETURN</b> for the Enter/Return key (different keyboards will call this \"Enter\" or \"Return\", but PyGame combines them together).  You can find a full list of these constants in the <b>pygame.key</b> documentation.</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://www.pygame.org/docs/ref/key.html\"><b>pygame.key</b> documentation</a></li>\r\n</ul>\r\n\r\n<p class=\"subtitle\">Events when the state of one key changes</p>\r\n\r\n<p>When the state of a key changes, you can find out by checking the sequence of events you get back from <b>pygame.event.get()</b>.  For every key that has been pressed since the last time you called <b>pygame.event.get()</b>, you'll receive a <b>pygame.KEYDOWN</b> event whose <b>key</b> attribute specifies what key it was.  For every key that has been released, you'll receive a <b>pygame.KEYUP</b> event, which will also have a <b>key</b> attribute similarly.  In each case, the <b>key</b> attribute will be one of the constants described earlier.  For example, if we want to know if someone has pressed the left arrow key, we could check this way.</p>\r\n\r\n<blockquote><pre>\r\nfor event in pygame.event.get():\r\n    ...\r\n    elif event.type == pygame.KEYDOWN:\r\n        if event.key == pygame.K_LEFT:\r\n            ...\r\n</pre></blockquote>\r\n\r\n<p class=\"subtitle\">Getting the state of all keys simultaneously</p>\r\n\r\n<p>If, instead, we want to check the state of all keys, this is something we can do separately from our usual call to <b>pygame.event.get()</b>.  Rather than being told when things change, we can simply interrogate the current state of all keys on every frame, then react accordingly.  The <b>pygame.key.get_pressed()</b> function returns an object that is effectively a dictionary that maps keys to boolean values that represent the state of each key &mdash; True being pressed down, False being released.  We can then separately look at the state of each key we're interested in.</p>\r\n\r\n<blockquote><pre>\r\nkeys = pygame.key.get_pressed()\r\n\r\nif keys[pygame.K_LEFT]:\r\n    ...\r\n\r\nif keys[pygame.K_RIGHT]:\r\n    ...\r\n\r\nif keys[pygame.K_UP]:\r\n    ...\r\n\r\nif keys[pygame.K_DOWN]:\r\n    ...\r\n</pre></blockquote>\r\n\r\n<p>Note that we'll tend to use a sequence of <b>if</b> statements here, rather than a single <b>if</b>/<b>elif</b>/<b>elif</b>, because we usually use this mechanism because we might want to take action on multiple different keys being held down in the same frame.  We can only do that if we check each key separately (i.e., just because the left arrow key is pressed doesn't mean we aren't interested in whether the up arrow key is also pressed).</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Loading and manipulating images</p>\r\n\r\n<p>We've previously seen that you can use the <b>pygame.draw</b> module to draw various shapes on PyGame's surfaces.  If what you want is to draw rectangles, ellipses, lines, and so on, then <b>pygame.draw</b> is perfect for your needs.  However, games are a lot more visually appealing when they can display finer-grained images, rather than just simply, clunky shapes.  Fortunately, PyGame can load and manipulate <i>images</i> in a variety of well-known formats, such as JPG, PNG, GIF, and BMP, then draw them on a surface.</p>\r\n\r\n<p class=\"subtitle\">Loading an image</p>\r\n\r\n<p>The <b>pygame.image</b> module contains tools for loading and manipulating images in various well-known formats.  The <b>pygame.image.load()</b> function allows you to load an image from a file; you tell it where the file is, it will load the image and give you back a surface containing that image's pixels.  (Note that a surface in PyGame is just a rectangular area containing pixels; what makes those pixels visible is that you draw them on PyGame's display surface.)</p>\r\n\r\n<blockquote><pre>\r\npeke_image = pygame.image.load('gray_peke.png')\r\n</pre></blockquote>\r\n\r\n<p>Of course, the file has to exist, and it has to actually be in a recognizable image format (one that PyGame knows how to process).</li>\r\n\r\n<p class=\"subtitle\">Blitting</p>\r\n\r\n<p>When it comes time to make our image visible on another surface, such as PyGame's display surface, we need to <i>blit</i> it on to that surface.  The term \"blit\" is a very old shorthand for what was once called a \"block transfer\" or a \"bit block transfer,\" which is literally the copying of a large number of bits from one place to another.  When we want an image to be visible on a surface, that's exactly what we want: Take the bits that describe that image and place them into the appropriate location on the surface.</p>\r\n\r\n<p>So, generally, what we need to specify are two things:</p>\r\n\r\n<ol>\r\n  <li>What image do we want to appear on the surface?</li>\r\n  <li>Where on that surface do we want the image to appear?</li>\r\n</ol>\r\n\r\n<p>The <b>pygame.Surface</b> class has a method called <b>blit()</b> that can do this.  You pass it two arguments: the image and a two-element tuple specifying the (pixel) x- and y-coordinates of the top-left corner of the image.  PyGame does the rest.  So, for example, if we had a surface called <b>some_surface</b> and an image called <b>peke_image</b>, this would place the image on the surface, where the top-left of the image was at the pixel coordinate (200, 250).</p>\r\n\r\n<blockquote><pre>\r\nsome_surface.blit(peke_image, (200, 250))\r\n</pre></blockquote>\r\n\r\n<p>The image covers whatever used to be in the pixels.  There are also ways to make it blend with what's already there, if you prefer.  Lots more information is available in PyGame's documentation.</p>\r\n\r\n<p class=\"subtitle\">Scaling an image</p>\r\n\r\n<p>One kind of image manipulation that PyGame supports is the ability to <i>scale</i> it, which proportionally alters its size, while generally preserving its visual characteristics.  Of course, if you scale something small enough, it will begin to lose those characteristics; similarly, if you scale something large enough, it will start to look blurry, because there wasn't enough detail in the original to convey the larger picture you're trying to create.  Nonetheless, PyGame can do a pretty decent job of scaling an image to a different size, while keeping it looking relatively decent.</p>\r\n\r\n<p>For example, below are two images.  One is a simple drawing of a Pekingese; the other is the same drawing, but scaled to be smaller (about one-quarter the width and one-quarter the height).</p>\r\n\r\n<p class=\"center\"><img src=\"gray_peke.png\" alt=\"Pekingese, larger\" />   <img src=\"gray_peke_small.png\" alt=\"Pekingese, scaled to be smaller\" /></p>\r\n\r\n<p>If you look at the images carefully, you'll see that the small one has the characteristics of the larger one &mdash; the shadows around the ear and tail, the darker area below the nose, and so on &mdash; even though those details are now proportionally smaller.</p>\r\n\r\n<p>PyGame is capable of performing this kind of scaling whenever you need it.  Because this can be a somewhat time-intensive operation, it's not the kind of thing you'll necessarily want to do a lot of (e.g., you won't want to do this on a large number of images in every frame of your animation), but you also will find that you won't often need to do a lot of it.  For example, if we use the Pekingese above as our \"player\" in our Adventure game, instead of a single-colored rectangle, we'll only need to scale the image when its size is different than it was in the previous frame, which only happens twice:</p>\r\n\r\n<ul>\r\n  <li>When we first start our game, we'll load the image.  The first time we draw a frame, we'll need to scale the image to whatever is appropriate for the size of our display.</li>\r\n  <li>Whenever the size of the display is changed, we'll need to re-scale the image to the new appropriate size.</li>\r\n</ul>\r\n\r\n<p>If, in between, we simply store the scaled image, we can blit it on to every one of our frames without re-scaling it, which can save a significant amount of processing time.  This can have an effect on the battery life of the device running our game, as well as whether or not our game can even play at the speed we want (e.g., if we do enough scaling, we won't be able to finish all of it to keep up with our game's frame rate).</p>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">Playing sounds via PyGame's mixer</p>\r\n\r\n<p>Of course, games are a lot more engaging when they play sounds, so PyGame provides a facility to do those that.  Playing sounds is done via PyGame's <i>mixer</i>.  A mixer is what it sounds like: It mixes together multiple sound waves, by combining them into a single one.  Operating systems generally include sound mixers, as well, which is why you can be watching a video in a web browser that generates one sound, while listening to music emanating from iTunes at the same time; what you hear is the combination of both sounds, mixed together by your operating system's mixer.  PyGame includes a <b>pygame.mixer</b> module, which allows you to mix multiple sounds together in your game.</p>\r\n\r\n<p>The <b>pygame.mixer</b> module provides a fair amount of functionality, so it's actually somewhat complex.  It's organized around the concept of <i>channels</i>, with each of those channels being capable of playing a single sound at a time.  Depending on the complexity of your sound-generating needs &mdash; how many sounds you might need to generate, or how often you might have multiple simultaneous sounds being played &mdash; you may need to manage how many channels there are, find open channels when you need to play a sound, or even be notified via events when channels become available.</p>\r\n\r\n<p>We'll start by keeping things fairly simple, though; we'll just generate one sound at a time.  For this, we need to be able to do two things.</p>\r\n\r\n<ul>\r\n  <li>First, we need a sound to play.  PyGame represents these as objects of a class called <b>pygame.mixer.Sound</b>.  We know, generally, that sounds can be represented as <i>waves</i>, so our goal is to load a description of those waves into the <b>Sound</b> object.  The simplest way to do that is to have a file that contains those waveforms in an uncompressed form called WAV, such as this sound of a <a href=\"dogbark.wav\">small dog barking</a>.  Loading a sound from a file is as simple as creating a <b>pygame.mixer.Sound</b> object and passing a path to the file containing that sound as an argument to its constructor.\r\n<blockquote><pre>\r\nbark_sound = pygame.mixer.Sound('dogbark.wav')\r\n</pre></blockquote>\r\n  Of course, the file has to exist, and it has to actually be in a recognizable format (i.e., it has to be a sound).</li>\r\n  <li>Next, when it comes time to play our sound, we need to run it through the mixer.  There are a lot of complexities that can be encountered if the number of sounds that might be played is large, because the mixer can only play a sound if it has an open channel in which to play it.  While you have control over how many channels there are, which channels you're using at any given time, and so on, the simplest thing to do is to just ask the sound to play.  When you do that, the mixer finds an open channel (if there is one) and plays the sound; if there isn't an open channel, it will stop playing some other sound and start playing this one instead.  (If you need to control things more carefully, then you'll need to get fancier.)  You can do this by calling the <b>play()</b> method on the <b>Sound</b> object.\r\n<blockquote><pre>\r\nbark_sound.play()\r\n</pre></blockquote>\r\n  </li>\r\n</ul>\r\n\r\n<p>Lots more documentation on the <b>pygame.mixer</b> module is available here, if you want to see what kinds of tools are available for managing all of this.</p>\r\n\r\n<ul>\r\n  <li><a href=\"https://www.pygame.org/docs/ref/mixer.html\"><b>pygame.mixer</b> documentation</a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n<div class=\"section\">\r\n\r\n<hr />\r\n\r\n<p class=\"title\">The code</p>\r\n\r\n<p>Below are two versions of the code that we wrote in lecture.  The first is the beginnings of an implementation of the Adventure game from the Atari 2600 &mdash; with a single-color, rectangular-shaped \"player\" that we can move around, which, when it exits the screen on one side, wraps around to the opposite side.</p>\r\n\r\n<ul>\r\n  <li><a href=\"adventure_game.py\"><b>adventure_game.py</b></a></li>\r\n  <li><a href=\"adventure.py\"><b>adventure.py</b></a></li>\r\n</ul>\r\n\r\n<p>In the second version, we augmented this with a couple of additional assets: one image that we used so that our player wouldn't just be a single-colored rectangle, and one sound that we played whenever the user pressed the Enter (or Return) key.</p>\r\n\r\n<ul>\r\n  <li><a href=\"adventure_game2.py\"><b>adventure_game2.py</b></a></li>\r\n  <li><a href=\"adventure.py\"><b>adventure.py</b></a></li>\r\n  <li><a href=\"gray_peke.png\"><b>gray_peke.png</b></a></li>\r\n  <li><a href=\"dogbark.wav\"><b>dogbark.wav</b></a></li>\r\n</ul>\r\n\r\n</div>\r\n\r\n</body>\r\n</html>\r\n", "encoding": "ascii"}