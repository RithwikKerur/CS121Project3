{"url": "https://www.ics.uci.edu/~ejw/authoring/protocol/draft-ietf-webdav-protocol-06.txt", "content": "\nWEBDAV Working Group                            Y.Y. Goland, Microsoft\nINTERNET DRAFT                          E.J. Whitehead, Jr., UC Irvine\n<draft-ietf-webdav-protocol-06>                     A. Faizi, Netscape\n                                                   S.R. Carter, Novell\n                                                     D. Jensen, Novell\nExpires July, 1998                                    January 18, 1998\n\n\n  Extensions for Distributed Authoring on the World Wide Web -- WEBDAV\n\n\nStatus of this Memo\n\n   This document is an Internet-Draft. Internet-Drafts are working\n   documents of the Internet Engineering Task Force (IETF), its areas,\n   and its working groups. Note that other groups may also distribute\n   working documents as Internet-Drafts.\n\n   Internet-Drafts are draft documents valid for a maximum of six\n   months and may be updated, replaced, or made obsolete by other\n   documents at any time. It is inappropriate to use Internet-Drafts as\n   reference material or to cite them other than as \"work in progress\".\n\n   To learn the current status of any Internet-Draft, please check the\n   \"1id-abstracts.txt\" listing contained in the Internet-Drafts Shadow\n   Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),\n   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or\n   ftp.isi.edu (US West Coast).\n\n   Distribution of this document is unlimited. Please send comments to\n   the Distributed Authoring and Versioning (WEBDAV) working group at\n   <w3c-dist-auth@w3.org>, which may be joined by sending a message\n   with subject \"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\n   Discussions of the WEBDAV working group are archived at\n   <URL:http://www.w3.org/pub/WWW/Archives/Public/w3c-dist-auth>.\n\nAbstract\n\n   This document specifies a set of methods, headers, and content-types\n   ancillary to HTTP/1.1 for the management of resource properties,\n   creation and management of resource collections, namespace\n   manipulation, and resource locking (collision avoidance).\n\nChanges\n\nChanges since draft-ietf-webdav-protocol-06.txt\n\n   [Editor's note: This section will not appear in the final form of\n   this document.  Its purpose is to provide a concise list of changes\n   from the previous revision of the draft for use by reviewers.]\n\n   Rationale for many of the changes made in this revision of the draft\n   can be found in the mailing list archives at:\n\n\nGoland et al.                                                 [Page 1]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   http://lists.w3.org/Archives/Public/w3c-dist-auth/1997OctDec/0160.ht\n   ml.\n\n   Where the 200 OK status code was used to indicate a successful\n   response without a response entity body, 204 No Content is now used.\n   Because PEP uses 420 and 421 status codes, and since PEP has been\n   submitted as an Experimental RFC, the WebDAV 420 status code has\n   been changed to 422, and the WebDAV 421 status code has been changed\n   to 423.\n\n   The 423 Destination Locked status code has been changed to 423\n   Locked, and now covers all cases where an operand was locked,\n   preventing the execution of the method.\n\n   Removed the Destroy header, since it is not needed in this draft,\n   but will be needed in the versioning draft.\n\n   The Enforce-Live-Properties header was renamed to Property-Behavior,\n   to more closely represent the meaning of the header now that the\n   \"omit\" functionality is included. A keepalive field was added to the\n   Property-Behavior header to make it more meaningful.\n\n   Removed the INDEX method, since the functionality of INDEX can now\n   be performed by the PROPFIND method.  PROPFIND provides more\n   flexibility in specifying the type and amount of property\n   information returned than does INDEX, which is important for\n   returning information on a large number of resources.\n\n   Clarified that performing a MOVE as a COPY, then DELETE, performed\n   atomically, only applies to non-collection resources.\n\n   Clarified the semantics of errors that are encountered in infinite\n   depth move and copy of a hierarchy of resources.  For errors copying\n   internal nodes of the hierarchy tree (i.e., collections), the\n   operation skips that subtree, and moves on to the next subtree.  If\n   an error is encountered moving/copying a leaf of the tree, then skip\n   that resource, and move on to the next leaf.\n\n   Removed the PATCH method.  This will be resubmitted as the document\n   draft-ietf-webdav-patch-00.\n\n   Added language that states that if a PROPPATCH is invoked on a null\n   resource (e.g., a deleted resource), an empty resource is created,\n   and the PROPPATCH directives are performed on this new resource.\n\n   Added a forward reference to the source link definition (Section\n   13.11) in Section 4.4.\n\n   Changed all Values= to Values:.  Also changed all \"values\" to\n   \"value\".\n\n\n\nGoland et al.                                                 [Page 2]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   References to state tokens are now restricted to sections 9.7 and\n   9.8.\n\n   The property-behavior header has been turned into the\n   propertybehavior XML element because it contained a list of URIs\n   which can thus have unbounded size.  The lock-info header has been\n   turned into the lockinfo XML element for the same reason.  I have\n   also made the same change of the Propfind header into the Propfind\n   XML element.  We can put the property behavior header into the body\n   because neither COPY nor MOVE have bodies. However we can't put\n   lock-token, if-state-match, etc. in the body because they may need\n   to be used with PUT. However I don't consider this a big deal\n   because I sincerely doubt that there will be cases where lock-token\n   or if-state-match will see large numbers of entries.\n\n   Also changed omit to mean \"copy properties with best effort but\n   failure is acceptable.\"\n\n   Added the external members property.\n\n   Added language to 6.4 making it clear that any new resources created\n   as the child of a write locked collection is added to the lock.\n\n   Made the lock-token response header from a single URL to multiple\n   URLs.  But all the URLs MUST refer to the exact same lock.\n\n   <?XML version=\"1.0\"> changed to the correct form: <?xml\n   version=\"1.0\"?>\n\n   Changed the delete rule for collections to read that if a delete in\n   a collection member fails then it is the ancestors, not the progeny,\n   who can not be deleted in order to maintain the namespace.\n\n   Updated our reference to the XML spec.\n\n   Added LOCK and UNLOCK to the list of methods covered by the write\n   lock. This is necessary so that a lock-token will have to be\n   submitted in order to make changes, otherwise we defeat the whole\n   purpose of requiring the lock-token.\n\n   Changed the title of section 6.6 from Re-Issuing Write Locks to\n   Refreshing Write Locks, made it illegal to make the same lock\n   request twice (you know you are making the same request because you\n   had to include the lock-token to make it!) and instead made it legal\n   to submit a LOCK method with no body but with a lock-token header.\n   I also added a refresh example.\n\n   Put in a note that an empty request body for PROPFIND means to\n   return all names and values of properties on the resources.\n\n\n\n\nGoland et al.                                                 [Page 3]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   I have added a section on XML processing errors. I know, I know, it\n   shouldn't be in the standard. I will move it to our compliance draft\n   as soon as we prepare the first version.\n\n   Removed addlocks and replaced with the depth header and the depth\n   element.\n\n   Changed all the as in namespace elements to all lower case.\n\n   Moved all XML element declarations to the same section.  Removed the\n   parent description.\n\n   Updated the depth section to make it more generic, changed the\n   wording for how COPY/MOVE are handled with write locks, require that\n   ALL propfind responses include href, require that if a property is\n   not found in a propfind then a 404 Not Found must be returned, and\n   made explicit that PROPFIND responses on resources with internal\n   members are returned as a flat list with no significance to its\n   ordering.\n\n   Removed reference to efficient update in the introduction since\n   PATCH is now gone.\n\n   Rewrote the write lock and null resource section to deal with the\n   question of the state of the resource when it is locked and null.\n\n   Changed www.ietf.org to www.iana.org.\n\n   Changed the response element and added the new propstat element.\n   With the prohibition that an HREF can only appear once in a\n   multistatus response we can guarantee linear processing costs.\n\n   Added Intellectual Property section, as required by RFC 2026.\n\n   Added IANA Considerations section.\n\n   Added Authorization headers to LOCK and UNLOCK examples.\n\n   Changed lock tokens in examples to use string format of UUID.\n\n   Since the latest HTTP revision defines a 418 and 419 status code,\n   the 418 status code has been changed to 422, 419 to 423, 422 to 424,\n   and 423 to 425.\n\n   Changed implementation of the get* (e.g., getcontentlength)\n   properties to strength MUST.\n\n   Changed definition of XML elements and DAV properties to use XML\n   element definitions, rather than BNF.\n\n   Renumbered all sections\n\n\nGoland et al.                                                 [Page 4]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\nContents\n\nSTATUS OF THIS MEMO..................................................1\nABSTRACT.............................................................1\nCHANGES..............................................................1\nChanges since draft-ietf-webdav-protocol-06.txt......................1\nCONTENTS.............................................................5\n1 INTRODUCTION.......................................................9\n2 DATA MODEL FOR RESOURCE PROPERTIES................................10\n2.1  The Resource Property Model....................................10\n2.2  Existing Metadata Proposals....................................10\n2.3  Properties and HTTP Headers....................................11\n2.4  Property Values................................................11\n2.5  Property Names.................................................12\n3 COLLECTIONS OF WEB RESOURCES......................................12\n3.1  Collection Resources...........................................12\n3.2  Creation and Retrieval of Collection Resources.................13\n3.3  HTTP URL Namespace Model.......................................13\n3.4  Source Resources and Output Resources..........................14\n4 LOCKING...........................................................15\n4.1  Exclusive Vs. Shared Locks.....................................15\n4.2  Required Support...............................................16\n4.3  Lock Tokens....................................................16\n4.4  opaquelocktoken Lock Token URI Scheme..........................17\n4.5  Lock Capability Discovery......................................17\n4.6  Active Lock Discovery..........................................18\n5 WRITE LOCK........................................................18\n5.1  Methods Restricted by Write Locks..............................18\n5.2  Write Locks and Properties.....................................18\n5.3  Write Locks and Null Resources.................................18\n5.4  Write Locks and Collections....................................19\n5.5  Write Locks and COPY/MOVE......................................19\n5.6  Refreshing Write Locks.........................................19\n5.7  Write Locks and The Lock-Token Request Header..................20\n 5.7.1   Write Lock Token Example...................................20\n6 NOTATIONAL CONVENTIONS............................................21\n7 HTTP METHODS FOR DISTRIBUTED AUTHORING............................21\n7.1  PROPFIND.......................................................21\n 7.1.1   Example: Retrieving Named Properties.......................22\n 7.1.2   Example: Using allprop to Retrieve All Properties..........23\n 7.1.3   Example: Using propname to Retrieve all Property Names.....26\n7.2  PROPPATCH......................................................28\n 7.2.1   Status Codes...............................................28\n 7.2.2   Example....................................................28\n7.3  MKCOL Method...................................................30\n 7.3.1   Request....................................................30\n\nGoland et al.                                                 [Page 5]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n 7.3.2   Response Codes.............................................30\n 7.3.3   Example....................................................31\n7.4  ADDREF Method..................................................31\n 7.4.1   The Request................................................31\n 7.4.2   Example....................................................31\n7.5  DELREF Method..................................................32\n 7.5.1   The Request................................................32\n 7.5.2   Example....................................................32\n7.6  GET, HEAD for Collections......................................32\n7.7  POST for Collections...........................................33\n7.8  DELETE.........................................................33\n 7.8.1   DELETE for Non-Collection Resources........................33\n 7.8.2   DELETE for Collections.....................................33\n7.9  PUT............................................................34\n 7.9.1   PUT for Non-Collection Resources...........................34\n 7.9.2   PUT for Collections........................................35\n7.10 COPY Method....................................................35\n 7.10.1  COPY for HTTP/1.1 resources................................35\n 7.10.2  COPY for Properties........................................35\n 7.10.3  COPY for Collections.......................................36\n 7.10.4  Type Interactions..........................................37\n 7.10.5  Status Codes...............................................37\n 7.10.6  Overwrite Example..........................................38\n 7.10.7  No Overwrite Example.......................................38\n 7.10.8  Collection Example.........................................38\n7.11 MOVE Method....................................................39\n 7.11.1  MOVE for Collections.......................................40\n 7.11.2  Status Codes...............................................40\n 7.11.3  Non-Collection Example.....................................41\n 7.11.4  Collection Example.........................................41\n7.12 LOCK Method....................................................42\n 7.12.1  Operation..................................................43\n 7.12.2  The Effect of Locks on Properties and Collections..........43\n 7.12.3  Locking Replicated Resources...............................43\n 7.12.4  Depth and Locking..........................................43\n 7.12.5  Interaction with other Methods.............................44\n 7.12.6  Lock Compatibility Table...................................44\n 7.12.7  Lock Response..............................................44\n 7.12.8  Status Codes...............................................44\n 7.12.9  Example - Simple Lock Request..............................45\n 7.12.10  Example - Refreshing a Write Lock.........................46\n 7.12.11  Example - Multi-Resource Lock Request.....................47\n7.13 UNLOCK Method..................................................48\n 7.13.1  Example....................................................48\n8 HTTP HEADERS FOR DISTRIBUTED AUTHORING............................49\n\n\nGoland et al.                                                 [Page 6]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n8.1  Collection-Member Header.......................................49\n8.2  DAV Header.....................................................49\n8.3  Depth Header...................................................49\n8.4  Destination Header.............................................50\n8.5  If-None-State-Match............................................50\n8.6  If-State-Match.................................................51\n8.7  Lock-Token Request Header......................................51\n8.8  Lock-Token Response Header.....................................52\n8.9  Overwrite Header...............................................53\n8.10 Status-URI Response Header.....................................53\n8.11 Timeout Header.................................................53\n9 STATUS CODE EXTENSIONS TO HTTP/1.1................................54\n9.1  102 Processing.................................................54\n9.2  207 Multi-Status...............................................55\n9.3  422 Unprocessable Entity.......................................55\n9.4  423 Insufficient Space on Resource.............................55\n9.5  424 Method Failure.............................................55\n9.6  425 Locked.....................................................55\n10  MULTI-STATUS RESPONSE...........................................55\n11  XML ELEMENT DEFINITIONS.........................................55\n11.1 activelock XML Element.........................................56\n 11.1.1  depth XML Element..........................................56\n 11.1.2  locktoken XML Element......................................56\n 11.1.3  timeout XML Element........................................56\n11.2 collection XML Element.........................................56\n11.3 href XML Element...............................................56\n11.4 link XML Element...............................................57\n 11.4.1  dst XML Element............................................57\n 11.4.2  src XML Element............................................57\n11.5 lockentry XML Element..........................................57\n11.6 lockinfo XML Element...........................................57\n11.7 lockscope XML Element..........................................58\n 11.7.1  exclusive XML Element......................................58\n 11.7.2  shared XML Element.........................................58\n11.8 locktype XML Element...........................................58\n 11.8.1  write XML Element..........................................58\n11.9 multistatus XML Element........................................58\n 11.9.1  response XML Element.......................................59\n 11.9.2  responsedescription XML Element............................59\n11.10 owner XML Element.............................................60\n11.11 prop XML element..............................................60\n11.12 propertybehavior XML element..................................60\n 11.12.1  keepalive XML element.....................................60\n 11.12.2  omit XML element..........................................61\n11.13 propertyupdate XML element....................................61\n\n\nGoland et al.                                                 [Page 7]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n 11.13.1  remove XML element........................................61\n 11.13.2  set XML element...........................................62\n11.14 propfind XML Element..........................................62\n 11.14.1  allprop XML Element.......................................62\n 11.14.2  propname XML Element......................................62\n12  DAV PROPERTIES..................................................62\n12.1 creationdate Property..........................................63\n12.2 displayname Property...........................................63\n12.3 externalmembers Property.......................................63\n12.4 getcontentlanguage Property....................................63\n12.5 getcontentlength Property......................................64\n12.6 getcontenttype Property........................................64\n12.7 getetag Property...............................................64\n12.8 getlastmodified Property.......................................64\n12.9 lockdiscovery Property.........................................65\n 12.9.1  Example....................................................65\n12.10 resourcetype Property.........................................66\n12.11 source Property...............................................66\n 12.11.1  Example...................................................67\n12.12 supportedlock Property........................................67\n 12.12.1  Example...................................................68\n13  DAV COMPLIANCE CLASSES..........................................68\n13.1 Class 1........................................................69\n13.2 Class 2........................................................69\n14  INTERNATIONALIZATION CONSIDERATIONS.............................69\n15  SECURITY CONSIDERATIONS.........................................70\n15.1 Authentication of Clients......................................71\n15.2 Denial of Service..............................................71\n15.3 Security through Obscurity.....................................72\n15.4 Privacy Issues Connected to Locks..............................72\n15.5 Privacy Issues Connected to Properties.........................72\n15.6 Reduction of Security due to Source Link.......................72\n16  IANA CONSIDERATIONS.............................................73\n17  TERMINOLOGY.....................................................73\n18  COPYRIGHT.......................................................74\n19  INTELLECTUAL PROPERTY...........................................74\n20  ACKNOWLEDGEMENTS................................................75\n21  REFERENCES......................................................76\n22  AUTHORS' ADDRESSES..............................................78\n23  APPENDICES......................................................79\n23.1 Appendix 1 - WebDAV Document Type Definition...................79\n23.2 Appendix 2 - ISO 8601 Date and Time Profile....................80\n23.3 Appendix 3 - Notes on Processing XML Elements..................81\n 23.3.1  XML Syntax Error Example...................................81\n 23.3.2  Unknown XML Element Example................................81\n\n\nGoland et al.                                                 [Page 8]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n1  Introduction\n\n   This document describes an extension to the HTTP/1.1 protocol that\n   allows clients to perform remote web content authoring operations.\n   This extension provides a coherent set of methods, headers, request\n   entity body formats, and response entity body formats that provide\n   operations for:\n\n   Properties: The ability to create, remove, and query information\n   about Web pages, such as their authors, creation dates, etc. Also,\n   the ability to link pages of any media type to related pages.\n\n   Collections: The ability to create sets of related documents, and to\n   receive a listing of pages at a particular hierarchy level (like a\n   directory listing in a file system).\n\n   Locking: The ability to keep more than one person from working on a\n   document at the same time. This prevents the \"lost update problem,\"\n   in which modifications are lost as first one author, then another\n   writes changes without merging the other author's changes\n\n   Namespace Operations: The ability to copy and move Web resources\n\n   Requirements and rationale for these operations are described in a\n   companion document, \"Requirements for a Distributed Authoring and\n   Versioning Protocol for the World Wide Web\" [Slein et al., 1997].\n\n   The sections below provide a detailed introduction to resource\n   properties (Section 2), collections of resources (Section 3), and\n   locking operations (Section 4).  These sections introduce the\n   abstractions manipulated by the WebDAV-specific HTTP methods\n   described in Section 7, \"HTTP Methods for Distributed Authoring\".\n\n   In HTTP/1.1, method parameter information was exclusively encoded in\n   HTTP headers. Unlike HTTP/1.1, WebDAV, encodes method parameter\n   information either in an Extensible Markup Language (XML) [Bray,\n   Paoli, Sperberg-McQueen, 1998] request entity body, or in an HTTP\n   header.  The use of XML to encode method parameters was motivated by\n   the ability to add extra XML elements to existing structures,\n   providing extensibility, and by XML's ability to encode information\n   in ISO 10646 character sets, providing internationalization support.\n   As a rule of thumb, parameters are encoded in XML entity bodies when\n   they have unbounded length, or when they may be shown to a human\n   user and hence require encoding in an ISO 10646 character set.\n   Otherwise, parameters are encoded within HTTP headers.  Section 8\n   describes the new HTTP headers used with WebDAV methods.\n\n   In addition to encoding method parameters, XML is used in WebDAV to\n   encode the responses from methods, providing the extensibility and\n   internationalization advantages of XML for method output, as well as\n\n\n\nGoland et al.                                                 [Page 9]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   input. XML elements used in this specification are defined in\n   Section 11.\n\n   While the status codes provided by HTTP/1.1 are sufficient to\n   describe most error conditions encountered by WebDAV methods, there\n   are some errors that do not fall neatly into the existing\n   categories.  New status codes developed for the WebDAV methods are\n   defined in Section 9.  Since some WebDAV methods may operate over\n   many resources, the Multi-Status status type has been introduced to\n   return status information for multiple resources.  Multi-Status\n   response is described in Section 10.\n\n   WebDAV employs the property mechanism to store information about the\n   current state of the resource.  For example, when a lock is taken\n   out on a resource, a lock information property describes the current\n   state of the lock. Section 12 defines the properties used within the\n   WebDAV specification.\n\n   Finishing off the specification are sections on what it means to be\n   compliant with this specification (Section 13), on\n   internationalization support (Section 14), and on security (Section\n   15).\n\n\n2  Data Model for Resource Properties\n\n2.1 The Resource Property Model\n\n   Properties are pieces of data that describe the state of a resource.\n   Properties are data about data.\n\n   Properties are used in distributed authoring environments to provide\n   for efficient discovery and management of resources.  For example, a\n   'subject' property might allow for the indexing of all resources by\n   their subject, and an 'author' property might allow for the\n   discovery of what authors have written which documents.\n\n   The DAV property model consists of name/value pairs.  The name of a\n   property identifies the property's syntax and semantics, and\n   provides an address by which to refer to that syntax and semantics.\n\n   There are two categories of properties: \"live\" and \"dead\".  A live\n   property has its syntax and semantics enforced by the server. Live\n   properties include cases where a) the value of a property is read-\n   only, maintained by the server, and b) the value of the property is\n   maintained by the client, but the server performs syntax checking on\n   submitted values. A dead property has its syntax and semantics\n   enforced by the client; the server merely records the value of the\n   property verbatim.\n\n2.2 Existing Metadata Proposals\n\n\nGoland et al.                                                [Page 10]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Properties have long played an essential role in the maintenance of\n   large document repositories, and many current proposals contain some\n   notion of a property, or discuss web metadata more generally.  These\n   include PICS [Miller et al., 1996], PICS-NG, XML [Bray, Paoli,\n   Sperberg-McQueen, 1998], Web Collections, and several proposals on\n   representing relationships within HTML. Work on PICS-NG and Web\n   Collections has been subsumed by the Resource Definition Framework\n   (RDF) metadata activity of the World Wide Web Consortium. RDF\n   consists of a network-based data model and an XML representation of\n   that model.\n\n   Some proposals come from a digital library perspective.  These\n   include the Dublin Core [Weibel et al., 1995] metadata set and the\n   Warwick Framework [Lagoze, 1996], a container architecture for\n   different metadata schemas.  The literature includes many examples\n   of metadata, including MARC [MARC, 1994], a bibliographic metadata\n   format, and RFC 1807 [Lasher, Cohen, 1995], a technical report\n   bibliographic format employed by the Dienst system. Additionally,\n   the proceedings from the first IEEE Metadata conference describe\n   many community-specific metadata sets.\n\n   Participants of the 1996 Metadata II Workshop in Warwick, UK\n   [Lagoze, 1996], noted that \"new metadata sets will develop as the\n   networked infrastructure matures\" and \"different communities will\n   propose, design, and be responsible for different types of\n   metadata.\" These observations can be corroborated by noting that\n   many community-specific sets of metadata already exist, and there is\n   significant motivation for the development of new forms of metadata\n   as many communities increasingly make their data available in\n   digital form, requiring a metadata format to assist data location\n   and cataloging.\n\n2.3 Properties and HTTP Headers\n\n   Properties already exist, in a limited sense, in HTTP message\n   headers.  However, in distributed authoring environments a\n   relatively large number of properties are needed to describe the\n   state of a resource, and setting/returning them all through HTTP\n   headers is inefficient.  Thus a mechanism is needed which allows a\n   principal to identify a set of properties in which the principal is\n   interested and to set or retrieve just those properties.\n\n2.4 Property Values\n\n   The value of a property is expressed as a well-formed XML document.\n\n   XML has been chosen because it is a flexible, self-describing,\n   structured data format that supports rich schema definitions, and\n   because of its support for multiple character sets.  XML's self-\n   describing nature allows any property's value to be extended by\n   adding new elements.  Older clients will not break when they\n   encounter extensions because they will still have the data specified\n\nGoland et al.                                                [Page 11]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   in the original schema and will ignore elements they do not\n   understand.  XML's support for multiple character sets allows any\n   human-readable property to be encoded and read in a character set\n   familiar to the user.\n\n2.5 Property Names\n\n   A property name is a universally unique identifier that is\n   associated with a schema that provides information about the syntax\n   and semantics of the property.\n\n   Because a property's name is universally unique, clients can depend\n   upon consistent behavior for a particular property across multiple\n   resources, so long as that property is \"live\" on the resources in\n   question.\n\n   The XML namespace mechanism, which is based on URIs, is used to name\n   properties because it prevents namespace collisions and provides for\n   varying degrees of administrative control.\n\n   The property namespace is flat; that is, no hierarchy of properties\n   is explicitly recognized.  Thus, if a property A and a property A/B\n   exist on a resource, there is no recognition of any relationship\n   between the two properties.  It is expected that a separate\n   specification will eventually be produced which will address issues\n   relating to hierarchical properties.\n\n   Finally, it is not possible to define the same property twice on a\n   single resource, as this would cause a collision in the resource's\n   property namespace.\n\n\n3  Collections of Web Resources\n\n   This section provides a description of a new type of Web resource,\n   the collection, and discusses its interactions with the HTTP Uniform\n   Resource Locator (URL) namespace. The purpose of a collection\n   resource is to model collection-like objects (e.g., filesystem\n   directories) within a server's namespace.\n\n   All DAV compliant resources MUST support the HTTP URL namespace\n   model specified herein.\n\n3.1 Collection Resources\n\n   A collection is a resource whose state consists of an unordered list\n   of internal members, an unordered list of external members, and a\n   set of properties.  An internal member resource MUST have a URI that\n   is immediately relative to the base URI of the collection.  That is,\n   the internal member's URI is equal to the parent collection's URI\n   plus an additional segment where segment is defined in Section 3.2.1\n   of RFC 2068 [Fielding et al., 1996].\n\nGoland et al.                                                [Page 12]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   An external member resource is a resource that could not be an\n   internal member resource. Any given internal or external Member MUST\n   only belong to the collection once, i.e., it is illegal to have\n   multiple instances of the same URI in a collection.  Properties\n   defined on collections behave exactly as do properties on non-\n   collection resources.\n\n   There is a standing convention that when a collection is referred to\n   by its name without a trailing slash, the trailing slash is\n   automatically appended.  Due to this, a resource MAY accept a URI\n   without a trailing \"/\" to point to a collection. In this case it\n   SHOULD return a location header in the response pointing to the URL\n   ending with the \"/\".  For example, if a client invokes a method on\n   http://foo.bar/blah (no trailing slash), the resource\n   http://foo.bar/blah/ (trailing slash) MAY respond as if the\n   operation were invoked on it, and SHOULD return a location header\n   with http://foo.bar/blah/ in it.  In general clients SHOULD use the\n   \"/\" form of collection names.\n\n3.2 Creation and Retrieval of Collection Resources\n\n   This document specifies the MKCOL method to create new collection\n   resources, rather than using the existing HTTP/1.1 PUT or POST\n   method, for the following reasons\n\n   In HTTP/1.1, the PUT method is defined to store the request body at\n   the location specified by the Request-URI.  While a description\n   format for a collection can readily be constructed for use with PUT,\n   the implications of sending such a description to the server are\n   undesirable.  For example, if a description of a collection that\n   omitted some existing resources were PUT to a server, this might be\n   interpreted as a command to remove those members.  This would extend\n   PUT to perform DELETE functionality, which is undesirable since it\n   changes the semantics of PUT, and makes it difficult to control\n   DELETE functionality with an access control scheme based on methods.\n\n   While the POST method is sufficiently open-ended that a \"create a\n   collection\" POST command could be constructed, this is undesirable\n   because it would be difficult to separate access control for\n   collection creation from other uses of POST.\n\n   The exact definition of the behavior of GET and PUT on collections\n   is defined later in this document.\n\n3.3 HTTP URL Namespace Model\n\n   The HTTP URL Namespace is a hierarchical namespace where the\n   hierarchy is delimited with the \"/\" character.  DAV compliant\n   resources MUST maintain the consistency of the HTTP URL namespace.\n   Any attempt to create a resource (excepting the root member of a\n   namespace) that would not be the internal member of a collection\n\nGoland et al.                                                [Page 13]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   MUST fail. For example, if the collection http://www.foo.bar.org/a/\n   exists, but http://www.foo.bar.org/a/b/does not exist, an attempt to\n   create http://www.foo.bar.org/a/b/c must fail.\n\n3.4 Source Resources and Output Resources\n\n   For many resources, the entity returned by a GET method exactly\n   matches the persistent state of the resource, for example, a GIF\n   file stored on a disk.  For this simple case, the URL at which a\n   resource is accessed is identical to the URL at which the source\n   (the persistent state) of the resource is accessed.  This is also\n   the case for HTML source files that are not processed by the server\n   prior to transmission.\n\n   However, the server can sometimes process HTML resources before they\n   are transmitted as a return entity body.  For example, server-side-\n   include directives within an HTML file instruct a server to replace\n   the directive with another value, such as the current date.  In this\n   case, what is returned by GET (HTML plus date) differs from the\n   persistent state of the resource (HTML plus directive).  Typically\n   there is no way to access the HTML resource containing the\n   unprocessed directive.\n\n   Sometimes the entity returned by GET is the output of a data-\n   producing process that is described by one or more source resources\n   (that may not even have a location in the URL namespace).  A single\n   data-producing process may dynamically generate the state of a\n   potentially large number of output resources.  An example of this is\n   a CGI script that describes a \"finger\" gateway process that maps\n   part of the namespace of a server into finger requests, such as\n   http://www.foo.bar.org/finger_gateway/user@host.\n\n   In the absence of distributed authoring capabilities, it is\n   acceptable to have no mapping of source resource(s) to the URI\n   namespace. In fact, preventing access to the source resource(s) has\n   desirable security benefits.  However, if remote editing of the\n   source resource(s) is desired, the source resource(s) should be\n   given a location in the URI namespace.  This source location should\n   not be one of the locations at which the generated output is\n   retrievable, since in general it is impossible for the server to\n   differentiate requests for source resources from requests for\n   process output resources.  There is often a many-to-many\n   relationship between source resources and output resources.\n\n   On WebDAV compliant servers, for all output resources which have a\n   single source resource (and that source resource has a URI), the URI\n   of the source resource SHOULD be stored in a link on the output\n   resource with type http://www.iana.org/standards/dav/source (see\n   Section 12.11 for a description of the source link).  Note that by\n   storing the source URIs in links on the output resources, the burden\n   of discovering the source is placed on the authoring client.\n\n\nGoland et al.                                                [Page 14]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n4  Locking\n\n   The ability to lock a resource provides a mechanism for serializing\n   access to that resource.  Using a lock, an authoring client can\n   provide a reasonable guarantee that another principal will not\n   modify a resource while it is being edited.  In this way, a client\n   can prevent the \"lost update\" problem.\n\n   This specification allows locks to vary over two client-specified\n   parameters, the number of principals involved (exclusive vs. shared)\n   and the type of access to be granted. This document defines locking\n   for only one access type, write. However, the syntax is extensible,\n   and permits the eventual specification of locking for other access\n   types.\n\n4.1 Exclusive Vs. Shared Locks\n\n   The most basic form of lock is an exclusive lock.  This is a lock\n   where the access right in question is only granted to a single\n   principal.  The need for this arbitration results from a desire to\n   avoid having to constantly merge results.\n\n   However, there are times when the goal of a lock is not to exclude\n   others from exercising an access right but rather to provide a\n   mechanism for principals to indicate that they intend to exercise\n   their access right.  Shared locks are provided for this case.  A\n   shared lock allows multiple principals to receive a lock.  Hence any\n   principal with appropriate access can get the lock.\n\n   With shared locks there are two trust sets that affect a resource.\n   The first trust set is created by access permissions.  Principals\n   who are trusted, for example, may have permission to write the\n   resource.  Those who are not, don't.  Among those who have access\n   permission to write the resource, the set of principals who have\n   taken out a shared lock also must trust each other, creating a\n   (typically) smaller trust set within the access permission write\n   set.\n\n   Starting with every possible principal on the Internet, in most\n   situations the vast majority of these principals will not have write\n   access to a given resource.  Of the small number who do have write\n   access, some principals may decide to guarantee their edits are free\n   from overwrite conflicts by using exclusive write locks.  Others may\n   decide they trust their collaborators will not overwrite their work\n   (the potential set of collaborators being the set of principals who\n   have write permission) and use a shared lock, which informs their\n   collaborators that a principal may be working on the resource.\n\n   The WebDAV extensions to HTTP do not need to provide all of the\n   communications paths necessary for principals to coordinate their\n   activities.  When using shared locks, principals may use any out of\n\nGoland et al.                                                [Page 15]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   band communication channel to coordinate their work (e.g., face-to-\n   face interaction, written notes, post-it notes on the screen,\n   telephone conversation, Email, etc.)  The intent of a shared lock is\n   to let collaborators know who else may be working on a resource.\n\n   Shared locks are included because experience from web distributed\n   authoring systems has indicated that exclusive write locks are often\n   too rigid.  An exclusive write lock is used to enforce a particular\n   editing process: take out exclusive write lock, read the resource,\n   perform edits, write the resource, release the lock.  This editing\n   process has the problem that locks are not always properly released,\n   for example when a program crashes, or when a lock owner leaves\n   without unlocking a resource.  While both timeouts and\n   administrative action can be used to remove an offending lock,\n   neither mechanism may be available when needed; the timeout may be\n   long or the administrator may not be available.\n\n   Despite their potential problems, exclusive write locks are\n   extremely useful, since often a guarantee of freedom from overwrite\n   conflicts is what is needed. This specification provides both\n   exclusive write locks and the less strict mechanism of shared locks.\n\n4.2 Required Support\n\n   A WebDAV compliant server is not required to support locking in any\n   form.  If the server does support locking it MAY choose to support\n   any combination of exclusive and shared locks for any access types.\n\n   The reason for this flexibility is that locking policy strikes to\n   the very heart of the resource management and versioning systems\n   employed by various storage repositories.  These repositories\n   require control over what sort of locking will be made available.\n   For example, some repositories only support shared write locks while\n   others only provide support for exclusive write locks while yet\n   others use no locking at all.  As each system is sufficiently\n   different to merit exclusion of certain locking features, this\n   specification leaves locking as the sole axis of negotiation within\n   WebDAV.\n\n4.3 Lock Tokens\n\n   A lock token is a URI that identifies a particular lock.  A lock\n   token is returned by every successful LOCK operation in the Lock-\n   Token response header, and can also be discovered through lock\n   discovery on a resource.\n\n   Lock token URIs are required to be unique across all resources for\n   all time. This uniqueness constraint allows lock tokens to be\n   submitted across resources and servers without fear of confusion.\n\n   This specification provides a lock token URI scheme called\n   opaquelocktoken that meets the uniqueness requirements.  However\n\nGoland et al.                                                [Page 16]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   resources are free to return any URI scheme so long as it meets the\n   uniqueness requirements.\n\n4.4 opaquelocktoken Lock Token URI Scheme\n\n   The opaquelocktoken URI scheme is designed to be unique across all\n   resources for all time.  Due to this uniqueness quality, a client\n   MAY submit an opaque lock token in a Lock-Token request header and\n   an If-[None]-State-Match header on a resource other than the one\n   that returned it.\n\n   All resources MUST recognize the opaquelocktoken scheme and, at\n   minimum, recognize that the lock token was not generated by the\n   resource.  Note, however, that resources are not required to\n   generate opaquelocktokens in LOCK method responses.\n\n   In order to guarantee uniqueness across all resources for all time\n   the opaquelocktoken requires the use of the Universally Unique\n   Identifier (UUID, also known as a Globally Unique Identifier, or\n   GUID) mechanism, as described in [Leach, Salz, 1998].\n\n   Opaquelocktoken generators, however, have a choice of how they\n   create these tokens.  They can either generate a new UUID for every\n   lock token they create, which is potentially very expensive, or they\n   can create a single UUID and then add extension characters.  If the\n   second method is selected then the program generating the extensions\n   MUST guarantee that the same extension will never be used twice with\n   the associated UUID.\n\n   OpaqueLockToken-URI = \"opaquelocktoken:\" UUID [Extension]  ; The\n   UUID production is the string form of a UUID, as defined in [Leach,\n   Salz, 1998]. Note that white space (LWS) is not allowed between\n   elements of this production.\n\n   Extension = path  ; path is defined in Section 3.2.1 of RFC 2068\n   [Fielding et al., 1996]\n\n4.5 Lock Capability Discovery\n\n   Since server lock support is optional, a client trying to lock a\n   resource on a server can either try the lock and hope for the best,\n   or perform some form of discovery to determine what lock\n   capabilities the server supports.  This is known as lock capability\n   discovery.  Lock capability discovery differs from discovery of\n   supported access control types, since there may be access control\n   types without corresponding lock types.  A client can determine what\n   lock types the server supports by retrieving the supportedlock\n   property.\n\n   Any DAV compliant resource that supports the LOCK method MUST\n   support the supportedlock property.\n\n\nGoland et al.                                                [Page 17]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n4.6 Active Lock Discovery\n\n   If another principal locks a resource that a principal wishes to\n   access, it is useful for the second principal to be able to find out\n   who the first principal is.  For this purpose the lockdiscovery\n   property is provided.  This property lists all outstanding locks,\n   describes their type, and provides their lock token.\n\n   Any DAV compliant resource that supports the LOCK method MUST\n   support the lockdiscovery property.\n\n\n5  Write Lock\n\n   This section describes the semantics specific to the write access\n   type for locks.  The write lock is a specific instance of a lock\n   type, and is the only lock type described in this specification.  A\n   DAV compliant resource MAY support the write lock.\n\n5.1 Methods Restricted by Write Locks\n\n   A write lock prevents a principal without the lock from successfully\n   executing a PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, DELETE, MKCOL,\n   ADDREF or DELREF on the locked resource.  All other current methods,\n   GET in particular, function independent of the lock.\n\n   Note, however, that as new methods are created it will be necessary\n   to specify how they interact with a write lock.\n\n5.2 Write Locks and Properties\n\n   While those without a write lock may not alter a property on a\n   resource it is still possible for the values of live properties to\n   change, even while locked, due to the requirements of their schemas.\n   Only dead properties and live properties defined to respect locks\n   are guaranteed not to change while write locked.\n\n5.3 Write Locks and Null Resources\n\n   It is possible to assert a write lock on a null resource in order to\n   lock the name.  A write locked null resource acts in all ways as a\n   null resource other than it MUST respond to a PROPFIND request and\n   MUST support the lockdiscovery and supportedlock properties.\n\n   Until a method such as PUT or MKCOL is executed, the resource stays\n   in the null state with the exception of the behavior stated above.\n\n   If the resource is unlocked without a PUT, MKCOL, or similar method\n   having been executed, the resource is no longer required to support\n   the PROPFIND method or the lockdiscovery and supportedlock\n   properties.\n\n\nGoland et al.                                                [Page 18]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n5.4 Write Locks and Collections\n\n   A write lock on a collection prevents the addition or removal of\n   members of the collection by non-lock owners.  As a consequence,\n   when a principal issues a request to create a new internal member of\n   a write locked collection using PUT or POST, or to remove an\n   existing internal member of a write locked collection using DELETE,\n   this request MUST fail if the principal does not have a write lock\n   on the collection.\n\n   However, if a write lock request is issued to a collection\n   containing internal member resources that are currently locked in a\n   manner which conflicts with the write lock, the request MUST fail\n   with a 425 Locked status code.\n\n   If a lock owner causes a resource to be added as an internal member\n   of a locked collection then the new resource is automatically added\n   to the lock.  This is the only mechanism that allows a resource to\n\n   be added to a write lock.  Thus, for example, if the collection\n   /a/b/ is write locked and the resource /c is moved to /a/b/c then\n   /a/b/c will be added to the write lock.\n\n5.5 Write Locks and COPY/MOVE\n\n   A COPY method invocation MUST NOT duplicate any write locks active\n   on the source.  However, as previously noted, if the COPY copies the\n   resource into a collection that is depth locked then the resource\n   will be added to the lock.\n\n   A MOVE does not move the write lock with the resource. There are two\n   exceptions to this rule. First, as noted in section 5.4, if the MOVE\n   makes the resource a child of a collection that is depth locked then\n   the resource will be under the same lock. Second, if a depth locked\n   resource is moved to a destination that is within the scope of the\n   same depth lock (e.g., within the namespace tree covered by the\n   lock), the moved resource is still a member of the lock. In both\n   cases a Lock-Token header MUST be submitted containing a lock token\n   for the lock on the source, if locked, and on the destination.\n\n5.6 Refreshing Write Locks\n\n   A client MUST NOT submit the same write lock request twice.  Note\n   that a client is always aware it is resubmitting the same lock\n   request because it must include the Lock-Token header in order to\n   make the request for a resource that is already locked.\n\n   However, a client MAY submit a LOCK method with a Lock-Token header\n   but without a body.  This form of LOCK MAY only be used to \"refresh\"\n   a lock.  Currently, refreshing a lock only means that any timers\n   associated with the lock are re-set.\n\n\n\nGoland et al.                                                [Page 19]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   A server MAY return a Timeout header with a lock refresh that is\n   different than the Timeout header returned when the lock was\n   originally requested.  Additionally clients MAY submit Timeout\n   headers of arbitrary value with their lock refresh requests.\n   Servers, as always, MAY ignore Timeout headers submitted by the\n   client.\n\n   If an error is received in response to a refresh LOCK request the\n   client MUST assume that the lock was not refreshed.\n\n5.7 Write Locks and The Lock-Token Request Header\n\n   If a user agent is not required to have knowledge about a lock when\n   requesting an operation on a locked resource, the following scenario\n   might occur.  Program A, run by User A, takes out a write lock on a\n   resource.  Program B, also run by User A, has no knowledge of the\n   lock taken out by Program A, yet performs a PUT to the locked\n   resource.  In this scenario, the PUT succeeds because locks are\n   associated with a principal, not a program, and thus program B,\n   because it is acting with principal A's credential, is allowed to\n   perform the PUT.  However, had program B known about the lock, it\n   would not have overwritten the resource, preferring instead to\n   present a dialog box describing the conflict to the user.  Due to\n   this scenario, a mechanism is needed to prevent different programs\n   from accidentally ignoring locks taken out by other programs with\n   the same authorization.\n\n   In order to prevent these collisions the Lock-Token request header,\n   defined in Section 8.7, is introduced.\n\n5.7.1     Write Lock Token Example\n\n   >>Request\n\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n   Lock-Token: <opaquelocktoken:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>\n   Authorization: Digest username=\"fielding\",\n      realm=\"fielding@ics.uci.edu\", nonce=\"...\",\n      uri=\"/~fielding/index.html\", response=\"...\",\n      opaque=\"...\"\n\n   >>Response\n\n   HTTP/1.1 204 No Content\n\n\n   In this example, even though both the source and destination are\n   locked, only one lock token must be submitted, for the lock on the\n   destination.  This is due to the source resource not being modified\n   during a COPY, and hence unaffected by the write lock. The\n\nGoland et al.                                                [Page 20]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Authorization header provides the Digest authentication credentials\n   for the principal making the request (note that the nonce, response,\n   and opaque fields have not been calculated for this example). The\n   source and the destination resources are both located within the\n   same authentication realm, therefore only one set of Authorization\n   credentials needs to be submitted.\n\n\n6  Notational Conventions\n\n   Since this document describes a set of extensions to the HTTP/1.1\n   protocol, the augmented BNF used herein to describe protocol\n   elements is exactly the same as described in Section 2.1 of\n   [Fielding et al., 1997].  Since this augmented BNF uses the basic\n   production rules provided in Section 2.2 of [Fielding et al., 1997],\n   these rules apply to this document as well.\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119 [Bradner,\n   1997].\n\n\n7  HTTP Methods for Distributed Authoring\n\n7.1 PROPFIND\n\n   The PROPFIND method retrieves properties defined on the Request-URI,\n   if the resource does not have any internal members, or on the\n   Request-URI and potentially its member resources, if the resource\n   does have internal members.  All DAV compliant resources MUST\n   support the PROPFIND method.\n\n   A client MAY submit a Depth header with a value of \"0\", \"1\", or\n   \"infinity\" with a PROPFIND on a resource with internal members.  DAV\n   compliant servers MUST support the \"0\", \"1\" and \"infinity\"\n   behaviors. By default, the PROPFIND method without a Depth header\n   MUST act as if a \"Depth: infinity\" header was included.\n\n   A client MAY submit a propfind XML element in the body of the\n   request method describing what information is being requested.  It\n   is possible to request particular property values, all property\n   values, or a list of the names of the resource's properties.  A\n   client MAY choose not to submit a request body.  An empty request\n   body MUST be treated as a request for the names and values of all\n   properties.\n\n   The response is a text/xml message body that contains a multistatus\n   XML element that describes the results of the attempts to retrieve\n   the various properties.  If a property was successfully retrieved\n   then its value MUST be returned in a prop XML element.\n\n\nGoland et al.                                                [Page 21]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   If there is an error retrieving a property then a proper error\n   result must be included.  Requests to retrieve the value of a\n   property which does not exist is an error and MUST be noted with a\n   response XML element which contains a 404 Not Found status value.\n\n   Consequently, the multistatus XML element for a resource with\n   members MUST include a response XML element for each member of the\n   resource, to whatever depth was requested. Each response XML element\n   MUST contain an href XML element that identifies the resource on\n   which the properties in the prop XML element are defined.  Results\n   for a PROPFIND on a resource with internal members are returned as a\n   flat list whose order of entries is not significant.\n\n   In the case of allprop and propname, if a principal does not have\n   the right to know if a particular property exists then a 404 Not\n   Found MUST be returned.\n\n   The results of this method SHOULD NOT be cached.\n\n7.1.1     Example: Retrieving Named Properties\n\n   >>Request\n\n   PROPFIND  /files/ HTTP/1.1\n   Host: www.foo.bar\n   Depth: 0\n   Content-type: text/xml\n   Content-Length: xyz\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:propfind>\n     <D:href>http://www.foo.bar/boxschema/bigbox</D:href>\n     <D:href>http://www.foo.bar/boxschema/author</D:href>\n     <D:href>http://www.foo.bar/boxschema/DingALing</D:href>\n     <D:href>http://www.foo.bar/boxschema/Random</D:href>\n   </D:propfind>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.foo.bar/boxschema\" as=\"R\"?>\n   <D:multistatus>\n     <D:response>\n          <D:href>http://www.foo.bar/files/</D:href>\n          <D:propstat>\n               <D:prop>\n\nGoland et al.                                                [Page 22]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n                    <R:bigbox>\n                         <R:BoxType>Box type A</R:BoxType>\n                    </R:bigbox>\n                    <R:author>\n                         <R:Name>J.J. Johnson</R:Name>\n                    </R:author>\n               </D:prop>\n               <D:status>HTTP/1.1 200 OK</D:status>\n          </D:propstat>\n          <D:propstat>\n               <D:prop><R:DingALing/><R:Random/></D:prop>\n               <D:status>HTTP/1.1 403 Forbidden</D:status>\n               <D:responsedescription> The user does not have access to\n   the DingALing property.\n               </D:responsedescription>\n          </D:propstat>\n     </D:response>\n     <D:responsedescription> There has been an access violation error.\n     </D:responsedescription>\n   </D:multistatus>\n\n   In this example, PROPFIND is executed on the collection\n   http://www.foo.bar/files/.  The specified depth is zero, hence the\n   PROPFIND applies only to the collection itself, and not to any of\n   its members.  The propfind XML element specifies the name of four\n   properties whose values are being requested. In this case only two\n   properties were returned, since the principal issuing the request\n   did not have sufficient access rights to see the third and fourth\n   properties.\n\n7.1.2     Example: Using allprop to Retrieve All Properties\n\n   >>Request\n\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Depth: 1\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:propfind>\n     <D:allprop/>\n   </D:propfind>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n\nGoland et al.                                                [Page 23]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"S\"?>\n   <?namespace href=\"http://www.foo.bar/boxschema/\" as=\"R\"?>\n   <S:multistatus>\n     <S:response>\n          <S:href>http://www.foo.bar/container/</S:href>\n          <S:propstat>\n               <S:prop>\n                    <R:bigbox>\n                         <R:BoxType>Box type A</R:BoxType>\n                    </R:bigbox>\n                    <R:author>\n                         <R:Name>Hadrian</R:Name>\n                    </R:author>\n                   <S:creationdate>\n                     1997-12-01T17:42:21-08:00\n                   </S:creationdate>\n                   <S:displayname>\n                     Example collection\n                   </S:displayname>\n                   <S:externalmembers>\n                     <S:href>http://www.acme.com/front/</S:href>\n                   </S:externalmembers>\n                   <S:resourcetype><S:collection/></S:resourcetype>\n                   <S:supportedlock>\n                     <S:lockentry>\n                       <S:exclusive/><S:write/>\n                     </S:lockentry>\n                     <S:lockentry>\n                       <S:shared/><S:write/>\n                     </S:lockentry>\n                   </S:supportedlock>\n               </S:prop>\n               <S:status>HTTP 1.1 200 OK</S:status>\n          </S:propstat>\n     </S:response>\n     <S:response>\n          <S:href>http://www.foo.bar/container/front.html</S:href>\n          <S:propstat>\n               <S:prop>\n                    <R:bigbox>\n                         <R:BoxType>Box type B</R:BoxType>\n                    </R:bigbox>\n                   <S:creationdate>\n                     1997-12-01T18:27:21-08:00\n                   </S:creationdate>\n                   <S:displayname>\n                     Example HTML resource\n                   </S:displayname>\n                   <S:getcontentlength>\n                     4525\n                   </S:getcontentlength>\n\nGoland et al.                                                [Page 24]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n                   <S:getcontenttype>\n                     text/html\n                   </S:getcontenttype>\n                   <S:getetag>\n                     zzyzx\n                      </S:getetag>\n                   <S:getlastmodified>\n                     Monday, 12-Jan-98 09:25:56 GMT\n                   </S:getlastmodified>\n                   <S:resourcetype/>\n                   <S:supportedlock>\n                     <S:lockentry>\n                       <S:exclusive/><S:write/>\n                     </S:lockentry>\n                     <S:lockentry>\n                       <S:shared/><S:write/>\n                     </S:lockentry>\n                   </S:supportedlock>\n               </S:prop>\n               <S:status>HTTP 1.1 200 OK</S:status>\n          </S:propstat>\n     </S:response>\n   </S:multistatus>\n\n   In this example, PROPFIND was invoked on the resource\n   http://www.foo.bar/container/ with a Depth header of 1, meaning the\n   request applies to the resource and its children, and a propfind XML\n   element containing the allprop XML element, meaning the request\n   should return the name and value of all properties defined on each\n   resource.\n\n   The resource http://www.foo.bar/container/ has seven properties\n   defined on it, named http://www.foo.bar/boxschema/bigbox,\n   http://www.foo.bar/boxschema/author,\n   http://www.iana.org/standards/dav/creationdate,\n   http://www.iana.org/standards/dav/displayname,\n   http://www.iana.org/standards/dav/externalmembers,\n   http://www.iana.org/standards/dav/resourcetype, and\n   http://www.iana.org/standards/dav/supportedlock.  The last five\n   properties are WebDAV-specific, defined in Section 12.  Since GET is\n   not supported on this resource, the get-* properties (e.g., get-\n   content-length) are not defined on this resource. The DAV-specific\n   properties assert that \"container\" was created on December 1, 1997,\n   at 5:42:21PM, in a time zone 8 hours west of GMT (creationdate), has\n   a name of \"Example collection\" (displayname), a single external\n   member resource, http://www.acme.com/front/ (externalmembers), a\n   collection resource type (resourcetype), and supports exclusive\n   write and shared write locks (supportedlock).\n\n   The resource http://www.foo.bar/container/front.html has nine\n   properties defined on it, named http://www.foo.bar/boxschema/bigbox\n   (another instance of the \"bigbox\" property type),\n\nGoland et al.                                                [Page 25]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   http://www.iana.org/standards/dav/creationdate,\n   http://www.iana.org/standards/dav/displayname,\n   http://www.iana.org/standards/dav/getcontentlength,\n   http://www.iana.org/standards/dav/getcontenttype,\n   http://www.iana.org/standards/dav/getetag,\n   http://www.iana.org/standards/dav/getlastmodified,\n   http://www.iana.org/standards/dav/resourcetype, and\n   http://www.iana.org/standards/dav/supportedlock.  The DAV-specific\n   properties assert that \"front.html\" was created on December 1, 1997,\n   at 6:27:21PM, in a time zone 8 hours west of GMT (creationdate), has\n   a name of \"Example HTML resource\" (displayname), a content length of\n   4525 (getcontentlength), a MIME type of \"text/html\"\n   (getcontenttype), an entity tag of \"zzyzx\" (getetag), was last\n   modified on Monday, January 12, 1998, at 09:25:56 GMT\n   (getlastmodified), has an undefined resource type, meaning that it\n   is not a collection (resourcetype), and supports both exclusive\n   write and shared write locks (supportedlock).\n\n7.1.3     Example: Using propname to Retrieve all Property Names\n\n   >>Request\n\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:propfind>\n     <D:propname/>\n   </D:propfind>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.foo.bar/boxschema/\" as=\"R\"?>\n   <D:multistatus>\n     <D:response>\n          <D:href>http://www.foo.bar/container/</D:href>\n          <D:propstat>\n               <D:prop>\n                    <R:bigbox/>\n                    <R:author/>\n                   <D:creationdate/>\n                   <D:displayname/>\n                   <D:externalmembers/>\n\nGoland et al.                                                [Page 26]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n                   <D:resourcetype/>\n                   <D:supportedlock/>\n               </D:prop>\n               <D:status>HTTP 1.1 200 OK</D:status>\n          </D:propstat>\n     </D:response>\n     <D:response>\n          <D:href>http://www.foo.bar/container/front.html</D:href>\n          <D:propstat>\n               <D:prop>\n                    <R:bigbox/>\n                   <D:creationdate/>\n                   <D:displayname/>\n                   <D:get-content-length/>\n                   <D:get-content-type/>\n                   <D:get-etag/>\n                   <D:get-last-modified/>\n                   <D:resourcetype/>\n                   <D:supportedlock/>\n               </D:prop>\n               <D:status>HTTP 1.1 200 OK</D:status>\n          </D:propstat>\n     </D:response>\n   </D:multistatus>\n\n\n   In this example, PROPFIND is invoked on the collection resource\n   http://www.foo.bar/container/, with a propfind XML element\n   containing the propname XML element, meaning the name of all\n   properties should be returned.  Since no depth header is present, it\n   assumes its default value of \"infinity\", meaning the name of the\n   properties on the collection and all its progeny should be returned.\n\n   Consistent with the previous example, resource\n   http://www.foo.bar/container/ has seven properties defined on it,\n   http://www.foo.bar/boxschema/bigbox, and\n   http://www.foo.bar/boxschema/author,\n   http://www.iana.org/standards/dav/creationdate,\n   http://www.iana.org/standards/dav/displayname,\n   http://www.iana.org/standards/dav/externalmembers,\n   http://www.iana.org/standards/dav/resourcetype, and\n   http://www.iana.org/standards/dav/supportedlock.  The resource\n   http://www.foo.bar/container/index.html, a member of the \"container\"\n   collection, has nine properties defined on it,\n   http://www.foo.bar/boxschema/bigbox,\n   http://www.iana.org/standards/dav/creationdate,\n   http://www.iana.org/standards/dav/displayname,\n   http://www.iana.org/standards/dav/get-content-length,\n   http://www.iana.org/standards/dav/get-content-type,\n   http://www.iana.org/standards/dav/get-etag,\n   http://www.iana.org/standards/dav/get-last-modified,\n\n\nGoland et al.                                                [Page 27]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   http://www.iana.org/standards/dav/resourcetype, and\n   http://www.iana.org/standards/dav/supportedlock.\n\n\n7.2 PROPPATCH\n\n   The PROPPATCH method processes instructions specified in the request\n   body to set and/or remove properties defined on the resource\n   identified by Request-URI.\n\n   All DAV compliant resources MUST support the PROPPATCH method and\n   MUST process instructions that are specified using the\n   propertyupdate, set, and remove XML elements of the DAV schema.\n   Execution of the directives in this method is, of course, subject to\n   access control constraints.  DAV compliant resources SHOULD support\n   the setting of arbitrary dead properties.\n\n   The request message body of a PROPPATCH method MUST contain at least\n   one propertyupdate XML element. Instruction processing MUST occur in\n   the order instructions are received (i.e., from top to bottom).\n   Instructions MUST either all be executed or none executed. Thus if\n   any error occurs during processing all executed instructions MUST be\n   undone and a proper error result returned. Instruction processing\n\n   details can be found in the definition of the set and remove\n   instructions in Section 11.13.\n\n   If PROPPATCH is invoked on a null resource (e.g., a deleted\n   resource), an empty resource is created, and the PROPPATCH\n   directives are performed on this new resource.\n\n7.2.1     Status Codes\n\n   200 OK - The command succeeded.  As there can be a mixture of sets\n   and removes in a body, a 201 Created seems inappropriate.\n\n   403 Forbidden - The client, for reasons the server chooses not to\n   specify, cannot alter one of the properties.\n\n   409 Conflict - The client has provided a value whose semantics are\n   not appropriate for the property.  This includes trying to set read-\n   only properties.\n\n   413 Request Entity Too Long - If a particular property is too long\n   to be recorded then a composite XML error will be returned\n   indicating the offending property.\n\n7.2.2     Example\n\n   >>Request\n\n   PROPPATCH /bar.html HTTP/1.1\n   Host: www.foo.com\n\nGoland et al.                                                [Page 28]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Content-Type: text/xml\n   Content-Length: xxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.w3.com/standards/z39.50/\" as=\"Z\"?>\n   <D:propertyupdate>\n     <D:set>\n          <D:prop>\n               <Z:authors>\n                    <Z:Author>Jim Whitehead</Z:Author>\n                    <Z:Author>Roy Fielding</Z:Author>\n               </Z:authors>\n          </D:prop>\n     </D:set>\n     <D:remove>\n          <D:prop><Z:Copyright-Owner/></D:prop>\n     </D:remove>\n   </D:propertyupdate>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.w3.com/standards/z39.50/\" as=\"Z\"?>\n   <D:multistatus>\n     <D:response>\n          <D:href>http://www.foo.com/bar</D:href>\n          <D:propstat>\n               <D:prop><Z:Authors/></D:prop>\n               <D:status>HTTP/1.1 424 Method Failure</D:status>\n          </D:propstat>\n          <D:propstat>\n               <D:prop><Z:Copyright-Owner/></D:prop>\n               <D:status>HTTP/1.1 409 Conflict</D:status>\n          </D:propstat>\n          <D:responsedescription> Copyright Owner can not be deleted or\n   altered.</D:responsedescription>\n     <D:response>\n   </D:multistatus>\n\n   In this example, the client requests the server to set the value of\n   the http://www.w3.com/standards/z39.50/Authors property, and to\n   remove the property http://www.w3.com/standards/z39.50/Copyright-\n   Owner.  Since the Copyright-Owner property could not be removed, no\n   property modifications occur.  The Method Failure status code for\n   the Authors property indicates this action would have succeeded if\n\n\nGoland et al.                                                [Page 29]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   it were not for the conflict with removing the Copyright-Owner\n   property.\n\n\n7.3 MKCOL Method\n\n   The MKCOL method is used to create a new collection. All DAV\n   compliant resources MUST support the MKCOL method.\n\n7.3.1     Request\n\n   MKCOL creates a new collection resource at the location specified by\n   the Request-URI.  If the resource identified by the Request-URI is\n   non-null then the MKCOL must fail.  During MKCOL processing, a\n   server MUST make the Request-URI a member of its parent collection.\n   If no such ancestor exists, the method MUST fail.  When the MKCOL\n   operation creates a new collection resource, all ancestors MUST\n   already exist, or the method MUST fail with a 409 Conflict status\n   code.  For example, if a request to create collection /a/b/c/d/ is\n   made, and neither /a/b/ nor /a/b/c/ exists, the request MUST fail.\n\n   When MKCOL is invoked without a request body, the newly created\n   collection has no members.\n\n   A MKCOL request message MAY contain a message body.  The behavior of\n   a MKCOL request when the body is present is limited to creating\n   collections, members of a collection, bodies of members and\n   properties on the collections or members.  If the server receives a\n   MKCOL request entity type it does not support or understand it MUST\n   respond with a 415 Unsupported Media Type status code.  The exact\n   behavior of MKCOL for various request media types is undefined in\n   this document, and will be specified in separate documents.\n\n7.3.2     Response Codes\n\n   Responses from a MKCOL request are not cacheable, since MKCOL has\n   non-idempotent semantics.\n\n   201 Created - The collection or structured resource was created in\n   its entirety.\n\n   403 Forbidden - This indicates at least one of two conditions: 1)\n   The server does not allow the creation of collections at the given\n   location in its namespace, and 2) The parent collection of the\n   Request-URI exists but cannot accept members.\n\n   405 Method Not Allowed - MKCOL can only be executed on a\n   deleted/non-existent resource.\n\n   409 Conflict - A collection cannot be made at the Request-URI until\n   one or more intermediate collections have been created.\n\n\nGoland et al.                                                [Page 30]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   415 Unsupported Media Type- The server does not support the request\n   type of the body.\n\n   423 Insufficient Space on Resource - The resource does not have\n   sufficient space to record the state of the resource after the\n   execution of this method.\n\n7.3.3     Example\n\n   This example creates a collection called /webdisc/xfiles/ on the\n   server www.server.org.\n\n   >>Request\n\n   MKCOL /webdisc/xfiles/ HTTP/1.1\n   Host: www.server.org\n\n   >>Response\n\n   HTTP/1.1 201 Created\n\n\n7.4 ADDREF Method\n\n   The ADDREF method is used to add external members to a resource.\n   All DAV compliant collection resources MUST support the ADDREF\n   method.  All other DAV compliant resources MAY support the ADDREF\n   method as appropriate.\n\n7.4.1     The Request\n\n   The ADDREF method adds the URI specified in the Collection-Member\n   header as an external member to the collection specified by the\n   Request-URI.\n\n   It is not an error if the URI specified in the Collection-Member\n   header already exists as an external member of the collection.\n   However, after processing the ADDREF there MUST be only one instance\n   of the URI in the collection.  If the URI specified in the\n   Collection-Member header already exists as an internal member of the\n   collection, the ADDREF method MUST fail with a 412 Precondition\n   Failed status code.\n\n   More than one Collection-Member request header MUST NOT be used with\n   the ADDREF method.\n\n7.4.2     Example\n\n   >>Request\n\n   ADDREF /~ejw/dav/ HTTP/1.1\n   Host: www.ics.uci.edu\n\nGoland et al.                                                [Page 31]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Collection-Member: http://www.iana.org/standards/dav/\n\n   >>Response\n\n   HTTP/1.1 204 No Content\n\n\n   This example adds the URI http://www.iana.org/standards/dav/ as an\n   external member resource of the collection\n   http://www.ics.uci.edu/~ejw/dav/.\n\n\n7.5 DELREF Method\n\n   The DELREF method is used to remove external members from a\n   resource.  All DAV compliant collection resources MUST support the\n   DELREF method.  All other DAV compliant resources MUST support the\n   DELREF method only if they support the ADDREF method.\n\n7.5.1     The Request\n\n   The DELREF method removes the URI specified in the Collection-Member\n   header from the collection specified by the Request-URI.\n\n   DELREFing a URI which is not a member of the collection is not an\n   error.  DELREFing an internal member MUST fail with a 412\n   Precondition Failed status code.\n\n   More than one Collection-Member request header MUST NOT be used with\n   the DELREF method.\n\n7.5.2     Example\n\n   >>Request\n\n   DELREF /~ejw/dav/ HTTP/1.1\n   Host: www.ics.udi.edu\n   Collection-Member: http://www.iana.org/standards/dav/\n\n\n   >>Response\n\n   HTTP/1.1 204 No Content\n\n   This example removes the URI http://www.iana.org/standards/dav/, an\n   external member resource, from the collection\n   http://www.ics.uci.edu/~ejw/dav/.\n\n\n7.6 GET, HEAD for Collections\n\n\n\nGoland et al.                                                [Page 32]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   The semantics of GET are unchanged when applied to a collection,\n   since GET is defined as, \"retrieve whatever information (in the form\n   of an entity) is identified by the Request-URI\" [Fielding et al.,\n   1997].  GET when applied to a collection MAY return the contents of\n   an \"index.html\" resource, a human-readable view of the contents of\n   the collection, or something else altogether. Hence it is possible\n   that the result of a GET on a collection will bear no correlation to\n   the state of the collection.\n\n   Similarly, since the definition of HEAD is a GET without a response\n   message body, the semantics of HEAD are unmodified when applied to\n   collection resources.\n\n7.7 POST for Collections\n\n   Since by definition the actual function performed by POST is\n   determined by the server and often depends on the particular\n   resource, the behavior of POST when applied to collections cannot be\n   meaningfully modified because it is largely undefined.  Thus the\n   semantics of POST are unmodified when applied to a collection.\n\n\n7.8 DELETE\n\n7.8.1     DELETE for Non-Collection Resources\n\n   If the DELETE method is issued to a non-collection resource which is\n   an internal member of a collection, then during DELETE processing a\n   server MUST remove the Request-URI from its parent collection.  A\n   server MAY remove the URI of a deleted resource from any collections\n   of which the resource is an external member.\n\n7.8.2     DELETE for Collections\n\n   The DELETE method on a collection MUST act as if a Depth = infinity\n   header was used on it.  A client MUST NOT submit a Depth header on a\n   DELETE on a collection with any value but infinity.\n\n   DELETE instructs that the collection specified in the request-URI,\n   the records of its external member resources, and all its internal\n   member resources, are to be deleted.\n\n   If any member cannot be deleted then all of the member's ancestors\n   MUST NOT be deleted, so as to maintain the namespace.\n\n   Any headers included with DELETE MUST be applied in processing every\n   resource to be deleted.\n\n   When the DELETE method has completed processing it MUST return a\n   consistent namespace.\n\n\n\nGoland et al.                                                [Page 33]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   The response SHOULD be a Multi-Status response that describes the\n   result of the DELETE on each affected resource.\n\n7.8.2.1   Example\n\n   >>Request\n\n   DELETE  /container/ HTTP/1.1\n   Host: www.foo.bar\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"d\"?>\n   <d:multistatus>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource1</d:href>\n          <d:href>http://www.foo.bar/container/resource2</d:href>\n          <d:status>HTTP/1.1 200 OK</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/</d:href>\n          <d:status>HTTP/1.1 424 Method Failure</d:status>\n     </d:response>\n     <d:response>\n          <d:href>http://www.foo.bar/container/resource3</d:href>\n          <d:status>HTTP/1.1 425 Locked</d:status>\n     </d:response>\n   </d:multistatus>\n\n   In this example the attempt to delete\n   http://www.foo.bar/container/resource3 failed because it is locked,\n   and no lock token was submitted with the request. Consequently, the\n   attempt to delete http://www.foo.bar/container/ also failed, but\n   resource1 and resource2 were deleted. Even though a Depth header has\n   not been included, a depth of infinity is assumed because the method\n   is on a collection. As this example illustrates, DELETE processing\n   need not be atomic.\n\n7.9 PUT\n\n7.9.1     PUT for Non-Collection Resources\n\n   A PUT performed on an existing resource replaces the GET response\n   entity of the resource.  Properties defined on the resource MAY be\n   recomputed during PUT processing but are not otherwise effected.\n   For example, if a server recognizes the content type of the request\n\n\nGoland et al.                                                [Page 34]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   body, it may be able to automatically extract information that could\n   be profitably exposed as properties.\n\n   A PUT that would result in the creation of a resource without an\n   appropriately scoped parent collection MUST fail with a 409\n   Conflict.\n\n7.9.2     PUT for Collections\n\n   As defined in the HTTP/1.1 specification [Fielding et al., 1997],\n   the \"PUT method requests that the enclosed entity be stored under\n   the supplied Request-URI.\"  Since submission of an entity\n   representing a collection would implicitly encode creation and\n   deletion of resources, this specification intentionally does not\n   define a transmission format for creating a collection using PUT.\n   Instead, the MKCOL method is defined to create collections.  If a\n   PUT is invoked on a collection resource it MUST fail.\n\n   When the PUT operation creates a new non-collection resource all\n   ancestors MUST already exist.  If all ancestors do not exist, the\n   method MUST fail with a 409 Conflict status code.  For example, if\n   resource /a/b/c/d.html is to be created and /a/b/c/ does not exist,\n   then the request must fail.\n\n\n7.10 COPY Method\n\n   The COPY method creates a duplicate of the source resource, given by\n   the Request-URI, in the destination resource, given by the\n   Destination header.  The Destination header MUST be present.  The\n   exact behavior of the COPY method depends on the type of the source\n   resource.\n\n   Support for the COPY method does not guarantee the ability to copy a\n   resource. For example, separate programs may control resources on\n   the same server.  As a result, it may not even be possible to copy a\n   resource to a location that appears to be on the same server.\n\n7.10.1    COPY for HTTP/1.1 resources\n\n   When the source resource is not a collection the body of the\n   destination resource MUST be octet-for-octet identical to the body\n   of the source resource.  Subsequent alterations to the destination\n   resource will not modify the source resource.  Subsequent\n   alterations to the source resource will not modify the destination\n   resource.  Thus, all copies are performed \"by-value\".\n\n   All properties on the source resource MUST be duplicated on the\n   destination resource, subject to modifying headers and XML elements,\n   following the definition for copying properties.\n\n7.10.2    COPY for Properties\n\nGoland et al.                                                [Page 35]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   The following section defines how properties on a resource are\n   handled during a COPY operation.\n\n   Live properties SHOULD be duplicated as identically behaving live\n   properties at the destination resource.  If a property cannot be\n   copied live, then its value MUST be duplicated, octet-for-octet, in\n   an identically named, dead property on the destination resource.\n\n   The propertybehavior XML element can specify that properties are\n   copied on best effort, that all live properties MUST be successfully\n   copied or the method MUST fail, or that a specified list of live\n   properties MUST be successfully copied or the method must fail. The\n   propertybehavior XML element is defined in Section 11.12.\n\n   If a property on the source already exists on the destination\n   resource and the Overwrite header is set to \"T\" then the property at\n   the destination MUST be overwritten with the property from the\n   source.  If the Overwrite header is \"F\" and the previous situation\n   exists, then the COPY MUST fail with a 412 Precondition Failed.\n\n7.10.3    COPY for Collections\n\n   The COPY method on a collection without a Depth header MUST act as\n   if a Depth header with value \"infinity\" was included.  A client MAY\n   submit a Depth header on a COPY on a collection with a value of \"0\"\n   or \"infinity\".  DAV compliant servers MUST support the \"0\" and\n   \"infinity\" behaviors.\n\n   A COPY of depth infinity instructs that the collection specified in\n   the Request-URI and the records of its external member resources is\n   to be copied to the location specified in the Destination header,\n   and all its internal member resources are to be copied to a\n   location relative to it, recursively through all levels of the\n   collection hierarchy.\n\n   A COPY of depth \"0\" only instructs that the collection, the\n   properties, and the records of its external members, not its\n   internal members, are to be copied.\n\n   Any headers included with a COPY are to be applied in processing\n   every resource to be copied.\n\n   The exception to this rule is the Destination header. This header\n   only specifies the destination for the Request-URI. When applied to\n   members of the collection specified in the request-URI the value of\n   Destination is to be modified to reflect the current location in the\n   hierarchy.  So, if the request-URI is \"a\" and the destination is \"b\"\n   then when a/c/d is processed it MUST use a destination of b/c/d.\n\n   When the COPY method has completed processing it MUST have created a\n   consistent namespace at the destination.  However, if an error\n\nGoland et al.                                                [Page 36]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   occurs while copying an internal member collection, all members of\n   this collection MUST NOT be copied. In this case, after detecting\n   the error, the COPY operation SHOULD try to finish as much of the\n   original copy operation as possible.  So, for example, if an\n   infinite depth copy operation is performed on collection /a/, which\n   contains collections /a/b/ and /a/c/, and an error occurs copying\n   /a/b/, an attempt should still be made to copy /a/c/. Similarly,\n   after encountering an error copying a non-collection resource as\n   part of an infinite depth copy, the server SHOULD try to finish as\n   much of the original copy operation as possible.\n\n   The response is a Multi-Status status code with an entity body that\n   describes the result of the COPY on each affected resource.  The\n   href XML element in the response refers to the resource that was to\n   be copied, not the resource that was created as a result of the\n   copy.  In other words, each entry indicates whether the copy on the\n   resource specified in the href XML element succeeded or failed and\n   why.\n\n   The exception to this rule is for errors that occurred on the\n   destination.  For example, if the destination was locked the\n   response would indicate the destination URL and a 425 Locked error.\n\n7.10.4    Type Interactions\n\n   If the destination resource identifies a collection and the\n   Overwrite header is \"T\", prior to performing the copy the server\n   MUST perform a DELETE operation on the collection.\n\n7.10.5    Status Codes\n\n   201 Created - The source resource was successfully copied.  The copy\n   operation resulted in the creation of a new resource.\n\n   204 No Content - The source resource was successfully copied to a\n   pre-existing destination resource.  Since there is no entity body in\n   the response, 204 No Content is used instead of 200 OK.\n\n   412 Precondition Failed - This status code MUST be returned if the\n   server was unable to maintain the liveness of the properties listed\n   in the propertybehavior XML element, or if the Overwrite header is\n   \"F\", and the state of the destination resource is non-null.\n\n   423 Insufficient Space on Resource - The destination resource does\n   not have sufficient space to record the state of the resource after\n   the execution of this method.\n\n   425 Locked - The destination resource was locked and either a valid\n   Lock-Token header was not submitted, or the Lock-Token header\n   identifies a lock held by another principal.\n\n\n\nGoland et al.                                                [Page 37]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   502 Bad Gateway - This may occur when the destination is on another\n   server and the destination server refuses to accept the resource.\n\n7.10.6    Overwrite Example\n\n   This example shows resource\n   http://www.ics.uci.edu/~fielding/index.html being copied to the\n   location http://www.ics.uci.edu/users/f/fielding/index.html.  The\n   204 No Content status code indicates the existing resource at the\n   destination was overwritten.\n\n   >>Request\n\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n\n   >>Response\n\n   HTTP/1.1 204 No Content\n\n7.10.7    No Overwrite Example\n\n   The following example shows the same copy operation being performed,\n   except with the Overwrite header set to \"F.\"  A response of 412\n   Precondition Failed is returned because the destination resource has\n   a non-null state.\n\n   >>Request\n\n   COPY /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n   Overwrite: F\n\n   >>Response\n\n   HTTP/1.1 412 Precondition Failed\n\n7.10.8    Collection Example\n\n   >>Request\n\n   COPY /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Depth: infinity\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"d\"?>\n\nGoland et al.                                                [Page 38]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   <d:propertybehavior>\n     <d:keepalive>*</d:keepalive>\n   </d:propertybehavior>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"d\"?>\n   <d:multistatus>\n     <d:response>\n       <d:href>http://www.foo.bar/othercontainer/resource1</d:href>\n       <d:href>http://www.foo.bar/othercontainer/resource2</d:href>\n       <d:href>http://www.foo.bar/othercontainer/</d:href>\n     <d:status>HTTP/1.1 201 Created</d:status>\n     </d:response>\n\n     <d:response>\n       <d:href>http://www.foo.bar/othercontainer/R2/</d:href>\n       <d:href>http://www.foo.bar/othercontainer/R2/D2</d:href>\n       <d:status>HTTP/1.1 412 Precondition Failed</d:status>\n     </d:response>\n   </d:multistatus>\n\n   The Depth header is unnecessary as the default behavior of COPY on a\n   collection is to act as if a \"Depth: infinity\" header had been\n   submitted.  In this example most of the resources, along with the\n   collection, were copied successfully. However the collection R2\n   failed, most likely due to a problem with maintaining the liveness\n   of properties (this is specified by the propertybehavior XML\n   element). Since an error occurred copying R2, R2's member D2 was not\n   copied.\n\n\n7.11 MOVE Method\n\n   The MOVE operation on a non-collection resource is the logical\n   equivalent of a copy (COPY) followed by a delete, where the actions\n   are performed atomically.  All DAV compliant resources MUST support\n   the MOVE method.\n\n   However, support for the MOVE method does not guarantee the ability\n   to move a resource to a particular destination. For example,\n   separate programs may actually control different sets of resources\n   on the same server.  Therefore, it may not even be possible to move\n   a resource within a namespace that appears to belong to the same\n   server.\n\n\n\nGoland et al.                                                [Page 39]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   If a resource exists at the destination, the destination resource\n   will be DELETEd as a side effect of the MOVE operation, subject to\n   the restrictions of the Overwrite header.\n\n7.11.1    MOVE for Collections\n\n   A MOVE of depth infinity instructs that the collection specified in\n   the Request-URI, including the records of its external member\n   resources, is to be moved to the location specified in the\n   Destination header, and all its internal member resources are to be\n   moved to locations relative to it, recursively through all levels of\n   the collection hierarchy.\n\n   The MOVE method on a collection MUST act as if a Depth \"infinity\"\n   header was used on it.  A client MUST NOT submit a Depth header on a\n   MOVE on a collection with any value but \"infinity\".\n\n   Any headers included with MOVE are to be applied in processing every\n   resource to be moved.\n\n   The exception to this rule is the Destination header.  The behavior\n   of this header is the same as given for COPY on collections.\n\n   When the MOVE method has completed processing it MUST have created a\n   consistent namespace on both the source and destination. However, if\n   an error occurs while moving an internal member collection, all\n   members of the failed collection MUST NOT be moved. In this case,\n   after detecting the error, the move operation SHOULD try to finish\n   as much of the original move as possible.  So, for example, if an\n   infinite depth move is performed on collection /a/, which contains\n   collections /a/b/ and /a/c/, and an error occurs moving /a/b/, an\n   attempt should still be made to try moving /a/c/. Similarly, after\n   encountering an error moving a non-collection resource as part of an\n   infinite depth move, the server SHOULD try to finish as much of the\n   original move operation as possible.\n\n   As specified in the definition of MOVE, a MOVE of a collection over\n   another collection causes the destination collection and all its\n   members to be deleted.\n\n   The response is a Multi-Status response that describes the result of\n   the MOVE on each affected resource.  The href XML element in the\n   response refers to the resource that was to be moved, not the\n   resource that was created as a result of the move.  In other words,\n   each entry indicates whether the move on the resource specified in\n   the href succeeded or failed and why.\n\n   The exception to this rule is for errors that occurred on the\n   destination.  For example, if the destination was locked the\n   response would indicate the destination URL and a 425 Locked error.\n\n7.11.2    Status Codes\n\nGoland et al.                                                [Page 40]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   201 Created - The source resource was successfully moved, and a new\n   resource was created at the destination.\n\n   204 No Content - The move operation was successful, and the resource\n   at the destination was overwritten.\n\n   412 Precondition Failed - This status code MUST be returned if the\n   server was unable to maintain the liveness of the properties listed\n   in the propertybehavior XML element, or if the Overwrite header is\n   \"F\", and the state of the destination resource is non-null.\n\n   425 Locked - The source or the destination resource was locked and\n   either a valid Lock-Token header was not submitted, or the Lock-\n   Token header identifies a lock held by another principal.\n\n   502 Bad Gateway - This may occur when the destination is on another\n   server and the destination server refuses to accept the resource.\n\n7.11.3    Non-Collection Example\n\n   This example shows resource\n   http://www.ics.uci.edu/~fielding/index.html being moved to the\n   location http://www.ics.uci.edu/users/f/fielding/index.html. The\n   contents of the destination resource would have been overwritten if\n   the destination resource had been non-null.  In this case, since\n   there was nothing at the destination resource, the response code is\n   201 Created.\n\n\n   >>Request\n\n   MOVE /~fielding/index.html HTTP/1.1\n   Host: www.ics.uci.edu\n   Destination: http://www.ics.uci.edu/users/f/fielding/index.html\n\n   >>Response\n\n   HTTP/1.1 201 Created\n   Location: http://www.ics.uci.edu/users/f/fielding/index.html\n\n\n7.11.4    Collection Example\n\n   >>Request\n\n   MOVE /container/ HTTP/1.1\n   Host: www.foo.bar\n   Destination: http://www.foo.bar/othercontainer/\n   Overwrite: F\n   Lock-Token: <opaquelocktoken:fe184f2e-6eec-41d0-c765-01adc56e6bb4>,\n      <opaquelocktoken:e454f3f3-acdc-452a-56c7-00a5c91e4b77>\n\nGoland et al.                                                [Page 41]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Content-Type: text/xml\n   Content-Length: xyz\n   Authorization: Digest username=\"rohit\",\n      realm=\"rohit@www.foo.bar\", nonce=\"...\",\n      uri=\"/container/\", response=\"...\",\n      opaque=\"...\"\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"d\"?>\n   <d:propertybehavior>\n     <d:keepalive>*</d:keepalive>\n   </d:propertybehavior>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: zzz\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"d\"?>\n   <d:multistatus>\n     <d:response>\n       <d:href>http://www.foo.bar/container/resource1</d:href>\n       <d:href>http://www.foo.bar/container/resource2</d:href>\n       <d:href>http://www.foo.bar/container/</d:href>\n       <d:status>HTTP/1.1 204 No Content</d:status>\n     </d:response>\n     <d:response>\n       <d:href>http://www.foo.bar/container/C2/R2</d:href>\n       <d:status>HTTP/1.1 424 Method Failure</d:status>\n     <d:response>\n       <d:href>http://www.foo.bar/othercontainer/C2/</d:href>\n       <d:status>HTTP/1.1 425 Locked</d:status>\n     </d:response>\n   </d:multistatus>\n\n   In this example the client has submitted a number of lock tokens\n   with the request.  A lock token will need to be submitted for every\n   resource, both source and destination, anywhere in the scope of the\n   method, that is locked.  In this case the proper lock token was not\n   submitted for the destination http://www.foo.bar/othercontainer/C2/.\n   This means that the resource /container/C2/ could not be moved.  As\n   the attempt to move /container/C2/ failed then the resource\n   /container/C2/R2 MUST also fail since it is a child of\n   /container/C2/.\n\n\n7.12 LOCK Method\n\n   The following sections describe the LOCK method, which is used to\n   take out a lock of any access type.  These sections on the LOCK\n\nGoland et al.                                                [Page 42]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   method describe only those semantics that are specific to the LOCK\n   method and are independent of the access type of the lock being\n   requested.\n\n7.12.1    Operation\n\n   A LOCK method invocation creates the lock specified by the lockinfo\n   XML element on the Request-URI.  Lock method requests SHOULD have a\n   XML request body which contains an owner XML element for this lock\n   request, unless this is a refresh request. The LOCK request MAY have\n   a Timeout header.\n\n   A successful response to a lock invocation MUST include Lock-Token\n   and Timeout headers.  Clients MUST assume that locks may arbitrarily\n   disappear at any time, regardless of the value given in the Timeout\n   header.  The Timeout header only indicates the behavior of the\n   server if \"extraordinary\" circumstances do not occur.  For example,\n   an administrator may remove a lock at any time or the system may\n   crash in such a way that it loses the record of the lock's\n   existence. The response MUST also contain the value of the\n   lockdiscovery property in a prop XML element.\n\n7.12.2    The Effect of Locks on Properties and Collections\n\n   The scope of a lock is the entire state of the resource, including\n   its body and associated properties.  As a result, a lock on a\n   resource also locks the resource's properties.\n\n   For collections, a lock also affects the ability to add or remove\n   members.  The nature of the effect depends upon the type of access\n   control involved.\n\n7.12.3    Locking Replicated Resources\n\n   Some servers automatically replicate resources across multiple URLs.\n   In such a circumstance the server MAY only accept a lock on one of\n   the URLs if the server can guarantee that the lock will be honored\n   across all the URLs.\n\n7.12.4    Depth and Locking\n\n   The Depth header MAY be used with the LOCK method.  Values other\n   than 0 or infinity MUST NOT be used with the Depth header.\n\n   A Depth header of value 0 means to just lock the resource specified\n   by the request-URI.\n\n   If the Depth header is set to infinity then the resource specified\n   in the request-URI along with all its internal members, all the way\n   down the hierarchy, are to be locked.  A successful result will\n   return a single lock token which represents all the resources that\n   have been locked.  If an UNLOCK is executed on this token, all\n\nGoland et al.                                                [Page 43]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   associated resources are unlocked.  If the lock cannot be granted to\n   all resources, a 409 Conflict status code MUST be returned with a\n   response entity body containing a multistatus XML element describing\n   which resource(s) prevented the lock from being granted.  Hence,\n   partial success is not an option.  Either the entire hierarchy is\n   locked or no resources are locked.\n\n7.12.5    Interaction with other Methods\n\n   The interaction of a LOCK with various methods is dependent upon the\n   lock type.  However, independent of lock type, a successful DELETE\n   of a resource MUST cause all of its locks to be removed.\n\n7.12.6    Lock Compatibility Table\n\n   The table below describes the behavior that occurs when a lock\n   request is made on a resource.\n\n\n   Current lock state/      Shared Lock       Exclusive\n   Lock request                               Lock\n\n   None                     True              True\n\n   Shared Lock              True              False\n\n   Exclusive Lock           False             False*\n\n\n\n   Legend: True = lock MAY be granted.  False = lock MUST NOT be\n   granted.  *=if the principal requesting the lock is the owner of the\n   lock, the lock MUST be regranted.\n\n   The current lock state of a resource is given in the leftmost\n   column, and lock requests are listed in the first row.  The\n   intersection of a row and column gives the result of a lock request.\n   For example, if a shared lock is held on a resource, and an\n   exclusive lock is requested, the table entry is \"false\", indicating\n   the lock must not be granted.\n\n   If an exclusive or shared lock is re-requested by the principal who\n   owns the lock, the lock MUST be regranted.  If the lock is\n   regranted, the same lock token that was previously issued MUST be\n   returned.\n\n7.12.7    Lock Response\n\n   A successful lock response MUST contain a Lock-Token response\n   header, a Timeout header and a prop XML element in the response body\n   which contains the value of the lockdiscovery property.\n\n7.12.8    Status Codes\n\n\n\n\n\nGoland et al.                                                [Page 44]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   412 Precondition Failed - The included Lock-Token was not\n   enforceable on this resource or the server could not satisfy the\n   request in the lockinfo XML element.\n\n   425 Locked - The resource is locked, so the method has been\n   rejected.\n\n7.12.9    Example - Simple Lock Request\n\n   >>Request\n\n   LOCK /workspace/webdav/proposal.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Timeout: Infinite, Second-4100000000\n   Content-Type: text/xml\n   Content-Length: xyz\n   Authorization: Digest username=\"ejw\",\n      realm=\"ejw@webdav.sb.aol.com\", nonce=\"...\",\n      uri=\"/workspace/webdav/proposal.doc\",\n      response=\"...\", opaque=\"...\"\n\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:lockinfo>\n     <D:locktype><D:write/></D:locktype>\n     <D:lockscope><D:exclusive/></D:lockscope>\n     <D:owner>\n       <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href>\n     </D:owner>\n   </D:lockinfo>\n\n   >>Response\n\n   HTTP/1.1 200 OK\n   Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>\n   Timeout: Second-604800\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:prop>\n     <D:lockdiscovery>\n       <D:activelock>\n         <D:locktype><D:write/></D:locktype>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:owner>\n           <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href>\n         </D:owner>\n         <D:timeout>Second-604800</D:timeout>\n         <D:locktoken>\n\nGoland et al.                                                [Page 45]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n           <D:href>\n     opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4\n           </D:href>\n         </D:locktoken>\n       </D:activelock>\n     </D:lockdiscovery>\n   </D:prop>\n\n   This example shows the successful creation of an exclusive write\n   lock on resource\n   http://webdav.sb.aol.com/workspace/webdav/proposal.doc.  The\n   resource http://www.ics.uci.edu/~ejw/contact.html contains contact\n   information for the owner of the lock.  The server has an activity-\n   based timeout policy in place on this resource, which causes the\n   lock to automatically be removed after 1 week (604800 seconds).  The\n   response has a Lock-Token header that gives the lock token URL that\n   uniquely identifies the lock created by this lock request.  Note\n   that the nonce, response, and opaque fields have not been calculated\n   in the Authorization request header.\n\n7.12.10   Example - Refreshing a Write Lock\n\n   >>Request\n\n   LOCK /workspace/webdav/proposal.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Timeout: Infinite, Second-4100000000\n   Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>\n   Authorization: Digest username=\"ejw\",\n      realm=\"ejw@webdav.sb.aol.com\", nonce=\"...\",\n      uri=\"/workspace/webdav/proposal.doc\",\n      response=\"...\", opaque=\"...\"\n\n   >>Response\n\n   HTTP/1.1 200 OK\n   Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4>\n   Timeout: Second-604800\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:prop>\n     <D:lockdiscovery>\n       <D:activelock>\n         <D:locktype><D:write/></D:locktype>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:owner>\n           <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href>\n         </D:owner>\n         <D:timeout>Second-604800</D:timeout>\n\nGoland et al.                                                [Page 46]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n         <D:locktoken>\n           <D:href>\n     opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4\n           </D:href>\n         </D:locktoken>\n       </D:activelock>\n     </D:lockdiscovery>\n   </D:prop>\n\n   This request would refresh the lock, resetting any time outs.\n   Notice that the client asked for an infinite time out but the server\n   choose to ignore the request. In this example, the nonce, response,\n   and opaque fields have not been calculated in the Authorization\n   request header.\n\n7.12.11   Example - Multi-Resource Lock Request\n\n   >>Request\n\n   LOCK /webdav/ HTTP/1.1\n   Host: webdav.sb.aol.com\n   Timeout: Infinite, Second-4100000000\n   Depth: infinity\n   Authorization: Digest username=\"ejw\",\n      realm=\"ejw@webdav.sb.aol.com\", nonce=\"...\",\n      uri=\"/workspace/webdav/proposal.doc\",\n      response=\"...\", opaque=\"...\"\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:lockinfo>\n     <D:locktype><D:write/></D:locktype>\n     <D:lockscope><D:exclusive/></D:lockscope>\n     <D:owner>\n       <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href>\n     </D:owner>\n   </D:lockinfo>\n\n   >>Response\n\n   HTTP/1.1 207 Multistatus\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:multistatus>\n     <D:response>\n          <D:href>http://webdav.sb.aol.com/webdav/proposal.doc</D:href>\n          <D:href>http://webdav.sb.aol.com/webdav/</D:href>\n          <D:status>HTTP/1.1 424 Method Failure</D:status>\n     </D:response>\n\nGoland et al.                                                [Page 47]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n     <D:response>\n          <D:href>http://webdav.sb.aol.com/webdav/secret</D:href>\n          <D:status>HTTP/1.1 403 Forbidden</D:status>\n     </D:response>\n   </D:multistatus>\n\n   This example shows a request for an exclusive write lock on a\n   collection and all its children.  In this request, the client has\n   specified that it desires an infinite length lock, if available,\n   otherwise a timeout of 4.1 billion seconds, if available. The\n   request entity body contains the contact information for the\n   principal taking out the lock, in this case a web page URL.\n\n   The 424 Method Failure indicates that a lock was not taken out on\n   these resources due to an error elsewhere.  Note that this does not\n   mean that a lock would have succeeded on these resources had the\n   other error not occurred.  It only means that another error has\n   occurred and so the entire method has been aborted.  The error is a\n   403 Forbidden response on the resource\n   http://webdav.sb.aol.com/webdav/secret.  Because this resource could\n   not be locked, none of the resources were locked.\n\n   In this example, the nonce, response, and opaque fields have not\n   been calculated in the Authorization request header.\n\n\n7.13 UNLOCK Method\n\n   The UNLOCK method removes the lock identified by the lock token in\n   the Lock-Token header from the Request-URI, and all other resources\n   included in the lock.\n\n   Any DAV compliant resource which supports the LOCK method MUST\n   support the UNLOCK method.\n\n7.13.1    Example\n\n   >>Request\n\n   UNLOCK /workspace/webdav/info.doc HTTP/1.1\n   Host: webdav.sb.aol.com\n   Lock-Token:<opaquelocktoken:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7>\n   Authorization: Digest username=\"ejw\",\n      realm=\"ejw@webdav.sb.aol.com\", nonce=\"...\",\n      uri=\"/workspace/webdav/proposal.doc\",\n      response=\"...\", opaque=\"...\"\n\n   >>Response\n\n   HTTP/1.1 204 No Content\n\n\n\nGoland et al.                                                [Page 48]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   In this example, the lock identified by the lock token\n   \"opaquelocktoken:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7\" is\n   successfully removed from the resource\n   http://webdav.sb.aol.com/workspace/webdav/info.doc.  If this lock\n   included more than just one resource, the lock is removed from all\n   resources included in the lock.  The 204 status code is used instead\n   of 200 OK because there is no response entity body.\n\n   In this example, the nonce, response, and opaque fields have not\n   been calculated in the Authorization request header.\n\n8  HTTP Headers for Distributed Authoring\n\n8.1 Collection-Member Header\n\n   CollectionMember = \"Collection-Member\" \":\" absoluteURI   ;\n   absoluteURI is defined in section 3.2.1 of [Fielding et al., 1997]\n\n   The Collection-Member header specifies the URI of an external\n   resource to be added/deleted to/from a collection.\n\n8.2 DAV Header\n\n   DAV = \"DAV\" \":\" [\"1\"] [\",2\"] [\",\" 1#extend]\n\n   This header indicates that the resource supports the DAV schema and\n   protocol as specified. All DAV compliant resources MUST return the\n   DAV header on all OPTIONS responses.\n\n   The value is a list of all compliance classes that the resource\n   supports. Note that above a comma has already been added to the 2.\n   This is because a resource can not be level 2 compliant unless it is\n   also level 1 compliant. Please refer to Section 13 for more details.\n   In general, however, support for one compliance class does not\n   entail support for any other.\n\n8.3 Depth Header\n\n   Depth = \"Depth\" \":\" (\"0\" | \"1\" | \"infinity\")\n\n   The Depth header is used with methods executed on resources which\n   could potentially have internal members to indicate whether the\n   method is to be applied only to the resource (Depth = 0), to the\n   resource and its immediate children, (Depth = 1), or the resource\n   and all its progeny (Depth = infinity).\n\n   The Depth header is only supported if a method's definition\n   explicitly provides for such support.\n\n   The following rules are the default behavior for any method that\n   supports the Depth header. A method MAY override these defaults by\n   defining different behavior in its definition.\n\nGoland et al.                                                [Page 49]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   Methods which support the Depth header MAY choose not to support all\n   of the header's values and MAY define, on a case by case basis, the\n   behavior of the method if a Depth header is not present. For\n   example, the MOVE method only supports Depth = infinity and if a\n   Depth header is not present will act as if a Depth = infinity header\n   had been applied.\n\n\n   Clients MUST NOT rely upon methods executing on members of their\n   hierarchies in any particular order or on the execution being\n   atomic. Note that methods MAY provide guarantees on ordering and\n   atomicity.\n\n   Upon execution, a method with a Depth header will perform as much of\n   its assigned task as possible and then return a response specifying\n   what it was able to accomplish and what it failed to do.\n\n   So, for example, an attempt to COPY a hierarchy may result in some\n   of the members being copied and some not.\n\n   Any headers on a method with a Depth header MUST be applied to all\n   resources in the scope of the method. For example, an If-Match\n   header will have its value applied against every resource in the\n   method's scope and will cause the method to fail if the header fails\n   to match.\n\n   If a resource, source or destination, within the scope of the method\n   is locked in such a way as to prevent the successful execution of\n   the method, then the lock token for that resource MUST be submitted\n   with the request in the Lock-Token request header.\n\n   The Depth header only specifies the behavior of the method with\n   regards to internal children.  If a resource does not have internal\n   children then the Depth header is ignored.\n\n   Please note, however, that it is always an error to submit a value\n   for the Depth header that is not allowed by the method's definition.\n   Thus submitting a \"Depth: 1\" on a COPY, even if the resource does\n   not have internal members, MUST result in a 400 Bad Request. The\n   method should fail not because the resource doesn't have internal\n   members, but because of the illegal value in the header.\n\n8.4 Destination Header\n\n   Destination = \"Destination\" \":\" URI\n\n   The Destination header specifies a destination resource for methods\n   such as COPY and MOVE, which take two URIs as parameters.\n\n8.5 If-None-State-Match\n\n   If-None-State-Match = \"If-None-State-Match\" \":\" 1#Coded-URL\n\nGoland et al.                                                [Page 50]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   Coded-URL = \"<\" URI \">\"\n\n\n   The If-None-State-Match header is intended to have similar\n   functionality to the If-None-Match header defined in section 14.26\n   of [Fielding et al., 1997].  However the If-None-State-Match header\n   is intended for use with any URI which represents state information\n   about a resource, referred to as a state token.  A typical example\n   is a lock token.\n\n   If any of the state tokens identifies the current state of the\n   resource, the server MUST NOT perform the requested method.\n   Instead, if the request method was GET, HEAD, or PROPFIND, the\n   server SHOULD respond with a 304 Not Modified response, including\n   the cache-related entity-header fields (particularly ETag) of the\n   current state of the resource.  For all other request methods, the\n   server MUST respond with a status of 412 Precondition Failed.\n\n   If none of the state tokens identifies the current state of the\n   resource, the server MAY perform the requested method.\n\n   If any of the tokens is not recognized, the method MUST fail with a\n   412 Precondition Failed.\n\n   Note that the \"AND\" and \"OR\" keywords specified with the If-State-\n   Match header are intentionally not defined for If-None-State-Match,\n   because this functionality is not required.\n\n8.6 If-State-Match\n\n   If-State-Match = \"If-State-Match\" \":\" (\"AND\" | \"OR\") 1#Coded-URL\n\n   The If-State-Match header is intended to have similar functionality\n   to the If-Match header defined in section 14.25 of [Fielding et al.,\n   1997].  However the If-State-Match header is intended for use with\n   any URI which represents state information about a resource.  A\n   typical example is a lock token.\n\n   If the AND keyword is used and all of the state tokens identify the\n   state of the resource, then the server MAY perform the requested\n   method.  If the OR keyword is used and any of the state tokens\n   identifies the current state of the resource, then the server MAY\n   perform the requested method.  If the keyword requirement for the\n   keyword used is not met, the server MUST NOT perform the requested\n   method, and MUST return a 412 Precondition Failed response.\n\n   If any of the tokens is not recognized, the method MUST fail with a\n   412 Precondition Failed.\n\n8.7 Lock-Token Request Header\n\n\nGoland et al.                                                [Page 51]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Lock-Token = \"Lock-Token\" \":\" 1#Coded-URL\n\n   The Lock-Token request header, containing a lock token owned by the\n   requesting principal, is used by the principal to indicate that the\n   principal is aware of the existence of the lock specified by the\n   lock token.\n\n   If the following conditions are met:\n\n   1) The method is restricted by a lock type that requires the\n   submission of a lock token, such as a write lock,\n   2) The user-agent has authenticated itself as a given principal,\n   3) The user-agent is submitting a method request to a resource on\n   which the principal owns a write lock,\n\n   Then:\n\n   1) The method request MUST include a Lock-Token header with the lock\n      token, or,\n   2) The method MUST fail with a 409 Conflict status code.\n\n   If multiple resources are involved with a method, such as the MOVE\n   method, then the lock tokens, if any, for all affected resources,\n   MUST be included in the Lock-Token request header.\n\n   For example, Program A, used by user A, takes out a write lock on a\n   resource.  Program A then makes a number of PUT requests on the\n   locked resource.  All the requests contain a Lock-Token request\n   header that includes the write lock token.  Program B, also run by\n   User A, then proceeds to perform a PUT to the locked resource.\n   However, program B was not aware of the existence of the lock and so\n   does not include the appropriate Lock-Token request header.  The\n   method is rejected even though principal A is authorized to perform\n   the PUT.  Program B can, if it so chooses, now perform lock\n   discovery and obtain the lock token.  Note that programs A and B can\n   perform GETs without using the Lock-Token header because the ability\n   to perform a GET is not affected by a write lock.\n\n   Having a lock token provides no special access rights.  Anyone can\n   find out anyone else's lock token by performing lock discovery.\n   Locks are to be enforced based upon whatever authentication\n   mechanism is used by the server, not based on the secrecy of the\n   token values.\n\n8.8 Lock-Token Response Header\n\n   Lock-Token = \"Lock-Token\" \":\" 1#Coded-URL\n\n   If a resource is successfully locked then a Lock-Token header will\n   be returned containing the lock token that represents the lock.\n\n\n\nGoland et al.                                                [Page 52]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   If multiple lock-tokens are returned then they MUST all refer to the\n   same lock.  As the lock tokens all refer to the same lock a client\n   need only record one of them.\n\n8.9 Overwrite Header\n\n   Overwrite = \"Overwrite\" \":\" (\"T\" | \"F\")\n\n   The Overwrite header specifies whether the server should overwrite\n   the state of a non-null destination resource during a COPY or MOVE.\n   A value of \"F\" states that the server MUST NOT perform the COPY or\n   MOVE operation if the state of the destination resource is non-null.\n   By default, the value of Overwrite is \"T\" and a client MAY omit this\n   header from a request when its value is \"T\". While the Overwrite\n   header appears to duplicate the functionality of the If-Match: *\n   header of HTTP/1.1, If-Match applies only to the Request-URI, and\n   not to the Destination of a COPY or MOVE.\n\n   If a COPY or MOVE is not performed due to the value of the Overwrite\n   header, the method MUST fail with a 409 Conflict status code.\n\n8.10 Status-URI Response Header\n\n   The Status-URI response header MAY be used with the 102 Processing\n   status code to inform the client as to the status of a method.\n\n   Status-URI = \"Status-URI\" \":\" *(Status-Code \"<\" URI \">\") ; Status-\n   Code is defined in 6.1.1 of [Fielding et al., 1997]\n\n   The URIs listed in the header are source resources which have been\n   affected by the outstanding method.  The status code indicates the\n   resolution of the method on the identified resource.  So, for\n   example, if a MOVE method on a collection is outstanding and a 102\n   \"Processing\" response with a Status-URI response header is returned,\n   the included URIs will indicate resources that have had move\n   attempted on them and what the result was.\n\n8.11 Timeout Header\n\n   TimeOut = \"Timeout\" \":\" 1#TimeType\n   TimeType = (\"Second-\" DAVTimeOutVal | \"Infinite\" | Other)\n   DAVTimeOutVal = 1*digit\n   Other = Extend field-value   ; See section 4.2 of [Fielding et al.,\n   1997]\n\n   Clients MAY include Timeout headers in their LOCK requests.\n   However, the server is not required to honor or even consider these\n   requests.  Clients MUST NOT submit a Timeout request header with any\n   method other than a LOCK method.\n\n   A Timeout request header MUST contain at least one TimeType and MAY\n   contain multiple TimeType entries. The purpose of listing multiple\n\nGoland et al.                                                [Page 53]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   TimeType entries is to indicate multiple different values and value\n   types that are acceptable to the client.  The client lists the\n   TimeType entries in order of preference.\n\n   The Timeout response header MUST use a Second value, Infinite, or a\n   TimeType the client has indicated familiarity with.  The server MAY\n   assume a client is familiar with any TimeType submitted in a Timeout\n   header.\n\n   The \"Second\" TimeType specifies the number of seconds that MUST\n   elapse between granting of the lock at the server, and the automatic\n   removal of the lock.  A server MUST not generate a timeout value for\n   \"Second\" greater than 2^32-1.\n\n   The timeout counter SHOULD be restarted any time an owner of the\n   lock sends a method to any member of the lock, including unsupported\n   methods, or methods which are unsuccessful.  However the lock MUST\n   be refreshed if a refresh LOCK method is successfully received.\n\n   If the timeout expires then the lock is lost.  Specifically the\n   server SHOULD act as if an UNLOCK method was executed by the server\n   on the resource using the lock token of the timed-out lock,\n   performed with its override authority. Thus logs should be updated\n   with the disposition of the lock, notifications should be sent,\n   etc., just as they would be for an UNLOCK request.\n\n   Servers are advised to pay close attention to the values submitted\n   by clients, as they will be indicative of the type of activity the\n   client intends to perform.  For example, an applet running in a\n   browser may need to lock a resource, but because of the instability\n   of the environment within which the applet is running, the applet\n   may be turned off without warning.  As a result, the applet is\n   likely to ask for a relatively small timeout value so that if the\n   applet dies, the lock can be quickly harvested.  However, a document\n   management system is likely to ask for an extremely long timeout\n   because its user may be planning on going off-line.\n\n\n9  Status Code Extensions to HTTP/1.1\n\n   The following status codes are added to those defined in HTTP/1.1\n   [Fielding et al., 1997].\n\n9.1 102 Processing\n\n   Methods can potentially take a long period of time to process,\n   especially methods that support the Depth header.  In such cases the\n   client may time-out the connection while waiting for a response.  To\n   prevent this the server MAY return a 102 status code to indicate to\n   the client that the server is still processing the method.\n\n\n\nGoland et al.                                                [Page 54]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   If a method is taking longer than 20 seconds (a reasonable, but\n   arbitrary value) to process the server SHOULD return a 102\n   \"Processing\" response.\n\n9.2 207 Multi-Status\n\n   The response provides status for multiple independent operations.\n\n9.3 422 Unprocessable Entity\n\n   The server understands the content type of the request entity, but\n   was unable to process the contained instructions.\n\n9.4 423 Insufficient Space on Resource\n\n   The resource does not have sufficient space to record the state of\n   the resource after the execution of this method.\n\n9.5 424 Method Failure\n\n   The method was not executed on a particular resource within its\n   scope because some part of the method's execution failed causing the\n   entire method to be aborted.  For example, if a resource could not\n   be moved as part of a MOVE method, all the other resources would\n   fail with a 424 Method Failure.\n\n9.6 425 Locked\n\n   The source or destination resource of a method is locked, and either\n   the request did not contain a valid Lock-Token header, or the lock\n   token in the Lock-Token header identifies a lock held by another\n   principal.\n\n\n10 Multi-Status Response\n\n   The default 207 Multi-Status response body is a text/xml HTTP entity\n   that contains a single XML element called multistatus, which\n   contains a set of XML elements called response, one for each 200,\n   300, 400, and 500 series status code generated during the method\n   invocation.  100 series status codes MUST NOT be recorded in a\n   response XML element.\n\n\n11 XML Element Definitions\n\n   In the section below, the final line of each section gives the\n   element type declaration using the format defined in [Bray, Paoli,\n   Sperberg-McQueen, 1998]. The \"Value\" field, where present, specifies\n   futher restrictions on the allowable contents of the XML element\n   using BNF (i.e., to further restrict the values of a PCDATA\n   element).\n\nGoland et al.                                                [Page 55]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n11.1 activelock XML Element\n\n   Name:       activelock\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Describes a lock on a resource.\n\n   <!ELEMENT activelock (locktype, lockscope, depth?, owner, timeout,\n   locktoken) >\n\n11.1.1    depth XML Element\n\n   Name:       depth\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    The value of the depth header used to create a lock.\n   Description: If this element is not included in a lockinfo element\n   then the client MUST assume that the lock is of depth 0.\n   Value:      \"0\" | \"infinity\"\n\n   <!ELEMENT depth (#PCDATA) >\n\n11.1.2    locktoken XML Element\n\n   Name:       locktoken\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    The lock token associated with a lock.\n   Description: The href contains an opaque lock token URI (i.e., the\n   OpaqueLockToken-URI production in Section 4.4).\n\n   <!ELEMENT locktoken (href) >\n\n11.1.3    timeout XML Element\n\n   Name:       timeout\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    The timeout associated with a lock\n   Value:      TimeType\n\n   <!ELEMENT timeout (#PCDATA) >\n\n11.2 collection XML Element\n\n   Name:       collection\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Identifies the associated resource as a collection. The\n   resourcetype property of a collection resource MUST have this value.\n\n   <!ELEMENT collection EMPTY >\n\n11.3 href XML Element\n\n   Name:       href\n\nGoland et al.                                                [Page 56]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Identifies the content of the element as a URI.\n   Value:      URI ; See section 3.2.1 of [Fielding et al., 1997]\n\n   <!ELEMENT href (#PCDATA)>\n\n11.4 link XML Element\n\n   Name:       link\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Identifies the property as a link and contains the\n   source and destination of that link.\n   Description: The link XML element is used to provide the sources and\n   destinations of a link.  The name of the property containing the\n   link XML element provides the type of the link.  Link is a multi-\n   valued element, so multiple links may be used together to indicate\n   multiple links with the same type.\n\n   <!ELEMENT link (src+, dst+) >\n\n11.4.1    dst XML Element\n\n   Name:       dst\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Indicates the destination of a link\n   Value:      URI\n\n   <!ELEMENT dst (#PCDATA) >\n\n11.4.2    src XML Element\n\n   Name:       src\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Indicates the source of a link.\n   Value:      URI\n\n   <!ELEMENT src (#PCDATA) >\n\n11.5 lockentry XML Element\n\n   Name:       lockentry\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Defines the types of locks that can be used with the\n   resource.\n\n   <!ELEMENT lockentry (lockscope, locktype) >\n\n11.6 lockinfo XML Element\n\n   Name:       lockinfo\n   Namespace:  http://www.iana.org/standards/dav/\n\n\nGoland et al.                                                [Page 57]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Purpose:    The lockinfo XML element is used with a LOCK method to\n   specify the type of lock the client wishes to have created.\n\n   <!ELEMENT lockinfo (lockscope, locktype, owner?) >\n\n11.7 lockscope XML Element\n\n   Name:       lockscope\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies whether a lock is an exclusive lock, or a\n   shared lock.\n\n   <!ELEMENT lockscope (exclusive | shared) >\n\n11.7.1    exclusive XML Element\n\n   Name:       exclusive\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies an exclusive lock\n\n   <!ELEMENT exclusive EMPTY >\n\n11.7.2    shared XML Element\n\n   Name:       shared\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies a shared lock\n\n   <!ELEMENT shared EMPTY >\n\n11.8 locktype XML Element\n\n   Name:       locktype\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies the access type of a lock.  At present, this\n   specification only defines one lock type, the write lock.\n\n   <!ELEMENT locktype (write) >\n\n11.8.1    write XML Element\n\n   Name:       write\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies a write lock.\n\n   <!ELEMENT write EMPTY >\n\n11.9 multistatus XML Element\n\n   Name:       multistatus\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains multiple response messages.\n\nGoland et al.                                                [Page 58]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Description: The responsedescription at the top level is used to\n   provide a general message describing the overarching nature of the\n   response.  If this value is available an application MAY use it\n   instead of presenting the individual response descriptions contained\n   within the responses.\n\n   <!ELEMENT multistatus (response+, responsedescription?) >\n\n11.9.1    response XML Element\n\n   Name:       response\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Holds a single response describing the effect of a\n   method on resource and/or its properties.\n   Description: A particular href MUST NOT appear more than once as the\n   child of a response XML element under a multistatus XML element.\n   This requirement is necessary in order to keep processing costs for\n   a response to linear time.  Essentially, this prevents having to\n   search in order to group together all the responses by href.  There\n   are, however, no requirements regarding ordering based on href\n   values.\n\n   <!ELEMENT response (href, ((href*, status)|(propstat+)),\n   responsedescription?) >\n\n11.9.1.1  propstat XML Element\n\n   Name:       propstat\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Groups together a prop and status element that is\n   associated with a particular href element.\n   Description: Prop MUST contain one or more empty XML elements\n   representing the names of properties.  Multiple properties may be\n   included if the same response applies to them all.\n\n   <!ELEMENT propstat (prop, status) >\n\n11.9.1.2  status XML Element\n\n   Name:       status\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Holds a single HTTP status-line\n   Value:      status-line   ;status-line defined in [Fielding et al.,\n   1997]\n\n   <!ELEMENT status (#PCDATA) >\n\n11.9.2    responsedescription XML Element\n\n   Name:       responsedescription\n   Namespace:  http://www.iana.org/standards/dav/\n\n\nGoland et al.                                                [Page 59]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Purpose:    Contains a message that can be displayed to the user\n   explaining the nature of the response.\n   Description: This XML element provides information suitable to be\n   presented to a user.\n\n   <!ELEMENT responsedescription (#PCDATA) >\n\n11.10     owner XML Element\n\n   Name:       owner\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Provides information about the principal taking out a\n   lock.\n   Description: The owner XML element provides information sufficient\n   for either directly contacting a principal (such as a telephone\n   number or Email URI), or for discovering the principal (such as the\n   URL of a homepage) who owns a lock.\n\n   <!ELEMENT owner (#PCDATA, ANY)* >\n\n11.11     prop XML element\n\n   Name:       prop\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains properties related to a resource.\n   Description: The prop XML element is a generic container for\n   properties defined on resources.  All elements inside prop MUST\n   define properties related to the resource.  No other elements may be\n   used inside of a prop element.\n\n   <!ELEMENT prop ANY>\n\n11.12     propertybehavior XML element\n\n   Name:       propertybehavior\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies how properties are handled during a COPY or\n   MOVE.\n   Description: The propertybehavior XML element specifies how\n   properties are handled during a COPY or MOVE.  If this XML element\n   is not included in the request body then the server is expected to\n   act as defined by the default property handling behavior of the\n   associated method.\n\n   <!ELEMENT propertybehavior (omit | keepalive) >\n\n11.12.1   keepalive XML element\n\n   Name:       keepalive\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies requirements for the copying/moving of live\n   properties.\n\nGoland et al.                                                [Page 60]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Description: If a list of URIs is included as the value of keepalive\n   then the named properties MUST be \"live\" after they are copied\n   (moved) to the destination resource of a COPY (or MOVE).  If the\n   value \"*\" is given for the keepalive XML element, this designates\n   that all live properties on the source resource MUST be live on the\n   destination.\n   Value:      \"*\" ; #PCDATA value can only be \"*\"\n\n   <!ELEMENT keepalive (#PCDATA | href+) >\n\n11.12.2   omit XML element\n\n   Name:       omit\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Indicates that the associated method MAY succeed even if\n   the server is not able to copy/move every property on the source\n   resource, even in a dead form.\n   Description: The default behavior for a COPY or MOVE is to copy/move\n   all properties or fail the method.  In certain circumstances, such\n   as when a server copies a resource over another protocol such as\n   FTP, it may not be possible to copy/move the properties associated\n   with the resource. Thus any attempt to copy/move over FTP would\n   always have to fail because properties could not be moved over, even\n   as dead properties. The omit XML element instructs the server that\n   it should use best effort to copy properties but a failure to copy a\n   property should not cause the method to fail.\n\n   <!ELEMENT omit EMPTY >\n\n11.13     propertyupdate XML element\n\n   Name:       propertyupdate\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains a request to alter the properties on a\n   resource.\n   Description: This XML element is a container for the information\n   required to modify the properties on the resource.  This XML element\n   is multi-valued.\n\n   <!ELEMENT propertyupdate (remove | set)+ >\n\n11.13.1   remove XML element\n\n   Name:       remove\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Lists the DAV properties to be removed from a resource.\n   Description: Remove instructs that the properties specified in prop\n   should be removed.  Specifying the removal of a property that does\n   not exist is not an error.  All the XML elements in prop MUST be\n   empty, as only the names of properties to be removed are required.\n\n   <!ELEMENT remove (prop) >\n\nGoland et al.                                                [Page 61]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n11.13.2   set XML element\n\n   Name:       set\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Lists the DAV property values to be set for a resource.\n   Value:      prop\n   Description: This XML element MUST contain only a prop XML element.\n   The elements contained by prop specify the name and value of\n   properties that are set on the Request-URI.  If a property already\n   exists then its value is replaced.\n\n   <!ELEMENT set (prop) >\n\n11.14     propfind XML Element\n\n   Name:       propfind\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies the properties to be returned from a PROPFIND\n   method.  Two special elements are specified for use with propfind,\n   allprop and propname.\n\n   <!ELEMENT propfind (allprop | propname | href+) >\n\n11.14.1   allprop XML Element\n\n   Name:       allprop\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    The allprop XML element specifies that all property\n   names and values on the resource are to be returned.\n\n   <!ELEMENT allprop EMPTY >\n\n11.14.2   propname XML Element\n\n   Name:       propname\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose: the propname XML element specifies that only a list of\n   property names on the resource is to be returned.\n\n   <!ELEMENT propname EMPTY >\n\n\n12 DAV Properties\n\n   For DAV properties, the name of the property is also the same as the\n   name of the XML element which contains its value. In the section\n   below, the final line of each section gives the element type\n   declaration using the format defined in [Bray, Paoli, Sperberg-\n   McQueen, 1998]. The \"Value\" field, where present, specifies futher\n   restrictions on the allowable contents of the XML element using BNF\n   (i.e., to further restrict the values of a PCDATA element).\n\nGoland et al.                                                [Page 62]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n12.1 creationdate Property\n\n   Name:       creationdate\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Records the time and date the resource was created.\n   Value:      ;The time and date MUST be given in ISO 8601 format\n   defined in Appendix 2\n   Description: This property SHOULD be defined on all DAV compliant\n   resources.  If present, it contains a timestamp of the moment when\n   the resource was created (i.e., the moment it had non-null state).\n\n   <!ELEMENT creationdate (#PCDATA) >\n\n12.2 displayname Property\n\n   Name:       displayname\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Provies a name for the resource that is suitable for\n   presentation to a user.\n   Description: This property SHOULD be defined on all DAV compliant\n   resources.  If present, the property contains a description of the\n   resource that is suitable for presentation to a user.\n\n   <!ELEMENT displayname (#PCDATA) >\n\n12.3 externalmembers Property\n\n   Name:       externalmembers\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Provides the list of external members defined on the\n   resource.\n   Description: This property MUST be defined on any DAV compliant\n   resource with external members.  If defined it MUST contain the full\n   list of external members.  Resources MAY make this property read-\n   only, thus only allowing its value to be altered using the\n   ADDREF/DELREF methods.\n\n   <!ELEMENT externalmembers (href*) >\n\n12.4 getcontentlanguage Property\n\n   Name:       getcontentlanguage\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains the Content-Language header returned by a GET\n   without accept headers\n   Description: This property MUST be defined on any DAV compliant\n   resource which supports GET, with the exception that if no Content-\n   Language header is available, this property MUST NOT exist.\n   Value:      language-tag   ;language-tag is defined in section 14.13\n   of [Fielding et al., 1997]\n\n\nGoland et al.                                                [Page 63]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   <!ELEMENT getcontentlanguage (#PCDATA) >\n\n12.5 getcontentlength Property\n\n   Name:       getcontentlength\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains the Content-Length header returned by a GET\n   without accept headers.  If no Content-Length header is available,\n   this property MUST NOT exist.\n   Description: This property MUST be defined on any DAV compliant\n   resource which returns the Content-Length header in response to a\n   GET.\n   Value:      content-length ; see section 14.14 of [Fielding et al.,\n   1997]\n\n   <!ELEMENT getcontentlength (#PCDATA) >\n\n12.6 getcontenttype Property\n\n   Name:       getcontenttype\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains the Content-Type header returned by a GET\n   without accept headers.  If no Content-Type header is available,\n   this property MUST NOT exist.\n   Description: This property MUST be defined on any DAV compliant\n   resource which returns the Content-Type header in response to a GET.\n   Value:      media-type   ; defined in Section 3.7 of [Fielding et\n   al., 1997]\n\n   <!ELEMENT getcontenttype (#PCDATA) >\n\n12.7 getetag Property\n\n   Name:       getetag\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains the ETag header returned by a GET without\n   accept headers.\n   Description: Note that the ETag on a resource may reflect changes in\n   any part of the state of the resource, not necessarily just a change\n   to the response to the GET method.  For example, a change to a\n   resource's access permissions may cause the ETag to change. This\n   property MUST be defined on any DAV compliant resource which returns\n   the Etag header in response to a GET, except for the case if no ETag\n   header is returned, this property MUST NOT exist.\n   Value:      entity-tag  ; defined in Section 3.11 of [Fielding et\n   al., 1997]\n\n   <!ELEMENT getetag (#PCDATA) >\n\n12.8 getlastmodified Property\n\n   Name:       getlastmodified\n\nGoland et al.                                                [Page 64]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Contains the Last-Modified header returned by a GET\n   method without accept headers.\n   Description: Note that the last-modified date on a resource may\n   reflect changes in any part of the state of the resource, not\n   necessarily just a change to the response to the GET method.  For\n   example, a change in a property may cause the last-modified date to\n   change. This property MUST be defined on any DAV compliant resource\n   which returns the Last-Modified header in response to a GET, except\n   for the case if no Last-Modified header is returned, this property\n   MUST NOT exist.\n   Value:      HTTP-date  ; defined in Section 3.3.1 of [Fielding et\n   al., 1997]\n\n   <!ELEMENT getlastmodified (#PCDATA) >\n\n12.9 lockdiscovery Property\n\n   Name:       lockdiscovery\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Describes the active locks on a resource\n   Description: The lockdiscovery property returns a listing of who has\n   a lock, what type of lock he has, the timeout type and the time\n   remaining on the timeout, and the associated lock token.  The server\n   is free to withhold any or all of this information if the requesting\n   principal does not have sufficient access rights to see the\n   requested data.  A server which supports locks MUST provide the\n   lockdiscovery property on any resource with locks on it.\n\n   <!ELEMENT lockdiscovery (activelock)* >\n\n12.9.1    Example\n\n   >>Request\n\n   PROPFIND /container/ HTTP/1.1\n   Host: www.foo.bar\n   Content-Length: xxxx\n   Content-Type: text/xml\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:propfind>\n     <D:prop><lockdiscovery/></D:prop>\n\n   </D:propfind>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n\nGoland et al.                                                [Page 65]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:multistatus>\n     <D:response>\n       <D:propstat>\n          <D:prop>\n            <D:lockdiscovery>\n              <D:activelock>\n                <D:locktype>write</D:locktype>\n                <D:lockscope>exclusive</D:lockscope>\n                <D:Depth>0</D:Depth>\n                <D:owner>Jane Smith</D:owner>\n                <D:timeout>Infinite</D:timeout>\n                <D:locktoken>\n                    <D:href>\n                  opaquelocktoken:f81de2ad-7f3d-a1b2-4f3c-00a0c91a9d76\n                    </D:href>\n                </D:locktoken>\n              </D:activelock>\n            </D:lockdiscovery>\n          </D:prop>\n          <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n   </D:multistatus>\n\n   This resource has a single exclusive write lock on it, with an\n   infinite timeout.  Note that the Depth element could have been\n   omitted as 0 is the default value of Depth.\n\n12.10     resourcetype Property\n\n   Name:       resourcetype\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    Specifies the nature of the resource.\n   Description: This property MUST be defined on all DAV compliant\n   resources.  The default value is empty.\n\n   <!ELEMENT resourcetype ANY >\n\n12.11     source Property\n\n   Name:       source\n   Namespace:  http://www.iana.org/standards/dav/link/\n   Purpose:    The destination of the source link identifies the\n   resource that contains the unprocessed source of the link's source.\n   Description: The source of the link (src) is typically the URI of\n   the output resource on which the link is defined, and there is\n   typically only one destination (dst) of the link, which is the URI\n   where the unprocessed source of the resource may be accessed.  When\n   more than one link destination exists, this specification asserts no\n   policy on ordering.\n\nGoland et al.                                                [Page 66]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   <!ELEMENT source (link)* >\n\n12.11.1   Example\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.foocorp.com/Project/\" as=\"F\"?>\n   <D:prop>\n     <D:source>\n          <D:link>\n               <F:projfiles>Source</F:projfiles>\n               <D:src>http://foo.bar/program</D:src>\n               <D:dst>http://foo.bar/src/main.c</D:dst>\n          </D:link>\n          <D:link>\n               <F:projfiles>Library</F:projfiles>\n               <D:src>http://foo.bar/program</D:src>\n               <D:dst>http://foo.bar/src/main.lib</D:dst>\n          </D:link>\n          <D:link>\n               <F:projfiles>Makefile</F:projfiles>\n               <D:src>http://foo.bar/program</D:src>\n               <D:dst>http://foo.bar/src/makefile</D:dst>\n          </D:link>\n     </D:source>\n   </D:prop>\n\n   In this example the resource http://foo.bar/program has a source\n   property that contains three links.  Each link contains three\n   elements, two of which, src and dst, are part of the DAV schema\n   defined in this document, and one which is defined by the schema\n   http://www.foocorp.com/project/ (Source, Library, and Makefile).  A\n   client which only implements the elements in the DAV spec will not\n   understand the foocorp elements and will ignore them, thus seeing\n   the expected source and destination links.  An enhanced client may\n   know about the foocorp elements and be able to present the user with\n   additional information about the links.  This example demonstrates\n   the power of XML markup, allowing element values to be enhanced\n   without breaking older clients.\n\n12.12     supportedlock Property\n\n   Name:       supportedlock\n   Namespace:  http://www.iana.org/standards/dav/\n   Purpose:    To provide a listing of the lock capabilities supported\n   by the resource.\n   Description: The supportedlock property of a resource returns a\n   listing of the combinations of scope and access types which may be\n   specified in a lock request on the resource.  Note that the actual\n   contents are themselves controlled by access controls so a server is\n   not required to provide information the client is not authorized to\n\nGoland et al.                                                [Page 67]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   see.  If supportedlock is available on \"*\" then it MUST define the\n   set of locks allowed on all resources on that server.\n\n   <!ELEMENT supportedlock (lockentry)* >\n\n12.12.1   Example\n\n   >>Request\n\n   PROPFIND  /container/ HTTP/1.1\n   Host: www.foo.bar\n   Content-Length: xxxx\n   Content-Type: text/xml\n\n\n   <?xml version=\"1.0\"?>\n   <?namespace href=\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:propfind>\n     <D:prop><supportedlock/></D:prop>\n   </D:propfind>\n\n   >>Response\n\n   HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml\n   Content-Length: xxxxx\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:multistatus>\n     <D:response>\n       <D:propstat>\n         <D:prop>\n           <D:supportedlock>\n             <D:LockEntry>\n               <D:locktype><D:Write/></D:locktype>\n               <D:lockscope><D:Exclusive/></D:lockscope>\n             </D:LockEntry>\n             <D:LockEntry>\n               <D:locktype><D:Write/></D:locktype>\n               <D:lockscope><D:Shared/></D:lockscope>\n             </D:LockEntry>\n           </D:supportedlock>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n   </D:multistatus>\n\n\n13 DAV Compliance Classes\n\n\nGoland et al.                                                [Page 68]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   A DAV compliant resource can choose from two classes of compliance.\n   A client can discover the compliance classes of a resource by\n   executing OPTIONS on the resource, and examining the \"DAV\" header\n   which is returned.\n\n   Since this document describes extensions to the HTTP/1.1 protocol,\n   minimally all DAV compliant resources, clients, and proxies MUST be\n   compliant with [Fielding et al., 1997].\n\n   Compliance classes are not necessarily sequential. A resource that\n   is class 2 compliant MUST also be class 1 compliant; but if\n   additional compliance classes are defined later, a resource that is\n   class 1, 2, and 4 compliant might not be class 3 compliant.\n\n13.1 Class 1\n\n   A class 1 compliant resource MUST meet all \"MUST\" requirements in\n   all sections of this document.\n\n   Class 1 compliant resources MUST return, at minimum, the value \"1\"\n   in the DAV header on all responses to the OPTIONS method.\n\n13.2 Class 2\n\n   A class 2 compliant resource MUST meet all class 1 requirements and\n   support the supportedlock property as well as the LOCK method. It\n   MUST also support the lockdiscovery property, since Section 12.9\n   specifies that the LOCK method MUST also support the lockdiscovery\n   property.\n\n   Class 2 compliant resources MUST return, at minimum, the value \"2\"\n   in the DAV header on all responses to the OPTIONS method.\n\n\n14 Internationalization Considerations\n\n   In the realm of internationalization, this specification complies\n   with the IETF Character Set Policy [Alvestrand, 1998]. In this\n   specification, human-readable fields can be found either in the\n   value of a property, or in an error message returned in a response\n   entity body.  In both cases, the human-readable content is encoded\n   using XML, which has explicit provisions for character set tagging\n   and encoding, and requires that XML processors read XML elements\n   encoded using the UTF-8 and UCS-2 encodings of the ISO 10646 basic\n   multilingual plane.  Furthermore, XML contains provisions for\n   encoding XML elements using other encoding schemes, notable among\n   them UCS-4, which permits encoding of characters from any ISO 10646\n   character plane.\n\n   The default character set encoding for XML data in this\n   specification, and in general, is UTF-8.  WebDAV compliant\n   applications MUST support the UTF-8 and UCS-2 character set\n\nGoland et al.                                                [Page 69]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   encodings for XML elements, and SHOULD support the UCS-4 encoding.\n   The XML character set encoding declaration for each supported\n   character set MUST also be supported, since it is by using this\n   encoding declaration that an XML processor determines the encoding\n   of an element.\n\n   XML also provides a language tagging capability for specifying the\n   language of the contents of a particular XML element.  XML uses\n   either IANA registered language tags (see RFC 1766, [Alvestrand,\n   1995]) or ISO 639 language tags [ISO-639] in the \"xml:lang\"\n   attribute of an XML element to identify the language its content and\n   attributes.\n\n   Names used within this specification fall into three categories:\n   names of protocol elements such as methods and headers, names of XML\n   elements, and names of properties.  Naming of protocol elements\n   follows the precedent of HTTP, using English names encoded in\n   USASCII for methods and headers.  Since these protocol elements are\n   not visible to users, and are in fact simply long token identifiers,\n   they do not need to support encoding in multiple character sets.\n   Similarly, though the names of XML elements used in this\n   specification are English names encoded in UTF-8, these names are\n   not visible to the user, and hence do not need to support multiple\n   character set encodings.\n\n   The name of a property defined on a resource is a URI.  Although\n   some applications (e.g., a generic property viewer) will display\n   property URIs directly to their users, it is expected that the\n   typical application will use a fixed set of properties, and will\n   provide a mapping from the property name URI to a human-readable\n   field when displaying the property name to a user.  It is only in\n   the case where the set of properties is not known ahead of time that\n   an application need display a property name URI to a user. We\n   recommend that applications provide human-readable property names\n   wherever feasible.\n\n   For error reporting, we follow the convention of HTTP/1.1 status\n   codes, including with each status code a short, English description\n   of the code (e.g., 425 Locked).  While the possibility exists that a\n   poorly crafted user agent would display this message to a user,\n   internationalized applications will ignore this message, and display\n   an appropriate message in the user's language and character set.\n\n   Since interoperation of clients and servers does not require locale\n   information, this specification does not specify any mechanism for\n   transmission of this information.\n\n\n15 Security Considerations\n\n   This section is provided to detail issues concerning security\n   implications of which WebDAV applications need to be aware.\n\nGoland et al.                                                [Page 70]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   All of the security considerations of HTTP/1.1 also apply to WebDAV.\n   In addition, the security risks inherent in remote authoring require\n   stronger authentication technology, and introduce several new\n   privacy concerns, and may increase the hazards from poor server\n   design. These issues are detailed below.\n\n15.1 Authentication of Clients\n\n   Due to their emphasis on authoring, WebDAV servers need to use\n   authentication technology to protect not just access to a network\n   resource, but the integrity of the resource as well.  Furthermore,\n   the introduction of locking functionality requires support for\n   authentication.\n\n   A password sent in the clear over an insecure channel is an\n   inadequate means for protecting the accessibility and integrity of a\n   resource as the password may be intercepted.  Since Basic\n   authentication for HTTP/1.1 performs essentially clear text\n   transmission of a password, Basic authentication MUST NOT be used to\n   authenticate a WebDAV client to a server unless the connection is\n   secure. Furthermore, a WebDAV server MUST NOT send Basic\n   authentication credentials in a WWW-Authenticate header unless the\n   connection is secure.  Examples of secure connections include a\n   Transport Layer Security (TLS) connection, or a connection over a\n   network which is physically secure, for example, an isolated network\n   in a building with restricted access.\n\n   WebDAV applications MUST support the Digest authentication scheme\n   [Franks, et al., 1997]. Since Digest authentication verifies that\n   both parties to a communication know a shared secret, a password,\n   without having to send that secret in the clear, Digest\n   authentication avoids the security problems inherent in Basic\n   authentication while providing a level of authentication which is\n   useful in a wide range of scenarios.\n\n15.2 Denial of Service\n\n   Denial of service attacks are of special concern to WebDAV servers.\n   WebDAV plus HTTP enables denial of service attacks on every part of\n   a system's resources.\n\n   The underlying storage can be attacked by PUTting extremely large\n   files.\n\n   Asking for recursive operations on large collections can attack\n   processing time.\n\n   Making multiple pipelined requests on multiple connections can\n   attack network connections.\n\n\n\nGoland et al.                                                [Page 71]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   WebDAV servers need to be aware of the possibility of a denial of\n   service attack at all levels.\n\n15.3 Security through Obscurity\n\n   WebDAV provides, through the PROPFIND method, a mechanism for\n   listing the member resources of a collection.  This greatly\n   diminishes the effectiveness of security or privacy techniques which\n   rely only on the difficulty of discovering the names of network\n   resources.  Users of WebDAV servers are encouraged to use access\n   control techniques to prevent unwanted access to resources, rather\n   than depending on the relative obscurity of their resource names.\n\n15.4 Privacy Issues Connected to Locks\n\n   When submitting a lock request a user agent may also submit an owner\n   XML field giving contact information for the person taking out the\n   lock (for those cases where a person, rather than a robot, is taking\n   out the lock). This contact information is stored in a lockdiscovery\n   property on the resource, and can be used by other collaborators to\n   begin negotiation over access to the resource.  However, in many\n   cases this contact information can be very private, and should not\n   be widely disseminated.  Servers SHOULD limit read access to the\n   lockdiscovery property as appropriate.  Furthermore, user agents\n   SHOULD provide control over whether contact information is sent at\n   all, and if contact information is sent, control over exactly what\n   information is sent.\n\n15.5 Privacy Issues Connected to Properties\n\n   Since property values are typically used to hold information such as\n   the author of a document, there is the possibility that privacy\n   concerns could arise stemming from widespread access to a resource's\n   property data.  To reduce the risk of inadvertent release of private\n   information via properties, servers are encouraged to develop access\n   control mechanisms that separate read access to the resource body\n   and read access to the resource's properties.  This allows a user to\n   control the dissemination of their property data without overly\n   restricting access to the resource's contents.\n\n15.6 Reduction of Security due to Source Link\n\n   HTTP/1.1 warns against providing read access to script code because\n   it may contain sensitive information.  Yet WebDAV, via its source\n   link facility, can potentially provide a URL for script resources so\n   they may be authored.  For HTTP/1.1, a server could reasonably\n   prevent access to source resources due to the predominance of read-\n   only access.  WebDAV, with its emphasis on authoring, encourages\n   read and write access to source resources, and provides the source\n   link facility to identify the source.  This reduces the security\n   benefits of eliminating access to source resources.  Users and\n   administrators of WebDAV servers should be very cautious when\n\nGoland et al.                                                [Page 72]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   allowing remote authoring of scripts, limiting read and write access\n   to the source resources to authorized principals.\n\n\n16 IANA Considerations\n\n   This document defines two namespaces, the namespace of property\n   names, and the namespace of WebDAV-specific XML elements used within\n   property values.\n\n   URLs are used for both names, for several reasons. Assignment of a\n   URL does not require a request to a central naming authority, and\n   hence allow WebDAV property names and XML elements to be quickly\n   defined by any WebDAV user or application.  URLs also provide a\n   unique address space, ensuring that the distributed users of WebDAV\n   will not have collisions among the property names and XML elements\n   they create.\n\n   This specification defines a distinguished set of property names and\n   XML elements which are understood by all WebDAV applications.  The\n   property names and XML elements in this specification are all\n   derived from the base URL: http://www.iana.org/standards/dav/ by\n   adding a suffix to this URL, for example,\n   http://www.iana.org/standards/dav/creationdate for the\n   \"creationdate\" property.\n\n   To ensure correct interoperation of this specification, IANA MUST\n   reserve the URL namespace starting with\n   http://www.iana.org/standards/dav/ for use by this specification,\n   its revisions, and related WebDAV specifications.\n\n\n17 Terminology\n\n   Collection - A resource that contains member resources.\n\n   Member Resource - A resource contained by a collection.  There are\n   two types of member resources: external and internal.\n\n   Internal Member Resource - A member resource of a collection whose\n   URI is relative to the URI of the collection.\n\n   External Member Resource - A member resource of a collection with an\n   absolute URI that is not relative to its parent's URI.\n\n   Property - A name/value pair that contains descriptive information\n   about a resource.\n\n   Live Property - A property whose semantics and syntax are enforced\n   by the server.  For example, a live \"content-length\" property would\n   have its value, the length of the entity returned by a GET request,\n   automatically calculated by the server.\n\nGoland et al.                                                [Page 73]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   Dead Property - A property whose semantics and syntax are not\n   enforced by the server.  The server only records the value of a dead\n   property; the client is responsible for maintaining the consistency\n   of the syntax and semantics of a dead property.\n\n\n18 Copyright\n\n   The following copyright notice is copied from RFC 2026 [Bradner,\n   1996], Section 10.4, and describes the applicable copyright for this\n   document.\n\n   Copyright (C) The Internet Society January 18, 1998. All Rights\n   Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph\n   are included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English.\n\n   The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assignees.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\n\n19 Intellectual Property\n\n   The following notice is copied from RFC 2026 [Bradner, 1996],\n   Section 10.4, and describes the position of the IETF concerning\n   intellectual property claims made against this document.\n\n   The IETF takes no position regarding the validity or scope of any\n   intellectual property or other rights that might be claimed to\n   pertain to the implementation or use other technology described in\n   this document or the extent to which any license under such rights\n   might or might not be available; neither does it represent that it\n\nGoland et al.                                                [Page 74]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   has made any effort to identify any such rights.  Information on the\n   IETF's procedures with respect to rights in standards-track and\n   standards-related documentation can be found in BCP-11.  Copies of\n   claims of rights made available for publication and any assurances\n   of licenses to be made available, or the result of an attempt made\n   to obtain a general license or permission for the use of such\n   proprietary rights by implementors or users of this specification\n   can be obtained from the IETF Secretariat.\n\n   The IETF invites any interested party to bring to its attention any\n   copyrights, patents or patent applications, or other proprietary\n   rights which may cover technology that may be required to practice\n   this standard.  Please address the information to the IETF Executive\n   Director.\n\n\n20 Acknowledgements\n\n   A specification such as this thrives on piercing critical review and\n   withers from apathetic neglect.  The authors gratefully acknowledge\n   the contributions of the following people, whose insights were so\n   valuable at every stage of our work.\n\n   Terry Allen, Harald Alvestrand, Alan Babich, Dylan Barrell, Bernard\n   Chester, Tim Berners-Lee, Dan Connolly, Jim Cunningham, Ron Daniel,\n   Jr., Jim Davis, Keith Dawson, Mark Day, Brian Deen, Martin Duerst,\n   David Durand, Lee Farrell, Chuck Fay, Roy Fielding, Mark Fisher,\n   Alan Freier, George Florentine, Jim Gettys, Phill Hallam-Baker,\n   Dennis Hamilton, Steve Henning, Alex Hopmann, Andre van der Hoek,\n   Ben Laurie, Paul Leach, Ora Lassila, Karen MacArthur, Steven Martin,\n   Larry Masinter, Michael Mealling, Keith Moore, Henrik Nielsen, Kenji\n   Ota, Bob Parker, Glenn Peterson, Jon Radoff, Saveen Reddy, Henry\n   Sanders, Christopher Seiwald, Judith Slein, Mike Spreitzer, Einar\n   Stefferud, Ralph Swick, Kenji Takahashi, Richard N. Taylor, Robert\n   Thau, John Turner, Sankar Virdhagriswaran, Fabio Vitali, Gregory\n   Woodhouse, and Lauren Wood.\n\n   Two from this list deserve special mention.  The contributions by\n   Larry Masinter have been invaluable, both in helping the formation\n   of the working group and in patiently coaching the authors along the\n   way.  In so many ways he has set high standards we have toiled to\n   meet. The contributions of Judith Slein in clarifying the\n   requirements, and in patiently reviewing draft after draft, both\n   improved this specification and expanded our minds on document\n   management.\n\n   We would also like to thank John Turner for developing the XML DTD.\n\n\n\n\n\n\nGoland et al.                                                [Page 75]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n21 References\n\n   [Alvestrand, 1995] H. T. Alvestrand, \"Tags for the Identification of\n   Languages.\" RFC 1766. Uninett. March, 1995.\n\n   [Alvestrand, 1998] H. T. Alvestrand, \"IETF Policy on Character Sets\n   and Languages.\" RFC XXXX, BCP YY. Maxware. January, 1998.\n\n   [Bradner, 1996] S. Bradner, \"The Internet Standards Process -\n   Revision 3.\"  RFC 2026, BCP 9. Harvard University. October, 1996.\n\n   [Bradner, 1997] S. Bradner, \"Key words for use in RFCs to Indicate\n   Requirement Levels.\"  RFC 2119, BCP 14. Harvard University. March,\n   1997.\n\n   [Bray, Paoli, Sperberg-McQueen, 1998] T. Bray, J. Paoli, C. M.\n   Sperberg-McQueen, \"Extensible Markup Language (XML).\" World Wide Web\n   Consortium Recommendation REC-XML-ZZZZ. http://www.w3.org/TR/PR-xml-\n   971208.\n\n   [Fielding et al., 1997] R. Fielding, J. Gettys, J. Mogul, H.\n   Frystyk, T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1.\"\n   RFC 2068. U.C. Irvine, DEC, MIT/LCS.  January, 1997.\n\n   [ISO-639] ISO (International Organization for Standardization). ISO\n   639:1988. \"Code for the representation of names of languages.\"\n\n   [ISO-8601] ISO (International Organization for Standardization). ISO\n   8601:1988. \"Data elements and interchange formats - Information\n   interchange - Representation of dates and times.\"\n\n   [Lasher, Cohen, 1995] R. Lasher, D. Cohen, \"A Format for\n   Bibliographic Records,\" RFC 1807. Stanford, Myricom. June, 1995.\n\n   [Leach, Salz, 1997] P. J. Leach, R. Salz, \"UUIDs and GUIDs.\"\n   Internet-draft (expired), work-in-progress, February, 1997.\n   http://www.internic.net/internet-drafts/draft-leach-uuids-guids-\n   00.txt\n\n   [MARC, 1994] Network Development and MARC Standards, Office, ed.\n   1994. \"USMARC Format for Bibliographic Data\", 1994. Washington, DC:\n   Cataloging Distribution Service, Library of Congress.\n\n   [Miller et al., 1996] J. Miller, T. Krauskopf, P. Resnick, W.\n   Treese, \"PICS Label Distribution Label Syntax and Communication\n   Protocols\" Version 1.1, World Wide Web Consortium Recommendation\n   REC-PICS-labels-961031. http://www.w3.org/pub/WWW/TR/REC-PICS-\n   labels-961031.html.\n\n   [Slein et al., 1997] J. A. Slein, F. Vitali, E. J. Whitehead, Jr.,\n   D. Durand, \"Requirements for Distributed Authoring and Versioning\n\n\nGoland et al.                                                [Page 76]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   Protocol for the World Wide Web.\" RFC XXXX. Xerox, Univ. of Bologna,\n   U.C. Irvine, Boston Univ. YYY, 1997.\n\n   [Weibel et al., 1995] S. Weibel, J. Godby, E. Miller, R. Daniel,\n   \"OCLC/NCSA Metadata Workshop Report.\"\n   http://purl.oclc.org/metadata/dublin_core_report.\n\n   [Yergeau, 1997] F. Yergeau, \"UTF-8, a transformation format of\n   Unicode and ISO 10646.\" RFC 2044. Alis Technologies. October, 1996.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGoland et al.                                                [Page 77]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n22 Authors' Addresses\n\n   Y. Y. Goland\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA 98052-6399\n   Email: yarong@microsoft.com\n\n   E. J. Whitehead, Jr.\n   Dept. Of Information and Computer Science\n   University of California, Irvine\n   Irvine, CA 92697-3425\n   Email: ejw@ics.uci.edu\n\n   A. Faizi\n   Netscape\n   685 East Middlefield Road\n   Mountain View, CA 94043\n   Email: asad@netscape.com\n\n   S. R. Carter\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   Email: srcarter@novell.com\n\n\n   D. Jensen\n   Novell\n   1555 N. Technology Way\n   M/S ORM F111\n   Orem, UT 84097-2399\n   Email: dcjensen@novell.com\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGoland et al.                                                [Page 78]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n23 Appendices\n\n23.1 Appendix 1 - WebDAV Document Type Definition\n\n   This section provides a document type definition, following the\n   rules in [Bray, Paoli, Sperberg-McQueen, 1998], for the XML elements\n   used in the protocol stream and in the values of properties. It\n   collects the element definitions given in Sections 11 and 12.\n\n   <!DOCTYPE webdav-1.0 [\n\n   <!--============ XML Elements from Section 11 ==================-->\n\n   <!ELEMENT activelock (locktype, lockscope, depth?, owner, timeout,\n   locktoken) >\n\n   <!ELEMENT lockentry (lockscope, locktype) >\n   <!ELEMENT lockinfo (lockscope, locktype, owner?) >\n\n   <!ELEMENT locktype (write) >\n   <!ELEMENT write EMPTY >\n\n   <!ELEMENT lockscope (exclusive | shared) >\n   <!ELEMENT exclusive EMPTY >\n   <!ELEMENT shared EMPTY >\n\n   <!ELEMENT depth (#PCDATA) >\n\n   <!ELEMENT owner (#PCDATA, ANY)* >\n\n   <!ELEMENT timeout (#PCDATA) >\n\n   <!ELEMENT locktoken (href) >\n\n   <!ELEMENT href (#PCDATA) >\n\n   <!ELEMENT link (src+, dst+) >\n   <!ELEMENT dst (#PCDATA) >\n   <!ELEMENT src (#PCDATA) >\n\n   <!ELEMENT multistatus (response+, responsedescription?) >\n\n   <!ELEMENT response (href, ((href*, status)|(propstat+)),\n   responsedescription?) >\n   <!ELEMENT status (#PCDATA) >\n   <!ELEMENT propstat (prop status) >\n   <!ELEMENT responsedescription (#PCDATA) >\n\n   <!ELEMENT prop ANY >\n\n   <!ELEMENT propertybehavior (omit | keepalive) >\n   <!ELEMENT omit EMPTY >\n\nGoland et al.                                                [Page 79]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   <!ELEMENT keepalive (#PCDATA | href+) >\n\n   <!ELEMENT propertyupdate (remove | set)+ >\n   <!ELEMENT remove (prop) >\n   <!ELEMENT set (prop) >\n\n   <!ELEMENT propfind (allprop | propname | href+) >\n   <!ELEMENT allprop EMPTY >\n   <!ELEMENT propname EMPTY >\n\n   <!ELEMENT collection EMPTY >\n\n\n   <!--=========== Property Elements from Section 12 ===============-->\n\n   <!ELEMENT creationdate (#PCDATA) >\n   <!ELEMENT displayname (#PCDATA) >\n   <!ELEMENT externalmembers (href*) >\n   <!ELEMENT getcontentlanguage (#PCDATA) >\n   <!ELEMENT getcontentlength (#PCDATA) >\n   <!ELEMENT getcontenttype (#PCDATA) >\n   <!ELEMENT getetag (#PCDATA) >\n   <!ELEMENT getlastmodified (#PCDATA) >\n   <!ELEMENT lockdiscovery (activelock)* >\n   <!ELEMENT resourcetype ANY >\n   <!ELEMENT source (link)* >\n   <!ELEMENT supportedlock (lockentry)* >\n\n   ]>\n\n23.2 Appendix 2 - ISO 8601 Date and Time Profile\n\n   The creationdate property specifies the use of the ISO 8601 date\n   format.  This section defines a profile of the ISO 8601 date format\n   for use with this specification.  This profile is quoted verbatim\n   from draft-newman-datetime-01.txt (expired).\n\n   date-time       = full-date \"T\" full-time\n\n   full-date       = date-fullyear \"-\" date-month \"-\" date-mday\n   full-time       = partial-time time-offset\n\n   date-fullyear   = 4DIGIT\n   date-month      = 2DIGIT  ; 01-12\n   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n   month/year\n   time-hour       = 2DIGIT  ; 00-23\n   time-minute     = 2DIGIT  ; 00-59\n   time-second     = 2DIGIT  ; 00-59, 00-60 based on leap second rules\n   time-secfrac    = \".\" 1*DIGIT\n   time-numoffset  = (\"+\" / \"-\") time-hour \":\" time-minute\n   time-offset     = \"Z\" / time-numoffset\n\nGoland et al.                                                [Page 80]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n\n   partial-time    = time-hour \":\" time-minute \":\" time-second\n                    [time-secfrac]\n\n\n   Numeric offsets are calculated as local time minus UTC (Coordinated\n   Universal Time).  So the equivalent time in UTC can be determined by\n   subtracting the offset from the local time.  For example, 18:50:00-\n   04:00 is the same time as 22:58:00Z.\n\n   If the time in UTC is known, but the offset to local time is\n   unknown, this can be represented with an offset of \"-00:00\".  This\n   differs from an offset of \"Z\" which implies that UTC is the\n   preferred reference point for the specified time.\n\n23.3 Appendix 3 - Notes on Processing XML Elements\n\n   XML is a flexible data format that makes it easy to submit data that\n   appears legal but in fact is not.  The philosophy of \"Be flexible in\n   what you accept and strict in what you send\" still applies, but it\n   must not be applied inappropriately.  XML is extremely flexible in\n   dealing with issues of white space, element ordering, inserting new\n   elements, etc.  This flexibility does not require extension,\n   especially not in the area of the meaning of elements.\n\n   There is no kindness in accepting illegal combinations of XML\n   elements.  At best it will cause an unwanted result and at worst it\n   can cause real damage.\n\n23.3.1    XML Syntax Error Example\n\n   The following request body for a PROPFIND method is illegal.\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <D:propfind>\n     <D:allprop/>\n     <D:propname/>\n   </D:propfind>\n\n   The definition of the propfind element only allows for the allprop\n   or the propname element, not both.  Thus the above is an error and\n   MUST be responded to with a 400 Bad Request.\n\n   Imagine, however, that a server wanted to be \"kind\" and decided to\n   pick the allprop element as the true element and respond to it.  A\n   client running over a bandwidth limited line who intended to execute\n   a propname would be in for a big surprise if the server treated the\n   command as an allprop.\n\n23.3.2    Unknown XML Element Example\n\n\nGoland et al.                                                [Page 81]\n\f\nINTERNET-DRAFT                  WebDAV                January 18, 1998\n\n\n   The previous example was illegal because it contained two elements\n   that were explicitly banned from appearing together in the propfind\n   element.  However, XML is an extensible language, so one can imagine\n   new elements being defined for use with propfind.  Below is the\n   request body of a PROPFIND and, like the previous example, MUST be\n   rejected with a 400 Bad Request by a server that does not understand\n   the expired-props element.\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.foo.bar/standards/props/\" as=\"E\"?>\n   <D:propfind>\n     <E:expired-props/>\n   </D:propfind>\n\n   To understand why a 400 Bad Request is returned let us look at the\n   request body as the server unfamiliar with expired-props sees it.\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.foo.bar/standards/props/\" as=\"E\"?>\n   <D:propfind>\n   </D:propfind>\n\n   As the server does not understand the expired-props element, by the\n   rules of XML, it MUST ignore it.  Thus the server sees an empty\n   propfind, which by the definition of the propfind element is\n   illegal.\n\n   Please note that had the extension been additive it would not\n   necessarily have resulted in a 400 Bad Request.  For example,\n   imagine the following request body for a PROPFIND:\n\n   <?xml version=\"1.0\"?>\n   <?namespace href =\"http://www.iana.org/standards/dav/\" as=\"D\"?>\n   <?namespace href=\"http://www.foo.bar/standards/props/\" as=\"E\"?>\n   <D:propfind>\n     <D:propname/>\n     <E:leave-out>*boss*</E:leave-out>\n   </D:propfind>\n\n   The previous example contains the fictitious element leave-out. Its\n   purpose is to prevent the return of any property whose name matches\n   the submitted pattern.  If the previous example were submitted to a\n   server unfamiliar with leave-out, the only result would be that the\n   leave-out element would be ignored and a propname would be executed.\n\n\n\n\n\n\n\nGoland et al.                                                [Page 82]\n\f", "encoding": "ascii"}