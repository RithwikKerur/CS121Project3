{"url": "https://www.ics.uci.edu/~eppstein/261/f03-outline/08.splay", "content": "Homework: exercises 12.2-8, 12.4-3, 13.2-4, 13.3-6; problem 18-1.\n\n\nMotivation: sequential searching in lists\n    move-to-front heuristic\n\nStatic analysis:\n\tassume inputs drawn from some random distribution\n\t\t(distr. not known => assume worst case)\n\tcompare your algorithm (which doesn't know distribut)\n\t\tto best algorithm knowing distribution\n\tfor sequential searching, best algorithm\n\t\tis to sort in order by priority\n\nCompetetive analysis: [Irani]\n\tratio your alg. to precognitive alg\n\t\ton worst-case input sequence\n\tsince w.c. seq, not w.c. dist, results are stronger than static\n\nFor move-to-front:\n\tcomparing MTF and OPT, where OPT may be assumed to know input seq\n\tas both algorithms progress, let\n\t\tPhi = #pairs x,y where x<y in MTF but x>y in OPT\n\tinitially zero, always positive\n\n\tdef amortized cost(MTF) = actual cost + Delta Phi\n\n\twhen search for item x, let\n\t\tk = #items before x in both MTF and OPT\n\t\tl = #items before x that are only in MTF\n\tthen cost(OPT) >= k\n\t     cost(MTF) = k+l (actual) + k (increase Phi) - l (decrease phi)\n\nSo MTF within factor of two of cost of any other sequential search heur!\n\n\nBack to search trees...\n\nSplay trees\n\tSleater and Tarjan 1985\n\n\tbinary search tree\n\teach node stores: left and right children\n\n\tUNLIKE other search structures so far,\n\tsearches will change structure of tree\n\tall op times (including search) amortized\n\n\tsearch(x):\n\t\tusual binary search for x,\n\t\t\tstoring list of nodes on path from root\n\t\tthen: splay -- repeatedly rotate so x=>root\n\n\t\tdouble rot: zigzag => balance, straight=>straight\n\t\t+ single rot at root if path has odd length\n\n\tinsert(x):\n\t\tusual bst insert + splay\n\n\tdelete(x):\n\t\tif x has one child, splice out, splay parent\n\t\telse: replace with sliced-out successor, splay\n\t\t\tprevious parent of successor\n\nAmortized analysis:\n\tassign weight w(x) to item x\n\ttotal weight tw(x) = sum_{y in subtree rooted at x} w(y)\n\trank(x) = floor(log_2(tw(x)))\n\n\tPhi = sum_x rank(x)\n\n\tTime per operation = O(# splay steps)\n\n\tSo (with a little care for insert/delete)\n\tWe mainly need to show that splay takes O(log n) amortized steps\n\n\tLemma: on splay, #steps + Delta Phi <= 1 + 3(rank(root) - rank(x))\n\t[note 0 <= rank(root)-rank(x) <= log total weight,\n\t so if w(x)=1 => O(log n); otherwise get weighted search tree]\n\n\t\tproof: induction on # steps\n\n\t\tsingle rot: rank at root stays same\n\t\t\trank(new child) < rank(v)\n\t\t\trank(old child) = rank(x)\n\t\t\tDeltaPhi <= rank(v) - rank(x)\n\t\ttotal <= 1 + rv-rx <= 1 + 3(rv-rx)\n\t\t\t\n\t\tstraight path:\n\t\t\tDelta Phi: old ranks(middle+bottom) - new\n\t\t\t\t<= 2 rank(old top) - 2 rank(x)\n\t\t\tif old top and x had different ranks,\n\t\t\t\t1step + 2r(t-x) <= 3(t-x)\n\t\t\telse: all three start at same rank\n\t\t\t\ttw(old x) + tw(new z) <= tw(new x)\n\t\t\t\tso new rank(z) < new rank(x)\n\t\t\t\tagain Phi drops by 1, pays for update\n\n\t\tzigzag path: similar\n\n        Deletion: only decreases Phi (decreases ranks of nodes)\n\tplus time proportional to following splay step\n\n\tInsertion: can increase Phi only by O(log n)\n\t\t[for each r, at most one rank-r node goes to rank r+1]\n\tplus time proportional to following splay step\n\n\tConclusion:\n\t\tsplay trees have amortized O(log n)\n\t\tfor weighted elements, O(log total weight / weight(x))\n\t\t\t[static optimality]\n\n\tAlso known (journal paper was so long it had to be split in 2):\n\tCole 1990\n\n\t\tamort. cost of access d steps from prev = O(log d)\n\t\tmatching performance of finger search trees\n\n\t\tspecial case (Tarjan 1985): sequential access is O(n)\n\n\tDynamic optimality conjecture\n\t(Major open problem in data strux):\n\n\t\tAre splay trees within a constant of the best possible\n\t\trotation-based search tree\n\t\t(in competetive ratio sense i.e. alg can know seq in advance)?\n", "encoding": "ascii"}