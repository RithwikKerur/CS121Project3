{"url": "https://www.ics.uci.edu/~eppstein/261/s13-hw8.txt", "content": "CS 261, Spring 2013, Homework 8, Due Thursday, June 6\n\n1. In the lecture we described a linear-time algorithm for finding the\nCartesian tree for an array of numbers, but we also described a more\ngeneral definition of a Cartesian tree from another tree, that applies\nto the problem of finding maximum-bandwidth paths. Prove that it is not\nalways possible to construct the Cartesian tree of a tree in linear time\n(in a comparison model of computation) by showing that, if you could do\nthat, you could use the construction to sort arbitrary sets of n numbers\nin linear time.\n\n\n2. In a binary tree (that is, a tree where each node may have at most\none parent, at most one left child, and at most one right child),\nsuppose that we wish to route a message from node u to node v. Describe\nhow to use lowest common ancestor queries to determine in constant time\nwhich of the three neighbors of u is the one on the shortest path to v.\n\n\n3. A queue data structure has two update operations (enqueue and\ndequeue) and one query operation (top). The sequence of values returned\nby top as dequeue operations are made should be the same as the sequence\nin which the same values were added to the queue by enqueue operations.\nA non-persistent queue can be represented by two pointers (head and\ntail) into a collection of nodes that each have \"data\" and \"next\"\ninstance variables, and in which the condition of being an empty queue\nis represented by the tail pointer being null. To perform an enqueue\noperation in an empty queue, a new node is created with the given data\nvalue and with next=null, and head and tail are both set to point to it.\nTo perform an enqueue operation in a non-empty queue, tail.next is set\nto be a new node, with the given data value and with next=null, and then\ntail is set to point to the new node. To perform a dequeue operation, head is set\nto head.next, and if this is null then tail is also set to null. To\nperform a top operation, head.top is returned.\n\nNow suppose that we want to make a queue persistent. Which of the two\ntechniques (fat nodes or path copying) would be more effective for this\nrepresentation of a queue? Explain why.", "encoding": "ascii"}