{"url": "https://www.ics.uci.edu/~eppstein/261/s13-hw6-answers.txt", "content": "CS 261, Spring 2013, Homework 6, Due Thursday, May 23\n\n1. (a) Find four strings whose compressed trie forms a complete binary\ntree with four leaves.\n\n    aardvark aableskiver zoology zoonosis\n\n    (Or any four strings where two pairs have nonempty common prefixes\n    and the other four pairs do not.)\n\n(b) Is it possible for the suffix tree of a string to form a complete\nbinary tree with four leaves? If yes, provide an example; if no, explain\nwhy not.\n\n    If you use the form of suffix tree described in class, the answer is\n    no, because the empty string makes a leaf of the root, which doesn't\n    exist in that binary tree.\n\n    If you use a variation of the suffix tree that skips the empty\n    suffix (which is the one in the Wikipedia article) then the string\n    \"papa\" works: the root has two edges labeled \"a\" and \"pa\", each of\n    which has two children.\n\n\n2. Let n be any integer, and let string s (including its string\ntermination symbol $) have n symbols in it: exactly n-1 copies of the\nsymbol \"a\" followed by the $. For instance, for n=5 the string s would\nbe aaaa$. How many leaves does the suffix tree of s have, as a function\nof n? How many non-leaf nodes does it have?\n\n    n leaves, for the version of suffix trees that include the empty\n    string. n-1 leaves, for the Wikipedia version.\n\n    Exactly one fewer non-leaf nodes than leaf nodes, in either case.\n\n\n3. Suppose you are given a string s, over a given alphabet, and have\nconstructed the suffix tree for s. Describe a linear-time algorithm for\nusing the suffix tree to construct a string of minimum length over the\nsame alphabet that is not a contiguous substring of s.\n\nE.g., if the alphabet is {A,T,C,G} and s is AATACAGTTCTGCCGGA, then s\ncontains all 16 different length-two strings, but it is missing some\nlength-three strings, such as AAA, and your algorithm should output one\nof the missing strings.\n\n    (By linear time I meant linear in the length of s.)\n\n    For each node x_i of the tree, compute two numbers: the length L_i\n    of the string formed by concatenating the labels on the path from\n    the root to x_i, and C_i, the number of children of x_i.\n\n    We can compute L_i as L_j (where x_j is the parent of x_i) plus the\n    length of the string labeling the edge from x_j to x_i; doing this\n    for all nodes in the suffix tree takes linear time.\n\n    Several students asked whether we can compute C_i in constant time.\n    The answer is that it depends on how the list of children of each\n    node is represented. It's ok to assume that it can be computed in\n    constant time, but even if it can't, it's easy to compute C_i for\n    all nodes by setting a counter to zero at each node and then, for\n    each node, incrementing its parent's counter. This algorithm again\n    takes linear time.\n\n    Let S be the set of nodes for which C_i is less than the alphabet\n    size, and let x_i be a node in S that has the smallest value of L_i\n    among nodes in S. (If there are ties, pick one arbitrarily.) Let q\n    be the string of length L_i formed by concatenating edge labels on\n    the path from the root to x_i. Search sequentially through the\n    characters of the alphabet for a character r that is not used to\n    label a child of x_i. (This search takes time proportional to the\n    number of children, at most, which is again linear in s).\n\n    The output of the algorithm is the string formed by adding r to the\n    end of string q.", "encoding": "ascii"}