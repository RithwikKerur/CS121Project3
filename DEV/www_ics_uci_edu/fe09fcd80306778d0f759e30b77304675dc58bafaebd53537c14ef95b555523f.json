{"url": "https://www.ics.uci.edu/~ejw/authoring/protocol/draft-ietf-webdav-rfc2518bis-04.txt", "content": "\r\n                                                                        \r\n    \r\n                                                   \r\nInternet Draft                                     L. Dusseault, Xythos \r\nDocument: draft-ietf-webdav-rfc2518bis-04.txt      J. Crawford, IBM \r\nExpires: Oct 2003 \r\n \r\n \r\n      HTTP Extensions for Distributed Authoring - WebDAV RFC2518 bis \r\n \r\n \r\nStatus of this Memo \r\n    \r\n   This document is an Internet-Draft and is in full conformance \r\n   with all provisions of Section 10 of RFC2026. \r\n    \r\n   Internet-Drafts are working documents of the Internet Engineering \r\n   Task Force (IETF), its areas, and its working groups.  Note that \r\n   other groups may also distribute working documents as Internet-\r\n   Drafts. \r\n   Internet-Drafts are draft documents valid for a maximum of six \r\n   months and may be updated, replaced, or obsoleted by other documents \r\n   at any time.  It is inappropriate to use Internet-Drafts as \r\n   reference material or to cite them other than as \"work in progress.\" \r\n    \r\n   The list of current Internet-Drafts can be accessed at \r\n        http://www.ietf.org/ietf/1id-abstracts.txt \r\n    \r\n   The list of Internet-Draft Shadow Directories can be accessed at \r\n        http://www.ietf.org/shadow.html. \r\n    \r\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \r\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this \r\n   document are to be interpreted as described in RFC 2119 [RFC2119]. \r\n    \r\nAbstract \r\n    \r\n   WebDAV consists of a set of methods, headers, and content-types \r\n   ancillary to HTTP/1.1 for the management of resource properties, \r\n   creation and management of resource collections, namespace \r\n   manipulation, and resource locking (collision avoidance). \r\n    \r\n   RFC2518 was published in February 1998, and this draft makes minor \r\n   revisions mostly due to interoperability experience. \r\n    \r\nTable of Contents \r\n    \r\n   1  Introduction...................................................6 \r\n   2  Notational Conventions.........................................7 \r\n   3  Terminology....................................................7 \r\n   4  Data Model for Resource Properties.............................8 \r\n     \r\n                           Expires Aug 2002                          1 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   4.1  The Resource Property Model..................................8 \r\n   4.2  Existing Metadata Proposals..................................8 \r\n   4.3  Properties and HTTP Headers..................................9 \r\n   4.4  XML Usage....................................................9 \r\n   4.5  Property Values.............................................10 \r\n   4.6  Property Names..............................................11 \r\n   5  Collections of Web Resources..................................11 \r\n   5.1  HTTP URL Namespace Model....................................12 \r\n   5.2  Collection Resources........................................12 \r\n   5.3  Source Resources and Output Resources.......................13 \r\n   6  Locking.......................................................14 \r\n   6.1  Exclusive Vs. Shared Locks..................................14 \r\n   6.2  Required Support............................................15 \r\n   6.3  Lock Tokens.................................................16 \r\n   6.4  opaquelocktoken Lock Token URI Scheme.......................16 \r\n   6.5  Lock Capability Discovery...................................17 \r\n   6.6  Active Lock Discovery.......................................17 \r\n   6.7  Usage Considerations........................................17 \r\n   7  Write Lock....................................................18 \r\n   7.1  Methods Restricted by Write Locks...........................18 \r\n   7.2  Write Locks and Lock Tokens.................................19 \r\n   7.3  Write Locks and Properties..................................19 \r\n   7.4  Write Locks and Unmapped URLs...............................19 \r\n   7.5  Write Locks and Collections.................................21 \r\n   7.6  Write Locks and the If Request Header.......................21 \r\n   7.7  Write Locks and COPY/MOVE...................................22 \r\n   7.8  Refreshing Write Locks......................................23 \r\n   8  HTTP Methods for Distributed Authoring........................23 \r\n   8.1  General request and response handling.......................23 \r\n   8.1.1 Use of XML.................................................23 \r\n   8.1.2 Required Bodies in Requests................................24 \r\n   8.1.3 Use of Location header in responses........................24 \r\n   8.1.4 Required Response Headers: Date............................24 \r\n   8.1.5 ETag.......................................................24 \r\n   8.1.6 Including error response bodies............................25 \r\n   8.2  PROPFIND....................................................26 \r\n   8.2.1 Example - Retrieving Named Properties......................28 \r\n   8.2.2 Example - Retrieving Named and Dead Properties.............29 \r\n   8.2.3 Example - Using propname to Retrieve all Property Names....30 \r\n   8.2.4 PROPFIND Request Errors....................................31 \r\n   8.3  PROPPATCH...................................................32 \r\n   8.3.1 Status Codes for use with 207 (Multi-Status)...............32 \r\n   8.3.2 Example - PROPPATCH........................................33 \r\n   8.4  MKCOL Method................................................34 \r\n   8.4.1 Example - MKCOL............................................35 \r\n     \r\n                           Expires Oct 2003                          2 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   8.5  GET, HEAD for Collections...................................35 \r\n   8.6  POST for Collections........................................36 \r\n   8.7  DELETE......................................................36 \r\n   8.7.1 Example - DELETE...........................................37 \r\n   8.8  PUT.........................................................37 \r\n   8.9  COPY Method.................................................38 \r\n   8.9.1 COPY for Collections.......................................39 \r\n   8.9.2 COPY and the Overwrite Header..............................40 \r\n   8.9.3 Status Codes...............................................40 \r\n   8.9.4 Example - COPY with Overwrite..............................41 \r\n   8.10  MOVE Method................................................42 \r\n   8.10.1  MOVE for Properties......................................43 \r\n   8.10.2  MOVE for Collections.....................................43 \r\n   8.10.3  MOVE and the Overwrite Header............................44 \r\n   8.10.4  Status Codes.............................................44 \r\n   8.10.5  Example - MOVE of a Non-Collection.......................45 \r\n   8.11  LOCK Method................................................46 \r\n   8.11.1  Example - Simple Lock Request............................50 \r\n   8.11.2  Example - Refreshing a Write Lock........................51 \r\n   8.11.3  Example - Multi-Resource Lock Request....................52 \r\n   8.12  UNLOCK Method..............................................54 \r\n   8.12.1  Example - UNLOCK.........................................54 \r\n   9  HTTP Headers for Distributed Authoring........................55 \r\n   9.1  DAV Header..................................................55 \r\n   9.2  Depth Header................................................55 \r\n   9.3  Destination Header..........................................57 \r\n   9.4  Force-Authentication Header.................................57 \r\n   9.5  If Header...................................................57 \r\n   9.5.1 No-tag-list Production.....................................58 \r\n   9.5.2 Example - No-tag-list If Header............................58 \r\n   9.5.3 Tagged-list Production.....................................59 \r\n   9.5.4 Example - Tagged List If header............................59 \r\n   9.5.5 Not Production.............................................59 \r\n   9.5.6 Matching Function..........................................60 \r\n   9.5.7 If Header and Non-DAV Aware Proxies........................60 \r\n   9.6  Lock-Token Header...........................................60 \r\n   9.7  Overwrite Header............................................60 \r\n   9.8  Status-URI Response Header..................................61 \r\n   9.9  Timeout Request Header......................................61 \r\n   10 Status Code Extensions to HTTP/1.1............................62 \r\n   10.1  102 Processing.............................................62 \r\n   10.2  207 Multi-Status...........................................63 \r\n   10.3  422 Unprocessable Entity...................................63 \r\n   10.4  423 Locked.................................................63 \r\n   10.5  424 Failed Dependency......................................63 \r\n     \r\n                           Expires Oct 2003                          3 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   10.6  507 Insufficient Storage...................................63 \r\n   11 Use of HTTP Status Codes......................................63 \r\n   11.1  301 Moved Permanently......................................63 \r\n   11.2  302 Found..................................................64 \r\n   11.3  400 Bad Request............................................64 \r\n   11.4  403 Forbidden..............................................64 \r\n   11.5  409 Conflict...............................................64 \r\n   11.6  414 Request-URI Too Long...................................64 \r\n   12 Multi-Status Response.........................................64 \r\n   12.1  Responses requiring Location in Multi-Status...............65 \r\n   13 XML Element Definitions.......................................65 \r\n   13.1  activelock XML Element.....................................65 \r\n   13.2  depth XML Element..........................................66 \r\n   13.3  locktoken XML Element......................................66 \r\n   13.4  lockroot XML Element.......................................66 \r\n   13.5  timeout XML Element........................................66 \r\n   13.6  collection XML Element.....................................67 \r\n   13.7  href XML Element...........................................67 \r\n   13.8  lockentry XML Element......................................67 \r\n   13.9  lockinfo XML Element.......................................67 \r\n   13.10 lockscope XML Element......................................67 \r\n   13.11 exclusive XML Element......................................68 \r\n   13.12 shared XML Element.........................................68 \r\n   13.13 locktype XML Element.......................................68 \r\n   13.14 write XML Element..........................................68 \r\n   13.15 multistatus XML Element....................................68 \r\n   13.16 response XML Element.......................................69 \r\n   13.17 propstat XML Element.......................................69 \r\n   13.18 status XML Element.........................................70 \r\n   13.19 responsedescription XML Element............................70 \r\n   13.20 owner XML Element..........................................70 \r\n   13.21 prop XML element...........................................70 \r\n   13.22 propertyupdate XML element.................................70 \r\n   13.23 remove XML element.........................................71 \r\n   13.24 set XML element............................................71 \r\n   13.25 propfind XML Element.......................................71 \r\n   13.26 allprop XML Element........................................72 \r\n   13.27 propname XML Element.......................................72 \r\n   13.28 deadprops XML Element......................................72 \r\n   14 DAV Properties................................................72 \r\n   14.1  creationdate Property......................................73 \r\n   14.2  displayname Property.......................................73 \r\n   14.3  getcontentlanguage Property................................74 \r\n   14.4  getcontentlength Property..................................74 \r\n   14.5  getcontenttype Property....................................74 \r\n     \r\n                           Expires Oct 2003                          4 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   14.6  getetag Property...........................................75 \r\n   14.7  getlastmodified Property...................................75 \r\n   14.8  lockdiscovery Property.....................................76 \r\n   14.8.1  Example - Retrieving the lockdiscovery Property..........76 \r\n   14.9  resourcetype Property......................................77 \r\n   14.10 supportedlock Property.....................................78 \r\n   14.10.1 Example - Retrieving the supportedlock Property..........78 \r\n   15 Instructions for Processing XML in DAV........................79 \r\n   16 DAV Compliance Classes........................................80 \r\n   16.1  Class 1....................................................80 \r\n   16.2  Class 2....................................................80 \r\n   16.3  Class \"bis\"................................................80 \r\n   17 Internationalization Considerations...........................81 \r\n   18 Security Considerations.......................................82 \r\n   18.1  Authentication of Clients..................................82 \r\n   18.2  Denial of Service..........................................83 \r\n   18.3  Security through Obscurity.................................83 \r\n   18.4  Privacy Issues Connected to Locks..........................83 \r\n   18.5  Privacy Issues Connected to Properties.....................84 \r\n   18.6  Implications of XML External Entities......................84 \r\n   18.7  Risks Connected with Lock Tokens...........................85 \r\n   19 IANA Considerations...........................................85 \r\n   20 Intellectual Property.........................................86 \r\n   21 Acknowledgements..............................................86 \r\n   22 References....................................................88 \r\n   22.1  Normative References.......................................88 \r\n   22.2  Informational References...................................89 \r\n   23 Authors' Addresses............................................90 \r\n   24 Appendices....................................................91 \r\n   24.1  Appendix 1 - WebDAV Document Type Definition...............91 \r\n   24.2  Appendix 3 - Notes on Processing XML Elements..............92 \r\n   24.2.1  Notes on Empty XML Elements..............................92 \r\n   24.2.2  Notes on Illegal XML Processing..........................92 \r\n   24.2.3  Example - XML Syntax Error...............................93 \r\n   24.2.4  Example - Unknown XML Element............................93 \r\n   24.3  Appendix 4: UUID Node Generation...........................94 \r\n   25 Full Copyright Statement......................................96 \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     \r\n                           Expires Oct 2003                          5 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n1  Introduction \r\n    \r\n   This document describes an extension to the HTTP/1.1 protocol that \r\n   allows clients to perform remote web content authoring operations.  \r\n   This extension provides a coherent set of methods, headers, request \r\n   entity body formats, and response entity body formats that provide \r\n   operations for: \r\n    \r\n   Properties: The ability to create, remove, and query information \r\n   about Web pages, such as their authors, creation dates, etc. Also, \r\n   the ability to link pages of any media type to related pages. \r\n    \r\n   Collections: The ability to create sets of documents and to retrieve \r\n   a hierarchical membership listing (like a directory listing in a \r\n   file system). \r\n    \r\n   Locking: The ability to keep more than one person from working on a \r\n   document at the same time. This prevents the \"lost update problem\", \r\n   in which modifications are lost as first one author then another \r\n   writes changes without merging the other author's changes. \r\n    \r\n   Namespace Operations: The ability to instruct the server to copy and \r\n   move Web resources. \r\n    \r\n   Requirements and rationale for these operations are described in a \r\n   companion document, \"Requirements for a Distributed Authoring and \r\n   Versioning Protocol for the World Wide Web\" [RFC2291]. \r\n    \r\n   This standard does not specify the versioning operations suggested \r\n   by [RFC2291]. That work was done in a separate document, \"Versioning \r\n   Extensions to WebDAV\" [RFC3253]. \r\n    \r\n   The sections below provide a detailed introduction to resource \r\n   properties (section 4), collections of resources (section 5), and \r\n   locking operations (section 6).  These sections introduce the \r\n   abstractions manipulated by the WebDAV-specific HTTP methods \r\n   described in section 8. Section 9 describes the new HTTP headers \r\n   used with WebDAV methods. \r\n    \r\n   While the status codes provided by HTTP/1.1 are sufficient to \r\n   describe most error conditions encountered by WebDAV methods, there \r\n   are some errors that do not fall neatly into the existing \r\n   categories.  New status codes developed for the WebDAV methods are \r\n   defined in section 10, and existing HTTP status codes as used in \r\n   WebDAV are described in section Error! Reference source not found..  \r\n   Since some WebDAV methods may operate over many resources, the \r\n   Multi-Status response has been introduced to return status \r\n   information for multiple resources.  The Multi-Status response is \r\n   described in section 12. \r\n    \r\n     \r\n                           Expires Oct 2003                          6 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   WebDAV uses XML to marshal complicated request and response \r\n   information, as well as to express metadata. XML elements used in \r\n   this specification are defined in section 13. An informational DTD \r\n   is provided in Appendix 1.  Section 15 explains how to process XML \r\n   appearing in WebDAV so that it truly is extensible. \r\n    \r\n   WebDAV employs the property mechanism to store information about the \r\n   current state of the resource.  For example, when a lock is taken \r\n   out on a resource, a lock information property describes the current \r\n   state of the lock. Section 13.28 defines the properties used within \r\n   the WebDAV specification. \r\n    \r\n   Finishing off the specification are sections on what it means to be \r\n   compliant with this specification (section 16), on \r\n   internationalization support (section 17), and on security (section \r\n   18). \r\n    \r\n    \r\n2  Notational Conventions \r\n    \r\n   Since this document describes a set of extensions to the HTTP/1.1 \r\n   protocol, the augmented BNF used herein to describe protocol \r\n   elements is exactly the same as described in section 2.1 of \r\n   [RFC2616], including the rules about implied linear white-space.  \r\n   Since this augmented BNF uses the basic production rules provided in \r\n   section 2.2 of [RFC2616], these rules apply to this document as \r\n   well. \r\n    \r\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \r\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in \r\n   this document are to be interpreted as described in RFC 2119 \r\n   [RFC2119]. \r\n    \r\n    \r\n3  Terminology \r\n    \r\n   URI/URL - A Uniform Resource Identifier and Uniform Resource \r\n   Locator, respectively. These terms (and the distinction between \r\n   them) are defined in [RFC2396]. \r\n    \r\n   Collection - A resource that contains a set of URLs, which identify \r\n   and locate member resources and which meet the requirements in \r\n   section 5 of this specification. \r\n     \r\n   Member URL - A URL which is a member of the set of URLs contained by \r\n   a collection. \r\n    \r\n   Internal Member URL - A Member URL that is immediately relative to \r\n   the URL of the collection (the definition of immediately relative is \r\n   given in section 5.2). \r\n    \r\n     \r\n                           Expires Oct 2003                          7 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Property - A name/value pair that contains descriptive information \r\n   about a resource. \r\n    \r\n   Live Property - A property whose semantics and syntax are enforced \r\n   by the server.  For example, the live \"getcontentlength\" property \r\n   has its value, the length of the entity returned by a GET request, \r\n   automatically calculated by the server. \r\n     \r\n   Dead Property - A property whose semantics and syntax are not \r\n   enforced by the server.  The server only records the value of a dead \r\n   property; the client is responsible for maintaining the consistency \r\n   of the syntax and semantics of a dead property. \r\n    \r\n \r\n4  Data Model for Resource Properties \r\n    \r\n4.1 The Resource Property Model \r\n    \r\n   Properties are pieces of data that describe the state of a resource.  \r\n   Properties are data about data. \r\n    \r\n   Properties are used in distributed authoring environments to provide \r\n   for efficient discovery and management of resources.  For example, a \r\n   'subject' property might allow for the indexing of all resources by \r\n   their subject, and an 'author' property might allow for the \r\n   discovery of what authors have written which documents. \r\n    \r\n   The DAV property model consists of name/value pairs.  The name of a \r\n   property identifies the property's syntax and semantics, and \r\n   provides an address by which to refer to its syntax and semantics. \r\n    \r\n   There are two categories of properties: \"live\" and \"dead\".  A live \r\n   property has its syntax and semantics enforced by the server. Live \r\n   properties include cases where a) the value of a property is read-\r\n   only, maintained by the server, and b) the value of the property is \r\n   maintained by the client, but the server performs syntax checking on \r\n   submitted values. All instances of a given live property MUST comply \r\n   with the definition associated with that property name.  A dead \r\n   property has its syntax and semantics enforced by the client; the \r\n   server merely records the value of the property verbatim. \r\n    \r\n4.2 Existing Metadata Proposals \r\n    \r\n   Properties have long played an essential role in the maintenance of \r\n   large document repositories, and many current proposals contain some \r\n   notion of a property, or discuss web metadata more generally.  These \r\n   include PICS [REC-PICS], PICS-NG, XML, Web Collections, and several \r\n   proposals on representing relationships within HTML. Work on PICS-NG \r\n   and Web Collections has been subsumed by the Resource Description \r\n   Framework (RDF) metadata activity of the World Wide Web Consortium. \r\n\r\n     \r\n                           Expires Oct 2003                          8 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   RDF consists of a network-based data model and an XML representation \r\n   of that model. \r\n    \r\n   Some proposals come from a digital library perspective.  These \r\n   include the Dublin Core [RFC2413] metadata set and the Warwick \r\n   Framework [WF], a container architecture for different metadata \r\n   schemas.  The literature includes many examples of metadata, \r\n   including MARC [USMARC], a bibliographic metadata format, and a \r\n   technical report bibliographic format employed by the Dienst system \r\n   [RFC1807]. Additionally, the proceedings from the first IEEE \r\n   Metadata conference describe many community-specific metadata sets. \r\n    \r\n   Participants of the 1996 Metadata II Workshop in Warwick, UK [WF], \r\n   noted that \"new metadata sets will develop as the networked \r\n   infrastructure matures\" and \"different communities will propose, \r\n   design, and be responsible for different types of metadata.\" These \r\n   observations can be corroborated by noting that many community-\r\n   specific sets of metadata already exist, and there is significant \r\n   motivation for the development of new forms of metadata as many \r\n   communities increasingly make their data available in digital form, \r\n   requiring a metadata format to assist data location and cataloging. \r\n    \r\n4.3 Properties and HTTP Headers \r\n    \r\n   Properties already exist, in a limited sense, in HTTP message \r\n   headers.  However, in distributed authoring environments a \r\n   relatively large number of properties are needed to describe the \r\n   state of a resource, and setting/returning them all through HTTP \r\n   headers is inefficient.  Thus a mechanism is needed which allows a \r\n   principal to identify a set of properties in which the principal is \r\n   interested and to set or retrieve just those properties. \r\n    \r\n4.4 XML Usage \r\n    \r\n   In HTTP/1.1, method parameter information was exclusively encoded in \r\n   HTTP headers. Unlike HTTP/1.1, WebDAV encodes method parameter \r\n   information either in an Extensible Markup Language (XML) [REC-XML] \r\n   request entity body, or in an HTTP header.  The use of XML to encode \r\n   method parameters was motivated by the ability to add extra XML \r\n   elements to existing structures, providing extensibility; and by \r\n   XML's ability to encode information in ISO 10646 character sets, \r\n   providing internationalization support. As a rule of thumb, \r\n   parameters are encoded in XML entity bodies when they have unbounded \r\n   length, or when they may be shown to a human user and hence require \r\n   encoding in an ISO 10646 character set.  Otherwise, parameters are \r\n   encoded within HTTP headers.   \r\n    \r\n   In addition to encoding method parameters, XML is used in WebDAV to \r\n   encode the responses from methods, providing the extensibility and \r\n   internationalization advantages of XML for method output, as well as \r\n   input. \r\n     \r\n                           Expires Oct 2003                          9 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   An XML DTD is included in an appendix for all the XML elements \r\n   defined in this specification. However, legal XML will not be valid \r\n   according to this DTD due to namespace usage and extension rules, so \r\n   the DTD is only informational. \r\n    \r\n   The XML namespace extension is also used in this specification in \r\n   order to allow for new XML elements to be added without fear of \r\n   colliding with other element names. Although WebDAV request and \r\n   response bodies can be extended by arbitrary XML elements, which can \r\n   be ignored by the message recipient, an XML element in the \"DAV:\" \r\n   namespace SHOULD NOT be used in the request or response body unless \r\n   that XML element is explicitly defined in an IETF RFC reviewed by a \r\n   WebDAV working group. \r\n    \r\n   Note that \u00f4DAV:\u00f6 is a top-level URI identifier that was defined \r\n   solely to provide a namespace for WebDAV XML elements and property \r\n   names.  This practice is discouraged in part because registration of \r\n   top-level URI identifiers is difficult. \"DAV:\" was defined as the \r\n   WebDAV namespace before standard best practices emerged, and this \r\n   namespace is kept and still used because of significant existing \r\n   deployments, but this should not be emulated. \r\n    \r\n4.5 Property Values \r\n    \r\n   The value of a property is always a (wellformed) XML fragment. \r\n    \r\n   XML has been chosen because it is a flexible, self-describing, \r\n   structured data format that supports rich schema definitions, and \r\n   because of its support for multiple character sets.  XML's self-\r\n   describing nature allows any property's value to be extended by \r\n   adding new elements.  Older clients will not break when they \r\n   encounter extensions because they will still have the data specified \r\n   in the original schema and will ignore elements they do not \r\n   understand.  XML's support for multiple character sets allows any \r\n   human-readable property to be encoded and read in a character set \r\n   familiar to the user.  XML's support for multiple human languages, \r\n   using the \"xml:lang\" attribute, handles cases where the same \r\n   character set is employed by multiple human languages. Note that \r\n   xml:lang scope is recursive, so a xml:lang attribute on any element \r\n   containing a property name element applies to the property value \r\n   unless it has been overridden by a more locally scoped attribute. \r\n    \r\n   A property is always represented in XML with an XML element \r\n   consisting of the property name. The simplest example is an empty \r\n   property, which is different from a property that does not exist. \r\n    \r\n     <R:title xmlns:R=\"http://www.example.com/ns/\"></R:title> \r\n    \r\n   The value of a property appears inside the property name element.  \r\n   The value may be any kind of well-formed XML content, including both \r\n     \r\n                           Expires Oct 2003                         10 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   text-only and mixed content.  When the property value contains \r\n   further XML elements, namespaces that are in scope for that part of \r\n   the XML document apply within the property value as well, and MUST \r\n   be preserved in server storage for retransmission later. Namespace \r\n   prefixes need not be preserved due to the rules of prefix \r\n   declaration in XML. \r\n    \r\n   Attributes on the property name element may convey information about \r\n   the property, but are not considered part of the value. However, \r\n   when language information appears in the 'xml:lang' attribute on the \r\n   property name element, the language information MUST be preserved in \r\n   server storage for retransmission later. \r\n    \r\n   The XML attribute xml:space MUST NOT be used to change white space \r\n   handling.  White space in property values is significant.  \r\n    \r\n4.6 Property Names \r\n    \r\n   A property name is a universally unique identifier that is \r\n   associated with a schema that provides information about the syntax \r\n   and semantics of the property. \r\n    \r\n   Because a property's name is universally unique, clients can depend \r\n   upon consistent behavior for a particular property across multiple \r\n   resources, on the same and across different servers, so long as that \r\n   property is \"live\" on the resources in question, and the \r\n   implementation of the live property is faithful to its definition. \r\n    \r\n   The XML namespace mechanism, which is based on URIs [RFC2396], is \r\n   used to name properties because it prevents namespace collisions and \r\n   provides for varying degrees of administrative control. \r\n    \r\n   The property namespace is flat; that is, no hierarchy of properties \r\n   is explicitly recognized.  Thus, if a property A and a property A/B \r\n   exist on a resource, there is no recognition of any relationship \r\n   between the two properties.  It is expected that a separate \r\n   specification will eventually be produced which will address issues \r\n   relating to hierarchical properties. \r\n    \r\n   Finally, it is not possible to define the same property twice on a \r\n   single resource, as this would cause a collision in the resource's \r\n   property namespace. \r\n    \r\n    \r\n5  Collections of Web Resources \r\n    \r\n   This section provides a description of a new type of Web resource, \r\n   the collection, and discusses its interactions with the HTTP URL \r\n   namespace. The purpose of a collection resource is to model \r\n   collection-like objects (e.g., file system directories) within a \r\n   server's namespace. \r\n     \r\n                           Expires Oct 2003                         11 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   All DAV compliant resources MUST support the HTTP URL namespace \r\n   model specified herein. \r\n    \r\n5.1 HTTP URL Namespace Model \r\n    \r\n   The HTTP URL namespace is a hierarchical namespace where the \r\n   hierarchy is delimited with the \"/\" character.    \r\n    \r\n   An HTTP URL namespace is said to be consistent if it meets the \r\n   following conditions: for every URL in the HTTP hierarchy there \r\n   exists a collection that contains that URL as an internal member. \r\n   The root, or top-level collection of the namespace under \r\n   consideration is exempt from the previous rule. \r\n    \r\n   Neither HTTP/1.1 nor WebDAV require that the entire HTTP URL \r\n   namespace be consistent.  However, certain WebDAV methods are \r\n   prohibited from producing results that cause namespace \r\n   inconsistencies. \r\n    \r\n   Although implicit in [RFC2616] and [RFC2396], any resource, \r\n   including collection resources, MAY be identified by more than one \r\n   URI. For example, a resource could be identified by multiple HTTP \r\n   URLs. \r\n    \r\n5.2 Collection Resources \r\n    \r\n   A collection is a resource whose state consists of at least a list \r\n   of internal member URLs and a set of properties, but which may have \r\n   additional state such as entity bodies returned by GET.  An internal \r\n   member URL MUST be immediately relative to a base URL of the \r\n   collection.  That is, the internal member URL is equal to a \r\n   containing collection's URL plus an additional segment for non-\r\n   collection resources, or additional segment plus trailing slash \"/\" \r\n   for collection resources, where segment is defined in section 3.3 of \r\n   [RFC2396].  \r\n    \r\n   Any given internal member URL MUST only belong to the collection \r\n   once, i.e., it is illegal to have multiple instances of the same URL \r\n   in a collection.  Properties defined on collections behave exactly \r\n   as do properties on non-collection resources.  \r\n    \r\n   For all WebDAV compliant resources A and B, identified by URLs U and \r\n   V, for which U is immediately relative to V, B MUST be a collection \r\n   that has U as an internal member URL. So, if the resource with URL \r\n   http://example.com/bar/blah is WebDAV compliant and if the resource \r\n   with URL http://example.com/bar/ is WebDAV compliant then the \r\n   resource with URL http://example.com/bar/ must be a collection and \r\n   must contain URL http://example.com/bar/blah as an internal member. \r\n    \r\n\r\n     \r\n                           Expires Oct 2003                         12 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Collection resources MAY list the URLs of non-WebDAV compliant \r\n   children in the HTTP URL namespace hierarchy as internal members but \r\n   are not required to do so. For example, if the resource with URL \r\n   http://example.com/bar/blah is not WebDAV compliant and the URL \r\n   http://example.com/bar/ identifies a collection then URL \r\n   http://example.com/bar/blah may or may not be an internal member of \r\n   the collection with URL http://example.com/bar/. \r\n    \r\n   If a WebDAV compliant resource has no WebDAV compliant children in \r\n   the HTTP URL namespace hierarchy then the WebDAV compliant resource \r\n   is not required to be a collection. \r\n    \r\n   There is a standing convention that when a collection is referred to \r\n   by its name without a trailing slash, the server MAY handle the \r\n   request as if the trailing slash were present.  In this case it \r\n   SHOULD return a Content-Location header in the response, pointing to \r\n   the URL ending with the \"/\".  For example, if a client invokes a \r\n   method on http://example.bar/blah (no trailing slash), the server \r\n   may respond as if the operation were invoked on \r\n   http://example.com/blah/ (trailing slash), and should return a \r\n   Content-Location header with the value http://example.bar/blah/. \r\n   Wherever a server produces a URL referring to a collection, the \r\n   server MUST include the trailing slash. In general clients SHOULD \r\n   use the \"/\" form of collection names.   \r\n    \r\n   A resource MAY be a collection but not be WebDAV compliant.  That \r\n   is, the resource may comply with all the rules set out in this \r\n   specification regarding how a collection is to behave without \r\n   necessarily supporting all methods that a WebDAV compliant resource \r\n   is required to support.  In such a case the resource may return the \r\n   DAV:resourcetype property with the value DAV:collection but MUST NOT \r\n   return a DAV header containing the value \"1\" on an OPTIONS response.   \r\n    \r\n   Clients MUST be able to support the case where WebDAV resources are \r\n   contained inside non-WebDAV resources.  For example, if a OPTIONS \r\n   response from \"http://example.com/servlet/dav/collection\" indicates \r\n   WebDAV support, the client cannot assume that \r\n   \"http://example.com/servlet/dav/\" or its parent necessarily are \r\n   WebDAV collections. \r\n    \r\n5.3 Source Resources and Output Resources \r\n    \r\n   For many resources, the entity returned by a GET method exactly \r\n   matches the persistent state of the resource, for example, a GIF \r\n   file stored on a disk.  For this simple case, the URL at which a \r\n   resource is accessed is identical to the URL at which the source \r\n   (the persistent state) of the resource is accessed.  This is also \r\n   the case for HTML source files that are not processed by the server \r\n   prior to transmission. \r\n    \r\n\r\n     \r\n                           Expires Oct 2003                         13 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   However, the server can sometimes process HTML resources before they \r\n   are transmitted as a return entity body.  For example, a server-\r\n   side-include directive within an HTML file might instruct a server \r\n   to replace the directive with another value, such as the current \r\n   date.  In this case, what is returned by GET (HTML plus date) \r\n   differs from the persistent state of the resource (HTML plus \r\n   directive).  Typically there is no way to access the HTML resource \r\n   containing the unprocessed directive. \r\n    \r\n   Sometimes the entity returned by GET is the output of a data-\r\n   producing process that is described by one or more source resources \r\n   (that may not even have a location in the URI namespace).  A single \r\n   data-producing process may dynamically generate the state of a \r\n   potentially large number of output resources.  An example of this is \r\n   a CGI script that describes a \"finger\" gateway process that maps \r\n   part of the namespace of a server into finger requests, such as \r\n   http://finger.example.com/finger_gateway/user@host. \r\n                     \r\n   Although this problem would usefully be solved, interoperable WebDAV \r\n   implementations have been widely deployed without actually solving \r\n   this problem. Thus, the source vs. output problem is not solved in \r\n   this specification, and has been deferred to a separate document. \r\n    \r\n    \r\n6  Locking \r\n    \r\n   The ability to lock a resource provides a mechanism for serializing \r\n   access to that resource.  Using a lock, an authoring client can \r\n   provide a reasonable guarantee that another principal will not \r\n   modify a resource while it is being edited.  In this way, a client \r\n   can prevent the \"lost update\" problem. \r\n    \r\n   This specification allows locks to vary over two client-specified \r\n   parameters, the number of principals involved (exclusive vs. shared) \r\n   and the type of access to be granted. This document defines locking \r\n   for only one access type, write. However, the syntax is extensible, \r\n   and permits the eventual specification of locking for other access \r\n   types. \r\n    \r\n6.1 Exclusive Vs. Shared Locks \r\n    \r\n   The most basic form of lock is an exclusive lock.  Only one \r\n   exclusive lock may exist on any resource, whether it is directly or \r\n   indirectly locked (see 7.5).  Exclusive locks avoid having to merge \r\n   results, without requiring any coordination other than the methods \r\n   described in this specification. \r\n    \r\n   However, there are times when the goal of a lock is not to exclude \r\n   others from exercising an access right but rather to provide a \r\n   mechanism for principals to indicate that they intend to exercise \r\n   their access rights.  Shared locks are provided for this case.  A \r\n     \r\n                           Expires Oct 2003                         14 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   shared lock allows multiple principals to receive a lock.  Hence any \r\n   principal with appropriate access can get the lock. \r\n    \r\n   With shared locks there are two trust sets that affect a resource.  \r\n   The first trust set is created by access permissions.  Principals \r\n   who are trusted, for example, may have permission to write to the \r\n   resource.  Among those who have access permission to write to the \r\n   resource, the set of principals who have taken out a shared lock \r\n   also must trust each other, creating a (typically) smaller trust set \r\n   within the access permission write set. \r\n    \r\n   Starting with every possible principal on the Internet, in most \r\n   situations the vast majority of these principals will not have write \r\n   access to a given resource.  Of the small number who do have write \r\n   access, some principals may decide to guarantee their edits are free \r\n   from overwrite conflicts by using exclusive write locks.  Others may \r\n   decide they trust their collaborators will not overwrite their work \r\n   (the potential set of collaborators being the set of principals who \r\n   have write permission) and use a shared lock, which informs their \r\n   collaborators that a principal may be working on the resource. \r\n    \r\n   The WebDAV extensions to HTTP do not need to provide all of the \r\n   communications paths necessary for principals to coordinate their \r\n   activities.  When using shared locks, principals may use any out of \r\n   band communication channel to coordinate their work (e.g., face-to-\r\n   face interaction, written notes, post-it notes on the screen, \r\n   telephone conversation, Email, etc.)  The intent of a shared lock is \r\n   to let collaborators know who else may be working on a resource. \r\n    \r\n   Shared locks are included because experience from web distributed \r\n   authoring systems has indicated that exclusive locks are often too \r\n   rigid.  An exclusive lock is used to enforce a particular editing \r\n   process: take out an exclusive lock, read the resource, perform \r\n   edits, write the resource, release the lock.  This editing process \r\n   has the problem that locks are not always properly released, for \r\n   example when a program crashes, or when a lock owner leaves without \r\n   unlocking a resource.  While both timeouts and administrative action \r\n   can be used to remove an offending lock, neither mechanism may be \r\n   available when needed; the timeout may be long or the administrator \r\n   may not be available. \r\n    \r\n6.2 Required Support \r\n    \r\n   A WebDAV compliant resource is not required to support locking in \r\n   any form.  If the resource does support locking it may choose to \r\n   support any combination of exclusive and shared locks for any access \r\n   types. \r\n    \r\n   The reason for this flexibility is that locking policy strikes to \r\n   the very heart of the resource management and versioning systems \r\n   employed by various storage repositories.  These repositories \r\n     \r\n                           Expires Oct 2003                         15 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   require control over what sort of locking will be made available.  \r\n   For example, some repositories only support shared write locks while \r\n   others only provide support for exclusive write locks while yet \r\n   others use no locking at all.  As each system is sufficiently \r\n   different to merit exclusion of certain locking features, this \r\n   specification leaves locking as the sole axis of negotiation within \r\n   WebDAV. \r\n    \r\n6.3 Lock Tokens \r\n    \r\n   A lock token is a type of state token, represented as a URI, which \r\n   identifies a particular lock.  A lock token is returned in the Lock-\r\n   Token header in the response to a successful LOCK operation. The \r\n   lock token also appears in the value of the lockdiscovery property, \r\n   the value of which is returned in the body of the response to a \r\n   successful LOCK operation (this property also includes the tokens of \r\n   other current locks on the resource).  Finally, the lockdiscovery \r\n   property can be queried using PROPFIND and the token can be \r\n   discovered that way. Each lock has only one unique lock token.  \r\n    \r\n   Lock token URIs MUST be unique across all resources for all time. \r\n   This uniqueness constraint allows lock tokens to be submitted across \r\n   resources and servers without fear of confusion. \r\n    \r\n   This specification provides a lock token URI scheme called \r\n   opaquelocktoken that meets the uniqueness requirements.  However \r\n   resources are free to return any URI scheme so long as it meets the \r\n   uniqueness requirements. \r\n    \r\n   Having a lock token provides no special access rights. Anyone can \r\n   find out anyone else's lock token by performing lock discovery. \r\n   Locks MUST be enforced based upon whatever authentication mechanism \r\n   is used by the server, not based on the secrecy of the token values. \r\n    \r\n6.4 opaquelocktoken Lock Token URI Scheme \r\n    \r\n   The opaquelocktoken URI scheme is designed to be unique across all \r\n   resources for all time.  Due to this uniqueness quality, a client \r\n   may submit an opaque lock token in an If header on a resource other \r\n   than the one that returned it. \r\n    \r\n   In order to guarantee uniqueness across all resources for all time \r\n   the opaquelocktoken requires the use of the Universal Unique \r\n   Identifier (UUID) mechanism, as described in [ISO-11578]. \r\n    \r\n   Opaquelocktoken generators, however, have a choice of how they \r\n   create these tokens.  They can either generate a new UUID for every \r\n   lock token they create or they can create a single UUID  and then \r\n   add extension characters.  If the second method is selected then the \r\n   program generating the extensions MUST guarantee that the same \r\n   extension will never be used twice with the associated UUID. \r\n     \r\n                           Expires Oct 2003                         16 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   OpaqueLockToken-URI = \"opaquelocktoken:\" UUID [Extension]  ; The \r\n   UUID production is the string representation of a UUID, as defined \r\n   in [ISO-11578]. Note that white space (LWS) is not allowed between \r\n   elements of this production. \r\n    \r\n   Extension = path  ; path is defined in section 3.2.1 of [RFC2616] \r\n    \r\n6.5 Lock Capability Discovery \r\n    \r\n   Since server lock support is optional, a client trying to lock a \r\n   resource on a server can either try the lock and hope for the best, \r\n   or perform some form of discovery to determine what lock \r\n   capabilities the server supports.  This is known as lock capability \r\n   discovery.  Lock capability discovery differs from discovery of \r\n   supported access control types, since there may be access control \r\n   types without corresponding lock types.  A client can determine what \r\n   lock types the server supports by retrieving the supportedlock \r\n   property. \r\n    \r\n   Any DAV compliant resource that supports the LOCK method MUST \r\n   support the supportedlock property. \r\n    \r\n6.6 Active Lock Discovery \r\n    \r\n   If another principal locks a resource that a principal wishes to \r\n   access, it is useful for the second principal to be able to find out \r\n   who the first principal is.  For this purpose the lockdiscovery \r\n   property is provided.  This property lists all outstanding locks, \r\n   describes their type, and where available, provides their lock \r\n   token. \r\n    \r\n   Any DAV compliant resource that supports the LOCK method MUST \r\n   support the lockdiscovery property. \r\n    \r\n6.7 Usage Considerations \r\n    \r\n   Although the locking mechanisms specified here provide some help in \r\n   preventing lost updates, they cannot guarantee that updates will \r\n   never be lost.  Consider the following scenario: \r\n    \r\n   Two clients A and B are interested in editing the resource \r\n   'index.html'.  Client A is an HTTP client rather than a WebDAV \r\n   client, and so does not know how to perform locking. \r\n    \r\n   Client A doesn't lock the document, but does a GET and begins \r\n   editing. \r\n   Client B does LOCK, performs a GET and begins editing. \r\n   Client B finishes editing, performs a PUT, then an UNLOCK. \r\n   Client A performs a PUT, overwriting and losing all of B's changes. \r\n     \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   There are several reasons why the WebDAV protocol itself cannot \r\n   prevent this situation.  First, it cannot force all clients to use \r\n   locking because it must be compatible with HTTP clients that do not \r\n   comprehend locking.  Second, it cannot require servers to support \r\n   locking because of the variety of repository implementations, some \r\n   of which rely on reservations and merging rather than on locking.  \r\n   Finally, being stateless, it cannot enforce a sequence of operations \r\n   like LOCK / GET / PUT / UNLOCK.  \r\n    \r\n   WebDAV servers that support locking can reduce the likelihood that \r\n   clients will accidentally overwrite each other's changes by \r\n   requiring clients to lock resources before modifying them.  Such \r\n   servers would effectively prevent HTTP 1.0 and HTTP 1.1 clients from \r\n   modifying resources. \r\n    \r\n   WebDAV clients can be good citizens by using a lock / retrieve / \r\n   write /unlock sequence of operations (at least by default) whenever \r\n   they interact with a WebDAV server that supports locking. \r\n    \r\n   HTTP 1.1 clients can be good citizens, avoiding overwriting other \r\n   clients' changes, by using entity tags in If-Match headers with any \r\n   requests that would modify resources.  \r\n    \r\n   Information managers may attempt to prevent overwrites by \r\n   implementing client-side procedures requiring locking before \r\n   modifying WebDAV resources. \r\n    \r\n    \r\n7  Write Lock \r\n    \r\n   This section describes the semantics specific to the write lock \r\n   type.  The write lock is a specific instance of a lock type, and is \r\n   the only lock type described in this specification. \r\n    \r\n   Write locks prevent unauthorized changes to resources. In general \r\n   terms, changes affected by write locks include changes to: \r\n    - the content of the resource \r\n    - any dead property of the resource \r\n    - any live property defined to be lockable (all properties defined \r\n   in this specification are lockable) \r\n    - the direct membership of the resource, if it is a collection \r\n    - the URL/location of a resource \r\n    \r\n   The next few sections describe in more specific terms how write \r\n   locks interact with various operations. \r\n    \r\n7.1 Methods Restricted by Write Locks \r\n    \r\n   A write lock MUST prevent a principal without the lock from \r\n   successfully executing a PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, \r\n     \r\n                           Expires Oct 2003                         18 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   DELETE, or MKCOL on the locked resource.  All other current methods, \r\n   GET in particular, function independently of the lock. \r\n    \r\n   Note, however, that as new methods are created it will be necessary \r\n   to specify how they interact with a write lock. \r\n    \r\n7.2 Write Locks and Lock Tokens \r\n    \r\n   A successful request for an exclusive or shared write lock MUST \r\n   result in the generation of a unique lock token associated with the \r\n   requesting principal.  Thus if five principals have a shared write \r\n   lock on the same resource there will be five lock tokens, one for \r\n   each principal. \r\n    \r\n7.3 Write Locks and Properties \r\n    \r\n   While those without a write lock may not alter a property on a \r\n   resource it is still possible for the values of live properties to \r\n   change, even while locked, due to the requirements of their schemas.  \r\n   Only dead properties and live properties defined to respect locks \r\n   are guaranteed not to change while write locked. \r\n    \r\n7.4 Write Locks and Unmapped URLs \r\n    \r\n   It is possible to lock an unmapped URL in order to lock the name for \r\n   use.  This is a simple way to avoid the lost-update problem on the \r\n   creation of a new resource (another way is to use If-None-Match \r\n   header specified in HTTP 1.1).  It has the side benefit of locking \r\n   the new resource immediately for use of the creator.   \r\n    \r\n   The lost-update problem is not an issue for collections because \r\n   MKCOL can only be used to create a collection, not to overwrite an \r\n   existing collection.  In order to immediately lock a collection upon \r\n   creation, clients may attempt to pipeline the MKCOL and LOCK \r\n   requests together.   \r\n    \r\n   A lock request to an unmapped URL should result in the creation of a \r\n   resource that is locked.  A subsequent PUT request with the correct \r\n   lock token should normally succeed, and provides the content, \r\n   content-type, content-language and other information as appropriate.  \r\n    \r\n   In this situation, a WebDAV server that was implemented from RFC2518 \r\n   MAY create \"lock-null\" resources which are special and unusual \r\n   resources.  Historically, a lock-null resource: \r\n    \r\n   -  Responds with a 404 or 405 to any DAV method except for PUT, \r\n     MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK. \r\n   -  Appears as a member of its parent collection. \r\n   -  Disappears (becomes once more an unmapped URL) if its lock goes \r\n     away before it is converted to a regular resource.  (This must \r\n     \r\n                           Expires Oct 2003                         19 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     also happen if it is renamed or moved, or if any parent collection \r\n     is renamed or moved, because locks are tied to URLs). \r\n   -  May be turned into a regular resource when a PUT request to the \r\n     URL is successful. Ceases to be a lock-null resource. \r\n   -  May be turned into a collection when a MKCOL request to the URL \r\n     is successful.  Ceases to be a lock-null resource \r\n   -  Has defined values for lockdiscovery and supportedlock \r\n     properties. \r\n    \r\n   However, interoperability and compliance problems have been found \r\n   with lock-null resources.  Therefore, they are deprecated.  WebDAV \r\n   servers SHOULD create regular locked empty resources, which are and \r\n   behave in every way as normal resources.  A locked empty resource: \r\n    \r\n   -  Can be read, deleted, moved, copied, and in all ways behave as a \r\n     regular resource, not a lock-null resource. \r\n   -  Appears as a member of its parent collection. \r\n   -  SHOULD NOT disappear when its lock goes away (clients must \r\n     therefore be responsible for cleaning up their own mess, as with \r\n     any other operation) \r\n   -  SHOULD default to having no content type. \r\n   -  MAY NOT have values for properties like getcontentlanguage which \r\n     haven\u00c6t been specified yet by the client. \r\n   -  May have content added with a PUT request.  MUST be able to \r\n     change content type. \r\n   -  MUST NOT be turned into a collection.  A MKCOL request must fail \r\n     as it would to any existing resource. \r\n   -  MUST have defined values for lockdiscovery and supportedlock \r\n     properties. \r\n   -  The response MUST indicate that a resource was created, by use of \r\n     the \"201 Created\" response code (a LOCK request to an existing \r\n     resource instead will result in 200 OK).  The body must still \r\n     include the lockdiscovery property, as with a LOCK request to an \r\n     existing resource. \r\n    \r\n   The client is expected to update the locked empty resource shortly \r\n   after locking it, using PUT and possibly PROPPATCH.  When the client \r\n   uses PUT to overwrite a locked empty resource the client MUST supply \r\n   a Content-Type if any is known.  If the client supplies a Content-\r\n   Type value the server MUST set that value (this requirement actually \r\n   applies to any resource that is overwritten but is particularly \r\n   necessary for locked empty resources which are initially created \r\n   with no Content-Type.   \r\n    \r\n   Clients can easily interoperate both with servers that support the \r\n   deprecated lock-null resources and servers that support simpler \r\n\r\n     \r\n                           Expires Oct 2003                         20 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   locked empty resources by only attempting PUT after a LOCK to an \r\n   unmapped URL, not MKCOL or GET. \r\n    \r\n7.5 Write Locks and Collections \r\n    \r\n   A write lock on a collection, whether created by a \"Depth: 0\" or \r\n   \"Depth: infinity\" lock request, prevents the addition or removal of \r\n   member URLs of the collection by non-lock owners.   \r\n    \r\n   A zero-depth lock on a collection affects changes to the direct \r\n   membership of that collection.  When a principal issues a PUT or \r\n   POST request to create a new resource in a write locked collection, \r\n   or issues a DELETE to remove a resource which has a URL which is an \r\n   existing internal member URL of a write locked collection, this \r\n   request MUST fail if the principal does not provide the correct lock \r\n   token for the locked collection. \r\n    \r\n   In addition, a depth-infinity lock affects all write operations to \r\n   all descendents of the locked collection.  With a depth-infinity \r\n   lock, the root of the lock is directly locked, and all its \r\n   descendants are indirectly locked.   \r\n    - Any new resource added as a descendent of a depth-infinity locked \r\n   collection becomes indirectly locked.   \r\n    - Any indirectly locked resource moved out of the locked collection \r\n   into an unlocked collection is thereafter unlocked. \r\n    - Any indirectly locked resource moved out of a locked source \r\n   collection into a depth-infinity locked target collection remains \r\n   indirectly locked but is now within the scope of the lock on the \r\n   target collection (the target collection's lock token will \r\n   thereafter be required to make further changes). \r\n    \r\n   If a depth-infinity write LOCK request is issued to a collection \r\n   containing member URLs identifying resources that are currently \r\n   locked in a manner which conflicts with the write lock, the request \r\n   MUST fail with a 423 (Locked) status code. \r\n    \r\n   If a lock owner causes the URL of a resource to be added as an \r\n   internal member URL of a depth-infinity locked collection then the \r\n   new resource MUST be automatically added to the lock.  This is the \r\n   only mechanism that allows a resource to be added to a write lock.  \r\n   Thus, for example, if the collection /a/b/ is write locked and the \r\n   resource /c is moved to /a/b/c then resource /a/b/c will be added to \r\n   the write lock. \r\n    \r\n7.6 Write Locks and the If Request Header \r\n    \r\n   If a user agent is not required to have knowledge about a lock when \r\n   requesting an operation on a locked resource, the following scenario \r\n   might occur.  Program A, run by User A, takes out a write lock on a \r\n   resource.  Program B, also run by User A, has no knowledge of the \r\n   lock taken out by Program A, yet performs a PUT to the locked \r\n     \r\n                           Expires Oct 2003                         21 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   resource.  In this scenario, the PUT succeeds because locks are \r\n   associated with a principal, not a program, and thus program B, \r\n   because it is acting with principal A\u00c6s credential, is allowed to \r\n   perform the PUT.  However, had program B known about the lock, it \r\n   would not have overwritten the resource, preferring instead to \r\n   present a dialog box describing the conflict to the user.  Due to \r\n   this scenario, a mechanism is needed to prevent different programs \r\n   from accidentally ignoring locks taken out by other programs with \r\n   the same authorization. \r\n    \r\n   In order to prevent these collisions a lock token MUST be submitted \r\n   by an authorized principal for all locked resources that a method \r\n   may change or the method MUST fail.  A lock token is submitted when \r\n   it appears in an If header.  For example, if a resource is to be \r\n   moved and both the source and destination are locked then two lock \r\n   tokens must be submitted in the if header, one for the source and \r\n   the other for the destination. \r\n    \r\nExample - Write Lock \r\n    \r\n   >>Request \r\n    \r\n     COPY /~fielding/index.html HTTP/1.1 \r\n     Host: www.ics.uci.edu \r\n     Destination: http://www.ics.uci.edu/users/f/fielding/index.html \r\n     If: <http://www.ics.uci.edu/users/f/fielding/index.html> \r\n         (<opaquelocktoken:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>) \r\n      \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 204 No Content \r\n      \r\n      \r\n   In this example, even though both the source and destination are \r\n   locked, only one lock token must be submitted, for the lock on the \r\n   destination.  This is because the source resource is not modified by \r\n   a COPY, and hence unaffected by the write lock. In this example, \r\n   user agent authentication has previously occurred via a mechanism \r\n   outside the scope of the HTTP protocol, in the underlying transport \r\n   layer. \r\n    \r\n7.7 Write Locks and COPY/MOVE \r\n    \r\n   A COPY method invocation MUST NOT duplicate any write locks active \r\n   on the source.  However, as previously noted, if the COPY copies the \r\n   resource into a collection that is locked with \"Depth: infinity\", \r\n   then the resource will be added to the lock. \r\n    \r\n     \r\n                           Expires Oct 2003                         22 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   A successful MOVE request on a write locked resource MUST NOT move \r\n   the write lock with the resource. However, the resource is subject \r\n   to being added to an existing lock at the destination, as specified \r\n   in section 7.5. For example, if the MOVE makes the resource a child \r\n   of a collection that is locked with \"Depth: infinity\", then the \r\n   resource will be added to that collection's lock. Additionally, if a \r\n   resource locked with \"Depth: infinity\" is moved to a destination \r\n   that is within the scope of the same lock (e.g., within the \r\n   namespace tree covered by the lock), the moved resource will again \r\n   be a added to the lock. In both these examples, as specified in \r\n   section 7.6, an If header must be submitted containing a lock token \r\n   for both the source and destination.  \r\n    \r\n7.8 Refreshing Write Locks \r\n    \r\n   A client MUST NOT submit the same write lock request twice.  Note \r\n   that a client is always aware it is resubmitting the same lock \r\n   request because it must include the lock token in the If header in \r\n   order to make the request for a resource that is already locked. \r\n    \r\n   However, a client may submit a LOCK method with an If header but \r\n   without a body.  This form of LOCK MUST only be used to \"refresh\" a \r\n   lock.  Meaning, at minimum, that any timers associated with the lock \r\n   MUST be re-set. \r\n    \r\n   A server may return a Timeout header with a lock refresh that is \r\n   different than the Timeout header returned when the lock was \r\n   originally requested.  Additionally clients may submit Timeout \r\n   headers of arbitrary value with their lock refresh requests.  \r\n   Servers, as always, may ignore Timeout headers submitted by the \r\n   client. Note that timeout is measured in seconds remaining until \r\n   expiration. \r\n    \r\n   If an error is received in response to a refresh LOCK request the \r\n   client MUST NOT assume that the lock was refreshed. \r\n    \r\n8  HTTP Methods for Distributed Authoring \r\n    \r\n8.1 General request and response handling \r\n    \r\n8.1.1   Use of XML \r\n    \r\n   Some of the following new HTTP methods use XML as a request and \r\n   response format.  All DAV compliant clients and resources MUST use \r\n   XML parsers that are compliant with [REC-XML] and [REC-XMLNS].  All \r\n   XML used in either requests or responses MUST be, at minimum, well \r\n   formed and use namespaces correctly.  If a server receives ill-\r\n   formed XML in a request it MUST reject the entire request with a 400 \r\n   (Bad Request).  If a client receives ill-formed XML in a response \r\n   then it MUST NOT assume anything about the outcome of the executed \r\n   method and SHOULD treat the server as malfunctioning. \r\n     \r\n                           Expires Oct 2003                         23 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n8.1.2   Required Bodies in Requests \r\n    \r\n   Some of these new methods do not define bodies.  Servers MUST \r\n   examine all requests for a body, even when a body was not expected.  \r\n   In cases where a request body is present but would be ignored by a \r\n   server, the server MUST reject the request with 415 (Unsupported \r\n   Media Type).  This informs the client (which may have been \r\n   attempting to use an extension) that the body could not be processed \r\n   as they intended. \r\n    \r\n8.1.3   Use of Location header in responses \r\n    \r\n   When the Location header is used in a response, it is used by the \r\n   server to indicate the preferred address for the target resource of \r\n   the request.  Whenever the server has a preferred address, it should \r\n   use that address consistently.  This means that when a response \r\n   contains a Location header, all the URLs in the response body (e.g. \r\n   a Multi-Status) should be consistent (most importantly, should use \r\n   the same host and port). \r\n    \r\n8.1.4   Required Response Headers: Date \r\n    \r\n     Note that HTTP 1.1 requires the Date header in all responses if \r\n     possible. \r\n    \r\n8.1.5   ETag \r\n    \r\n   HTTP 1.1 suggests the use of the ETag header in responses to GET and \r\n   PUT requests. Correct use of ETags is even more important in a \r\n   distributed authoring environment, because ETags are necessary along \r\n   with locks to avoid the lost-update problem.  A client might fail to \r\n   renew a lock, for example when the lock times out and the client is \r\n   accidentally offline or in the middle of a long upload.  When a \r\n   client fails to renew the lock, it's quite possible the resource can \r\n   still be relocked and the user can go on editing, as long as no \r\n   changes were made in the meantime. ETags are required for the client \r\n   to be able to distinguish this case. Otherwise, the client is forced \r\n   to ask the user whether to overwrite the resource on the server \r\n   without even being able to tell the user whether it has changed. \r\n   Timestamps do not solve this problem nearly as well as ETags. \r\n    \r\n   WebDAV servers SHOULD support strong ETags for all resources that \r\n   may be PUT.  If ETags are supported for a resource, the server MUST \r\n   return the ETag header in all PUT and GET responses to that \r\n   resource, as well as provide the same value for the 'getetag' \r\n   property.  \r\n    \r\n   Because clients may be forced to prompt users or throw away changed \r\n   content if the ETag changes, a WebDAV server MUST not change the \r\n   ETag (or getlastmodified value) for a resource when only its \r\n     \r\n                           Expires Oct 2003                         24 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   property values change. The ETag represents the state of the body or \r\n   contents of the resource. There is no similar way to tell if \r\n   properties have changed. \r\n \r\n8.1.6   Including error response bodies \r\n \r\n   HTTP and WebDAV did not use the bodies of most error responses for \r\n   machine-parsable information until DeltaV introduced a mechanism to \r\n   include more specific information in the body of an error response \r\n   (section 1.6 of [RFC3253]). The mechanism is appropriate to use with \r\n   any error response that may take a body but does not already have a \r\n   body defined. The mechanism is particularly appropriate when a \r\n   status code can mean many things (for example, 400 Bad Request can \r\n   mean required headers are missing, headers are incorrectly \r\n   formatted, or much more).  \r\n    \r\n   This mechanism does not take the place of using a correct numeric \r\n   error code as defined here or in HTTP, because the client MUST \r\n   always be able to take a reasonable course of action based only on \r\n   the numeric error.  However, it does remove the need to define new \r\n   numeric error codes, avoiding the confusion of who is allowed to \r\n   define such new codes. The codes used in this mechanism are XML \r\n   elements in a namespace, so naturally any group defining a new error \r\n   code can use their own namespace. As always, the \"DAV:\" namespace is \r\n   reserved for use by IETF-chartered WebDAV working groups. \r\n \r\n   A server supporting \"bis\" SHOULD include a specific XML error code \r\n   in a \"DAV:error\" response body element, when a specific XML error \r\n   code is defined in this document. The \u00f4DAV:error\u00f6 element may \r\n   contain multiple elements describing specific errors. For error \r\n   conditions not specified in this document, the server MAY simply \r\n   choose an appropriate numeric status and leave the response body \r\n   blank. \r\n    \r\n     HTTP/1.1 403 Conflict \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n    \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:error xmlns:D=\"DAV:\"> \r\n       <D:forbid-external-entities/> \r\n     </D:error> \r\n    \r\n   In this specification, both the numeric and the XML error code are \r\n   defined for some failure situations, in which case the XML error \r\n   code must have the \"DAV:\" namespace, appear in the \"error\" root \r\n   element, and be returned in a body with the numeric error code \r\n   specified. \r\n    \r\n   Status codes are specified in this document with the convention of \r\n   following the numeric error code with the XML error code. E.g. \r\n     \r\n                           Expires Oct 2003                         25 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n     403/DAV:forbid-external-entities - response codes when the server  \r\n     refuses to accept external XML entities in XML request bodies. \r\n    \r\n8.2 PROPFIND \r\n    \r\n   The PROPFIND method retrieves properties defined on the resource \r\n   identified by the Request-URI, if the resource does not have any \r\n   internal members, or on the resource identified by the Request-URI \r\n   and potentially its member resources, if the resource is a \r\n   collection that has internal member URLs.  All DAV compliant \r\n   resources MUST support the PROPFIND method and the propfind XML \r\n   element (section 13.25) along with all XML elements defined for use \r\n   with that element. \r\n    \r\n   A client may submit a Depth header with a value of \"0\", \"1\", or \r\n   \"infinity\" with a PROPFIND on a collection resource with internal \r\n   member URLs.  Servers MUST support the \"0\", \"1\" and \"infinity\" \r\n   behaviors on WebDAV-compliant resources. By default, the PROPFIND \r\n   method without a Depth header MUST act as if a \"Depth: infinity\" \r\n   header was included. \r\n    \r\n   A client may submit a propfind XML element in the body of the \r\n   request method describing what information is being requested.  It \r\n   is possible to request: \r\n    \r\n    - Request particular property values, by naming the properties \r\n     desired within the 'prop' element \r\n    - Request all dead property values, by using 'deadprops' element.  \r\n     This can be combined with retrieving specific live properties \r\n     named as above.  Servers advertising support for RFC2518bis MUST \r\n     support this feature. \r\n    - Request property values for those properties defined in this \r\n     specification plus dead properties, by using \u00e6allprop\u00c6 element \r\n    - Request a list of names of all the properties defined on the \r\n     resource, by using the \u00e6propname\u00c6 element.   \r\n    \r\n   A client may choose not to submit a request body.  An empty PROPFIND \r\n   request body MUST be treated as if it were an \u00e6allprop\u00c6 request.   \r\n    \r\n   Note that \u00e6allprop\u00c6 does not return values for all live properties. \r\n   WebDAV servers increasingly have expensively-calculated or lengthy \r\n   properties (see [RFC3253] and [TODO: ref ACL RFC when available]) \r\n   and do not return all properties already.  Instead, WebDAV clients \r\n   can use propname requests to discover what live properties exist, \r\n   and request named properties when retrieving values.  A WebDAV \r\n   server MAY omit certain live properties from other specifications \r\n   when responding to an allprop request from an older client, and MAY \r\n\r\n     \r\n                           Expires Oct 2003                         26 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   return only custom (dead) properties and those defined in this \r\n   specification. \r\n    \r\n    \r\n   All servers MUST support returning a response of content type \r\n   text/xml or application/xml that contains a multistatus XML element \r\n   that describes the results of the attempts to retrieve the various \r\n   properties. \r\n    \r\n   If there is an error retrieving a property then a proper error \r\n   result MUST be included in the response.  A request to retrieve the \r\n   value of a property which does not exist is an error and MUST be \r\n   noted, if the response uses a multistatus XML element, with a \r\n   response XML element which contains a 404 (Not Found) status value. \r\n    \r\n   Consequently, the multistatus XML element for a collection resource \r\n   with member URLs MUST include a response XML element for each member \r\n   URL of the collection, to whatever depth was requested. Each \r\n   response XML element MUST contain an href XML element that gives the \r\n   URL of the resource on which the properties in the prop XML element \r\n   are defined.  URLs for collections appearing in the results MUST end \r\n   in a slash character.  Results for a PROPFIND on a collection \r\n   resource with internal member URLs are returned as a flat list whose \r\n   order of entries is not significant. \r\n \r\n   A server enumerating the members of a collection using absolute URLs \r\n   in a PROPFIND response MUST use a common prefix in those URLs, and \r\n   that prefix MUST be the absolute URL used in the response to refer \r\n   to the parent collection.  \r\n    \r\n   Unless otherwise notified, clients may expect that the URL for the \r\n   parent collection in the PROPFIND response will be the same URL that \r\n   was used to refer to the parent collection in the PROPFIND request.  \r\n   Servers MAY use an alternate URL for the parent collection in a \r\n   PROPFIND response, but in this case the server MUST include a \r\n   Content-Location header whose value is the fully-qualified URL used \r\n   by the server to refer to the parent collection in this response.   \r\n    \r\n   Clients expect the fully-qualified URLs of members of a collection \r\n   to have a common prefix which is the fully-qualified URL of the \r\n   parent collection itself.   \r\n    \r\n   URLs in a PROPFIND response body MAY be represented as fully-\r\n   qualified URLs, in which case they must all contain the full parent \r\n   collection URL (scheme, host, port, and absolute path).  \r\n   Alternatively, these URLs MAY be absolute paths (not containing \r\n   scheme, host or port), but in this case they must all still contain \r\n   the full parent collection path. \r\n    \r\n   If a server allows resource names to include characters that aren\u00c6t \r\n   legal in HTTP URL paths, these characters must be URI-escaped on the \r\n     \r\n                           Expires Oct 2003                         27 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   wire. For example, it is illegal to use a space character or double-\r\n   quote in a URI [RFC2396].  URIs appearing in PROPFIND or PROPPATCH \r\n   XML bodies (or other XML marshalling defined in this specification) \r\n   must also be legal URIs. \r\n    \r\n   Properties may be subject to access control. In the case of allprop \r\n   and propname, if a principal does not have the right to know whether \r\n   a particular property exists then the property should be silently \r\n   excluded from the response. \r\n    \r\n   The results of this method SHOULD NOT be cached. \r\n    \r\n8.2.1   Example - Retrieving Named Properties \r\n    \r\n   >>Request \r\n    \r\n     PROPFIND  /file HTTP/1.1 \r\n     Host: www.example.com \r\n     Content-type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\"> \r\n      <D:prop xmlns:R=\"http://www.example.com/boxschema/\"> \r\n        <R:bigbox/> \r\n        <R:author/> \r\n        <R:DingALing/> \r\n        <R:Random/> \r\n      </D:prop> \r\n     </D:propfind> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:multistatus xmlns:D=\"DAV:\"> \r\n      <D:response xmlns:R=\"http://www.example.com/boxschema/\"> \r\n        <D:href>http://www.example.com/file</D:href> \r\n        <D:propstat> \r\n          <D:prop> \r\n            <R:bigbox> \r\n              <R:BoxType>Box type A</R:BoxType> \r\n            </R:bigbox> \r\n            <R:author> \r\n     \r\n                           Expires Oct 2003                         28 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n              <R:Name>J.J. Johnson</R:Name> \r\n            </R:author> \r\n          </D:prop> \r\n          <D:status>HTTP/1.1 200 OK</D:status> \r\n        </D:propstat> \r\n        <D:propstat> \r\n          <D:prop><R:DingALing/><R:Random/></D:prop> \r\n          <D:status>HTTP/1.1 403 Forbidden</D:status> \r\n          <D:responsedescription> The user does not have access to the \r\n     DingALing property. \r\n          </D:responsedescription> \r\n        </D:propstat> \r\n      </D:response> \r\n      <D:responsedescription> There has been an access violation error.\r\n      </D:responsedescription> \r\n     </D:multistatus> \r\n      \r\n   In this example, PROPFIND is executed on a non-collection resource \r\n   http://www.example.com/file.  The propfind XML element specifies the \r\n   name of four properties whose values are being requested. In this \r\n   case only two properties were returned, since the principal issuing \r\n   the request did not have sufficient access rights to see the third \r\n   and fourth properties. \r\n    \r\n8.2.2   Example - Retrieving Named and Dead Properties \r\n    \r\n   >>Request \r\n    \r\n     PROPFIND /mycol/ HTTP/1.1 \r\n     Host: www.example.com \r\n     Depth: 1 \r\n     Content-type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\"> \r\n      <D:prop> \r\n        <D:creationdate/> \r\n        <D:getlastmodified/> \r\n      </D:prop> \r\n      <D:deadprops/> \r\n     </D:propfind> \r\n    \r\n   In this example, PROPFIND is executed on a collection resource \r\n   http://www.example.com/mycol/.  The client requests the values of \r\n\r\n\r\n     \r\n                           Expires Oct 2003                         29 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   two specific live properties plus all dead properties (names and \r\n   values). The response is not shown. \r\n    \r\n8.2.3   Example - Using propname to Retrieve all Property Names \r\n    \r\n   >>Request \r\n    \r\n     PROPFIND  /container/ HTTP/1.1 \r\n     Host: www.example.com \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <propfind xmlns=\"DAV:\"> \r\n      <propname/> \r\n     </propfind> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <multistatus xmlns=\"DAV:\"> \r\n      <response> \r\n        <href>http://www.example.com/container/</href> \r\n        <propstat> \r\n          <prop xmlns:R=\"http://www.example.com/boxschema/\"> \r\n            <R:bigbox/> \r\n            <R:author/> \r\n            <creationdate/> \r\n            <displayname/> \r\n            <resourcetype/> \r\n            <supportedlock/> \r\n          </prop> \r\n          <status>HTTP/1.1 200 OK</status> \r\n        </propstat> \r\n      </response> \r\n      <response> \r\n        <href>http://www.example.com/container/front.html</href> \r\n        <propstat> \r\n          <prop xmlns:R=\"http://www.example.com/boxschema/\"> \r\n            <R:bigbox/> \r\n            <creationdate/> \r\n            <displayname/> \r\n     \r\n                           Expires Oct 2003                         30 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n            <getcontentlength/> \r\n            <getcontenttype/> \r\n            <getetag/> \r\n            <getlastmodified/> \r\n            <resourcetype/> \r\n            <supportedlock/> \r\n          </prop> \r\n          <status>HTTP/1.1 200 OK</status> \r\n        </propstat> \r\n      </response> \r\n     </multistatus> \r\n    \r\n    \r\n   In this example, PROPFIND is invoked on the collection resource \r\n   http://www.example.com/container/, with a propfind XML element \r\n   containing the propname XML element, meaning the name of all \r\n   properties should be returned.  Since no Depth header is present, it \r\n   assumes its default value of \"infinity\", meaning the name of the \r\n   properties on the collection and all its descendents should be \r\n   returned. \r\n    \r\n   Consistent with the previous example, resource \r\n   http://www.example.com/container/ has six properties defined on it: \r\n   bigbox and author in the \"http://www.example.com/boxschema/\" \r\n   namespace, and creationdate, displayname, resourcetype, and \r\n   supportedlock in the \"DAV:\" namespace.   \r\n    \r\n   The resource http://www.example.com/container/index.html, a member \r\n   of the \"container\" collection, has nine properties defined on it, \r\n   bigbox in the \"http://www.example.com/boxschema/\" namespace and, \r\n   creationdate, displayname, getcontentlength, getcontenttype, \r\n   getetag, getlastmodified, resourcetype, and supportedlock in the \r\n   \"DAV:\" namespace. \r\n    \r\n   This example also demonstrates the use of XML namespace scoping and \r\n   the default namespace.  Since the \"xmlns\" attribute does not contain \r\n   a prefix, the namespace applies by default to all enclosed elements.  \r\n   Hence, all elements which do not explicitly state the namespace to \r\n   which they belong are members of the \"DAV:\" namespace schema. \r\n    \r\n8.2.4   PROPFIND Request Errors \r\n    \r\n   PROPFIND requests may also fail entirely, before the server even \r\n   gets a chance to evaluate individual properties. 404 (Not Found) and \r\n   401 (Unauthorized) are possible as with every request. These are \r\n   some other notable errors. \r\n    \r\n\r\n\r\n     \r\n                           Expires Oct 2003                         31 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   403/DAV:propfind-infinite-depth-forbidden  - A server MAY reject all \r\n   PROPFIND requests on collections with depth header of \"Infinity\", in \r\n   which case it should use this error. \r\n    \r\n8.3 PROPPATCH \r\n    \r\n   The PROPPATCH method processes instructions specified in the request \r\n   body to set and/or remove properties defined on the resource \r\n   identified by the Request-URI. \r\n    \r\n   All DAV compliant resources MUST support the PROPPATCH method and \r\n   MUST process instructions that are specified using the \r\n   propertyupdate, set, and remove XML elements.  Execution of the \r\n   directives in this method is, of course, subject to access control \r\n   constraints.  DAV compliant resources SHOULD support the setting of \r\n   arbitrary dead properties. \r\n    \r\n   The request message body of a PROPPATCH method MUST contain the \r\n   propertyupdate XML element.  Instruction processing MUST occur in \r\n   document order. Instructions MUST either all be executed or none \r\n   executed. Thus if any error occurs during processing all executed \r\n   instructions MUST be undone and a proper error result returned. \r\n   Instruction processing details can be found in the definition of the \r\n   set and remove instructions in sections 13.23 and section 13.24. \r\n    \r\n8.3.1   Status Codes for use with 207 (Multi-Status) \r\n    \r\n   The following are examples of response codes one would expect to be \r\n   used in a 207 (Multi-Status) response for this method.  Note, \r\n   however, that unless explicitly prohibited any 2/3/4/5xx series \r\n   response code may be used in a 207 (Multi-Status) response. \r\n    \r\n   200 (OK) - The command succeeded.  As there can be a mixture of sets \r\n   and removes in a body, a 201 (Created) seems inappropriate. \r\n    \r\n   403 (Forbidden) - The client, for reasons the server chooses not to \r\n   specify, cannot alter one of the properties. \r\n    \r\n   403/DAV:read-only-property: The client has attempted to set a read-\r\n   only property, such as getetag. \r\n    \r\n   409 (Conflict) - The client has provided a value whose semantics are \r\n   not appropriate for the property.   \r\n    \r\n   423 (Locked) - The specified resource is locked and the client \r\n   either is not a lock owner or the lock type requires a lock token to \r\n   be submitted and the client did not submit it. \r\n    \r\n   507 (Insufficient Storage) - The server did not have sufficient \r\n   space to record the property. \r\n    \r\n     \r\n                           Expires Oct 2003                         32 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n8.3.2   Example - PROPPATCH \r\n    \r\n   >>Request \r\n    \r\n     PROPPATCH /bar.html HTTP/1.1 \r\n     Host: www.example.com \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propertyupdate xmlns:D=\"DAV:\"   \r\n     xmlns:Z=\"http://www.w3.com/standards/z39.50/\"> \r\n      <D:set> \r\n        <D:prop> \r\n          <Z:authors> \r\n            <Z:Author>Jim Whitehead</Z:Author> \r\n            <Z:Author>Roy Fielding</Z:Author> \r\n          </Z:authors> \r\n        </D:prop> \r\n      </D:set> \r\n      <D:remove> \r\n        <D:prop><Z:Copyright-Owner/></D:prop> \r\n      </D:remove> \r\n     </D:propertyupdate> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:multistatus xmlns:D=\"DAV:\" \r\n     xmlns:Z=\"http://www.w3.com/standards/z39.50\"> \r\n      <D:response> \r\n        <D:href>http://www.example.com/bar.html</D:href> \r\n        <D:propstat> \r\n          <D:prop><Z:Authors/></D:prop> \r\n          <D:status>HTTP/1.1 424 Failed Dependency</D:status> \r\n        </D:propstat> \r\n        <D:propstat> \r\n          <D:prop><Z:Copyright-Owner/></D:prop> \r\n          <D:status>HTTP/1.1 409 Conflict</D:status> \r\n        </D:propstat> \r\n\r\n\r\n     \r\n                           Expires Oct 2003                         33 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n        <D:responsedescription> Copyright Owner can not be deleted or \r\n     altered.</D:responsedescription> \r\n      </D:response> \r\n     </D:multistatus> \r\n    \r\n   In this example, the client requests the server to set the value of \r\n   the \"Authors\" property in the \"http://www.w3.com/standards/z39.50/\" \r\n   namespace, and to remove the property \"Copyright-Owner\" in the \r\n   \"http://www.w3.com/standards/z39.50/\" namespace.  Since the \r\n   Copyright-Owner property could not be removed, no property \r\n   modifications occur.  The 424 (Failed Dependency) status code for \r\n   the Authors property indicates this action would have succeeded if \r\n   it were not for the conflict with removing the Copyright-Owner \r\n   property. \r\n    \r\n8.4 MKCOL Method \r\n    \r\n   The MKCOL method is used to create a new collection. All WebDAV \r\n   compliant resources MUST support the MKCOL method. \r\n    \r\n   MKCOL creates a new collection resource at the location specified by \r\n   the Request-URI.  If the resource identified by the Request-URI is \r\n   non-null then the MKCOL MUST fail.  During MKCOL processing, a \r\n   server MUST make the Request-URI a member of its parent collection, \r\n   unless the Request-URI is \"/\".  If no such ancestor exists, the \r\n   method MUST fail.  When the MKCOL operation creates a new collection \r\n   resource, all ancestors MUST already exist, or the method MUST fail \r\n   with a 409 (Conflict) status code.  For example, if a request to \r\n   create collection /a/b/c/d/ is made, and neither /a/b/ nor /a/b/c/ \r\n   exists, the request must fail. \r\n    \r\n   When MKCOL is invoked without a request body, the newly created \r\n   collection SHOULD have no members. \r\n    \r\n   A MKCOL request message may contain a message body.  The behavior of \r\n   a MKCOL request when the body is present is limited to creating \r\n   collections, members of a collection, bodies of members and \r\n   properties on the collections or members.  If the server receives a \r\n   MKCOL request entity type it does not support or understand it MUST \r\n   respond with a 415 (Unsupported Media Type) status code.  If the \r\n   server decides to reject the request based on the presence of an \r\n   entity or the type of an entity, it should use the 415 (Unsupported \r\n   Media Type) status code.  The exact behavior of MKCOL for various \r\n   request media types is undefined in this document, and will be \r\n   specified in separate documents. \r\n    \r\nStatus Codes \r\n    \r\n   Responses from a MKCOL request MUST NOT be cached as MKCOL has non-\r\n   idempotent semantics. \r\n     \r\n                           Expires Oct 2003                         34 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   201 (Created) - The collection or structured resource was created in \r\n   its entirety. \r\n    \r\n   403 (Forbidden) - This indicates at least one of two conditions: 1) \r\n   the server does not allow the creation of collections at the given \r\n   location in its namespace, or 2) the parent collection of the \r\n   Request-URI exists but cannot accept members. \r\n    \r\n   405 (Method Not Allowed) - MKCOL can only be executed on a \r\n   deleted/non-existent resource. \r\n    \r\n   409 (Conflict) - A collection cannot be made at the Request-URI \r\n   until one or more intermediate collections have been created.  The \r\n   server MUST NOT create those intermediate collections automatically. \r\n    \r\n   415 (Unsupported Media Type) - The server does not support the \r\n   request type of the body. \r\n    \r\n   507 (Insufficient Storage) - The resource does not have sufficient \r\n   space to record the state of the resource after the execution of \r\n   this method. \r\n    \r\n8.4.1   Example - MKCOL \r\n    \r\n   This example creates a collection called /webdisc/xfiles/ on the \r\n   server www.example.com. \r\n    \r\n   >>Request \r\n    \r\n     MKCOL /webdisc/xfiles/ HTTP/1.1 \r\n     Host: www.example.com \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 201 Created \r\n      \r\n    \r\n8.5 GET, HEAD for Collections \r\n    \r\n   The semantics of GET are unchanged when applied to a collection, \r\n   since GET is defined as, \"retrieve whatever information (in the form \r\n   of an entity) is identified by the Request-URI\" [RFC2616].  GET when \r\n   applied to a collection may return the contents of an \"index.html\" \r\n   resource, a human-readable view of the contents of the collection, \r\n   or something else altogether. Hence it is possible that the result \r\n   of a GET on a collection will bear no correlation to the membership \r\n   of the collection. \r\n    \r\n\r\n     \r\n                           Expires Oct 2003                         35 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Similarly, since the definition of HEAD is a GET without a response \r\n   message body, the semantics of HEAD are unmodified when applied to \r\n   collection resources. \r\n    \r\n8.6 POST for Collections \r\n    \r\n   Since by definition the actual function performed by POST is \r\n   determined by the server and often depends on the particular \r\n   resource, the behavior of POST when applied to collections cannot be \r\n   meaningfully modified because it is largely undefined.  Thus the \r\n   semantics of POST are unmodified when applied to a collection. \r\n    \r\n8.7 DELETE \r\n    \r\nDELETE for Non-Collection Resources \r\n    \r\n   When a client issues a DELETE request to a Request-URI mapping to a \r\n   non-collection resource, if the operation is successful the server \r\n   MUST remove that mapping.  Thus, after a successful DELETE operation \r\n   (and in the absence of other actions) a subsequent GET/HEAD/PROPFIND \r\n   request to the target Request-URI would return 404 (Not Found). \r\n    \r\nDELETE for Collections \r\n    \r\n   The DELETE method on a collection MUST act as if a \"Depth: infinity\" \r\n   header was used on it.  A client MUST NOT submit a Depth header with \r\n   a DELETE on a collection with any value but infinity. \r\n    \r\n   DELETE instructs that the collection specified in the Request-URI \r\n   and all resources identified by its internal member URLs are to be \r\n   deleted. \r\n    \r\n   If any resource identified by a member URL cannot be deleted then \r\n   all of the member's ancestors MUST NOT be deleted, so as to maintain \r\n   namespace consistency.        \r\n    \r\n   Any headers included with DELETE MUST be applied in processing every \r\n   resource to be deleted. \r\n    \r\n   When the DELETE method has completed processing it MUST result in a \r\n   consistent namespace. \r\n    \r\n   If an error occurs deleting an internal resource (a resource other \r\n   than the resource identified in the Request-URI) then the response \r\n   can be a 207 (Multi-Status). Multi-Status is used here to indicate \r\n   which internal resources could NOT be deleted, including an error \r\n   code which should help the client understand which resources caused \r\n   the failure.  For example, the Multi-Status body could include a \r\n   response with status 423 (Locked) if an internal resource was \r\n   locked.   \r\n     \r\n                           Expires Oct 2003                         36 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   The server MAY return a 4xx status response, rather than a Multi-\r\n   Status, if the entire DELETE request failed and it can\u00c6t identify \r\n   the internal resources that caused the DELETE to fail. \r\n    \r\n   424 (Failed Dependency) errors SHOULD NOT be in the 207 (Multi-\r\n   Status).  They can be safely left out because the client will know \r\n   that the ancestors of a resource could not be deleted when the \r\n   client receives an error for the ancestor's progeny.  Additionally \r\n   204 (No Content) errors SHOULD NOT be returned in the 207 (Multi-\r\n   Status).  The reason for this prohibition is that 204 (No Content) \r\n   is the default success code. \r\n    \r\n8.7.1   Example - DELETE \r\n    \r\n   >>Request \r\n    \r\n     DELETE  /container/ HTTP/1.1 \r\n     Host: www.example.com \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <d:multistatus xmlns:d=\"DAV:\"> \r\n      <d:response> \r\n        <d:href>http://www.example.com/container/resource3</d:href> \r\n        <d:status>HTTP/1.1 423 Locked</d:status> \r\n      </d:response> \r\n     </d:multistatus> \r\n      \r\n   In this example the attempt to delete \r\n   http://www.example.com/container/resource3 failed because it is \r\n   locked, and no lock token was submitted with the request. \r\n   Consequently, the attempt to delete \r\n   http://www.example.com/container/ also failed. Thus the client knows \r\n   that the attempt to delete http://www.example.com/container/ must \r\n   have also failed since the parent can not be deleted unless its \r\n   child has also been deleted.  Even though a Depth header has not \r\n   been included, a depth of infinity is assumed because the method is \r\n   on a collection. \r\n    \r\n8.8 PUT \r\n    \r\nPUT for Non-Collection Resources \r\n    \r\n     \r\n                           Expires Oct 2003                         37 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   A PUT performed on an existing resource replaces the GET response \r\n   entity of the resource.  Properties defined on the resource may be \r\n   recomputed during PUT processing but are not otherwise affected.  \r\n   For example, if a server recognizes the content type of the request \r\n   body, it may be able to automatically extract information that could \r\n   be profitably exposed as properties. \r\n    \r\n   A PUT that would result in the creation of a resource without an \r\n   appropriately scoped parent collection MUST fail with a 409 \r\n   (Conflict). \r\n    \r\nPUT for Collections \r\n    \r\n   As defined in [RFC2616], the \"PUT method requests that the enclosed \r\n   entity be stored under the supplied Request-URI.\"  Since submission \r\n   of an entity representing a collection would implicitly encode \r\n   creation and deletion of resources, this specification intentionally \r\n   does not define a transmission format for creating a collection \r\n   using PUT.  Instead, the MKCOL method is defined to create \r\n   collections. \r\n    \r\n8.9 COPY Method \r\n    \r\n   The COPY method creates a duplicate of the source resource, \r\n   identified by the Request-URI, in the destination resource, \r\n   identified by the URI in the Destination header.  The Destination \r\n   header MUST be present.  The exact behavior of the COPY method \r\n   depends on the type of the source resource. \r\n    \r\n   All WebDAV compliant resources MUST support the COPY method.  \r\n   However, support for the COPY method does not guarantee the ability \r\n   to copy a resource. For example, separate programs may control \r\n   resources on the same server.  As a result, it may not be possible \r\n   to copy a resource to a location that appears to be on the same \r\n   server. \r\n    \r\nCOPY for HTTP/1.1 resources \r\n    \r\n   When the source resource is not a collection the result of the COPY \r\n   method is the creation of a new resource at the destination whose \r\n   state and behavior match that of the source resource as closely as \r\n   possible.  After a successful COPY invocation, all properties on the \r\n   source resource MUST be duplicated on the destination resource, \r\n   subject to modifying headers and XML elements, following the \r\n   definition for copying properties.  Since the environment at the \r\n   destination may be different than at the source due to factors \r\n   outside the scope of control of the server, such as the absence of \r\n   resources required for correct operation, it may not be possible to \r\n   completely duplicate the behavior of the resource at the \r\n   destination. Subsequent alterations to the destination resource will \r\n     \r\n                           Expires Oct 2003                         38 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   not modify the source resource.  Subsequent alterations to the \r\n   source resource will not modify the destination resource. \r\n    \r\nCOPY for Properties \r\n    \r\n   Live properties described in this document SHOULD be duplicated as \r\n   identically behaving live properties at the destination resource, \r\n   but not necessarily with the same values.  If a property cannot be \r\n   copied live, then its value MUST be duplicated, octet-for-octet, in \r\n   an identically named, dead property on the destination resource. \r\n    \r\n   A COPY operation creates a new resource, much like a PUT operation \r\n   does.  Live properties which are related to resource creation (such \r\n   as creationdate) should have their values set accordingly. \r\n    \r\n   Dead properties must be duplicated exactly. \r\n    \r\n8.9.1   COPY for Collections \r\n    \r\n   The COPY method on a collection without a Depth header MUST act as \r\n   if a Depth header with value \"infinity\" was included.  A client may \r\n   submit a Depth header on a COPY on a collection with a value of \"0\" \r\n   or \"infinity\".  Servers MUST support the \"0\" and \"infinity\" Depth \r\n   header behaviors on WebDAV-compliant resources. \r\n    \r\n   A COPY of depth infinity instructs that the collection resource \r\n   identified by the Request-URI is to be copied to the location \r\n   identified by the URI in the Destination header, and all its \r\n   internal member resources are to be copied to a location relative to \r\n   it, recursively through all levels of the collection hierarchy. \r\n    \r\n   A COPY of \"Depth: 0\" only instructs that the collection and its \r\n   properties but not resources identified by its internal member URLs, \r\n   are to be copied. \r\n    \r\n   Any headers included with a COPY MUST be applied in processing every \r\n   resource to be copied with the exception of the Destination header. \r\n    \r\n   The Destination header only specifies the destination URI for the \r\n   Request-URI. When applied to members of the collection identified by \r\n   the Request-URI the value of Destination is to be modified to \r\n   reflect the current location in the hierarchy.  So, if the Request-\r\n   URI is /a/ with Host header value http://fun.com/ and the \r\n   Destination is http://fun.com/b/ then when http://fun.com/a/c/d is \r\n   processed it must use a Destination of http://fun.com/b/c/d. \r\n    \r\n   When the COPY method has completed processing it MUST have created a \r\n   consistent namespace at the destination (see section 5.1 for the \r\n   definition of namespace consistency).  However, if an error occurs \r\n   while copying an internal collection, the server MUST NOT copy any \r\n\r\n     \r\n                           Expires Oct 2003                         39 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   resources identified by members of this collection (i.e., the server \r\n   must skip this subtree), as this would create an inconsistent \r\n   namespace. After detecting an error, the COPY operation SHOULD try \r\n   to finish as much of the original copy operation as possible (i.e., \r\n   the server should still attempt to copy other subtrees and their \r\n   members, that are not descendents of an error-causing collection).  \r\n   So, for example, if an infinite depth copy operation is performed on \r\n   collection /a/, which contains collections /a/b/ and /a/c/, and an \r\n   error occurs copying /a/b/, an attempt should still be made to copy \r\n   /a/c/. Similarly, after encountering an error copying a non-\r\n   collection resource as part of an infinite depth copy, the server \r\n   SHOULD try to finish as much of the original copy operation as \r\n   possible. \r\n    \r\n   If an error in executing the COPY method occurs with a resource \r\n   other than the resource identified in the Request-URI then the \r\n   response MUST be a 207 (Multi-Status), and the URL of the resource \r\n   causing the failure MUST appear with the specific error.  \r\n    \r\n   The 424 (Failed Dependency) status code SHOULD NOT be returned in \r\n   the 207 (Multi-Status) response from a COPY method.  These responses \r\n   can be safely omitted because the client will know that the progeny \r\n   of a resource could not be copied when the client receives an error \r\n   for the parent.  Additionally 201 (Created)/204 (No Content) status \r\n   codes SHOULD NOT be returned as values in 207 (Multi-Status) \r\n   responses from COPY methods.  They, too, can be safely omitted \r\n   because they are the default success codes. \r\n    \r\n8.9.2   COPY and the Overwrite Header \r\n    \r\n   If a resource exists at the destination and the Overwrite header is \r\n   \"T\" then prior to performing the copy the server MUST perform a \r\n   DELETE with \"Depth: infinity\" on the destination resource.  If the \r\n   Overwrite header is set to \"F\" then the operation will fail. \r\n    \r\n8.9.3   Status Codes \r\n    \r\n   201 (Created) - The source resource was successfully copied.  The \r\n   copy operation resulted in the creation of a new resource. \r\n    \r\n   204 (No Content) - The source resource was successfully copied to a \r\n   pre-existing destination resource. \r\n    \r\n   207 (Multi-Status) - Multiple resources were to be affected by the \r\n   COPY, but errors on some of them prevented the operation from taking \r\n   place.  Specific error messages, together with the most appropriate \r\n   of the source and destination URLs, appear in the body of the multi-\r\n   status response. E.g. if a destination resource was locked and could \r\n   not be overwritten, then the destination resource URL appears with \r\n   the 423 (Locked) status. \r\n    \r\n     \r\n                           Expires Oct 2003                         40 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   403 (Forbidden) - The operation is forbidden.  Possibly this is \r\n   because the source and destination resources are the same resource. \r\n    \r\n   409 (Conflict) - A resource cannot be created at the destination \r\n   until one or more intermediate collections have been created.  The \r\n   server MUST NOT create those intermediate collections automatically. \r\n    \r\n   412 (Precondition Failed) - A precondition failed, e.g. the \r\n   Overwrite header is \"F\" and the state of the destination resource is \r\n   non-null. \r\n    \r\n   423 (Locked) - The destination resource was locked. \r\n    \r\n   502 (Bad Gateway) - This may occur when the destination is on \r\n   another server, repository or context.  Either the source context \r\n   does not support copying to the destination context, or the \r\n   destination context refuses to accept the resource. The client may \r\n   wish to try GET/PUT and PROPFIND/PROPPATCH instead. \r\n    \r\n   507 (Insufficient Storage) - The destination resource does not have \r\n   sufficient space to record the state of the resource after the \r\n   execution of this method. \r\n    \r\n8.9.4   Example - COPY with Overwrite \r\n    \r\n   This example shows resource \r\n   http://www.ics.uci.edu/~fielding/index.html being copied to the \r\n   location http://www.ics.uci.edu/users/f/fielding/index.html.  The \r\n   204 (No Content) status code indicates the existing resource at the \r\n   destination was overwritten. \r\n    \r\n   >>Request \r\n    \r\n     COPY /~fielding/index.html HTTP/1.1 \r\n     Host: www.ics.uci.edu \r\n     Destination: http://www.ics.uci.edu/users/f/fielding/index.html \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 204 No Content \r\n      \r\nExample - COPY with No Overwrite \r\n    \r\n   The following example shows the same copy operation being performed, \r\n   but with the Overwrite header set to \"F.\"  A response of 412 \r\n   (Precondition Failed) is returned because the destination resource \r\n   has a non-null state. \r\n    \r\n   >>Request \r\n    \r\n     \r\n                           Expires Oct 2003                         41 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     COPY /~fielding/index.html HTTP/1.1 \r\n     Host: www.ics.uci.edu \r\n     Destination: http://www.ics.uci.edu/users/f/fielding/index.html \r\n     Overwrite: F \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 412 Precondition Failed \r\n      \r\nExample - COPY of a Collection \r\n    \r\n   >>Request \r\n    \r\n     COPY /container/ HTTP/1.1 \r\n     Host: www.example.com \r\n     Destination: http://www.example.com/othercontainer/ \r\n     Depth: infinity \r\n      \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n      \r\n     <d:multistatus xmlns:d=\"DAV:\"> \r\n      <d:response> \r\n        <d:href>http://www.example.com/othercontainer/R2/</d:href> \r\n        <d:status>HTTP/1.1 423 Locked</d:status> \r\n      </d:response> \r\n     </d:multistatus> \r\n    \r\n   The Depth header is unnecessary as the default behavior of COPY on a \r\n   collection is to act as if a \"Depth: infinity\" header had been \r\n   submitted.  In this example most of the resources, along with the \r\n   collection, were copied successfully. However the collection R2 \r\n   failed because the destination R2 is locked.  Because there was an \r\n   error copying R2, none of R2's members were copied.  However no \r\n   errors were listed for those members due to the error minimization \r\n   rules. \r\n    \r\n8.10    MOVE Method \r\n    \r\n   The MOVE operation on a non-collection resource is the logical \r\n   equivalent of a copy (COPY), followed by consistency maintenance \r\n   processing, followed by a delete of the source, where all three \r\n\r\n     \r\n                           Expires Oct 2003                         42 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   actions are performed atomically.  The consistency maintenance step \r\n   allows the server to perform updates caused by the move, such as \r\n   updating all URLs other than the Request-URI which identify the \r\n   source resource, to point to the new destination resource.  \r\n   Consequently, the Destination header MUST be present on all MOVE \r\n   methods and MUST follow all COPY requirements for the COPY part of \r\n   the MOVE method.  All WebDAV compliant resources MUST support the \r\n   MOVE method.  However, support for the MOVE method does not \r\n   guarantee the ability to move a resource to a particular \r\n   destination.  \r\n    \r\n   For example, separate programs may actually control different sets \r\n   of resources on the same server.  Therefore, it may not be possible \r\n   to move a resource within a namespace that appears to belong to the \r\n   same server. \r\n    \r\n   If a resource exists at the destination, the destination resource \r\n   will be DELETEd as a side-effect of the MOVE operation, subject to \r\n   the restrictions of the Overwrite header. \r\n    \r\n8.10.1  MOVE for Properties \r\n \r\n    \r\n   Live properties described in this document MUST be moved along with \r\n   the resource, such that the resource has identically behaving live \r\n   properties at the destination resource, but not necessarily with the \r\n   same values.  If the live properties will not work the same way at \r\n   the destination, the server MUST fail the request (the client can \r\n   perform COPY then DELETE if it wants a MOVE to work that badly). \r\n   This can mean that the server removes a live property if that's the \r\n   most appropriate behavior for that live property at the destination. \r\n    \r\n   A MOVE can be a rename operation, so it's not appropriate to reset \r\n   live properties which are set at resource creation. For example, the \r\n   creationdate property value SHOULD remain the same. \r\n    \r\n   Dead properties must be moved along with the resource. \r\n   . \r\n    \r\n8.10.2  MOVE for Collections \r\n    \r\n   A MOVE with \"Depth: infinity\" instructs that the collection \r\n   identified by the Request-URI be moved to the address specified in \r\n   the Destination header, and all resources identified by its internal \r\n   member URLs are to be moved to locations relative to it, recursively \r\n   through all levels of the collection hierarchy. \r\n    \r\n   The MOVE method on a collection MUST act as if a \"Depth: infinity\" \r\n   header was used on it.  A client MUST NOT submit a Depth header on a \r\n   MOVE on a collection with any value but \"infinity\". \r\n    \r\n     \r\n                           Expires Oct 2003                         43 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Any headers included with MOVE MUST be applied in processing every \r\n   resource to be moved with the exception of the Destination header. \r\n    \r\n   The behavior of the Destination header is the same as given for COPY \r\n   on collections.  \r\n    \r\n   When the MOVE method has completed processing it MUST have created a \r\n   consistent namespace at both the source and destination (see section \r\n   5.1 for the definition of namespace consistency). However, if an \r\n   error occurs while moving an internal collection, the server MUST \r\n   NOT move any resources identified by members of the failed \r\n   collection (i.e., the server must skip the error-causing subtree), \r\n   as this would create an inconsistent namespace. In this case, after \r\n   detecting the error, the move operation SHOULD try to finish as much \r\n   of the original move as possible (i.e., the server should still \r\n   attempt to move other subtrees and the resources identified by their \r\n   members, that are not descendents of an error-causing collection).  \r\n   So, for example, if an infinite depth move is performed on \r\n   collection /a/, which contains collections /a/b/ and /a/c/, and an \r\n   error occurs moving /a/b/, an attempt should still be made to try \r\n   moving /a/c/. Similarly, after encountering an error moving a non-\r\n   collection resource as part of an infinite depth move, the server \r\n   SHOULD try to finish as much of the original move operation as \r\n   possible. \r\n    \r\n   If an error occurs with a resource other than the resource \r\n   identified in the Request-URI then the response MUST be a 207 \r\n   (Multi-Status), and the errored resource's URL MUST appear with the \r\n   specific error. \r\n    \r\n   The 424 (Failed Dependency) status code SHOULD NOT be returned in \r\n   the 207 (Multi-Status) response from a MOVE method.  These errors \r\n   can be safely omitted because the client will know that the progeny \r\n   of a resource could not be moved when the client receives an error \r\n   for the parent.  Additionally 201 (Created)/204 (No Content) \r\n   responses SHOULD NOT be returned as values in 207 (Multi-Status) \r\n   responses from a MOVE.  These responses can be safely omitted \r\n   because they are the default success codes. \r\n    \r\n8.10.3  MOVE and the Overwrite Header \r\n    \r\n   If a resource exists at the destination and the Overwrite header is \r\n   \"T\" then prior to performing the move the server MUST perform a \r\n   DELETE with \"Depth: infinity\" on the destination resource.  If the \r\n   Overwrite header is set to \"F\" then the operation will fail. \r\n    \r\n8.10.4  Status Codes \r\n    \r\n   201 (Created) - The source resource was successfully moved, and a \r\n   new resource was created at the destination. \r\n    \r\n     \r\n                           Expires Oct 2003                         44 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   204 (No Content) - The source resource was successfully moved to a \r\n   pre-existing destination resource. \r\n    \r\n   207 (Multi-Status) - Multiple resources were to be affected by the \r\n   MOVE, but errors on some of them prevented the operation from taking \r\n   place.  Specific error messages, together with the most appropriate \r\n   of the source and destination URLs, appear in the body of the multi-\r\n   status response. E.g. if a source resource was locked and could not \r\n   be moved, then the source resource URL appears with the 423 (Locked) \r\n   status. \r\n    \r\n   403 (Forbidden) \u00fb The source and destination resources are the same. \r\n    \r\n   409 (Conflict) \u00fb A resource cannot be created at the destination \r\n   until one or more intermediate collections have been created.  The \r\n   server MUST NOT create those intermediate collections automatically. \r\n    \r\n    \r\n   412 (Precondition Failed) \u00fb A condition failed, e.g. the Overwrite \r\n   header is \"F\" and the state of the destination resource is non-null. \r\n    \r\n   423 (Locked) - The source or the destination resource was locked. \r\n    \r\n   500/DAV:live-properties-not-preserved - The server was unable to \r\n   preserve the behavior of the live properties and still move the \r\n   resource to the destination.   \r\n    \r\n   502 (Bad Gateway) - This may occur when the destination is on \r\n   another server and the destination server refuses to accept the \r\n   resource. \r\n    \r\n8.10.5  Example - MOVE of a Non-Collection \r\n    \r\n   This example shows resource \r\n   http://www.ics.uci.edu/~fielding/index.html being moved to the \r\n   location http://www.ics.uci.edu/users/f/fielding/index.html. The \r\n   contents of the destination resource would have been overwritten if \r\n   the destination resource had been non-null.  In this case, since \r\n   there was nothing at the destination resource, the response code is \r\n   201 (Created). \r\n    \r\n   >>Request \r\n    \r\n     MOVE /~fielding/index.html HTTP/1.1 \r\n     Host: www.ics.uci.edu \r\n     Destination: http://www.ics.uci.edu/users/f/fielding/index.html \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 201 Created \r\n     \r\n                           Expires Oct 2003                         45 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     Location: http://www.ics.uci.edu/users/f/fielding/index.html \r\n      \r\n      \r\nExample - MOVE of a Collection \r\n    \r\n   >>Request \r\n    \r\n     MOVE /container/ HTTP/1.1 \r\n     Host: www.example.com \r\n     Destination: http://www.example.com/othercontainer/ \r\n     Overwrite: F \r\n     If: (<opaquelocktoken:fe184f2e-6eec-41d0-c765-01adc56e6bb4>) \r\n         (<opaquelocktoken:e454f3f3-acdc-452a-56c7-00a5c91e4b77>) \r\n      \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <d:multistatus xmlns:d='DAV:'> \r\n      <d:response> \r\n        <d:href>http://www.example.com/othercontainer/C2/</d:href> \r\n        <d:status>HTTP/1.1 423 Locked</d:status> \r\n      </d:response> \r\n     </d:multistatus> \r\n    \r\n   In this example the client has submitted a number of lock tokens \r\n   with the request.  A lock token will need to be submitted for every \r\n   resource, both source and destination, anywhere in the scope of the \r\n   method, that is locked.  In this case the proper lock token was not \r\n   submitted for the destination \r\n   http://www.example.com/othercontainer/C2/. This means that the \r\n   resource /container/C2/ could not be moved.  Because there was an \r\n   error moving /container/C2/, none of /container/C2's members were \r\n   moved.  However no errors were listed for those members due to the \r\n   error minimization rules.  User agent authentication has previously \r\n   occurred via a mechanism outside the scope of the HTTP protocol, in \r\n   an underlying transport layer. \r\n    \r\n8.11    LOCK Method \r\n    \r\n   The following sections describe the LOCK method, which is used to \r\n   take out a lock of any access type and to refresh an existing lock.  \r\n   These sections on the LOCK method describe only those semantics that \r\n\r\n     \r\n                           Expires Oct 2003                         46 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   are specific to the LOCK method and are independent of the access \r\n   type of the lock being requested. \r\n    \r\n   Any resource which supports the LOCK method MUST, at minimum, \r\n   support the XML request and response formats defined herein. \r\n    \r\nOperation \r\n    \r\n   A LOCK method invocation creates the lock specified by the lockinfo \r\n   XML element on the resource indicated by the Request-URI, which \r\n   becomes the root of the lock.  Lock method requests to create a new \r\n   lock MUST have a XML request body which contains an owner XML \r\n   element for this lock request. The server MUST preserve the \r\n   information provided by the client in the owner field when the lock \r\n   information is requested.  The LOCK request MAY have a Timeout \r\n   header. \r\n    \r\n   Clients MUST assume that locks may arbitrarily disappear at any \r\n   time, regardless of the value given in the Timeout header.  The \r\n   Timeout header only indicates the behavior of the server if \r\n   \"extraordinary\" circumstances do not occur.  For example, a \r\n   sufficiently privileged user may remove a lock at any time or the \r\n   system may crash in such a way that it loses the record of the \r\n   lock's existence. The response MUST contain the value of the \r\n   lockdiscovery property in a prop XML element. \r\n    \r\n   In order to indicate the lock token associated with a newly created \r\n   lock, a Lock-Token response header MUST be included in the response \r\n   for every successful LOCK request for a new lock.  Note that the \r\n   Lock-Token header would not be returned in the response for a \r\n   successful refresh LOCK request because a new lock was not created. \r\n    \r\nRefreshing Locks \r\n    \r\n   A lock is refreshed by sending a new LOCK request to the resource \r\n   which is the root of the lock. A LOCK request to refresh a lock must \r\n   specify which lock to refresh by using the Lock-Token header with a \r\n   single lock token (only one lock may be refreshed at a time).  This \r\n   request does not contain a body, but it may contain a Timeout \r\n   header.  A server MAY accept the Timeout header to change the \r\n   duration remaining on the lock to the new value.  \r\n    \r\n   If the resource has other (shared) locks, those locks are unaffected \r\n   by a lock refresh.  Additionally, those locks do not prevent the \r\n   named lock from being refreshed. \r\n    \r\n   Note that in RFC2518, clients were indicated through the example in \r\n   the text to use the If header to specify what lock to refresh \r\n   (rather than the Lock-Token header). Servers are encouraged to \r\n   continue to support this as well as the Lock-Token header. \r\n     \r\n                           Expires Oct 2003                         47 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n \r\nThe Effect of Locks on Properties and Collections \r\n    \r\n   The scope of a lock is the entire state of the resource, including \r\n   its body and associated properties.  As a result, a lock on a \r\n   resource MUST also lock the resource's properties. \r\n    \r\n   For collections, a lock also affects the ability to add or remove \r\n   members.  The nature of the effect depends upon the type of access \r\n   control involved.  This means that if a collection is locked, its \r\n   lock-token is required in all these cases: \r\n    - DELETE a collection\u00c6s direct  internal member \r\n    - MOVE a member out of the collection \r\n    - MOVE a member into the collection, unless it overwrites a pre-\r\n      existing member \r\n    - MOVE to rename it within a collection, \r\n    - COPY a member into a collection, unless it overwrites a pre-\r\n      existing member \r\n    - PUT or MKCOL request which would create a new member.   \r\n   The collection\u00c6s lock token is required in addition to the lock \r\n   token on the internal member itself, if it exists. \r\n    \r\nLocking Replicated Resources \r\n    \r\n   A resource may be made available through more than one URI. However \r\n   locks apply to resources, not URIs. Therefore a LOCK request on a \r\n   resource MUST NOT succeed if can not be honored by all the URIs \r\n   through which the resource is addressable. \r\n    \r\nDepth and Locking \r\n    \r\n   The Depth header may be used with the LOCK method.  Values other \r\n   than 0 or infinity MUST NOT be used with the Depth header on a LOCK \r\n   method.  All resources that support the LOCK method MUST support the \r\n   Depth header. \r\n    \r\n   A Depth header of value 0 means to just lock the resource specified \r\n   by the Request-URI. \r\n    \r\n   If the Depth header is set to infinity then the resource specified \r\n   in the Request-URI along with all its internal members, all the way \r\n   down the hierarchy, are to be locked.  A successful result MUST \r\n   return a single lock token which represents all the resources that \r\n   have been locked.  If an UNLOCK is successfully executed on this \r\n   token, all associated resources are unlocked.  If the lock cannot be \r\n   granted to all resources, a 409 (Conflict) status code MUST be \r\n   returned with a response entity body containing a multistatus XML \r\n   element describing which resource(s) prevented the lock from being \r\n\r\n     \r\n                           Expires Oct 2003                         48 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   granted.  Hence, partial success is not an option.  Either the \r\n   entire hierarchy is locked or no resources are locked. \r\n    \r\n   If no Depth header is submitted on a LOCK request then the request \r\n   MUST act as if a \"Depth:infinity\" had been submitted. \r\n    \r\nInteraction with other Methods \r\n    \r\n   The interaction of a LOCK with various methods is dependent upon the \r\n   lock type.  However, independent of lock type, a successful DELETE \r\n   of a resource MUST cause all of its direct locks to be removed. \r\n    \r\nLocking Unmapped URLs \r\n    \r\n   A successful LOCK method MUST result in the creation of an empty \r\n   resource which is locked (and which is not a collection), when a \r\n   resource did not previously exist at that URL.  Later on, the lock \r\n   may go away but the empty resource remains.  Empty resources MUST \r\n   then appear in PROPFIND responses including that URL in the response \r\n   scope.  A server MUST respond successfully to a GET request to an \r\n   empty resource, either by using a 204 No Content response, or by \r\n   using 200 OK with a Content-Length header indicating zero length and \r\n   no Content-Type. \r\n    \r\nLock Compatibility Table \r\n    \r\n   The table below describes the behavior that occurs when a lock \r\n   request is made on a resource. \r\n    \r\n     Current State   Shared Lock Request   Exclusive Lock Request \r\n   -------------------------------------------------------------------- \r\n     None            True                  True \r\n     Shared Lock     True                  False \r\n     Exclusive Lock  False                 False* \r\n    \r\n    \r\n   Legend: True = lock may be granted.  False = lock MUST NOT be \r\n   granted. *=It is illegal for a principal to request the same lock \r\n   twice. \r\n    \r\n   The current lock state of a resource is given in the leftmost \r\n   column, and lock requests are listed in the first row.  The \r\n   intersection of a row and column gives the result of a lock request.  \r\n   For example, if a shared lock is held on a resource, and an \r\n   exclusive lock is requested, the table entry is \"false\", indicating \r\n   the lock must not be granted. \r\n    \r\nStatus Codes \r\n    \r\n\r\n     \r\n                           Expires Oct 2003                         49 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   200 (OK) - The lock request succeeded and the value of the \r\n   lockdiscovery property is included in the body. \r\n                \r\n   409 (Conflict) \u00fb A resource cannot be created at the destination \r\n   until one or more intermediate collections have been created.  The \r\n   server MUST NOT create those intermediate collections automatically. \r\n    \r\n   412 (Precondition Failed) - The included lock token was not \r\n   enforceable on this resource or the server could not satisfy the \r\n   request in the lockinfo XML element. \r\n    \r\n   423 (Locked) - The resource is locked, so the method has been \r\n   rejected.  \r\n    \r\n8.11.1  Example - Simple Lock Request \r\n    \r\n   >>Request \r\n    \r\n     LOCK /workspace/webdav/proposal.doc HTTP/1.1 \r\n     Host: example.com \r\n     Timeout: Infinite, Second-4100000000 \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n     Authorization: Digest username=\"ejw\", \r\n        realm=\"ejw@example.com\", nonce=\"...\", \r\n        uri=\"/workspace/webdav/proposal.doc\", \r\n        response=\"...\", opaque=\"...\" \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:lockinfo xmlns:D='DAV:'> \r\n      <D:lockscope><D:exclusive/></D:lockscope> \r\n      <D:locktype><D:write/></D:locktype> \r\n      <D:owner> \r\n        <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href> \r\n      </D:owner> \r\n     </D:lockinfo> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 200 OK \r\n     Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4> \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:prop xmlns:D=\"DAV:\"> \r\n      <D:lockdiscovery> \r\n     \r\n                           Expires Oct 2003                         50 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n        <D:activelock> \r\n          <D:locktype><D:write/></D:locktype> \r\n          <D:lockscope><D:exclusive/></D:lockscope> \r\n          <D:depth>infinity</D:depth> \r\n          <D:owner> \r\n            <D:href> \r\n              http://www.ics.uci.edu/~ejw/contact.html \r\n            </D:href> \r\n          </D:owner> \r\n          <D:timeout>Second-604800</D:timeout> \r\n          <D:locktoken> \r\n            <D:href>opaquelocktoken:e71d4fae-5dec-22d6-fea5-\r\n     00a0c91e6be4</D:href> \r\n          </D:locktoken> \r\n          <D:lockroot> \r\n            <D:href>http://example.com/workspace/webdav \r\n              /proposal.doc</D:href> \r\n          </D:lockroot> \r\n        </D:activelock> \r\n      </D:lockdiscovery> \r\n     </D:prop> \r\n      \r\n   This example shows the successful creation of an exclusive write \r\n   lock on resource http://example.com/workspace/webdav/proposal.doc.  \r\n   The resource http://www.ics.uci.edu/~ejw/contact.html contains \r\n   contact information for the owner of the lock.  The server has an \r\n   activity-based timeout policy in place on this resource, which \r\n   causes the lock to automatically be removed after 1 week (604800 \r\n   seconds).  Note that the nonce, response, and opaque fields have not \r\n   been calculated in the Authorization request header. \r\n    \r\n   Note that the locktoken and lockroot href elements would not contain \r\n   any whitespace.  The line return appearing in this document is only \r\n   for formatting. \r\n    \r\n8.11.2  Example - Refreshing a Write Lock \r\n    \r\n   >>Request \r\n    \r\n     LOCK /workspace/webdav/proposal.doc HTTP/1.1 \r\n     Host: example.com \r\n     Timeout: Infinite, Second-4100000000 \r\n     Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4> \r\n     Authorization: Digest username=\"ejw\", \r\n        realm=\"ejw@example.com\", nonce=\"...\", \r\n        uri=\"/workspace/webdav/proposal.doc\", \r\n        response=\"...\", opaque=\"...\" \r\n     \r\n                           Expires Oct 2003                         51 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 200 OK \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:prop xmlns:D=\"DAV:\"> \r\n      <D:lockdiscovery> \r\n        <D:activelock> \r\n          <D:locktype><D:write/></D:locktype> \r\n          <D:lockscope><D:exclusive/></D:lockscope> \r\n          <D:depth>infinity</D:depth> \r\n          <D:owner> \r\n            <D:href> \r\n            http://www.ics.uci.edu/~ejw/contact.html \r\n            </D:href> \r\n          </D:owner> \r\n          <D:timeout>Second-604800</D:timeout> \r\n          <D:locktoken> \r\n            <D:href>opaquelocktoken:e71d4fae-5dec-22d6-fea5-\r\n     00a0c91e6be4</D:href> \r\n          </D:locktoken> \r\n          <D:lockroot> \r\n            <D:href>http://example.com/workspace/webdav \r\n              /proposal.doc</D:href> \r\n          </D:lockroot> \r\n        </D:activelock> \r\n      </D:lockdiscovery> \r\n     </D:prop> \r\n    \r\n   This request would refresh the lock, attempting to reset the timeout \r\n   to the new value specified in the timeout header.  Notice that the \r\n   client asked for an infinite time out but the server choose to \r\n   ignore the request. In this example, the nonce, response, and opaque \r\n   fields have not been calculated in the Authorization request header. \r\n    \r\n8.11.3  Example - Multi-Resource Lock Request \r\n    \r\n   >>Request \r\n    \r\n     LOCK /webdav/ HTTP/1.1 \r\n     Host: example.com \r\n     Timeout: Infinite, Second-4100000000 \r\n     Depth: infinity \r\n\r\n     \r\n                           Expires Oct 2003                         52 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n     Authorization: Digest username=\"ejw\", \r\n        realm=\"ejw@example.com\", nonce=\"...\", \r\n        uri=\"/workspace/webdav/proposal.doc\", \r\n        response=\"...\", opaque=\"...\" \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:lockinfo xmlns:D=\"DAV:\"> \r\n      <D:locktype><D:write/></D:locktype> \r\n      <D:lockscope><D:exclusive/></D:lockscope> \r\n      <D:owner> \r\n        <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href> \r\n      </D:owner> \r\n     </D:lockinfo> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:multistatus xmlns:D=\"DAV:\"> \r\n      <D:response> \r\n        <D:href>http://example.com/webdav/secret</D:href> \r\n        <D:status>HTTP/1.1 403 Forbidden</D:status> \r\n      </D:response> \r\n      <D:response> \r\n        <D:href>http://example.com/webdav/</D:href> \r\n        <D:propstat> \r\n          <D:prop><D:lockdiscovery/></D:prop> \r\n          <D:status>HTTP/1.1 424 Failed Dependency</D:status> \r\n        </D:propstat> \r\n      </D:response> \r\n     </D:multistatus> \r\n      \r\n   This example shows a request for an exclusive write lock on a \r\n   collection and all its children.  In this request, the client has \r\n   specified that it desires an infinite length lock, if available, \r\n   otherwise a timeout of 4.1 billion seconds, if available. The \r\n   request entity body contains the contact information for the \r\n   principal taking out the lock, in this case a web page URL. \r\n    \r\n   The error is a 403 (Forbidden) response on the resource \r\n   http://example.com/webdav/secret.  Because this resource could not \r\n     \r\n                           Expires Oct 2003                         53 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   be locked, none of the resources were locked.  Note also that the \r\n   lockdiscovery property for the Request-URI has been included as \r\n   required.  In this example the lockdiscovery property is empty which \r\n   means that there are no outstanding locks on the resource. \r\n    \r\n   In this example, the nonce, response, and opaque fields have not \r\n   been calculated in the Authorization request header. \r\n    \r\n8.12    UNLOCK Method \r\n    \r\n   The UNLOCK method removes the lock identified by the lock token in \r\n   the Lock-Token request header from the Request-URI and all other \r\n   resources included in the lock.  The root of the lock MUST be named \r\n   by the Request-URI, not any other resource within the scope of the \r\n   lock.  Servers SHOULD redirect the UNLOCK request to the lock root.  \r\n   Failing that, servers MAY fail an UNLOCK request to a resource that \r\n   is not directly locked (not the root of the lock) with error code \r\n   400 (Bad Request). \r\n    \r\n   If all resources which have been locked under the submitted lock \r\n   token can not be unlocked then the UNLOCK request MUST fail. \r\n    \r\n   A successful response to an UNLOCK method does not mean that the \r\n   resource is necessarily unlocked.  It means that the specific lock \r\n   corresponding to the specified token no longer exists. \r\n    \r\n   Any DAV compliant resource which supports the LOCK method MUST \r\n   support the UNLOCK method. \r\n    \r\nStatus Codes \r\n    \r\n   204 (No Content) \u00fb Normal success response \r\n    \r\n   400 (Bad Request) \u00fb No lock token was provided, or request was not \r\n   made to lock root. \r\n                \r\n   412 (Precondition Failed) - The resource was not locked. \r\n \r\n \r\n8.12.1  Example - UNLOCK \r\n    \r\n   >>Request \r\n    \r\n     UNLOCK /workspace/webdav/info.doc HTTP/1.1 \r\n     Host: example.com \r\n     Lock-Token: <opaquelocktoken:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7> \r\n     Authorization: Digest username=\"ejw\", \r\n        realm=\"ejw@example.com\", nonce=\"...\", \r\n        uri=\"/workspace/webdav/proposal.doc\", \r\n\r\n     \r\n                           Expires Oct 2003                         54 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n        response=\"...\", opaque=\"...\" \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 204 No Content \r\n      \r\n      \r\n   In this example, the lock identified by the lock token \r\n   \"opaquelocktoken:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7\" is \r\n   successfully removed from the resource \r\n   http://example.com/workspace/webdav/info.doc.  If this lock included \r\n   more than just one resource, the lock is removed from all resources \r\n   included in the lock.  The 204 (No Content) status code is used \r\n   instead of 200 (OK) because there is no response entity body. \r\n    \r\n   In this example, the nonce, response, and opaque fields have not \r\n   been calculated in the Authorization request header. \r\n    \r\n    \r\n    \r\n9  HTTP Headers for Distributed Authoring \r\n    \r\n   All DAV headers follow the same basic formatting rules as HTTP \r\n   headers. This includes rules like line continuation and how to \r\n   combine (or separate) multiple instances of the same header using \r\n   commas. \r\n    \r\n9.1 DAV Header \r\n    \r\n   DAV             = \"DAV\" \":\" #( compliance-code ) \r\n   compliance-code = ( \"1\" | \"2\" | \"bis\" | extend ) \r\n   extend          = Coded-URL | token \r\n    \r\n   This header indicates that the resource supports the DAV schema and \r\n   protocol as specified. All DAV compliant resources MUST return the \r\n   DAV header on all OPTIONS responses. \r\n    \r\n   The value is a comma-separated list of all compliance class \r\n   identifiers that the resource supports.  Class identifiers may be \r\n   Coded-URLs or tokens (as defined by [RFC2616]). Identifiers can \r\n   appear in any order. \r\n    \r\n   A resource must show class 1 compliance if it shows class 2 or \"bis\" \r\n   compliance. In general, support for one compliance class does not \r\n   entail support for any other.  Please refer to section 16 for more \r\n   details on compliance classes defined in this specification. \r\n    \r\n9.2 Depth Header \r\n    \r\n\r\n     \r\n                           Expires Oct 2003                         55 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Depth = \"Depth\" \":\" (\"0\" | \"1\" | \"infinity\") \r\n    \r\n   The Depth header is used with methods executed on resources which \r\n   could potentially have internal members to indicate whether the \r\n   method is to be applied only to the resource (\"Depth: 0\"), to the \r\n   resource and its immediate children, (\"Depth: 1\"), or the resource \r\n   and all its progeny (\"Depth: infinity\"). \r\n    \r\n   The Depth header is only supported if a method's definition \r\n   explicitly provides for such support. \r\n    \r\n   The following rules are the default behavior for any method that \r\n   supports the Depth header. A method may override these defaults by \r\n   defining different behavior in its definition. \r\n    \r\n   Methods which support the Depth header may choose not to support all \r\n   of the header's values and may define, on a case by case basis, the \r\n   behavior of the method if a Depth header is not present. For \r\n   example, the MOVE method only supports \"Depth: infinity\" and if a \r\n   Depth header is not present will act as if a \"Depth: infinity\" \r\n   header had been applied. \r\n    \r\n   Clients MUST NOT rely upon methods executing on members of their \r\n   hierarchies in any particular order or on the execution being atomic \r\n   unless the particular method explicitly provides such guarantees. \r\n    \r\n   Upon execution, a method with a Depth header will perform as much of \r\n   its assigned task as possible and then return a response specifying \r\n   what it was able to accomplish and what it failed to do. \r\n    \r\n   So, for example, an attempt to COPY a hierarchy may result in some \r\n   of the members being copied and some not. \r\n    \r\n   Any headers on a method that has a defined interaction with the \r\n   Depth header MUST be applied to all resources in the scope of the \r\n   method except where alternative behavior is explicitly defined. For \r\n   example, an If-Match header will have its value applied against \r\n   every resource in the method's scope and will cause the method to \r\n   fail if the header fails to match. \r\n    \r\n   If a resource, source or destination, within the scope of the method \r\n   with a Depth header is locked in such a way as to prevent the \r\n   successful execution of the method, then the lock token for that \r\n   resource MUST be submitted with the request in the If request \r\n   header. \r\n    \r\n   The Depth header only specifies the behavior of the method with \r\n   regards to internal children.  If a resource does not have internal \r\n   children then the Depth header MUST be ignored. \r\n    \r\n\r\n     \r\n                           Expires Oct 2003                         56 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Please note, however, that it is always an error to submit a value \r\n   for the Depth header that is not allowed by the method's definition.  \r\n   Thus submitting a \"Depth: 1\" on a COPY, even if the resource does \r\n   not have internal members, will result in a 400 (Bad Request). The \r\n   method should fail not because the resource doesn't have internal \r\n   members, but because of the illegal value in the header. \r\n    \r\n9.3 Destination Header \r\n    \r\n   Destination = \"Destination\" \":\" ( absoluteURI | abs_path ) \r\n    \r\n   The Destination header specifies the URI which identifies a \r\n   destination resource for methods such as COPY and MOVE, which take \r\n   two URIs as parameters.  Note that the absoluteURI and abs_path \r\n   production are defined in [RFC2396].  If abs_path is used, the \r\n   scheme, host and port of the destination are the same as those for \r\n   the Request-URI (note the Host header, which must be present on \r\n   requests, contains the host and port). \r\n    \r\n   If the Destination value is an absolute URI, it may name a different \r\n   server (or different port or scheme). If the source server cannot \r\n   attempt a copy to the remote server, it MUST fail the request with a \r\n   502 (Bad Gateway) response.  \r\n    \r\n    \r\n    \r\n9.4 Force-Authentication Header \r\n    \r\n   Force-Authentication = \"Force-Authentication\" \":\" Method \r\n    \r\n   The Force-Authentication header is used with the OPTIONS method to \r\n   specify that the client wants to be challenged for authentication \r\n   credentials to the resource identified by the Request-URI.  If \r\n   present on a request to a WebDAV-compliant resource, the server MUST \r\n   respond with either 401 (Unauthorized) or 501 (Not Implemented) \r\n   status code. The Method value is used for the client to indicate \r\n   what method it intends to use first on the resource identified in \r\n   the Request-URI.  \r\n    \r\n9.5 If Header \r\n    \r\n   If = \"If\" \":\" ( 1*No-tag-list | 1*Tagged-list) \r\n   No-tag-list = List \r\n   Tagged-list = Resource 1*List \r\n   Resource = Coded-URL \r\n   List = \"(\" 1*([\"Not\"](State-token | \"[\" entity-tag \"]\")) \")\" \r\n   State-token = Coded-URL | \"<DAV:no-lock>\" \r\n   Coded-URL = \"<\" absoluteURI \">\" \r\n    \r\n     \r\n                           Expires Oct 2003                         57 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   The If header is intended to have similar functionality to the If-\r\n   Match header defined in section 14.24 of [RFC2616].  However the If \r\n   header is intended for use with any URI which represents state \r\n   information, referred to as a state token, about a resource as well \r\n   as ETags.  A typical example of a state token is a lock token, and \r\n   lock tokens are the only state tokens defined in this specification. \r\n   The <DAV:no-lock> state token is a token that must never match an \r\n   actual valid lock token. The purpose of this is described in section \r\n   9.5.5. \r\n    \r\n   The If header's purpose is to describe a series of state lists.  If \r\n   the state of the resource to which the header is applied does not \r\n   match any of the specified state lists then the request MUST fail \r\n   with a 412 (Precondition Failed).  If one of the described state \r\n   lists matches the state of the resource then the request may \r\n   succeed. \r\n    \r\n   The server must parse the If header when it appears on any request, \r\n   evaluate all the clauses, and if the conditional evaluates to false, \r\n   fail the request.  \r\n    \r\n   Note that the absoluteURI production is defined in [RFC2396]. \r\n    \r\n   RFC2518 originally defined the If header without comma separators. \r\n   This oversight meant that the If header couldn't be divided up among \r\n   multiple lines according to the HTTP header manipulation rules. \r\n   Servers supporting \"bis\" MUST be able to accept commas in If header \r\n   values. If the header has commas between tokens or clauses, the \r\n   header can be evaluated simply by removing the commas and proceeding \r\n   with the evaluation rules. \r\n    \r\n9.5.1   No-tag-list Production \r\n    \r\n   The No-tag-list production describes a series of state tokens and \r\n   ETags.  If multiple No-tag-list productions are used then one only \r\n   needs to match the state of the resource for the method to be \r\n   allowed to continue.  All untagged tokens apply to the resource \r\n   identified in the Request-URI. \r\n    \r\n9.5.2   Example - No-tag-list If Header \r\n    \r\n     If: (<opaquelocktoken:a-write-lock-token> [\"I am an ETag\"]), ([\"I \r\n     am another ETag\"]) \r\n    \r\n   The previous header would require that the resource identified in \r\n   the Request-URI be locked with the specified lock token and in the \r\n   state identified by the \"I am an ETag\" ETag or in the state \r\n   identified by the second ETag \"I am another ETag\".  To put the \r\n   matter more plainly one can think of the previous If header as being \r\n\r\n     \r\n                           Expires Oct 2003                         58 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   in the form (or (and <opaquelocktoken:a-write-lock-token> [\"I am an \r\n   ETag\"]) (and [\"I am another ETag\"])). \r\n    \r\n9.5.3   Tagged-list Production \r\n    \r\n   The tagged-list production scopes a list production.  That is, it \r\n   specifies that the lists following the resource specification only \r\n   apply to the specified resource.  The scope of the resource \r\n   production begins with the list production immediately following the \r\n   resource production and ends with the next resource production, if \r\n   any.  All clauses must be evaluated. \r\n    \r\n \r\n   The same URI MUST NOT appear more than once in a resource production \r\n   in an If header. \r\n    \r\n9.5.4   Example - Tagged List If header \r\n    \r\n     COPY /resource1 HTTP/1.1 \r\n     Host: www.example.com \r\n     Destination: http://www.example.com/resource2 \r\n     If: <http://www.example.com/resource1> (<locktoken:a-write-lock-\r\n     token> [W/\"A weak ETag\"]), ([\"strong ETag\"]), \r\n     <http://www.bar.bar/random>([\"another strong ETag\"]) \r\n    \r\n   In this example http://www.example.com/resource1 is being copied to \r\n   http://www.example.com/resource2.  When the method is first applied \r\n   to http://www.example.com/resource1, resource1 must be in the state \r\n   specified by \"(<locktoken:a-write-lock-token> [W/\"A weak ETag\"]) \r\n   ([\"strong ETag\"])\", that is, it either must be locked with a lock \r\n   token of \"locktoken:a-write-lock-token\" and have a weak entity tag \r\n   W/\"A weak ETag\" or it must have a strong entity tag \"strong ETag\". \r\n    \r\n   That is the only success condition since the resource \r\n   http://www.bar.bar/random never has the method applied to it (the \r\n   only other resource listed in the If header) and \r\n   http://www.example.com/resource2 is not listed in the If header. \r\n    \r\n9.5.5   Not Production \r\n    \r\n   Every state token or ETag is either current, and hence describes the \r\n   state of a resource, or is not current, and does not describe the \r\n   state of a resource. The boolean operation of matching a state token \r\n   or ETag to the current state of a resource thus resolves to a true \r\n   or false value.  The \u00e6Not\u00c6 production is used to reverse that value.  \r\n   The scope of the not production is the state-token or entity-tag \r\n   immediately following it. \r\n    \r\n     If: (Not <locktoken:write1> <locktoken:write2>) \r\n    \r\n     \r\n                           Expires Oct 2003                         59 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   When submitted with a request, this If header requires that all \r\n   operand resources must not be locked with locktoken:write1 and must \r\n   be locked with locktoken:write2. \r\n    \r\n   The Not production is particularly useful with the \"<DAV:no-lock>\" \r\n   state token defined. The clause \"Not <DAV:no-lock>\" must evaluate to \r\n   true. Thus, any \"OR\" statement containing the clause \"Not <DAV:no-\r\n   lock> must also evaluate to true.  \r\n    \r\n9.5.6   Matching Function \r\n    \r\n   When performing If header processing, the definition of a matching \r\n   state token or entity tag is as follows. \r\n    \r\n   Matching entity tag: Where the entity tag matches an entity tag \r\n   associated with that resource. \r\n    \r\n   Matching state token: Where there is an exact match between the \r\n   state token in the If header and any state token on the resource. \r\n \r\n9.5.7   If Header and Non-DAV Aware Proxies \r\n    \r\n   Non-DAV aware proxies will not honor the If header, since they will \r\n   not understand the If header, and HTTP requires non-understood \r\n   headers to be ignored.  When communicating with HTTP/1.1 proxies, \r\n   the \"Cache-Control: no-cache\" request header MUST be used so as to \r\n   prevent the proxy from improperly trying to service the request from \r\n   its cache.  When dealing with HTTP/1.0 proxies the \"Pragma: no-\r\n   cache\" request header MUST be used for the same reason. \r\n    \r\n9.6 Lock-Token Header \r\n    \r\n   Lock-Token = \"Lock-Token\" \":\" Coded-URL \r\n    \r\n   The Lock-Token request header is used with the UNLOCK method to \r\n   identify the lock to be removed.  The lock token in the Lock-Token \r\n   request header MUST identify a lock that contains the resource \r\n   identified by Request-URI as a member. \r\n    \r\n   The Lock-Token response header is used with the LOCK method to \r\n   indicate the lock token created as a result of a successful LOCK \r\n   request to create a new lock. \r\n    \r\n9.7 Overwrite Header \r\n    \r\n   Overwrite = \"Overwrite\" \":\" (\"T\" | \"F\") \r\n    \r\n   The Overwrite header specifies whether the server should overwrite \r\n   the state of a non-null destination resource during a COPY or MOVE.  \r\n   A value of \"F\" states that the server must not perform the COPY or \r\n     \r\n                           Expires Oct 2003                         60 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   MOVE operation if the state of the destination resource is non-null. \r\n   If the overwrite header is not included in a COPY or MOVE request \r\n   then the resource MUST treat the request as if it has an overwrite \r\n   header of value \"T\". While the Overwrite header appears to duplicate \r\n   the functionality of the If-Match: * header of HTTP/1.1, If-Match \r\n   applies only to the Request-URI, and not to the Destination of a \r\n   COPY or MOVE. \r\n    \r\n   If a COPY or MOVE is not performed due to the value of the Overwrite \r\n   header, the method MUST fail with a 412 (Precondition Failed) status \r\n   code. \r\n    \r\n   All DAV compliant resources MUST support the Overwrite header. \r\n    \r\n9.8 Status-URI Response Header \r\n    \r\n   The Status-URI response header may be used with the 102 (Processing) \r\n   status code to inform the client as to the status of a method. \r\n    \r\n   Status-URI = \"Status-URI\" \":\" *(Status-Code Coded-URL) ; Status-Code \r\n   is defined in 6.1.1 of [RFC2616] \r\n    \r\n   The URIs listed in the header are source resources which have been \r\n   affected by the outstanding method.  The status code indicates the \r\n   resolution of the method on the identified resource.  So, for \r\n   example, if a MOVE method on a collection is outstanding and a 102 \r\n   (Processing) response with a Status-URI response header is returned, \r\n   the included URIs will indicate resources that have had move \r\n   attempted on them and what the result was. \r\n    \r\n9.9 Timeout Request Header \r\n    \r\n   TimeOut = \"Timeout\" \":\" 1#TimeType \r\n   TimeType = (\"Second-\" DAVTimeOutVal | \"Infinite\") \r\n   DAVTimeOutVal = 1*digit \r\n    \r\n   Clients may include Timeout headers in their LOCK requests.  \r\n   However, the server is not required to honor or even consider these \r\n   requests.  Clients MUST NOT submit a Timeout request header with any \r\n   method other than a LOCK method. \r\n    \r\n   Timeout response values MUST use a Second value or Infinite. \r\n    \r\n   The \"Second\" TimeType specifies the number of seconds that will \r\n   elapse between granting of the lock at the server, and the automatic \r\n   removal of the lock.  The timeout value for TimeType \"Second\" MUST \r\n   NOT be greater than 2^32-1. \r\n    \r\n     \r\n                           Expires Oct 2003                         61 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   The timeout counter MUST be restarted if a refresh LOCK request is \r\n   successful.  The timeout counter SHOULD NOT be restarted at any \r\n   other time.   \r\n    \r\n   If the timeout expires then the lock may be lost.  Specifically, if \r\n   the server wishes to harvest the lock upon time-out, the server \r\n   SHOULD act as if an UNLOCK method was executed by the server on the \r\n   resource using the lock token of the timed-out lock, performed with \r\n   its override authority. Thus logs should be updated with the \r\n   disposition of the lock, notifications should be sent, etc., just as \r\n   they would be for an UNLOCK request. \r\n    \r\n   Servers are advised to pay close attention to the values submitted \r\n   by clients, as they will be indicative of the type of activity the \r\n   client intends to perform.  For example, an applet running in a \r\n   browser may need to lock a resource, but because of the instability \r\n   of the environment within which the applet is running, the applet \r\n   may be turned off without warning.  As a result, the applet is \r\n   likely to ask for a relatively small timeout value so that if the \r\n   applet dies, the lock can be quickly harvested.  However, a document \r\n   management system is likely to ask for an extremely long timeout \r\n   because its user may be planning on going off-line. \r\n    \r\n   A client MUST NOT assume that just because the time-out has expired \r\n   the lock has been lost. Likewise, a client MUST NOT assume that just \r\n   because the time-out has not expired, the lock still exists (and for \r\n   this reason, clients are strongly advised to use ETags as well). \r\n    \r\n10 Status Code Extensions to HTTP/1.1 \r\n    \r\n   The following status codes are added to those defined in HTTP/1.1 \r\n   [RFC2616]. \r\n    \r\n10.1    102 Processing \r\n    \r\n   The 102 (Processing) status code is an interim response used to \r\n   inform the client that the server has accepted the complete request, \r\n   but has not yet completed it.  This status code SHOULD only be sent \r\n   when the server has a reasonable expectation that the request will \r\n   take significant time to complete. As guidance, if a method is \r\n   taking longer than 20 seconds (a reasonable, but arbitrary value) to \r\n   process the server SHOULD return a 102 (Processing) response. The \r\n   server MUST send a final response after the request has been \r\n   completed. \r\n    \r\n   Methods can potentially take a long period of time to process, \r\n   especially methods that support the Depth header.  In such cases the \r\n   client may time-out the connection while waiting for a response.  To \r\n     \r\n                           Expires Oct 2003                         62 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   prevent this the server may return a 102 (Processing) status code to \r\n   indicate to the client that the server is still processing the \r\n   method. \r\n    \r\n10.2    207 Multi-Status \r\n    \r\n   The 207 (Multi-Status) status code provides status for multiple \r\n   independent operations (see section 12 for more information). \r\n    \r\n10.3    422 Unprocessable Entity \r\n    \r\n   The 422 (Unprocessable Entity) status code means the server \r\n   understands the content type of the request entity (hence a \r\n   415(Unsupported Media Type) status code is inappropriate), and the \r\n   syntax of the request entity is correct (thus a 400 (Bad Request) \r\n   status code is inappropriate) but was unable to process the \r\n   contained instructions.  For example, this error condition may occur \r\n   if an XML request body contains well-formed (i.e., syntactically \r\n   correct), but semantically erroneous XML instructions. \r\n    \r\n10.4    423 Locked \r\n    \r\n   The 423 (Locked) status code means the source or destination \r\n   resource of a method is locked. \r\n    \r\n10.5    424 Failed Dependency \r\n    \r\n   The 424 (Failed Dependency) status code means that the method could \r\n   not be performed on the resource because the requested action \r\n   depended on another action and that action failed.  For example, if \r\n   a command in a PROPPATCH method fails then, at minimum, the rest of \r\n   the commands will also fail with 424 (Failed Dependency). \r\n    \r\n10.6    507 Insufficient Storage \r\n    \r\n   The 507 (Insufficient Storage) status code means the method could \r\n   not be performed on the resource because the server is unable to \r\n   store the representation needed to successfully complete the \r\n   request.  This condition is considered to be temporary.  If the \r\n   request which received this status code was the result of a user \r\n   action, the request MUST NOT be repeated until it is requested by a \r\n   separate user action. \r\n    \r\n    \r\n11 Use of HTTP Status Codes \r\n    \r\n11.1    301 Moved Permanently \r\n    \r\n   Any WebDAV request may be redirected using this status code. \r\n\r\n     \r\n                           Expires Oct 2003                         63 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n11.2    302 Found \r\n    \r\n   Any WebDAV request may be redirected using this status code. \r\n    \r\n11.3    400 Bad Request \r\n    \r\n   This code may be used if: \r\n    - the Host header is missing in any request \r\n    - The protocol version is HTTP/1.0 \r\n    - Any header is improperly formatted  \r\n    - The request method line is improperly formatted \r\n    \r\n11.4    403 Forbidden \r\n    \r\n   Uses: \r\n    - The server does not ever accept this method on this kind of \r\n   resource. For example, if a PUT is not accepted on a collection. \r\n    \r\n11.5    409 Conflict \r\n    \r\n   The 409 Conflict is most typically returned when a method that \r\n   attempts to create a new resource must fail, because one of the \r\n   collections that resource depends on does not exist.  However, other \r\n   types of conflicts are defined in specifications extending RFC2518.  \r\n   Therefore, this can be returned in response to all methods. \r\n    \r\n    \r\n11.6    414 Request-URI Too Long \r\n    \r\n   This status code is used in HTTP 1.1 only for Request-URIs, because \r\n   full URIs aren\u00c6t used in other headers. WebDAV specifies full URLs \r\n   in other headers, therefore this error may be used if the URI is too \r\n   long in other locations as well. This status code may be used in \r\n   response to any method in this specification. \r\n\r\n12 Multi-Status Response \r\n    \r\n   The default 207 (Multi-Status) response body is a text/xml or \r\n   application/xml HTTP entity that contains a single XML element \r\n   called multistatus, which contains a set of XML elements called \r\n   response which contain 200, 300, 400, and 500 series status codes \r\n   generated during the method invocation.  100 series status codes \r\n   SHOULD NOT be recorded in a response XML element.  The 207 status \r\n   code itself MUST NOT be considered a success response, it is only \r\n   completely successful if all response elements inside contain \r\n   success status codes. \r\n    \r\n   The body of a 207 Multi-Status response MUST contain a URL \r\n   associated with each specific status code, so that the client can \r\n     \r\n                           Expires Oct 2003                         64 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   tell whether the error occurred with the source resource, \r\n   destination resource or some other resource in the scope of the \r\n   request. URLs for collections appearing in the results SHOULD end in \r\n   a \u00e6/\u00c6 character.   \r\n    \r\n   When a Multi-Status response does not have a clear scope (e.g. in \r\n   response to MOVE or COPY when the scope could be either the source \r\n   or the destination), URLs appearing in the response body SHOULD be \r\n   absolute and fully-qualified URLs.   \r\n    \r\n   When a Multi-Status response does have a clear scope, especially in \r\n   response to a PROPFIND request when all URLs appearing in the body \r\n   must be inside the collection named in the request-URI, the URLs MAY \r\n   be absolute or MAY be relative.   \r\n    - If the URLs are absolute, then the server MUST ensure that the \r\n   URLs have the same prefix (scheme, host, port, and path) as the URL \r\n   of the requested collection (which may be the same as the Request-\r\n   URI or may be the corrected in the response Location header). \r\n    - If the URLs are relative, they MUST be resolved against the \r\n   Location header, if present, or as second choice against the \r\n   Request-URI. \r\n    \r\n12.1    Responses requiring Location in Multi-Status \r\n    \r\n   The 300-303, 305 and 307 responses defined in HTTP 1.1 normally take \r\n   a Location header to indicate where the client should make the \r\n   request.  The Multi-Status response syntax does not allow for the \r\n   Location header information to be included in an unambiguous way, so \r\n   servers MAY choose not to use these status codes in Multi-Status \r\n   responses. If a clients receives this status code in Multi-Status, \r\n   the client MAY reissue the request to the individual resource, so \r\n   that the server can issue a response with a Location header for each \r\n   resource.  \r\n\r\n13 XML Element Definitions \r\n    \r\n   In the section below, the final line of each section gives the \r\n   element type declaration using the format defined in [REC-XML]. The \r\n   \"Value\" field, where present, specifies further restrictions on the \r\n   allowable contents of the XML element using BNF (i.e., to further \r\n   restrict the values of a PCDATA element). \r\n    \r\n   All of the elements defined here may be extended by the addition of \r\n   attributes and child elements not defined in this specification.  \r\n    \r\n13.1    activelock XML Element \r\n    \r\n   Name:    activelock \r\n   Namespace:   DAV: \r\n     \r\n                           Expires Oct 2003                         65 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Purpose: Describes a lock on a resource. \r\n    \r\n   <!ELEMENT activelock ANY> \r\n   ANY value: Any number of elements, including one of each of \r\n   (lockscope, locktype, depth, owner, timeout, locktoken, lockroot)  \r\n    \r\n13.2    depth XML Element \r\n    \r\n   Name:    depth \r\n   Namespace:   DAV: \r\n   Purpose: The value of the Depth header. \r\n   Value:   \"0\" | \"1\" | \"infinity\"    \r\n    \r\n   <!ELEMENT depth (#PCDATA) > \r\n    \r\n13.3    locktoken XML Element \r\n    \r\n   Name:    locktoken \r\n   Namespace:   DAV: \r\n   Purpose: The lock token associated with a lock. \r\n   Description:         The href contains a single lock token URI which \r\n            refers to the lock (i.e., the OpaqueLockToken-URI \r\n            production in section 6.4). \r\n    \r\n   <!ELEMENT locktoken (href) > \r\n    \r\n13.4    lockroot XML Element \r\n    \r\n   Name:    lockroot \r\n   Namespace:   DAV: \r\n   Purpose: The resource where the lock is \u00f4rooted\u00f6, which is the \r\n            resource that was addressed in the LOCK request. \r\n   Description: The href contains a URL with the address of the root of \r\n            the lock. The server SHOULD include this in all \r\n            lockdiscovery property values and the response to LOCK \r\n            requests. \r\n    \r\n   <!ELEMENT lockroot (href) > \r\n    \r\n13.5    timeout XML Element \r\n    \r\n   Name:    timeout \r\n   Namespace:   DAV: \r\n   Purpose: The number of seconds remaining before a lock expires. \r\n   Value:   TimeType ;Defined in section 9.9. \r\n\r\n     \r\n                           Expires Oct 2003                         66 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   <!ELEMENT timeout (#PCDATA) > \r\n    \r\n13.6    collection XML Element \r\n    \r\n   Name:    collection \r\n   Namespace:   DAV: \r\n   Purpose: Identifies the associated resource as a collection. The \r\n            resourcetype property of a collection resource MUST have \r\n            this value.  It is normally empty but extensions may add \r\n            sub-elements. \r\n    \r\n   <!ELEMENT collection EMPTY > \r\n    \r\n13.7    href XML Element \r\n    \r\n   Name:    href \r\n   Namespace:   DAV: \r\n   Purpose: Identifies the content of the element as a URI. \r\n   Value:   URI ; See section 3.2.1 of [RFC2616] \r\n    \r\n   <!ELEMENT href (#PCDATA)> \r\n    \r\n    \r\n13.8    lockentry XML Element \r\n    \r\n   Name:    lockentry \r\n   Namespace:   DAV: \r\n   Purpose: Defines the types of locks that can be used with the \r\n            resource. \r\n    \r\n   <!ELEMENT lockentry ANY > \r\n   ANY value: any number of elements, including one of each of \r\n   (lockscope, locktype) \r\n    \r\n13.9    lockinfo XML Element \r\n    \r\n   Name:    lockinfo \r\n   Namespace:   DAV: \r\n   Purpose: The lockinfo XML element is used with a LOCK method to \r\n            specify the type of lock the client wishes to have created. \r\n    \r\n   <!ELEMENT lockinfo ANY > \r\n   ANY value: any number of elements, including one of each of \r\n   (lockscope, locktype), and optionally including the owner element. \r\n    \r\n13.10   lockscope XML Element \r\n    \r\n     \r\n                           Expires Oct 2003                         67 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Name:    lockscope \r\n   Namespace:   DAV: \r\n   Purpose: Specifies whether a lock is an exclusive lock, or a shared \r\n            lock. \r\n    \r\n   <!ELEMENT lockscope (exclusive | shared) > \r\n    \r\n13.11   exclusive XML Element \r\n    \r\n   Name:    exclusive \r\n   Namespace:   DAV: \r\n   Purpose: Specifies an exclusive lock \r\n    \r\n   <!ELEMENT exclusive EMPTY > \r\n    \r\n13.12   shared XML Element \r\n    \r\n   Name:    shared \r\n   Namespace:   DAV: \r\n   Purpose: Specifies a shared lock \r\n    \r\n   <!ELEMENT shared EMPTY > \r\n    \r\n13.13   locktype XML Element \r\n    \r\n   Name:    locktype \r\n   Namespace:   DAV: \r\n   Purpose: Specifies the access type of a lock.  At present, this \r\n            specification only defines one lock type, the write lock. \r\n    \r\n   <!ELEMENT locktype ANY > \r\n   ANY value: Any element meaning a lock type. The only such element \r\n   defined in this document is the write element. \r\n    \r\n13.14   write XML Element \r\n    \r\n   Name:    write \r\n   Namespace:   DAV: \r\n   Purpose: Specifies a write lock. \r\n    \r\n   <!ELEMENT write EMPTY > \r\n    \r\n13.15   multistatus XML Element \r\n    \r\n   Name:    multistatus \r\n   Namespace:   DAV: \r\n   Purpose: Contains multiple response messages. \r\n     \r\n                           Expires Oct 2003                         68 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Description:         The responsedescription at the top level is \r\n            used to provide a general message describing the \r\n            overarching nature of the response.  If this value is \r\n            available an application may use it instead of presenting \r\n            the individual response descriptions contained within the \r\n            responses. \r\n    \r\n   <!ELEMENT multistatus ANY > \r\n   ANY value: At least one response element, and zero or more \r\n   responsedescription elements. \r\n    \r\n13.16   response XML Element \r\n    \r\n   Name:    response \r\n   Namespace:   DAV: \r\n   Purpose: Holds a single response describing the effect of a method \r\n            on resource and/or its properties. \r\n   Description:         A particular href MUST NOT appear more than \r\n            once as the child of a response XML element under a \r\n            multistatus XML element.  This requirement is necessary in \r\n            order to keep processing costs for a response to linear \r\n            time.  Essentially, this prevents having to search in order \r\n            to group together all the responses by href.  There are, \r\n            however, no requirements regarding ordering based on href \r\n            values. \r\n    \r\n   <!ELEMENT response ANY > \r\n   ANY value: MUST contain an href element.  MUST contain a status \r\n   element or a propstat element.  MAY contain a responsedescription \r\n   element.  \r\n    \r\n13.17   propstat XML Element \r\n    \r\n   Name:    propstat \r\n   Namespace:   DAV: \r\n   Purpose: Groups together a prop and status element that is \r\n            associated with a particular href element.  \r\n   Description:         The propstat XML element MUST contain one prop \r\n            XML element and one status XML element.  The contents of \r\n            the prop XML element MUST only list the names of properties \r\n            to which the result in the status element applies. \r\n    \r\n   <!ELEMENT propstat ANY > \r\n   ANY value: Contains one of each of (prop, status) and may contain a \r\n   responsedescription element.  \r\n    \r\n     \r\n                           Expires Oct 2003                         69 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n13.18   status XML Element \r\n    \r\n   Name:    status \r\n   Namespace:   DAV: \r\n   Purpose: Holds a single HTTP status-line \r\n   Value:   status-line   ;status-line defined in [RFC2616] \r\n    \r\n   <!ELEMENT status (#PCDATA) > \r\n    \r\n13.19   responsedescription XML Element \r\n    \r\n   Name:    responsedescription \r\n   Namespace:   DAV: \r\n   Purpose: Contains a message that can be displayed to the user \r\n            explaining the nature of the response. \r\n   Description:         This XML element provides information suitable \r\n            to be presented to a user. \r\n    \r\n   <!ELEMENT responsedescription (#PCDATA) > \r\n    \r\n13.20   owner XML Element \r\n    \r\n   Name:    owner \r\n   Namespace:   DAV: \r\n   Purpose: Provides information about the principal taking out a lock. \r\n   Description:         The owner XML element provides information \r\n            sufficient for either directly contacting a principal (such \r\n            as a telephone number or Email URI), or for discovering the \r\n            principal (such as the URL of a homepage) who owns a lock. \r\n    \r\n   <!ELEMENT owner ANY> \r\n    \r\n13.21   prop XML element \r\n    \r\n   Name:    prop \r\n   Namespace:   DAV: \r\n   Purpose: Contains properties related to a resource. \r\n   Description:         The prop XML element is a generic container for \r\n            properties defined on resources.  All elements inside a \r\n            prop XML element MUST define properties related to the \r\n            resource.  No other elements may be used inside of a prop \r\n            element. \r\n    \r\n   <!ELEMENT prop ANY> \r\n    \r\n13.22   propertyupdate XML element \r\n    \r\n     \r\n                           Expires Oct 2003                         70 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Name:    propertyupdate \r\n   Namespace:   DAV: \r\n   Purpose: Contains a request to alter the properties on a resource. \r\n   Description:         This XML element is a container for the \r\n            information required to modify the properties on the \r\n            resource.  This XML element is multi-valued. \r\n    \r\n   <!ELEMENT propertyupdate ANY > \r\n   ANY value: Must contain at least one remove or set element. May \r\n   contain any number of remove and set elements.  \r\n    \r\n13.23   remove XML element \r\n    \r\n   Name:    remove \r\n   Namespace:   DAV: \r\n   Purpose: Lists the DAV properties to be removed from a resource. \r\n   Description:         Remove instructs that the properties specified \r\n            in prop should be removed.  Specifying the removal of a \r\n            property that does not exist is not an error.  All the XML \r\n            elements in a prop XML element inside of a remove XML \r\n            element MUST be empty, as only the names of properties to \r\n            be removed are required. \r\n    \r\n   <!ELEMENT remove (prop) > \r\n    \r\n13.24   set XML element \r\n    \r\n   Name:    set \r\n   Namespace:   DAV: \r\n   Purpose: Lists the DAV property values to be set for a resource. \r\n   Description: The set XML element MUST contain only a prop XML \r\n            element.  The elements contained by the prop XML element \r\n            inside the set XML element MUST specify the name and value \r\n            of properties that are set on the resource identified by \r\n            Request-URI.  If a property already exists then its value \r\n            is replaced. Language tagging information appearing in the \r\n            scope of the prop element (in the \"xml:lang\" attribute, if \r\n            present) MUST be persistently stored along with the \r\n            property, and MUST be subsequently retrievable using \r\n            PROPFIND. \r\n    \r\n   <!ELEMENT set (prop) > \r\n    \r\n13.25   propfind XML Element \r\n    \r\n   Name:    propfind \r\n     \r\n                           Expires Oct 2003                         71 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Namespace:   DAV: \r\n   Purpose: Specifies the properties to be returned from a PROPFIND \r\n            method.  Four special elements are specified for use with \r\n            propfind: prop, deadprops, allprop and propname.  If prop \r\n            is used inside propfind it MUST NOT contain property \r\n            values. \r\n    \r\n   <!ELEMENT propfind ANY > \r\n   ANY value: MUST contain one and only one of (allprop | propname | \r\n   prop).   \r\n    \r\n13.26   allprop XML Element \r\n    \r\n   Name:    allprop \r\n   Namespace:   DAV: \r\n   Purpose: The allprop XML element specifies that all names and values \r\n            of dead properties and the live properties defined by this \r\n            document existing on the resource are to be returned. \r\n    \r\n   <!ELEMENT allprop EMPTY > \r\n    \r\n13.27   propname XML Element \r\n    \r\n   Name:    propname \r\n   Namespace:   DAV: \r\n   Purpose: The propname XML element specifies that only a list of \r\n            property names on the resource is to be returned. \r\n    \r\n   <!ELEMENT propname EMPTY > \r\n    \r\n13.28   deadprops XML Element \r\n    \r\n   Name:    deadprops \r\n   Namespace:   DAV: \r\n   Purpose: The deadprops XML element specifies that all dead \r\n            properties, names and values, should be returned in the \r\n            response. \r\n    \r\n   <!ELEMENT deadprops EMPTY > \r\n    \r\n14 DAV Properties \r\n    \r\n   For DAV properties, the name of the property is also the same as the \r\n   name of the XML element that contains its value. In the section \r\n   below, the final line of each section gives the element type \r\n   declaration using the format defined in [REC-XML]. The \"Value\" \r\n   field, where present, specifies further restrictions on the \r\n     \r\n                           Expires Oct 2003                         72 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   allowable contents of the XML element using BNF (i.e., to further \r\n   restrict the values of a PCDATA element).  Note that a resource may \r\n   have only one value for a property of a given name, so the property \r\n   may only show up once in PROPFIND responses or PROPPATCH requests. \r\n    \r\n   The value of a protected property may not be changed even by a user \r\n   with permission to edit other properties.  Some property values are \r\n   calculated by the server and it is not appropriate to allow client \r\n   changes. This specification mentions which properties may be \r\n   protected in order to set client expectations. \r\n    \r\n14.1    creationdate Property \r\n    \r\n   Name:    creationdate \r\n   Namespace:   DAV: \r\n   Purpose:     Records the time and date the resource was created. \r\n   Value:   date-time   \r\n   COPY/MOVE behaviour: This property value SHOULD be kept during a \r\n            MOVE operation, but is re-initialized when a resource is \r\n            created with a COPY. It should not be set in a remote COPY. \r\n   Description: The creationdate property should be defined on all DAV \r\n            compliant resources.  If present, it contains a timestamp \r\n            of the moment when the resource was created (i.e., the \r\n            moment it had non-null state).  This property is live and \r\n            protected. The Internet date-time format is defined in \r\n            [RFC3339], see the ABNF in section 5.6. \r\n    \r\n   <!ELEMENT creationdate (#PCDATA) > \r\n    \r\n14.2    displayname Property \r\n    \r\n   Name:    displayname \r\n   Namespace:   DAV: \r\n   Purpose: Provides a name for the resource that is suitable for \r\n            presentation to a user. \r\n   COPY/MOVE behaviour: This property value SHOULD be preserved in \r\n            local COPY and MOVE operations. It MAY be attempted to be \r\n            set in remote COPY operation. \r\n   Description:         The displayname property should be defined on \r\n            all DAV compliant resources.  If present, the property \r\n            contains a description of the resource that is suitable for \r\n            presentation to a user. This property is live and MAY be \r\n            protected. \r\n    \r\n   <!ELEMENT displayname (#PCDATA) > \r\n\r\n     \r\n                           Expires Oct 2003                         73 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n14.3    getcontentlanguage Property \r\n    \r\n   Name:    getcontentlanguage \r\n   Namespace:   DAV: \r\n   Purpose: Contains the Content-Language header returned by a GET \r\n            without accept headers \r\n   COPY/MOVE behaviour: This property value SHOULD be preserved in \r\n            local COPY and MOVE operations. It should be attempted to \r\n            be set in remote COPY operation. \r\n   Description:         The getcontentlanguage property MUST be defined \r\n            on any DAV compliant resource that returns the Content-\r\n            Language header on a GET.  This property is live and MAY be \r\n            protected. \r\n   Value:   language-tag   ;language-tag is defined in section 14.13 of \r\n            [RFC2616] \r\n    \r\n   <!ELEMENT getcontentlanguage (#PCDATA) > \r\n    \r\n14.4    getcontentlength Property \r\n    \r\n   Name:    getcontentlength \r\n   Namespace:   DAV: \r\n   Purpose: Contains the Content-Length header returned by a GET \r\n            without accept headers. \r\n   Description:         The getcontentlength property MUST be defined \r\n            on any DAV compliant resource that returns the Content-\r\n            Length header in response to a GET.  This property is live \r\n            and protected. \r\n   COPY/MOVE behaviour: This property value is dependent on the size of \r\n            the destination resource, not the value of the property on \r\n            the source resource. \r\n   Value:   content-length ; see section 14.14 of [RFC2616] \r\n    \r\n   <!ELEMENT getcontentlength (#PCDATA) > \r\n    \r\n14.5    getcontenttype Property \r\n    \r\n   Name:    getcontenttype \r\n   Namespace:   DAV: \r\n   Purpose: Contains the Content-Type header returned by a GET without \r\n            accept headers. \r\n   COPY/MOVE behaviour: This property value SHOULD be preserved in \r\n            local COPY and MOVE operations. In a remote COPY operation \r\n            that is implemented through a GET request, the GET request \r\n            must have the appropriate Content-Type header. \r\n\r\n     \r\n                           Expires Oct 2003                         74 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Description:         This getcontenttype property MUST be defined on \r\n            any DAV compliant resource that returns the Content-Type \r\n            header in response to a GET. This property is live and MAY \r\n            be protected. \r\n   Value:   media-type   ; defined in section 3.7 of [RFC2616] \r\n    \r\n   <!ELEMENT getcontenttype (#PCDATA) > \r\n    \r\n14.6    getetag Property \r\n    \r\n   Name:    getetag \r\n   Namespace:   DAV: \r\n   Purpose: Contains the ETag header returned by a GET without accept \r\n            headers. \r\n   COPY/MOVE behaviour: This property value is dependent on the final \r\n            state of the destination resource, not the value of the \r\n            property on the source resource. It MUST NOT be set in \r\n            PROPPATCH during a cross-server copy. \r\n   Description:         The getetag property MUST be defined on any DAV \r\n            compliant resource that returns the Etag header.  Refer to \r\n            RFC2616 for a complete definition of the semantics of an \r\n            ETag.  Note that changes in properties or lock state MUST \r\n            not cause a resource\u00c6s ETag to change This property is live \r\n            and protected. \r\n   Value:   entity-tag  ; defined in section 3.11 of [RFC2616] \r\n    \r\n   <!ELEMENT getetag (#PCDATA) > \r\n    \r\n14.7    getlastmodified Property \r\n    \r\n   Name:    getlastmodified \r\n   Namespace:   DAV: \r\n   Purpose: Contains the Last-Modified header returned by a GET method \r\n            without accept headers. \r\n   COPY/MOVE behaviour: This property value is dependent on the last \r\n            modified date of the destination resource, not the value of \r\n            the property on the source resource. \r\n   Description: Note that the last-modified date on a resource SHOULD \r\n            only reflect changes in the body (the GET responses) of the \r\n            resource.  A change in a property SHOULD NOT cause the \r\n            last-modified date to change, because clients MAY rely on \r\n            the last-modified date to know when to overwrite the \r\n            existing body. The getlastmodified property MUST be defined \r\n            on any DAV compliant resource that returns the Last-\r\n\r\n\r\n     \r\n                           Expires Oct 2003                         75 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n            Modified header in response to a GET. This property is live \r\n            and protected.  \r\n   Value:   HTTP-date  ; defined in section 3.3.1 of [RFC2616] \r\n    \r\n   <!ELEMENT getlastmodified (#PCDATA) > \r\n    \r\n14.8    lockdiscovery Property \r\n    \r\n   Name:    lockdiscovery \r\n   Namespace:   DAV: \r\n   Purpose: Describes the active locks on a resource \r\n   COPY/MOVE behaviour: The value of this property depends on the lock \r\n            state of the destination, not on the locks of the source \r\n            resource.  Recall that locks are not moved in a MOVE \r\n            operation. \r\n   Description: The lockdiscovery property returns a listing of who has \r\n            a lock, what type of lock he has, the timeout type and the \r\n            time remaining on the timeout, and the associated lock \r\n            token.  If there are no locks, but the server supports \r\n            locks, the property will be present but contain zero \r\n            \u00e6activelock\u00c6 elements.  If there is one or more lock, an \r\n            \u00e6activelock\u00c6 element appears for each lock on the resource. \r\n            This property is live and protected. \r\n    \r\n   <!ELEMENT lockdiscovery ANY > \r\n   ANY value: MAY contain zero or more activelock elements. MAY contain \r\n   additional elements not defined in this document. \r\n    \r\n14.8.1  Example - Retrieving the lockdiscovery Property \r\n    \r\n   >>Request \r\n    \r\n     PROPFIND /container/ HTTP/1.1 \r\n     Host: www.example.com \r\n     Content-Length: xxxx \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D='DAV:'> \r\n      <D:prop><D:lockdiscovery/></D:prop> \r\n     </D:propfind> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     \r\n                           Expires Oct 2003                         76 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:multistatus xmlns:D='DAV:'> \r\n      <D:response> \r\n        <D:href>http://www.example.com/container/</D:href> \r\n        <D:propstat> \r\n          <D:prop> \r\n            <D:lockdiscovery> \r\n             <D:activelock> \r\n              <D:locktype><D:write/></D:locktype> \r\n              <D:lockscope><D:exclusive/></D:lockscope> \r\n              <D:depth>0</D:depth> \r\n              <D:owner>Jane Smith</D:owner> \r\n              <D:timeout>Infinite</D:timeout> \r\n              <D:locktoken> \r\n                <D:href>opaquelocktoken:f81de2ad-7f3d-a1b2-4f3c-\r\n     00a0c91a9d76</D:href> \r\n              </D:locktoken> \r\n              <D:lockroot> \r\n                <D:href>http://www.example.com/container/</D:href> \r\n              </D:lockroot> \r\n              </D:activelock> \r\n            </D:lockdiscovery> \r\n          </D:prop> \r\n          <D:status>HTTP/1.1 200 OK</D:status> \r\n        </D:propstat> \r\n      </D:response> \r\n     </D:multistatus> \r\n      \r\n   This resource has a single exclusive write lock on it, with an \r\n   infinite timeout. \r\n    \r\n14.9    resourcetype Property \r\n    \r\n   Name:    resourcetype \r\n   Namespace:   DAV: \r\n   Purpose: Specifies the nature of the resource. \r\n   COPY/MOVE behaviour: Generally a COPY/MOVE of a resource results in \r\n            the same type of resource at the destination. In a remote \r\n            COPY, the source server SHOULD NOT attempt to set this \r\n            property. \r\n   Description:         The resourcetype property MUST be defined on \r\n            all DAV compliant resources.  The default value is empty. \r\n            This property is live and protected. \r\n     \r\n                           Expires Oct 2003                         77 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   <!ELEMENT resourcetype ANY > \r\n    \r\n   Example: (fictional example to show extensibility) \r\n            <x:resourcetype xmlns:x=\"DAV:\"><x:collection/> \r\n                <f:search-results xmlns:f=\"http://www.example.com/ns\"/> \r\n            </x:resourcetype> \r\n    \r\n14.10   supportedlock Property \r\n    \r\n   Name:    supportedlock \r\n   Namespace:   DAV: \r\n   Purpose: To provide a listing of the lock capabilities supported by \r\n            the resource. \r\n   COPY/MOVE behaviour: This property value is dependent on the kind of \r\n            locks supported at the destination, not on the value of the \r\n            property at the source resource. It should not be attempted \r\n            to be set on a remote COPY. \r\n   Description:         The supportedlock property of a resource \r\n            returns a listing of the combinations of scope and access \r\n            types which may be specified in a lock request on the \r\n            resource.  Note that the actual contents are themselves \r\n            controlled by access controls so a server is not required \r\n            to provide information the client is not authorized to see. \r\n            This property is live and protected. \r\n    \r\n   <!ELEMENT supportedlock ANY > \r\n    \r\n14.10.1 Example - Retrieving the supportedlock Property \r\n    \r\n   >>Request \r\n    \r\n     PROPFIND  /container/ HTTP/1.1 \r\n     Host: www.example.com \r\n     Content-Length: xxxx \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\"> \r\n      <D:prop><D:supportedlock/></D:prop> \r\n     </D:propfind> \r\n    \r\n   >>Response \r\n    \r\n     HTTP/1.1 207 Multi-Status \r\n     Content-Type: text/xml; charset=\"utf-8\" \r\n     \r\n                           Expires Oct 2003                         78 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     Content-Length: xxxx \r\n      \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:multistatus xmlns:D=\"DAV:\"> \r\n      <D:response> \r\n        <D:href>http://www.example.com/container/</D:href> \r\n        <D:propstat> \r\n          <D:prop> \r\n            <D:supportedlock> \r\n              <D:lockentry> \r\n                <D:lockscope><D:exclusive/></D:lockscope> \r\n                <D:locktype><D:write/></D:locktype> \r\n              </D:lockentry> \r\n              <D:lockentry> \r\n                <D:lockscope><D:shared/></D:lockscope> \r\n                <D:locktype><D:write/></D:locktype> \r\n              </D:lockentry> \r\n            </D:supportedlock> \r\n          </D:prop> \r\n          <D:status>HTTP/1.1 200 OK</D:status> \r\n        </D:propstat> \r\n      </D:response> \r\n     </D:multistatus> \r\n      \r\n      \r\n15 Instructions for Processing XML in DAV  \r\n    \r\n   All DAV compliant resources MUST ignore any unknown XML element and \r\n   all its children encountered while processing a DAV method that uses \r\n   XML as its command language. \r\n    \r\n   This restriction also applies to the processing, by clients, of DAV \r\n   property values where unknown XML elements SHOULD be ignored unless \r\n   the property's schema declares otherwise. \r\n    \r\n   This restriction does not apply to setting dead DAV properties on \r\n   the server where the server MUST record unknown XML elements. \r\n    \r\n   Additionally, this restriction does not apply to the use of XML \r\n   where XML happens to be the content type of the entity body, for \r\n   example, when used as the body of a PUT. \r\n     \r\n   Since XML can be transported as text/xml or application/xml, a DAV \r\n   server MUST accept DAV method requests with XML parameters \r\n   transported as either text/xml or application/xml, and DAV client \r\n   MUST accept XML responses using either text/xml or application/xml. \r\n    \r\n     \r\n                           Expires Oct 2003                         79 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n16 DAV Compliance Classes \r\n    \r\n   A DAV compliant resource can advertise several classes of \r\n   compliance.  A client can discover the compliance classes of a \r\n   resource by executing OPTIONS on the resource, and examining the \r\n   \"DAV\" header which is returned.  Note particularly that resources \r\n   are spoken of as being compliant, rather than servers. That is \r\n   because theoretically some resources on a server could support \r\n   different feature sets.  E.g. a server could have a sub-repository \r\n   where an advanced feature like server was supported, even if that \r\n   feature was not supported on all servers. \r\n    \r\n   Since this document describes extensions to the HTTP/1.1 protocol, \r\n   minimally all DAV compliant resources, clients, and proxies MUST be \r\n   compliant with [RFC2616]. \r\n    \r\n   A resource that is class 2 compliant must also be class 1 compliant, \r\n   and a resource that is compliant with \"bis\" must also be class 1 \r\n   compliant.   \r\n    \r\n16.1    Class 1 \r\n    \r\n   A class 1 compliant resource MUST meet all \"MUST\" requirements in \r\n   all sections of this document. \r\n    \r\n   Class 1 compliant resources MUST return, at minimum, the value \"1\" \r\n   in the DAV header on all responses to the OPTIONS method. \r\n    \r\n16.2    Class 2 \r\n    \r\n   A class 2 compliant resource MUST meet all class 1 requirements and \r\n   support the LOCK method, the supportedlock property, the \r\n   lockdiscovery property, the Time-Out response header and the Lock-\r\n   Token request header.  A class \"2\" compliant resource SHOULD also \r\n   support the Time-Out request header and the owner XML element. \r\n    \r\n   Class 2 compliant resources MUST return, at minimum, the values \"1\" \r\n   and \"2\" in the DAV header on all responses to the OPTIONS method. \r\n    \r\n16.3    Class \"bis\" \r\n    \r\n   A resource can explicitly advertise its support for the revisions to \r\n   RFC2518 made in this document. In particular, this allows clients to \r\n   use the Force-Authentication header on requests.  Class 1 must be \r\n   supported as well. Class 2 MAY be supported.   \r\n    \r\n   A resource that supports bis MUST support: \r\n    - the Force-Authentication header.  \r\n    - Any behavior that it supports, in the manner specified in this \r\n   document, rather than in the manner specified in RFC2518, for all \r\n     \r\n                           Expires Oct 2003                         80 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   client requests.  A server MAY use an older behavior for specific \r\n   clients that are discovered to have interoperability problems with \r\n   the requirements of this specification, but MUST NOT use an older \r\n   behavior indiscriminately. \r\n    \r\n   Example: \r\n    \r\n        DAV: 1, bis \r\n    \r\n    \r\n17 Internationalization Considerations \r\n    \r\n   In the realm of internationalization, this specification complies \r\n   with the IETF Character Set Policy [RFC2277]. In this specification, \r\n   human-readable fields can be found either in the value of a \r\n   property, or in an error message returned in a response entity body.  \r\n   In both cases, the human-readable content is encoded using XML, \r\n   which has explicit provisions for character set tagging and \r\n   encoding, and requires that XML processors read XML elements \r\n   encoded, at minimum, using the UTF-8 [UTF-8] and UTF-16 encodings of \r\n   the ISO 10646 multilingual plane.  XML examples in this \r\n   specification demonstrate use of the charset parameter of the \r\n   Content-Type header, as defined in [RFC2376], as well as the XML \r\n   declarations which provide charset identification information for \r\n   MIME and XML processors. \r\n    \r\n   XML also provides a language tagging capability for specifying the \r\n   language of the contents of a particular XML element.  The \r\n   \"xml:lang\" attribute appears on an XML element to identify the \r\n   language of its content and attributes. See [REC-XML] for \r\n   definitions of values and scoping. \r\n    \r\n   WebDAV applications MUST support the character set tagging, \r\n   character set encoding, and the language tagging functionality of \r\n   the XML specification.  Implementors of WebDAV applications are \r\n   strongly encouraged to read \"XML Media Types\" [RFC2376] for \r\n   instruction on which MIME media type to use for XML transport, and \r\n   on use of the charset parameter of the Content-Type header. \r\n    \r\n   Names used within this specification fall into three categories: \r\n   names of protocol elements such as methods and headers, names of XML \r\n   elements, names of properties, and names of conditions.  Naming of \r\n   protocol elements follows the precedent of HTTP, using English names \r\n   encoded in USASCII for methods and headers.  Since these protocol \r\n   elements are not visible to users, and are simply long token \r\n   identifiers, they do not need to support multiple languages.  \r\n   Similarly, the names of XML elements used in this specification are \r\n   not visible to the user and hence do not need to support multiple \r\n   languages. \r\n\r\n     \r\n                           Expires Oct 2003                         81 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   WebDAV property names are qualified XML names (pairs of XML \r\n   namespace name and local name).  Although some applications (e.g., a \r\n   generic property viewer) will display property names directly to \r\n   their users, it is expected that the typical application will use a \r\n   fixed set of properties, and will provide a mapping from the \r\n   property name URI to a human-readable field when displaying the \r\n   property name to a user.  It is only in the case where the set of \r\n   properties is not known ahead of time that an application need \r\n   display a property name URI to a user. We recommend that \r\n   applications provide human-readable property names wherever \r\n   feasible. \r\n    \r\n   For error reporting, we follow the convention of HTTP/1.1 status \r\n   codes, including with each status code a short, English description \r\n   of the code (e.g., 423 (Locked)).  While the possibility exists that \r\n   a poorly crafted user agent would display this message to a user, \r\n   internationalized applications will ignore this message, and display \r\n   an appropriate message in the user's language and character set. \r\n    \r\n   Since interoperation of clients and servers does not require locale \r\n   information, this specification does not specify any mechanism for \r\n   transmission of this information. \r\n    \r\n    \r\n18 Security Considerations \r\n    \r\n   This section is provided to detail issues concerning security \r\n   implications of which WebDAV applications need to be aware. \r\n    \r\n   All of the security considerations of HTTP/1.1 (discussed in \r\n   [RFC2616]) and XML (discussed in [RFC2376]) also apply to WebDAV. In \r\n   addition, the security risks inherent in remote authoring require \r\n   stronger authentication technology, introduce several new privacy \r\n   concerns, and may increase the hazards from poor server design. \r\n   These issues are detailed below. \r\n    \r\n    \r\n18.1    Authentication of Clients \r\n    \r\n   Due to their emphasis on authoring, WebDAV servers need to use \r\n   authentication technology to protect not just access to a network \r\n   resource, but the integrity of the resource as well.  Furthermore, \r\n   the introduction of locking functionality requires support for \r\n   authentication. \r\n    \r\n   A password sent in the clear over an insecure channel is an \r\n   inadequate means for protecting the accessibility and integrity of a \r\n   resource as the password may be intercepted.  Since Basic \r\n   authentication for HTTP/1.1 performs essentially clear text \r\n   transmission of a password, Basic authentication MUST NOT be used to \r\n   authenticate a WebDAV client to a server unless the connection is \r\n     \r\n                           Expires Oct 2003                         82 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   secure. Furthermore, a WebDAV server MUST NOT send Basic \r\n   authentication credentials in a WWW-Authenticate header unless the \r\n   connection is secure.  Examples of secure connections include a \r\n   Transport Layer Security (TLS) connection employing a strong cipher \r\n   suite with mutual authentication of client and server, or a \r\n   connection over a network which is physically secure, for example, \r\n   an isolated network in a building with restricted access. \r\n    \r\n   WebDAV applications MUST support the Digest authentication scheme \r\n   [RFC2069]. Since Digest authentication verifies that both parties to \r\n   a communication know a shared secret, a password, without having to \r\n   send that secret in the clear, Digest authentication avoids the \r\n   security problems inherent in Basic authentication while providing a \r\n   level of authentication which is useful in a wide range of \r\n   scenarios. \r\n    \r\n18.2    Denial of Service \r\n    \r\n   Denial of service attacks are of special concern to WebDAV servers.  \r\n   WebDAV plus HTTP enables denial of service attacks on every part of \r\n   a system's resources. \r\n    \r\n   The underlying storage can be attacked by PUTting extremely large \r\n   files. \r\n    \r\n   Asking for recursive operations on large collections can attack \r\n   processing time. \r\n    \r\n   Making multiple pipelined requests on multiple connections can \r\n   attack network connections. \r\n    \r\n   WebDAV servers need to be aware of the possibility of a denial of \r\n   service attack at all levels. \r\n    \r\n18.3    Security through Obscurity \r\n    \r\n   WebDAV provides, through the PROPFIND method, a mechanism for \r\n   listing the member resources of a collection.  This greatly \r\n   diminishes the effectiveness of security or privacy techniques that \r\n   rely only on the difficulty of discovering the names of network \r\n   resources.  Users of WebDAV servers are encouraged to use access \r\n   control techniques to prevent unwanted access to resources, rather \r\n   than depending on the relative obscurity of their resource names. \r\n    \r\n18.4    Privacy Issues Connected to Locks \r\n    \r\n   When submitting a lock request a user agent may also submit an owner \r\n   XML field giving contact information for the person taking out the \r\n   lock (for those cases where a person, rather than a robot, is taking \r\n   out the lock). This contact information is stored in a lockdiscovery \r\n   property on the resource, and can be used by other collaborators to \r\n     \r\n                           Expires Oct 2003                         83 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   begin negotiation over access to the resource.  However, in many \r\n   cases this contact information can be very private, and should not \r\n   be widely disseminated.  Servers SHOULD limit read access to the \r\n   lockdiscovery property as appropriate.  Furthermore, user agents \r\n   SHOULD provide control over whether contact information is sent at \r\n   all, and if contact information is sent, control over exactly what \r\n   information is sent. \r\n    \r\n18.5    Privacy Issues Connected to Properties \r\n    \r\n   Since property values are typically used to hold information such as \r\n   the author of a document, there is the possibility that privacy \r\n   concerns could arise stemming from widespread access to a resource's \r\n   property data.  To reduce the risk of inadvertent release of private \r\n   information via properties, servers are encouraged to develop access \r\n   control mechanisms that separate read access to the resource body \r\n   and read access to the resource's properties.  This allows a user to \r\n   control the dissemination of their property data without overly \r\n   restricting access to the resource's contents. \r\n    \r\n    \r\n18.6    Implications of XML External Entities  \r\n    \r\n   XML supports a facility known as \"external entities\", defined in \r\n   section 4.2.2 of [REC-XML], which instruct an XML processor to \r\n   retrieve and include additional XML. An external XML entity can be \r\n   used to append or modify the document type declaration (DTD) \r\n   associated with an XML document.  An external XML entity can also be \r\n   used to include XML within the content of an XML document.  For non-\r\n   validating XML, such as the XML used in this specification, \r\n   including an external XML entity is not required by [REC-XML]. \r\n   However, [REC-XML] does state that an XML processor may, at its \r\n   discretion, include the external XML entity. \r\n    \r\n   External XML entities have no inherent trustworthiness and are \r\n   subject to all the attacks that are endemic to any HTTP GET request.  \r\n   Furthermore, it is possible for an external XML entity to modify the \r\n   DTD, and hence affect the final form of an XML document, in the \r\n   worst case significantly modifying its semantics, or exposing the \r\n   XML processor to the security risks discussed in [RFC2376]. \r\n   Therefore, implementers must be aware that external XML entities \r\n   should be treated as untrustworthy.  If a server implementor chooses \r\n   not to handle external XML entities, it SHOULD respond to requests \r\n   containing external entities with an error (403 Forbidden, with the \r\n   'forbid-external-entities' element in the error body). \r\n    \r\n   There is also the scalability risk that would accompany a widely \r\n   deployed application which made use of external XML entities.  In \r\n   this situation, it is possible that there would be significant \r\n   numbers of requests for one external XML entity, potentially \r\n\r\n     \r\n                           Expires Oct 2003                         84 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   overloading any server which fields requests for the resource \r\n   containing the external XML entity. \r\n    \r\n18.7    Risks Connected with Lock Tokens \r\n    \r\n   This specification, in section 6.4, requires the use of Universal \r\n   Unique Identifiers (UUIDs) for lock tokens, in order to guarantee \r\n   their uniqueness across space and time.  UUIDs, as defined in [ISO-\r\n   11578], contain a \"node\" field which \"consists of the IEEE address, \r\n   usually the host address.  For systems with multiple IEEE 802 nodes, \r\n   any available node address can be used.\"  Since a WebDAV server will \r\n   issue many locks over its lifetime, the implication is that it will \r\n   also be publicly exposing its IEEE 802 address. \r\n    \r\n   There are several risks associated with exposure of IEEE 802 \r\n   addresses.  Using the IEEE 802 address: \r\n    \r\n   * It is possible to track the movement of hardware from subnet to \r\n   subnet. \r\n    \r\n   * It may be possible to identify the manufacturer of the hardware \r\n   running a WebDAV server. \r\n    \r\n   * It may be possible to determine the number of each type of \r\n   computer running WebDAV. \r\n   Section 24.3 of this specification details an alternate mechanism \r\n   for generating the \"node\" field of a UUID without using an IEEE 802 \r\n   address, which alleviates the risks associated with exposure of IEEE \r\n   802 addresses by using an alternate source of uniqueness. \r\n    \r\n    \r\n19 IANA Considerations \r\n    \r\n   This document defines two namespaces, the namespace of property \r\n   names, and the namespace of WebDAV-specific XML elements used within \r\n   property values.   \r\n    \r\n   The use of XML namespaces means that unique WebDAV property names \r\n   and XML elements can be quickly defined by any WebDAV user or \r\n   application, without requiring IANA action.   \r\n    \r\n   This specification defines a distinguished set of property names and \r\n   XML elements that are understood by all WebDAV applications.  The \r\n   property names and XML elements in this specification are all in the \r\n   \"DAV:\" namespace. In natural language, a property like the \r\n   \"creationdate\" property in the \"DAV:\" namespace is sometimes \r\n   referred to as \"DAV:creationdate\" for brevity. \r\n    \r\n   This specification also defines a URI scheme for the encoding of \r\n   lock tokens, the opaquelocktoken URI scheme described in section \r\n   6.4. \r\n     \r\n                           Expires Oct 2003                         85 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   To ensure correct interoperation based on this specification, IANA \r\n   must reserve the URI namespaces starting with \"DAV:\" and with \r\n   \"opaquelocktoken:\" for use by this specification, its revisions, and \r\n   related WebDAV specifications. \r\n    \r\n    \r\n20 Intellectual Property \r\n    \r\n   The following notice is copied from RFC 2026 [RFC2026], section \r\n   10.4, and describes the position of the IETF concerning intellectual \r\n   property claims made against this document. \r\n    \r\n   The IETF takes no position regarding the validity or scope of any \r\n   intellectual property or other rights that might be claimed to \r\n   pertain to the implementation or use other technology described in \r\n   this document or the extent to which any license under such rights \r\n   might or might not be available; neither does it represent that it \r\n   has made any effort to identify any such rights.  Information on the \r\n   IETF's procedures with respect to rights in standards-track and \r\n   standards-related documentation can be found in BCP-11.  Copies of \r\n   claims of rights made available for publication and any assurances \r\n   of licenses to be made available, or the result of an attempt made \r\n   to obtain a general license or permission for the use of such \r\n   proprietary rights by implementors or users of this specification \r\n   can be obtained from the IETF Secretariat. \r\n    \r\n   The IETF invites any interested party to bring to its attention any \r\n   copyrights, patents or patent applications, or other proprietary \r\n   rights which may cover technology that may be required to practice \r\n   this standard.  Please address the information to the IETF Executive \r\n   Director. \r\n    \r\n    \r\n21 Acknowledgements \r\n    \r\n   A specification such as this thrives on piercing critical review and \r\n   withers from apathetic neglect.  The authors gratefully acknowledge \r\n   the contributions of the following people, whose insights were so \r\n   valuable at every stage of our work. \r\n    \r\n   Contributors to RFC2518 \r\n    \r\n   Terry Allen, Harald Alvestrand, Jim Amsden, Becky Anderson, Alan \r\n   Babich, Sanford Barr, Dylan Barrell, Bernard Chester, Tim Berners-\r\n   Lee, Dan Connolly, Jim Cunningham, Ron Daniel, Jr., Jim Davis, Keith \r\n   Dawson, Mark Day, Brian Deen, Martin Duerst, David Durand, Lee \r\n   Farrell, Chuck Fay, Wesley Felter, Roy Fielding, Mark Fisher, Alan \r\n   Freier, George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis \r\n   Hamilton, Steve Henning, Mead Himelstein, Alex Hopmann, Andre van \r\n   der Hoek, Ben Laurie, Paul Leach, Ora Lassila, Karen MacArthur, \r\n     \r\n                           Expires Oct 2003                         86 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   Steven Martin, Larry Masinter, Michael Mealling, Keith Moore, Thomas \r\n   Narten, Henrik Nielsen, Kenji Ota, Bob Parker, Glenn Peterson, Jon \r\n   Radoff, Saveen Reddy, Henry Sanders, Christopher Seiwald, Judith \r\n   Slein, Mike Spreitzer, Einar Stefferud, Greg Stein, Ralph Swick, \r\n   Kenji Takahashi, Richard N. Taylor, Robert Thau, John Turner, Sankar \r\n   Virdhagriswaran, Fabio Vitali, Gregory Woodhouse, and Lauren Wood. \r\n    \r\n   Two from this list deserve special mention.  The contributions by \r\n   Larry Masinter have been invaluable, both in helping the formation \r\n   of the working group and in patiently coaching the authors along the \r\n   way.  In so many ways he has set high standards we have toiled to \r\n   meet. The contributions of Judith Slein in clarifying the \r\n   requirements, and in patiently reviewing draft after draft, both \r\n   improved this specification and expanded our minds on document \r\n   management. \r\n    \r\n   We would also like to thank John Turner for developing the XML DTD. \r\n    \r\n   The authors of RFC2518 were Yaron Goland, Jim Whitehead, A. Faizi, \r\n   Steve Carter and D. Jensen.  Although their names had to be removed \r\n   due to IETF author count restrictions they can take credit for the \r\n   majority of the design of WebDAV. \r\n    \r\n   Additional Contributors to This Specification \r\n    \r\n   Valuable contributions to RFC2518 bis came from some already named. \r\n   New contributors must also be gratefully acknowledged. Julian \r\n   Reschke, Geoff Clemm, Joel Soderberg, and Dan Brotsky hashed out \r\n   specific text on the list or in meetings. Ilya Kirnos supplied text \r\n   for Force-Authentication header. \r\n    \r\n\r\n\r\n                           Expires Oct 2003                         87 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n22 References \r\n    \r\n22.1    Normative References \r\n    \r\n    \r\n   [RFC2277] H. T. Alvestrand, \"IETF Policy on Character Sets and \r\n          Languages.\" RFC 2277, BCP 18, January 1998. \r\n    \r\n   [RFC2119] S. Bradner, \"Key words for use in RFCs to Indicate \r\n          Requirement Levels.\"  RFC 2119, BCP 14, March 1997. \r\n    \r\n   [RFC2396] T. Berners-Lee, R. Fielding, L. Masinter, \"Uniform \r\n          Resource Identifiers (URI): Generic Syntax.\" RFC 2396, August \r\n          1998. \r\n    \r\n   [REC-XML] T. Bray, J. Paoli, C. M. Sperberg-McQueen, \"Extensible \r\n          Markup Language (XML).\" World Wide Web Consortium \r\n          Recommendation REC-xml-20001006. \r\n          http://www.w3.org/TR/2000/REC-xml-20001006, February 1998. \r\n    \r\n   [REC-XML-NAMES] T. Bray, D. Hollander, A. Layman, \"Name Spaces in \r\n          XML\" World Wide Web Consortium Recommendation REC-xml-names. \r\n          http://www.w3.org/TR/REC-xml-names-19990114, January 1999. \r\n    \r\n   [RFC2069] J. Franks, P. Hallam-Baker, J. Hostetler, P. Leach, A. \r\n          Luotonen, E. Sink, and L. Stewart. \"An Extension to HTTP : \r\n          Digest Access Authentication\" RFC 2069, January 1997. \r\n    \r\n   [RFC2616] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, \r\n          P. Leach, T. Berners-Lee, \"Hypertext Transfer Protocol -- \r\n          HTTP/1.1.\" RFC 2616, June 1999.  \r\n    \r\n    \r\n   [ISO-11578] ISO (International Organization for Standardization). \r\n          ISO/IEC 11578:1996. \"Information technology - Open Systems \r\n          Interconnection - Remote Procedure Call (RPC)\" \r\n    \r\n   [RFC2141] R. Moats, \"URN Syntax.\" RFC 2141, May 1997. \r\n    \r\n   [RFC3339] G. Klyne, C. Newman, \u00f4Date and Time on the Internet: \r\n          Timestamps.\u00f6 RFC3339, July 2002. \r\n    \r\n   [UTF-8] F. Yergeau, \"UTF-8, a transformation format of Unicode and \r\n          ISO 10646.\" RFC 2279, January 1998. \r\n\r\n     \r\n                           Expires Oct 2003                         88 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n22.2    Informational References \r\n    \r\n   [RFC2026] S. Bradner, \"The Internet Standards Process - Revision 3.\"  \r\n          RFC 2026, BCP 9, October 1996. \r\n    \r\n   [RFC1807] R. Lasher, D. Cohen, \"A Format for Bibliographic Records,\" \r\n          RFC 1807, June 1995. \r\n    \r\n   [WF]   C. Lagoze, \"The Warwick Framework: A Container Architecture \r\n          for Diverse Sets of Metadata\", D-Lib Magazine, July/August \r\n          1996. http://www.dlib.org/dlib/july96/lagoze/07lagoze.html. \r\n    \r\n   [USMARC] Network Development and MARC Standards, Office, ed. 1994. \r\n          \"USMARC Format for Bibliographic Data\", 1994. Washington, DC: \r\n          Cataloging Distribution Service, Library of Congress. \r\n    \r\n   [REC-PICS] J. Miller, T. Krauskopf, P. Resnick, W. Treese, \"PICS \r\n          Label Distribution Label Syntax and Communication Protocols\" \r\n          Version 1.1, World Wide Web Consortium Recommendation REC-\r\n          PICS-labels-961031. http://www.w3.org/pub/WWW/TR/REC-PICS-\r\n          labels-961031.html. \r\n    \r\n   [RFC2291] J. A. Slein, F. Vitali, E. J. Whitehead, Jr., D. Durand, \r\n          \"Requirements for Distributed Authoring and Versioning \r\n          Protocol for the World Wide Web.\" RFC 2291, February 1998. \r\n    \r\n   [RFC2413] S. Weibel, J. Kunze, C. Lagoze, M. Wolf, \"Dublin Core \r\n          Metadata for Resource Discovery.\" RFC 2413, September 1998. \r\n    \r\n   [RFC2376] E. Whitehead, M. Murata, \"XML Media Types.\" RFC 2376, July \r\n          1998. \r\n    \r\n   [RFC3253]  G. Clemm, J. Amsden, T. Ellison, C. Kaler, J. Whitehead, \r\n          \"Versioning Extensions to WebDAV (Web Distributed Authoring \r\n          and Versioning)\", RFC 3253, March 2002. \r\n    \r\n\r\n\r\n                           Expires Oct 2003                         89 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n23 Authors' Addresses \r\n    \r\n   Editors of RFC2518 \r\n    \r\n   Y. Y. Goland \r\n   Microsoft Corporation \r\n   One Microsoft Way \r\n   Redmond, WA 98052-6399 \r\n   Email: yarong@microsoft.com \r\n    \r\n   E. J. Whitehead, Jr. \r\n   Dept. Of Information and Computer Science \r\n   University of California, Irvine \r\n   Irvine, CA 92697-3425 \r\n   Email: ejw@ics.uci.edu \r\n    \r\n   A. Faizi \r\n   Netscape \r\n   685 East Middlefield Road \r\n   Mountain View, CA 94043 \r\n   Email: asad@netscape.com \r\n    \r\n   S. R. Carter \r\n   Novell \r\n   1555 N. Technology Way \r\n   M/S ORM F111 \r\n   Orem, UT 84097-2399 \r\n   Email: srcarter@novell.com \r\n    \r\n   D. Jensen \r\n   Novell \r\n   1555 N. Technology Way \r\n   M/S ORM F111 \r\n   Orem, UT 84097-2399 \r\n   Email: dcjensen@novell.com \r\n    \r\n   Current Editors \r\n    \r\n   L. Dusseault \r\n   Xythos Software, Inc. \r\n   25 Maiden Lane, 6th floor \r\n   San Francisco \r\n   Email: lisa@xythos.com \r\n    \r\n   Jason L Crawford \r\n   P.O.Box 704 \r\n   Yorktown Heights, NY 10598 \r\n   Phone: 914-784-7569 \r\n   Email: nnjason8451@smallcue.com \r\n\r\n\r\n     \r\n                           Expires Oct 2003                         90 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n24 Appendices \r\n    \r\n24.1    Appendix 1 - WebDAV Document Type Definition \r\n    \r\n   This section provides a document type definition, following the \r\n   rules in [REC-XML], for the XML elements used in the protocol stream \r\n   and in the values of properties. It collects the element definitions \r\n   given in sections 13 and 13.28. \r\n    \r\n   The DTD is informational only, because legal XML in WebDAV bodies \r\n   can not be validated according to this DTD. There are two reasons \r\n   for this:  \r\n    - the DTD syntax does not specify namespace usage \r\n    - additional elements may appear according to the XML extensibility \r\n   rules outlined in section 15. \r\n    \r\n   <!DOCTYPE webdav-1.0 [ \r\n    \r\n   <!--============ XML Elements from Section 13 ==================--> \r\n    \r\n   <!-- General-use Elements --> \r\n   <!ELEMENT href (#PCDATA) > \r\n   <!ELEMENT prop ANY > \r\n    \r\n   <!-- Property Elements for 'lockdiscovery' and 'supportedlock' --> \r\n   <!ELEMENT activelock ANY> \r\n    \r\n   <!ELEMENT lockentry ANY > \r\n   <!ELEMENT lockinfo ANY > \r\n   <!ELEMENT locktype ANY > \r\n   <!ELEMENT write EMPTY > \r\n    \r\n   <!ELEMENT lockscope (exclusive | shared) > \r\n   <!ELEMENT exclusive EMPTY > \r\n   <!ELEMENT shared EMPTY > \r\n    \r\n   <!ELEMENT depth (#PCDATA) > \r\n   <!ELEMENT owner ANY > \r\n   <!ELEMENT timeout (#PCDATA) > \r\n   <!ELEMENT locktoken (href) > \r\n   <!ELEMENT lockroot (href) > \r\n    \r\n    \r\n   <!-- Multi-Status Response Body Elements --> \r\n   <!ELEMENT multistatus ANY > \r\n   <!ELEMENT response ANY > \r\n\r\n     \r\n                           Expires Oct 2003                         91 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   <!ELEMENT status (#PCDATA) > \r\n   <!ELEMENT propstat ANY > \r\n   <!ELEMENT responsedescription (#PCDATA) > \r\n    \r\n   <!-- PROPPATCH Request Body Elements --> \r\n   <!ELEMENT propertyupdate ANY > \r\n   <!ELEMENT remove (prop) > \r\n   <!ELEMENT set (prop) > \r\n    \r\n   <!-- PROPFIND Request Body Elements --> \r\n   <!ELEMENT propfind ANY > \r\n   <!ELEMENT allprop EMPTY > \r\n   <!ELEMENT propname EMPTY > \r\n    \r\n   <!-- Property Elements for 'resourcetype' --> \r\n   <!ELEMENT collection EMPTY > \r\n    \r\n   <!--========= Property Name Elements from Section 13.28 \r\n   ============--> \r\n   <!ELEMENT creationdate (#PCDATA) > \r\n   <!ELEMENT displayname (#PCDATA) > \r\n   <!ELEMENT getcontentlanguage (#PCDATA) > \r\n   <!ELEMENT getcontentlength (#PCDATA) > \r\n   <!ELEMENT getcontenttype (#PCDATA) > \r\n   <!ELEMENT getetag (#PCDATA) > \r\n   <!ELEMENT getlastmodified (#PCDATA) > \r\n   <!ELEMENT lockdiscovery ANY > \r\n   <!ELEMENT resourcetype ANY > \r\n   <!ELEMENT supportedlock ANY > \r\n   ]> \r\n    \r\n24.2    Appendix 3 - Notes on Processing XML Elements \r\n    \r\n24.2.1   Notes on Empty XML Elements \r\n    \r\n   XML supports two mechanisms for indicating that an XML element does \r\n   not have any content.  The first is to declare an XML element of the \r\n   form <A></A>.  The second is to declare an XML element of the form \r\n   <A/>.  The two XML elements are semantically identical. \r\n    \r\n \r\n24.2.2   Notes on Illegal XML Processing \r\n    \r\n   XML is a flexible data format that makes it easy to submit data that \r\n   appears legal but in fact is not.  The philosophy of \"Be flexible in \r\n   what you accept and strict in what you send\" still applies, but it \r\n   must not be applied inappropriately.  XML is extremely flexible in \r\n     \r\n                           Expires Oct 2003                         92 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   dealing with issues of white space, element ordering, inserting new \r\n   elements, etc.  This flexibility does not require extension, \r\n   especially not in the area of the meaning of elements. \r\n    \r\n   There is no kindness in accepting illegal combinations of XML \r\n   elements.  At best it will cause an unwanted result and at worst it \r\n   can cause real damage. \r\n    \r\n24.2.3  Example - XML Syntax Error \r\n    \r\n   The following request body for a PROPFIND method is illegal. \r\n    \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\"> \r\n      <D:allprop/> \r\n      <D:propname/> \r\n     </D:propfind> \r\n    \r\n   The definition of the propfind element only allows for the allprop \r\n   or the propname element, not both.  Thus the above is an error and \r\n   must be responded to with a 400 (Bad Request). \r\n    \r\n   Imagine, however, that a server wanted to be \"kind\" and decided to \r\n   pick the allprop element as the true element and respond to it.  A \r\n   client running over a bandwidth limited line who intended to execute \r\n   a propname would be in for a big surprise if the server treated the \r\n   command as an allprop. \r\n    \r\n   Additionally, if a server were lenient and decided to reply to this  \r\n   request, the results would vary randomly from server to server, with \r\n   some servers executing the allprop directive, and others executing \r\n   the propname directive. This reduces interoperability rather than \r\n   increasing it. \r\n    \r\n24.2.4  Example - Unknown XML Element \r\n    \r\n   The previous example was illegal because it contained two elements \r\n   that were explicitly banned from appearing together in the propfind \r\n   element.  However, XML is an extensible language, so one can imagine \r\n   new elements being defined for use with propfind.  Below is the \r\n   request body of a PROPFIND and, like the previous example, must be \r\n   rejected with a 400 (Bad Request) by a server that does not \r\n   understand the expired-props element. \r\n\r\n\r\n                           Expires Oct 2003                         93 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\" \r\n     xmlns:E=\"http://www.example.com/standards/props/\"> \r\n      <E:expired-props/> \r\n     </D:propfind> \r\n    \r\n   To understand why a 400 (Bad Request) is returned let us look at the \r\n   request body as the server unfamiliar with expired-props sees it. \r\n    \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\"   \r\n                 xmlns:E=\"http://www.example.com/standards/props/\"> \r\n     </D:propfind> \r\n    \r\n   As the server does not understand the expired-props element, \r\n   according to the WebDAV-specific XML processing rules specified in \r\n   section 15, it must ignore it.  Thus the server sees an empty \r\n   propfind, which by the definition of the propfind element is \r\n   illegal. \r\n    \r\n   Please note that had the extension been additive it would not \r\n   necessarily have resulted in a 400 (Bad Request).  For example, \r\n   imagine the following request body for a PROPFIND: \r\n    \r\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?> \r\n     <D:propfind xmlns:D=\"DAV:\"  \r\n                 xmlns:E=\"http://www.example.com/standards/props/\"> \r\n      <D:propname/> \r\n      <E:leave-out>*boss*</E:leave-out> \r\n     </D:propfind> \r\n    \r\n   The previous example contains the fictitious element leave-out. Its \r\n   purpose is to prevent the return of any property whose name matches \r\n   the submitted pattern.  If the previous example were submitted to a \r\n   server unfamiliar with leave-out, the only result would be that the \r\n   leave-out element would be ignored and a propname would be executed. \r\n    \r\n24.3    Appendix 4: UUID Node Generation \r\n    \r\n   UUIDs, as defined in [ISO-11578], contain a \"node\" field that \r\n   contains one of the IEEE 802 addresses for the server machine.  As \r\n   noted in section 18, there are several security risks associated \r\n   with exposing a machine's IEEE 802 address. This section provides an \r\n   alternate mechanism for generating the \"node\" field of a UUID which \r\n   does not employ an IEEE 802 address.  WebDAV servers MAY use this \r\n   algorithm for creating the node field when generating UUIDs.  The \r\n   text in this section is originally from an Internet-Draft by Paul \r\n   Leach and Rich Salz, who are noted here to properly attribute their \r\n   work. \r\n     \r\n                           Expires Oct 2003                         94 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n    \r\n   The ideal solution is to obtain a 47 bit cryptographic quality \r\n   random number, and use it as the low 47 bits of the node ID, with \r\n   the most significant bit of the first octet of the node ID set to 1. \r\n   This bit is the unicast/multicast bit, which will never be set in \r\n   IEEE 802 addresses obtained from network cards; hence, there can \r\n   never be a conflict between UUIDs generated by machines with and \r\n   without network cards. \r\n    \r\n   If a system does not have a primitive to generate cryptographic \r\n   quality random numbers, then in most systems there are usually a \r\n   fairly large number of sources of randomness available from which \r\n   one can be generated. Such sources are system specific, but often \r\n   include: \r\n    \r\n     - the percent of memory in use \r\n     - the size of main memory in bytes \r\n     - the amount of free main memory in bytes \r\n     - the size of the paging or swap file in bytes \r\n     - free bytes of paging or swap file \r\n     - the total size of user virtual address space in bytes \r\n     - the total available user address space bytes \r\n     - the size of boot disk drive in bytes \r\n     - the free disk space on boot drive in bytes \r\n     - the current time \r\n     - the amount of time since the system booted \r\n     - the individual sizes of files in various system directories \r\n     - the creation, last read, and modification times of files in    \r\n       various system directories \r\n     - the utilization factors of various system resources (heap, etc.) \r\n     - current mouse cursor position \r\n     - current caret position \r\n     - current number of running processes, threads \r\n     - handles or IDs of the desktop window and the active window \r\n     - the value of stack pointer of the caller \r\n     - the process and thread ID of caller \r\n     - various processor architecture specific performance counters \r\n       (instructions executed, cache misses, TLB misses) \r\n    \r\n   (Note that it is precisely the above kinds of sources of randomness \r\n   that are used to seed cryptographic quality random number generators \r\n   on systems without special hardware for their construction.) \r\n    \r\n   In addition, items such as the computer's name and the name of the \r\n   operating system, while not strictly speaking random, will help \r\n   differentiate the results from those obtained by other systems. \r\n     \r\n   The exact algorithm to generate a node ID using these data is system \r\n   specific, because both the data available and the functions to \r\n   obtain them are often very system specific. However, assuming that \r\n   one can concatenate all the values from the randomness sources into \r\n     \r\n                           Expires Oct 2003                         95 \r\n\r\n                         WebDAV (RFC2518) bis                June 2003 \r\n    \r\n   a buffer, and that a cryptographic hash function such as MD5 is \r\n   available, then any 6 bytes of the MD5 hash of the buffer, with the \r\n   multicast bit (the high bit of the first byte) set will be an \r\n   appropriately random node ID. \r\n    \r\n   Other hash functions, such as SHA-1, can also be used. The only \r\n   requirement is that the result be suitably random _ in the sense \r\n   that the outputs from a set uniformly distributed inputs are \r\n   themselves uniformly distributed, and that a single bit change in \r\n   the input can be expected to cause half of the output bits to \r\n   change. \r\n    \r\n    \r\n25 Full Copyright Statement \r\n    \r\n   Copyright (C) The Internet Society (1999).  All Rights Reserved. \r\n    \r\n   This document and translations of it may be copied and furnished to \r\n   others, and derivative works that comment on or otherwise explain it \r\n   or assist in its implementation may be prepared, copied, published \r\n   and distributed, in whole or in part, without restriction of any \r\n   kind, provided that the above copyright notice and this paragraph \r\n   are included on all such copies and derivative works.  However, this \r\n   document itself may not be modified in any way, such as by removing \r\n   the copyright notice or references to the Internet Society or other \r\n   Internet organizations, except as needed for the purpose of \r\n   developing Internet standards in which case the procedures for \r\n   copyrights defined in the Internet Standards process must be \r\n   followed, or as required to translate it into languages other than \r\n   English. \r\n    \r\n   The limited permissions granted above are perpetual and will not be \r\n   revoked by the Internet Society or its successors or assigns. \r\n    \r\n   This document and the information contained herein is provided on an \r\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING \r\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING \r\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION \r\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF \r\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. \r\n    \r\n    \r\n\r\n\r\n\r\n\r\n                           Expires Oct 2003                         96 \r\n", "encoding": "ISO-8859-1"}