{"url": "https://www.ics.uci.edu/~eppstein/161/960222.html", "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n<html>\n<head>\n<title>Finite automata and string matching</title>\n<meta name=\"Owner\" value=\"eppstein\">\n<meta name=\"Reply-To\" value=\"eppstein@ics.uci.edu\">\n</head>\n<body>\n<h1>ICS 161: Design and Analysis of Algorithms<br>\nLecture notes for February 22, 1996</h1>\n\n<!--#config timefmt=\"%d %h %Y, %T %Z\" -->\n<hr>\n<p></p>\n\n<h1>String matching</h1>\n\nYou probably often use your text editor (or the UNIX program\n\"grep\") to find some text in a file (e.g. the place where you\ndefined your depth first search program, or the email message you\nsent six weeks ago asking for an extension on your programming\nproject). \n\n<p>How does it do it?</p>\n\n<p>There are two commonly used algorithms: Knuth-Morris-Pratt (KMP)\nand <a href=\"people.html#boyer\">Boyer</a>-<a href=\n\"people.html#moore\">Moore</a> (BM). Both use similar ideas. Both\ntake linear time: O(m + n) where m is the length of the search\nstring, and n is the length of the file. Both only test whether\ncertain characters are equal or unequal, they don't do any\ncomplicated arithmetic on characters.</p>\n\n<p>Boyer-Moore is a little faster in practice, but more\ncomplicated. Knuth-Morris-Pratt is simpler, so it's the one we'll\ndiscuss. The book talks about it in terms of finite state machines\nwhich would be fine if you'd taken 162 but you haven't....</p>\n\n<h2>Finite state machines</h2>\n\nA finite state machine (FSM, also known as a deterministic finite\nautomaton or DFA) is a way of representing a <i>language</i>\n(meaning a set of strings; we're interested in representing the set\nstrings matching some pattern). \n\n<p>It's explicitly algorithmic: we represent the language as the\nset of those strings <i>accepted</i> by some program. So, once\nyou've found the right machine, you can test whether a given string\nmatches just by running it.</p>\n\n<p>The KMP algorithm works by turning the pattern it's given into a\nmachine, and then running the machine. The hard part of KMP is\nfinding the machine.</p>\n\n<p>We need some restrictions on what we mean by \"program\". This is\nwhere \"deterministic &amp; finite\" come from.</p>\n\n<p>One way of thinking about it, is in terms of programs without\nany variables. All such a program can do is look at each incoming\ncharacter determine what line to go to, and eventually return true\nor false (depending on whether it thinks the string matches or\ndoesn't).</p>\n\n<p><a name=\"even\">As a simple warmup example, let's look at a\nprogram for an easier problem: testing whether a string has an even\nnumber of characters.</a></p>\n\n<pre>\n    main()\n    {\n        for (;;) {\n            if (getchar() == EOF) return TRUE;\n            if (getchar() == EOF) return FALSE;\n        }\n    }\n</pre>\n\nNote the lack of variables. To simplify things, we'll rewrite\nprograms to avoid complicated loops, and instead just use <a name= \n\"goto\">goto statements</a>. (You've probably been taught that gotos\nare bad, but this sort of rewriting happens all the time, in fact\nevery time you run a compiler it has to do this.) \n\n<pre>\n    main()\n    {\n        even:\n            if (getchar() == EOF) return TRUE;\n            else goto odd;\n\n        odd:\n            if (getchar() == EOF) return FALSE;\n            else goto even;\n    }\n</pre>\n\nWe've chosen labels for the goto statements, to represent what we\nknow about the string so far (in this problem, whether we've seen\nan even or odd number of characters so far). Because there are no\nvariables, we can only represent knowledge about the input in terms\nof where we are in the program. We think of each line in the\nprogram as being a <a name=\"state\"><i>state</i></a>, representing\nsome specific fact about the part of the string we've seen so far.\nHere the states are \"even\" and \"odd\", and represent what we know\nabout the number of characters seen so far. \n\n<p>Since there are no variables, the only thing a machine can do in\na given state (state = what line the prog is on) is to go to\ndifferent states, depending on what character it sees.</p>\n\n<p>This can be a useful programming style; for instance I am using\n<a href=\"http://www.ics.uci.edu/~eppstein/pubs/filter.html\"> a\nprogram written in close to this style</a> to filter some html\nfiles on my web pages. One advantage of this style is that there\nare few ways the program can be tricked into having unexpected\nvalues in its variables (since there are no variables) so it is\nhard to make such a program crash. But it's a little long and\ncumbersome, and you wouldn't want to have to compile a separate C\nprogram every time you ran \"grep\".</p>\n\n<p>Rather than writing C code, we'll draw pictures with circles and\narrows. (These pictures are known as <a name=\"diag\"><i>state\ndiagrams</i></a>.) A circle will represent a state, an arrow with a\nlabel will represent that we go to that state if we see that\ncharacter. (You can think of this as just being a special kind of\ngraph.) We'll also draw an arrow from nowhere to the first state\nthe program starts in, and arrows to nowhere if the program returns\ntrue if the string ends at that state. So our program can be\nrepresented with the following diagram.</p>\n\n<p><img src=\"parity.gif\" width=\"217\" height=\"128\"></p>\n\n<p>In class I described a more complicated example, that could be\nused by the <a name=\"cpp\"><i>C preprocessor</i></a> (a part of most\nC compilers) to tell which characters are part of comments and can\nbe removed from the input:</p>\n\n<p><img src=\"comment.gif\" width=\"460\" height=\"279\"></p>\n\n<p>It's easy to turn such a diagram into a program, that simply has\none label and one case statement per state.</p>\n\n<p>If we're given such a diagram, and a string, we can easily see\nwhether the corresponding program returns true or false. Simply\nplace a marker (such as a penny) on the initial state, and move it\naround one state at a time until you run out of characters. Once\nyou run out of characters, see whether the state you're in has an\n\"accept\" arrow -- if so, the pattern matches, and if not it\ndoesn't.</p>\n\n<p>In a computer, we obviously don't represent these things with\ncircles and arrows. Instead they can be viewed as just being a\nspecial kind of graph, and we can use any of the normal <a href= \n\"960201.html#rep\">graph representations</a> to store them.</p>\n\n<p>One particularly useful representation is a <a name=\"tt\"><i>\ntransition table</i></a>: we make a table with rows indexed by\nstates, and columns indexed by possible input characters. Then\nsimulating the machine can be done simply by looking up each new\nstep in the table. (You also need to store separately the start and\naccept states.) For the machine above that tests whether a string\nhas even length, the table might look like this:</p>\n\n<pre>\n                any\n                ---\n    even:       odd\n    odd:        even\n</pre>\n\nFor the C comment machine, we get a more complicated table: \n\n<pre>\n                /       *       EOL     other\n                ---     ---     ---     ---\n    none:       slash   none    none    none\n    slash:      C++     C       none    none\n    C++:        C++     C++     none    C++\n    C:          C       star    C       C\n    star:       none    star    C       C\n</pre>\n\nSince a state diagram is just a kind of graph, we can use graph\nalgorithms to find some information about finite state machines.\nFor instance we can simplify them by eliminating <a name=\"unreach\">\nunreachable states</a>, or find the shortest path through the\ndiagram (which corresponds to the <a name=\"ssa\">shortest string\naccepted</a> by that machine). \n\n<h2>Automata and string matching</h2>\n\nThe examples above didn't have much to do with string matching.\nLet's look at one that does. Suppose we want to <a name=\"nano\">\n\"grep nano\"</a>. Rather than just starting to write states down,\nlet's think about what we want them to mean. At each step, we want\nto store in the current state the information we need about the\nstring seen so far. Say the string seen so far is \"...stuvwxy\",\nthen we need to know two things: \n\n<ol>\n<li>Have we already matched the string we're looking for\n(\"nano\")?</li>\n\n<li>If not, could we possibly be in the middle of a match?</li>\n</ol>\n\nIf we're in the middle of a match, we need to know how much of\n\"nano\" we've already seen. Also, depending on the characters we\nhaven't seen yet, there may be more than one match that we could be\nin the middle of -- for instance if we've just seen \"...nan\", then\nwe have different matches if the next characters are \"o...\" or if\nthey're \"ano...\". But let's be optimistic, and only remember the\nlongest partial match. \n\n<p>So we want our states to be partial matches to the pattern. The\npossible partial matches to \"nano\" are \"\", \"n\", \"na\", \"nan\", or\n(the complete match) \"nano\" itself. In other words, they're just\nthe <a name=\"prefix\"><i>prefixes</i></a> of the string. In general,\nif the pattern has m characters, we need m+1 states; here m=4 and\nthere are five states.</p>\n\n<p>The start and accept states are obvious: they are just the 0-\nand m-character prefixes. So the only thing we need to decide is\nwhat the transition table should look like. If we've just seen\n\"...nan\", and see another character \"x\", what state should we go\nto? Clearly, if x is the next character in the match (here \"o\"), we\nshould go to the next longer prefix (here \"nano\"). And clearly,\nonce we've seen a complete match, we just stay in that state. But\nsuppose we see a different character, such as \"a\"? That means that\nthe string so far looks like \"...nana\". The longest partial match\nwe could be in is just \"na\". So from state \"nan\", we should draw an\narrow labeled \"a\" to state \"na\". Note that \"na\" is a prefix of\n\"nano\" (so it's a state) and a <a name=\"suffix\"><i>suffix</i></a>\nof \"nana\" (so it's a partial match consistent with what we've just\nseen).</p>\n\n<p>In general the transition from state+character to state is the\nlongest string that's simultanously a prefix of the original\npattern and a suffix of the state+character we've just seen. This\nis enough to tell us what all the transitions should be. If we're\nlooking for pattern \"nano\", the transition table would be</p>\n\n<pre>\n        n       a       o       other\n        ---     ---     ---     ---\n    empty:  \"n\"     empty   empty   empty\n    \"n\":    \"n\"     \"na\"    empty   empty\n    \"na\":   \"nan\"   empty   empty   empty\n    \"nan\":  \"n\"     \"na\"    \"nano\"  empty\n    \"nano\": \"nano\"  \"nano\"  \"nano\"  \"nano\"\n</pre>\n\nFor instance the entry in row \"nan\" and column n says that the\nlargest string that's simultaneously a prefix of \"nano\" and a\nsuffix of \"nan\"+n=\"nann\" is simply \"n\". We can also represent this\nas a state diagram: \n\n<p><img src=\"nano.gif\" width=\"421\" height=\"156\"></p>\n\n<p>Simulating this on the string \"banananona\", we get the sequence\nof states empty, empty, empty, \"n\", \"na\", \"nan\", \"na\", \"nan\",\n\"nano\", \"nano\", \"nano\". Since we end in state \"nano\", this string\ncontains \"nano\" in it somewhere. By paying more careful attention\nto when we first entered state \"nano\", we can tell exactly where it\noccurs; it is also possible to modify the machine slightly and find\nall occurrences of the substring rather than just the first\noccurrence.</p>\n\n<p>This description is enough to get a string matching algorithm\nthat takes something like O(m^3 + n) time: O(m^3) to build the\nstate table described above, and O(n) to simulate it on the input\nfile. There are two tricky points to the KMP algorithm. First, it\nuses an alternate representation of the state table which takes\nonly O(m) space (the one above could take O(m^2)). And second, it\nuses a complicated loop to build the whole thing in O(m) time.\nWe'll see this algorithm next time.</p>\n\n<hr>\n<p><a href=\"/~eppstein/161/\">ICS 161</a> -- <a href=\"/\">Dept.\nInformation &amp; Computer Science</a> -- <a href= \n\"http://www.uci.edu/\">UC Irvine</a><br>\n<small>Last update: \n<!--#flastmod file=\"960222.html\" --></small></p>\n</body>\n</html>\n\n", "encoding": "ascii"}