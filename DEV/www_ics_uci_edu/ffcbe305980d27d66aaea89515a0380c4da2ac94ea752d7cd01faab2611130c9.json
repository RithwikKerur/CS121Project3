{"url": "https://www.ics.uci.edu/~ejw/authoring/collection/dt/CollSpec034.txt", "content": "WEBDAV Working Group                                     J. Slein, Xerox\nINTERNET DRAFT                             E.J. Whitehead Jr., UC Irvine\n<draft-ietf-webdav-collection-protocol-03.4>         J. Davis, CourseNet\n                                                      G. Clemm, Rational\n                                                         C. Fay, FileNet\n                                                        J. Crawford, IBM\n                                                 T. Chihaya, DataChannel\n                                                           June 18, 1999\nExpires December 18, 1999\n\n\t\t\tWebDAV Advanced Collections Protocol\n\nStatus of this Memo\n\nThis document is an Internet-Draft and is in full conformance with all \nprovisions of Section 10 of RFC2026. Internet-Drafts are working \ndocuments of the Internet Engineering Task Force (IETF), its areas, and \nits working groups. Note that other groups may also distribute working \ndocuments as Internet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months \nand may be updated, replaced, or obsoleted by other documents at any \ntime. It is inappropriate to use Internet-Drafts as reference material \nor to cite them other than as \"work in progress\".\n\nTo view the list Internet-Draft Shadow Directories, see \nhttp://www.ietf.org/shadow.html.\n\nDistribution of this document is unlimited. Please send comments to the \nDistributed Authoring and Versioning (WebDAV) working group at <w3c-\ndist-auth@w3.org>, which may be joined by sending a message with subject \n\"subscribe\" to <w3c-dist-auth-request@w3.org>.\n\nDiscussions of the WEBDAV working group are archived at URL: \n<http://lists.w3.org/Archives/Public/w3c-dist-auth/>.\n\nAbstract\n\nThe WebDAV Distributed Authoring Protocol provides basic support for \ncollections, offering the ability to create and list unordered \ncollections.  Many applications, however, need more powerful \ncollections, especially for resource sharing and collection ordering.\n\nThis specification defines HTTP methods, headers, and XML elements that \nsupplement the WebDAV Distributed Authoring Protocol to support resource \nsharing and collection orderings.  Resource sharing is provided by \nbindings and redirect references.  Bindings create new mappings of URIs \nto resources, while redirect references respond to most requests with an \nHTTP Redirection (i.e., a 302 status code).  An ordered collection \nalways returns a listing of its members in a specific order.  Together, \nthese capabilities are referred to as WebDAV Advanced Collections.\n\nTable of Contents\n\n1\tNotational Conventions......................................3\n2\tTerminology.................................................4\n3\tIntroduction................................................5\n\nSlein et al.                                                    Page 1\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n4\tShared Resources............................................6\n4.1\tOverview....................................................6\n4.2\tBindings....................................................7\n4.2.1\tBIND Method.................................................8\n4.2.2\tBindings to Collections.....................................9\n4.2.3\tURI Mappings Created by BIND...............................10\n4.2.4\tExample: Generating the Set of URI Mappings................10\n4.2.5\tStatus Codes...............................................11\n4.2.6\tExample: BIND..............................................11\n4.2.7\tExample: BIND Conflict.....................................12\n4.2.8\tDELETE and Bindings........................................12\n4.2.9\tCOPY and Bindings..........................................13\n4.2.10\tMOVE and Bindings..........................................13\n4.2.11\tLOCK and UNLOCK............................................15\n4.2.12\tBindings and Other Methods.................................16\n4.2.13\tDiscovering the Bindings to a Resource.....................16\n4.3\tRedirect References........................................17\n4.3.1\tMKREF Method...............................................17\n4.3.2\tListing the Redirect References in a Collection............19\n4.3.3\tCopying Redirect References................................22\n4.3.4\tDeleting and Moving Redirect References....................24\n4.3.5\tLocking Redirect References................................24\n4.3.6\tLOCK on Redirect References................................25\n4.3.7\tOther Operations on Redirect References....................28\n4.3.8\tOperations on Targets of Redirect References...............30\n4.3.9\tRelative URIs in Ref-Target and DAV:reftarget..............31\n4.3.10\tRedirect References to Collections.........................32\n5\tOrdered Collections........................................33\n5.1\tOverview...................................................33\n5.2\tCreating an Ordered Collection.............................34\n5.2.1\tOverview...................................................34\n5.2.2\tExample: Creating an Ordered Collection....................34\n5.3\tSetting the Position of a Collection Member................35\n5.3.1\tOverview...................................................35\n5.3.2\tStatus Codes...............................................35\n5.3.3\tExamples: Setting the Position of a Collection Member......35\n5.4\tChanging the Semantics of a Collection Ordering............36\n5.5\tChanging the Position of a Collection Member...............36\n5.5.1\tORDERPATCH Method..........................................36\n5.5.2\tStatus Codes...............................................36\n5.5.3\tExample: Changing Positions in an Ordered Collection.......37\n5.5.4\tExample: Failure of an ORDERPATCH Request..................38\n6\tHeaders....................................................39\n6.1\tAll-Bindings Request Header................................39\n6.2\tRef-Target Entity Header...................................39\n6.3\tResource-Type Entity Header................................40\n6.4\tPassthrough Request Header.................................40\n6.5\tOrdered Entity Header......................................40\n6.6\tPosition Request Header....................................40\n7\tStatus Codes...............................................41\n\nSlein et al.                                                    Page 2\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n7.1\t506 Loop Detected..........................................41\n7.2\t425 Unordered Collection...................................41\n8\tProperties.................................................41\n8.1\treftarget Property.........................................41\n8.2\tlocation Property..........................................42\n8.3\tbindings Property..........................................42\n8.4\torderingtype Property......................................42\n9\tXML Elements...............................................43\n9.1\tredirectref XML Element....................................43\n9.2\tsegment XML Element........................................43\n9.3\tunordered XML Element......................................43\n9.4\tcustom XML Element.........................................43\n9.5\torder XML Element..........................................44\n9.6\tordermember XML Element....................................44\n9.7\tposition XML Element.......................................44\n9.8\tfirst XML Element..........................................44\n9.9\tlast XML Element...........................................44\n9.10\tbefore XML Element.........................................45\n9.11\tafter XML Element..........................................45\n9.12\toptions XML Element........................................45\n9.13\torderingoptions XML Element................................45\n10\tExtensions to the DAV:response XML Element for Multi-Status \n        Responses..................................................45\n11\tCapability Discovery.......................................46\n11.1\tCompliance Classes.........................................46\n11.2\tExample: Discovery of Compliance Classes...................46\n11.3\tAdditional Advanced Collections Capabilities...............47\n11.4\tExample: Discovery of Ordering Options.....................47\n12\tSecurity Considerations....................................48\n12.1\tPrivacy Concerns...........................................48\n12.2\tRedirect Loops.............................................48\n12.3\tRedirect References, Bindings, and Denial of Service.......48\n12.4\tPrivate Locations May Be Revealed..........................49\n12.5\tDAV:bindings and Denial of Service.........................49\n12.6\tDenial of Service and DAV:orderingtype.....................49\n13\tInternationalization Considerations........................49\n14\tIANA Considerations........................................50\n15\tCopyright..................................................50\n16\tIntellectual Property......................................50\n17\tAcknowledgements...........................................50\n18\tReferences.................................................50\n18.1\tNormative References.......................................50\n18.2\tInformational References...................................51\n19\tAuthors' Addresses.........................................51\n20\tAppendices.................................................52\n20.1\tAppendix 1: Extensions to the WebDAV Document Type \n        Definition.................................................52\n\n1 Notational Conventions\n\nSince this document describes a set of extensions to the HTTP/1.1 \nprotocol, the augmented BNF used here to describe protocol elements is \nexactly the same as described in Section 2.1 of [HTTP].  Since this \naugmented BNF uses the basic production rules provided in Section 2.2 of \n[HTTP], these rules apply to this document as well.\n\n\nSlein et al.                                                    Page 3\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this \ndocument are to be interpreted as described in [RFC2119].\n\n2 Terminology\n\nThe terminology used here follows and extends that in the WebDAV \nDistributed Authoring Protocol specification [WebDAV]. Definitions of \nthe terms resource, Uniform Resource Identifier (URI), and Uniform \nResource Locator (URL) are provided in [URI].\n\nAssociation\n     A direct or indirect connection between a resource and a namespace \n     element that supports resource sharing. The bindings, URI \n     mappings, and redirect references defined in this specification \n     are types of associations.\n\nURI Mapping\n     An association between an absolute URL or URI and a resource. \n     Since a resource can represent items that are not network \n     retrievable, as well as those that are, it is possible for a \n     resource to have zero, one, or many URI mappings to URLs or URIs. \n     Mapping a resource to an \"http\" scheme URL makes it possible to \n     submit HTTP protocol requests to the resource using the URL.\n\nPath Segment\n     Informally, the characters found between slashes (\"/\") in a URL or \n     URI.  Formally, as defined in section 3.3 of [URI].\n\nBinding\n     An association between a single path segment (in a collection) and \n     a resource. A binding creates one or more URI mappings, and hence \n     is a mechanism for resource sharing, allowing a single resource to \n     be accessed from multiple locations in a URI namespace.\n \nCollection\n     A resource that contains, as part of its state, a set of bindings \n     which identify member resources.\n\nInternal Member URI\n     The URI mapping, created by a binding that is contained in a \n     collection.  While, in general, bindings can create multiple URI \n     mappings to a resource, for a given request, only one of these URI \n     mappings is referred to as the internal member. The URI of the \n     parent collection used in a given request determines the base URI \n     for internal member URI calculation.\n\n     In [WebDAV], a collection is defined as containing a list of \n     internal member URIs, where an internal member URI is the URI of \n     the collection, plus a single path segment.  This definition \n     combines the two concepts of binding and mapping that are \n     separated in this specification.  As a result, this specification \n     redefines a collection's state to be a set of bindings, and \n     redefines an internal member URI to be a mapping derived from a \n     binding. After this redefinition, an internal member URI can be \n\nSlein et al.                                                    Page 4\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n     used when reading [WebDAV] without loss of meaning. For purposes \n     of interpretation, when [WebDAV] discusses a collection \n     \"containing\" an internal member URI, this should be read as the \n     collection containing a binding whose mapping to a URI creates an \n     internal member URI, in this sense \"containing\" the internal \n     member URI.  The authors of this specification anticipate and \n     recommend that future revisions of [WebDAV] perform a full \n     reconciliation of terms between these two specifications.\n\nReference\n     A resource whose purpose is to provide access to another resource.\n\nRedirect Reference\n     A resource whose purpose is to provide access to another resource, \n     and that requires client action before it can be resolved.  The \n     client is aware that this type of reference is mediating between \n     it and the target resource.\n\nOrdinary Resource\n     A resource that is not a reference to another resource.\n\nTarget Resource\n     The resource referenced by a referential resource.\n\nReferential Integrity\n     The integrity of a reference is preserved as long as it points to \n     the same resource it pointed to when it was created.  Its \n     integrity may be destroyed if the target resource is moved without \n     updating the reference to reflect its new location, or if the \n     target resource is deleted while a reference to it still exists.\n\n3 Introduction\n\nThe simple collections that the WebDAV Distributed Authoring Protocol \nspecification supports are powerful enough to be widely useful.  They \nprovide for the hierarchical organization of resources, with mechanisms \nfor creating and deleting collections, copying and moving them, locking \nthem, adding members to them and removing members from them, and getting \nlistings of their members.  Delete, copy, move, list, and lock \noperations can be applied recursively, so that a client can operate on \nwhole hierarchies with a single request.\n\nMany applications, however, need more powerful collections.  There are \ntwo areas in particular where more powerful functionality is often \nneeded: shared resources and ordering.  This specification defines  \nextensions to [WebDAV] in both these areas.\n\nOrganizing resources into hierarchies places them into smaller \ngroupings, known as collections, which are more easily browsed and \nmanipulated than a flat namespace.  However, hierarchies require \ncategorization decisions that locate resources at a single location in \nthe hierarchy, a drawback when a resource has multiple valid categories. \nFor example, in a hierarchy of vehicle descriptions containing \ncollections for cars and boats, a description of a combination car/boat \nvehicle could belong in either collection. Ideally, the description \n\nSlein et al.                                                    Page 5\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nshould be accessible from both.\n\nHierarchies also make resource sharing more difficult, since resources \nthat have utility across many collections are still forced into a single \ncollection. For example, the mathematics department at one university \nmight create a collection of information on fractals that contains \nbindings to some local resources, but also provides access to some \nresources at other universities.  For many reasons, it may be \nundesirable to make physical copies of the shared resources on the local \nserver - to conserve disk space, to respect copyright constraints, or to \nmake any changes in the shared resources visible automatically.  \n\nThis protocol provides two mechanisms for allowing resources to appear \nin multiple places in an http URL hierarchy, and for sharing resources: \nbindings and redirect references.\n\nThe WebDAV Distributed Authoring Protocol added to the Web the ability \nto navigate Web resources hierarchically, complementing existing \nhypertext navigation facilities. In hypertext navigation, links appear \nin a specific order in a document. By contrast, hierarchical navigation \nhas fewer mechanisms for expressing the ordering of a set of resources.\n\nThere are many scenarios where it is useful to impose an ordering on a \ncollection, such as expressing a recommended access order, or a revision \nhistory order. Orderings may be based on property values, but they may \nbe completely independent of any properties on the resources identified \nby the collection's internal member URIs.  Orderings based on properties \ncan be obtained using a search protocol [DASL], but orderings not based \non properties need some other mechanism.  These orderings generally need \nto be maintained by a human user.  The ordering protocol defined here \nfocuses on support for such human-maintained orderings, but also allows \nfor server-maintained orderings.\n\n4 Shared Resources\n\n4.1 Overview\n\nShared resources make the same resource accessible from multiple \nlocations in http URL namespaces.  This protocol provides two mechanisms \nfor sharing resources: bindings and redirect references.\n\nThe binding mechanism defined in this specification provides a way for \nclients to add new URI mappings to existing resources.  A URI mapping is \nan association between an absolute URI and a resource, which makes it \npossible to submit requests to the resource using that URI as the \nRequest-URI. Bindings, and the URI mappings based on them, are appealing \nmechanisms for resource sharing because: \n\no Once URI mappings are created with a BIND request, clients need do \n  nothing special to use them.  They behave just like any other URI \n  mappings, transparently applying operations to the target resource.  \no HTTP and WebDAV servers already provide URI mappings, so there is \n  little extra work involved in allowing clients to create them.\no The integrity of bindings is guaranteed.  MOVE and DELETE operations \n  cannot leave bindings in an inconsistent state.  \n\nSlein et al.                                                    Page 6\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\nA limitation of bindings is that a server would need proxy capabilities \nin order to support bindings to resources on another server.  In light \nof this complexity, support for cross-server bindings is OPTIONAL.\n\nA redirect reference is a resource whose purpose is to provide access to \nanother resource.  It redirects most requests on the reference to \nanother resource, thereby providing a form of mediated access to the \nother resource.  Since the HTTP 302 (Moved Temporarily) status code is \nused to redirect client requests on a redirect reference, from the \nclient\u2019s point of view redirect references are less convenient to use \nthan bindings.  Redirect references require action by the client before \nthey can be resolved.  Moreover, the server is not required to enforce \nthe integrity of redirect references.  However, redirect references have \na number of advantages: \n\no They are simple for servers to implement.  Servers already provide \n  redirect resources in the form of 301 / 302 redirection control, and \n  the same mechanism can be used for redirect references.\no The same simple implementation works equally well for target \n  resources that reside on the same server and for target resources \n  that reside on a different server.  \no Redirect references have only limited security implications.  \no Since redirect references are resources, they can carry properties of \n  their own.\n\nIdeally, non-referencing clients should be able to use both bindings and \nredirect references.  This goal is more difficult to meet for redirect \nreferences, since client action is required to resolve them.  The \nstrategy of having redirect references respond to most requests with a \n302 (Moved Temporarily), accompanied by the URI of the target resource \nin the Location header, fulfills this goal in most cases.\n\n4.2 Bindings\n\nBindings are part of the state of a collection. In general, there is a \none-to-one correspondence between a collection's bindings and its \ninternal member URIs.  The URI segment associated with a resource by one \nof a collection's bindings is also the final segment of one of the \ncollection's internal member URIs.  The final segment of each internal \nmember URI identifies one of the bindings that is part of the \ncollection's state, unless the internal member URI is not bound to a \nresource.\n\nEven though a binding is just an association between a path segment and \na resource, a binding creates one or more URI mappings of a URI to a \nresource.  For example, if the segment \"index.html\" is being bound to a \nresource in a collection with URL \"http://www.foo.net/A/\", the binding \ncreates a URI mapping of URL \"http://www.foo.net/A/index.html\" to the \nHTML resource. If the parent collection is then bound to the segment \n\"B\", this creates two URI mappings, \"http://www.foo.net/B/\" to the \ncollection resource, and \"http://www.foo.net/B/index.html\" to the HTML \nresource.  Both the collection and the HTML resource are now accessible \nvia two URLs apiece.\n\n\nSlein et al.                                                    Page 7\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nFor a resource implemented by a computer, the relationship between a URI \nmapping and a resource is highlighted in the following diagram:\n\n           URI 1   URI 2 ... URI N  \n             |       |        |\n             |       |        |      <------- URI Mappings\n             |       |        |\n          +---------------------+\n          |     Resource R      |\n          +---------------------+\n\nAs discussed in [URI], a resource is an abstraction that maps a URI to \nan entity or set of entities.  This resource can have multiple URIs/URLs \nmapped to it.\n\nThe identity of a binding is determined by the URI segment (in its\ncollection) and the resource that the binding associates.  If the \nresource is destroyed, the binding also goes out of existence.  If the \nURI segment comes to be associated with a different resource, the \noriginal binding ceases to exist and another binding is created.\n\nBindings are not unique to advanced collections, although the BIND \nmethod for explicitly creating bindings is introduced here.  Existing \nmethods that create resources, such as PUT, MOVE, COPY, and MKCOL, \nimplicitly create bindings.  There is no difference between implicitly \ncreated bindings and bindings created with BIND.\n\nSince a binding is an association between a path segment and a resource, \nit would be very undesirable if one binding could be destroyed as a side \neffect of operating on the resource through a different binding.  It is \nnot acceptable for a DELETE or MOVE through a different binding to \ndestroy the resource or fail to update one binding, turning that binding \ninto a dangling path segment.  As a result, implementations MUST act to \nensure the integrity of bindings.\n\nIt is especially difficult to maintain the integrity of cross-server \nbindings.  Unless the server where the resource resides knows about all \nbindings on all servers to that resource, it may unwittingly destroy the \nresource or move it without notifying a server where a binding resides.  \nFor example, if server A permits creation of a binding to a resource on \nserver B, server A must notify server B about its binding and must have \nan agreement with B that B will not destroy the resource while A's \nbinding exists.  Otherwise server B may receive a DELETE request that it \nthinks removes the last binding to the resource and destroy the resource \nwhile A's binding still exists. \n\nConsequently, support for cross-server bindings is OPTIONAL.\n\n4.2.1 BIND Method\n\nThe BIND method creates a new binding from the final segment of the \nRequest-URI (minus any trailing slash) to the resource identified\nby the Destination header.  This binding is added to the collection \nidentified by the Request-URI minus its trailing slash (if present) and \nfinal segment.  The Destination header is defined in Section 9.3 of \n\nSlein et al.                                                    Page 8\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n[WebDAV].\n\nIf a server cannot guarantee the binding behavior specified for GET \n(Section 4.2.12), DELETE (Section 4.2.8), and MOVE (Section 4.2.10), the \nBIND request MUST fail with a 501 (Not Implemented) status code.\n\nIf the Request-URI ends in a slash (\"/\") (i.e., the Request-URI \nidentifies a collection), the resource identified by the Destination \nheader MUST be a collection resource, or the request fails with a 409 \n(Conflict) status code. This ensures that URIs ending in a slash are \nalways bound to collections.  If the Request-URI does not contain a path \nsegment (i.e., it consists simply of a slash \"/\"), the BIND operation \nMUST fail and report a 409 (Conflict) status code.\n\nAfter successful processing of a BIND request, it MUST be possible for \nclients to use the Request-URI to submit requests to the resource \nidentified by the Destination header.\n\nBy default, if the Request-URI identifies an existing binding, the new \nbinding replaces the existing binding. This default binding replacement \nbehavior can be overridden using the Overwrite header defined in Section \n9.6 of [WebDAV]. \n\nThe Position request header (defined in Section 6.6) MAY be used in BIND \nrequests.\n\nA server MAY allow the BIND method to be used to create bindings to \nresources that support content negotiation or to resources that \ndynamically generate response entities.\n\n4.2.2 Bindings to Collections\n\nBIND can create a binding to a collection resource.  A collection \naccessed through such a binding behaves exactly as would a collection \naccessed through any other binding.  Bindings to collections can result \nin loops, which servers MUST detect when processing \"Depth: infinity\" \nrequests.  When a loop is detected, the server MUST respond with a 506 \n(Loop Detected) status code (defined in Section 7.1).\n\nCreating a new binding to a collection makes each resource associated \nwith a binding in that collection accessible via a new URI, but does not \nresult in the creation of a new binding for each of these resources.\n\nFor example, suppose a new binding COLLX is created for collection C1 in \nthe figure below.  It immediately becomes possible to access resource R1 \nusing the URI /COLLX/x.gif and to access resource R2 using the URI \n/COLLX/y.jpg, but no new bindings for these child resources were \ncreated.  This is because bindings are part of the state of a \ncollection, and associate a URI that is *relative to that collection* \nwith its target resource.  No change to the bindings in Collection C1 is \nneeded to make its children accessible using /COLLX/x.gif and \n/COLLX/y.jpg.\n\n+-------------------------+\n| Root Collection         |\n\nSlein et al.                                                    Page 9\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n| (properties)            |\n|  bindings:              |\n|  coll1          COLLX   |\n+-------------------------+\n    |            /           \n    |           / \n    |          / \n+------------------+   \n| Collection C1    |   \n| (properties)     |   \n| bindings:        |\n| x.gif     y.jpg  |   \n+------------------+   \n    |          \\                \n    |           \\                \n    |            \\               \n+-------------+   +-------------+\n| Resource R1 |   | Resource R2 |\n+-------------+   +-------------+ \n\n4.2.3 URI Mappings Created by BIND\n\nThe set of URI mappings created by a successful BIND operation MUST be \ndetermined as follows:\n\n1. Start with an empty set of URLs, called U.\n2. Take the Request-URI and remove path segments (and associated \"/\" \ncharacters) from the right until either (a) a non-WebDAV collection, or \na non-WebDAV advanced collection is found, or (b) the root, \"/\" is \nreached (i.e., no characters after the scheme and authority parts of the \nURL).  This is the base URL B.\n3. Add B, and all possible domain name variants of B (i.e., all other \ndomain names which can be substituted for the domain name in B, and \nstill retrieve the resource mapped to B), to URL set U.\n4. Calculate the next path segment of the Request-URI, going from right \nto left, and call it S, which is bound to resource R. \n5. For each member of URL set U, called Um, remove Um, then for every \npossible binding to R, create a new URL by adding the binding's path \nsegment to Um, then add this new URL to U.\n6. If there is no further path segment, then U has the complete set of \nURI mappings. Otherwise, go back to step 4.\n\n4.2.4 Example: Generating the Set of URI Mappings\n\nAssume a server responds to two domain names, www.fuzz.com, and \nfuzz.com, and has a top level that is not WebDAV-aware, called A/.  \nBelow A/ is an advanced collection that is bound to both 1/ and one/. In \ncollection one/ there is a resource called index.html.\n\n>> Request:\n\nBIND /A/1/info.html HTTP/1.1\nHost: www.fuzz.com\nDestination: http://www.fuzz.com/A/one/index.html\n\n\nSlein et al.                                                    Page 10\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nThe set of all possible URI mappings to the resource identified by \nhttp://www.fuzz.com/A/one/index.html is calculated as follows:\n\n1. U is empty.\n2. The base URL, B, is http://www.fuzz.com/A/, since A/ is not WebDAV-\naware.\n3. Since there are two domain names for this server, the domain name \nvariations of B are added to U, making U contain: http://www.fuzz.com/A/ \nand http://fuzz.com/A/.\n4. (iteration 1) The next path segment of the Request-URI is 1/, which \nis bound to an advanced collection resource, R.\n5. (iteration 1) Since the advanced collection resource R is bound to 1/ \nand one/, the value of U after the operation is: \nhttp://www.fuzz.com/A/1/, http://www.fuzz.com/A/one/, \nhttp://fuzz.com/A/1/, and http://fuzz.com/A/one/.\n6. Go back to step 4, since there is one more path segment in the \nRequest-URI.\n4. (iteration 2) The next path segment of the Request-URI is info.html, \nwhich is bound to an HTML resource, R.\n5. (iteration 2) Since the HTML resource is bound to info.html and \nindex.html, the value of U after the operation is: \nhttp://www.fuzz.com/A/1/index.html, http://www.fuzz.com/A/1/info.html, \nhttp://www.fuzz.com/A/one/index.html, \nhttp://www.fuzz.com/A/one/info.html, http://fuzz.com/A/1/index.html, \nhttp://fuzz.com/A/1/info.html, http://fuzz.com/A/one/index.html, \nhttp://fuzz.com/A/one/info.html.\n6. Since there are no further path segments in the Request-URI, U now \nhas the complete set of URI mappings for the resource identified by the \nDestination header.\n\n4.2.5 Status Codes\n\n201 (Created): The binding was successfully created.\n\n400 (Bad Request): The client set an invalid value for the Destination \nor Position header.\n\n409 (Conflict): Several conditions may produce this response.  The URI \nin the Destination header is not mapped to a resource.  The request is \nattempting to create a binding in a collection that does not exist.  The \nrequest is attempting to position the binding in an unordered \ncollection. The request is attempting to re-bind the top-level \ncollection.\n\n412 (Precondition Failed): The Overwrite header is \"F\", and a binding \nalready exists for the request-URI.\n\n4.2.6 Example: BIND \n\n>> Request:\n\n\nSlein et al.                                                    Page 11\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nBIND /~whitehead/dav/spec08.txt HTTP/1.1\nHost: www.ics.uci.edu\nDestination: http://www.ics.uci.edu/pub/i-d/draft-webdav-protocol-08.txt\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nThe server created a new binding, associating \"spec08.txt\" with the \nresource identified by the URL \"http://www.ics.uci.edu/pub/i-d/draft-\nwebdav-protocol-08.txt\".  Clients can now use the Request-URI, \n\"http://www.ics.uci.edu/~whitehead/dav/spec08.txt\", to submit requests \nto that resource.  As part of this operation, the server added the \nbinding \"spec08.txt\" to collection /~whitehead/dav/.\n\n4.2.7 Example: BIND Conflict\n\n>> Request:\n\nBIND /press/prlogo.gif HTTP/1.1\nHost: www.softcorp.com\nDestination: http://www.softcorp.com/logos/\n\n>> Response: \n\nHTTP/1.1 409 Conflict\n\nThe client requested the server to create a binding between \"prlogo.gif\" \nand the resource identified by the URL \"http://www.softcorp.com/logos/\".  \nSince the Destination does end in a slash, while the Request-URI does \nnot, the server failed the request, returning a 409 (Conflict) status \ncode.\n\n4.2.8 DELETE and Bindings\n\nThe DELETE method requests that the server remove the binding between \nthe resource identified by the Request-URI and the binding name, the \nlast path segment of the Request-URI. The binding MUST be removed from \nits parent collection, identified by the Request-URI minus its trailing \nslash (if present) and final segment. The All-Bindings header may be \nused with DELETE to request that the server remove all bindings to the \nresource identified by the Request-URI.  \n\nOnce all bindings to the resource are removed, the server MAY reclaim \nsystem resources associated with the resource. If DELETE removes a \nbinding to a resource, but there remain other bindings to that resource, \nthe server MUST NOT reclaim system resources associated with the \nresource.\n\nSince DELETE as specified in [WebDAV] is not an atomic operation, it may \nhappen that parts of the hierarchy under the request-URI cannot be \ndeleted.  In this case, the response is as described in [WebDAV].\n\n[HTTP] states that \"the DELETE method requests that the origin server \ndelete the resource identified by the Request-URI.\"  Because [HTTP] did \n\nSlein et al.                                                    Page 12\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nnot distinguish between bindings and resources, the intent of its \ndefinition of DELETE is unclear.  We consider the definition presented \nhere to be a clarification of the definition in [HTTP].\n\nSection 8.6.1 of [WebDAV] states that during DELETE processing, a server \n\"MUST remove any URI for the resource identified by the Request-URI from \ncollections which contain it as a member.\"  Servers that support \nbindings SHOULD NOT follow this requirement.\n\n4.2.9 COPY and Bindings\n\nAs defined in Section 8.8 of [WebDAV], COPY causes the resource \nidentified by the Request-URI to be duplicated, and makes the new \nresource accessible using the URI specified in the Destination header.  \nUpon successful completion of a COPY, a new binding is created between \nthe last path segment of the Destination header (including trailing \"/\", \nif present), and the destination resource. The new binding is added to \nits parent collection, identified by the Destination header minus its \ntrailing slash (if present) and final segment.\n\nA COPY with \"Depth: 0\" MUST NOT duplicate the bindings contained by the \ncollection.\n\nAs an example, suppose that a COPY is issued to URI 3 for resource R \nbelow (which is also mapped to URI 1 and URI 2), with the Destination \nheader set to URIX.  After successful completion of the COPY operation, \nresource R is duplicated to create resource R', and a new binding has \nbeen created which creates at least the URI mapping between URIX and the \nnew resource (although other URI mappings may also have been created).\n\n URI 1   URI 2    URI 3                             URIX\n   |       |        |                                |\n   |       |        |    <---- URI Mappings ---->    |\n   |       |        |                                |\n+---------------------+                   +------------------------+\n|     Resource R      |                   |     Resource R\u2019        |\n+---------------------+                   +------------------------+\n\n4.2.10 MOVE and Bindings\n\nThe MOVE method has the effect of creating a new binding to a resource \n(at the Destination), and removing an existing binding (at the Request-\nURI). The name of the new binding is the last path segment of the \nDestination header, and the new binding is added to its parent \ncollection, identified by the Destination header minus its trailing \nslash (if present) and final segment.  \n\nAs an example, suppose that a MOVE is issued to URI 3 for resource R \nbelow (which is also mapped to URI 1 and URI 2), with the Destination \nheader set to URIX.  After successful completion of the MOVE operation, \na new binding has been created which creates at least the URI mapping \nbetween URIX and resource R (although other URI mappings may also have \nbeen created).  The binding corresponding to the final segment of URI 3 \nhas been removed, which also causes the URI mapping between URI 3 and R \nto be removed.\n\nSlein et al.                                                    Page 13\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\n>> Before Request:\n\n URI 1   URI 2    URI 3\n   |       |        |                                \n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+                   \n|     Resource R      |\n+---------------------+                   \n\n>> After Request:\n\n URI 1   URI 2    URIX\n   |       |        |                                \n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+                   \n|     Resource R      |\n+---------------------+                   \n\nSince MOVE as specified in [WebDAV] is not an atomic operation, it may \nhappen that parts of the hierarchy under the request-URI can be moved.  \nIn this case, the response is as described in [WebDAV].\n\n4.2.10.1 Implementation Note \n\nIn some situations, particularly when the destination is on a different \nserver from the original resource, the server may implement MOVE by \nperforming a COPY, performing some consistency maintenance on bindings \nand properties, and then performing a DELETE. In the end, all of the \noriginal bindings except the one corresponding to the Request-URI will \nbe associated with the new resource. The binding corresponding to the \nURI in the Destination header will be associated with the new resource. \nAnd the original resource together with the binding corresponding to the \nRequest-URI will have been deleted. This implementation is in accord \nwith the definition of MOVE in [WebDAV], and is logically equivalent to \nthe definition given above.\n\nThe consistency maintenance processing that is required for this \nimplementation is as follows:\n\nThe DAV:creationdate property of the new resource SHOULD have the same \nvalue as the DAV:creationdate property of the old resource.\n\nThe DAV:getlastmodified property of the new resource SHOULD have the \nsame value as the DAV:getlastmodified property of the old resource.\n\nAll URIs that were bound to the original resource except for the \nRequest-URI MUST be bound instead to the new resource.\n\nConsider again the case where a MOVE is issued to URI 3 for resource R \n(which is also mapped to URI 1 and URI 2), with the Destination header \nset to URIX.  Unlike the previous example, in this implementation, after \nsuccessful completion of the MOVE operation, resource R has been \n\nSlein et al.                                                    Page 14\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nduplicated as resource R'.  The original bindings corresponding to URI 1 \nand URI2 are now associated with R'.  The binding corresponding to the \nRequest-URI (URI 3) has been removed.  And a new binding has been \ncreated which creates at least the URI mapping between URIX and resource \nR'. Note that the server may reclaim the storage associated with \nresource R once the MOVE operation has finished.\n\n>> Before Request:\n\n URI 1   URI 2    URI 3\n   |       |        |                                \n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+                   \n|     Resource R      |\n+---------------------+                   \n\n>> After Request:\n\nURI1     URI2 ---------------------------------    URIX\n  |                                            |     |\n   -----------------------------------------   |     |\n                                            |  |     |\n+---------------------+                   +------------------------+\n|     Resource R      |                   |     Resource R\u2019        |\n+---------------------+                   +------------------------+\n\n4.2.11 LOCK and UNLOCK\n\nBindings do not affect the semantics of locks, as specified in [WebDAV]. \nSpecifically, the requirement in section 8.10.3 that \"a LOCK request on \na resource MUST NOT succeed if it can not be honored by all the URIs \nthrough which the resource is accessible\" still holds.  The LOCK method \nlocks the resource, and a lock is visible via all URIs mapped to that \nresource. Similarly, a successful UNLOCK issued via any URI mapping to a \nresource removes the lock from the resource, and this lock removal is \nvisible via all URI mappings.\n\nWhen a resource is locked, the lock owner expects to be able to access \nthe resource -- using the same Request-URI that he used to lock the \nresource -- for as long as he holds the lock.  This would not be \npossible if another user could move or delete any of the collections \ncorresponding to segments of the request-URI. \n\nConsequently, for the duration of a lock, it MUST NOT be possible for a \nprincipal other than the lock owner to make a locked resource \ninaccessible via the URI mapping used to lock the resource.  Only the \nlock owner can move or delete any of the collections corresponding to \nsegments of the Request-URI. This restriction does not prevent others \nfrom modifying those collections, by adding members to them, removing \nmembers from them, or changing their property values.\n\nFor example, if a user locks /plants/herbs/rosemary.html, it is not \npossible for another user to move /plants/herbs/ to \n/plants/flowering/herbs/, or to completely delete /plants/herbs/, though \n\nSlein et al.                                                    Page 15\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nit is possible this delete operation may succeed in deleting everything \nexcept for /plants/herbs/rosemary.html and /plants/herbs/.\n\n4.2.12 Bindings and Other Methods\n\nThis section describes the interaction of bindings with those HTTP \nmethods not yet explicitly discussed.  The semantics of the methods GET, \nHEAD, PUT, POST and OPTIONS are specified in [HTTP].  The semantics of \nPROPFIND, PROPPATCH, and MKCOL are specified in [WebDAV].\n\nFor most of these methods, no new complexities are introduced by \nallowing explicit creation of multiple bindings to the same resource.  \nFor the access operations (GET, HEAD, OPTIONS, and PROPFIND), it is \nsimply the case that no matter which URI mapping to a given resource is \nused as the Request-URI, the response is mediated by that same resource.  \nThe responses may, however, vary depending upon which Request-URI was \nused.  For example, the response to a GET request may contain the \nRequest-URI in its entity.\n\nThe same is true for POST.  No matter which URI mapping to a given \nresource is used as the Request-URI, the response is mediated by that \nsame resource.  The changes made on the server and the responses may, \nhowever, vary depending upon which Request-URI was used.\n\nIf the Request-URI of a PUT identifies an existing resource, then a PUT \nvia one URI mapping to this resource MUST produce the same result as a \nPUT with the same headers and request entity body via any other URI \nmapping to the same resource. The change made by a PUT via one URI \nmapping MUST affect the resource that generates the GET response for all \nURI mappings to the same resource.\n\nA PROPPATCH through one URI mapping to a resource MUST produce the same \nchanges to its properties as the same PROPPATCH request through a \ndifferent URI mapping to the same resource. \n\nAs specified in [WebDAV], MKCOL cannot overwrite an existing resource. \nMKCOL through any URI mapping to an existing resource must fail. \n\nThe semantics of MKREF are specified in Section 4.5.1 below.  A MKREF \nthrough one URI mapping to a resource MUST produce the same result as a \nMKREF with the same headers through any other URI mapping to the same \nresource.  By default, it overwrites the resource with a new redirect \nreference.\n\nThe semantics of ORDERPATCH are specified in 5.5.1 below.  An ORDERPATCH \nthrough one URI mapping to a collection MUST produce the same changes to \nits ordering as the same ORDERPATCH request through any other URI \nmapping to the same collection. \n\n4.2.13 Discovering the Bindings to a Resource\n\nAn OPTIONAL DAV:bindings property on a resource provides a list of the \nbindings that associate URI segments with that resource. By retrieving \nthis property, a client can discover the bindings that point to the \nresource and the collections that contain bindings to the resource.  As \n\nSlein et al.                                                    Page 16\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nfor all DAV: properties, this specification is silent as to how the \nDAV:bindings property is implemented on the server.\n\nRationale: A number of scenarios require clients to navigate from a \nresource to the bindings that point to it, and to the collections that \ncontain those bindings.  This capability is particularly important for \nDocument Management Systems.  Their clients may need to determine, for \nany object in the DMS, what collections contain bindings to that object.  \nThis information can be used for upward navigation through a hierarchy \nor to discover related documents in other collections.\n\nRisks: When deciding whether to support the DAV:bindings property, \nserver implementers / administrators should balance the benefits it \nprovides against the cost of maintaining the property and the security \nrisks enumerated in Sections 12.5 and 12.6.\n\n4.3 Redirect References\n\nFor most operations submitted to a redirect reference, the response is a \n302 (Moved Temporarily), accompanied by the Resource-Type header \n(defined in Section 6.2 below) set to \"DAV:redirectref\" and the Location \nheader set to the URI of the target resource.  With this information, \nthe client can resubmit the request to the URI of the target resource.  \nThe methods COPY (for collections containing redirect references), \nDELETE, MOVE, and LOCK, for reasons that will be explained, are \nexceptions to this general behavior. These exceptional operations are \napplied to the reference itself and do not result in a 302 response.\n\nIf the client is aware that it is operating on a redirect reference, it \ncan resolve the reference by retrieving the reference's DAV:reftarget \nproperty (defined in Section 7.1 below), whose value is the URI of the \ntarget resource.  It can then submit requests to the target resource. \n\nA redirect reference is a new type of resource. To distinguish redirect \nreferences from ordinary resources, a new value of the DAV:resourcetype \nproperty (defined in [WebDAV]), DAV:redirectref, is defined in Section \n8.1 below.\n\nSince a redirect reference is a resource, it is possible to apply \nmethods to the reference rather than to its target.  The Passthrough \nrequest header (defined in Section 6.4 below) is provided so that \nreferencing-aware clients can control whether an operation is applied to \nthe redirect reference or to its target resource.  The Passthrough \nheader can be used with most requests to redirect references.  This \nheader is particularly useful with PROPFIND, to retrieve the reference's \nown properties.\n\n4.3.1 MKREF Method\n\nThe MKREF method creates a redirect reference resource identified by the \nRequest-URI, whose target is identified by the REQUIRED Ref-Target \nheader. MKREF sets the value of the REQUIRED DAV:reftarget property to \nthe value of the Ref-Target header.\n\nThe MKREF method creates a new binding between the new redirect \n\nSlein et al.                                                    Page 17\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nreference resource and the last path segment of the Request-URI.  The \nnew binding is added to its parent collection, identified by the \nRequest-URI minus its trailing slash (if present) and final segment.\n\nThe Position request header (defined in Section 6.6) MAY be used in \nMKREF requests.\n\nMKREF requests MAY include an entity body.  This specification does not \ndefine the action to be taken if a request entity body is present, but \nallows it for extensibility. \n\nBy default, if the Request-URI of the MKREF request identifies an \nexisting resource, the server MUST perform a delete operation on the \nexisting resource before performing the MKREF. This default behavior can \nbe overridden using the Overwrite header defined in Section 9.6 of \n[WebDAV].\n\n4.3.1.1 Status Codes\n\n201 (Created): The redirect reference resource was successfully created.\n\n400 (Bad Request): The client set an invalid value for the Ref-Target or \nPosition header.\n\n409 (Conflict): Several conditions may produce this response.  There may \nbe no resource at the location specified in Ref-Target, on a server that \nprohibits dangling references.  The request may be attempting to create \nthe reference in a collection that does not exist.  The request may be \nattempting to position the reference before or after a resource that is \nnot in the collection, or before or after itself.  The request may be \nattempting to position the reference in an unordered collection.\n\n412 (Precondition Failed): The Overwrite header is \"F\", and a resource \nalready exists at the request-URI.  \n\n4.3.1.2 Example: MKREF\n\n>> Request:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHost: www.ics.uci.edu\nRef-Target: /i-d/draft-webdav-protocol-08.txt\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new redirect reference at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header. In this example, the target \nresource of the referential resource is identified by the URI \nhttp://www.ics.uci.edu/~whitehead/dav/i-d/draft-webdav-protocol-08.txt. \nThe referential resource's DAV:resourcetype property is set to \nDAV:redirectref.  Its DAV:reftarget property is set to the value of the \nRef-Target header, \"/i-d/draft-webdav-protocol-08.txt\".\n\nSlein et al.                                                    Page 18\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\n4.3.2 Listing the Redirect References in a Collection\n\nA URI of a redirect reference can be an internal member URI of a \ncollection just as the URI of an ordinary resource can.  A listing of \nthe internal member URIs of a collection shows all of the URIs that are \ninternal members of the collection, whether they identify redirect \nreferences or ordinary resources.  That is, a WebDAV PROPFIND request on \na collection resource with the Depth header set to 1 or infinity MUST \nreturn a response XML element for each member URI in the collection, \nwhether it identifies an ordinary resource or a redirect reference.\n\nFor each redirect reference, the response element MUST contain a 302 \n(Moved Temporarily) status code unless a Passthrough header with the \nvalue \"F\" is included with the PROPFIND request.  The DAV:location and \nDAV:resourcetype properties MUST be included with the 302 status code, \nextending the syntax of the DAV:response element that was defined in \n[WebDAV] as described in Section 9 below.  A referencing-aware client \ncan tell from the DAV:resourcetype property that the collection contains \na redirect reference.  The DAV:location property contains the absolute \nURI of the target resource.  A referencing-aware client can either use \nthe URI value of the DAV:location property to retrieve the properties of \nthe target resource, or it can submit a PROPFIND to the redirect \nreference with \"Passthrough: F\" to retrieve its properties.  It is \nrecommended that future editors of [WebDAV] define the DAV:location \nproperty in [WebDAV], so that non-referencing clients will also be able \nto use the response to retrieve the properties of the target resource.\n\nIf the Depth header is set to infinity in the PROPFIND request, the \nserver MUST NOT follow redirect references into any collections to which \nthey may refer.\n\nThe Passthrough header (defined in Section 6.4) MAY be used with a \nPROPFIND request on a collection. \n\n4.3.2.1 Example: PROPFIND on a Collection with Redirect References\n\nSuppose a PROPFIND request with Depth = infinity is submitted to the \nfollowing collection, with the members shown here:\n\nhttp://www.svr.com/MyCollection/\n   (ordinary resource) diary.html\n   (redirect reference) nunavut\n\n>> Request:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV: \">\n   <D:prop xmlns:J=\"http://www.svr.com/jsprops/\">\n\nSlein et al.                                                    Page 19\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n      <D:resourcetype/>\n      <J:keywords/>\n   </D:prop>\n</D:propfind>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\"\n               xmlns:J=\"http://www.svr.com/jsprops/\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n            <J:keywords>diary, interests, hobbies</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n            <J:keywords>diary, travel, family, history</J:keywords>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location> \n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:resourcetype><D:redirectref/></D:resourcetype>\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nIn this example the Depth header is set to infinity, and the Passthrough \nheader is not used.  The collection contains one URI that identifies a \nredirect reference.  The response element for the redirect reference has \na status of 302 (Moved Temporarily), and includes a DAV:prop element \nwith the DAV:location and DAV:resourcetype properties to allow clients \nto retrieve the properties of its target resource.  (The response \nelement for the redirect reference does not include the requested \nproperties.  The client can submit another PROPFIND request to the URI \nin the DAV:location property to retrieve those properties.) \n\nSlein et al.                                                    Page 20\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\n4.3.2.2 Example: PROPFIND with Passthrough: F on a Collection with \nRedirect References\n\nSuppose a PROPFIND request with Passthrough = F and Depth = infinity is \nsubmitted to the following collection, with the members shown here:\n\n/MyCollection/\n   (ordinary resource) diary.html\n   (redirect reference) nunavut\n\n>> Request:\n\nPROPFIND /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDepth: infinity\nPassthrough: F\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxxx\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n<D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype/>\n         </D:prop>\n\nSlein et al.                                                    Page 21\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n      <D:propstat>\n         <D:prop> <D:reftarget/> </D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:redirectref/></D:resourcetype>\n            <D:reftarget>\n               <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n            </D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nSince the Passthrough header has the value \"F\", the response shows the \nproperties of the redirect reference in the collection rather than the \nproperties of its target. The value of the Passthrough header also \nprevents a 302 response from being returned for the redirect reference.\n\n4.3.3 Copying Redirect References\n\nA client's intent in performing a COPY operation is to create a new \nresource that is similar to the original resource and behaves like the \noriginal resource, and that can be modified without affecting the \noriginal resource.  For a COPY request to a redirect reference, the \nexpectation would be a 302 response that the client could use to copy \nthe target resource.  This would yield an independent resource that \ncould be modified without affecting the original resource.  For COPY \nrequests to collections that contain redirect references, the situation \nis less clear.  There is tension between two expectations. On the one \nhand, the client may expect the new copy of the collection to behave \nlike the old one (which implies having references where the old one had \nreferences).  On the other hand, the client may expect that it will be \npossible to modify the resources in the new collection without affecting \nthe resources in the old collection (which implies having copies of the \ntargets where the original collection had references).\n\nFor a COPY request on an individual reference, the response MUST be a \n302 (Moved Temporarily) status code, with the URI of the target resource \nin the Location header, and \"Resource-Type: DAV:redirectref\" to \ndistinguish the response from an ordinary HTTP redirect.  This is the \nnormal behavior for redirect references, allowing the client to resubmit \nthe request to the target resource identified in the Location header.  \nThis also yields intuitively correct behavior for a COPY request to an \nindividual reference.  Reference-aware clients can use the Passthrough \nheader with the value \"F\" to copy the redirect reference itself.\n\nFor COPY on a collection containing redirect references, different \n\nSlein et al.                                                    Page 22\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nsemantics may be desirable in different scenarios.  Consequently, this \nspecification makes a fairly arbitrary choice to take the simplest path.  \nWhen a COPY request is submitted to a collection containing redirect \nreferences, the server MUST copy the redirect references to the new \ncollection rather than returning 302 status codes for them.  This will \nresult in a new collection that behaves like the old one, and avoids \nresponding with multiple 302 status codes, each of which the client \nwould have to process separately.  Reference-aware clients can force the \nserver to respond with 302 status codes rather than copying the \nreferences by using the Passthrough header with the value \"T\".\n\n4.3.3.1 Example: COPY on a Redirect Reference\n\n>> Request:\n\nCOPY /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/tuva.html\n\n>> Response:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Asia/History/tuva.html\nResource-Type: DAV:redirectref\n\nIn this example, the request-URI identifies a redirect reference whose \ntarget resource is identified by \nhttp://www.svr.com/Asia/History/tuva.html.  In this case, the server \nresponded with a 302, and provided the URL of the target resource in the \nLocation header.  The Resource-Type header indicates to a reference-\naware client that this is not an HTTP 1.1 redirect, but a reference to \nthe resource identified by the Location header.  The client can now \nresubmit the COPY request to the target resource, producing the desired \nresult: a duplicate of the original target resource that can be modified \nindependently of the original.\n\n4.3.3.2 Example: COPY on a Collection That Contains a Redirect Reference\n\nSuppose a COPY request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n     (ordinary resource) diary.html\n     (redirect reference) nunavut with target /Someplace/nunavut.map\n\n>> Request:\n\nCOPY /MyCollection/ HTTP/1.1\nHost: www.svr.com\nDestination: http://www.svr.com/OtherCollection/\n\n>> Response:\n\nHTTP/1.1 201 Created\n\n\nSlein et al.                                                    Page 23\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nIn this case, since /MyCollection/nunavut is a redirect reference, the \nreference itself, and not its target, was copied into the new \ncollection.  So the resulting collection is as follows:\n\n/OtherCollection/\n      (ordinary resource) diary.html\n      (redirect reference) nunavut with target /Someplace/nunavut.map\n\n4.3.4 Deleting and Moving Redirect References\n\nThe DELETE method is used to delete bindings to redirect references. \nDELETE MUST affect bindings to the reference itself, unless \n\"Passthrough: T\" is used, in which case it generates a 302 (Moved \nTemporarily) response.  Similarly, when a DELETE on a collection \nencounters a redirect reference in the subtree under that collection, it \nMUST delete bindings to the reference, unless \"Passthrough: T\" is used, \nin which case it generates a 302 (Moved Temporarily) response. Whether \ndeleting an individual resource or a collection, DELETE on a redirect \nreference does not affect the target of the reference.\n\nA MOVE operation on a redirect reference MUST move the reference to a \ndifferent location, and MUST NOT change the location of its target, \nunless \"Passthrough: T\" is used, in which case a 302 (Moved Temporarily) \nresponse is generated. The DAV:reftarget property is unchanged after a \nMOVE.  Similarly, when a MOVE on a collection encounters a redirect \nreference in the subtree under that collection, it MUST move the \nreference, and not its target, unless \"Passthrough: T\" is used, in which \ncase a 302 (Moved Temporarily) response is generated.\n\nDELETE and MOVE differ from other methods in that they do not alter the \nresource that is being deleted or moved, but rather the collection that \ncontains its binding.  They change the membership of that collection.\n\nWhen a redirect reference is added to a collection, the aim is to make \nit look as if the target resource were a member of that collection.  \nWhen the reference is removed from that collection, the aim is to change \nthe membership of that collection.  Membership of the target in any \nother collections, either internally or by reference, should not be \naffected.  Consequently, DELETE and MOVE do not follow the normal rules \nof behavior for references.  Instead, they are applied by default to the \nreference itself, not to its target, and by default do not result in 302 \nstatus codes.\n\n4.3.5 Locking Redirect References\n\nThe semantics of LOCK described here resulted from balancing a set of \nincompatible considerations:\n\no Ideally, a LOCK on a redirect reference should lock both the \n  reference and its target resource.  The owner of an exclusive write \n  lock, for example, would be surprised if anyone else could modify the \n  content of the target resource while he held the lock.  He would also \n  be surprised if anyone else could delete the reference to it, or \n  replace the reference with one pointing to a different target.\no Non-referencing clients should be able to use redirect references \n\nSlein et al.                                                    Page 24\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n  without encountering surprising results.\no The basic characteristics of redirect references should be honored.  \n  Redirect references should be simple for servers to implement. In \n  particular, a server should never have to resolve a redirect \n  reference.  A server should not have to provide proxy capabilities in \n  order to implement redirect references.\no There should be consistency between the behavior of LOCK on a single \n  redirect reference and the behavior of LOCK on a collection that \n  contains redirect references.\no The behavior of all requests to redirect references should be as \n  consistent as possible. In the absence of a Passthrough header, all \n  methods should return a 302 when sent to a redirect reference.\no LOCK semantics for redirect references should be consistent with the \n  LOCK semantics defined in [WebDAV].\n\nWe have compromised the intuitive locking behavior and support for non-\nreferencing clients in order to preserve various sorts of consistency. \n\n4.3.6 LOCK on Redirect References\n\nThe behavior of LOCK for redirect references was determined by what is \npossible for the case of locking collections that contain redirect \nreferences.  \n\nThe default behavior for any operation on a redirect reference is that a \n302 (Moved Temporarily) response will be returned, unless the \nPassthrough header with a value of \"F\" is used.  However, this policy \nhas unacceptable consequences when locking a collection that contains \nredirect references.  Since [WebDAV] requires LOCK on a collection to be \nan atomic operation, if a 302 response is received for any member of the \ncollection, the entire LOCK must fail.  This would make it impossible to \nlock any collection that contained a redirect reference. \n\nTo avoid this result, a LOCK with Depth > 0 on a collection MUST lock \nany redirect references it encounters, and not return 302 responses for \nthem, unless the Passthrough header with a value of \"T\" is used.  Use of \nthe Passthrough header with a value of \"T\" in a LOCK request on a \ncollection will cause the entire lock to fail if a redirect reference is \nencountered.\n\nThis gives part of the expected default lock behavior without forcing \nthe server to resolve the redirect reference or become a proxy server in \ncases where the target resides on a different server. \n\nThere will be no hint in any response code that there are redirect \nreferences whose targets need to be locked.  The client will most likely \nnot lock any targets until it attempts an operation on the target and \ngets a 302 response.  It is possible that a non-referencing client may \nnever realize that the reference's target has not been locked.  \n\nClearly, a LOCK with Depth = infinity on a collection MUST NOT follow \nany redirect references whose targets are collections into the target \ncollections; it MUST NOT cause any resources in those target collections \nto be locked.\n\n\nSlein et al.                                                    Page 25\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nThe behavior of LOCK for individual redirect references is designed to \nbe consistent with LOCK behavior for collections that contain redirect \nreferences.  By default a LOCK on a redirect reference MUST lock only \nthe reference, not its target, and it MUST NOT return a 302 response.  A \nreference-aware client can use the Passthrough header with a value of \n\"T\" to get a 302 response with the URI of the target resource in the \nLocation header.\n\nUNLOCK behaves as specified in [WebDAV], unlocking all resources \nincluded in the lock identified by the Lock-Token header.\n\n4.3.6.1 Example: LOCK on a Redirect Reference\n\n>> Request:\n\nLOCK /MyCollection/tuva HTTP/1.1\nHost: www.svr.com\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\n>> Response:\n\nHTTP/1.1 200 OK\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:prop xmlns:D=\"DAV:\">\n   <D:lockdiscovery>\n      <D:activelock>\n         <D:lockscope><D:exclusive/></D:lockscope>\n         <D:locktype><D:write/></D:locktype>\n         <D:depth>0</D:depth>\n         <D:owner>\n            <D:href>http://www.svr.com/~jas/contact.html</D:href>\n         </D:owner>\n         <D:locktoken>\n            opaquelocktoken:e71dfae-5dec-22d6-fea5-00a0c91e6be4\n         </D:locktoken>\n      </D:activelock>\n   </D:lockdiscovery>\n</D:prop>\n\nSlein et al.                                                    Page 26\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\nThe request and response look exactly as specified in [WebDAV].  In this \nexample, the request-URI, http://www.svr.com/MyCollection/tuva,  \nidentifies a redirect reference, which was successfully locked.  The \ntarget resource of the redirect reference is not locked.\n\n4.3.6.2 Example: LOCK on a Collection That Contains a Redirect \nReference, with Passthrough: T\n\nSuppose a LOCK request is submitted to the following collection, with \nthe members shown:\n\n/MyCollection/\n     (ordinary resource) diary.html\n     (redirect reference) nunavut\n\n>> Request:\n\nLOCK /MyCollection/ HTTP/1.1\nHost: www.svr.com\nPassthrough: T\nContent-Type: text/xml\nContent-Length: nnnn\nAuthorizaton: Digest username=\"jas\",\n   realm=jas@webdav.sb.aol.com, nonce=\". . . \",\n   uri=\"/MyCollection/tuva\",\n   response=\". . . \", opaque=\". . . \"\n\n<?xml version=\"1.0\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n   <D:lockscope><D:exclusive/></D:lockscope>\n   <D:locktype><D:write/></D:locktype>\n   <D:owner>\n      <D:href>http://www.svr.com/~jas/contact.html</D:href>\n   </D:owner>\n</D:lockinfo>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnnn\n\n<?xml version=\"1.0\" ?>\n<D:multistatus xmlns:D=\"Dav:\">\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/</D:href>\n      <D:propstat>\n         <D:prop><D:lockdiscovery/></D:prop>\n         <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n      </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/diary.html</D:href>\n      <D:status>HTTP/1.1 424 Failed Dependency</D:status>\n\nSlein et al.                                                    Page 27\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n   </D:response>\n   <D:response>\n      <D:href>http://www.svr.com/MyCollection/nunavut</D:href>\n      <D:status>HTTP/1.1 302 Moved Temporarily</D:status>\n      <D:prop>\n         <D:location>\n            <D:href>http://www.inac.gc.ca/art/inuit/</D:href>\n         </D:location>\n         <D:resourcetype><D:redirectref/></D:resourcetype>\n      </D:prop>\n   </D:response>\n</D:multistatus>\n\nThe \"Passthrough: T\" header caused the server to return a 302 response \ncode for the redirect reference in the collection.  Consequently, \nneither the collection nor any of the resources identified by its \ninternal member URIs were locked.  A referencing-aware client can submit \na separate LOCK request to the URI in the DAV:location property returned \nfor the redirect reference, and can resubmit the LOCK request with \n\"Passthrough: F\" to the collection.  At that point both the reference \nand its target will be locked (as well as the collection and all the \nresources identified by its other members).\n\n4.3.7 Other Operations on Redirect References\n\nAlthough non-referencing-aware clients cannot create referential \nresources, they should be able to use the references created by \nreference-aware WebDAV clients.  They should be able to follow any \nreferences to their targets.  To make this possible, a server that \nreceives a GET, HEAD, PUT, POST, OPTIONS, PROPFIND, PROPPATCH, MKCOL, \nMKREF, BIND, or ORDERPATCH request made via a redirect reference MUST \nreturn a 302 (Moved Temporarily) status code. The client and server MUST \nfollow [HTTP] Section 10.3.3 \"302 Moved Temporarily,\" but with these \nadditional rules: \n\no The Location response header MUST contain the absolute target URI of \n  the reference.  \n\no The response MUST include the Resource-Type header.  This header \n  allows reference-aware WebDAV clients to recognize the resource as a \n  reference and understand the reason for the redirection. \n\nA reference-aware WebDAV client can act on this response in one of two \nways.  It can, like a non-referencing client, resubmit the request to \nthe URI in the Location header in order to operate on the target \nresource.  Alternatively, it can resubmit the request to the URI of the \nredirect reference with the Passthrough header set to \"F\" in order to \noperate on the reference itself.  If the Passthrough header is present \nwith a value of \"F\", the request MUST be applied to the reference \nitself, and a 302 response MUST NOT be returned.\n\nIf a reference-aware client knows before submitting its request that the \nrequest-URI identifies a redirect reference, and if the client wants to \napply the method to the reference, it can save the round trip caused by \nthe 302 response by using \"Passthrough: F\" in its initial request to the \n\nSlein et al.                                                    Page 28\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nURI.\n\n\"Passthrough: F\" can be used with GET or HEAD to retrieve the entity \nheaders of a redirect reference.  When \"Passthrough: F\" is used with GET \nor HEAD, the referencing entity headers (Ref-Type and Ref-Target) MUST \nbe returned, along with all HTTP headers that make sense for references \n(at a minimum, Cache-Control, Age, ETag, Expires, and Last-Modified).  \n\n\"Passthrough: F\" can be used with PUT to replace the redirect reference \nwith an ordinary resource.  It can be used with OPTIONS to retrieve the \ncapabilities of a redirect reference.  \n\nClients MUST NOT, however, use \"Passthrough: F\" with POST. Since a \nreference cannot accept another entity as its subordinate, an attempt to \nPOST to a reference with \"Passthrough: F\" will also fail.  If a server \nreceives a POST request with \"Passthrough: F\" on a redirect reference, \nit MUST fail the request with a 400 (Bad Request) status code.\n\nSince MKCOL fails when applied to existing resources, if the client \nattempts to resubmit the request to the target resource, the request \nMUST fail (unless the reference is a dangling reference).  Similarly, if \nthe client attempts to resubmit the request to the reference with \n\"Passthrough: F\", the request MUST fail.\n\nSince ORDERPATCH applies only to collections, an ORDERPATCH request with \na Passthrough header with the value \"F\" on a redirect reference MUST \nfail.\n\n4.3.7.1 Example: GET on a Redirect Reference\n\n>> Request:\n\nGET /bar.html HTTP/1.1\nHost: www.foo.com \n\n>> Response:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Internet/xxspec08.html\nResource-Type: DAV:redirectref\n\nSince /bar.html is a redirect reference and the Passthrough header is \nnot included in the request, the response is a 302 (Moved Temporarily).  \nThe Resource-Type header informs a reference-aware client that this is \nnot an ordinary HTTP 1.1 redirect, but is a redirect reference.  The URI \nof the target resource is provided in the Location header so that the \nclient can resubmit the request to the target resource.\n\n4.3.7.2 Example: PUT on a Redirect Reference with \"Passthrough: F\"\n\n>> Request:\n\nPUT /bar.html HTTP/1.1 \nHost: www.foo.com\nPassthrough: F \n\nSlein et al.                                                    Page 29\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nContent-Type: text/xml; charset=\"utf-8\" \nContent-Length: xxxx\n\n. . . some content . . .\n\n>> Response:\n\nHTTP/1.1 200 OK \n\nAlthough /bar.html is a redirect reference, the presence of the \n\"Passthrough: F\" header prevents a 302 response, and instead causes the \nrequest to be applied to the reference.  The result in this case is that \nthe reference is replaced by an ordinary resource having the content \nsubmitted with the request.\n\n4.3.7.3 Example: PROPPATCH on a Redirect Reference\n\nRequest:\n\nPROPPATCH /bar.html HTTP/1.1 \nHost: www.foo.com \nContent-Type: text/xml; charset=\"utf-8\" \nContent-Length: xxxx \n\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:propertyupdate xmlns:D=\"DAV:\"\n   xmlns:Z=\"http://www.w3.com/standards/z39.50/\">\n     <D:set>\n          <D:prop>\n               <Z:authors>\n                    <Z:Author>Jim Whitehead</Z:Author>\n                    <Z:Author>Roy Fielding</Z:Author>\n               </Z:authors>\n          </D:prop>\n     </D:set>\n     <D:remove>\n          <D:prop><Z:Copyright-Owner/></D:prop>\n     </D:remove>\n   </D:propertyupdate>\n\nResponse:\n\nHTTP/1.1 302 Moved Temporarily\nLocation: http://www.svr.com/Internet/xxspec08.html\nResource-Type: DAV:redirectref\n\nSince /bar.html is a redirect reference and the Passthrough header is \nnot included in the request, the response is a 302 (Moved Temporarily).  \nThe Resource-Type header informs a reference-aware client that this is \nnot an ordinary HTTP 1.1 redirect, but is a redirect reference.  The URI \nof the target resource is provided in the Location header so that the \nclient can resubmit the request to the target resource.\n\n4.3.8 Operations on Targets of Redirect References\n\n\nSlein et al.                                                    Page 30\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nOperations on targets of redirect references have no effect on the \nreference. \n\n4.3.9 Relative URIs in Ref-Target and DAV:reftarget\n\nThe URI in a Ref-Target header MAY be a relative URI.  Similarly, the \nhref in a DAV:reftarget property MAY be a relative URI.  In both cases, \nthe base URI to be used for resolving the relative URI to absolute form \nis the URI used in the HTTP message to identify the redirect reference \nto which the Ref-Target entity header or DAV:reftarget property belongs.  \n\nIn the case of a Ref-Target header, the base URI is constructed as \nfollows: Its scheme component is \"http\", its authority component is the \nvalue of the Host header in the request, and its path component is the \nrequest-URI in the request.  See Section 5 of [URI] for a discussion of \nrelative URI references and how to resolve them.\n\nThe DAV:reftarget property appears in the protocol in the context of a \nMulti-Status response, in a DAV:response element that contains a single \nDAV:href element.  The value of this DAV:href element serves as the base \nURI for resolving a relative URI in DAV:reftarget.  The value of \nDAV:href may itself be relative, in which case it must be resolved first \nin order to serve as the base URI for the relative URI in DAV:reftarget.  \nIf the DAV:href element is relative, its base URI is constructed from \nthe scheme component \"http\", the value of the Host header in the \nrequest, and the request-URI.\n\n4.3.9.1 Example: Resolving a Relative URI in Ref-Target\n\n>> Request:\n\nMKREF /north/inuvik HTTP/1.1\nHost: www.somehost.edu\nRef-Target: mapcollection/inuvik.gif\n\n>> Response:\n\nHTTP/1.1 201 Created\n\nIn this example, the base URI is http://www.somehost.edu/north/inuvik.  \nThen, following the rules in [URI] Section 5, the relative URI in Ref-\nTarget resolves to the absolute URI \nhttp://www.somehost.edu/north/mapcollection/inuvik.gif. \n\n4.3.9.2 Example: Resolving a Relative URI in DAV:reftarget\n\n>> Request:\n\nPROPFIND /geog/ HTTP/1.1\nHost: www.xxsvr.com\nPassthrough: F\nDepth: 1\nContent-Type: text/xml\nContent-Length: nnn\n\n\nSlein et al.                                                    Page 31\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n<?xml version=\"1.0\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop>\n      <D:resourcetype/>\n      <D:reftarget/>\n   </D:prop>\n</D:propfind>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: nnn\n\n<?xml version=\"1/0\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>/geog/</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:collection/></D:resourcetype>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n     </D:propstat>\n     <D:propstat>\n         <D:prop><D:reftarget/></D:prop>\n         <D:status>HTTP/1.1 404 Not Found</D:status>\n     </D:propstat>\n   </D:response>\n   <D:response>\n      <D:href>/geog/stats.html</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:resourcetype><D:redirectref/></D:resourcetype>\n            <D:reftarget>statistics/population/1997.html</D:reftarget>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n</D:multistatus>\n\nIn this example, the relative URI statistics/population/1997.html is \nreturned as the value of reftarget for the reference identified by href \n/geog/stats.html.  The href is itself a relative URI, which resolves to \nhttp://www.xxsrv.com/geog/stats.html.  This is the base URI for \nresolving the relative URI in reftarget.  The absolute URI of reftarget \nis http://www.xxsrv.com/geog/statistics/population/1997.html.\n\n4.3.10 Redirect References to Collections\n\nIn a Request-URI /segment1/segment2/segment3, any of the three segments \nmay identify a redirect reference.  (See [URI], Section 3.3, for \ndefinitions of \"path\" and \"segment\".)  If any segment in a Request-URI \nidentifies a redirect reference, the response is a 302.  The value of \nthe Location header in the 302 response is as follows: \n\nSlein et al.                                                    Page 32\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\nThe leftmost path segment of the request-URI that identifies a redirect \nreference, together with all path segments and separators to the left of \nit, is replaced by the value of the redirect reference's\nDAV:reftarget property (resolved to an absolute URI).  The remainder of \nthe request-URI is concatenated to this path.  \n\nNote: If the DAV:reftarget property ends with a \"/\" and the remainder of \nthe Request-URI is non-empty (and therefore must begin with a \"/\"), the \nfinal \"/\" in the DAV:reftarget property is dropped before the remainder \nof the Request-URI is appended.\n\nConsider Request-URI /x/y/z.html.  Suppose that /x/ is a redirect \nreference whose target is collection /a/, which contains redirect \nreference y whose target is collection /b/, which contains redirect \nreference z.html whose target is /c/d.html.\n\n/x/ -----> /a/\n           /a/y/ -----> /b/\n                        /b/z.html -----> /c/d.html\n\nIn this case the client must follow up three separate 302 responses \nbefore finally reaching the target resource.  The server responds to the \ninitial request with a 302 with Location: /a/y/z.html, and the client \nresubmits the request to /a/y/z.html.  The server responds to this \nrequest with a 302 with Location: /b/z.html, and the client resubmits \nthe request to /b/z.html.  The server responds to this request with a \n302 with Location: /c/d.html, and the client resubmits the request to \n/c/d.html.  This final request succeeds.\n\n5 Ordered Collections\n\n5.1 Overview\n\nCollections on a compliant server may be ordered, but need not be.  It \nis up to the client to decide whether a given collection is ordered and, \nif so, to specify the semantics to be used for ordering its bindings.  \nIf a collection is ordered, each of its bindings, and hence internal \nmember URIs, MUST be in the ordering exactly once, and the ordering MUST \nNOT include any binding that is not contained by the collection.  Only \none ordering can be attached to any collection. An ordering is \nconsidered to be part of the state of a collection resource, and hence \nis the same across all URI mappings to the collection.  Multiple \norderings of the same resources can be achieved by creating multiple \ncollections referencing those resources, and attaching a different \nordering to each collection.\n\nThe server is responsible for enforcing these constraints on orderings.  \nThe server MUST remove a binding (and its derived internal member URI) \nfrom the ordering when it is removed from the collection. The server \nMUST add a binding (and its derived internal member URI) to the ordering \nwhen it is added to the collection.\n\nWhen responding to a PROPFIND on a collection, the server MUST order the \nresponse elements according to the ordering defined on the collection. \n\nSlein et al.                                                    Page 33\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nIf the collection is unordered, the client cannot depend on the \nrepeatability of the ordering of results from a PROPFIND request.\n\nOrderings may be client-maintained or server-maintained.  This protocol \nprovides support for both types of orderings.\n\n5.2 Creating an Ordered Collection\n\n5.2.1 Overview \n\nWhen a collection is created, the client MAY request that it be ordered \nand specify the semantics of the ordering by using the new Ordered \nheader (defined in Section 6.5) with a MKCOL request.   \n\nFor collections that are ordered, the client SHOULD identify the \nsemantics of the ordering with a URI in the Ordered header.  This URI \nmay identify a server-maintained ordering.  Clients can discover the \navailable server-maintained orderings using the mechanism defined in \nSection 11.3.  The URI may identify a semantics for a client-maintained \nordering, providing the information a human user or software package \nneeds to insert new collection members into the ordering intelligently.  \nAlthough the URI in the Ordered header MAY point to a resource that \ncontains a definition of the semantics of the ordering, clients are \ndiscouraged from accessing that resource, in order to avoid \noverburdening its server.  The client MAY set the header value to \nDAV:custom to indicate that the collection is ordered, but the semantics \nof the ordering are not being advertised.  If the client does not want \nthe collection to be ordered, it may omit the Ordered header, or use it \nwith the value DAV:unordered.\n\nIf the server does not recognize the value of the Ordered header as one \nof its server-maintained orderings, it MUST assume that a client-\nmaintained ordering is intended.  If the value of the Ordered header is \none of the server-maintained orderings that the server supports, it MUST \nmaintain the collection's ordering according to that ordering semantics \nas new members are added.\n\nEvery collection MUST have a DAV:orderingtype property (defined in \nSection 7.5), which indicates whether the collection is ordered and, if \nso, identifies the semantics of the ordering.  The server sets the \ninitial value of this property based on the value of the Ordering header \nin the MKCOL request. If the collection is unordered, the \nDAV:orderingtype property MUST have the value DAV:unordered. An \nordering-aware client interacting with an ordering-unaware server (e.g., \none that is implemented only according to [WebDAV]) SHOULD assume that \nif a collection does not have the DAV:orderingtype property, the \ncollection is unordered.\n\n5.2.2 Example: Creating an Ordered Collection\n\n>>Request:\n\nMKCOL /theNorth/ HTTP/1.1\nHost: www.server.org\nOrdered: http://www.server.org/orderings/compass.html\n\nSlein et al.                                                    Page 34\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\n>>Response:\n\nHTTP/1.1 201 Created\n\nIn this example a new, ordered collection was created.  Its \nDAV:orderingtype property has as its value the URI from the Ordered \nheader, http://www.server.org/orderings/compass.html.  In this case, the \nURI identifies the semantics governing a client-maintained ordering.  As \nnew members are added to the collection, clients or end users can use \nthe semantics to determine where to position the new members in the \nordering. \n\n5.3 Setting the Position of a Collection Member\n\n5.3.1 Overview\n\nWhen a new member is added to a collection with a client-maintained \nordering (for example, with PUT, MKREF, or MKCOL), its position in the \nordering can be set with the new Position header (defined in Section \n6.6).  The Position header allows the client to specify that the member \nshould be first in the collection's ordering, last in the collection's \nordering, immediately before some other binding in the collection's \nordering, or immediately after some other binding in the collection's \nordering.\n\n5.3.2 Status Codes\n\n409 (Conflict): The request specifies a position that is before or after \na URI that is not an internal member URI of the collection, or before or \nafter itself.\n\n425 (Unordered Collection): The request specifies a collection position \nin an unordered collection or in a collection with a server-maintained \nordering.\n\n5.3.3 Examples: Setting the Position of a Collection Member\n\n>>Request:\n\nMKREF /~whitehead/dav/spec08.ref HTTP/1.1\nHOST: www.ics.uci.edu\nRef-Target: http://www.ics.uci.edu/i-d/draft-webdav-protocol-08.txt\nPosition: After <requirements.html>       \n\n>>Response:\n\nHTTP/1.1 201 Created\n\nThis request resulted in the creation of a new referential resource at \nwww.ics.uci.edu/~whitehead/dav/spec08.ref, which points to the resource \nidentified by the Ref-Target header.  The Position header in this \nexample caused the server to set its position in the ordering of the \n/~whitehead/dav/ collection immediately after requirements.html.\n\n\nSlein et al.                                                    Page 35\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n>>Request:\n\nMOVE /i-d/draft-webdav-protocol-08.txt HTTP/1.1\nHost: www.ics.uci.edu\nDestination: http://www.ics.uci.edu/~whitehead/dav/draft-webdav-\n     protocol-08.txt\nPosition: First\n\n>>Response:\n\nHTTP/1.1 425 Unordered Collection\n\nIn this case, the server returned a 425 (Unordered Collection) status \ncode because the /~whitehead/dav/ collection is an unordered collection.  \nConsequently, the server was unable to satisfy the Position header.\n\n5.4 Changing the Semantics of a Collection Ordering\n\nAfter a collection has been created, a client can change its ordering \nsemantics, or change an ordered collection to an unordered collection or \nvice versa, by using PROPPATCH to change the value of its \nDAV:orderingtype property (defined in Section 7.5).  If the new value \nidentifies a client-maintained ordering, the client is then responsible \nfor updating the collection's ordering according to the new semantics.  \nIf it identifies a server-maintained ordering, the server MUST reorder \nthe collection according to the new semantics.  PROPPATCH is defined in \n[WebDAV], Section 7.2.\n\n5.5 Changing the Position of a Collection Member\n\n5.5.1 ORDERPATCH Method\n\nThe ORDERPATCH method alters the ordering of bindings in the collection \nidentified by the Request-URI, based on instructions in the order XML \nelement. The order XML element identifies the bindings whose positions \nare to be changed, and describes their new positions in the ordering.  \nEach new position can be specified as first in the ordering, last in the \nordering, immediately before some other binding, or immediately after \nsome other binding.  \n\nThe server MUST apply the changes in the order they appear in the order \nXML element.  The server MUST either apply all the changes or apply none \nof them.  If any error occurs during processing, all executed changes \nMUST be undone and a proper error result returned.\n\n5.5.2 Status Codes\n\nSince multiple changes can be requested in a single ORDERPATCH request, \nthe server MUST return a 207 (Multi-Status) response, as defined in \n[WebDAV].\n\nThe following are examples of response codes one would expect to be used \nin a 207 (Multi-Status) response for this method: \n\n200 (OK): The change in ordering was successfully made.\n\nSlein et al.                                                    Page 36\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\n409 (Conflict): The request specifies a position that is before or after \na URI that is not an internal member URI of the collection, or before or \nafter itself.\n\n425 (Unordered Collection): The request specifies a collection position \nin an unordered collection or in a collection with a server-maintained \nordering.\n\nA request to reposition a binding at the same place in the ordering is \nnot an error. \n\n5.5.3 Example: Changing Positions in an Ordered Collection\n\nConsider a collection /coll-1/ with bindings ordered as follows:\n\nnunavut.map\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\nnunavut.desc\niqaluit.img\niqaluit.desc\n\n>> Request:\n\nORDERPATCH /coll-1/ HTTP/1.1\nHost: www.nunanet.com\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:order xmlns:d=\"DAV:\">\n   <d:ordermember>\n      <d:href>nunavut.desc</d:href>\n      <d:position> \n         <d:after>\n            <d:href>nunavut.map</d:href>\n         </d:after>\n      </d:position>\n   </d:ordermember>\n   <d:ordermember>\n      <d:href>iqaluit.img</d:href>\n      <d:position>\n         <d:last/>\n      </d:position>\n   </d:ordermember>\n</d:order>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\n\nSlein et al.                                                    Page 37\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/nunavut.desc</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/iqaluit.img</d:href>\n      <d:status>HTTP/1.1 200 OK</d:status>\n   </d:response>\n</d:multistatus>\n\nIf the href elements are relative URIs, as in this example, they are \ninterpreted relative to the collection that is being reordered.  In this \nexample, after the request has been processed, the collection's ordering \nis as follows:\n\nnunavut.map\nnunavut.desc\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\niqaluit.desc\niqaluit.img\n\n5.5.4 Example: Failure of an ORDERPATCH Request\n\nConsider a collection /coll-1/ with bindings ordered as follows:\n\nnunavut.map\nnunavut.img\nbaffin.map\nbaffin.desc\nbaffin.img\niqaluit.map\nnunavut.desc\niqaluit.img\niqaluit.desc\n\n>> Request:\n\nORDERPATCH /coll-1/ HTTP/1.1\nHost: www.nunanet.com\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:order xmlns:d=\"DAV:\">\n   <d:ordermember>\n      <d:href>nunavut.desc</d:href>\n      <d:position> \n\nSlein et al.                                                    Page 38\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n         <d:after>\n            <d:href>nunavut.map</d:href>\n         </d:after>\n      </d:position>\n   </d:ordermember>\n   <d:ordermember>\n      <d:href>iqaluit.map</d:href>\n      <d:position>\n         <d:after>\n            <d:href>pangnirtung.img</d:href>\n         </d:after>\n      </d:position>\n   </d:ordermember>\n</d:order>\n\n>> Response:\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml\nContent-Length: xxx\n\n<?xml version=\"1.0\" ?>\n<d:multistatus xmlns:d=\"DAV:\">\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/nunavut.desc</d:href>\n      <d:status>HTTP/1.1 424 Failed Dependency</d:status>\n   </d:response>\n   <d:response>\n      <d:href>http://www.nunanet.com/coll-1/iqaluit.map</d:href>\n      <d:status>HTTP/1.1 409 Conflict</d:status>\n      <d:responsedescription>pangnirtung.img is not a collection   \n                member.</d:responsedescription>\n   </d:response>\n</d:multistatus>\n\nIn this example, the client attempted to position iqaluit.map after a \nbinding that is not contained in the collection /coll-1/.  The server \nresponded to this client error with a 409 (Conflict) status code.  \nBecause ORDERPATCH is an atomic method, the request to reposition \nnunavut.desc (which would otherwise have succeeded) failed with a 424 \n(Failed Dependency) status code.\n\n6 Headers\n\n6.1 All-Bindings Request Header\n\nAll-Bindings = \"All-Bindings\" \":\"\n\nThe All-Bindings request header may be used with DELETE requests to \ninstruct the server to remove all bindings to the resource identified by \nthe Request-URI.\n\n6.2 Ref-Target Entity Header\n\nRef-Target = \"Ref-Target\" \":\" (absoluteURI | relativeURI)\n\nSlein et al.                                                    Page 39\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\nThe Ref-Target header is defined primarily for use with MKREF requests \nto identify the target resource of the new redirect reference being \ncreated. \n\n6.3 Resource-Type Entity Header\n\nResource-Type = \"Resource-Type\" \":\" (\"DAV:redirectref\" | \n                                      ext-resource-type)\next-resource-type = coded-URL \n\nThe Resource-Type header is defined primarily for use in 302 responses, \nto allow reference-aware clients to distinguish between HTTP 1.1 \nredirects and 302 responses for redirect references (see Sections 4.1, \nand 4.3.7).  The possible values of this header are DAV:redirectref, and \next-resource-type. The ext-resource-type production is provided for \nextensibility.  \n\n6.4 Passthrough Request Header\n\nPassthrough = \"Passthrough\" \":\" (\"T\" | \"F\")\n\nThe optional Passthrough header can be used on any request to a redirect \nreference.  If the Passthrough header has the value \"F\", the request \nMUST be applied to the reference itself, and a 302 response MUST NOT be \nreturned.  If the Passthrough header has the value \"T\", a 302 response \nMUST be returned, with the URI of the target resource in the Location \nheader and the Resource-Type header with a value \"DAV:redirectref\".  \n\nIf the Passthrough header is used on a request to any other sort of \nresource besides a reference, the server SHOULD ignore it.  If the \nPassthrough header with the value \"F\" appears in a POST or ORDERPATCH \nrequest to a reference, the server MUST respond with a 400 (Bad \nRequest).\n\n6.5 Ordered Entity Header\n\nOrdered = \"Ordered\" \":\" (\"DAV:unordered\" | \"DAV:custom\" | absoluteURI)\n\nThe Ordered header may be used with MKCOL to request that the new \ncollection be ordered and to specify its ordering semantics.  A value of \n\"DAV:unordered\" indicates that the collection is not ordered. A value of \n\"DAV:custom\" indicates that the collection is to be ordered, but the \nsemantics of the ordering is not being advertised.  Any other \nabsoluteURI value indicates that the collection is ordered, and \nidentifies the semantics of the ordering. \n\n6.6 Position Request Header\n\nPosition = \"Position\" \":\" (\"First\" | \"Last\" | \n                           ((\"Before\" | \"After\") Generic-Coded-url))\nGeneric-Coded-url = \"<\" (absoluteURI | relativeURI) \">\"\nabsoluteURI and relativeURI are defined in [URI].\n\nThe Position header may be used with any method that adds a binding to a \n\nSlein et al.                                                    Page 40\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\ncollection with a client-maintained ordering, to tell the server where \nin the collection ordering to position the new binding being added to \nthe collection. \n\nIf the Generic-Coded-url is a relative URL, it is interpreted relative \nto the collection to which the new binding is being added. \n\nThe server MUST insert the new binding into the ordering at the location \nspecified in the Position header, if one is present (and if the \ncollection has a client-maintained ordering). \n\nThe \"First\" keyword indicates the new binding is put in the beginning \nposition in the collection's ordering, while \"Last\" indicates the new \nbinding is put in the final position in the collection's ordering.  The \n\"Before\" keyword indicates the new binding is added to the collection's \nordering immediately prior to the position of the binding identified in \nthe Generic-Coded-url. Likewise, the \"After\" keyword indicates the new \nbinding is added to the collection's ordering immediately following the \nposition of the binding identified in the Generic-Coded-url.\n\nIf the request is replacing an existing resource, and the Position \nheader is present, the server MUST remove the binding from its previous \nposition, and then insert it at the requested position.\n\nIf the Position request header is not used when adding a binding to a \ncollection with a client-maintained ordering, then:\n\no If the request is replacing an existing resource, the server MUST \n  preserve the present ordering.\n\no If the request is adding a new binding to the collection, the server \n  MUST append the new binding to the end of the ordering.\n\nIf an attempt is made to use the Position header on a collection that is \nunordered or that has a server-maintained ordering, the server MUST fail \nthe request with a 409 (Conflict) status code.\n\n7 Status Codes\n\n7.1 506 Loop Detected\n\nThe 506 (Loop Detected) status code indicates that the server detected \nan infinite loop while processing a request with \"Depth: infinity\". \n\n7.2 425 Unordered Collection\n\nThe 425 (Unordered Collection) status code indicates that the client \nattempted to set the position of an internal collection member in an \nunordered collection or in a collection with a server-maintained \nordering.\n\n8 Properties\n\n8.1 reftarget Property\n\n\nSlein et al.                                                    Page 41\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nName:\t    reftarget\nNamespace:  DAV:\nPurpose:    A property of redirect references that provides an efficient \n            way for clients to discover the URI of the target resource.  \n            This is a read-only property, whose value can only be set by \n            using the Ref-Target header with a MKREF request.\nValue: \t    URI of the target resource.  This value MAY be a relative \n            URI.  The reftarget property can occur in the entity bodies \n            of responses to PROPFIND requests.\n\n<!ELEMENT reftarget (#PCDATA)>\n\n8.2 location Property\n\nName:       location\nNamespace:  DAV:\nPurpose:    For use with 302 (Moved Temporarily) response codes in \n            Multi-Status responses.  It contains the absolute URI of the \n            temporary location of the resource.  In the context of \n            redirect references, this value is the absolute URI of the \n            target resource.  It is analogous to the Location header in \n            HTTP 302 responses defined in [HTTP] Section 10.3.3 \"302 \n            Moved Temporarily.\"  Including the location property in a \n            Multi-Status response requires an extension to the syntax of \n            the DAV:response element defined in [WebDAV], which is \n            defined in Section 9 below.  This property is not expected \n            to be stored on the reference. It is modeled as a property \n            only so that it can be returned inside a DAV:prop element in \n            a Multi-Status response.\nValue:      href containing the absolute URI of the target resource.\n\n<!ELEMENT location href >\n\n8.3 bindings Property\n\nName:\t    bindings\nNamespace:  DAV:\nPurpose:    Enables clients to discover, for any resource, what bindings \n            point to it and what collections contain those bindings.  \n            This is an optional property.  If present, it is a read-only \n            property, maintained by the server.\nValue:\t    List of href / segment pairs for all of the bindings that \n            associate URI segments with the resource.  The href is an \n            absolute URI for one URI mapping of the collection \n            containing the binding.  The segment is the URI segment that \n            identifies the binding within that collection. If a binding \n            belongs to a collection that has multiple URI mappings, only \n            one URI mapping for that collection should be reported.\n\n<!ELEMENT bindings ((href, segment)*)>\n\n8.4 orderingtype Property\n\nName:\t    orderingtype\nNamespace:  DAV:\n\nSlein et al.                                                    Page 42\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nPurpose:    Indicates whether the collection is ordered and, if so, \n            uniquely identifies the semantics of the ordering being \n            used.  May also point to an explanation of the semantics in \n            human and / or machine-readable form.  At a minimum, this \n            allows human users who add members to the collection to \n            understand where to position them in the ordering.\nValue:\t    unordered for an unordered collection, or a URI that \n            uniquely identifies the semantics of the collection's \n            ordering.  The value custom indicates that the collection is \n            ordered, but the semantics are not being advertised. \n\n<!ELEMENT orderingtype (unordered | custom | href) >\n\n9 XML Elements\n\n9.1 redirectref XML Element\n\nName: \t    redirectref\nNamespace:  DAV:\nPurpose:    Used as the value of the DAV:resourcetype property to   \n            specify that the resource type is a redirect reference.  \n\n<!ELEMENT redirectref EMPTY >\n\n9.2 segment XML Element\n\nName:\t    segment\nNamespace:  DAV:\nPurpose:    The segment that names a binding, used in the DAV:bindings \n            property.\nValue:\t    segment  ; as defined in section 3.3 of [URI].\n\n<!ELEMENT segment (#PCDATA)>\n\n9.3 unordered XML Element\n\nName:\t    unordered\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is not ordered.  That is, the client cannot \n            depend on the repeatability of the ordering of results from \n            a PROPFIND request.\n\n<!ELEMENT unordered EMPTY >\n\n9.4 custom XML Element\n\nName: \t    custom\nNamespace:  DAV:\nPurpose:    A value of the DAV:orderingtype property that indicates that \n            the collection is ordered, but the semantics of the ordering \n            are not being advertised. \n\n<!ELEMENT custom EMPTY >\n\n\nSlein et al.                                                    Page 43\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n9.5 order XML Element\n        \nName: \t    order\nNamespace:  DAV:\nPurpose:    For use with the new ORDERPATCH method.  Describes a change \n            to be made in a collection ordering.\nValue:      A description of the new positions of the bindings a \n            collection contains in its ordering.\n\n<!ELEMENT order (ordermember+) >\n\n9.6 ordermember XML Element\n \nName: \t    ordermember\nNamespace:  DAV:\nPurpose:    Occurs in the order XML Element, and describes the new \n            position of a single binding in the collection's ordering.\nValue: \t    An href containing a binding's path segment, and a \n            description of its new position in the ordering.  The href \n            XML element is defined in [WebDAV], Section 11.3.\n\n<!ELEMENT ordermember (href, position) >\n\n9.7 position XML Element\n\nName: \t    position\nNamespace:  DAV:\nPurpose:    Occurs in the ordermember XML element.  Describes the new \n            position in a collection's ordering of one of the bindings \n            it contains.\nValue: \t    The new position can be described as first in the \n            collection's ordering, last in the collection's ordering, \n            immediately before some other binding, or immediately after \n            some other binding.\n\n<!ELEMENT position (first | last | before | after)>\n\n9.8 first XML Element\n\nName: \t    first\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Specifies that the \n            binding should be placed first in the collection's ordering.\n\n<!ELEMENT first EMPTY >\n\n9.9 last XML Element\n\nName: \t    last\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Specifies that the \n            binding should be placed last in the collection's ordering.\n\n<!ELEMENT last EMPTY >\n\n\nSlein et al.                                                    Page 44\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n9.10 before XML Element\n\nName: \t    before\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Specifies that the \n            binding should be placed immediately before the binding in \n            the enclosed href XML element in the collection's ordering.\nValue: \t    href of the member it precedes in the ordering\n\n<!ELEMENT before href >\n\n9.11 after XML Element\n\nName: \t    after\nNamespace:  DAV:\nPurpose:    Occurs in the position XML element.  Specifies that the \n            binding should be placed immediately after the binding in \n            the enclosed href XML element in the collection's ordering.\nValue:      href of the member it follows in the ordering\n\n<!ELEMENT after href >\n\n9.12 options XML Element\n\nName:       options\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for more detailed     \n            information about capabilities than can be provided in the  \n            DAV: response header.  Used in OPTIONS responses to provide\n            that information.\nValue:      List of elements identifying or providing the additional \n            information desired.\n\n<!ELEMENT options (orderingoptions | ANY)+ >\n\n9.13 orderingoptions XML Element\n\nName:       orderingoptions\nNamespace:  DAV:\nPurpose:    Used in OPTIONS requests to ask for the list of server-    \n            maintained orderings that can be supported at the request-\n            URI.  Used in OPTIONS responses to provide that information.  \n            These values can be used in the Ordered header or the \n            DAV:orderingtype property to request that a particular  \n            server-maintained ordering be applied to the collection.\nValue:      EMPTY on requests.  On responses, it is the list of server-\n            maintained orderings available for the request-URI.\n\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n\n10 Extensions to the DAV:response XML Element for Multi-Status Responses\n\nAs described in Sections 4.6 and 4.9, the DAV:location property and the \nDAV:reftype property may be returned in the DAV:response element of a \n207 Multi-Status response, to allow clients to resubmit their requests \n\nSlein et al.                                                    Page 45\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nto the target resource of a redirect reference.  \n\nWhenever these properties are included in a Multi-Status response, they \nare placed in a DAV:prop element associated with the href to which they \napply.  This structure provides a framework for future extensions by \nother standards that may need to include additional properties in their \nresponses.\n\nConsequently, the definition of the DAV:response XML element changes to \nthe following:\n\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\n11 Capability Discovery\n\n11.1 Compliance Classes\n\nThis specification defines OPTIONAL extensions to [WebDAV].  Since \nresource sharing and ordering are independent capabilities, a resource \nMAY support either, both, or neither of these capabilities.  A resource \nthat provides resource sharing MUST support both bindings and redirect \nreferences.  A response to an OPTIONS request MUST indicate which of \nthese capabilities the resource supports.\n\nThis specification defines three new methods: BIND and MKREF in support \nof shared resources, and ORDERPATCH in support of ordering.  The \nresponse MUST indicate which of these methods the resource allows.  In \naddition, the response MUST include the DAV header, as described in \nSections 9.1 and 15 of [WebDAV].  Two new compliance classes are defined \nhere for use with the DAV header: sharing and orderedcoll. \n\nWhen responding to an OPTIONS request, only a collection or a null \nresource can include orderedcoll in the value of the DAV header.  By \nincluding orderedcoll, the resource indicates that its bindings can be \nordered.  It implies nothing about whether any collections identified by \nits internal member URIs can be ordered.\n\nWhen responding to an OPTIONS request, any type of resource can include \nsharing in the value of the DAV header.  Including sharing indicates \nthat the server permits a redirect reference or a binding at the request \nURI.\n\n11.2 Example: Discovery of Compliance Classes\n\n>> Request:\n\nOPTIONS /somecollection/ HTTP/1.1\nHOST: somehost.org\n\n>> Response:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\n\nSlein et al.                                                    Page 46\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, ORDERPATCH\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF, ORDERPATCH\nDAV: 1, 2, sharing, orderedcoll\n\nThe DAV header in the response indicates that the resource \n/somecollection/ is level 1 and level 2 compliant, as defined in \n[WebDAV].  In addition, /somecollection/ supports ordering and resource \nsharing.  The Allow header indicates that BIND and ORDERPATCH requests \ncan be submitted to /somecollection/.  Since a redirect reference is not \na collection, a MKREF request with /somecollection/ as its Request-URI \nwould fail, but the Public header shows that other Request-URIs on the \nserver do support MKREF.\n\n11.3 Additional Advanced Collections Capabilities\n\nClients may need detailed information about specific areas of advanced \ncollections functionality.  This information can be requested by sending \nan OPTIONS request with an XML body that includes a DAV:options element.  \nThe DAV:options element contains a list of empty elements identifying \nthe information the client needs.\n\nAs described in Section 5.2, servers may offer a set of server-\nmaintained orderings on collections.  Clients can discover the list of \nserver-maintained orderings available for the request-URI by including \nan empty DAV:orderingoptions element in the DAV:options element.  The \nresponse will include a DAV:orderingoptions element with the list of \nsupported server-maintained orderings.  Servers SHOULD advertise the \nserver-maintained orderings available using this mechanism.\n\n11.4 Example: Discovery of Ordering Options\n\n>> Request:\n\nOPTIONS /somecollection/ HTTP/1.1\nHOST: somehost.org\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:orderingoptions/>\n</D:options>\n\n>> Response:\n\nHTTP/1.1 200 OK\nDate: Tue, 20 Jan 1998 20:52:29 GMT\nConnection: close\nAccept-Ranges: none\nAllow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, ORDERPATCH\nPublic: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE, MKCOL, \nPROPFIND, PROPPATCH, LOCK, UNLOCK, BIND, MKREF, ORDERPATCH\nDAV: 1, sharing, orderedcoll\n\nSlein et al.                                                    Page 47\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\n\n<?xml version=\"1.0\" ?>\n<D:options xmlns:D=\"DAV:\">\n  <D:orderingoptions xmlns:X=\"Xerox:\">\n      <X:author-ascending/>\n      <X:title-ascending/>\n      <X:date-descending/>\n  </D:orderingoptions>\n</D:options>\n\nThis response indicates that the resource /somecollection/ is level 1 \ncompliant, as defined in [WebDAV].  In addition, /somecollection/ \nsupports ordering and resource sharing.  The client also asked for a \nlist of the server-maintained orderings that are supported for \n/somecollection/.  The response indicates that the orderings \nXerox:author-ascending, Xerox:title-ascending, and Xerox:date-descending \nare supported.\n\n12 Security Considerations\n\nThis section is provided to detail issues concerning security \nimplications of which WebDAV applications need to be aware. \n\nAll of the security considerations of HTTP/1.1 and the WebDAV \nDistributed Authoring Protocol specification also apply to WebDAV \ncollections.  In addition, resource sharing and ordered collections \nintroduce several new security concerns and increase the risk of some \nexisting threats.  These issues are detailed below.\n\n12.1 Privacy Concerns\n\nBy creating redirect references on a trusted server, it is possible for \na hostile agent to induce users to send private information to a target \non a different server.   This risk is mitigated somewhat, since clients \nare required to notify the user of the redirection for any request other \nthan GET or HEAD. (See [HTTP], Section 10.3.3 Moved Temporarily.)\n\nThe same risk exists for bindings, although it is less likely that \nservers will support cross-server bindings.\n\n12.2 Redirect Loops\n\nAlthough redirect loops were already possible in HTTP 1.1, the \nintroduction of the BIND and MKREF methods creates a new avenue for \nclients to create loops accidentally or maliciously.  If the binding or \nreference and its target are on the same server, the server may be able \nto detect MKREF and BIND requests that would create loops. See also \n[HTTP], Section 10.3 \"Redirection 3xx.\"  Servers are required to detect \nloops caused by bindings to collections during the processing of any \nrequests with \"Depth: infinity\".\n\n12.3 Redirect References, Bindings, and Denial of Service\n\nDenial of service attacks were already possible by posting URLs that \nwere intended for limited use at heavily used Web sites.  The \n\nSlein et al.                                                    Page 48\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nintroduction of BIND and MKREF creates a new avenue for similar denial \nof service attacks.  Clients can now create bindings and redirect \nreferences at heavily used sites to target locations that were not \ndesigned for heavy usage.\n\n12.4 Private Locations May Be Revealed\n\nThere are several ways that redirect references may reveal information \nabout directory structures.  First, the DAV:reftarget property of every \nredirect reference contains the URI of the target resource.  Anyone who \nhas access to the reference can discover the directory path that leads \nto the target resource.   The owner of the target resource may have \nwanted to limit knowledge of this directory structure.\n\nSufficiently powerful access control mechanisms can control this risk to \nsome extent.  Property-level access control could prevent users from \nexamining the DAV:reftarget property.  (The Ref-Target and Location \nheaders, which are returned in some responses to requests on redirect \nreferences, reveal the same information, however.)  In some \nenvironments, the owner of a resource might be able to use access \ncontrol to prevent others from creating references to that resource.\n\nIn addition, if backpointers are maintained on the target resource, the \nowners of bindings face these same risks.  The directory structures \nwhere bindings are located are revealed to anyone who has access to the \nDAV:bindings property on a target resource.  Moving a binding may reveal \nits new location to anyone with access to DAV:bindings on its target \nresource.\n\n12.5 DAV:bindings and Denial of Service\n\nIf the server maintains the DAV:bindings property in response to \nbindings created in other administrative domains, it is exposed to \nhostile attempts to make it devote resources to adding bindings to the \nlist.\n\n12.6 Denial of Service and DAV:orderingtype\n\nThere may be some risk of denial of service at sites that are advertised \nin the DAV:orderingtype property of collections.  However, it is \nanticipated that widely-deployed applications will use hard-coded values \nfor frequently-used ordering semantics rather than looking up the \nsemantics at the location specified by DAV:orderingtype.  In addition, \nSection 5.2 discourages clients from looking up the semantics at that \nlocation.\n\n13 Internationalization Considerations\n\nThis specification follows the practices of [WebDAV] in encoding all \nhuman-readable content using XML [XML] and in the treatment of names.  \nConsequently, this specification complies with the IETF Character Set \nPolicy [Alvestrand].\n\nWebDAV applications MUST support the character set tagging, character \nset encoding, and the language tagging functionality of the XML \n\nSlein et al.                                                    Page 49\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nspecification.  This constraint ensures that the human-readable content \nof this specification complies with [Alvestrand].\n\nAs in [WebDAV}, names in this specification fall into three categories: \nnames of protocol elements such as methods and headers, names of XML \nelements, and names of properties.  Naming of protocol elements follows \nthe precedent of HTTP, using English names encoded in USASCII for \nmethods and headers.  The names of XML elements used in this \nspecification are English names encoded in UTF-8.\n\nFor error reporting, [WebDAV] follows the convention of HTTP/1.1 status \ncodes, including with each status code a short, English description of \nthe code (e.g., 423 Locked).  Internationalized applications will ignore \nthis message, and display an appropriate message in the user's language \nand character set.\n \nFor rationales for these decisions and advice for application \nimplementors, see [WebDAV].\n\n14 IANA Considerations\n\nThis document uses the namespaces defined by [WebDAV] for properties and \nXML elements.  All other IANA considerations mentioned in [WebDAV] also \napply to this document.\n\n15 Copyright\n\nTo be supplied by the RFC Editor.\n\n16 Intellectual Property\n\nTo be supplied by the RFC Editor.\n\n17 Acknowledgements\n\nThis draft has benefited from thoughtful discussion by Jim Amsden, Steve \nCarter, Ken Coar, Ellis Cohen, Bruce Cragun, Spencer Dawkins, Mark Day, \nRajiv Dulepet, David Durand, Roy Fielding, Yaron Goland, Fred Hitt, Alex \nHopmann, Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit Khare, \nDaniel LaLiberte, Steve Martin, Larry Masinter, Jeff McAffer, Surendra \nKoduru Reddy, Max Rible, Sam Ruby, Bradley Sergeant, Nick Shelness, John \nStracke, John Tigue, John Turner, and others.\n\n18 References\n\n18.1 Normative References\n\n[URI] T. Berners-Lee, R. Fielding, L. Masinter, \"Uniform Resource \nIdentifiers (URI): Generic Syntax.\" RFC 2396. MIT/LCS, U.C. Irvine, \nXerox. August, 1998.\n\n[RFC2119] S. Bradner, \"Key words for use in RFCs to Indicate Requirement \nLevels.\"  RFC 2119, BCP 14.  Harvard University.  March, 1997.\n\n[XML] T. Bray, J. Paoli, C.M. Sperberg-McQueen, \"Extensible Markup \n\nSlein et al.                                                    Page 50\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nLanguage (XML).\"  World Wide Web Consortium Recommendation REC-xml-\n19980210. http://www.w3.org/TR/1998/REC-xml-19980210.\n\n[HTTP] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-Lee, \n\"Hypertext Transfer Protocol -- HTTP/1.1.\" RFC 2068.  UC Irvine, DEC, \nMIT/LCS.  January, 1997.\n\n[WebDAV] Y. Y. Goland, E. J. Whitehead, Jr., A. Faizi, S. R. Carter, D. \nJensen, \"HTTP Extensions for Distributed Authoring - WebDAV.\" RFC 2518.  \nMicrosoft, U.C. Irvine, Netscape, Novell.  February, 1999.\n\n18.2 Informational References\n\n[DASL] Saveen Reddy, D. Jensen, Surendra Reddy, R. Henderson, J. Davis, \nA. Babich, \"DAV Searching & Locating.\" Draft-reddy-dasl-protocol-03. \nInternet Draft, work in progress. Microsoft, Novell, Oracle, Netscape, \nXerox, Filenet.  November, 1998.\n \n[CollReq] J. Slein, J. Davis, \"Requirements for Advanced Collection \nFunctionality in WebDAV.\" Draft-ietf-webdav-collection-reqts-02. \nInternet Draft, work in progress.  Xerox.  February, 1999.\n\n19 Authors' Addresses\n\nJ. Slein\nXerox Corporation\n800 Phillips Road, 105-50C\nWebster, NY 14580\nEmail: jslein@crt.xerox.com\n\nE. J. Whitehead, Jr.\nDept. of Information and Computer Science\nUniversity of California, Irvine\nIrvine, CA 92697-3425\nEmail: ejw@ics.uci.edu\n\nJ. Davis\nCourseNet Systems\n170 Capp Street\nSan Francisco, CA 94110\nEmail: jrd3@alum.mit.edu\n\nG. Clemm\nRational Software Corporation\n20 Maguire Road\nLexington, MA 02173-3104\nEmail: gclemm@rational.com\n\nC. Fay\nFileNet Corporation\n3565 Harbor Boulevard\nCosta Mesa, CA 92626-1420\nEmail: cfay@filenet.com\n\nJ. Crawford\n\nSlein et al.                                                    Page 51\n\fINTERNET-DRAFT            WebDAV Collections Protocol         June 1999\n\nIBM\nEmail: ccjason@us.ibm.com\n\nT. Chihaya\nDataChannel, Inc.\n155 108th Ave. N.E., Suite 400\nBellevue, WA 98004\nEmail: Tyson@DataChannel.com\n\n20 Appendices\n\n20.1 Appendix 1: Extensions to the WebDAV Document Type Definition\n\n<!--============= XML Elements from Section 8 ================-->\n<!ELEMENT redirectref EMPTY >\n<!ELEMENT segment (#PCDATA)>\n<!ELEMENT unordered EMPTY >\n<!ELEMENT custom EMPTY >\n<!ELEMENT order (ordermember+) >\n<!ELEMENT ordermember (href, position) >\n<!ELEMENT position (first | last | before | after)>\n<!ELEMENT first EMPTY >\n<!ELEMENT last EMPTY >\n<!ELEMENT before href >\n<!ELEMENT after href >\n<!ELEMENT options (refintegrityoptions | orderingoptions)+ >\n<!ELEMENT orderingoptions ( (#PCDATA)+ | EMPTY) >\n<!--============= Property Elements from Section 7 ==================-->\n<!ELEMENT reftarget (#PCDATA)>\n<!ELEMENT location href>\n<!ELEMENT bindings ((href, segment)*)>\n<!ELEMENT orderingtype (arbitrary | custom | href) >\n<!--====== Changes to the DAV:response Element from Section 9 ====-->\n<!ELEMENT response (href, ((href*, status, prop?) | (propstat+)), \nresponsedescription?) >\n\nExpires December 18, 1999\n\nSlein et al.                                                    Page 52\n\f", "encoding": "Windows-1252"}